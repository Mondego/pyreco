__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Philo documentation build configuration file, created by
# sphinx-quickstart on Fri Jan 28 14:04:16 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), "_ext")))
sys.path.append(os.path.abspath(os.path.dirname(os.path.dirname(__file__))))

os.environ['DJANGO_SETTINGS_MODULE'] = 'dummy-settings'

# Import loader so that loader_tags will be correctly added to builtins. Weird import situations... this is necessary for doc build to work.
from django.template import loader

# HACK to override descriptors that would cause AttributeErrors to be raised otherwise (which would keep them from being documented.)
from philo.contrib.sobol.models import SearchView
SearchView.searches = 5
from philo.models.nodes import TargetURLModel, File
TargetURLModel.reversing_parameters = 5
File.file = 5

# -- General configuration -----------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['djangodocs', 'sphinx.ext.autodoc', 'philodocs']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Philo'
copyright = u'2009-2012, iThink Software'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
from philo import VERSION
version = '.'.join([str(v) for v in VERSION])
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# Autodoc config
autodoc_member_order = "bysource"


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Philodoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Philo.tex', u'Philo Documentation',
   u'iThink Software', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output --------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'philo', u'Philo Documentation',
     [u'iThink Software'], 1)
]

def skip_attribute_attrs(app, what, name, obj, skip, options):
	if name in ("attribute_set", "get_attribute_mapper", "nodes"):
		return True
	return skip

def setup(app):
	app.connect('autodoc-skip-member', skip_attribute_attrs)
	#app.connect('autodoc-process-signature', )

########NEW FILE########
__FILENAME__ = dummy-settings
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'db.sl3'
    }
}
########NEW FILE########
__FILENAME__ = djangodocs
"""
Sphinx plugins for Django documentation.
"""
import os
import re

from docutils import nodes, transforms
try:
    import json
except ImportError:
    try:
        import simplejson as json
    except ImportError:
        try:
            from django.utils import simplejson as json
        except ImportError:
            json = None

from sphinx import addnodes, roles
from sphinx.builders.html import StandaloneHTMLBuilder
from sphinx.writers.html import SmartyPantsHTMLTranslator
from sphinx.util.console import bold
from sphinx.util.compat import Directive

# RE for option descriptions without a '--' prefix
simple_option_desc_re = re.compile(
    r'([-_a-zA-Z0-9]+)(\s*.*?)(?=,\s+(?:/|-|--)|$)')

def setup(app):
    app.add_crossref_type(
        directivename = "setting",
        rolename      = "setting",
        indextemplate = "pair: %s; setting",
    )
    #app.add_crossref_type(
    #    directivename = "templatetag",
    #    rolename      = "ttag",
    #    indextemplate = "pair: %s; template tag"
    #)
    #app.add_crossref_type(
    #    directivename = "templatefilter",
    #    rolename      = "tfilter",
    #    indextemplate = "pair: %s; template filter"
    #)
    app.add_crossref_type(
        directivename = "fieldlookup",
        rolename      = "lookup",
        indextemplate = "pair: %s; field lookup type",
    )
    app.add_description_unit(
        directivename = "django-admin",
        rolename      = "djadmin",
        indextemplate = "pair: %s; django-admin command",
        parse_node    = parse_django_admin_node,
    )
    app.add_description_unit(
        directivename = "django-admin-option",
        rolename      = "djadminopt",
        indextemplate = "pair: %s; django-admin command-line option",
        parse_node    = parse_django_adminopt_node,
    )
    app.add_config_value('django_next_version', '0.0', True)
    app.add_directive('versionadded', VersionDirective)
    app.add_directive('versionchanged', VersionDirective)
    app.add_transform(SuppressBlockquotes)
    app.add_builder(DjangoStandaloneHTMLBuilder)


class VersionDirective(Directive):
    has_content = True
    required_arguments = 1
    optional_arguments = 1
    final_argument_whitespace = True
    option_spec = {}

    def run(self):
        env = self.state.document.settings.env
        arg0 = self.arguments[0]
        is_nextversion = env.config.django_next_version == arg0
        ret = []
        node = addnodes.versionmodified()
        ret.append(node)
        if not is_nextversion:
            if len(self.arguments) == 1:
                linktext = 'Please, see the release notes </releases/%s>' % (arg0)
                xrefs = roles.XRefRole()('doc', linktext, linktext, self.lineno, self.state)
                node.extend(xrefs[0])
            node['version'] = arg0
        else:
            node['version'] = "Development version"
        node['type'] = self.name
        if len(self.arguments) == 2:
            inodes, messages = self.state.inline_text(self.arguments[1], self.lineno+1)
            node.extend(inodes)
            if self.content:
                self.state.nested_parse(self.content, self.content_offset, node)
            ret = ret + messages
        env.note_versionchange(node['type'], node['version'], node, self.lineno)
        return ret


class SuppressBlockquotes(transforms.Transform):
    """
    Remove the default blockquotes that encase indented list, tables, etc.
    """
    default_priority = 300

    suppress_blockquote_child_nodes = (
        nodes.bullet_list,
        nodes.enumerated_list,
        nodes.definition_list,
        nodes.literal_block,
        nodes.doctest_block,
        nodes.line_block,
        nodes.table
    )

    def apply(self):
        for node in self.document.traverse(nodes.block_quote):
            if len(node.children) == 1 and isinstance(node.children[0], self.suppress_blockquote_child_nodes):
                node.replace_self(node.children[0])

class DjangoHTMLTranslator(SmartyPantsHTMLTranslator):
    """
    Django-specific reST to HTML tweaks.
    """

    # Don't use border=1, which docutils does by default.
    def visit_table(self, node):
        self.body.append(self.starttag(node, 'table', CLASS='docutils'))

    # <big>? Really?
    def visit_desc_parameterlist(self, node):
        self.body.append('(')
        self.first_param = 1

    def depart_desc_parameterlist(self, node):
        self.body.append(')')

    #
    # Don't apply smartypants to literal blocks
    #
    def visit_literal_block(self, node):
        self.no_smarty += 1
        SmartyPantsHTMLTranslator.visit_literal_block(self, node)

    def depart_literal_block(self, node):
        SmartyPantsHTMLTranslator.depart_literal_block(self, node)
        self.no_smarty -= 1

    #
    # Turn the "new in version" stuff (versionadded/versionchanged) into a
    # better callout -- the Sphinx default is just a little span,
    # which is a bit less obvious that I'd like.
    #
    # FIXME: these messages are all hardcoded in English. We need to change
    # that to accomodate other language docs, but I can't work out how to make
    # that work.
    #
    version_text = {
        'deprecated':       'Deprecated in Django %s',
        'versionchanged':   'Changed in Django %s',
        'versionadded':     'New in Django %s',
    }

    def visit_versionmodified(self, node):
        self.body.append(
            self.starttag(node, 'div', CLASS=node['type'])
        )
        title = "%s%s" % (
            self.version_text[node['type']] % node['version'],
            len(node) and ":" or "."
        )
        self.body.append('<span class="title">%s</span> ' % title)

    def depart_versionmodified(self, node):
        self.body.append("</div>\n")

    # Give each section a unique ID -- nice for custom CSS hooks
    def visit_section(self, node):
        old_ids = node.get('ids', [])
        node['ids'] = ['s-' + i for i in old_ids]
        node['ids'].extend(old_ids)
        SmartyPantsHTMLTranslator.visit_section(self, node)
        node['ids'] = old_ids

def parse_django_admin_node(env, sig, signode):
    command = sig.split(' ')[0]
    env._django_curr_admin_command = command
    title = "django-admin.py %s" % sig
    signode += addnodes.desc_name(title, title)
    return sig

def parse_django_adminopt_node(env, sig, signode):
    """A copy of sphinx.directives.CmdoptionDesc.parse_signature()"""
    from sphinx.domains.std import option_desc_re
    count = 0
    firstname = ''
    for m in option_desc_re.finditer(sig):
        optname, args = m.groups()
        if count:
            signode += addnodes.desc_addname(', ', ', ')
        signode += addnodes.desc_name(optname, optname)
        signode += addnodes.desc_addname(args, args)
        if not count:
            firstname = optname
        count += 1
    if not count:
        for m in simple_option_desc_re.finditer(sig):
            optname, args = m.groups()
            if count:
                signode += addnodes.desc_addname(', ', ', ')
            signode += addnodes.desc_name(optname, optname)
            signode += addnodes.desc_addname(args, args)
            if not count:
                firstname = optname
            count += 1
    if not firstname:
        raise ValueError
    return firstname


class DjangoStandaloneHTMLBuilder(StandaloneHTMLBuilder):
    """
    Subclass to add some extra things we need.
    """

    name = 'djangohtml'

    def finish(self):
        super(DjangoStandaloneHTMLBuilder, self).finish()
        if json is None:
            self.warn("cannot create templatebuiltins.js due to missing simplejson dependency")
            return
        self.info(bold("writing templatebuiltins.js..."))
        xrefs = self.env.domaindata["std"]["objects"]
        templatebuiltins = {
            "ttags": [n for ((t, n), (l, a)) in xrefs.items()
                        if t == "templatetag" and l == "ref/templates/builtins"],
            "tfilters": [n for ((t, n), (l, a)) in xrefs.items()
                        if t == "templatefilter" and l == "ref/templates/builtins"],
        }
        outfilename = os.path.join(self.outdir, "templatebuiltins.js")
        f = open(outfilename, 'wb')
        f.write('var django_template_builtins = ')
        json.dump(templatebuiltins, f)
        f.write(';\n')
        f.close();

########NEW FILE########
__FILENAME__ = philodocs
import inspect

from sphinx.addnodes import desc_addname
from sphinx.domains.python import PyModulelevel, PyXRefRole
from sphinx.ext import autodoc


DOMAIN = 'py'


class TemplateTag(PyModulelevel):
	indextemplate = "pair: %s; template tag"
	
	def get_signature_prefix(self, sig):
		return self.objtype + ' '
	
	def handle_signature(self, sig, signode):
		fullname, name_prefix = PyModulelevel.handle_signature(self, sig, signode)
		
		for i, node in enumerate(signode):
			if isinstance(node, desc_addname):
				lib = '.'.join(node[0].split('.')[-2:])
				new_node = desc_addname(lib, lib)
				signode[i] = new_node
		
		return fullname, name_prefix


class TemplateTagDocumenter(autodoc.FunctionDocumenter):
	objtype = 'templatetag'
	domain = DOMAIN
	
	@classmethod
	def can_document_member(cls, member, membername, isattr, parent):
		# Only document explicitly.
		return False
	
	def format_args(self):
		return None

class TemplateFilterDocumenter(autodoc.FunctionDocumenter):
	objtype = 'templatefilter'
	domain = DOMAIN
	
	@classmethod
	def can_document_member(cls, member, membername, isattr, parent):
		# Only document explicitly.
		return False

def setup(app):
	app.add_directive_to_domain(DOMAIN, 'templatetag', TemplateTag)
	app.add_role_to_domain(DOMAIN, 'ttag', PyXRefRole())
	app.add_directive_to_domain(DOMAIN, 'templatefilter', TemplateTag)
	app.add_role_to_domain(DOMAIN, 'tfilter', PyXRefRole())
	app.add_autodocumenter(TemplateTagDocumenter)
	app.add_autodocumenter(TemplateFilterDocumenter)
########NEW FILE########
__FILENAME__ = base
from django.conf import settings
from django.contrib import admin
from django.contrib.contenttypes import generic
from django.http import HttpResponse
from django.utils import simplejson as json
from django.utils.html import escape
from mptt.admin import MPTTModelAdmin

from philo.models import Attribute
from philo.models.fields.entities import ForeignKeyAttribute, ManyToManyAttribute
from philo.admin.forms.attributes import AttributeForm, AttributeInlineFormSet
from philo.forms.entities import EntityForm, proxy_fields_for_entity_model


COLLAPSE_CLASSES = ('collapse', 'collapse-closed', 'closed',)


class AttributeInline(generic.GenericTabularInline):
	ct_field = 'entity_content_type'
	ct_fk_field = 'entity_object_id'
	model = Attribute
	extra = 1
	allow_add = True
	classes = COLLAPSE_CLASSES
	form = AttributeForm
	formset = AttributeInlineFormSet
	fields = ['key', 'value_content_type']
	if 'grappelli' in settings.INSTALLED_APPS:
		template = 'admin/philo/edit_inline/grappelli_tabular_attribute.html'
	else:
		template = 'admin/philo/edit_inline/tabular_attribute.html'


# HACK to bypass model validation for proxy fields
class SpoofedHiddenFields(object):
	def __init__(self, proxy_fields, value):
		self.value = value
		self.spoofed = list(set(value) - set(proxy_fields))
	
	def __get__(self, instance, owner):
		if instance is None:
			return self.spoofed
		return self.value


class SpoofedAddedFields(SpoofedHiddenFields):
	def __init__(self, proxy_fields, value):
		self.value = value
		self.spoofed = list(set(value) | set(proxy_fields))


def hide_proxy_fields(cls, attname):
	val = getattr(cls, attname, [])
	proxy_fields = getattr(cls, 'proxy_fields')
	if val:
		setattr(cls, attname, SpoofedHiddenFields(proxy_fields, val))

def add_proxy_fields(cls, attname):
	val = getattr(cls, attname, [])
	proxy_fields = getattr(cls, 'proxy_fields')
	setattr(cls, attname, SpoofedAddedFields(proxy_fields, val))


class EntityAdminMetaclass(admin.ModelAdmin.__metaclass__):
	def __new__(cls, name, bases, attrs):
		new_class = super(EntityAdminMetaclass, cls).__new__(cls, name, bases, attrs)
		hide_proxy_fields(new_class, 'raw_id_fields')
		add_proxy_fields(new_class, 'readonly_fields')
		return new_class
# END HACK

class EntityAdmin(admin.ModelAdmin):
	__metaclass__ = EntityAdminMetaclass
	form = EntityForm
	inlines = [AttributeInline]
	save_on_top = True
	proxy_fields = []
	
	def formfield_for_dbfield(self, db_field, **kwargs):
		"""
		Override the default behavior to provide special formfields for EntityEntitys.
		Essentially clones the ForeignKey/ManyToManyField special behavior for the Attribute versions.
		"""
		if not db_field.choices and isinstance(db_field, (ForeignKeyAttribute, ManyToManyAttribute)):
			request = kwargs.pop("request", None)
			# Combine the field kwargs with any options for formfield_overrides.
			# Make sure the passed in **kwargs override anything in
			# formfield_overrides because **kwargs is more specific, and should
			# always win.
			if db_field.__class__ in self.formfield_overrides:
				kwargs = dict(self.formfield_overrides[db_field.__class__], **kwargs)
			
			# Get the correct formfield.
			if isinstance(db_field, ManyToManyAttribute):
				formfield = self.formfield_for_manytomanyattribute(db_field, request, **kwargs)
			elif isinstance(db_field, ForeignKeyAttribute):
				formfield = self.formfield_for_foreignkeyattribute(db_field, request, **kwargs)
			
			# For non-raw_id fields, wrap the widget with a wrapper that adds
			# extra HTML -- the "add other" interface -- to the end of the
			# rendered output. formfield can be None if it came from a
			# OneToOneField with parent_link=True or a M2M intermediary.
			# TODO: Implement this.
			#if formfield and db_field.name not in self.raw_id_fields:
			#	formfield.widget = admin.widgets.RelatedFieldWidgetWrapper(formfield.widget, db_field, self.admin_site)
			
			return formfield
		return super(EntityAdmin, self).formfield_for_dbfield(db_field, **kwargs)
	
	def formfield_for_foreignkeyattribute(self, db_field, request=None, **kwargs):
		"""Get a form field for a ForeignKeyAttribute field."""
		db = kwargs.get('using')
		if db_field.name in self.raw_id_fields:
			kwargs['widget'] = admin.widgets.ForeignKeyRawIdWidget(db_field, db)
		#TODO: Add support for radio fields
		#elif db_field.name in self.radio_fields:
		#	kwargs['widget'] = widgets.AdminRadioSelect(attrs={
		#		'class': get_ul_class(self.radio_fields[db_field.name]),
		#	})
		#	kwargs['empty_label'] = db_field.blank and _('None') or None
		
		return db_field.formfield(**kwargs)
	
	def formfield_for_manytomanyattribute(self, db_field, request=None, **kwargs):
		"""Get a form field for a ManyToManyAttribute field."""
		db = kwargs.get('using')
		
		if db_field.name in self.raw_id_fields:
			kwargs['widget'] = admin.widgets.ManyToManyRawIdWidget(db_field, using=db)
			kwargs['help_text'] = ''
		#TODO: Add support for filtered fields.
		#elif db_field.name in (list(self.filter_vertical) + list(self.filter_horizontal)):
		#	kwargs['widget'] = widgets.FilteredSelectMultiple(db_field.verbose_name, (db_field.name in self.filter_vertical))
		
		return db_field.formfield(**kwargs)


class TreeEntityAdmin(EntityAdmin, MPTTModelAdmin):
	pass
########NEW FILE########
__FILENAME__ = collections
from django.contrib import admin

from philo.admin.base import COLLAPSE_CLASSES
from philo.models import CollectionMember, Collection


class CollectionMemberInline(admin.TabularInline):
	fk_name = 'collection'
	model = CollectionMember
	extra = 1
	classes = COLLAPSE_CLASSES
	allow_add = True
	fields = ('member_content_type', 'member_object_id', 'index')
	sortable_field_name = 'index'


class CollectionAdmin(admin.ModelAdmin):
	inlines = [CollectionMemberInline]
	list_display = ('name', 'description', 'get_count')


admin.site.register(Collection, CollectionAdmin)
########NEW FILE########
__FILENAME__ = attributes
from django.contrib.contenttypes.generic import BaseGenericInlineFormSet
from django.contrib.contenttypes.models import ContentType
from django.forms.models import ModelForm

from philo.models import Attribute


__all__ = ('AttributeForm', 'AttributeInlineFormSet')


class AttributeForm(ModelForm):
	"""
	This class handles an attribute's fields as well as the fields for its value (if there is one.)
	The fields defined will vary depending on the value type, but the fields for defining the value
	(i.e. value_content_type and value_object_id) will always be defined. Except that value_object_id
	will never be defined. BLARGH!
	"""
	def __init__(self, *args, **kwargs):
		super(AttributeForm, self).__init__(*args, **kwargs)
		
		# This is necessary because model forms store changes to self.instance in their clean method.
		# Mutter mutter.
		value = self.instance.value
		self._cached_value_ct_id = self.instance.value_content_type_id
		self._cached_value = value
		
		# If there is a value, pull in its fields.
		if value is not None:
			self.value_fields = value.value_formfields()
			self.fields.update(self.value_fields)
	
	def save(self, *args, **kwargs):
		# At this point, the cleaned_data has already been stored on self.instance.
		
		if self.instance.value_content_type_id != self._cached_value_ct_id:
			# The value content type has changed. Clear the old value, if there was one.
			if self._cached_value:
				self._cached_value.delete()
			
			# Clear the submitted value, if any.
			self.cleaned_data.pop('value', None)
			
			# Now create a new value instance so that on next instantiation, the form will
			# know what fields to add.
			if self.instance.value_content_type_id is not None:
				self.instance.value = ContentType.objects.get_for_id(self.instance.value_content_type_id).model_class().objects.create()
		elif self.instance.value is not None:
			# The value content type is the same, but one of the value fields has changed.
			
			# Use construct_instance to apply the changes from the cleaned_data to the value instance.
			fields = self.value_fields.keys()
			if set(fields) & set(self.changed_data):
				self.instance.value.construct_instance(**dict([(key, self.cleaned_data[key]) for key in fields]))
				self.instance.value.save()
		
		return super(AttributeForm, self).save(*args, **kwargs)
	
	class Meta:
		model = Attribute


class AttributeInlineFormSet(BaseGenericInlineFormSet):
	"Necessary to force the GenericInlineFormset to use the form's save method for new objects."
	def save_new(self, form, commit):
		setattr(form.instance, self.ct_field.get_attname(), ContentType.objects.get_for_model(self.instance).pk)
		setattr(form.instance, self.ct_fk_field.get_attname(), self.instance.pk)
		return form.save()
########NEW FILE########
__FILENAME__ = containers
from django import forms
from django.core.exceptions import ObjectDoesNotExist
from django.db.models import Q
from django.forms.models import ModelForm, BaseInlineFormSet, BaseModelFormSet
from django.forms.formsets import TOTAL_FORM_COUNT
from django.utils.datastructures import SortedDict

from philo.admin.widgets import ModelLookupWidget, EmbedWidget
from philo.models import Contentlet, ContentReference


__all__ = (
	'ContentletForm',
	'ContentletInlineFormSet',
	'ContentReferenceForm',
	'ContentReferenceInlineFormSet'
)


class ContainerForm(ModelForm):
	def __init__(self, *args, **kwargs):
		super(ContainerForm, self).__init__(*args, **kwargs)
		self.verbose_name = self.instance.name.replace('_', ' ')
		self.prefix = self.instance.name


class ContentletForm(ContainerForm):
	content = forms.CharField(required=False, widget=EmbedWidget, label='Content')
	
	def should_delete(self):
		# Delete iff: the data has changed and is now empty.
		return self.has_changed() and not bool(self.cleaned_data['content'])
	
	class Meta:
		model = Contentlet
		fields = ['content']


class ContentReferenceForm(ContainerForm):
	def __init__(self, *args, **kwargs):
		super(ContentReferenceForm, self).__init__(*args, **kwargs)
		try:
			self.fields['content_id'].widget = ModelLookupWidget(self.instance.content_type)
		except ObjectDoesNotExist:
			# This will happen when an empty form (which we will never use) gets instantiated.
			pass
	
	def should_delete(self):
		return self.has_changed() and (self.cleaned_data['content_id'] is None)
	
	class Meta:
		model = ContentReference
		fields = ['content_id']


class ContainerInlineFormSet(BaseInlineFormSet):
	@property
	def containers(self):
		if not hasattr(self, '_containers'):
			self._containers = self.get_containers()
		return self._containers
	
	def total_form_count(self):
		# This ignores the posted management form data... but that doesn't
		# seem to have any ill side effects.
		return len(self.containers.keys())
	
	def _get_initial_forms(self):
		return [form for form in self.forms if form.instance.pk is not None]
	initial_forms = property(_get_initial_forms)
	
	def _get_extra_forms(self):
		return [form for form in self.forms if form.instance.pk is None]
	extra_forms = property(_get_extra_forms)
	
	def _construct_form(self, i, **kwargs):
		if 'instance' not in kwargs:
			kwargs['instance'] = self.containers.values()[i]
		
		# Skip over the BaseModelFormSet. We have our own way of doing things!
		form = super(BaseModelFormSet, self)._construct_form(i, **kwargs)
		
		# Since we skipped over BaseModelFormSet, we need to duplicate what BaseInlineFormSet would do.
		if self.save_as_new:
			# Remove the primary key from the form's data, we are only
			# creating new instances
			form.data[form.add_prefix(self._pk_field.name)] = None
			
			# Remove the foreign key from the form's data
			form.data[form.add_prefix(self.fk.name)] = None
		
		# Set the fk value here so that the form can do it's validation.
		setattr(form.instance, self.fk.get_attname(), self.instance.pk)
		return form
	
	def add_fields(self, form, index):
		"""Override the pk field's initial value with a real one."""
		super(ContainerInlineFormSet, self).add_fields(form, index)
		if index is not None:
			pk_value = self.containers.values()[index].pk
		else:
			pk_value = None
		form.fields[self._pk_field.name].initial = pk_value
	
	def save_existing_objects(self, commit=True):
		self.changed_objects = []
		self.deleted_objects = []
		if not self.get_queryset():
			return []
		
		saved_instances = []
		for form in self.initial_forms:
			pk_name = self._pk_field.name
			raw_pk_value = form._raw_value(pk_name)
			
			# clean() for different types of PK fields can sometimes return
			# the model instance, and sometimes the PK. Handle either.
			pk_value = form.fields[pk_name].clean(raw_pk_value)
			pk_value = getattr(pk_value, 'pk', pk_value)
			
			# if the pk_value is None, they have just switched to a
			# template which didn't contain data about this container.
			# Skip!
			if pk_value is not None:
				obj = self._existing_object(pk_value)
				if form.should_delete():
					self.deleted_objects.append(obj)
					obj.delete()
					continue
				if form.has_changed():
					self.changed_objects.append((obj, form.changed_data))
					saved_instances.append(self.save_existing(form, obj, commit=commit))
					if not commit:
						self.saved_forms.append(form)
		return saved_instances

	def save_new_objects(self, commit=True):
		self.new_objects = []
		for form in self.extra_forms:
			if not form.has_changed():
				continue
			# If someone has marked an add form for deletion, don't save the
			# object.
			if form.should_delete():
				continue
			self.new_objects.append(self.save_new(form, commit=commit))
			if not commit:
				self.saved_forms.append(form)
		return self.new_objects


class ContentletInlineFormSet(ContainerInlineFormSet):
	def get_containers(self):
		try:
			containers = self.instance.containers[0]
		except ObjectDoesNotExist:
			containers = []
		
		qs = self.get_queryset().filter(name__in=containers)
		container_dict = SortedDict([(container.name, container) for container in qs])
		for name in containers:
			if name not in container_dict:
				container_dict[name] = self.model(name=name)
		
		container_dict.keyOrder = containers
		return container_dict


class ContentReferenceInlineFormSet(ContainerInlineFormSet):
	def get_containers(self):
		try:
			containers = self.instance.containers[1]
		except ObjectDoesNotExist:
			containers = {}
		
		filter = Q()
		for name, ct in containers.items():
			filter |= Q(name=name, content_type=ct)
		qs = self.get_queryset().filter(filter)
		
		container_dict = SortedDict([(container.name, container) for container in qs])
		
		keyOrder = []
		for name, ct in containers.items():
			keyOrder.append(name)
			if name not in container_dict:
				container_dict[name] = self.model(name=name, content_type=ct)
		
		container_dict.keyOrder = keyOrder
		return container_dict
########NEW FILE########
__FILENAME__ = nodes
from django.contrib import admin
from mptt.admin import MPTTModelAdmin

from philo.admin.base import EntityAdmin, TreeEntityAdmin, COLLAPSE_CLASSES
from philo.models import Node, Redirect, File


class NodeAdmin(TreeEntityAdmin):
	list_display = ('slug', 'view', 'accepts_subpath')
	raw_id_fields = ('parent',)
	related_lookup_fields = {
		'fk': raw_id_fields,
		'm2m': [],
		'generic': [['view_content_type', 'view_object_id']]
	}
	
	def accepts_subpath(self, obj):
		return obj.accepts_subpath
	accepts_subpath.boolean = True
	
	def formfield_for_foreignkey(self, db_field, request, **kwargs):
		return super(MPTTModelAdmin, self).formfield_for_foreignkey(db_field, request, **kwargs)


class ViewAdmin(EntityAdmin):
	pass


class RedirectAdmin(ViewAdmin):
	fieldsets = (
		(None, {
			'fields': ('target_node', 'url_or_subpath', 'status_code')
		}),
		('Advanced', {
			'fields': ('reversing_parameters',),
			'classes': COLLAPSE_CLASSES
		})
	)
	list_display = ('target_url', 'status_code', 'target_node', 'url_or_subpath')
	list_filter = ('status_code',)
	raw_id_fields = ['target_node']
	related_lookup_fields = {
		'fk': raw_id_fields
	}


class FileAdmin(ViewAdmin):
	fieldsets = (
		(None, {
			'fields': ('name', 'file', 'mimetype')
		}),
	)
	list_display = ('name', 'mimetype', 'file')
	search_fields = ('name',)
	list_filter = ('mimetype',)


admin.site.register(Node, NodeAdmin)
admin.site.register(Redirect, RedirectAdmin)
admin.site.register(File, FileAdmin)
########NEW FILE########
__FILENAME__ = pages
from django import forms
from django.conf import settings
from django.contrib import admin

from philo.admin.base import COLLAPSE_CLASSES, TreeEntityAdmin
from philo.admin.forms.containers import *
from philo.admin.nodes import ViewAdmin
from philo.admin.widgets import EmbedWidget
from philo.models.fields import TemplateField
from philo.models.pages import Page, Template, Contentlet, ContentReference


class ContainerInline(admin.StackedInline):
	extra = 0
	max_num = 0
	can_delete = False
	classes = ('collapse-open', 'collapse','open')
	if 'grappelli' in settings.INSTALLED_APPS:
		template = 'admin/philo/edit_inline/grappelli_tabular_container.html'
	else:
		template = 'admin/philo/edit_inline/tabular_container.html'


class ContentletInline(ContainerInline):
	model = Contentlet
	formset = ContentletInlineFormSet
	form = ContentletForm


class ContentReferenceInline(ContainerInline):
	model = ContentReference
	formset = ContentReferenceInlineFormSet
	form = ContentReferenceForm


class PageAdmin(ViewAdmin):
	add_form_template = 'admin/philo/page/add_form.html'
	fieldsets = (
		(None, {
			'fields': ('title', 'template')
		}),
	)
	list_display = ('title', 'template')
	list_filter = ('template',)
	search_fields = ['title', 'contentlets__content']
	inlines = [ContentletInline, ContentReferenceInline] + ViewAdmin.inlines
	
	def response_add(self, request, obj, post_url_continue='../%s/'):
		# Shamelessly cribbed from django/contrib/auth/admin.py:143
		if '_addanother' not in request.POST and '_popup' not in request.POST:
			request.POST['_continue'] = 1
		return super(PageAdmin, self).response_add(request, obj, post_url_continue)


class TemplateAdmin(TreeEntityAdmin):
	prepopulated_fields = {'slug': ('name',)}
	fieldsets = (
		(None, {
			'fields': ('parent', 'name', 'slug')
		}),
		('Documentation', {
			'classes': COLLAPSE_CLASSES,
			'fields': ('documentation',)
		}),
		(None, {
			'fields': ('code',)
		}),
		('Advanced', {
			'classes': COLLAPSE_CLASSES,
			'fields': ('mimetype',)
		}),
	)
	formfield_overrides = {
		TemplateField: {'widget': EmbedWidget}
	}
	save_on_top = True
	save_as = True
	list_display = ('__unicode__', 'slug', 'get_path',)


admin.site.register(Page, PageAdmin)
admin.site.register(Template, TemplateAdmin)
########NEW FILE########
__FILENAME__ = widgets
from django import forms
from django.conf import settings
from django.contrib.admin.widgets import url_params_from_lookup_dict
from django.utils import simplejson as json
from django.utils.html import escape
from django.utils.safestring import mark_safe
from django.utils.text import truncate_words
from django.utils.translation import ugettext as _


class ModelLookupWidget(forms.TextInput):
	# is_hidden = False
	
	def __init__(self, content_type, attrs=None, limit_choices_to=None):
		self.content_type = content_type
		self.limit_choices_to = limit_choices_to
		super(ModelLookupWidget, self).__init__(attrs)
	
	def render(self, name, value, attrs=None):
		related_url = '../../../%s/%s/' % (self.content_type.app_label, self.content_type.model)
		params = url_params_from_lookup_dict(self.limit_choices_to)
		if params:
			url = u'?' + u'&amp;'.join([u'%s=%s' % (k, v) for k, v in params.items()])
		else:
			url = u''
		if attrs is None:
			attrs = {}
		if "class" not in attrs:
			attrs['class'] = 'vForeignKeyRawIdAdminField'
		output = [super(ModelLookupWidget, self).render(name, value, attrs)]
		output.append('<a href="%s%s" class="related-lookup" id="lookup_id_%s" onclick="return showRelatedObjectLookupPopup(this);">' % (related_url, url, name))
		output.append('<img src="%simg/admin/selector-search.gif" width="16" height="16" alt="%s" />' % (settings.ADMIN_MEDIA_PREFIX, _('Lookup')))
		output.append('</a>')
		if value:
			value_class = self.content_type.model_class()
			try:
				value_object = value_class.objects.get(pk=value)
				output.append('&nbsp;<strong>%s</strong>' % escape(truncate_words(value_object, 14)))
			except value_class.DoesNotExist:
				pass
		return mark_safe(u''.join(output))


class EmbedWidget(forms.Textarea):
	"""A form widget with the HTML class embedding and an embedded list of content-types."""
	def __init__(self, attrs=None):
		from philo.models import value_content_type_limiter
		
		content_types = value_content_type_limiter.classes
		data = []
		
		for content_type in content_types:
			data.append({'app_label': content_type._meta.app_label, 'object_name': content_type._meta.object_name.lower(), 'verbose_name': unicode(content_type._meta.verbose_name)})
		
		json_ = json.dumps(data)
		
		default_attrs = {'class': 'embedding vLargeTextField', 'data-content-types': json_ }
		
		if attrs:
			default_attrs.update(attrs)
			
		super(EmbedWidget, self).__init__(default_attrs)
		
	class Media:
		css = {
			'all': ('philo/css/EmbedWidget.css',),
		}
		js = ('philo/js/EmbedWidget.js',)

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from philo.admin import EntityAdmin, COLLAPSE_CLASSES
from philo.contrib.julian.models import Location, Event, Calendar, CalendarView


class LocationAdmin(EntityAdmin):
	pass


class EventAdmin(EntityAdmin):
	fieldsets = (
		(None, {
			'fields': ('name', 'slug', 'description', 'tags', 'owner')
		}),
		('Location', {
			'fields': ('location_content_type', 'location_pk')
		}),
		('Time', {
			'fields': (('start_date', 'start_time'), ('end_date', 'end_time'),),
		}),
		('Advanced', {
			'fields': ('parent_event', 'site',),
			'classes': COLLAPSE_CLASSES
		})
	)
	filter_horizontal = ['tags']
	raw_id_fields = ['parent_event']
	related_lookup_fields = {
		'fk': raw_id_fields,
		'generic': [["location_content_type", "location_pk"]]
	}
	prepopulated_fields = {'slug': ('name',)}


class CalendarAdmin(EntityAdmin):
	prepopulated_fields = {'slug': ('name',)}
	filter_horizontal = ['events']
	fieldsets = (
		(None, {
			'fields': ('name', 'description', 'events')
		}),
		('Advanced', {
			'fields': ('slug', 'site', 'language',),
			'classes': COLLAPSE_CLASSES
		})
	)


class CalendarViewAdmin(EntityAdmin):
	fieldsets = (
		(None, {
			'fields': ('calendar',)
		}),
		('Pages', {
			'fields': ('index_page', 'event_detail_page')
		}),
		('General Settings', {
			'fields': ('tag_permalink_base', 'owner_permalink_base', 'location_permalink_base', 'events_per_page')
		}),
		('Event List Pages', {
			'fields': ('timespan_page', 'tag_page', 'location_page', 'owner_page'),
			'classes': COLLAPSE_CLASSES
		}),
		('Archive Pages', {
			'fields': ('location_archive_page', 'tag_archive_page', 'owner_archive_page'),
			'classes': COLLAPSE_CLASSES
		}),
		('Feed Settings', {
			'fields': ( 'feeds_enabled', 'feed_suffix', 'feed_type', 'item_title_template', 'item_description_template',),
			'classes': COLLAPSE_CLASSES
		})
	)
	raw_id_fields = ('index_page', 'event_detail_page', 'timespan_page', 'tag_page', 'location_page', 'owner_page', 'location_archive_page', 'tag_archive_page', 'owner_archive_page', 'item_title_template', 'item_description_template',)
	related_lookup_fields = {'fk': raw_id_fields}


admin.site.register(Location, LocationAdmin)
admin.site.register(Event, EventAdmin)
admin.site.register(Calendar, CalendarAdmin)
admin.site.register(CalendarView, CalendarViewAdmin)
########NEW FILE########
__FILENAME__ = feedgenerator
from django.http import HttpResponse
from django.utils.feedgenerator import SyndicationFeed
import vobject


# Map the keys in the ICalendarFeed internal dictionary to the names of iCalendar attributes.
FEED_ICAL_MAP = {
	'title': 'x-wr-calname',
	'description': 'x-wr-caldesc',
	#'link': ???,
	#'language': ???,
	#author_email
	#author_name
	#author_link
	#subtitle
	#categories
	#feed_url
	#feed_copyright
	'id': 'prodid',
	'ttl': 'x-published-ttl'
}


ITEM_ICAL_MAP = {
	'title': 'summary',
	'description': 'description',
	'link': 'url',
	# author_email, author_name, and author_link need special handling. Consider them the
	# 'organizer' of the event <http://tools.ietf.org/html/rfc5545#section-3.8.4.3> and
	# construct something based on that.
	'pubdate': 'created',
	'last_modified': 'last-modified',
	#'comments' require special handling as well <http://tools.ietf.org/html/rfc5545#section-3.8.1.4>
	'unique_id': 'uid',
	'enclosure': 'attach', # does this need special handling?
	'categories': 'categories', # does this need special handling?
	# ttl is ignored.
	'start': 'dtstart',
	'end': 'dtend',
}


class ICalendarFeed(SyndicationFeed):
	mime_type = 'text/calendar'
	
	def add_item(self, *args, **kwargs):
		for kwarg in ['start', 'end', 'last_modified', 'location']:
			kwargs.setdefault(kwarg, None)
		super(ICalendarFeed, self).add_item(*args, **kwargs)
	
	def write(self, outfile, encoding):
		# TODO: Use encoding... how? Just convert all values when setting them should work...
		cal = vobject.iCalendar()
		
		# IE/Outlook needs this. See
		# <http://blog.thescoop.org/archives/2007/07/31/django-ical-and-vobject/>
		cal.add('method').value = 'PUBLISH'
		
		for key, val in self.feed.items():
			if key in FEED_ICAL_MAP and val:
				cal.add(FEED_ICAL_MAP[key]).value = val
		
		for item in self.items:
			# TODO: handle multiple types of events.
			event = cal.add('vevent')
			for key, val in item.items():
				#TODO: handle the non-standard items like comments and author.
				if key in ITEM_ICAL_MAP and val:
					event.add(ITEM_ICAL_MAP[key]).value = val
		
		cal.serialize(outfile)
		
		# Some special handling for HttpResponses. See link above.
		if isinstance(outfile, HttpResponse):
			filename = self.feed.get('filename', 'filename.ics')
			outfile['Filename'] = filename
			outfile['Content-Disposition'] = 'attachment; filename=%s' % filename
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Location'
        db.create_table('julian_location', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=255, db_index=True)),
        ))
        db.send_create_signal('julian', ['Location'])

        # Adding model 'Event'
        db.create_table('julian_event', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('start_date', self.gf('django.db.models.fields.DateField')()),
            ('start_time', self.gf('django.db.models.fields.TimeField')(null=True, blank=True)),
            ('end_date', self.gf('django.db.models.fields.DateField')()),
            ('end_time', self.gf('django.db.models.fields.TimeField')(null=True, blank=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('location_content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'], null=True, blank=True)),
            ('location_pk', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('description', self.gf('philo.models.fields.TemplateField')()),
            ('parent_event', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['julian.Event'], null=True, blank=True)),
            ('owner', self.gf('django.db.models.fields.related.ForeignKey')(related_name='owned_events', to=orm['auth.User'])),
            ('created', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('last_modified', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('site', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sites.Site'])),
        ))
        db.send_create_signal('julian', ['Event'])

        # Adding unique constraint on 'Event', fields ['site', 'created']
        db.create_unique('julian_event', ['site_id', 'created'])

        # Adding M2M table for field tags on 'Event'
        db.create_table('julian_event_tags', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('event', models.ForeignKey(orm['julian.event'], null=False)),
            ('tag', models.ForeignKey(orm['philo.tag'], null=False))
        ))
        db.create_unique('julian_event_tags', ['event_id', 'tag_id'])

        # Adding model 'Calendar'
        db.create_table('julian_calendar', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=100)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=100, db_index=True)),
            ('description', self.gf('django.db.models.fields.TextField')(blank=True)),
            ('site', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sites.Site'])),
            ('language', self.gf('django.db.models.fields.CharField')(default='en', max_length=5)),
        ))
        db.send_create_signal('julian', ['Calendar'])

        # Adding unique constraint on 'Calendar', fields ['name', 'site', 'language']
        db.create_unique('julian_calendar', ['name', 'site_id', 'language'])

        # Adding M2M table for field events on 'Calendar'
        db.create_table('julian_calendar_events', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('calendar', models.ForeignKey(orm['julian.calendar'], null=False)),
            ('event', models.ForeignKey(orm['julian.event'], null=False))
        ))
        db.create_unique('julian_calendar_events', ['calendar_id', 'event_id'])

        # Adding model 'CalendarView'
        db.create_table('julian_calendarview', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('feed_type', self.gf('django.db.models.fields.CharField')(default='text/calendar', max_length=50)),
            ('feed_suffix', self.gf('django.db.models.fields.CharField')(default='feed', max_length=255)),
            ('feeds_enabled', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('feed_length', self.gf('django.db.models.fields.PositiveIntegerField')(default=15, null=True, blank=True)),
            ('item_title_template', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='julian_calendarview_title_related', null=True, to=orm['philo.Template'])),
            ('item_description_template', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='julian_calendarview_description_related', null=True, to=orm['philo.Template'])),
            ('calendar', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['julian.Calendar'])),
            ('index_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='calendar_index_related', to=orm['philo.Page'])),
            ('event_detail_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='calendar_detail_related', to=orm['philo.Page'])),
            ('timespan_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='calendar_timespan_related', null=True, to=orm['philo.Page'])),
            ('tag_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='calendar_tag_related', null=True, to=orm['philo.Page'])),
            ('location_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='calendar_location_related', null=True, to=orm['philo.Page'])),
            ('owner_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='calendar_owner_related', null=True, to=orm['philo.Page'])),
            ('tag_archive_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='calendar_tag_archive_related', null=True, to=orm['philo.Page'])),
            ('location_archive_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='calendar_location_archive_related', null=True, to=orm['philo.Page'])),
            ('owner_archive_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='calendar_owner_archive_related', null=True, to=orm['philo.Page'])),
            ('tag_permalink_base', self.gf('django.db.models.fields.CharField')(default='tags', max_length=30)),
            ('owner_permalink_base', self.gf('django.db.models.fields.CharField')(default='owners', max_length=30)),
            ('location_permalink_base', self.gf('django.db.models.fields.CharField')(default='locations', max_length=30)),
            ('events_per_page', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
        ))
        db.send_create_signal('julian', ['CalendarView'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Calendar', fields ['name', 'site', 'language']
        db.delete_unique('julian_calendar', ['name', 'site_id', 'language'])

        # Removing unique constraint on 'Event', fields ['site', 'created']
        db.delete_unique('julian_event', ['site_id', 'created'])

        # Deleting model 'Location'
        db.delete_table('julian_location')

        # Deleting model 'Event'
        db.delete_table('julian_event')

        # Removing M2M table for field tags on 'Event'
        db.delete_table('julian_event_tags')

        # Deleting model 'Calendar'
        db.delete_table('julian_calendar')

        # Removing M2M table for field events on 'Calendar'
        db.delete_table('julian_calendar_events')

        # Deleting model 'CalendarView'
        db.delete_table('julian_calendarview')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'julian.calendar': {
            'Meta': {'unique_together': "(('name', 'site', 'language'),)", 'object_name': 'Calendar'},
            'description': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'events': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'related_name': "'calendars'", 'blank': 'True', 'to': "orm['julian.Event']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'language': ('django.db.models.fields.CharField', [], {'default': "'en'", 'max_length': '5'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '100', 'db_index': 'True'})
        },
        'julian.calendarview': {
            'Meta': {'object_name': 'CalendarView'},
            'calendar': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['julian.Calendar']"}),
            'event_detail_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'calendar_detail_related'", 'to': "orm['philo.Page']"}),
            'events_per_page': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'feed_length': ('django.db.models.fields.PositiveIntegerField', [], {'default': '15', 'null': 'True', 'blank': 'True'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feed_type': ('django.db.models.fields.CharField', [], {'default': "'text/calendar'", 'max_length': '50'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'calendar_index_related'", 'to': "orm['philo.Page']"}),
            'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'julian_calendarview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'julian_calendarview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'location_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'calendar_location_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'location_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'calendar_location_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'location_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'locations'", 'max_length': '30'}),
            'owner_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'calendar_owner_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'owner_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'calendar_owner_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'owner_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'owners'", 'max_length': '30'}),
            'tag_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'calendar_tag_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'tag_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'calendar_tag_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'tag_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'tags'", 'max_length': '30'}),
            'timespan_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'calendar_timespan_related'", 'null': 'True', 'to': "orm['philo.Page']"})
        },
        'julian.event': {
            'Meta': {'unique_together': "(('site', 'created'),)", 'object_name': 'Event'},
            'created': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('philo.models.fields.TemplateField', [], {}),
            'end_date': ('django.db.models.fields.DateField', [], {}),
            'end_time': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_modified': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'location_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'location_pk': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'owner': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'owned_events'", 'to': "orm['auth.User']"}),
            'parent_event': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['julian.Event']", 'null': 'True', 'blank': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'start_date': ('django.db.models.fields.DateField', [], {}),
            'start_time': ('django.db.models.fields.TimeField', [], {'null': 'True', 'blank': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'events'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"})
        },
        'julian.location': {
            'Meta': {'object_name': 'Location'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'root_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'sites'", 'null': 'True', 'to': "orm['philo.Node']"})
        }
    }

    complete_apps = ['julian']

########NEW FILE########
__FILENAME__ = models
import calendar
import datetime

from django.conf import settings
from django.conf.urls.defaults import url, patterns, include
from django.contrib.auth.models import User
from django.contrib.contenttypes.generic import GenericForeignKey
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.models import Site
from django.core.exceptions import ValidationError, ObjectDoesNotExist
from django.core.validators import RegexValidator
from django.db import models
from django.db.models.query import QuerySet
from django.http import HttpResponse, Http404
from django.utils.encoding import force_unicode
from taggit.managers import TaggableManager

from philo.contrib.julian.feedgenerator import ICalendarFeed
from philo.contrib.winer.models import FeedView
from philo.contrib.winer.feeds import registry
from philo.exceptions import ViewCanNotProvideSubpath
from philo.models import Tag, Entity, Page
from philo.models.fields import TemplateField
from philo.utils import ContentTypeRegistryLimiter


__all__ = ('register_location_model', 'unregister_location_model', 'Location', 'TimedModel', 'Event', 'Calendar', 'CalendarView',)


registry.register(ICalendarFeed, verbose_name="iCalendar")
try:
	DEFAULT_SITE = Site.objects.get_current()
except:
	DEFAULT_SITE = None
_languages = dict(settings.LANGUAGES)
try:
	_languages[settings.LANGUAGE_CODE]
	DEFAULT_LANGUAGE = settings.LANGUAGE_CODE
except KeyError:
	try:
		lang = settings.LANGUAGE_CODE.split('-')[0]
		_languages[lang]
		DEFAULT_LANGUAGE = lang
	except KeyError:
		DEFAULT_LANGUAGE = None


location_content_type_limiter = ContentTypeRegistryLimiter()


def register_location_model(model):
	location_content_type_limiter.register_class(model)


def unregister_location_model(model):
	location_content_type_limiter.unregister_class(model)


class Location(Entity):
	name = models.CharField(max_length=255)
	slug = models.SlugField(max_length=255, unique=True)
	
	def __unicode__(self):
		return self.name


register_location_model(Location)


class TimedModel(models.Model):
	start_date = models.DateField(help_text="YYYY-MM-DD")
	start_time = models.TimeField(blank=True, null=True, help_text="HH:MM:SS - 24 hour clock")
	end_date = models.DateField()
	end_time = models.TimeField(blank=True, null=True)
	
	def is_all_day(self):
		return self.start_time is None and self.end_time is None
	
	def clean(self):
		if bool(self.start_time) != bool(self.end_time):
			raise ValidationError("A %s must have either a start time and an end time or neither.")
		
		if self.start_date > self.end_date or self.start_date == self.end_date and self.start_time > self.end_time:
			raise ValidationError("A %s cannot end before it starts." % self.__class__.__name__)
	
	def get_start(self):
		return datetime.datetime.combine(self.start_date, self.start_time) if self.start_time else self.start_date
	
	def get_end(self):
		return datetime.datetime.combine(self.end_date, self.end_time) if self.end_time else self.end_date
	
	class Meta:
		abstract = True


class EventManager(models.Manager):
	def get_query_set(self):
		return EventQuerySet(self.model)

class EventQuerySet(QuerySet):
	def upcoming(self):
		return self.filter(start_date__gte=datetime.date.today())
	def current(self):
		return self.filter(start_date__lte=datetime.date.today(), end_date__gte=datetime.date.today())
	def single_day(self):
		return self.filter(start_date__exact=models.F('end_date'))
	def multiday(self):
		return self.exclude(start_date__exact=models.F('end_date'))

class Event(Entity, TimedModel):
	name = models.CharField(max_length=255)
	slug = models.SlugField(max_length=255, unique_for_date='start_date')
	
	location_content_type = models.ForeignKey(ContentType, limit_choices_to=location_content_type_limiter, blank=True, null=True)
	location_pk = models.TextField(blank=True)
	location = GenericForeignKey('location_content_type', 'location_pk')
	
	description = TemplateField()
	
	tags = models.ManyToManyField(Tag, related_name='events', blank=True, null=True)
	
	parent_event = models.ForeignKey('self', blank=True, null=True)
	
	# TODO: "User module"
	owner = models.ForeignKey(User, related_name='owned_events')
	
	created = models.DateTimeField(auto_now_add=True)
	last_modified = models.DateTimeField(auto_now=True)
	
	site = models.ForeignKey(Site, default=DEFAULT_SITE)
	
	@property
	def uuid(self):
		return "%s@%s" % (self.created.isoformat(), getattr(self.site, 'domain', 'None'))
	
	objects = EventManager()
	
	def __unicode__(self):
		return self.name
	
	class Meta:
		unique_together = ('site', 'created')


class Calendar(Entity):
	name = models.CharField(max_length=100)
	slug = models.SlugField(max_length=100)
	description = models.TextField(blank=True)
	events = models.ManyToManyField(Event, related_name='calendars', blank=True)
	
	site = models.ForeignKey(Site, default=DEFAULT_SITE)
	language = models.CharField(max_length=5, choices=settings.LANGUAGES, default=DEFAULT_LANGUAGE)
	
	def __unicode__(self):
		return self.name
	
	@property
	def fpi(self):
		# See http://xml.coverpages.org/tauber-fpi.html or ISO 9070:1991 for format information.
		return "-//%s//%s//%s" % (self.site.name, self.name, self.language.split('-')[0].upper())
	
	class Meta:
		unique_together = ('name', 'site', 'language')


class CalendarView(FeedView):
	calendar = models.ForeignKey(Calendar)
	index_page = models.ForeignKey(Page, related_name="calendar_index_related")
	event_detail_page = models.ForeignKey(Page, related_name="calendar_detail_related")
	
	timespan_page = models.ForeignKey(Page, related_name="calendar_timespan_related", blank=True, null=True)
	tag_page = models.ForeignKey(Page, related_name="calendar_tag_related", blank=True, null=True)
	location_page = models.ForeignKey(Page, related_name="calendar_location_related", blank=True, null=True)
	owner_page = models.ForeignKey(Page, related_name="calendar_owner_related", blank=True, null=True)
	
	tag_archive_page = models.ForeignKey(Page, related_name="calendar_tag_archive_related", blank=True, null=True)
	location_archive_page = models.ForeignKey(Page, related_name="calendar_location_archive_related", blank=True, null=True)
	owner_archive_page = models.ForeignKey(Page, related_name="calendar_owner_archive_related", blank=True, null=True)
	
	tag_permalink_base = models.CharField(max_length=30, default='tags')
	owner_permalink_base = models.CharField(max_length=30, default='owners')
	location_permalink_base = models.CharField(max_length=30, default='locations')
	events_per_page = models.PositiveIntegerField(blank=True, null=True)
	
	item_context_var = "events"
	object_attr = "calendar"
	
	def get_reverse_params(self, obj):
		if isinstance(obj, User):
			return 'events_for_user', [], {'username': obj.username}
		elif isinstance(obj, Event):
			return 'event_detail', [], {
				'year': str(obj.start_date.year).zfill(4),
				'month': str(obj.start_date.month).zfill(2),
				'day': str(obj.start_date.day).zfill(2),
				'slug': obj.slug
			}
		elif isinstance(obj, Tag) or isinstance(obj, models.query.QuerySet) and obj.model == Tag:
			if isinstance(obj, Tag):
				obj = [obj]
			return 'entries_by_tag', [], {'tag_slugs': '/'.join(obj)}
		raise ViewCanNotProvideSubpath
	
	def timespan_patterns(self, pattern, timespan_name):
		return self.feed_patterns(pattern, 'get_events_by_timespan', 'timespan_page', "events_by_%s" % timespan_name)
	
	@property
	def urlpatterns(self):
		# Perhaps timespans should be done with GET parameters? Or two /-separated
		# date slugs? (e.g. 2010-02-1/2010-02-2) or a start and duration?
		# (e.g. 2010-02-01/week/ or ?d=2010-02-01&l=week)
		urlpatterns = self.feed_patterns(r'^', 'get_all_events', 'index_page', 'index') + \
			self.timespan_patterns(r'^(?P<year>\d{4})', 'year') + \
			self.timespan_patterns(r'^(?P<year>\d{4})/(?P<month>\d{2})', 'month') + \
			self.timespan_patterns(r'^(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})', 'day') + \
			self.feed_patterns(r'^%s/(?P<username>[^/]+)' % self.owner_permalink_base, 'get_events_by_owner', 'owner_page', 'events_by_user') + \
			self.feed_patterns(r'^%s/(?P<app_label>\w+)/(?P<model>\w+)/(?P<pk>[^/]+)' % self.location_permalink_base, 'get_events_by_location', 'location_page', 'events_by_location') + \
			self.feed_patterns(r'^%s/(?P<tag_slugs>[-\w]+[-+/\w]*)' % self.tag_permalink_base, 'get_events_by_tag', 'tag_page', 'events_by_tag') + \
			patterns('',
				url(r'(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})/(?P<slug>[\w-]+)$', self.event_detail_view, name="event_detail"),
			)
			
			# Some sort of shortcut for a location would be useful. This could be on a per-calendar
			# or per-calendar-view basis.
			#url(r'^%s/(?P<slug>[\w-]+)' % self.location_permalink_base, ...)
		
		if self.tag_archive_page_id:
			urlpatterns += patterns('',
				url(r'^%s$' % self.tag_permalink_base, self.tag_archive_view, name='tag_archive')
			)
		
		if self.owner_archive_page_id:
			urlpatterns += patterns('',
				url(r'^%s$' % self.owner_permalink_base, self.owner_archive_view, name='owner_archive')
			)
		
		if self.location_archive_page_id:
			urlpatterns += patterns('',
				url(r'^%s$' % self.location_permalink_base, self.location_archive_view, name='location_archive')
			)
		return urlpatterns
	
	# Basic QuerySet fetchers.
	def get_event_queryset(self):
		return self.calendar.events.all()
	
	def get_timespan_queryset(self, year, month=None, day=None):
		qs = self.get_event_queryset()
		# See python documentation for the min/max values.
		if year and month and day:
			year, month, day = int(year), int(month), int(day)
			start_datetime = datetime.datetime(year, month, day, 0, 0)
			end_datetime = datetime.datetime(year, month, day, 23, 59)
		elif year and month:
			year, month = int(year), int(month)
			start_datetime = datetime.datetime(year, month, 1, 0, 0)
			end_datetime = datetime.datetime(year, month, calendar.monthrange(year, month)[1], 23, 59)
		else:
			year = int(year)
			start_datetime = datetime.datetime(year, 1, 1, 0, 0)
			end_datetime = datetime.datetime(year, 12, 31, 23, 59)
		
		return qs.exclude(end_date__lt=start_datetime, end_time__lt=start_datetime).exclude(start_date__gt=end_datetime, start_time__gt=end_datetime, start_time__isnull=False).exclude(start_time__isnull=True, start_date__gt=end_datetime)
	
	def get_tag_queryset(self):
		return Tag.objects.filter(events__calendars=self.calendar).distinct()
	
	def get_location_querysets(self):
		# Potential bottleneck?
		location_map = {}
		locations = Event.objects.values_list('location_content_type', 'location_pk')
		
		for ct, pk in locations:
			location_map.setdefault(ct, []).append(pk)
		
		location_cts = ContentType.objects.in_bulk(location_map.keys())
		location_querysets = {}
		
		for ct_pk, pks in location_map.items():
			ct = location_cts[ct_pk]
			location_querysets[ct] = ct.model_class()._default_manager.filter(pk__in=pks)
		
		return location_querysets
	
	def get_owner_queryset(self):
		return User.objects.filter(owned_events__calendars=self.calendar).distinct()
	
	# Event QuerySet parsers for a request/args/kwargs
	def get_all_events(self, request, extra_context=None):
		return self.get_event_queryset(), extra_context
	
	def get_events_by_timespan(self, request, year, month=None, day=None, extra_context=None):
		context = extra_context or {}
		context.update({
			'year': year,
			'month': month,
			'day': day
		})
		return self.get_timespan_queryset(year, month, day), context
	
	def get_events_by_owner(self, request, username, extra_context=None):
		try:
			owner = self.get_owner_queryset().get(username=username)
		except User.DoesNotExist:
			raise Http404
		
		qs = self.get_event_queryset().filter(owner=owner)
		context = extra_context or {}
		context.update({
			'owner': owner
		})
		return qs, context
	
	def get_events_by_tag(self, request, tag_slugs, extra_context=None):
		tag_slugs = tag_slugs.replace('+', '/').split('/')
		tags = self.get_tag_queryset().filter(slug__in=tag_slugs)
		
		if not tags:
			raise Http404
		
		# Raise a 404 on an incorrect slug.
		found_slugs = [tag.slug for tag in tags]
		for slug in tag_slugs:
			if slug and slug not in found_slugs:
				raise Http404

		events = self.get_event_queryset()
		for tag in tags:
			events = events.filter(tags=tag)
		
		context = extra_context or {}
		context.update({'tags': tags})
		
		return events, context
	
	def get_events_by_location(self, request, app_label, model, pk, extra_context=None):
		try:
			ct = ContentType.objects.get_by_natural_key(app_label, model)
			location = ct.model_class()._default_manager.get(pk=pk)
		except ObjectDoesNotExist:
			raise Http404
		
		events = self.get_event_queryset().filter(location_content_type=ct, location_pk=location.pk)
		
		context = extra_context or {}
		context.update({
			'location': location
		})
		return events, context
	
	# Detail View.
	def event_detail_view(self, request, year, month, day, slug, extra_context=None):
		try:
			event = Event.objects.select_related('parent_event').get(start_date__year=year, start_date__month=month, start_date__day=day, slug=slug)
		except Event.DoesNotExist:
			raise Http404
		
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'event': event
		})
		return self.event_detail_page.render_to_response(request, extra_context=context)
	
	# Archive Views.
	def tag_archive_view(self, request, extra_context=None):
		tags = self.get_tag_queryset()
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'tags': tags
		})
		return self.tag_archive_page.render_to_response(request, extra_context=context)
	
	def location_archive_view(self, request, extra_context=None):
		# What datastructure should locations be?
		locations = self.get_location_querysets()
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'locations': locations
		})
		return self.location_archive_page.render_to_response(request, extra_context=context)
	
	def owner_archive_view(self, request, extra_context=None):
		owners = self.get_owner_queryset()
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'owners': owners
		})
		return self.owner_archive_page.render_to_response(request, extra_context=context)
	
	# Process page items
	def process_page_items(self, request, items):
		if self.events_per_page:
			page_num = request.GET.get('page', 1)
			paginator, paginated_page, items = paginate(items, self.events_per_page, page_num)
			item_context = {
				'paginator': paginator,
				'paginated_page': paginated_page,
				self.item_context_var: items
			}
		else:
			item_context = {
				self.item_context_var: items
			}
		return items, item_context
	
	# Feed information hooks
	def title(self, obj):
		return obj.name
	
	def link(self, obj):
		# Link is ignored anyway...
		return ""
	
	def feed_guid(self, obj):
		return obj.fpi
	
	def description(self, obj):
		return obj.description
	
	def feed_extra_kwargs(self, obj):
		return {'filename': "%s.ics" % obj.slug}
	
	def item_title(self, item):
		return item.name
	
	def item_description(self, item):
		return item.description
	
	def item_link(self, item):
		return self.reverse(item)
	
	def item_guid(self, item):
		return item.uuid
	
	def item_author_name(self, item):
		if item.owner:
			return item.owner.get_full_name()
	
	def item_author_email(self, item):
		return getattr(item.owner, 'email', None) or None
	
	def item_pubdate(self, item):
		return item.created
	
	def item_categories(self, item):
		return [tag.name for tag in item.tags.all()]
	
	def item_extra_kwargs(self, item):
		return {
			'start': item.get_start(),
			'end': item.get_end(),
			'last_modified': item.last_modified,
			# Is forcing unicode enough, or should we look for a "custom method"?
			'location': force_unicode(item.location),
		}
	
	def __unicode__(self):
		return u"%s for %s" % (self.__class__.__name__, self.calendar)

field = CalendarView._meta.get_field('feed_type')
field.default = registry.get_slug(ICalendarFeed, field.default)
########NEW FILE########
__FILENAME__ = admin
from django import forms
from django.contrib import admin
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect, QueryDict

from philo.admin import EntityAdmin, COLLAPSE_CLASSES
from philo.admin.widgets import EmbedWidget
from philo.contrib.penfield.models import BlogEntry, Blog, BlogView, Newsletter, NewsletterArticle, NewsletterIssue, NewsletterView
from philo.models.fields import TemplateField


class DelayedDateForm(forms.ModelForm):
	date_field = 'date'
	
	def __init__(self, *args, **kwargs):
		super(DelayedDateForm, self).__init__(*args, **kwargs)
		self.fields[self.date_field].required = False


class BlogAdmin(EntityAdmin):
	prepopulated_fields = {'slug': ('title',)}
	list_display = ('title', 'slug')


class BlogEntryAdmin(EntityAdmin):
	form = DelayedDateForm
	list_filter = ['author', 'blog']
	date_hierarchy = 'date'
	search_fields = ('content',)
	list_display = ['title', 'date', 'author']
	raw_id_fields = ('author',)
	fieldsets = (
		(None, {
			'fields': ('title', 'author', 'blog')
		}),
		('Content', {
			'fields': ('content', 'excerpt', 'tags'),
		}),
		('Advanced', {
			'fields': ('slug', 'date'),
			'classes': COLLAPSE_CLASSES
		})
	)
	related_lookup_fields = {'fk': raw_id_fields}
	prepopulated_fields = {'slug': ('title',)}
	formfield_overrides = {
		TemplateField: {'widget': EmbedWidget}
	}


class BlogViewAdmin(EntityAdmin):
	fieldsets = (
		(None, {
			'fields': ('blog',)
		}),
		('Pages', {
			'fields': ('index_page', 'entry_page', 'tag_page')
		}),
		('Archive Pages', {
			'fields': ('entry_archive_page', 'tag_archive_page')
		}),
		('General Settings', {
			'fields': ('entry_permalink_style', 'entry_permalink_base', 'tag_permalink_base', 'entries_per_page'),
			'classes': COLLAPSE_CLASSES
		}),
		('Feed Settings', {
			'fields': ( 'feeds_enabled', 'feed_suffix', 'feed_type', 'feed_length', 'item_title_template', 'item_description_template',),
			'classes': COLLAPSE_CLASSES
		})
	)
	raw_id_fields = ('index_page', 'entry_page', 'tag_page', 'entry_archive_page', 'tag_archive_page', 'item_title_template', 'item_description_template',)
	related_lookup_fields = {'fk': raw_id_fields}


class NewsletterAdmin(EntityAdmin):
	prepopulated_fields = {'slug': ('title',)}
	list_display = ('title', 'slug')


class NewsletterArticleAdmin(EntityAdmin):
	form = DelayedDateForm
	filter_horizontal = ('authors',)
	list_filter = ('newsletter',)
	date_hierarchy = 'date'
	search_fields = ('title', 'authors__name',)
	list_display = ['title', 'date', 'author_names']
	fieldsets = (
		(None, {
			'fields': ('title', 'authors', 'newsletter')
		}),
		('Content', {
			'fields': ('full_text', 'lede', 'tags')
		}),
		('Advanced', {
			'fields': ('slug', 'date'),
			'classes': COLLAPSE_CLASSES
		})
	)
	actions = ['make_issue']
	prepopulated_fields = {'slug': ('title',)}
	formfield_overrides = {
		TemplateField: {'widget': EmbedWidget}
	}
	
	def author_names(self, obj):
		return ', '.join([author.get_full_name() for author in obj.authors.all()])
	author_names.short_description = "Authors"
	
	def make_issue(self, request, queryset):
		opts = NewsletterIssue._meta
		info = opts.app_label, opts.module_name
		url = reverse("admin:%s_%s_add" % info)
		return HttpResponseRedirect("%s?articles=%s" % (url, ",".join([str(a.pk) for a in queryset])))
	make_issue.short_description = u"Create issue from selected %(verbose_name_plural)s"


class NewsletterIssueAdmin(EntityAdmin):
	filter_horizontal = ('articles',)
	prepopulated_fields = {'slug': ('title',)}
	list_display = ('title', 'slug')


class NewsletterViewAdmin(EntityAdmin):
	fieldsets = (
		(None, {
			'fields': ('newsletter',)
		}),
		('Pages', {
			'fields': ('index_page', 'article_page', 'issue_page')
		}),
		('Archive Pages', {
			'fields': ('article_archive_page', 'issue_archive_page')
		}),
		('Permalinks', {
			'fields': ('article_permalink_style', 'article_permalink_base', 'issue_permalink_base'),
			'classes': COLLAPSE_CLASSES
		}),
		('Feeds', {
			'fields': ( 'feeds_enabled', 'feed_suffix', 'feed_type', 'feed_length', 'item_title_template', 'item_description_template',),
			'classes': COLLAPSE_CLASSES
		})
	)
	raw_id_fields = ('index_page', 'article_page', 'issue_page', 'article_archive_page', 'issue_archive_page', 'item_title_template', 'item_description_template',)
	related_lookup_fields = {'fk': raw_id_fields}


admin.site.register(Blog, BlogAdmin)
admin.site.register(BlogEntry, BlogEntryAdmin)
admin.site.register(BlogView, BlogViewAdmin)
admin.site.register(Newsletter, NewsletterAdmin)
admin.site.register(NewsletterArticle, NewsletterArticleAdmin)
admin.site.register(NewsletterIssue, NewsletterIssueAdmin)
admin.site.register(NewsletterView, NewsletterViewAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from philo.migrations import person_model, frozen_person

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Blog'
        db.create_table('penfield_blog', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
        ))
        db.send_create_signal('penfield', ['Blog'])

        # Adding model 'BlogEntry'
        db.create_table('penfield_blogentry', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('blog', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='entries', null=True, to=orm['penfield.Blog'])),
            ('author', self.gf('django.db.models.fields.related.ForeignKey')(related_name='blogentries', to=orm[person_model])),
            ('date', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('content', self.gf('django.db.models.fields.TextField')()),
            ('excerpt', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
        ))
        db.send_create_signal('penfield', ['BlogEntry'])

        # Adding M2M table for field tags on 'BlogEntry'
        db.create_table('penfield_blogentry_tags', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('blogentry', models.ForeignKey(orm['penfield.blogentry'], null=False)),
            ('tag', models.ForeignKey(orm['philo.tag'], null=False))
        ))
        db.create_unique('penfield_blogentry_tags', ['blogentry_id', 'tag_id'])

        # Adding model 'BlogView'
        db.create_table('penfield_blogview', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('blog', self.gf('django.db.models.fields.related.ForeignKey')(related_name='blogviews', to=orm['penfield.Blog'])),
            ('index_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='blog_index_related', to=orm['philo.Page'])),
            ('entry_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='blog_entry_related', to=orm['philo.Page'])),
            ('entry_archive_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='blog_entry_archive_related', null=True, to=orm['philo.Page'])),
            ('tag_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='blog_tag_related', to=orm['philo.Page'])),
            ('tag_archive_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='blog_tag_archive_related', null=True, to=orm['philo.Page'])),
            ('entries_per_page', self.gf('django.db.models.fields.IntegerField')(null=True, blank=True)),
            ('entry_permalink_style', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('entry_permalink_base', self.gf('django.db.models.fields.CharField')(default='entries', max_length=255)),
            ('tag_permalink_base', self.gf('django.db.models.fields.CharField')(default='tags', max_length=255)),
            ('feed_suffix', self.gf('django.db.models.fields.CharField')(default='feed', max_length=255)),
            ('feeds_enabled', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True)),
        ))
        db.send_create_signal('penfield', ['BlogView'])

        # Adding model 'Newsletter'
        db.create_table('penfield_newsletter', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
        ))
        db.send_create_signal('penfield', ['Newsletter'])

        # Adding model 'NewsletterArticle'
        db.create_table('penfield_newsletterarticle', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('newsletter', self.gf('django.db.models.fields.related.ForeignKey')(related_name='articles', to=orm['penfield.Newsletter'])),
            ('date', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime.now)),
            ('lede', self.gf('philo.models.fields.TemplateField')(null=True, blank=True)),
            ('full_text', self.gf('philo.models.fields.TemplateField')()),
        ))
        db.send_create_signal('penfield', ['NewsletterArticle'])

        # Adding unique constraint on 'NewsletterArticle', fields ['newsletter', 'slug']
        db.create_unique('penfield_newsletterarticle', ['newsletter_id', 'slug'])

        # Adding M2M table for field authors on 'NewsletterArticle'
        db.create_table('penfield_newsletterarticle_authors', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('newsletterarticle', models.ForeignKey(orm['penfield.newsletterarticle'], null=False)),
            ('person', models.ForeignKey(orm[person_model], null=False))
        ))
        db.create_unique('penfield_newsletterarticle_authors', ['newsletterarticle_id', 'person_id'])

        # Adding M2M table for field tags on 'NewsletterArticle'
        db.create_table('penfield_newsletterarticle_tags', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('newsletterarticle', models.ForeignKey(orm['penfield.newsletterarticle'], null=False)),
            ('tag', models.ForeignKey(orm['philo.tag'], null=False))
        ))
        db.create_unique('penfield_newsletterarticle_tags', ['newsletterarticle_id', 'tag_id'])

        # Adding model 'NewsletterIssue'
        db.create_table('penfield_newsletterissue', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('newsletter', self.gf('django.db.models.fields.related.ForeignKey')(related_name='issues', to=orm['penfield.Newsletter'])),
            ('numbering', self.gf('django.db.models.fields.CharField')(max_length=50)),
        ))
        db.send_create_signal('penfield', ['NewsletterIssue'])

        # Adding unique constraint on 'NewsletterIssue', fields ['newsletter', 'numbering']
        db.create_unique('penfield_newsletterissue', ['newsletter_id', 'numbering'])

        # Adding M2M table for field articles on 'NewsletterIssue'
        db.create_table('penfield_newsletterissue_articles', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('newsletterissue', models.ForeignKey(orm['penfield.newsletterissue'], null=False)),
            ('newsletterarticle', models.ForeignKey(orm['penfield.newsletterarticle'], null=False))
        ))
        db.create_unique('penfield_newsletterissue_articles', ['newsletterissue_id', 'newsletterarticle_id'])

        # Adding model 'NewsletterView'
        db.create_table('penfield_newsletterview', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('newsletter', self.gf('django.db.models.fields.related.ForeignKey')(related_name='newsletterviews', to=orm['penfield.Newsletter'])),
            ('index_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='newsletter_index_related', to=orm['philo.Page'])),
            ('article_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='newsletter_article_related', to=orm['philo.Page'])),
            ('article_archive_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='newsletter_article_archive_related', null=True, to=orm['philo.Page'])),
            ('issue_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='newsletter_issue_related', to=orm['philo.Page'])),
            ('issue_archive_page', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='newsletter_issue_archive_related', null=True, to=orm['philo.Page'])),
            ('article_permalink_style', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('article_permalink_base', self.gf('django.db.models.fields.CharField')(default='articles', max_length=255)),
            ('issue_permalink_base', self.gf('django.db.models.fields.CharField')(default='issues', max_length=255)),
            ('feed_suffix', self.gf('django.db.models.fields.CharField')(default='feed', max_length=255)),
            ('feeds_enabled', self.gf('django.db.models.fields.BooleanField')(default=False, blank=True)),
        ))
        db.send_create_signal('penfield', ['NewsletterView'])


    def backwards(self, orm):
        
        # Deleting model 'Blog'
        db.delete_table('penfield_blog')

        # Deleting model 'BlogEntry'
        db.delete_table('penfield_blogentry')

        # Removing M2M table for field tags on 'BlogEntry'
        db.delete_table('penfield_blogentry_tags')

        # Deleting model 'BlogView'
        db.delete_table('penfield_blogview')

        # Deleting model 'Newsletter'
        db.delete_table('penfield_newsletter')

        # Deleting model 'NewsletterArticle'
        db.delete_table('penfield_newsletterarticle')

        # Removing unique constraint on 'NewsletterArticle', fields ['newsletter', 'slug']
        db.delete_unique('penfield_newsletterarticle', ['newsletter_id', 'slug'])

        # Removing M2M table for field authors on 'NewsletterArticle'
        db.delete_table('penfield_newsletterarticle_authors')

        # Removing M2M table for field tags on 'NewsletterArticle'
        db.delete_table('penfield_newsletterarticle_tags')

        # Deleting model 'NewsletterIssue'
        db.delete_table('penfield_newsletterissue')

        # Removing unique constraint on 'NewsletterIssue', fields ['newsletter', 'numbering']
        db.delete_unique('penfield_newsletterissue', ['newsletter_id', 'numbering'])

        # Removing M2M table for field articles on 'NewsletterIssue'
        db.delete_table('penfield_newsletterissue_articles')

        # Deleting model 'NewsletterView'
        db.delete_table('penfield_newsletterview')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        person_model: frozen_person,
        'penfield.blog': {
            'Meta': {'object_name': 'Blog'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogentry': {
            'Meta': {'object_name': 'BlogEntry'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogentries'", 'to': "orm['%s']" % person_model}),
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'entries'", 'null': 'True', 'to': "orm['penfield.Blog']"}),
            'content': ('django.db.models.fields.TextField', [], {}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'excerpt': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'blogentries'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogview': {
            'Meta': {'object_name': 'BlogView'},
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogviews'", 'to': "orm['penfield.Blog']"}),
            'entries_per_page': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'entry_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_entry_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'entry_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_entry_related'", 'to': "orm['philo.Page']"}),
            'entry_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'entries'", 'max_length': '255'}),
            'entry_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_index_related'", 'to': "orm['philo.Page']"}),
            'tag_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_tag_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'tag_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_tag_related'", 'to': "orm['philo.Page']"}),
            'tag_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'tags'", 'max_length': '255'})
        },
        'penfield.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterarticle': {
            'Meta': {'unique_together': "(('newsletter', 'slug'),)", 'object_name': 'NewsletterArticle'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'newsletterarticles'", 'symmetrical': 'False', 'to': "orm['%s']" % person_model}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'full_text': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lede': ('philo.models.fields.TemplateField', [], {'null': 'True', 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['penfield.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'newsletterarticles'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterissue': {
            'Meta': {'unique_together': "(('newsletter', 'numbering'),)", 'object_name': 'NewsletterIssue'},
            'articles': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'issues'", 'symmetrical': 'False', 'to': "orm['penfield.NewsletterArticle']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'issues'", 'to': "orm['penfield.Newsletter']"}),
            'numbering': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterview': {
            'Meta': {'object_name': 'NewsletterView'},
            'article_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_article_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'article_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_article_related'", 'to': "orm['philo.Page']"}),
            'article_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'articles'", 'max_length': '255'}),
            'article_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_index_related'", 'to': "orm['philo.Page']"}),
            'issue_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_issue_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'issue_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_issue_related'", 'to': "orm['philo.Page']"}),
            'issue_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'issues'", 'max_length': '255'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletterviews'", 'to': "orm['penfield.Newsletter']"})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json_value': ('django.db.models.fields.TextField', [], {}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['penfield']

########NEW FILE########
__FILENAME__ = 0002_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from philo.migrations import person_model, frozen_person

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'NewsletterArticle', fields ['full_text']
        db.create_index('penfield_newsletterarticle', ['full_text'])


    def backwards(self, orm):
        
        # Removing index on 'NewsletterArticle', fields ['full_text']
        db.delete_index('penfield_newsletterarticle', ['full_text'])


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        person_model: frozen_person,
        'penfield.blog': {
            'Meta': {'object_name': 'Blog'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogentry': {
            'Meta': {'object_name': 'BlogEntry'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogentries'", 'to': "orm['%s']" % person_model}),
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'entries'", 'null': 'True', 'to': "orm['penfield.Blog']"}),
            'content': ('django.db.models.fields.TextField', [], {}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'excerpt': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'blogentries'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogview': {
            'Meta': {'object_name': 'BlogView'},
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogviews'", 'to': "orm['penfield.Blog']"}),
            'entries_per_page': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'entry_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_entry_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'entry_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_entry_related'", 'to': "orm['philo.Page']"}),
            'entry_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'entries'", 'max_length': '255'}),
            'entry_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_index_related'", 'to': "orm['philo.Page']"}),
            'tag_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_tag_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'tag_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_tag_related'", 'to': "orm['philo.Page']"}),
            'tag_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'tags'", 'max_length': '255'})
        },
        'penfield.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterarticle': {
            'Meta': {'unique_together': "(('newsletter', 'slug'),)", 'object_name': 'NewsletterArticle'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'newsletterarticles'", 'symmetrical': 'False', 'to': "orm['%s']" % person_model}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'full_text': ('philo.models.fields.TemplateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lede': ('philo.models.fields.TemplateField', [], {'null': 'True', 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['penfield.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'newsletterarticles'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterissue': {
            'Meta': {'unique_together': "(('newsletter', 'numbering'),)", 'object_name': 'NewsletterIssue'},
            'articles': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'issues'", 'symmetrical': 'False', 'to': "orm['penfield.NewsletterArticle']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'issues'", 'to': "orm['penfield.Newsletter']"}),
            'numbering': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterview': {
            'Meta': {'object_name': 'NewsletterView'},
            'article_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_article_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'article_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_article_related'", 'to': "orm['philo.Page']"}),
            'article_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'articles'", 'max_length': '255'}),
            'article_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_index_related'", 'to': "orm['philo.Page']"}),
            'issue_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_issue_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'issue_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_issue_related'", 'to': "orm['philo.Page']"}),
            'issue_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'issues'", 'max_length': '255'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletterviews'", 'to': "orm['penfield.Newsletter']"})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['penfield']

########NEW FILE########
__FILENAME__ = 0003_auto__add_field_newsletterview_feed_type__add_field_newsletterview_ite
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from philo.migrations import person_model, frozen_person

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'NewsletterView.feed_type'
        db.add_column('penfield_newsletterview', 'feed_type', self.gf('django.db.models.fields.CharField')(default='application/atom+xml', max_length=50), keep_default=False)

        # Adding field 'NewsletterView.item_title_template'
        db.add_column('penfield_newsletterview', 'item_title_template', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='penfield_newsletterview_title_related', null=True, to=orm['philo.Template']), keep_default=False)

        # Adding field 'NewsletterView.item_description_template'
        db.add_column('penfield_newsletterview', 'item_description_template', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='penfield_newsletterview_description_related', null=True, to=orm['philo.Template']), keep_default=False)

        # Adding field 'BlogView.feed_type'
        db.add_column('penfield_blogview', 'feed_type', self.gf('django.db.models.fields.CharField')(default='atom', max_length=50), keep_default=False)

        # Adding field 'BlogView.item_title_template'
        db.add_column('penfield_blogview', 'item_title_template', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='penfield_blogview_title_related', null=True, to=orm['philo.Template']), keep_default=False)

        # Adding field 'BlogView.item_description_template'
        db.add_column('penfield_blogview', 'item_description_template', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='penfield_blogview_description_related', null=True, to=orm['philo.Template']), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'NewsletterView.feed_type'
        db.delete_column('penfield_newsletterview', 'feed_type')

        # Deleting field 'NewsletterView.item_title_template'
        db.delete_column('penfield_newsletterview', 'item_title_template_id')

        # Deleting field 'NewsletterView.item_description_template'
        db.delete_column('penfield_newsletterview', 'item_description_template_id')

        # Deleting field 'BlogView.feed_type'
        db.delete_column('penfield_blogview', 'feed_type')

        # Deleting field 'BlogView.item_title_template'
        db.delete_column('penfield_blogview', 'item_title_template_id')

        # Deleting field 'BlogView.item_description_template'
        db.delete_column('penfield_blogview', 'item_description_template_id')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        person_model: frozen_person,
        'penfield.blog': {
            'Meta': {'object_name': 'Blog'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogentry': {
            'Meta': {'object_name': 'BlogEntry'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogentries'", 'to': "orm['%s']" % person_model}),
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'entries'", 'null': 'True', 'to': "orm['penfield.Blog']"}),
            'content': ('django.db.models.fields.TextField', [], {}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
            'excerpt': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'blogentries'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogview': {
            'Meta': {'object_name': 'BlogView'},
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogviews'", 'to': "orm['penfield.Blog']"}),
            'entries_per_page': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'entry_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_entry_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'entry_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_entry_related'", 'to': "orm['philo.Page']"}),
            'entry_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'entries'", 'max_length': '255'}),
            'entry_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feed_type': ('django.db.models.fields.CharField', [], {'default': "'atom'", 'max_length': '50'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_index_related'", 'to': "orm['philo.Page']"}),
            'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'tag_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_tag_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'tag_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_tag_related'", 'to': "orm['philo.Page']"}),
            'tag_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'tags'", 'max_length': '255'})
        },
        'penfield.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterarticle': {
            'Meta': {'unique_together': "(('newsletter', 'slug'),)", 'object_name': 'NewsletterArticle'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'newsletterarticles'", 'symmetrical': 'False', 'to': "orm['%s']" % person_model}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
            'full_text': ('philo.models.fields.TemplateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lede': ('philo.models.fields.TemplateField', [], {'null': 'True', 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['penfield.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'newsletterarticles'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterissue': {
            'Meta': {'unique_together': "(('newsletter', 'numbering'),)", 'object_name': 'NewsletterIssue'},
            'articles': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'issues'", 'symmetrical': 'False', 'to': "orm['penfield.NewsletterArticle']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'issues'", 'to': "orm['penfield.Newsletter']"}),
            'numbering': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterview': {
            'Meta': {'object_name': 'NewsletterView'},
            'article_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_article_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'article_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_article_related'", 'to': "orm['philo.Page']"}),
            'article_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'articles'", 'max_length': '255'}),
            'article_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feed_type': ('django.db.models.fields.CharField', [], {'default': "'atom'", 'max_length': '50'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_index_related'", 'to': "orm['philo.Page']"}),
            'issue_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_issue_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'issue_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_issue_related'", 'to': "orm['philo.Page']"}),
            'issue_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'issues'", 'max_length': '255'}),
            'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletterviews'", 'to': "orm['penfield.Newsletter']"})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['penfield']

########NEW FILE########
__FILENAME__ = 0004_auto__add_field_newsletterview_feed_length__add_field_blogview_feed_le
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from philo.migrations import person_model, frozen_person

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'NewsletterView.feed_length'
        db.add_column('penfield_newsletterview', 'feed_length', self.gf('django.db.models.fields.PositiveIntegerField')(default=15, null=True, blank=True), keep_default=False)

        # Adding field 'BlogView.feed_length'
        db.add_column('penfield_blogview', 'feed_length', self.gf('django.db.models.fields.PositiveIntegerField')(default=15, null=True, blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'NewsletterView.feed_length'
        db.delete_column('penfield_newsletterview', 'feed_length')

        # Deleting field 'BlogView.feed_length'
        db.delete_column('penfield_blogview', 'feed_length')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False', 'blank': 'True'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        person_model: frozen_person,
        'penfield.blog': {
            'Meta': {'object_name': 'Blog'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogentry': {
            'Meta': {'object_name': 'BlogEntry'},
            'author': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogentries'", 'to': "orm['%s']" % person_model}),
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'entries'", 'null': 'True', 'to': "orm['penfield.Blog']"}),
            'content': ('django.db.models.fields.TextField', [], {}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
            'excerpt': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'blogentries'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.blogview': {
            'Meta': {'object_name': 'BlogView'},
            'blog': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogviews'", 'to': "orm['penfield.Blog']"}),
            'entries_per_page': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
            'entry_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_entry_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'entry_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_entry_related'", 'to': "orm['philo.Page']"}),
            'entry_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'entries'", 'max_length': '255'}),
            'entry_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_length': ('django.db.models.fields.PositiveIntegerField', [], {'default': '15', 'null': 'True', 'blank': 'True'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feed_type': ('django.db.models.fields.CharField', [], {'default': "'application/atom+xml; charset=utf8'", 'max_length': '50'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_index_related'", 'to': "orm['philo.Page']"}),
            'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'tag_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_tag_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'tag_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_tag_related'", 'to': "orm['philo.Page']"}),
            'tag_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'tags'", 'max_length': '255'})
        },
        'penfield.newsletter': {
            'Meta': {'object_name': 'Newsletter'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterarticle': {
            'Meta': {'unique_together': "(('newsletter', 'slug'),)", 'object_name': 'NewsletterArticle'},
            'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'newsletterarticles'", 'symmetrical': 'False', 'to': "orm['%s']" % person_model}),
            'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
            'full_text': ('philo.models.fields.TemplateField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lede': ('philo.models.fields.TemplateField', [], {'null': 'True', 'blank': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['penfield.Newsletter']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'newsletterarticles'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterissue': {
            'Meta': {'unique_together': "(('newsletter', 'numbering'),)", 'object_name': 'NewsletterIssue'},
            'articles': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'issues'", 'symmetrical': 'False', 'to': "orm['penfield.NewsletterArticle']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'issues'", 'to': "orm['penfield.Newsletter']"}),
            'numbering': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'penfield.newsletterview': {
            'Meta': {'object_name': 'NewsletterView'},
            'article_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_article_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'article_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_article_related'", 'to': "orm['philo.Page']"}),
            'article_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'articles'", 'max_length': '255'}),
            'article_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'feed_length': ('django.db.models.fields.PositiveIntegerField', [], {'default': '15', 'null': 'True', 'blank': 'True'}),
            'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
            'feed_type': ('django.db.models.fields.CharField', [], {'default': "'application/atom+xml; charset=utf8'", 'max_length': '50'}),
            'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_index_related'", 'to': "orm['philo.Page']"}),
            'issue_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_issue_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
            'issue_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_issue_related'", 'to': "orm['philo.Page']"}),
            'issue_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'issues'", 'max_length': '255'}),
            'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletterviews'", 'to': "orm['penfield.Newsletter']"})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['penfield']

########NEW FILE########
__FILENAME__ = 0005_to_taggit
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models
from philo.migrations import person_model, frozen_person

class Migration(DataMigration):

	depends_on = (
		("philo", "0019_to_taggit"),
	)
	
	needed_by = (
		("philo", "0020_from_taggit"),
	)

	def forwards(self, orm):
		"Write your forwards methods here."
		BlogEntry = orm['penfield.BlogEntry']
		NewsletterArticle = orm['penfield.NewsletterArticle']
		TaggitTag = orm['taggit.Tag']
		TaggedItem = orm['taggit.TaggedItem']
		ContentType = orm['contenttypes.contenttype']
		
		entry_ct = ContentType.objects.get(app_label="penfield", model="blogentry")
		article_ct = ContentType.objects.get(app_label="penfield", model="newsletterarticle")
		
		for entry in BlogEntry.objects.all():
			for tag in entry.tags.all():
				ttag = TaggitTag.objects.get(slug=tag.slug)
				TaggedItem.objects.get_or_create(tag=ttag, content_type=entry_ct, object_id=entry.pk)
		
		for article in NewsletterArticle.objects.all():
			for tag in article.tags.all():
				ttag = TaggitTag.objects.get(slug=tag.slug)
				TaggedItem.objects.get_or_create(tag=ttag, content_type=article_ct, object_id=article.pk)


	def backwards(self, orm):
		"Write your backwards methods here."
		BlogEntry = orm['penfield.BlogEntry']
		NewsletterArticle = orm['penfield.NewsletterArticle']
		Tag = orm['philo.Tag']
		TaggitTag = orm['taggit.Tag']
		TaggedItem = orm['taggit.TaggedItem']
		ContentType = orm['contenttypes.contenttype']
		
		entry_ct = ContentType.objects.get(app_label="penfield", model="blogentry")
		article_ct = ContentType.objects.get(app_label="penfield", model="newsletterarticle")
		
		for entry in BlogEntry.objects.all():
			tag_slugs = list(TaggitTag.objects.filter(taggit_taggeditem_items__content_type=entry_ct, taggit_taggeditem_items__object_id=entry.pk).values_list('slug', flat=True).distinct())
			entry.tags = Tag.objects.filter(slug__in=tag_slugs)
			entry.save()
		
		for article in NewsletterArticle.objects.all():
			tag_slugs = list(TaggitTag.objects.filter(taggit_taggeditem_items__content_type=article_ct, taggit_taggeditem_items__object_id=article.pk).values_list('slug', flat=True).distinct())
			article.tags = Tag.objects.filter(slug__in=tag_slugs)
			article.save()


	models = {
		'auth.group': {
			'Meta': {'object_name': 'Group'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
			'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
		},
		'auth.permission': {
			'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
			'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
		},
		'auth.user': {
			'Meta': {'object_name': 'User'},
			'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
			'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
			'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
			'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
			'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
			'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
			'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
			'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
			'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
			'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
			'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
		},
		'contenttypes.contenttype': {
			'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
			'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
		},
		person_model: frozen_person,
		'penfield.blog': {
			'Meta': {'object_name': 'Blog'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.blogentry': {
			'Meta': {'ordering': "['-date']", 'object_name': 'BlogEntry'},
			'author': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogentries'", 'to': "orm['%s']" % person_model}),
			'blog': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'entries'", 'null': 'True', 'to': "orm['penfield.Blog']"}),
			'content': ('django.db.models.fields.TextField', [], {}),
			'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
			'excerpt': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'blogentries'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.blogview': {
			'Meta': {'object_name': 'BlogView'},
			'blog': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogviews'", 'to': "orm['penfield.Blog']"}),
			'entries_per_page': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
			'entry_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_entry_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'entry_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_entry_related'", 'to': "orm['philo.Page']"}),
			'entry_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'entries'", 'max_length': '255'}),
			'entry_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
			'feed_length': ('django.db.models.fields.PositiveIntegerField', [], {'default': '15', 'null': 'True', 'blank': 'True'}),
			'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
			'feed_type': ('django.db.models.fields.CharField', [], {'default': "'atom'", 'max_length': '50'}),
			'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_index_related'", 'to': "orm['philo.Page']"}),
			'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'tag_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_tag_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'tag_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_tag_related'", 'to': "orm['philo.Page']"}),
			'tag_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'tags'", 'max_length': '255'})
		},
		'penfield.newsletter': {
			'Meta': {'object_name': 'Newsletter'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.newsletterarticle': {
			'Meta': {'ordering': "['-date']", 'unique_together': "(('newsletter', 'slug'),)", 'object_name': 'NewsletterArticle'},
			'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'newsletterarticles'", 'symmetrical': 'False', 'to': "orm['%s']" % person_model}),
			'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
			'full_text': ('philo.models.fields.TemplateField', [], {'db_index': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'lede': ('philo.models.fields.TemplateField', [], {'null': 'True', 'blank': 'True'}),
			'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['penfield.Newsletter']"}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tags': ('django.db.models.fields.related.ManyToManyField', [], {'blank': 'True', 'related_name': "'newsletterarticles'", 'null': 'True', 'symmetrical': 'False', 'to': "orm['philo.Tag']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.newsletterissue': {
			'Meta': {'ordering': "['-numbering']", 'unique_together': "(('newsletter', 'numbering'),)", 'object_name': 'NewsletterIssue'},
			'articles': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'issues'", 'symmetrical': 'False', 'to': "orm['penfield.NewsletterArticle']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'issues'", 'to': "orm['penfield.Newsletter']"}),
			'numbering': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.newsletterview': {
			'Meta': {'object_name': 'NewsletterView'},
			'article_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_article_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'article_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_article_related'", 'to': "orm['philo.Page']"}),
			'article_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'articles'", 'max_length': '255'}),
			'article_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
			'feed_length': ('django.db.models.fields.PositiveIntegerField', [], {'default': '15', 'null': 'True', 'blank': 'True'}),
			'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
			'feed_type': ('django.db.models.fields.CharField', [], {'default': "'atom'", 'max_length': '50'}),
			'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_index_related'", 'to': "orm['philo.Page']"}),
			'issue_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_issue_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'issue_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_issue_related'", 'to': "orm['philo.Page']"}),
			'issue_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'issues'", 'max_length': '255'}),
			'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletterviews'", 'to': "orm['penfield.Newsletter']"})
		},
		'philo.attribute': {
			'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
			'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
			'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.node': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.page': {
			'Meta': {'object_name': 'Page'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.tag': {
			'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
		},
		'philo.template': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
			'code': ('philo.models.fields.TemplateField', [], {}),
			'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
		},
		'taggit.tag': {
			'Meta': {'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
		},
		'taggit.taggeditem': {
			'Meta': {'object_name': 'TaggedItem'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_tagged_items'", 'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
			'tag': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_items'", 'to': "orm['taggit.Tag']"})
		}
	}

	complete_apps = ['penfield', 'taggit']
	symmetrical = True

########NEW FILE########
__FILENAME__ = 0006_delete_tag_rels
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from philo.migrations import person_model, frozen_person

class Migration(SchemaMigration):

	needed_by = (
		('philo', '0021_auto__del_tag'),
	)

	def forwards(self, orm):
		
		# Removing M2M table for field tags on 'BlogEntry'
		db.delete_table('penfield_blogentry_tags')

		# Removing M2M table for field tags on 'NewsletterArticle'
		db.delete_table('penfield_newsletterarticle_tags')


	def backwards(self, orm):
		
		# Adding M2M table for field tags on 'BlogEntry'
		db.create_table('penfield_blogentry_tags', (
			('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
			('blogentry', models.ForeignKey(orm['penfield.blogentry'], null=False)),
			('tag', models.ForeignKey(orm['philo.tag'], null=False))
		))
		db.create_unique('penfield_blogentry_tags', ['blogentry_id', 'tag_id'])

		# Adding M2M table for field tags on 'NewsletterArticle'
		db.create_table('penfield_newsletterarticle_tags', (
			('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
			('newsletterarticle', models.ForeignKey(orm['penfield.newsletterarticle'], null=False)),
			('tag', models.ForeignKey(orm['philo.tag'], null=False))
		))
		db.create_unique('penfield_newsletterarticle_tags', ['newsletterarticle_id', 'tag_id'])


	models = {
		'auth.group': {
			'Meta': {'object_name': 'Group'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
			'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
		},
		'auth.permission': {
			'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
			'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
		},
		'auth.user': {
			'Meta': {'object_name': 'User'},
			'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
			'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
			'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
			'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
			'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
			'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
			'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
			'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
			'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
			'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
			'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
		},
		'contenttypes.contenttype': {
			'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
			'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
		},
		person_model: frozen_person,
		'penfield.blog': {
			'Meta': {'object_name': 'Blog'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.blogentry': {
			'Meta': {'object_name': 'BlogEntry'},
			'author': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogentries'", 'to': "orm['%s']" % person_model}),
			'blog': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'entries'", 'null': 'True', 'to': "orm['penfield.Blog']"}),
			'content': ('django.db.models.fields.TextField', [], {}),
			'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
			'excerpt': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.blogview': {
			'Meta': {'object_name': 'BlogView'},
			'blog': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blogviews'", 'to': "orm['penfield.Blog']"}),
			'entries_per_page': ('django.db.models.fields.IntegerField', [], {'null': 'True', 'blank': 'True'}),
			'entry_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_entry_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'entry_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_entry_related'", 'to': "orm['philo.Page']"}),
			'entry_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'entries'", 'max_length': '255'}),
			'entry_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
			'feed_length': ('django.db.models.fields.PositiveIntegerField', [], {'default': '15', 'null': 'True', 'blank': 'True'}),
			'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
			'feed_type': ('django.db.models.fields.CharField', [], {'default': "'atom'", 'max_length': '50'}),
			'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_index_related'", 'to': "orm['philo.Page']"}),
			'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_blogview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'tag_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blog_tag_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'tag_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'blog_tag_related'", 'to': "orm['philo.Page']"}),
			'tag_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'tags'", 'max_length': '255'})
		},
		'penfield.newsletter': {
			'Meta': {'object_name': 'Newsletter'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.newsletterarticle': {
			'Meta': {'ordering': "['-date']", 'unique_together': "(('newsletter', 'slug'),)", 'object_name': 'NewsletterArticle'},
			'authors': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'newsletterarticles'", 'symmetrical': 'False', 'to': "orm['%s']" % person_model}),
			'date': ('django.db.models.fields.DateTimeField', [], {'default': 'None'}),
			'full_text': ('philo.models.fields.TemplateField', [], {'db_index': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'lede': ('philo.models.fields.TemplateField', [], {'null': 'True', 'blank': 'True'}),
			'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'articles'", 'to': "orm['penfield.Newsletter']"}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.newsletterissue': {
			'Meta': {'ordering': "['-numbering']", 'unique_together': "(('newsletter', 'numbering'),)", 'object_name': 'NewsletterIssue'},
			'articles': ('django.db.models.fields.related.ManyToManyField', [], {'related_name': "'issues'", 'symmetrical': 'False', 'to': "orm['penfield.NewsletterArticle']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'issues'", 'to': "orm['penfield.Newsletter']"}),
			'numbering': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'penfield.newsletterview': {
			'Meta': {'object_name': 'NewsletterView'},
			'article_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_article_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'article_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_article_related'", 'to': "orm['philo.Page']"}),
			'article_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'articles'", 'max_length': '255'}),
			'article_permalink_style': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
			'feed_length': ('django.db.models.fields.PositiveIntegerField', [], {'default': '15', 'null': 'True', 'blank': 'True'}),
			'feed_suffix': ('django.db.models.fields.CharField', [], {'default': "'feed'", 'max_length': '255'}),
			'feed_type': ('django.db.models.fields.CharField', [], {'default': "'atom'", 'max_length': '50'}),
			'feeds_enabled': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_index_related'", 'to': "orm['philo.Page']"}),
			'issue_archive_page': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'newsletter_issue_archive_related'", 'null': 'True', 'to': "orm['philo.Page']"}),
			'issue_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletter_issue_related'", 'to': "orm['philo.Page']"}),
			'issue_permalink_base': ('django.db.models.fields.CharField', [], {'default': "'issues'", 'max_length': '255'}),
			'item_description_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_description_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'item_title_template': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'penfield_newsletterview_title_related'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'newsletter': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'newsletterviews'", 'to': "orm['penfield.Newsletter']"})
		},
		'philo.attribute': {
			'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
			'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
			'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.node': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.page': {
			'Meta': {'object_name': 'Page'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.template': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
			'code': ('philo.models.fields.TemplateField', [], {}),
			'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
		},
		'taggit.tag': {
			'Meta': {'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
		},
		'taggit.taggeditem': {
			'Meta': {'object_name': 'TaggedItem'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_tagged_items'", 'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
			'tag': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_items'", 'to': "orm['taggit.Tag']"})
		}
	}

	complete_apps = ['penfield', 'taggit']

########NEW FILE########
__FILENAME__ = models
# encoding: utf-8
from datetime import date, datetime

from django.conf import settings
from django.conf.urls.defaults import url, patterns, include
from django.db import models
from django.http import Http404, HttpResponse
from taggit.managers import TaggableManager
from taggit.models import Tag, TaggedItem

from philo.contrib.winer.models import FeedView
from philo.exceptions import ViewCanNotProvideSubpath
from philo.models import Entity, Page, register_value_model
from philo.models.fields import TemplateField
from philo.utils import paginate


class Blog(Entity):
	"""Represents a blog which can be posted to."""
	#: The name of the :class:`Blog`, currently called 'title' for historical reasons.
	title = models.CharField(max_length=255)
	
	#: A slug used to identify the :class:`Blog`.
	slug = models.SlugField(max_length=255)
	
	def __unicode__(self):
		return self.title
	
	@property
	def entry_tags(self):
		"""Returns a :class:`QuerySet` of :class:`.Tag`\ s that are used on any entries in this blog."""
		entry_pks = list(self.entries.values_list('pk', flat=True))
		kwargs = {
			'%s__object_id__in' % TaggedItem.tag_relname(): entry_pks
		}
		return TaggedItem.tags_for(BlogEntry).filter(**kwargs)
	
	@property
	def entry_dates(self):
		"""Returns a dictionary of date :class:`QuerySet`\ s for years, months, and days for which there are entries."""
		dates = {'year': self.entries.dates('date', 'year', order='DESC'), 'month': self.entries.dates('date', 'month', order='DESC'), 'day': self.entries.dates('date', 'day', order='DESC')}
		return dates


register_value_model(Blog)


class BlogEntry(Entity):
	"""Represents an entry in a :class:`Blog`."""
	#: The title of the :class:`BlogEntry`.
	title = models.CharField(max_length=255)
	
	#: A slug which identifies the :class:`BlogEntry`.
	slug = models.SlugField(max_length=255)
	
	#: The :class:`Blog` which this entry has been posted to. Can be left blank to represent a "draft" status.
	blog = models.ForeignKey(Blog, related_name='entries', blank=True, null=True)
	
	#: A :class:`ForeignKey` to the author. The model is either :setting:`PHILO_PERSON_MODULE` or :class:`auth.User`.
	author = models.ForeignKey(getattr(settings, 'PHILO_PERSON_MODULE', 'auth.User'), related_name='blogentries')
	
	#: The date and time which the :class:`BlogEntry` is considered posted at.
	date = models.DateTimeField(default=None)
	
	#: The content of the :class:`BlogEntry`.
	content = TemplateField()
	
	#: An optional brief excerpt from the :class:`BlogEntry`.
	excerpt = TemplateField(blank=True, null=True)
	
	#: A ``django-taggit`` :class:`TaggableManager`.
	tags = TaggableManager()
	
	def save(self, *args, **kwargs):
		if self.date is None:
			self.date = datetime.now()
		super(BlogEntry, self).save(*args, **kwargs)
	
	def __unicode__(self):
		return self.title
	
	class Meta:
		ordering = ['-date']
		verbose_name_plural = "blog entries"
		get_latest_by = "date"


register_value_model(BlogEntry)


class BlogView(FeedView):
	"""
	A subclass of :class:`.FeedView` which handles patterns and feeds for a :class:`Blog` and its related :class:`entries <BlogEntry>`.
	
	"""
	ENTRY_PERMALINK_STYLE_CHOICES = (
		('D', 'Year, month, and day'),
		('M', 'Year and month'),
		('Y', 'Year'),
		('B', 'Custom base'),
		('N', 'No base')
	)
	
	#: The :class:`Blog` whose entries should be managed by this :class:`BlogView`
	blog = models.ForeignKey(Blog, related_name='blogviews')
	
	#: The main page of the :class:`Blog` will be rendered with this :class:`.Page`.
	index_page = models.ForeignKey(Page, related_name='blog_index_related')
	#: The detail view of a :class:`BlogEntry` will be rendered with this :class:`Page`.
	entry_page = models.ForeignKey(Page, related_name='blog_entry_related')
	# TODO: entry_archive is misleading. Rename to ymd_page or timespan_page.
	#: Views of :class:`BlogEntry` archives will be rendered with this :class:`Page` (optional).
	entry_archive_page = models.ForeignKey(Page, related_name='blog_entry_archive_related', null=True, blank=True)
	#: Views of :class:`BlogEntry` archives according to their :class:`.Tag`\ s will be rendered with this :class:`Page`.
	tag_page = models.ForeignKey(Page, related_name='blog_tag_related')
	#: The archive of all available tags will be rendered with this :class:`Page` (optional).
	tag_archive_page = models.ForeignKey(Page, related_name='blog_tag_archive_related', null=True, blank=True)
	#: This number will be passed directly into pagination for :class:`BlogEntry` list pages. Pagination will be disabled if this is left blank.
	entries_per_page = models.IntegerField(blank=True, null=True)
	
	#: Depending on the needs of the site, different permalink styles may be appropriate. Example subpaths are provided for a :class:`BlogEntry` posted on May 2nd, 2011 with a slug of "hello". The choices are:
	#: 
	#: 	* Year, month, and day - ``2011/05/02/hello``
	#: 	* Year and month - ``2011/05/hello``
	#: 	* Year - ``2011/hello``
	#: 	* Custom base - :attr:`entry_permalink_base`\ ``/hello``
	#: 	* No base - ``hello``
	entry_permalink_style = models.CharField(max_length=1, choices=ENTRY_PERMALINK_STYLE_CHOICES)
	#: If the :attr:`entry_permalink_style` is set to "Custom base" then the value of this field will be used as the base subpath for year/month/day entry archive pages and entry detail pages. Default: "entries"
	entry_permalink_base = models.CharField(max_length=255, blank=False, default='entries')
	#: This will be used as the base for the views of :attr:`tag_page` and :attr:`tag_archive_page`. Default: "tags"
	tag_permalink_base = models.CharField(max_length=255, blank=False, default='tags')
	
	item_context_var = 'entries'
	
	def __unicode__(self):
		return u'BlogView for %s' % self.blog.title
	
	def get_reverse_params(self, obj):
		if isinstance(obj, BlogEntry):
			if obj.blog_id == self.blog_id:
				kwargs = {'slug': obj.slug}
				if self.entry_permalink_style in 'DMY':
					kwargs.update({'year': str(obj.date.year).zfill(4)})
					if self.entry_permalink_style in 'DM':
						kwargs.update({'month': str(obj.date.month).zfill(2)})
						if self.entry_permalink_style == 'D':
							kwargs.update({'day': str(obj.date.day).zfill(2)})
				return self.entry_view, [], kwargs
		elif isinstance(obj, Tag) or (isinstance(obj, models.query.QuerySet) and obj.model == Tag and obj):
			if isinstance(obj, Tag):
				obj = [obj]
			slugs = [tag.slug for tag in obj if tag in self.get_tag_queryset(self.blog)]
			if slugs:
				return 'entries_by_tag', [], {'tag_slugs': "/".join(slugs)}
		elif isinstance(obj, (date, datetime)):
			kwargs = {
				'year': str(obj.year).zfill(4),
				'month': str(obj.month).zfill(2),
				'day': str(obj.day).zfill(2)
			}
			return 'entries_by_day', [], kwargs
		raise ViewCanNotProvideSubpath
	
	@property
	def urlpatterns(self):
		urlpatterns = self.feed_patterns(r'^', 'get_entries', 'index_page', 'index') +\
			self.feed_patterns(r'^%s/(?P<tag_slugs>[-\w]+[-+/\w]*)' % self.tag_permalink_base, 'get_entries', 'tag_page', 'entries_by_tag')
		
		if self.tag_archive_page_id:
			urlpatterns += patterns('',
				url((r'^%s$' % self.tag_permalink_base), self.tag_archive_view, name='tag_archive')
			)
		
		if self.entry_archive_page_id:
			if self.entry_permalink_style in 'DMY':
				urlpatterns += self.feed_patterns(r'^(?P<year>\d{4})', 'get_entries', 'entry_archive_page', 'entries_by_year')
				if self.entry_permalink_style in 'DM':
					urlpatterns += self.feed_patterns(r'^(?P<year>\d{4})/(?P<month>\d{2})', 'get_entries', 'entry_archive_page', 'entries_by_month')
					if self.entry_permalink_style == 'D':
						urlpatterns += self.feed_patterns(r'^(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})', 'get_entries', 'entry_archive_page', 'entries_by_day')
		
		if self.entry_permalink_style == 'D':
			urlpatterns += patterns('',
				url(r'^(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})/(?P<slug>[-\w]+)$', self.entry_view)
			)
		elif self.entry_permalink_style == 'M':
			urlpatterns += patterns('',
				url(r'^(?P<year>\d{4})/(?P<month>\d{2})/(?P<slug>[-\w]+)$', self.entry_view)
			)
		elif self.entry_permalink_style == 'Y':
			urlpatterns += patterns('',
				url(r'^(?P<year>\d{4})/(?P<slug>[-\w]+)$', self.entry_view)
			)
		elif self.entry_permalink_style == 'B':
			urlpatterns += patterns('',
				url((r'^%s/(?P<slug>[-\w]+)$' % self.entry_permalink_base), self.entry_view)
			)
		else:
			urlpatterns += patterns('',
				url(r'^(?P<slug>[-\w]+)$', self.entry_view)
			)
		return urlpatterns
	
	def get_entry_queryset(self, obj):
		"""Returns the default :class:`QuerySet` of :class:`BlogEntry` instances for the :class:`BlogView` - all entries that are considered posted in the past. This allows for scheduled posting of entries."""
		return obj.entries.filter(date__lte=datetime.now())
	
	def get_tag_queryset(self, obj):
		"""Returns the default :class:`QuerySet` of :class:`.Tag`\ s for the :class:`BlogView`'s :meth:`get_entries_by_tag` and :meth:`tag_archive_view`."""
		return obj.entry_tags
	
	def get_object(self, request, year=None, month=None, day=None, tag_slugs=None):
		"""Returns a dictionary representing the parameters for a feed which will be exposed."""
		if tag_slugs is None:
			tags = None
		else:
			tag_slugs = tag_slugs.replace('+', '/').split('/')
			tags = self.get_tag_queryset(self.blog).filter(slug__in=tag_slugs)
			if not tags:
				raise Http404
			
			# Raise a 404 on an incorrect slug.
			found_slugs = set([tag.slug for tag in tags])
			for slug in tag_slugs:
				if slug and slug not in found_slugs:
					raise Http404
		
		try:
			if year and month and day:
				context_date = date(int(year), int(month), int(day))
			elif year and month:
				context_date = date(int(year), int(month), 1)
			elif year:
				context_date = date(int(year), 1, 1)
			else:
				context_date = None
		except TypeError, ValueError:
			context_date = None
		
		return {
			'blog': self.blog,
			'tags': tags,
			'year': year,
			'month': month,
			'day': day,
			'date': context_date
		}
	
	def get_entries(self, obj, request, year=None, month=None, day=None, tag_slugs=None, extra_context=None):
		"""Returns the :class:`BlogEntry` objects which will be exposed for the given object, as returned from :meth:`get_object`."""
		entries = self.get_entry_queryset(obj['blog'])
		
		if obj['tags'] is not None:
			tags = obj['tags']
			for tag in tags:
				entries = entries.filter(tags=tag)
		
		if obj['date'] is not None:
			if year:
				entries = entries.filter(date__year=year)
			if month:
				entries = entries.filter(date__month=month)
			if day:
				entries = entries.filter(date__day=day)
		
		context = extra_context or {}
		context.update(obj)
		
		return entries, context
	
	def entry_view(self, request, slug, year=None, month=None, day=None, extra_context=None):
		"""Renders :attr:`entry_page` with the entry specified by the given parameters."""
		entries = self.get_entry_queryset(self.blog)
		if year:
			entries = entries.filter(date__year=year)
		if month:
			entries = entries.filter(date__month=month)
		if day:
			entries = entries.filter(date__day=day)
		try:
			entry = entries.get(slug=slug)
		except:
			raise Http404
		context = self.get_context()
		context.update(extra_context or {})
		context.update({'entry': entry})
		return self.entry_page.render_to_response(request, extra_context=context)
	
	def tag_archive_view(self, request, extra_context=None):
		"""Renders :attr:`tag_archive_page` with the result of :meth:`get_tag_queryset` added to the context."""
		if not self.tag_archive_page:
			raise Http404
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'tags': self.get_tag_queryset(self.blog)
		})
		return self.tag_archive_page.render_to_response(request, extra_context=context)
	
	def process_page_items(self, request, items):
		"""Overrides :meth:`.FeedView.process_page_items` to add pagination."""
		if self.entries_per_page:
			page_num = request.GET.get('page', 1)
			paginator, paginated_page, items = paginate(items, self.entries_per_page, page_num)
			item_context = {
				'paginator': paginator,
				'paginated_page': paginated_page,
				self.item_context_var: items
			}
		else:
			item_context = {
				self.item_context_var: items
			}
		return items, item_context
	
	def title(self, obj):
		title = obj['blog'].title
		if obj['tags']:
			title += u"  %s" % u", ".join((tag.name for tag in obj['tags']))
		date = obj['date']
		if date:
			if obj['day']:
				datestr = date.strftime("%F %j, %Y")
			elif obj['month']:
				datestr = date.strftime("%F, %Y")
			elif obj['year']:
				datestr = date.strftime("%Y")
			title += u"  %s" % datestr
		return title
	
	def categories(self, obj):
		tags = obj['tags']
		if tags:
			return (tag.name for tag in tags)
		return None
	
	def item_title(self, item):
		return item.title
	
	def item_description(self, item):
		return item.content
	
	def item_author_name(self, item):
		return item.author.get_full_name()
	
	def item_pubdate(self, item):
		return item.date
	
	def item_categories(self, item):
		return [tag.name for tag in item.tags.all()]


class Newsletter(Entity):
	"""Represents a newsletter which will contain :class:`articles <NewsletterArticle>` organized into :class:`issues <NewsletterIssue>`."""
	#: The name of the :class:`Newsletter`, currently callse 'title' for historical reasons.
	title = models.CharField(max_length=255)
	#: A slug used to identify the :class:`Newsletter`.
	slug = models.SlugField(max_length=255)
	
	def __unicode__(self):
		return self.title


register_value_model(Newsletter)


class NewsletterArticle(Entity):
	"""Represents an article in a :class:`Newsletter`"""
	#: The title of the :class:`NewsletterArticle`.
	title = models.CharField(max_length=255)
	#: A slug which identifies the :class:`NewsletterArticle`.
	slug = models.SlugField(max_length=255)
	#: A :class:`ForeignKey` to :class:`Newsletter` representing the newsletter which this article was written for.
	newsletter = models.ForeignKey(Newsletter, related_name='articles')
	#: A :class:`ManyToManyField` to the author(s) of the :class:`NewsletterArticle`. The model is either :setting:`PHILO_PERSON_MODULE` or :class:`auth.User`.
	authors = models.ManyToManyField(getattr(settings, 'PHILO_PERSON_MODULE', 'auth.User'), related_name='newsletterarticles')
	#: The date and time which the :class:`NewsletterArticle` is considered published at.
	date = models.DateTimeField(default=None)
	#: A :class:`.TemplateField` containing an optional short summary of the article, meant to grab a reader's attention and draw them in.
	lede = TemplateField(null=True, blank=True, verbose_name='Summary')
	#: A :class:`.TemplateField` containing the full text of the article.
	full_text = TemplateField(db_index=True)
	#: A ``django-taggit`` :class:`TaggableManager`.
	tags = TaggableManager()
	
	def save(self, *args, **kwargs):
		if self.date is None:
			self.date = datetime.now()
		super(NewsletterArticle, self).save(*args, **kwargs)
	
	def __unicode__(self):
		return self.title
	
	class Meta:
		get_latest_by = 'date'
		ordering = ['-date']
		unique_together = (('newsletter', 'slug'),)


register_value_model(NewsletterArticle)


class NewsletterIssue(Entity):
	"""Represents an issue of the newsletter."""
	#: The title of the :class:`NewsletterIssue`.
	title = models.CharField(max_length=255)
	#: A slug which identifies the :class:`NewsletterIssue`.
	slug = models.SlugField(max_length=255)
	#: A :class:`ForeignKey` to the :class:`Newsletter` which this issue belongs to.
	newsletter = models.ForeignKey(Newsletter, related_name='issues')
	#: The numbering of the issue - for example, 04.02 for volume 4, issue 2. This is an instance of :class:`CharField` to allow any arbitrary numbering system.
	numbering = models.CharField(max_length=50, help_text='For example, 04.02 for volume 4, issue 2.')
	#: A :class:`ManyToManyField` to articles belonging to this issue.
	articles = models.ManyToManyField(NewsletterArticle, related_name='issues')
	
	def __unicode__(self):
		return self.title
	
	class Meta:
		ordering = ['-numbering']
		unique_together = (('newsletter', 'numbering'),)


register_value_model(NewsletterIssue)


class NewsletterView(FeedView):
	"""A subclass of :class:`.FeedView` which handles patterns and feeds for a :class:`Newsletter` and its related :class:`articles <NewsletterArticle>`."""
	ARTICLE_PERMALINK_STYLE_CHOICES = (
		('D', 'Year, month, and day'),
		('M', 'Year and month'),
		('Y', 'Year'),
		('S', 'Slug only')
	)
	
	#: A :class:`ForeignKey` to the :class:`Newsletter` managed by this :class:`NewsletterView`.
	newsletter = models.ForeignKey(Newsletter, related_name='newsletterviews')
	
	#: A :class:`ForeignKey` to the :class:`Page` used to render the main page of this :class:`NewsletterView`.
	index_page = models.ForeignKey(Page, related_name='newsletter_index_related')
	#: A :class:`ForeignKey` to the :class:`Page` used to render the detail view of a :class:`NewsletterArticle` for this :class:`NewsletterView`.
	article_page = models.ForeignKey(Page, related_name='newsletter_article_related')
	#: A :class:`ForeignKey` to the :class:`Page` used to render the :class:`NewsletterArticle` archive pages for this :class:`NewsletterView`.
	article_archive_page = models.ForeignKey(Page, related_name='newsletter_article_archive_related', null=True, blank=True)
	#: A :class:`ForeignKey` to the :class:`Page` used to render the detail view of a :class:`NewsletterIssue` for this :class:`NewsletterView`.
	issue_page = models.ForeignKey(Page, related_name='newsletter_issue_related')
	#: A :class:`ForeignKey` to the :class:`Page` used to render the :class:`NewsletterIssue` archive pages for this :class:`NewsletterView`.
	issue_archive_page = models.ForeignKey(Page, related_name='newsletter_issue_archive_related', null=True, blank=True)
	
	#: Depending on the needs of the site, different permalink styles may be appropriate. Example subpaths are provided for a :class:`NewsletterArticle` posted on May 2nd, 2011 with a slug of "hello". The choices are:
	#: 
	#: 	* Year, month, and day - :attr:`article_permalink_base`\ ``/2011/05/02/hello``
	#: 	* Year and month - :attr:`article_permalink_base`\ ``/2011/05/hello``
	#: 	* Year - :attr:`article_permalink_base`\ ``/2011/hello``
	#: 	* Slug only - :attr:`article_permalink_base`\ ``/hello``
	article_permalink_style = models.CharField(max_length=1, choices=ARTICLE_PERMALINK_STYLE_CHOICES)
	#: This will be used as the base subpath for year/month/day article archive pages and article detail pages. Default: "articles"
	article_permalink_base = models.CharField(max_length=255, blank=False, default='articles')
	#: This will be used as the base subpath for issue detail pages and the issue archive page.
	issue_permalink_base = models.CharField(max_length=255, blank=False, default='issues')
	
	item_context_var = 'articles'
	object_attr = 'newsletter'
	
	def __unicode__(self):
		return "NewsletterView for %s" % self.newsletter.__unicode__()
	
	def get_reverse_params(self, obj):
		if isinstance(obj, NewsletterArticle):
			if obj.newsletter_id == self.newsletter_id:
				kwargs = {'slug': obj.slug}
				if self.article_permalink_style in 'DMY':
					kwargs.update({'year': str(obj.date.year).zfill(4)})
					if self.article_permalink_style in 'DM':
						kwargs.update({'month': str(obj.date.month).zfill(2)})
						if self.article_permalink_style == 'D':
							kwargs.update({'day': str(obj.date.day).zfill(2)})
				return self.article_view, [], kwargs
		elif isinstance(obj, NewsletterIssue):
			if obj.newsletter_id == self.newsletter_id:
				return 'issue', [], {'numbering': obj.numbering}
		elif isinstance(obj, (date, datetime)):
			kwargs = {
				'year': str(obj.year).zfill(4),
				'month': str(obj.month).zfill(2),
				'day': str(obj.day).zfill(2)
			}
			return 'articles_by_day', [], kwargs
		raise ViewCanNotProvideSubpath
	
	@property
	def urlpatterns(self):
		urlpatterns = self.feed_patterns(r'^', 'get_all_articles', 'index_page', 'index') + patterns('',
			url(r'^%s/(?P<numbering>.+)$' % self.issue_permalink_base, self.page_view('get_articles_by_issue', 'issue_page'), name='issue')
		)
		if self.issue_archive_page_id:
			urlpatterns += patterns('',
				url(r'^%s$' % self.issue_permalink_base, self.issue_archive_view, 'issue_archive')
			)
		if self.article_archive_page_id:
			urlpatterns += self.feed_patterns(r'^%s' % self.article_permalink_base, 'get_all_articles', 'article_archive_page', 'articles')
			if self.article_permalink_style in 'DMY':
				urlpatterns += self.feed_patterns(r'^%s/(?P<year>\d{4})' % self.article_permalink_base, 'get_articles_by_ymd', 'article_archive_page', 'articles_by_year')
				if self.article_permalink_style in 'DM':
					urlpatterns += self.feed_patterns(r'^%s/(?P<year>\d{4})/(?P<month>\d{2})' % self.article_permalink_base, 'get_articles_by_ymd', 'article_archive_page', 'articles_by_month')
					if self.article_permalink_style == 'D':
						urlpatterns += self.feed_patterns(r'^%s/(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})' % self.article_permalink_base, 'get_articles_by_ymd', 'article_archive_page', 'articles_by_day')
		
		if self.article_permalink_style == 'Y':
			urlpatterns += patterns('',
				url(r'^%s/(?P<year>\d{4})/(?P<slug>[\w-]+)$' % self.article_permalink_base, self.article_view)
			)
		elif self.article_permalink_style == 'M':
			urlpatterns += patterns('',
				url(r'^%s/(?P<year>\d{4})/(?P<month>\d{2})/(?P<slug>[\w-]+)$' % self.article_permalink_base, self.article_view)
			)
		elif self.article_permalink_style == 'D':
			urlpatterns += patterns('',
				url(r'^%s/(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})/(?P<slug>[\w-]+)$' % self.article_permalink_base, self.article_view)
			)
		else:	
			urlpatterns += patterns('',
				url(r'^%s/(?P<slug>[-\w]+)$' % self.article_permalink_base, self.article_view)
			)
		
		return urlpatterns
	
	def get_context(self):
		return {'newsletter': self.newsletter}
	
	def get_article_queryset(self, obj):
		"""Returns the default :class:`QuerySet` of :class:`NewsletterArticle` instances for the :class:`NewsletterView` - all articles that are considered posted in the past. This allows for scheduled posting of articles."""
		return obj.articles.filter(date__lte=datetime.now())
	
	def get_issue_queryset(self, obj):
		"""Returns the default :class:`QuerySet` of :class:`NewsletterIssue` instances for the :class:`NewsletterView`."""
		return obj.issues.all()
	
	def get_all_articles(self, obj, request, extra_context=None):
		"""Used to generate :meth:`~.FeedView.feed_patterns` for all entries."""
		return self.get_article_queryset(obj), extra_context
	
	def get_articles_by_ymd(self, obj, request, year, month=None, day=None, extra_context=None):
		"""Used to generate :meth:`~.FeedView.feed_patterns` for a specific year, month, and day."""
		articles = self.get_article_queryset(obj).filter(date__year=year)
		if month:
			articles = articles.filter(date__month=month)
		if day:
			articles = articles.filter(date__day=day)
		return articles, extra_context
	
	def get_articles_by_issue(self, obj, request, numbering, extra_context=None):
		"""Used to generate :meth:`~.FeedView.feed_patterns` for articles from a certain issue."""
		try:
			issue = self.get_issue_queryset(obj).get(numbering=numbering)
		except NewsletterIssue.DoesNotExist:
			raise Http404
		context = extra_context or {}
		context.update({'issue': issue})
		return self.get_article_queryset(obj).filter(issues=issue), context
	
	def article_view(self, request, slug, year=None, month=None, day=None, extra_context=None):
		"""Renders :attr:`article_page` with the article specified by the given parameters."""
		articles = self.get_article_queryset(self.newsletter)
		if year:
			articles = articles.filter(date__year=year)
		if month:
			articles = articles.filter(date__month=month)
		if day:
			articles = articles.filter(date__day=day)
		try:
			article = articles.get(slug=slug)
		except NewsletterArticle.DoesNotExist:
			raise Http404
		context = self.get_context()
		context.update(extra_context or {})
		context.update({'article': article})
		return self.article_page.render_to_response(request, extra_context=context)
	
	def issue_archive_view(self, request, extra_context):
		"""Renders :attr:`issue_archive_page` with the result of :meth:`get_issue_queryset` added to the context."""
		if not self.issue_archive_page:
			raise Http404
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'issues': self.get_issue_queryset(self.newsletter)
		})
		return self.issue_archive_page.render_to_response(request, extra_context=context)
	
	def title(self, obj):
		return obj.title
	
	def item_title(self, item):
		return item.title
	
	def item_description(self, item):
		return item.full_text
	
	def item_author_name(self, item):
		authors = list(item.authors.all())
		if len(authors) > 1:
			return "%s and %s" % (", ".join([author.get_full_name() for author in authors[:-1]]), authors[-1].get_full_name())
		elif authors:
			return authors[0].get_full_name()
		else:
			return ''
	
	def item_pubdate(self, item):
		return item.date
	
	def item_categories(self, item):
		return [tag.name for tag in item.tags.all()]
########NEW FILE########
__FILENAME__ = penfield
"""
Penfield supplies two template filters to handle common use cases for blogs and newsletters.

"""
from django import template
from django.utils.dates import MONTHS, MONTHS_AP


register = template.Library()


@register.filter
def monthname(value):
	"""Returns the name of a month with the supplied numeric value."""
	try:
		value = int(value)
	except:
		pass
	
	try:
		return MONTHS[value]
	except KeyError:
		return value


@register.filter
def apmonthname(value):
	"""Returns the Associated Press abbreviated month name for the supplied numeric value."""
	try:
		value = int(value)
	except:
		pass
	
	try:
		return MONTHS_AP[value]
	except KeyError:
		return value
########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from philo.admin import TreeEntityAdmin, COLLAPSE_CLASSES, NodeAdmin, EntityAdmin
from philo.models import Node
from philo.contrib.shipherd.models import NavigationItem, Navigation


NAVIGATION_RAW_ID_FIELDS = ('navigation', 'parent', 'target_node')


class NavigationItemInline(admin.StackedInline):
	raw_id_fields = NAVIGATION_RAW_ID_FIELDS
	model = NavigationItem
	extra = 0
	sortable_field_name = 'order'
	ordering = ('order',)
	related_lookup_fields = {'fk': raw_id_fields}


class NavigationItemChildInline(NavigationItemInline):
	verbose_name = "child"
	verbose_name_plural = "children"
	fieldsets = (
		(None, {
			'fields': ('text', 'parent')
		}),
		('Target', {
			'fields': ('target_node', 'url_or_subpath',)
		}),
		('Advanced', {
			'fields': ('reversing_parameters', 'order'),
			'classes': COLLAPSE_CLASSES
		})
	)


class NavigationNavigationItemInline(NavigationItemInline):
	fieldsets = (
		(None, {
			'fields': ('text', 'navigation')
		}),
		('Target', {
			'fields': ('target_node', 'url_or_subpath',)
		}),
		('Advanced', {
			'fields': ('reversing_parameters', 'order'),
			'classes': COLLAPSE_CLASSES
		})
	)


class NodeNavigationItemInline(NavigationItemInline):
	verbose_name_plural = 'targeting navigation'
	fieldsets = (
		(None, {
			'fields': ('text',)
		}),
		('Target', {
			'fields': ('target_node', 'url_or_subpath',)
		}),
		('Advanced', {
			'fields': ('reversing_parameters', 'order'),
			'classes': COLLAPSE_CLASSES
		}),
		('Expert', {
			'fields': ('parent', 'navigation')
		}),
	)


class NodeNavigationInline(admin.TabularInline):
	model = Navigation
	extra = 0


NodeAdmin.inlines = [NodeNavigationInline, NodeNavigationItemInline] + NodeAdmin.inlines


class NavigationItemAdmin(TreeEntityAdmin):
	list_display = ('__unicode__', 'target_node', 'url_or_subpath', 'reversing_parameters')
	fieldsets = (
		(None, {
			'fields': ('text', 'navigation',)
		}),
		('Target', {
			'fields': ('target_node', 'url_or_subpath',)
		}),
		('Advanced', {
			'fields': ('reversing_parameters',),
			'classes': COLLAPSE_CLASSES
		}),
		('Expert', {
			'fields': ('parent', 'order'),
			'classes': COLLAPSE_CLASSES
		})
	)
	raw_id_fields = NAVIGATION_RAW_ID_FIELDS
	related_lookup_fields = {'fk': raw_id_fields}
	inlines = [NavigationItemChildInline] + TreeEntityAdmin.inlines


class NavigationAdmin(EntityAdmin):
	inlines = [NavigationNavigationItemInline]
	raw_id_fields = ['node']
	related_lookup_fields = {'fk': raw_id_fields}


admin.site.unregister(Node)
admin.site.register(Node, NodeAdmin)
admin.site.register(Navigation, NavigationAdmin)
admin.site.register(NavigationItem, NavigationItemAdmin)
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Navigation'
        db.create_table('shipherd_navigation', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('node', self.gf('django.db.models.fields.related.ForeignKey')(related_name='navigation_set', to=orm['philo.Node'])),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('depth', self.gf('django.db.models.fields.PositiveSmallIntegerField')(default=3)),
        ))
        db.send_create_signal('shipherd', ['Navigation'])

        # Adding unique constraint on 'Navigation', fields ['node', 'key']
        db.create_unique('shipherd_navigation', ['node_id', 'key'])

        # Adding model 'NavigationItem'
        db.create_table('shipherd_navigationitem', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('parent', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='children', null=True, to=orm['shipherd.NavigationItem'])),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('lft', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('rght', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('tree_id', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('level', self.gf('django.db.models.fields.PositiveIntegerField')(db_index=True)),
            ('navigation', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='roots', null=True, to=orm['shipherd.Navigation'])),
            ('text', self.gf('django.db.models.fields.CharField')(max_length=50)),
            ('target_node', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='navigation_items', null=True, to=orm['philo.Node'])),
            ('url_or_subpath', self.gf('django.db.models.fields.CharField')(max_length=200, blank=True)),
            ('reversing_parameters', self.gf('philo.models.fields.JSONField')(blank=True)),
            ('order', self.gf('django.db.models.fields.PositiveSmallIntegerField')(default=0)),
        ))
        db.send_create_signal('shipherd', ['NavigationItem'])


    def backwards(self, orm):
        
        # Deleting model 'Navigation'
        db.delete_table('shipherd_navigation')

        # Removing unique constraint on 'Navigation', fields ['node', 'key']
        db.delete_unique('shipherd_navigation', ['node_id', 'key'])

        # Deleting model 'NavigationItem'
        db.delete_table('shipherd_navigationitem')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'shipherd.navigation': {
            'Meta': {'unique_together': "(('node', 'key'),)", 'object_name': 'Navigation'},
            'depth': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '3'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'node': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'navigation_set'", 'to': "orm['philo.Node']"})
        },
        'shipherd.navigationitem': {
            'Meta': {'object_name': 'NavigationItem'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'navigation': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'roots'", 'null': 'True', 'to': "orm['shipherd.Navigation']"}),
            'order': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '0'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['shipherd.NavigationItem']"}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'navigation_items'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'text': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        }
    }

    complete_apps = ['shipherd']

########NEW FILE########
__FILENAME__ = 0002_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'Navigation', fields ['key']
        db.create_index('shipherd_navigation', ['key'])


    def backwards(self, orm):
        
        # Removing index on 'Navigation', fields ['key']
        db.delete_index('shipherd_navigation', ['key'])


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'shipherd.navigation': {
            'Meta': {'unique_together': "(('node', 'key'),)", 'object_name': 'Navigation'},
            'depth': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '3'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'node': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'navigation_set'", 'to': "orm['philo.Node']"})
        },
        'shipherd.navigationitem': {
            'Meta': {'object_name': 'NavigationItem'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'navigation': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'roots'", 'null': 'True', 'to': "orm['shipherd.Navigation']"}),
            'order': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '0'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['shipherd.NavigationItem']"}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'shipherd_navigationitem_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'text': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        }
    }

    complete_apps = ['shipherd']

########NEW FILE########
__FILENAME__ = 0003_auto__del_field_navigationitem_slug
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'NavigationItem.slug'
        db.delete_column('shipherd_navigationitem', 'slug')


    def backwards(self, orm):
        
        # User chose to not deal with backwards NULL issues for 'NavigationItem.slug'
        raise RuntimeError("Cannot reverse this migration. 'NavigationItem.slug' and its values cannot be restored.")


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'shipherd.navigation': {
            'Meta': {'unique_together': "(('node', 'key'),)", 'object_name': 'Navigation'},
            'depth': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '3'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'node': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'navigation_set'", 'to': "orm['philo.Node']"})
        },
        'shipherd.navigationitem': {
            'Meta': {'object_name': 'NavigationItem'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'navigation': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'roots'", 'null': 'True', 'to': "orm['shipherd.Navigation']"}),
            'order': ('django.db.models.fields.PositiveSmallIntegerField', [], {'default': '0'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['shipherd.NavigationItem']"}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'shipherd_navigationitem_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'text': ('django.db.models.fields.CharField', [], {'max_length': '50'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        }
    }

    complete_apps = ['shipherd']

########NEW FILE########
__FILENAME__ = models
#encoding: utf-8
from UserDict import DictMixin
from hashlib import sha1

from django.contrib.sites.models import Site
from django.core.cache import cache
from django.core.exceptions import ValidationError
from django.core.urlresolvers import NoReverseMatch
from django.core.validators import RegexValidator, MinValueValidator
from django.db import models
from django.forms.models import model_to_dict

from philo.models.base import TreeEntity, TreeEntityManager, Entity
from philo.models.nodes import Node, TargetURLModel


DEFAULT_NAVIGATION_DEPTH = 3


class NavigationMapper(object, DictMixin):
	"""
	The :class:`NavigationMapper` is a dictionary-like object which allows easy fetching of the root items of a navigation for a node according to a key. A :class:`NavigationMapper` instance will be available on each node instance as :attr:`Node.navigation` if :mod:`~philo.contrib.shipherd` is in the :setting:`INSTALLED_APPS`
	
	"""
	def __init__(self, node):
		self.node = node
		self._cache = {}
	
	def __getitem__(self, key):
		if key not in self._cache:
			try:
				self._cache[key] = Navigation.objects.get_for_node(self.node, key)
			except Navigation.DoesNotExist:
				self._cache[key] = None
		return self._cache[key]


def navigation(self):
	if not hasattr(self, '_navigation'):
		self._navigation = NavigationMapper(self)
	return self._navigation


Node.navigation = property(navigation)


class NavigationManager(models.Manager):
	use_for_related = True
	
	def get_for_node(self, node, key):
		cache_key = self._get_cache_key(node, key)
		cached = cache.get(cache_key)
		
		if cached is None:
			opts = Node._mptt_meta
			left = getattr(node, opts.left_attr)
			right = getattr(node, opts.right_attr)
			tree_id = getattr(node, opts.tree_id_attr)
			kwargs = {
				"node__%s__lte" % opts.left_attr: left,
				"node__%s__gte" % opts.right_attr: right,
				"node__%s" % opts.tree_id_attr: tree_id
			}
			navs = self.filter(key=key, **kwargs).select_related('node').order_by('-node__%s' % opts.level_attr)
			nav = navs[0]
			roots = nav.roots.all().select_related('target_node').order_by('order')
			item_opts = NavigationItem._mptt_meta
			by_pk = {}
			tree_ids = []
			
			site_root_node = Site.objects.get_current().root_node
			
			for root in roots:
				by_pk[root.pk] = root
				tree_ids.append(getattr(root, item_opts.tree_id_attr))
				root._cached_children = []
				if root.target_node:
					root.target_node.get_path(root=site_root_node)
				root.navigation = nav
			
			kwargs = {
				'%s__in' % item_opts.tree_id_attr: tree_ids,
				'%s__lt' % item_opts.level_attr: nav.depth,
				'%s__gt' % item_opts.level_attr: 0
			}
			items = NavigationItem.objects.filter(**kwargs).select_related('target_node').order_by('level', 'order')
			for item in items:
				by_pk[item.pk] = item
				item._cached_children = []
				parent_pk = getattr(item, '%s_id' % item_opts.parent_attr)
				item.parent = by_pk[parent_pk]
				item.parent._cached_children.append(item)
				if item.target_node:
					item.target_node.get_path(root=site_root_node)
			
			cached = roots
			cache.set(cache_key, cached)
		
		return cached
	
	def _get_cache_key(self, node, key):
		opts = Node._mptt_meta
		left = getattr(node, opts.left_attr)
		right = getattr(node, opts.right_attr)
		tree_id = getattr(node, opts.tree_id_attr)
		parent_id = getattr(node, "%s_id" % opts.parent_attr)
		
		return sha1(unicode(left) + unicode(right) + unicode(tree_id) + unicode(parent_id) + unicode(node.pk) + unicode(key)).hexdigest()


class Navigation(Entity):
	"""
	:class:`Navigation` represents a group of :class:`NavigationItem`\ s that have an intrinsic relationship in terms of navigating a website. For example, a ``main`` navigation versus a ``side`` navigation, or a ``authenticated`` navigation versus an ``anonymous`` navigation.
	
	A :class:`Navigation`'s :class:`NavigationItem`\ s will be accessible from its related :class:`.Node` and that :class:`.Node`'s descendants through a :class:`NavigationMapper` instance at :attr:`Node.navigation`. Example::
	
		>>> node.navigation_set.all()
		[]
		>>> parent = node.parent
		>>> items = parent.navigation_set.get(key='main').roots.all()
		>>> parent.navigation["main"] == node.navigation["main"] == list(items)
		True
	
	"""
	#: A :class:`NavigationManager` instance.
	objects = NavigationManager()
	
	#: The :class:`.Node` which the :class:`Navigation` is attached to. The :class:`Navigation` will also be available to all the :class:`.Node`'s descendants and will override any :class:`Navigation` with the same key on any of the :class:`.Node`'s ancestors.
	node = models.ForeignKey(Node, related_name='navigation_set', help_text="Be available as navigation for this node.")
	#: Each :class:`Navigation` has a ``key`` which consists of one or more word characters so that it can easily be accessed in a template as ``{{ node.navigation.this_key }}``.
	key = models.CharField(max_length=255, validators=[RegexValidator("\w+")], help_text="Must contain one or more alphanumeric characters or underscores.", db_index=True)
	#: There is no limit to the depth of a tree of :class:`NavigationItem`\ s, but ``depth`` will limit how much of the tree will be displayed.
	depth = models.PositiveSmallIntegerField(default=DEFAULT_NAVIGATION_DEPTH, validators=[MinValueValidator(1)], help_text="Defines the maximum display depth of this navigation.")
	
	def __unicode__(self):
		return "%s[%s]" % (self.node, self.key)
	
	class Meta:
		unique_together = ('node', 'key')


class NavigationItem(TreeEntity, TargetURLModel):
	#: A :class:`ForeignKey` to a :class:`Navigation` instance. If this is not null, then the :class:`NavigationItem` will be a root node of the :class:`Navigation` instance.
	navigation = models.ForeignKey(Navigation, blank=True, null=True, related_name='roots', help_text="Be a root in this navigation tree.")
	#: The text which will be displayed in the navigation. This is a :class:`CharField` instance with max length 50.
	text = models.CharField(max_length=50)
	
	#: The order in which the :class:`NavigationItem` will be displayed.
	order = models.PositiveSmallIntegerField(default=0)
	
	def get_path(self, root=None, pathsep=u'  ', field='text'):
		return super(NavigationItem, self).get_path(root, pathsep, field)
	path = property(get_path)
	
	def clean(self):
		super(NavigationItem, self).clean()
		if bool(self.parent) == bool(self.navigation):
			raise ValidationError("Exactly one of `parent` and `navigation` must be defined.")
	
	def is_active(self, request):
		"""Returns ``True`` if the :class:`NavigationItem` is considered active for a given request and ``False`` otherwise."""
		if self.target_url == request.path:
			# Handle the `default` case where the target_url and requested path
			# are identical.
			return True
		
		if self.target_node is None and self.url_or_subpath == "http%s://%s%s" % (request.is_secure() and 's' or '', request.get_host(), request.path):
			# If there's no target_node, double-check whether it's a full-url
			# match.
			return True
		
		if self.target_node and not self.url_or_subpath:
			# If there is a target node and it's targeted simply, but the target URL is not
			# the same as the request path, check whether the target node is an ancestor
			# of the requested node. If so, this is active unless the target node
			# is the same as the ``host node`` for this navigation structure.
			root = self
			
			# The common case will be cached items, whose parents are cached with them.
			while root.parent is not None:
				root = root.parent
			
			host_node_id = root.navigation.node_id
			if self.target_node.pk != host_node_id and self.target_node.is_ancestor_of(request.node):
				return True
		
		return False
	
	def has_active_descendants(self, request):
		"""Returns ``True`` if the :class:`NavigationItem` has active descendants and ``False`` otherwise."""
		for child in self.get_children():
			if child.is_active(request) or child.has_active_descendants(request):
				return True
		return False
########NEW FILE########
__FILENAME__ = shipherd
from django import template, VERSION as django_version
from django.conf import settings
from django.utils.safestring import mark_safe
from philo.contrib.shipherd.models import Navigation
from philo.models import Node
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _


register = template.Library()


class LazyNavigationRecurser(object):
	def __init__(self, template_nodes, items, context, request):
		self.template_nodes = template_nodes
		self.items = items
		self.context = context
		self.request = request
	
	def __call__(self):
		items = self.items
		context = self.context
		request = self.request
		
		if not items:
			return ''
		
		if 'navloop' in context:
			parentloop = context['navloop']
		else:
			parentloop = {}
		context.push()
		
		depth = items[0].get_level()
		len_items = len(items)
		
		loop_dict = context['navloop'] = {
			'parentloop': parentloop,
			'depth': depth + 1,
			'depth0': depth
		}
		
		bits = []
		
		for i, item in enumerate(items):
			# First set context variables.
			loop_dict['counter0'] = i
			loop_dict['counter'] = i + 1
			loop_dict['revcounter'] = len_items - i
			loop_dict['revcounter0'] = len_items - i - 1
			loop_dict['first'] = (i == 0)
			loop_dict['last'] = (i == len_items - 1)
			
			# Set on loop_dict and context for backwards-compatibility.
			# Eventually only allow access through the loop_dict.
			loop_dict['active'] = context['active'] = item.is_active(request)
			loop_dict['active_descendants'] = context['active_descendants'] = item.has_active_descendants(request)
			
			# Set these directly in the context for easy access.
			context['item'] = item
			context['children'] = self.__class__(self.template_nodes, item.get_children(), context, request)
			
			# Then render the nodelist bit by bit.
			for node in self.template_nodes:
				bits.append(node.render(context))
		context.pop()
		return mark_safe(''.join(bits))


class RecurseNavigationNode(template.Node):
	def __init__(self, template_nodes, instance_var, key_var):
		self.template_nodes = template_nodes
		self.instance_var = instance_var
		self.key_var = key_var
	
	def render(self, context):
		try:
			request = context['request']
		except KeyError:
			return ''
		
		instance = self.instance_var.resolve(context)
		key = self.key_var.resolve(context)
		
		# Fall back on old behavior if the key doesn't seem to be a variable.
		if not key:
			token = self.key_var.token
			if token[0] not in ["'", '"'] and '.' not in token:
				key = token
			else:
				return settings.TEMPLATE_STRING_IF_INVALID
		
		try:
			items = instance.navigation[key]
		except:
			return settings.TEMPLATE_STRING_IF_INVALID
		
		return LazyNavigationRecurser(self.template_nodes, items, context, request)()


@register.tag
def recursenavigation(parser, token):
	"""
	The :ttag:`recursenavigation` templatetag takes two arguments:
	
	* the :class:`.Node` for which the :class:`.Navigation` should be found
	* the :class:`.Navigation`'s :attr:`~.Navigation.key`.
	
	It will then recursively loop over each :class:`.NavigationItem` in the :class:`.Navigation` and render the template
	chunk within the block. :ttag:`recursenavigation` sets the following variables in the context:
	
		==============================  ================================================
		Variable                        Description
		==============================  ================================================
		``navloop.depth``               The current depth of the loop (1 is the top level)
		``navloop.depth0``              The current depth of the loop (0 is the top level)
		``navloop.counter``             The current iteration of the current level(1-indexed)
		``navloop.counter0``            The current iteration of the current level(0-indexed)
		``navloop.first``               True if this is the first time through the current level
		``navloop.last``                True if this is the last time through the current level
		``navloop.parentloop``          This is the loop one level "above" the current one
		
		``item``                        The current item in the loop (a :class:`.NavigationItem` instance)
		``children``                    If accessed, performs the next level of recursion.
		``navloop.active``              True if the item is active for this request
		``navloop.active_descendants``  True if the item has active descendants for this request
		==============================  ================================================
	
	Example::
	
		<ul>
		    {% recursenavigation node "main" %}
		        <li{% if navloop.active %} class='active'{% endif %}>
		            <a href="{{ item.get_target_url }}">{{ item.text }}</a>
		            {% if item.get_children %}
		                <ul>
		                    {{ children }}
		                </ul>
		            {% endif %}
		        </li>
		    {% endrecursenavigation %}
		</ul>
	
	.. note:: {% recursenavigation %} requires that the current :class:`HttpRequest` be present in the context as ``request``. The simplest way to do this is with the `request context processor`_. Simply make sure that ``django.core.context_processors.request`` is included in your :setting:`TEMPLATE_CONTEXT_PROCESSORS` setting.
	
	.. _request context processor: https://docs.djangoproject.com/en/dev/ref/templates/api/#django-core-context-processors-request
	
	"""
	bits = token.contents.split()
	if len(bits) != 3:
		raise template.TemplateSyntaxError(_('%s tag requires two arguments: a node and a navigation section name') % bits[0])
	
	instance_var = parser.compile_filter(bits[1])
	key_var = parser.compile_filter(bits[2])
	
	template_nodes = parser.parse(('endrecursenavigation',))
	token = parser.delete_first_token()
	return RecurseNavigationNode(template_nodes, instance_var, key_var)


@register.filter
def has_navigation(node, key=None):
	"""Returns ``True`` if the node has a :class:`.Navigation` with the given key and ``False`` otherwise. If ``key`` is ``None``, returns whether the node has any :class:`.Navigation`\ s at all."""
	try:
		return bool(node.navigation[key])
	except:
		return False


@register.filter
def navigation_host(node, key):
	"""Returns the :class:`.Node` which hosts the :class:`.Navigation` which ``node`` has inherited for ``key``. Returns ``node`` if any exceptions are encountered."""
	try:
		return node.navigation[key].node
	except:
		return node
########NEW FILE########
__FILENAME__ = admin
from functools import update_wrapper

from django.conf import settings
from django.conf.urls.defaults import patterns, url
from django.contrib import admin
from django.core.urlresolvers import reverse
from django.db.models import Count
from django.http import HttpResponseRedirect, Http404
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext_lazy as _

from philo.admin import EntityAdmin
from philo.contrib.sobol.models import Search, ResultURL, SearchView


class ResultURLInline(admin.TabularInline):
	model = ResultURL
	readonly_fields = ('url',)
	can_delete = False
	extra = 0
	max_num = 0


class SearchAdmin(admin.ModelAdmin):
	readonly_fields = ('string',)
	inlines = [ResultURLInline]
	list_display = ['string', 'unique_urls', 'total_clicks']
	search_fields = ['string', 'result_urls__url']
	actions = ['results_action']
	if 'grappelli' in settings.INSTALLED_APPS:
		change_form_template = 'admin/sobol/search/grappelli_change_form.html'
	
	def unique_urls(self, obj):
		return obj.unique_urls
	unique_urls.admin_order_field = 'unique_urls'
	
	def total_clicks(self, obj):
		return obj.total_clicks
	total_clicks.admin_order_field = 'total_clicks'
	
	def queryset(self, request):
		qs = super(SearchAdmin, self).queryset(request)
		return qs.annotate(total_clicks=Count('result_urls__clicks', distinct=True), unique_urls=Count('result_urls', distinct=True))


class SearchViewAdmin(EntityAdmin):
	raw_id_fields = ('results_page',)
	related_lookup_fields = {'fk': raw_id_fields}


admin.site.register(Search, SearchAdmin)
admin.site.register(SearchView, SearchViewAdmin)
########NEW FILE########
__FILENAME__ = forms
from django import forms

from philo.contrib.sobol.utils import SEARCH_ARG_GET_KEY


class BaseSearchForm(forms.BaseForm):
	base_fields = {
		SEARCH_ARG_GET_KEY: forms.CharField()
	}


class SearchForm(forms.Form, BaseSearchForm):
	pass
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Search'
        db.create_table('sobol_search', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('string', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('sobol', ['Search'])

        # Adding model 'ResultURL'
        db.create_table('sobol_resulturl', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('search', self.gf('django.db.models.fields.related.ForeignKey')(related_name='result_urls', to=orm['sobol.Search'])),
            ('url', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('sobol', ['ResultURL'])

        # Adding model 'Click'
        db.create_table('sobol_click', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('result', self.gf('django.db.models.fields.related.ForeignKey')(related_name='clicks', to=orm['sobol.ResultURL'])),
            ('datetime', self.gf('django.db.models.fields.DateTimeField')()),
        ))
        db.send_create_signal('sobol', ['Click'])

        # Adding model 'SearchView'
        db.create_table('sobol_searchview', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('results_page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='search_results_related', to=orm['philo.Page'])),
            ('searches', self.gf('philo.models.fields.SlugMultipleChoiceField')()),
            ('enable_ajax_api', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('placeholder_text', self.gf('django.db.models.fields.CharField')(default='Search', max_length=75)),
        ))
        db.send_create_signal('sobol', ['SearchView'])


    def backwards(self, orm):
        
        # Deleting model 'Search'
        db.delete_table('sobol_search')

        # Deleting model 'ResultURL'
        db.delete_table('sobol_resulturl')

        # Deleting model 'Click'
        db.delete_table('sobol_click')

        # Deleting model 'SearchView'
        db.delete_table('sobol_searchview')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        },
        'sobol.click': {
            'Meta': {'ordering': "['datetime']", 'object_name': 'Click'},
            'datetime': ('django.db.models.fields.DateTimeField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'result': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'clicks'", 'to': "orm['sobol.ResultURL']"})
        },
        'sobol.resulturl': {
            'Meta': {'ordering': "['url']", 'object_name': 'ResultURL'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'search': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'result_urls'", 'to': "orm['sobol.Search']"}),
            'url': ('django.db.models.fields.TextField', [], {})
        },
        'sobol.search': {
            'Meta': {'ordering': "['string']", 'object_name': 'Search'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'string': ('django.db.models.fields.TextField', [], {})
        },
        'sobol.searchview': {
            'Meta': {'object_name': 'SearchView'},
            'enable_ajax_api': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'placeholder_text': ('django.db.models.fields.CharField', [], {'default': "'Search'", 'max_length': '75'}),
            'results_page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'search_results_related'", 'to': "orm['philo.Page']"}),
            'searches': ('philo.models.fields.SlugMultipleChoiceField', [], {})
        }
    }

    complete_apps = ['sobol']

########NEW FILE########
__FILENAME__ = models
import datetime
import itertools

from django.conf import settings
from django.conf.urls.defaults import patterns, url
from django.contrib import messages
from django.core.exceptions import ValidationError
from django.core.validators import URLValidator
from django.db import models
from django.http import HttpResponseRedirect, Http404, HttpResponse
from django.utils import simplejson as json
from django.utils.datastructures import SortedDict

from philo.contrib.sobol import registry, get_search_instance
from philo.contrib.sobol.forms import SearchForm
from philo.contrib.sobol.utils import HASH_REDIRECT_GET_KEY, URL_REDIRECT_GET_KEY, SEARCH_ARG_GET_KEY, check_redirect_hash, RegistryIterator
from philo.exceptions import ViewCanNotProvideSubpath
from philo.models import MultiView, Page
from philo.models.fields import SlugMultipleChoiceField

eventlet = None
if getattr(settings, 'SOBOL_USE_EVENTLET', False):
	try:
		import eventlet
	except:
		pass


class Search(models.Model):
	"""Represents all attempts to search for a unique string."""
	#: The string which was searched for.
	string = models.TextField()
	
	def __unicode__(self):
		return self.string
	
	def get_weighted_results(self, threshhold=None):
		"""
		Returns a list of :class:`ResultURL` instances related to the search and ordered by decreasing weight. This will be cached on the instance.
		
		:param threshhold: The earliest datetime that a :class:`Click` can have been made on a related :class:`ResultURL` in order to be included in the weighted results (or ``None`` to include all :class:`Click`\ s and :class:`ResultURL`\ s).
		
		"""
		if not hasattr(self, '_weighted_results'):
			result_qs = self.result_urls.all()
			
			if threshhold is not None:
				result_qs = result_qs.filter(counts__datetime__gte=threshhold)
			
			results = [result for result in result_qs]
			
			results.sort(cmp=lambda x,y: cmp(y.weight, x.weight))
			
			self._weighted_results = results
		
		return self._weighted_results
	
	def get_favored_results(self, error=5, threshhold=None):
		"""
		Calculates the set of most-favored results based on their weight. Evenly-weighted results will be grouped together and either added or excluded as a group.
		
		:param error: An arbitrary number; higher values will cause this method to be more reticent about adding new items to the favored results.
		:param threshhold: Will be passed directly into :meth:`get_weighted_results`
		
		"""
		if not hasattr(self, '_favored_results'):
			results = self.get_weighted_results(threshhold)
			
			grouped_results = SortedDict()
			
			for result in results:
				grouped_results.setdefault(result.weight, []).append(result)
			
			self._favored_results = []
			
			for value, subresults in grouped_results.items():
				cost = error * sum([(value - result.weight)**2 for result in self._favored_results])
				if value > cost:
					self._favored_results += subresults
				else:
					break
			if len(self._favored_results) == len(results):
				self._favored_results = []
		return self._favored_results
	
	class Meta:
		ordering = ['string']
		verbose_name_plural = 'searches'


class ResultURL(models.Model):
	"""Represents a URL which has been selected one or more times for a :class:`Search`."""
	#: A :class:`ForeignKey` to the :class:`Search` which the :class:`ResultURL` is related to.
	search = models.ForeignKey(Search, related_name='result_urls')
	#: The URL which was selected.
	url = models.TextField(validators=[URLValidator()])
	
	def __unicode__(self):
		return self.url
	
	def get_weight(self, threshhold=None):
		"""
		Calculates, caches, and returns the weight of the :class:`ResultURL`.
		
		:param threshhold: The datetime limit before which :class:`Click`\ s will not contribute to the weight of the :class:`ResultURL`.
		
		"""
		if not hasattr(self, '_weight'):
			clicks = self.clicks.all()
			
			if threshhold is not None:
				clicks = clicks.filter(datetime__gte=threshhold)
			
			self._weight = sum([click.weight for click in clicks])
		
		return self._weight
	weight = property(get_weight)
	
	class Meta:
		ordering = ['url']


class Click(models.Model):
	"""Represents a click on a :class:`ResultURL`."""
	#: A :class:`ForeignKey` to the :class:`ResultURL` which the :class:`Click` is related to.
	result = models.ForeignKey(ResultURL, related_name='clicks')
	#: The datetime when the click was registered in the system.
	datetime = models.DateTimeField()
	
	def __unicode__(self):
		return self.datetime.strftime('%B %d, %Y %H:%M:%S')
	
	def get_weight(self, default=1, weighted=lambda value, days: value/days**2):
		"""Calculates and returns the weight of the :class:`Click`."""
		if not hasattr(self, '_weight'):
			days = (datetime.datetime.now() - self.datetime).days
			if days < 0:
				raise ValueError("Click dates must be in the past.")
			default = float(default)
			if days == 0:
				self._weight = float(default)
			else:
				self._weight = weighted(default, days)
		return self._weight
	weight = property(get_weight)
	
	def clean(self):
		if self.datetime > datetime.datetime.now():
			raise ValidationError("Click dates must be in the past.")
	
	class Meta:
		ordering = ['datetime']
		get_latest_by = 'datetime'


try:
	from south.modelsinspector import add_introspection_rules
except ImportError:
	pass
else:
	add_introspection_rules([], ["^philo\.contrib\.sobol\.models\.RegistryChoiceField"])


class SearchView(MultiView):
	"""Handles a view for the results of a search, anonymously tracks the selections made by end users, and provides an AJAX API for asynchronous search result loading. This can be particularly useful if some searches are slow."""
	#: :class:`ForeignKey` to a :class:`.Page` which will be used to render the search results.
	results_page = models.ForeignKey(Page, related_name='search_results_related')
	#: A :class:`.SlugMultipleChoiceField` whose choices are the contents of :obj:`.sobol.search.registry`
	searches = SlugMultipleChoiceField(choices=registry.iterchoices())
	#: A :class:`BooleanField` which controls whether or not the AJAX API is enabled.
	#:
	#: .. note:: If the AJAX API is enabled, a ``ajax_api_url`` attribute will be added to each search instance containing the url and get parameters for an AJAX request to retrieve results for that search.
	#:
	#: .. note:: Be careful not to access :attr:`search_instance.results <.BaseSearch.results>` if the AJAX API is enabled - otherwise the search will be run immediately rather than on the AJAX request.
	enable_ajax_api = models.BooleanField("Enable AJAX API", default=True)
	#: A :class:`CharField` containing the placeholder text which is intended to be used for the search box for the :class:`SearchView`. It is the template author's responsibility to make use of this information.
	placeholder_text = models.CharField(max_length=75, default="Search")
	
	#: The form which will be used to validate the input to the search box for this :class:`SearchView`.
	search_form = SearchForm
	
	def __unicode__(self):
		return u"%s (%s)" % (self.placeholder_text, u", ".join([display for slug, display in registry.iterchoices() if slug in self.searches]))
	
	def get_reverse_params(self, obj):
		raise ViewCanNotProvideSubpath
	
	@property
	def urlpatterns(self):
		urlpatterns = patterns('',
			url(r'^$', self.results_view, name='results'),
		)
		if self.enable_ajax_api:
			urlpatterns += patterns('',
				url(r'^(?P<slug>[\w-]+)$', self.ajax_api_view, name='ajax_api_view')
			)
		return urlpatterns
	
	def results_view(self, request, extra_context=None):
		"""
		Renders :attr:`results_page` with a context containing an instance of :attr:`search_form`. If the form was submitted and was valid, then one of two things has happened:
		
		* A search has been initiated. In this case, a list of search instances will be added to the context as ``searches``. If :attr:`enable_ajax_api` is enabled, each instance will have an ``ajax_api_url`` attribute containing the url needed to make an AJAX request for the search results.
		* A link has been chosen. In this case, corresponding :class:`Search`, :class:`ResultURL`, and :class:`Click` instances will be created and the user will be redirected to the link's actual url.
		
		"""
		results = None
		
		context = self.get_context()
		context.update(extra_context or {})
		
		if SEARCH_ARG_GET_KEY in request.GET:
			form = self.search_form(request.GET)
			
			if form.is_valid():
				search_string = request.GET[SEARCH_ARG_GET_KEY].lower()
				url = request.GET.get(URL_REDIRECT_GET_KEY)
				hash = request.GET.get(HASH_REDIRECT_GET_KEY)
				
				if url and hash:
					if check_redirect_hash(hash, search_string, url):
						# Create the necessary models
						search = Search.objects.get_or_create(string=search_string)[0]
						result_url = search.result_urls.get_or_create(url=url)[0]
						result_url.clicks.create(datetime=datetime.datetime.now())
						return HttpResponseRedirect(url)
					else:
						messages.add_message(request, messages.INFO, "The link you followed had been tampered with. Here are all the results for your search term instead!")
						# TODO: Should search_string be escaped here?
						return HttpResponseRedirect("%s?%s=%s" % (request.path, SEARCH_ARG_GET_KEY, search_string))
				
				search_instances = []
				for slug in self.searches:
					if slug in registry:
						search_instance = get_search_instance(slug, search_string)
						search_instances.append(search_instance)
					
						if self.enable_ajax_api:
							search_instance.ajax_api_url = "%s?%s=%s" % (self.reverse('ajax_api_view', kwargs={'slug': slug}, node=request.node), SEARCH_ARG_GET_KEY, search_string)
				
				if eventlet and not self.enable_ajax_api:
					pool = eventlet.GreenPool()
					for instance in search_instances:
						pool.spawn_n(lambda x: x.results, search_instance)
					pool.waitall()
				
				context.update({
					'searches': search_instances,
					'favored_results': []
				})
				
				try:
					search = Search.objects.get(string=search_string)
				except Search.DoesNotExist:
					pass
				else:
					context['favored_results'] = [r.url for r in search.get_favored_results()]
		else:
			form = SearchForm()
		
		context.update({
			'form': form
		})
		return self.results_page.render_to_response(request, extra_context=context)
	
	def ajax_api_view(self, request, slug, extra_context=None):
		"""
		Returns a JSON object containing the following variables:
		
		search
			Contains the slug for the search.
		results
			Contains the results of :meth:`.Result.get_context` for each result.
		rendered
			Contains the results of :meth:`.Result.render` for each result.
		hasMoreResults
			``True`` or ``False`` whether the search has more results according to :meth:`BaseSearch.has_more_results`
		moreResultsURL
			Contains ``None`` or a querystring which, once accessed, will note the :class:`Click` and redirect the user to a page containing more results.
		
		"""
		search_string = request.GET.get(SEARCH_ARG_GET_KEY)
		
		if not request.is_ajax() or not self.enable_ajax_api or slug not in registry or slug not in self.searches or search_string is None:
			raise Http404
		
		search_instance = get_search_instance(slug, search_string)
		
		return HttpResponse(json.dumps({
			'search': search_instance.slug,
			'results': [result.get_context() for result in search_instance.results],
			'hasMoreResults': search_instance.has_more_results,
			'moreResultsURL': search_instance.more_results_url,
		}), mimetype="application/json")
########NEW FILE########
__FILENAME__ = search
#encoding: utf-8
import datetime
from hashlib import sha1

from django.conf import settings
from django.contrib.sites.models import Site
from django.core.cache import cache
from django.db.models.options import get_verbose_name as convert_camelcase
from django.utils import simplejson as json
from django.utils.http import urlquote_plus
from django.utils.safestring import mark_safe
from django.utils.text import capfirst
from django.template import loader, Context, Template, TemplateDoesNotExist

from philo.contrib.sobol.utils import make_tracking_querydict
from philo.utils.registry import Registry


if getattr(settings, 'SOBOL_USE_EVENTLET', False):
	try:
		from eventlet.green import urllib2
	except:
		import urllib2
else:
	import urllib2


__all__ = (
	'Result', 'BaseSearch', 'DatabaseSearch', 'URLSearch', 'JSONSearch', 'GoogleSearch', 'registry', 'get_search_instance'
)


SEARCH_CACHE_SEED = 'philo_sobol_search_results'
USE_CACHE = getattr(settings, 'SOBOL_USE_CACHE', True)


#: A registry for :class:`BaseSearch` subclasses that should be available in the admin.
registry = Registry()


def _make_cache_key(search, search_arg):
	return sha1(SEARCH_CACHE_SEED + search.slug + search_arg).hexdigest()


def get_search_instance(slug, search_arg):
	"""Returns a search instance for the given slug, either from the cache or newly-instantiated."""
	search = registry[slug]
	search_arg = search_arg.lower()
	if USE_CACHE:
		key = _make_cache_key(search, search_arg)
		cached = cache.get(key)
		if cached:
			return cached
	instance = search(search_arg)
	instance.slug = slug
	return instance


class Result(object):
	"""
	:class:`Result` is a helper class that, given a search and a result of that search, is able to correctly render itself with a template defined by the search. Every :class:`Result` will pass a ``title``, a ``url`` (if applicable), and the raw ``result`` returned by the search into the template context when rendering.
	
	:param search: An instance of a :class:`BaseSearch` subclass or an object that implements the same API.
	:param result: An arbitrary result from the ``search``.
	
	"""
	def __init__(self, search, result):
		self.search = search
		self.result = result
	
	def get_title(self):
		"""Returns the title of the result by calling :meth:`BaseSearch.get_result_title` on the raw result."""
		return self.search.get_result_title(self.result)
	
	def get_url(self):
		"""Returns the url of the result or ``None`` by calling :meth:`BaseSearch.get_result_url` on the raw result. This url will contain a querystring which, if used, will track a :class:`.Click` for the actual url."""
		return self.search.get_result_url(self.result)
	
	def get_actual_url(self):
		"""Returns the actual url of the result by calling :meth:`BaseSearch.get_actual_result_url` on the raw result."""
		return self.search.get_actual_result_url(self.result)
	
	def get_content(self):
		"""Returns the content of the result by calling :meth:`BaseSearch.get_result_content` on the raw result."""
		return self.search.get_result_content(self.result)
	
	def get_template(self):
		"""Returns the template which will be used to render the :class:`Result` by calling :meth:`BaseSearch.get_result_template` on the raw result."""
		return self.search.get_result_template(self.result)
	
	def get_context(self):
		"""
		Returns the context dictionary for the result. This is used both in rendering the result and in the AJAX return value for :meth:`.SearchView.ajax_api_view`. The context will contain the following keys:
		
		title
			The result of calling :meth:`get_title`
		url
			The result of calling :meth:`get_url`
		content
			The result of calling :meth:`get_content`
		
		"""
		if not hasattr(self, '_context'):
			self._context = {
				'title': self.get_title(),
				'url': self.get_url(),
				'actual_url': self.get_actual_url(),
				'content': self.get_content()
			}
		return self._context
	
	def render(self):
		"""Returns the template from :meth:`get_template` rendered with the context from :meth:`get_context`."""
		t = self.get_template()
		c = Context(self.get_context())
		return t.render(c)
	
	def __unicode__(self):
		"""Returns :meth:`render`"""
		return self.render()


class BaseSearchMetaclass(type):
	def __new__(cls, name, bases, attrs):
		if 'verbose_name' not in attrs:
			attrs['verbose_name'] = capfirst(' '.join(convert_camelcase(name).rsplit(' ', 1)[:-1]))
		if 'slug' not in attrs:
			attrs['slug'] = name[:-6].lower() if name.endswith("Search") else name.lower()
		return super(BaseSearchMetaclass, cls).__new__(cls, name, bases, attrs)


class BaseSearch(object):
	"""
	Defines a generic search api. Accessing :attr:`results` will attempt to retrieve cached results and, if that fails, will initiate a new search and store the results in the cache. Each search has a ``verbose_name`` and a ``slug``. If these are not provided as attributes, they will be automatically generated based on the name of the class.
	
	:param search_arg: The string which is being searched for.
	
	"""
	__metaclass__ = BaseSearchMetaclass
	#: The number of results to return from the complete list. Default: 5
	result_limit = 5
	#: How long the items for the search should be cached (in minutes). Default: 48 hours.
	_cache_timeout = 60*48
	#: The path to the template which will be used to render the :class:`Result`\ s for this search. If this is ``None``, then the framework will try ``sobol/search/<slug>/result.html`` and ``sobol/search/result.html``.
	result_template = None
	#: The path to the template which will be used to generate the title of the :class:`Result`\ s for this search. If this is ``None``, then the framework will try ``sobol/search/<slug>/title.html`` and ``sobol/search/title.html``.
	title_template = None
	#: The path to the template which will be used to generate the content of the :class:`Result`\ s for this search. If this is ``None``, then the framework will try ``sobol/search/<slug>/content.html`` and ``sobol/search/content.html``.
	content_template = None
	
	def __init__(self, search_arg):
		self.search_arg = search_arg
	
	@property
	def results(self):
		"""Retrieves cached results or initiates a new search via :meth:`get_results` and caches the results."""
		if not hasattr(self, '_results'):
			try:
				# Cache one extra result so we can see if there are
				# more results to be had.
				limit = self.result_limit
				if limit is not None:
					limit += 1
				results = self.get_results(limit)
			except:
				if settings.DEBUG:
					raise
				#  On exceptions, don't set any cache; just return.
				return []
			
			self._results = results
			
			if USE_CACHE:
				for result in results:
					result.get_context()
				key = _make_cache_key(self, self.search_arg)
				cache.set(key, self, self._cache_timeout)
		
		return self._results
	
	def get_results(self, limit=None, result_class=Result):
		"""
		Calls :meth:`search` and parses the return value into :class:`Result` instances.
		
		:param limit: Passed directly to :meth:`search`.
		:param result_class: The class used to represent the results. This will be instantiated with the :class:`BaseSearch` instance and the raw result from the search.
		
		"""
		results = self.search(limit)
		return [result_class(self, result) for result in results]
	
	def search(self, limit=None):
		"""Returns an iterable of up to ``limit`` results. The :meth:`get_result_title`, :meth:`get_result_url`, :meth:`get_result_template`, and :meth:`get_result_extra_context` methods will be used to interpret the individual items that this function returns, so the result can be an object with attributes as easily as a dictionary with keys. However, keep in mind that the raw results will be stored with django's caching mechanisms and will be converted to JSON."""
		raise NotImplementedError
	
	def get_actual_result_url(self, result):
		"""Returns the actual URL for the ``result`` or ``None`` if there is no URL. Must be implemented by subclasses."""
		raise NotImplementedError
	
	def get_result_querydict(self, result):
		"""Returns a querydict for tracking selection of the result, or ``None`` if there is no URL for the result."""
		url = self.get_actual_result_url(result)
		if url is None:
			return None
		return make_tracking_querydict(self.search_arg, url)
	
	def get_result_url(self, result):
		"""Returns ``None`` or a url which, when accessed, will register a :class:`.Click` for that url."""
		qd = self.get_result_querydict(result)
		if qd is None:
			return None
		return "?%s" % qd.urlencode()
	
	def get_result_title(self, result):
		"""Returns the title of the ``result``. By default, renders ``sobol/search/<slug>/title.html`` or ``sobol/search/title.html`` with the result in the context. This can be overridden by setting :attr:`title_template` or simply overriding :meth:`get_result_title`. If no template can be found, this will raise :exc:`TemplateDoesNotExist`."""
		return loader.render_to_string(self.title_template or [
			'sobol/search/%s/title.html' % self.slug,
			'sobol/search/title.html'
		], {'result': result})
	
	def get_result_content(self, result):
		"""Returns the content for the ``result``. By default, renders ``sobol/search/<slug>/content.html`` or ``sobol/search/content.html`` with the result in the context. This can be overridden by setting :attr:`content_template` or simply overriding :meth:`get_result_content`. If no template is found, this will return an empty string."""
		try:
			return loader.render_to_string(self.content_template or [
				'sobol/search/%s/content.html' % self.slug,
				'sobol/search/content.html'
			], {'result': result})
		except TemplateDoesNotExist:
			return ""
	
	def get_result_template(self, result):
		"""Returns the template to be used for rendering the ``result``. For a search with slug ``google``, this would first try ``sobol/search/google/result.html``, then fall back on ``sobol/search/result.html``. Subclasses can override this by setting :attr:`result_template` to the path of another template."""
		if self.result_template:
			return loader.get_template(self.result_template)
		return loader.select_template([
			'sobol/search/%s/result.html' % self.slug,
			'sobol/search/result.html'
		])
	
	@property
	def has_more_results(self):
		"""Returns ``True`` if there are more results than :attr:`result_limit` and ``False`` otherwise."""
		return len(self.results) > self.result_limit
	
	def get_actual_more_results_url(self):
		"""Returns the actual url for more results. By default, simply returns ``None``."""
		return None
	
	def get_more_results_querydict(self):
		"""Returns a :class:`QueryDict` for tracking whether people click on a 'more results' link."""
		url = self.get_actual_more_results_url()
		if url:
			return make_tracking_querydict(self.search_arg, url)
		return None
	
	@property
	def more_results_url(self):
		"""Returns a URL which consists of a querystring which, when accessed, will log a :class:`.Click` for the actual URL."""
		qd = self.get_more_results_querydict()
		if qd is None:
			return None
		return "?%s" % qd.urlencode()
	
	def __unicode__(self):
		return self.verbose_name


class DatabaseSearch(BaseSearch):
	"""Implements :meth:`~BaseSearch.search` and :meth:`get_queryset` methods to handle database queries."""
	#: The model which should be searched by the :class:`DatabaseSearch`.
	model = None
	
	def search(self, limit=None):
		if not hasattr(self, '_qs'):
			self._qs = self.get_queryset()
			if limit is not None:
				self._qs = self._qs[:limit]
		
		return self._qs
	
	def get_queryset(self):
		"""Returns a :class:`QuerySet` of all instances of :attr:`model`. This method should be overridden by subclasses to specify how the search should actually be implemented for the model."""
		return self.model._default_manager.all()


class URLSearch(BaseSearch):
	"""Defines a generic interface for searches that require accessing a certain url to get search results."""
	#: The base URL which will be accessed to get the search results.
	search_url = ''
	#: The url-encoded query string to be used for fetching search results from :attr:`search_url`. Must have one ``%s`` to contain the search argument.
	query_format_str = "%s"

	@property
	def url(self):
		"""The URL where the search gets its results. Composed from :attr:`search_url` and :attr:`query_format_str`."""
		return self.search_url + self.query_format_str % urlquote_plus(self.search_arg)
	
	def get_actual_more_results_url(self):
		return self.url
	
	def parse_response(self, response, limit=None):
		"""Handles the ``response`` from accessing :attr:`url` (with :func:`urllib2.urlopen`) and returns a list of up to ``limit`` results."""
		raise NotImplementedError
	
	def search(self, limit=None):
		return self.parse_response(urllib2.urlopen(self.url), limit=limit)


class JSONSearch(URLSearch):
	"""Makes a GET request and parses the results as JSON. The default behavior assumes that the response contains a list of results."""
	def parse_response(self, response, limit=None):
		return json.loads(response.read())[:limit]


class GoogleSearch(JSONSearch):
	"""An example implementation of a :class:`JSONSearch`."""
	search_url = "http://ajax.googleapis.com/ajax/services/search/web"
	_cache_timeout = 60
	verbose_name = "Google search (current site)"
	_more_results_url = None
	
	@property
	def query_format_str(self):
		default_args = self.default_args
		if default_args:
			default_args += " "
		return "?v=1.0&q=%s%%s" % urlquote_plus(default_args).replace('%', '%%')
	
	@property
	def default_args(self):
		"""Unquoted default arguments for the :class:`GoogleSearch`."""
		return "site:%s" % Site.objects.get_current().domain
	
	def parse_response(self, response, limit=None):
		responseData = json.loads(response.read())['responseData']
		results, cursor = responseData['results'], responseData['cursor']
		
		if results:
			self._more_results_url = cursor['moreResultsUrl']
			self._estimated_result_count = cursor['estimatedResultCount']
		
		return results[:limit]
	
	@property
	def url(self):
		# Google requires that an ajax request have a proper Referer header.
		return urllib2.Request(
			super(GoogleSearch, self).url,
			None,
			{'Referer': "http://%s" % Site.objects.get_current().domain}
		)
	
	@property
	def has_more_results(self):
		if self.results and len(self.results) < self._estimated_result_count:
			return True
		return False
	
	def get_actual_more_results_url(self):
		return self._more_results_url
	
	def get_actual_result_url(self, result):
		return result['unescapedUrl']
	
	def get_result_title(self, result):
		return mark_safe(result['titleNoFormatting'])
	
	def get_result_content(self, result):
		return mark_safe(result['content'])


registry.register(GoogleSearch)


try:
	from BeautifulSoup import BeautifulSoup, SoupStrainer, BeautifulStoneSoup
except:
	pass
else:
	__all__ += ('ScrapeSearch', 'XMLSearch',)
	class ScrapeSearch(URLSearch):
		"""A base class for scrape-style searching, available if :mod:`BeautifulSoup` is installed."""
		#: Arguments to be passed into a :class:`SoupStrainer`.
		strainer_args = []
		#: Keyword arguments to be passed into a :class:`SoupStrainer`.
		strainer_kwargs = {}
		
		@property
		def strainer(self):
			"""
			Caches and returns a :class:`SoupStrainer` initialized with :attr:`strainer_args` and :attr:`strainer_kwargs`. This strainer will be used to parse only certain parts of the document.
			
			.. seealso:: `BeautifulSoup: Improving Performance by Parsing Only Part of the Document <http://www.crummy.com/software/BeautifulSoup/documentation.html#Improving%20Performance%20by%20Parsing%20Only%20Part%20of%20the%20Document>`_
			
			"""
			if not hasattr(self, '_strainer'):
				self._strainer = SoupStrainer(*self.strainer_args, **self.strainer_kwargs)
			return self._strainer
		
		def parse_response(self, response, limit=None):
			strainer = self.strainer
			soup = BeautifulSoup(response, parseOnlyThese=strainer)
			return self.parse_results(soup.findAll(recursive=False, limit=limit))
		
		def parse_results(self, results):
			"""
			Provides a hook for parsing the results of straining. This has no default behavior and must be implemented by subclasses because the results absolutely must be parsed to properly extract the information.
			
			.. seealso:: `BeautifulSoup: Improving Memory Usage with extract <http://www.crummy.com/software/BeautifulSoup/documentation.html#Improving%20Memory%20Usage%20with%20extract>`_
			"""
			raise NotImplementedError
	
	
	class XMLSearch(ScrapeSearch):
		"""A base class for searching XML results."""
		#: Self-closing tag names to be used when interpreting the XML document
		#:
		#: .. seealso:: `BeautifulSoup: Parsing XML <http://www.crummy.com/software/BeautifulSoup/documentation.html#Parsing%20XML>`_
		self_closing_tags = []
		
		def parse_response(self, response, limit=None):
			strainer = self.strainer
			soup = BeautifulStoneSoup(response, selfClosingTags=self.self_closing_tags, parseOnlyThese=strainer)
			return self.parse_results(soup.findAll(recursive=False, limit=limit))
########NEW FILE########
__FILENAME__ = utils
from hashlib import sha1

from django.conf import settings
from django.http import QueryDict
from django.utils.encoding import smart_str
from django.utils.http import urlquote_plus, urlquote


SEARCH_ARG_GET_KEY = 'q'
URL_REDIRECT_GET_KEY = 'url'
HASH_REDIRECT_GET_KEY = 's'


def make_redirect_hash(search_arg, url):
	"""Hashes a redirect for a ``search_arg`` and ``url`` to avoid providing a simple URL spoofing service."""
	return sha1(smart_str(search_arg + url + settings.SECRET_KEY)).hexdigest()[::2]


def check_redirect_hash(hash, search_arg, url):
	"""Checks whether a hash is valid for a given ``search_arg`` and ``url``."""
	return hash == make_redirect_hash(search_arg, url)


def make_tracking_querydict(search_arg, url):
	"""Returns a :class:`QueryDict` instance containing the information necessary for tracking :class:`.Click`\ s on the ``url``."""
	return QueryDict("%s=%s&%s=%s&%s=%s" % (
		SEARCH_ARG_GET_KEY, urlquote_plus(search_arg),
 		URL_REDIRECT_GET_KEY, urlquote(url),
		HASH_REDIRECT_GET_KEY, make_redirect_hash(search_arg, url))
	)


class RegistryIterator(object):
	def __init__(self, registry, iterattr='__iter__', transform=lambda x:x):
		if not hasattr(registry, iterattr):
			raise AttributeError("Registry has no attribute %s" % iterattr)
		self.registry = registry
		self.iterattr = iterattr
		self.transform = transform
	
	def __iter__(self):
		return self
	
	def next(self):
		if not hasattr(self, '_iter'):
			self._iter = getattr(self.registry, self.iterattr)()
		
		return self.transform(self._iter.next())
	
	def copy(self):
		return self.__class__(self.registry, self.iterattr, self.transform)
########NEW FILE########
__FILENAME__ = forms
from datetime import date

from django import forms
from django.conf import settings
from django.contrib.auth import authenticate
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm
from django.contrib.auth.models import User
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _

from philo.contrib.waldo.tokens import REGISTRATION_TIMEOUT_DAYS


class EmailInput(forms.TextInput):
	"""Displays an HTML5 email input on browsers which support it and a normal text input on other browsers."""
	input_type = 'email'


class RegistrationForm(UserCreationForm):
	"""
	Handles user registration. If :mod:`recaptcha_django` is installed on the system and :class:`recaptcha_django.middleware.ReCaptchaMiddleware` is in :setting:`settings.MIDDLEWARE_CLASSES`, then a recaptcha field will automatically be added to the registration form.
	
	.. seealso:: `recaptcha-django <http://code.google.com/p/recaptcha-django/>`_
	
	"""
	#: An :class:`EmailField` using the :class:`EmailInput` widget.
	email = forms.EmailField(widget=EmailInput)
	try:
		from recaptcha_django import ReCaptchaField
	except ImportError:
		pass
	else:
		if 'recaptcha_django.middleware.ReCaptchaMiddleware' in settings.MIDDLEWARE_CLASSES:
			recaptcha = ReCaptchaField()
	
	def clean_username(self):
		username = self.cleaned_data['username']
		
		# Trivial case: if the username doesn't exist, go for it!
		try:
			user = User.objects.get(username=username)
		except User.DoesNotExist:
			return username
		
		if not user.is_active and (date.today() - user.date_joined.date()).days > REGISTRATION_TIMEOUT_DAYS and user.last_login == user.date_joined:
			# Then this is a user who has not confirmed their registration and whose time is up. Delete the old user and return the username.
			user.delete()
			return username
		
		raise ValidationError(_("A user with that username already exists."))
	
	def clean_email(self):
		if User.objects.filter(email__iexact=self.cleaned_data['email']):
			raise ValidationError(_('This email is already in use. Please supply a different email address'))
		return self.cleaned_data['email']
	
	def save(self):
		username = self.cleaned_data['username']
		email = self.cleaned_data['email']
		password = self.cleaned_data['password1']
		new_user = User.objects.create_user(username, email, password)
		new_user.is_active = False
		new_user.save()
		return new_user


class UserAccountForm(forms.ModelForm):
	"""Handles a user's account - by default, :attr:`auth.User.first_name`, :attr:`auth.User.last_name`, :attr:`auth.User.email`."""
	first_name = User._meta.get_field('first_name').formfield(required=True)
	last_name = User._meta.get_field('last_name').formfield(required=True)
	email = User._meta.get_field('email').formfield(required=True, widget=EmailInput)
	
	def __init__(self, user, *args, **kwargs):
		kwargs['instance'] = user
		super(UserAccountForm, self).__init__(*args, **kwargs)
	
	def email_changed(self):
		"""Returns ``True`` if the email field changed value and ``False`` if it did not, or if there is no email field on the form. This method must be supplied by account forms used with :mod:`~philo.contrib.waldo`."""
		return 'email' in self.changed_data
	
	def reset_email(self):
		"""
		ModelForms modify their instances in-place during :meth:`_post_clean`; this method resets the email value to its initial state and returns the altered value. This is a method on the form to allow unusual behavior such as storing email on a :class:`UserProfile`.
		
		"""
		email = self.instance.email
		self.instance.email = self.initial['email']
		self.cleaned_data.pop('email')
		return email
	
	@classmethod
	def set_email(cls, user, email):
		"""
		Given a valid instance and an email address, correctly set the email address for that instance and save the changes. This is a class method in order to allow unusual behavior such as storing email on a :class:`UserProfile`.
		
		"""
		user.email = email
		user.save()
		
	
	class Meta:
		model = User
		fields = ('first_name', 'last_name', 'email')


class WaldoAuthenticationForm(AuthenticationForm):
	"""Handles user authentication. Checks that the user has not mistakenly entered their email address (like :class:`django.contrib.admin.forms.AdminAuthenticationForm`) but does not require that the user be staff."""
	ERROR_MESSAGE = _("Please enter a correct username and password. Note that both fields are case-sensitive.")
	
	def clean(self):
		username = self.cleaned_data.get('username')
		password = self.cleaned_data.get('password')
		message = self.ERROR_MESSAGE
		
		if username and password:
			self.user_cache = authenticate(username=username, password=password)
			if self.user_cache is None:
				if u'@' in username:
					# Maybe they entered their email? Look it up, but still raise a ValidationError.
					try:
						user = User.objects.get(email=username)
					except (User.DoesNotExist, User.MultipleObjectsReturned):
						pass
					else:
						if user.check_password(password):
							message = _("Your e-mail address is not your username. Try '%s' instead.") % user.username
				raise ValidationError(message)
			elif not self.user_cache.is_active:
				raise ValidationError(message)
		self.check_for_test_cookie()
		return self.cleaned_data
########NEW FILE########
__FILENAME__ = models
"""
Waldo provides abstract :class:`.MultiView`\ s to handle several levels of common authentication:

* :class:`LoginMultiView` handles the case where users only need to be able to log in and out.
* :class:`PasswordMultiView` handles the case where users will also need to change their password.
* :class:`RegistrationMultiView` builds on top of :class:`PasswordMultiView` to handle user registration, as well.
* :class:`AccountMultiView` adds account-handling functionality to the :class:`RegistrationMultiView`.

"""

import urlparse

from django import forms
from django.conf.urls.defaults import url, patterns, include
from django.contrib import messages
from django.contrib.auth import authenticate, login, views as auth_views
from django.contrib.auth.forms import PasswordResetForm, SetPasswordForm, PasswordChangeForm
from django.contrib.auth.models import User
from django.contrib.auth.tokens import default_token_generator as password_token_generator
from django.contrib.sites.models import Site
from django.core.mail import EmailMultiAlternatives, send_mail
from django.db import models
from django.http import Http404, HttpResponseRedirect
from django.shortcuts import render_to_response, get_object_or_404
from django.template.defaultfilters import striptags
from django.utils.http import int_to_base36, base36_to_int
from django.utils.translation import ugettext as _
from django.views.decorators.cache import never_cache
from django.views.decorators.csrf import csrf_protect

from philo.models import MultiView, Page
from philo.contrib.waldo.forms import WaldoAuthenticationForm, RegistrationForm, UserAccountForm
from philo.contrib.waldo.tokens import registration_token_generator, email_token_generator


class LoginMultiView(MultiView):
	"""Handles exclusively methods and views related to logging users in and out."""
	#: A :class:`ForeignKey` to the :class:`.Page` which will be used to render the login form.
	login_page = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_login_related')
	#: A django form class which will be used for the authentication process. Default: :class:`.WaldoAuthenticationForm`.
	login_form = WaldoAuthenticationForm
	
	@property
	def urlpatterns(self):
		return patterns('',
			url(r'^login$', self.login, name='login'),
			url(r'^logout$', self.logout, name='logout'),
		)
	
	def set_requirement_redirect(self, request, redirect=None):
		"""Figures out and stores where a user should end up after landing on a page (like the login page) because they have not fulfilled some kind of requirement."""
		if redirect is not None:
			pass
		elif 'requirement_redirect' in request.session:
			return
		else:
			referrer = request.META.get('HTTP_REFERER', None)
		
			if referrer is not None:
				referrer = urlparse.urlparse(referrer)
				host = referrer[1]
				if host != request.get_host():
					referrer = None
				else:
					redirect = '%s?%s' % (referrer[2], referrer[4])
		
			path = request.get_full_path()
			if referrer is None or redirect == path:
				# Default to the index page if we can't find a referrer or
				# if we'd otherwise redirect to where we already are.
				redirect = request.node.get_absolute_url()
		
		request.session['requirement_redirect'] = redirect
	
	def get_requirement_redirect(self, request, default=None):
		"""Returns the location which a user should be redirected to after fulfilling a requirement (like logging in)."""
		redirect = request.session.pop('requirement_redirect', None)
		# Security checks a la django.contrib.auth.views.login
		if not redirect or ' ' in redirect:
			redirect = default
		else:
			netloc = urlparse.urlparse(redirect)[1]
			if netloc and netloc != request.get_host():
				redirect = default
		if redirect is None:
			redirect = request.node.get_absolute_url()
		return redirect
	
	@never_cache
	def login(self, request, extra_context=None):
		"""Renders the :attr:`login_page` with an instance of the :attr:`login_form` for the given :class:`HttpRequest`."""
		self.set_requirement_redirect(request)
		
		# Redirect already-authenticated users to the index page.
		if request.user.is_authenticated():
			messages.add_message(request, messages.INFO, "You are already authenticated. Please log out if you wish to log in as a different user.")
			return HttpResponseRedirect(self.get_requirement_redirect(request))
		
		if request.method == 'POST':
			form = self.login_form(request=request, data=request.POST)
			if form.is_valid():
				redirect = self.get_requirement_redirect(request)
				login(request, form.get_user())
				
				if request.session.test_cookie_worked():
					request.session.delete_test_cookie()
				
				return HttpResponseRedirect(redirect)
		else:
			form = self.login_form(request)
		
		request.session.set_test_cookie()
		
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'form': form
		})
		return self.login_page.render_to_response(request, extra_context=context)
	
	@never_cache
	def logout(self, request, extra_context=None):
		"""Logs the given :class:`HttpRequest` out, redirecting the user to the page they just left or to the :meth:`~.Node.get_absolute_url` for the ``request.node``."""
		return auth_views.logout(request, request.META.get('HTTP_REFERER', request.node.get_absolute_url()))
	
	def login_required(self, view):
		"""Wraps a view function to require that the user be logged in."""
		def inner(request, *args, **kwargs):
			if not request.user.is_authenticated():
				self.set_requirement_redirect(request, redirect=request.path)
				if request.POST:
					messages.add_message(request, messages.ERROR, "Please log in again, because your session has expired.")
				return HttpResponseRedirect(self.reverse('login', node=request.node))
			return view(request, *args, **kwargs)
		
		return inner
	
	class Meta:
		abstract = True


class PasswordMultiView(LoginMultiView):
	"""
	Adds support for password setting, resetting, and changing to the :class:`LoginMultiView`. Password reset support includes handling of a confirmation email.
	
	"""
	#: A :class:`ForeignKey` to the :class:`.Page` which will be used to render the password reset request form.
	password_reset_page = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_password_reset_related', blank=True, null=True)
	#: A :class:`ForeignKey` to the :class:`.Page` which will be used to render the password reset confirmation email.
	password_reset_confirmation_email = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_password_reset_confirmation_email_related', blank=True, null=True)
	#: A :class:`ForeignKey` to the :class:`.Page` which will be used to render the password setting form (i.e. the page that users will see after confirming a password reset).
	password_set_page = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_password_set_related', blank=True, null=True)
	#: A :class:`ForeignKey` to the :class:`.Page` which will be used to render the password change form.
	password_change_page = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_password_change_related', blank=True, null=True)
	
	#: The password change form class. Default: :class:`django.contrib.auth.forms.PasswordChangeForm`.
	password_change_form = PasswordChangeForm
	#: The password set form class. Default: :class:`django.contrib.auth.forms.SetPasswordForm`.
	password_set_form = SetPasswordForm
	#: The password reset request form class. Default: :class:`django.contrib.auth.forms.PasswordResetForm`.
	password_reset_form = PasswordResetForm
	
	@property
	def urlpatterns(self):
		urlpatterns = super(PasswordMultiView, self).urlpatterns
		
		if self.password_reset_page_id and self.password_reset_confirmation_email_id and self.password_set_page_id:
			urlpatterns += patterns('',
				url(r'^password/reset$', csrf_protect(self.password_reset), name='password_reset'),
				url(r'^password/reset/(?P<uidb36>\w+)/(?P<token>[^/]+)$', self.password_reset_confirm, name='password_reset_confirm'),
			)
		
		if self.password_change_page_id:
			urlpatterns += patterns('',
				url(r'^password/change$', csrf_protect(self.login_required(self.password_change)), name='password_change'),
			)
		return urlpatterns
	
	def make_confirmation_link(self, confirmation_view, token_generator, user, node, token_args=None, reverse_kwargs=None, secure=False):
		"""
		Generates a confirmation link for an arbitrary action, such as a password reset.
		
		:param confirmation_view: The view function which needs to be linked to.
		:param token_generator: Generates a confirmable token for the action.
		:param user: The user who is trying to take the action.
		:param node: The node which is providing the basis for the confirmation URL.
		:param token_args: A list of additional arguments (i.e. besides the user) to be used for token creation.
		:param reverse_kwargs: A dictionary of any additional keyword arguments necessary for correctly reversing the view.
		:param secure: Whether the link should use the https:// or http://.
		
		"""
		token = token_generator.make_token(user, *(token_args or []))
		kwargs = {
			'uidb36': int_to_base36(user.id),
			'token': token
		}
		kwargs.update(reverse_kwargs or {})
		return node.construct_url(subpath=self.reverse(confirmation_view, kwargs=kwargs), with_domain=True, secure=secure)
	
	def send_confirmation_email(self, subject, email, page, extra_context):
		"""
		Sends a confirmation email for an arbitrary action, such as a password reset. If the ``page``'s :class:`.Template` has a mimetype of ``text/html``, then the email will be sent with an HTML alternative version.
		
		:param subject: The subject line of the email.
		:param email: The recipient's address.
		:param page: The page which will be used to render the email body.
		:param extra_context: The context for rendering the ``page``.
		
		"""
		text_content = page.render_to_string(extra_context=extra_context)
		from_email = 'noreply@%s' % Site.objects.get_current().domain
		
		if page.template.mimetype == 'text/html':
			msg = EmailMultiAlternatives(subject, striptags(text_content), from_email, [email])
			msg.attach_alternative(text_content, 'text/html')
			msg.send()
		else:
			send_mail(subject, text_content, from_email, [email])
	
	def password_reset(self, request, extra_context=None, token_generator=password_token_generator):
		"""
		Handles the process by which users request a password reset, and generates the context for the confirmation email. That context will contain:
		
		link
			The confirmation link for the password reset.
		user
			The user requesting the reset.
		site
			The current :class:`Site`.
		request
			The current :class:`HttpRequest` instance.
		
		:param token_generator: The token generator to use for the confirmation link.
		
		"""
		if request.user.is_authenticated():
			return HttpResponseRedirect(request.node.get_absolute_url())
		
		if request.method == 'POST':
			form = self.password_reset_form(request.POST)
			if form.is_valid():
				current_site = Site.objects.get_current()
				for user in form.users_cache:
					context = {
						'link': self.make_confirmation_link('password_reset_confirm', token_generator, user, request.node, secure=request.is_secure()),
						'user': user,
						'site': current_site,
						'request': request
					}
					self.send_confirmation_email('Confirm password reset for account at %s' % current_site.domain, user.email, self.password_reset_confirmation_email, context)
					messages.add_message(request, messages.SUCCESS, "An email has been sent to the address you provided with details on resetting your password.", fail_silently=True)
				return HttpResponseRedirect('')
		else:
			form = self.password_reset_form()
		
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'form': form
		})
		return self.password_reset_page.render_to_response(request, extra_context=context)
	
	def password_reset_confirm(self, request, extra_context=None, uidb36=None, token=None, token_generator=password_token_generator):
		"""
		Checks that ``token``` is valid, and if so, renders an instance of :attr:`password_set_form` with :attr:`password_set_page`.
		
		:param token_generator: The token generator used to check the ``token``.
		
		"""
		assert uidb36 is not None and token is not None
		try:
			uid_int = base36_to_int(uidb36)
		except:
			raise Http404
		
		user = get_object_or_404(User, id=uid_int)
		
		if token_generator.check_token(user, token):
			if request.method == 'POST':
				form = self.password_set_form(user, request.POST)
				
				if form.is_valid():
					form.save()
					messages.add_message(request, messages.SUCCESS, "Password reset successful.")
					return HttpResponseRedirect(self.reverse('login', node=request.node))
			else:
				form = self.password_set_form(user)
			
			context = self.get_context()
			context.update(extra_context or {})
			context.update({
				'form': form
			})
			return self.password_set_page.render_to_response(request, extra_context=context)
		
		raise Http404
	
	def password_change(self, request, extra_context=None):
		"""Renders an instance of :attr:`password_change_form` with :attr:`password_change_page`."""
		if request.method == 'POST':
			form = self.password_change_form(request.user, request.POST)
			if form.is_valid():
				form.save()
				messages.add_message(request, messages.SUCCESS, 'Password changed successfully.', fail_silently=True)
				return HttpResponseRedirect('')
		else:
			form = self.password_change_form(request.user)
		
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'form': form
		})
		return self.password_change_page.render_to_response(request, extra_context=context)
	
	class Meta:
		abstract = True


class RegistrationMultiView(PasswordMultiView):
	"""Adds support for user registration to the :class:`PasswordMultiView`."""
	#: A :class:`ForeignKey` to the :class:`.Page` which will be used to display the registration form.
	register_page = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_register_related', blank=True, null=True)
	#: A :class:`ForeignKey` to the :class:`.Page` which will be used to render the registration confirmation email.
	register_confirmation_email = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_register_confirmation_email_related', blank=True, null=True)
	#: The registration form class. Default: :class:`.RegistrationForm`.
	registration_form = RegistrationForm
	
	@property
	def urlpatterns(self):
		urlpatterns = super(RegistrationMultiView, self).urlpatterns
		if self.register_page_id and self.register_confirmation_email_id:
			urlpatterns += patterns('',
				url(r'^register$', csrf_protect(self.register), name='register'),
				url(r'^register/(?P<uidb36>\w+)/(?P<token>[^/]+)$', self.register_confirm, name='register_confirm')
			)
		return urlpatterns
	
	def register(self, request, extra_context=None, token_generator=registration_token_generator):
		"""
		Renders the :attr:`register_page` with an instance of :attr:`registration_form` in the context as ``form``. If the form has been submitted, sends a confirmation email using :attr:`register_confirmation_email` and the same context as :meth:`PasswordMultiView.password_reset`.
		
		:param token_generator: The token generator to use for the confirmation link.
		
		"""
		if request.user.is_authenticated():
			return HttpResponseRedirect(request.node.get_absolute_url())
		
		if request.method == 'POST':
			form = self.registration_form(request.POST)
			if form.is_valid():
				user = form.save()
				current_site = Site.objects.get_current()
				context = {
					'link': self.make_confirmation_link('register_confirm', token_generator, user, request.node, secure=request.is_secure()),
					'user': user,
					'site': current_site,
					'request': request
				}
				self.send_confirmation_email('Confirm account creation at %s' % current_site.name, user.email, self.register_confirmation_email, context)
				messages.add_message(request, messages.SUCCESS, 'An email has been sent to %s with details on activating your account.' % user.email, fail_silently=True)
				return HttpResponseRedirect(request.node.get_absolute_url())
		else:
			form = self.registration_form()
		
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'form': form
		})
		return self.register_page.render_to_response(request, extra_context=context)
	
	def register_confirm(self, request, extra_context=None, uidb36=None, token=None, token_generator=registration_token_generator):
		"""
		Checks that ``token`` is valid, and if so, logs the user in and redirects them to :meth:`post_register_confirm_redirect`.
		
		:param token_generator: The token generator used to check the ``token``.
		"""
		assert uidb36 is not None and token is not None
		try:
			uid_int = base36_to_int(uidb36)
		except:
			raise Http404
		
		user = get_object_or_404(User, id=uid_int)
		if token_generator.check_token(user, token):
			user.is_active = True
			true_password = user.password
			temp_password = token_generator.make_token(user)
			try:
				user.set_password(temp_password)
				user.save()
				authenticated_user = authenticate(username=user.username, password=temp_password)
				login(request, authenticated_user)
			finally:
				# if anything goes wrong, do our best make sure that the true password is restored.
				user.password = true_password
				user.save()
			return self.post_register_confirm_redirect(request)
		
		raise Http404
	
	def post_register_confirm_redirect(self, request):
		"""Returns an :class:`HttpResponseRedirect` for post-registration-confirmation. Default: :meth:`Node.get_absolute_url` for ``request.node``."""
		return HttpResponseRedirect(request.node.get_absolute_url())
	
	class Meta:
		abstract = True


class AccountMultiView(RegistrationMultiView):
	"""Adds support for user accounts on top of the :class:`RegistrationMultiView`. By default, the account consists of the first_name, last_name, and email fields of the User model. Using a different account model is as simple as replacing :attr:`account_form` with any form class that takes an :class:`auth.User` instance as the first argument."""
	#: A :class:`ForeignKey` to the :class:`Page` which will be used to render the account management form.
	manage_account_page = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_manage_account_related', blank=True, null=True)
	#: A :class:`ForeignKey` to a :class:`Page` which will be used to render an email change confirmation email. This is optional; if it is left blank, then email changes will be performed without confirmation.
	email_change_confirmation_email = models.ForeignKey(Page, related_name='%(app_label)s_%(class)s_email_change_confirmation_email_related', blank=True, null=True, help_text="If this is left blank, email changes will be performed without confirmation.")
	
	#: A django form class which will be used to manage the user's account. Default: :class:`.UserAccountForm`
	account_form = UserAccountForm
	
	@property
	def urlpatterns(self):
		urlpatterns = super(AccountMultiView, self).urlpatterns
		if self.manage_account_page_id:
			urlpatterns += patterns('',
				url(r'^account$', self.login_required(self.account_view), name='account'),
			)
		if self.email_change_confirmation_email_id:
			urlpatterns += patterns('',
				url(r'^account/email/(?P<uidb36>\w+)/(?P<email>[\w.]+[+][\w.]+)/(?P<token>[^/]+)$', self.email_change_confirm, name='email_change_confirm')
			)
		return urlpatterns
	
	def account_view(self, request, extra_context=None, token_generator=email_token_generator, *args, **kwargs):
		"""
		Renders the :attr:`manage_account_page` with an instance of :attr:`account_form` in the context as ``form``. If the form has been posted, the user's email was changed, and :attr:`email_change_confirmation_email` is not ``None``, sends a confirmation email to the new email to make sure it exists before making the change. The email will have the same context as :meth:`PasswordMultiView.password_reset`.
		
		:param token_generator: The token generator to use for the confirmation link. 
		
		"""
		if request.method == 'POST':
			form = self.account_form(request.user, request.POST, request.FILES)
			
			if form.is_valid():
				message = "Account information saved."
				redirect = self.get_requirement_redirect(request, default='')
				if form.email_changed() and self.email_change_confirmation_email:
					email = form.reset_email()
					
					current_site = Site.objects.get_current()
					
					context = {
						'link': self.make_confirmation_link('email_change_confirm', token_generator, request.user, request.node, token_args=[email], reverse_kwargs={'email': email.replace('@', '+')}, secure=request.is_secure()),
						'user': request.user,
						'site': current_site,
						'request': request
					}
					self.send_confirmation_email('Confirm account email change at %s' % current_site.domain, email, self.email_change_confirmation_email, context)
					
					message = "An email has be sent to %s to confirm the email%s." % (email, " change" if bool(request.user.email) else "")
					if not request.user.email:
						message += " You will need to confirm the email before accessing pages that require a valid account."
						redirect = ''
				
				form.save()
				
				if redirect != '':
					message += " Here you go!"
				
				messages.add_message(request, messages.SUCCESS, message, fail_silently=True)
				return HttpResponseRedirect(redirect)
		else:
			form = self.account_form(request.user)
		
		context = self.get_context()
		context.update(extra_context or {})
		context.update({
			'form': form
		})
		return self.manage_account_page.render_to_response(request, extra_context=context)
	
	def has_valid_account(self, user):
		"""Returns ``True`` if the ``user`` has a valid account and ``False`` otherwise."""
		form = self.account_form(user, {})
		form.data = form.initial
		return form.is_valid()
	
	def account_required(self, view):
		"""Wraps a view function to allow access only to users with valid accounts and otherwise redirect them to the :meth:`account_view`."""
		def inner(request, *args, **kwargs):
			if not self.has_valid_account(request.user):
				messages.add_message(request, messages.ERROR, "You need to add some account information before you can access that page.", fail_silently=True)
				if self.manage_account_page:
					self.set_requirement_redirect(request, redirect=request.path)
					redirect = self.reverse('account', node=request.node)
				else:
					redirect = request.node.get_absolute_url()
				return HttpResponseRedirect(redirect)
			return view(request, *args, **kwargs)
		
		inner = self.login_required(inner)
		return inner
	
	def post_register_confirm_redirect(self, request):
		"""Automatically redirects users to the :meth:`account_view` after registration."""
		if self.manage_account_page:
			messages.add_message(request, messages.INFO, 'Welcome! Please fill in some more information.', fail_silently=True)
			return HttpResponseRedirect(self.reverse('account', node=request.node))
		return super(AccountMultiView, self).post_register_confirm_redirect(request)
	
	def email_change_confirm(self, request, extra_context=None, uidb36=None, token=None, email=None, token_generator=email_token_generator):
		"""
		Checks that ``token`` is valid, and if so, changes the user's email.
		
		:param token_generator: The token generator used to check the ``token``.
		
		"""
		assert uidb36 is not None and token is not None and email is not None
		
		try:
			uid_int = base36_to_int(uidb36)
		except:
			raise Http404
		
		user = get_object_or_404(User, id=uid_int)
		
		email = '@'.join(email.rsplit('+', 1))
		
		if email == user.email:
			# Then short-circuit.
			raise Http404
		
		if token_generator.check_token(user, email, token):
			self.account_form.set_email(user, email)
			messages.add_message(request, messages.SUCCESS, 'Email changed successfully.')
			if self.manage_account_page:
				redirect = self.reverse('account', node=request.node)
			else:
				redirect = request.node.get_absolute_url()
			return HttpResponseRedirect(redirect)
		
		raise Http404
	
	class Meta:
		abstract = True
########NEW FILE########
__FILENAME__ = tokens
"""
Based on :mod:`django.contrib.auth.tokens`. Supports the following settings:

:setting:`WALDO_REGISTRATION_TIMEOUT_DAYS`
	The number of days a registration link will be valid before expiring. Default: 1.

:setting:`WALDO_EMAIL_TIMEOUT_DAYS`
	The number of days an email change link will be valid before expiring. Default: 1.

"""

from hashlib import sha1
from datetime import date

from django.conf import settings
from django.utils.http import int_to_base36, base36_to_int
from django.contrib.auth.tokens import PasswordResetTokenGenerator


REGISTRATION_TIMEOUT_DAYS = getattr(settings, 'WALDO_REGISTRATION_TIMEOUT_DAYS', 1)
EMAIL_TIMEOUT_DAYS = getattr(settings, 'WALDO_EMAIL_TIMEOUT_DAYS', 1)


class RegistrationTokenGenerator(PasswordResetTokenGenerator):
	"""Strategy object used to generate and check tokens for the user registration mechanism."""
	
	def check_token(self, user, token):
		"""Check that a registration token is correct for a given user."""
		# If the user is active, the hash can't be valid.
		if user.is_active:
			return False
		
		# Parse the token
		try:
			ts_b36, hash = token.split('-')
		except ValueError:
			return False
		
		try:
			ts = base36_to_int(ts_b36)
		except ValueError:
			return False
		
		# Check that the timestamp and uid have not been tampered with.
		if self._make_token_with_timestamp(user, ts) != token:
			return False
		
		# Check that the timestamp is within limit
		if (self._num_days(self._today()) - ts) > REGISTRATION_TIMEOUT_DAYS:
			return False
		
		return True
	
	def _make_token_with_timestamp(self, user, timestamp):
		ts_b36 = int_to_base36(timestamp)
		
		# By hashing on the internal state of the user and using state that is
		# sure to change, we produce a hash that will be invalid as soon as it
		# is used.
		hash = sha1(settings.SECRET_KEY + unicode(user.id) + unicode(user.is_active) + user.last_login.strftime('%Y-%m-%d %H:%M:%S') + unicode(timestamp)).hexdigest()[::2]
		return '%s-%s' % (ts_b36, hash)


registration_token_generator = RegistrationTokenGenerator()


class EmailTokenGenerator(PasswordResetTokenGenerator):
	"""Strategy object used to generate and check tokens for a user email change mechanism."""
	
	def make_token(self, user, email):
		"""Returns a token that can be used once to do an email change for the given user and email."""
		return self._make_token_with_timestamp(user, email, self._num_days(self._today()))
	
	def check_token(self, user, email, token):
		if email == user.email:
			return False
		
		# Parse the token
		try:
			ts_b36, hash = token.split('-')
		except ValueError:
			return False
		
		try:
			ts = base36_to_int(ts_b36)
		except ValueError:
			return False
		
		# Check that the timestamp and uid have not been tampered with.
		if self._make_token_with_timestamp(user, email, ts) != token:
			return False
		
		# Check that the timestamp is within limit
		if (self._num_days(self._today()) - ts) > EMAIL_TIMEOUT_DAYS:
			return False
		
		return True
	
	def _make_token_with_timestamp(self, user, email, timestamp):
		ts_b36 = int_to_base36(timestamp)
		
		hash = sha1(settings.SECRET_KEY + unicode(user.id) + user.email + email + unicode(timestamp)).hexdigest()[::2]
		return '%s-%s' % (ts_b36, hash)


email_token_generator = EmailTokenGenerator()
########NEW FILE########
__FILENAME__ = exceptions
class HttpNotAcceptable(Exception):
	"""This will be raised in :meth:`.FeedView.get_feed_type` if an Http-Accept header will not accept any of the feed content types that are available."""
	pass
########NEW FILE########
__FILENAME__ = feeds
from django.utils.feedgenerator import Atom1Feed, Rss201rev2Feed

from philo.utils.registry import Registry


DEFAULT_FEED = Atom1Feed


registry = Registry()


registry.register(Atom1Feed, verbose_name='Atom')
registry.register(Rss201rev2Feed, verbose_name='RSS')
########NEW FILE########
__FILENAME__ = middleware
from django.http import HttpResponse
from django.utils.decorators import decorator_from_middleware

from philo.contrib.winer.exceptions import HttpNotAcceptable


class HttpNotAcceptableMiddleware(object):
	"""Middleware to catch :exc:`~philo.contrib.winer.exceptions.HttpNotAcceptable` and return an :class:`HttpResponse` with a 406 response code. See :rfc:`2616`."""
	def process_exception(self, request, exception):
		if isinstance(exception, HttpNotAcceptable):
			return HttpResponse(status=406)


http_not_acceptable = decorator_from_middleware(HttpNotAcceptableMiddleware)
########NEW FILE########
__FILENAME__ = models
from django.conf import settings
from django.conf.urls.defaults import url, patterns, include
from django.contrib.sites.models import Site, RequestSite
from django.contrib.syndication.views import add_domain
from django.db import models
from django.http import HttpResponse
from django.template import RequestContext, Template as DjangoTemplate
from django.utils import feedgenerator, tzinfo
from django.utils.encoding import smart_unicode, force_unicode
from django.utils.html import escape

from philo.contrib.winer.exceptions import HttpNotAcceptable
from philo.contrib.winer.feeds import registry, DEFAULT_FEED
from philo.contrib.winer.middleware import http_not_acceptable
from philo.models import Page, Template, MultiView

try:
	import mimeparse
except:
	mimeparse = None


class FeedView(MultiView):
	"""
	:class:`FeedView` is an abstract model which handles a number of pages and related feeds for a single object such as a blog or newsletter. In addition to all other methods and attributes, :class:`FeedView` supports the same generic API as `django.contrib.syndication.views.Feed <http://docs.djangoproject.com/en/dev/ref/contrib/syndication/#django.contrib.syndication.django.contrib.syndication.views.Feed>`_.
	
	"""
	#: The type of feed which should be served by the :class:`FeedView`.
	feed_type = models.CharField(max_length=50, choices=registry.choices, default=registry.get_slug(DEFAULT_FEED))
	#: The suffix which will be appended to a page URL for a :attr:`feed_type` feed of its items. Default: "feed". Note that RSS and Atom feeds will always be available at ``<page_url>/rss`` and ``<page_url>/atom`` regardless of the value of this setting.
	#:
	#: .. seealso:: :meth:`get_feed_type`, :meth:`feed_patterns`
	feed_suffix = models.CharField(max_length=255, blank=False, default="feed")
	#: A :class:`BooleanField` - whether or not feeds are enabled.
	feeds_enabled = models.BooleanField(default=True)
	#: A :class:`PositiveIntegerField` - the maximum number of items to return for this feed. All items will be returned if this field is blank. Default: 15.
	feed_length = models.PositiveIntegerField(blank=True, null=True, default=15, help_text="The maximum number of items to return for this feed. All items will be returned if this field is blank.")
	
	#: A :class:`ForeignKey` to a :class:`.Template` which will be used to render the title of each item in the feed if provided.
	item_title_template = models.ForeignKey(Template, blank=True, null=True, related_name="%(app_label)s_%(class)s_title_related")
	#: A :class:`ForeignKey` to a :class:`.Template` which will be used to render the description of each item in the feed if provided.
	item_description_template = models.ForeignKey(Template, blank=True, null=True, related_name="%(app_label)s_%(class)s_description_related")
	
	#: An attribute holding the name of the context variable to be populated with the items managed by the :class:`FeedView`. Default: "items"
	item_context_var = 'items'
	#: An attribute holding the name of the attribute on a subclass of :class:`FeedView` which will contain the main object of a feed (such as a :class:`~philo.contrib.penfield.models.Blog`.) Default: "object"
	#:
	#: Example::
	#:
	#:     class BlogView(FeedView):
	#:         blog = models.ForeignKey(Blog)
	#:         
	#:         object_attr = 'blog'
	#:         item_context_var = 'entries'
	object_attr = 'object'
	
	#: An attribute holding a description of the feeds served by the :class:`FeedView`. This is a required part of the :class:`django.contrib.syndication.view.Feed` API.
	description = ""
	
	def feed_patterns(self, base, get_items_attr, page_attr, reverse_name):
		"""
		Given the name to be used to reverse this view and the names of the attributes for the function that fetches the objects, returns patterns suitable for inclusion in urlpatterns. In addition to ``base`` (which will serve the page at ``page_attr``) and ``base`` + :attr:`feed_suffix` (which will serve a :attr:`feed_type` feed), patterns will be provided for each registered feed type as ``base`` + ``slug``.
		
		:param base: The base of the returned patterns - that is, the subpath pattern which will reference the page for the items. The :attr:`feed_suffix` will be appended to this subpath.
		:param get_items_attr: A callable or the name of a callable on the :class:`FeedView` which will return an (``items``, ``extra_context``) tuple. This will be passed directly to :meth:`feed_view` and :meth:`page_view`.
		:param page_attr: A :class:`.Page` instance or the name of an attribute on the :class:`FeedView` which contains a :class:`.Page` instance. This will be passed directly to :meth:`page_view` and will be rendered with the items from ``get_items_attr``.
		:param reverse_name: The string which is considered the "name" of the view function returned by :meth:`page_view` for the given parameters.
		:returns: Patterns suitable for use in urlpatterns.
		
		Example::
		
			class BlogView(FeedView):
			    blog = models.ForeignKey(Blog)
			    entry_archive_page = models.ForeignKey(Page)
			    
			    @property
			    def urlpatterns(self):
			        urlpatterns = self.feed_patterns(r'^', 'get_all_entries', 'index_page', 'index')
			        urlpatterns += self.feed_patterns(r'^(?P<year>\d{4})/(?P<month>\d{2})/(?P<day>\d{2})', 'get_entries_by_ymd', 'entry_archive_page', 'entries_by_day')
			        return urlpatterns
			    
			    def get_entries_by_ymd(request, year, month, day, extra_context=None):
			        entries = Blog.entries.all()
			        # filter entries based on the year, month, and day.
			        return entries, extra_context
		
		.. seealso:: :meth:`get_feed_type`
		
		"""
		feed_patterns = ()
		if self.feeds_enabled:
			suffixes = [(self.feed_suffix, None)] + [(slug, slug) for slug in registry]
			for suffix, feed_type in suffixes:
				feed_view = http_not_acceptable(self.feed_view(get_items_attr, reverse_name, feed_type))
				feed_pattern = r'%s%s%s$' % (base, "/" if base and base[-1] != "^" else "", suffix)
				feed_patterns += (url(feed_pattern, feed_view, name="%s_%s" % (reverse_name, suffix)),)
		feed_patterns += (url(r"%s$" % base, self.page_view(get_items_attr, page_attr), name=reverse_name),)
		return patterns('', *feed_patterns)
	
	def get_object(self, request, **kwargs):
		"""By default, returns the object stored in the attribute named by :attr:`object_attr`. This can be overridden for subclasses that publish different data for different URL parameters. It is part of the :class:`django.contrib.syndication.views.Feed` API."""
		return getattr(self, self.object_attr)
	
	def feed_view(self, get_items_attr, reverse_name, feed_type=None):
		"""
		Returns a view function that renders a list of items as a feed.
		
		:param get_items_attr: A callable or the name of a callable on the :class:`FeedView` that will return a (items, extra_context) tuple when called with the object for the feed and view arguments.
		:param reverse_name: The name which can be used reverse the page for this feed using the :class:`FeedView` as the urlconf.
		:param feed_type: The slug used to render the feed class which will be used by the returned view function.
		
		:returns: A view function that renders a list of items as a feed.
		
		"""
		get_items = get_items_attr if callable(get_items_attr) else getattr(self, get_items_attr)
		
		def inner(request, extra_context=None, *args, **kwargs):
			obj = self.get_object(request, *args, **kwargs)
			feed = self.get_feed(obj, request, reverse_name, feed_type, *args, **kwargs)
			items, xxx = get_items(obj, request, extra_context=extra_context, *args, **kwargs)
			self.populate_feed(feed, items, request)
			
			response = HttpResponse(mimetype=feed.mime_type)
			feed.write(response, 'utf-8')
			return response
		
		return inner
	
	def page_view(self, get_items_attr, page_attr):
		"""
		:param get_items_attr: A callable or the name of a callable on the :class:`FeedView` that will return a (items, extra_context) tuple when called with view arguments.
		:param page_attr: A :class:`.Page` instance or the name of an attribute on the :class:`FeedView` which contains a :class:`.Page` instance. This will be rendered with the items from ``get_items_attr``.
		
		:returns: A view function that renders a list of items as an :class:`HttpResponse`.
		
		"""
		get_items = get_items_attr if callable(get_items_attr) else getattr(self, get_items_attr)
		
		def inner(request, extra_context=None, *args, **kwargs):
			obj = self.get_object(request, *args, **kwargs)
			items, extra_context = get_items(obj, request, extra_context=extra_context, *args, **kwargs)
			items, item_context = self.process_page_items(request, items)
			
			context = self.get_context()
			context.update(extra_context or {})
			context.update(item_context or {})
			
			page = page_attr if isinstance(page_attr, Page) else getattr(self, page_attr)
			return page.render_to_response(request, extra_context=context)
		return inner
	
	def process_page_items(self, request, items):
		"""
		Hook for handling any extra processing of ``items`` based on an :class:`HttpRequest`, such as pagination or searching. This method is expected to return a list of items and a dictionary to be added to the page context.
		
		"""
		item_context = {
			self.item_context_var: items
		}
		return items, item_context
	
	def get_feed_type(self, request, feed_type=None):
		"""
		If ``feed_type`` is not ``None``, returns the corresponding class from the registry or raises :exc:`.HttpNotAcceptable`.
		
		Otherwise, intelligently chooses a feed type for a given request. Tries to return :attr:`feed_type`, but if the Accept header does not include that mimetype, tries to return the best match from the feed types that are offered by the :class:`FeedView`. If none of the offered feed types are accepted by the :class:`HttpRequest`, raises :exc:`.HttpNotAcceptable`.
		
		If `mimeparse <http://code.google.com/p/mimeparse/>`_ is installed, it will be used to select the best matching accepted format; otherwise, the first available format that is accepted will be selected.
		
		"""
		if feed_type is not None:
			feed_type = registry[feed_type]
			loose = False
		else:
			feed_type = registry.get(self.feed_type, DEFAULT_FEED)
			loose = True
		mt = feed_type.mime_type
		accept = request.META.get('HTTP_ACCEPT')
		if accept and mt not in accept and "*/*" not in accept and "%s/*" % mt.split("/")[0] not in accept:
			# Wups! They aren't accepting the chosen format.
			feed_type = None
			if loose:
				# Is there another format we can use?
				accepted_mts = dict([(obj.mime_type, obj) for obj in registry.values()])
				if mimeparse:
					mt = mimeparse.best_match(accepted_mts.keys(), accept)
					if mt:
						feed_type = accepted_mts[mt]
				else:
					for mt in accepted_mts:
						if mt in accept or "%s/*" % mt.split("/")[0] in accept:
							feed_type = accepted_mts[mt]
							break
			if not feed_type:
				raise HttpNotAcceptable
		return feed_type
	
	def get_feed(self, obj, request, reverse_name, feed_type=None, *args, **kwargs):
		"""
		Returns an unpopulated :class:`django.utils.feedgenerator.DefaultFeed` object for this object.
		
		:param obj: The object for which the feed should be generated.
		:param request: The current request.
		:param reverse_name: The name which can be used to reverse the URL of the page corresponding to this feed.
		:param feed_type: The slug used to register the feed class that will be instantiated and returned.
		
		:returns: An instance of the feed class registered as ``feed_type``, falling back to :attr:`feed_type` if ``feed_type`` is ``None``.
		
		"""
		try:
			current_site = Site.objects.get_current()
		except Site.DoesNotExist:
			current_site = RequestSite(request)
		
		feed_type = self.get_feed_type(request, feed_type)
		node = request.node
		link = node.construct_url(self.reverse(reverse_name, args=args, kwargs=kwargs), with_domain=True, request=request, secure=request.is_secure())
		
		feed = feed_type(
			title = self.__get_dynamic_attr('title', obj),
			subtitle = self.__get_dynamic_attr('subtitle', obj),
			link = link,
			description = self.__get_dynamic_attr('description', obj),
			language = settings.LANGUAGE_CODE.decode(),
			feed_url = add_domain(
				current_site.domain,
				self.__get_dynamic_attr('feed_url', obj) or node.construct_url(self.reverse("%s_%s" % (reverse_name, registry.get_slug(feed_type)), args=args, kwargs=kwargs), with_domain=True, request=request, secure=request.is_secure()),
				request.is_secure()
			),
			author_name = self.__get_dynamic_attr('author_name', obj),
			author_link = self.__get_dynamic_attr('author_link', obj),
			author_email = self.__get_dynamic_attr('author_email', obj),
			categories = self.__get_dynamic_attr('categories', obj),
			feed_copyright = self.__get_dynamic_attr('feed_copyright', obj),
			feed_guid = self.__get_dynamic_attr('feed_guid', obj),
			ttl = self.__get_dynamic_attr('ttl', obj),
			**self.feed_extra_kwargs(obj)
		)
		return feed
	
	def populate_feed(self, feed, items, request):
		"""Populates a :class:`django.utils.feedgenerator.DefaultFeed` instance as is returned by :meth:`get_feed` with the passed-in ``items``."""
		if self.item_title_template:
			title_template = DjangoTemplate(self.item_title_template.code)
		else:
			title_template = None
		if self.item_description_template:
			description_template = DjangoTemplate(self.item_description_template.code)
		else:
			description_template = None
		
		node = request.node
		try:
			current_site = Site.objects.get_current()
		except Site.DoesNotExist:
			current_site = RequestSite(request)
		
		if self.feed_length is not None:
			items = items[:self.feed_length]
		
		for item in items:
			if title_template is not None:
				title = title_template.render(RequestContext(request, {'obj': item}))
			else:
				title = self.__get_dynamic_attr('item_title', item)
			if description_template is not None:
				description = description_template.render(RequestContext(request, {'obj': item}))
			else:
				description = self.__get_dynamic_attr('item_description', item)
			
			link = node.construct_url(self.reverse(obj=item), with_domain=True, request=request, secure=request.is_secure())
			
			enc = None
			enc_url = self.__get_dynamic_attr('item_enclosure_url', item)
			if enc_url:
				enc = feedgenerator.Enclosure(
					url = smart_unicode(add_domain(
							current_site.domain,
							enc_url,
							request.is_secure()
					)),
					length = smart_unicode(self.__get_dynamic_attr('item_enclosure_length', item)),
					mime_type = smart_unicode(self.__get_dynamic_attr('item_enclosure_mime_type', item))
				)
			author_name = self.__get_dynamic_attr('item_author_name', item)
			if author_name is not None:
				author_email = self.__get_dynamic_attr('item_author_email', item)
				author_link = self.__get_dynamic_attr('item_author_link', item)
			else:
				author_email = author_link = None
			
			pubdate = self.__get_dynamic_attr('item_pubdate', item)
			if pubdate and not pubdate.tzinfo:
				ltz = tzinfo.LocalTimezone(pubdate)
				pubdate = pubdate.replace(tzinfo=ltz)
			
			feed.add_item(
				title = title,
				link = link,
				description = description,
				unique_id = self.__get_dynamic_attr('item_guid', item, link),
				enclosure = enc,
				pubdate = pubdate,
				author_name = author_name,
				author_email = author_email,
				author_link = author_link,
				categories = self.__get_dynamic_attr('item_categories', item),
				item_copyright = self.__get_dynamic_attr('item_copyright', item),
				**self.item_extra_kwargs(item)
			)
	
	def __get_dynamic_attr(self, attname, obj, default=None):
		try:
			attr = getattr(self, attname)
		except AttributeError:
			return default
		if callable(attr):
			# Check func_code.co_argcount rather than try/excepting the
			# function and catching the TypeError, because something inside
			# the function may raise the TypeError. This technique is more
			# accurate.
			if hasattr(attr, 'func_code'):
				argcount = attr.func_code.co_argcount
			else:
				argcount = attr.__call__.func_code.co_argcount
			if argcount == 2: # one argument is 'self'
				return attr(obj)
			else:
				return attr()
		return attr
	
	def feed_extra_kwargs(self, obj):
		"""Returns an extra keyword arguments dictionary that is used when initializing the feed generator."""
		return {}
	
	def item_extra_kwargs(self, item):
		"""Returns an extra keyword arguments dictionary that is used with the `add_item` call of the feed generator."""
		return {}
	
	def item_title(self, item):
		return escape(force_unicode(item))
	
	def item_description(self, item):
		return force_unicode(item)
	
	class Meta:
		abstract=True
########NEW FILE########
__FILENAME__ = exceptions
from django.core.exceptions import ImproperlyConfigured


#: Raised if ``request.node`` is required but not present. For example, this can be raised by :func:`philo.views.node_view`. :data:`MIDDLEWARE_NOT_CONFIGURED` is an instance of :exc:`django.core.exceptions.ImproperlyConfigured`.
MIDDLEWARE_NOT_CONFIGURED = ImproperlyConfigured("""Philo requires the RequestNode middleware to be installed. Edit your MIDDLEWARE_CLASSES setting to insert 'philo.middleware.RequestNodeMiddleware'.""")


class ViewDoesNotProvideSubpaths(Exception):
	"""Raised by :meth:`.View.reverse` when the :class:`.View` does not provide subpaths (the default)."""
	silent_variable_failure = True


class ViewCanNotProvideSubpath(Exception):
	"""Raised by :meth:`.View.reverse` when the :class:`.View` can not provide a subpath for the supplied arguments."""
	silent_variable_failure = True


class AncestorDoesNotExist(Exception):
	"""Raised by :meth:`.TreeEntity.get_path` if the root instance is not an ancestor of the current instance."""
	pass
########NEW FILE########
__FILENAME__ = entities
from django.forms.models import ModelFormMetaclass, ModelForm, ModelFormOptions
from django.utils.datastructures import SortedDict

from philo.utils import fattr


__all__ = ('EntityForm',)


def proxy_fields_for_entity_model(entity_model, fields=None, exclude=None, widgets=None, formfield_callback=None):
	field_list = []
	ignored = []
	opts = entity_model._entity_meta
	for f in opts.proxy_fields:
		if not f.editable:
			continue
		if fields and not f.name in fields:
			continue
		if exclude and f.name in exclude:
			continue
		if widgets and f.name in widgets:
			kwargs = {'widget': widgets[f.name]}
		else:
			kwargs = {}
		
		if formfield_callback is None:
			formfield = f.formfield(**kwargs)
		elif not callable(formfield_callback):
			raise TypeError('formfield_callback must be a function or callable')
		else:
			formfield = formfield_callback(f, **kwargs)
		
		if formfield:
			field_list.append((f.name, formfield))
		else:
			ignored.append(f.name)
	field_dict = SortedDict(field_list)
	if fields:
		field_dict = SortedDict(
			[(f, field_dict.get(f)) for f in fields
				if ((not exclude) or (exclude and f not in exclude)) and (f not in ignored) and (f in field_dict)]
		)
	return field_dict


# HACK until http://code.djangoproject.com/ticket/14082 is resolved.
_old = ModelFormMetaclass.__new__
def _new(cls, name, bases, attrs):
	if cls == ModelFormMetaclass:
		m = attrs.get('__metaclass__', None)
		if m is None:
			parents = [b for b in bases if issubclass(b, ModelForm)]
			for c in parents:
				if c.__metaclass__ != ModelFormMetaclass:
					m = c.__metaclass__
					break
	
		if m is not None:
			return m(name, bases, attrs)
	
	return _old(cls, name, bases, attrs)
ModelFormMetaclass.__new__ = staticmethod(_new)
# END HACK


class EntityFormMetaclass(ModelFormMetaclass):
	def __new__(cls, name, bases, attrs):
		try:
			parents = [b for b in bases if issubclass(b, EntityForm)]
		except NameError:
			# We are defining EntityForm itself
			parents = None
		sup = super(EntityFormMetaclass, cls)
		
		if not parents:
			# Then there's no business trying to use proxy fields.
			return sup.__new__(cls, name, bases, attrs)
		
		# Fake a declaration of all proxy fields so they'll be handled correctly.
		opts = ModelFormOptions(attrs.get('Meta', None))
		
		if opts.model:
			formfield_callback = attrs.get('formfield_callback', None)
			proxy_fields = proxy_fields_for_entity_model(opts.model, opts.fields, opts.exclude, opts.widgets, formfield_callback)
		else:
			proxy_fields = {}
		
		new_attrs = proxy_fields.copy()
		new_attrs.update(attrs)
		
		new_class = sup.__new__(cls, name, bases, new_attrs)
		new_class.proxy_fields = proxy_fields
		return new_class


class EntityForm(ModelForm):
	"""
	:class:`EntityForm` knows how to handle :class:`.Entity` instances - specifically, how to set initial values for :class:`.AttributeProxyField`\ s and save cleaned values to an instance on save.
	
	"""
	__metaclass__ = EntityFormMetaclass
	
	def __init__(self, *args, **kwargs):
		initial = kwargs.pop('initial', None)
		instance = kwargs.get('instance', None)
		if instance is not None:
			new_initial = {}
			for f in instance._entity_meta.proxy_fields:
				if self._meta.fields and not f.name in self._meta.fields:
					continue
				if self._meta.exclude and f.name in self._meta.exclude:
					continue
				new_initial[f.name] = f.value_from_object(instance)
		else:
			new_initial = {}
		if initial is not None:
			new_initial.update(initial)
		kwargs['initial'] = new_initial
		super(EntityForm, self).__init__(*args, **kwargs)
	
	@fattr(alters_data=True)
	def save(self, commit=True):
		cleaned_data = self.cleaned_data
		instance = super(EntityForm, self).save(commit=False)
		
		for f in instance._entity_meta.proxy_fields:
			if not f.editable or not f.name in cleaned_data:
				continue
			if self._meta.fields and f.name not in self._meta.fields:
				continue
			if self._meta.exclude and f.name in self._meta.exclude:
				continue
			setattr(instance, f.attname, f.get_storage_value(cleaned_data[f.name]))
		
		if commit:
			instance.save()
			self.save_m2m()
		
		return instance
########NEW FILE########
__FILENAME__ = fields
from django import forms
from django.core.exceptions import ValidationError
from django.utils import simplejson as json

from philo.validators import json_validator


__all__ = ('JSONFormField',)


class JSONFormField(forms.Field):
	"""A form field which is validated by :func:`philo.validators.json_validator`."""
	default_validators = [json_validator]
	
	def clean(self, value):
		if value == '' and not self.required:
			return None
		try:
			return json.loads(value)
		except Exception, e:
			raise ValidationError(u'JSON decode error: %s' % e)
########NEW FILE########
__FILENAME__ = database
from django.template import TemplateDoesNotExist
from django.template.loader import BaseLoader
from django.utils.encoding import smart_unicode

from philo.models import Template


class Loader(BaseLoader):
	"""
	:class:`philo.loaders.database.Loader` enables loading of template code from :class:`.Template`\ s. This would let :class:`.Template`\ s be used with ``{% include %}`` and ``{% extends %}`` tags, as well as any other features that use template loading.
	
	"""
	is_usable=True
	
	def load_template_source(self, template_name, template_dirs=None):
		try:
			template = Template.objects.get_with_path(template_name)
		except Template.DoesNotExist:
			raise TemplateDoesNotExist(template_name)
		return (template.code, smart_unicode(template))
########NEW FILE########
__FILENAME__ = middleware
from django.conf import settings
from django.contrib.sites.models import Site
from django.http import Http404

from philo.models import Node, View
from philo.utils.lazycompat import SimpleLazyObject


def get_node(path):
	"""Returns a :class:`Node` instance at ``path`` (relative to the current site) or ``None``."""
	try:
		current_site = Site.objects.get_current()
	except Site.DoesNotExist:
		current_site = None
	
	trailing_slash = False
	if path[-1] == '/':
		trailing_slash = True
	
	try:
		node, subpath = Node.objects.get_with_path(path, root=getattr(current_site, 'root_node', None), absolute_result=False)
	except Node.DoesNotExist:
		return None
	
	if subpath is None:
		subpath = ""
	subpath = "/" + subpath
	
	if trailing_slash and subpath[-1] != "/":
		subpath += "/"
	
	node._path = path
	node._subpath = subpath
	
	return node


class RequestNodeMiddleware(object):
	"""
	Adds a ``node`` attribute, representing the currently-viewed :class:`.Node`, to every incoming :class:`HttpRequest` object. This is required by :func:`philo.views.node_view`.
	
	:class:`RequestNodeMiddleware` also catches all exceptions raised while handling requests that have attached :class:`.Node`\ s if :setting:`settings.DEBUG` is ``True``. If a :exc:`django.http.Http404` error was caught, :class:`RequestNodeMiddleware` will look for an "Http404" :class:`.Attribute` on the request's :class:`.Node`; otherwise it will look for an "Http500" :class:`.Attribute`. If an appropriate :class:`.Attribute` is found, and the value of the attribute is a :class:`.View` instance, then the :class:`.View` will be rendered with the exception in the ``extra_context``, bypassing any later handling of exceptions.
	
	"""
	def process_view(self, request, view_func, view_args, view_kwargs):
		try:
			path = view_kwargs['path']
		except KeyError:
			request.node = None
		else:
			request.node = SimpleLazyObject(lambda: get_node(path))
	
	def process_exception(self, request, exception):
		if settings.DEBUG or not hasattr(request, 'node') or not request.node:
			return
		
		if isinstance(exception, Http404):
			error_view = request.node.attributes.get('Http404', None)
			status_code = 404
		else:
			error_view = request.node.attributes.get('Http500', None)
			status_code = 500
		
		if error_view is None or not isinstance(error_view, View):
			# Should this be duck-typing? Perhaps even no testing?
			return
		
		extra_context = {'exception': exception}
		response = error_view.render_to_response(request, extra_context)
		response.status_code = status_code
		return response
########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'Tag'
        db.create_table('philo_tag', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=255, db_index=True)),
        ))
        db.send_create_signal('philo', ['Tag'])

        # Adding model 'Attribute'
        db.create_table('philo_attribute', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('entity_content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('entity_object_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('json_value', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('philo', ['Attribute'])

        # Adding unique constraint on 'Attribute', fields ['key', 'entity_content_type', 'entity_object_id']
        db.create_unique('philo_attribute', ['key', 'entity_content_type_id', 'entity_object_id'])

        # Adding model 'Relationship'
        db.create_table('philo_relationship', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('entity_content_type', self.gf('django.db.models.fields.related.ForeignKey')(related_name='relationship_entity_set', to=orm['contenttypes.ContentType'])),
            ('entity_object_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('value_content_type', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='relationship_value_set', null=True, to=orm['contenttypes.ContentType'])),
            ('value_object_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
        ))
        db.send_create_signal('philo', ['Relationship'])

        # Adding unique constraint on 'Relationship', fields ['key', 'entity_content_type', 'entity_object_id']
        db.create_unique('philo_relationship', ['key', 'entity_content_type_id', 'entity_object_id'])

        # Adding model 'Collection'
        db.create_table('philo_collection', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('description', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
        ))
        db.send_create_signal('philo', ['Collection'])

        # Adding model 'CollectionMember'
        db.create_table('philo_collectionmember', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('collection', self.gf('django.db.models.fields.related.ForeignKey')(related_name='members', to=orm['philo.Collection'])),
            ('index', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('member_content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('member_object_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
        ))
        db.send_create_signal('philo', ['CollectionMember'])

        # Adding model 'Node'
        db.create_table('philo_node', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('parent', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='children', null=True, to=orm['philo.Node'])),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('view_content_type', self.gf('django.db.models.fields.related.ForeignKey')(related_name='node_view_set', to=orm['contenttypes.ContentType'])),
            ('view_object_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
        ))
        db.send_create_signal('philo', ['Node'])

        # Adding model 'Redirect'
        db.create_table('philo_redirect', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('target', self.gf('django.db.models.fields.CharField')(max_length=200)),
            ('status_code', self.gf('django.db.models.fields.IntegerField')(default=302)),
        ))
        db.send_create_signal('philo', ['Redirect'])

        # Adding model 'File'
        db.create_table('philo_file', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('mimetype', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('file', self.gf('django.db.models.fields.files.FileField')(max_length=100)),
        ))
        db.send_create_signal('philo', ['File'])

        # Adding model 'Template'
        db.create_table('philo_template', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('parent', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='children', null=True, to=orm['philo.Template'])),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, db_index=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('documentation', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('mimetype', self.gf('django.db.models.fields.CharField')(default='text/html', max_length=255)),
            ('code', self.gf('philo.models.fields.TemplateField')()),
        ))
        db.send_create_signal('philo', ['Template'])

        # Adding model 'Page'
        db.create_table('philo_page', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('template', self.gf('django.db.models.fields.related.ForeignKey')(related_name='pages', to=orm['philo.Template'])),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('philo', ['Page'])

        # Adding model 'Contentlet'
        db.create_table('philo_contentlet', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='contentlets', to=orm['philo.Page'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('content', self.gf('philo.models.fields.TemplateField')()),
        ))
        db.send_create_signal('philo', ['Contentlet'])

        # Adding model 'ContentReference'
        db.create_table('philo_contentreference', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('page', self.gf('django.db.models.fields.related.ForeignKey')(related_name='contentreferences', to=orm['philo.Page'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['contenttypes.ContentType'])),
            ('content_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
        ))
        db.send_create_signal('philo', ['ContentReference'])


    def backwards(self, orm):
        
        # Deleting model 'Tag'
        db.delete_table('philo_tag')

        # Deleting model 'Attribute'
        db.delete_table('philo_attribute')

        # Removing unique constraint on 'Attribute', fields ['key', 'entity_content_type', 'entity_object_id']
        db.delete_unique('philo_attribute', ['key', 'entity_content_type_id', 'entity_object_id'])

        # Deleting model 'Relationship'
        db.delete_table('philo_relationship')

        # Removing unique constraint on 'Relationship', fields ['key', 'entity_content_type', 'entity_object_id']
        db.delete_unique('philo_relationship', ['key', 'entity_content_type_id', 'entity_object_id'])

        # Deleting model 'Collection'
        db.delete_table('philo_collection')

        # Deleting model 'CollectionMember'
        db.delete_table('philo_collectionmember')

        # Deleting model 'Node'
        db.delete_table('philo_node')

        # Deleting model 'Redirect'
        db.delete_table('philo_redirect')

        # Deleting model 'File'
        db.delete_table('philo_file')

        # Deleting model 'Template'
        db.delete_table('philo_template')

        # Deleting model 'Page'
        db.delete_table('philo_page')

        # Deleting model 'Contentlet'
        db.delete_table('philo_contentlet')

        # Deleting model 'ContentReference'
        db.delete_table('philo_contentreference')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json_value': ('django.db.models.fields.TextField', [], {}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0002_auto__add_field_attribute_value
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Attribute.value'
        db.add_column('philo_attribute', 'value', self.gf('philo.models.fields.JSONField')(default=''), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Attribute.value'
        db.delete_column('philo_attribute', 'value_json')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json_value': ('django.db.models.fields.TextField', [], {}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0003_move_json
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for attribute in orm.Attribute.objects.all():
            attribute.value_json = attribute.json_value
            attribute.save()


    def backwards(self, orm):
        "Write your backwards methods here."
        for attribute in orm.Attribute.objects.all():
            attribute.json_value = attribute.value_json
            attribute.save()


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'json_value': ('django.db.models.fields.TextField', [], {}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0004_auto__del_field_attribute_json_value
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Attribute.json_value'
        db.delete_column('philo_attribute', 'json_value')


    def backwards(self, orm):
        
        # Adding field 'Attribute.json_value'
        db.add_column('philo_attribute', 'json_value', self.gf('django.db.models.fields.TextField')(default=''), keep_default=False)


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0005_add_attribute_values
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ManyToManyValue'
        db.create_table('philo_manytomanyvalue', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='many_to_many_value_set', null=True, to=orm['contenttypes.ContentType'])),
            ('object_ids', self.gf('django.db.models.fields.CommaSeparatedIntegerField')(max_length=300, null=True, blank=True)),
        ))
        db.send_create_signal('philo', ['ManyToManyValue'])

        # Adding model 'JSONValue'
        db.create_table('philo_jsonvalue', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('value', self.gf('philo.models.fields.JSONField')()),
        ))
        db.send_create_signal('philo', ['JSONValue'])

        # Adding model 'ForeignKeyValue'
        db.create_table('philo_foreignkeyvalue', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('content_type', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='foreign_key_value_set', null=True, to=orm['contenttypes.ContentType'])),
            ('object_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
        ))
        db.send_create_signal('philo', ['ForeignKeyValue'])

        # Adding field 'Attribute.value_content_type'
        db.add_column('philo_attribute', 'value_content_type', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='attribute_value_set', null=True, to=orm['contenttypes.ContentType']), keep_default=False)

        # Adding field 'Attribute.value_object_id'
        db.add_column('philo_attribute', 'value_object_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True), keep_default=False)

        # Adding unique constraint on 'Attribute', fields ['value_object_id', 'value_content_type']
        db.create_unique('philo_attribute', ['value_object_id', 'value_content_type_id'])

        # Manual addition! This is necessary to immediately cause contenttype creation.
        # (needed for the next migration)
        db.send_pending_create_signals()


    def backwards(self, orm):
        
        # Deleting model 'ManyToManyValue'
        db.delete_table('philo_manytomanyvalue')

        # Deleting model 'JSONValue'
        db.delete_table('philo_jsonvalue')

        # Deleting model 'ForeignKeyValue'
        db.delete_table('philo_foreignkeyvalue')

        # Deleting field 'Attribute.value_content_type'
        db.delete_column('philo_attribute', 'value_content_type_id')

        # Deleting field 'Attribute.value_object_id'
        db.delete_column('philo_attribute', 'value_object_id')

        # Removing unique constraint on 'Attribute', fields ['value_object_id', 'value_content_type']
        db.delete_unique('philo_attribute', ['value_object_id', 'value_content_type_id'])


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'foreign_key_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'many_to_many_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_ids': ('django.db.models.fields.CommaSeparatedIntegerField', [], {'max_length': '300', 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0006_move_attribute_and_relationship_values
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

	def forwards(self, orm):
		"Write your forwards methods here."
		ContentType = orm['contenttypes.ContentType']
		json_ct = ContentType.objects.get(app_label='philo', model='jsonvalue')
		fk_ct = ContentType.objects.get(app_label='philo', model='foreignkeyvalue')
		
		for attribute in orm.Attribute.objects.all():
			value = orm.JSONValue(value_json=attribute.value_json)
			value.save()
			attribute.value_content_type = json_ct
			attribute.value_object_id = value.id
			attribute.save()
		
		for relationship in orm.Relationship.objects.all():
			attribute = orm.Attribute(entity_content_type=relationship.entity_content_type, entity_object_id=relationship.entity_object_id, key=relationship.key)
			value = orm.ForeignKeyValue(content_type=relationship.value_content_type, object_id=relationship.value_object_id)
			value.save()
			attribute.value_content_type = fk_ct
			attribute.value_object_id = value.id
			attribute.save()
			relationship.delete()


	def backwards(self, orm):
		"Write your backwards methods here."
		if orm.ManyToManyValue.objects.count():
			raise NotImplementedError("ManyToManyValue objects cannot be unmigrated.")
		
		ContentType = orm['contenttypes.ContentType']
		json_ct = ContentType.objects.get(app_label='philo', model='jsonvalue')
		fk_ct = ContentType.objects.get(app_label='philo', model='foreignkeyvalue')
		
		for attribute in orm.Attribute.objects.all():
			if attribute.value_content_type == json_ct:
				value = orm.JSONValue.objects.get(pk=attribute.value_object_id)
				attribute.value_json = value.value_json
				attribute.save()
			elif attribute.value_content_type == fk_ct:
				value = orm.ForeignKeyValue.objects.get(pk=attribute.value_object_id)
				relationship = orm.Relationship(value_content_type=value.content_type, value_object_id=value.object_id, key=attribute.key, entity_content_type=attribute.entity_content_type, entity_object_id=attribute.entity_object_id)
				relationship.save()
				attribute.delete()
			else:
				ct = attribute.value_content_type
				raise NotImplementedError("Class cannot be converted: %s.%s" % (ct.app_label, ct.model))


	models = {
		'contenttypes.contenttype': {
			'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
			'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
		},
		'philo.attribute': {
			'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
			'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
			'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {})
		},
		'philo.collection': {
			'Meta': {'object_name': 'Collection'},
			'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.collectionmember': {
			'Meta': {'object_name': 'CollectionMember'},
			'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
		},
		'philo.contentlet': {
			'Meta': {'object_name': 'Contentlet'},
			'content': ('philo.models.fields.TemplateField', [], {}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
		},
		'philo.contentreference': {
			'Meta': {'object_name': 'ContentReference'},
			'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
		},
		'philo.file': {
			'Meta': {'object_name': 'File'},
			'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.foreignkeyvalue': {
			'Meta': {'object_name': 'ForeignKeyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'foreign_key_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.jsonvalue': {
			'Meta': {'object_name': 'JSONValue'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'value': ('philo.models.fields.JSONField', [], {})
		},
		'philo.manytomanyvalue': {
			'Meta': {'object_name': 'ManyToManyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'many_to_many_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_ids': ('django.db.models.fields.CommaSeparatedIntegerField', [], {'max_length': '300', 'null': 'True', 'blank': 'True'})
		},
		'philo.node': {
			'Meta': {'object_name': 'Node'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
			'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
		},
		'philo.page': {
			'Meta': {'object_name': 'Page'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.redirect': {
			'Meta': {'object_name': 'Redirect'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
			'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
		},
        'philo.relationship': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'),)", 'object_name': 'Relationship'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'relationship_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'relationship_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
		'philo.tag': {
			'Meta': {'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
		},
		'philo.template': {
			'Meta': {'object_name': 'Template'},
			'code': ('philo.models.fields.TemplateField', [], {}),
			'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
		}
	}

	complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0007_auto__del_relationship__del_field_attribute_value
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting model 'Relationship'
        db.delete_table('philo_relationship')

        # Deleting field 'Attribute.value'
        db.delete_column('philo_attribute', 'value_json')


    def backwards(self, orm):
        
        # Adding model 'Relationship'
        db.create_table('philo_relationship', (
            ('key', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('entity_content_type', self.gf('django.db.models.fields.related.ForeignKey')(related_name='relationship_entity_set', to=orm['contenttypes.ContentType'])),
            ('entity_object_id', self.gf('django.db.models.fields.PositiveIntegerField')()),
            ('value_object_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True, blank=True)),
            ('value_content_type', self.gf('django.db.models.fields.related.ForeignKey')(related_name='relationship_value_set', null=True, to=orm['contenttypes.ContentType'], blank=True)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
        ))
        db.send_create_signal('philo', ['Relationship'])

        # Adding field 'Attribute.value'
        db.add_column('philo_attribute', 'value', self.gf('philo.models.fields.JSONField')(default='null'), keep_default=False)


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'foreign_key_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'many_to_many_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_ids': ('django.db.models.fields.CommaSeparatedIntegerField', [], {'max_length': '300', 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0008_auto__del_field_manytomanyvalue_object_ids
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'ManyToManyValue.object_ids'
        db.delete_column('philo_manytomanyvalue', 'object_ids')

        # Adding M2M table for field values on 'ManyToManyValue'
        db.create_table('philo_manytomanyvalue_values', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('manytomanyvalue', models.ForeignKey(orm['philo.manytomanyvalue'], null=False)),
            ('foreignkeyvalue', models.ForeignKey(orm['philo.foreignkeyvalue'], null=False))
        ))
        db.create_unique('philo_manytomanyvalue_values', ['manytomanyvalue_id', 'foreignkeyvalue_id'])


    def backwards(self, orm):
        
        # Adding field 'ManyToManyValue.object_ids'
        db.add_column('philo_manytomanyvalue', 'object_ids', self.gf('django.db.models.fields.CommaSeparatedIntegerField')(max_length=300, null=True, blank=True), keep_default=False)

        # Removing M2M table for field values on 'ManyToManyValue'
        db.delete_table('philo_manytomanyvalue_values')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'foreign_key_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'many_to_many_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0009_auto__add_field_node_lft__add_field_node_rght__add_field_node_tree_id_
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models
from philo.models import Node, Template


class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Node.lft'
        db.add_column('philo_node', 'lft', self.gf('django.db.models.fields.PositiveIntegerField')(default=0, db_index=True), keep_default=False)

        # Adding field 'Node.rght'
        db.add_column('philo_node', 'rght', self.gf('django.db.models.fields.PositiveIntegerField')(default=1, db_index=True), keep_default=False)

        # Adding field 'Node.tree_id'
        db.add_column('philo_node', 'tree_id', self.gf('django.db.models.fields.PositiveIntegerField')(default=0, db_index=True), keep_default=False)

        # Adding field 'Node.level'
        db.add_column('philo_node', 'level', self.gf('django.db.models.fields.PositiveIntegerField')(default=1, db_index=True), keep_default=False)

        # Adding field 'Template.lft'
        db.add_column('philo_template', 'lft', self.gf('django.db.models.fields.PositiveIntegerField')(default=0, db_index=True), keep_default=False)

        # Adding field 'Template.rght'
        db.add_column('philo_template', 'rght', self.gf('django.db.models.fields.PositiveIntegerField')(default=1, db_index=True), keep_default=False)

        # Adding field 'Template.tree_id'
        db.add_column('philo_template', 'tree_id', self.gf('django.db.models.fields.PositiveIntegerField')(default=1, db_index=True), keep_default=False)

        # Adding field 'Template.level'
        db.add_column('philo_template', 'level', self.gf('django.db.models.fields.PositiveIntegerField')(default=1, db_index=True), keep_default=False)

        # Rebuild trees!
        Template._tree_manager.rebuild()
        Node._tree_manager.rebuild()


    def backwards(self, orm):
        
        # Deleting field 'Node.lft'
        db.delete_column('philo_node', 'lft')

        # Deleting field 'Node.rght'
        db.delete_column('philo_node', 'rght')

        # Deleting field 'Node.tree_id'
        db.delete_column('philo_node', 'tree_id')

        # Deleting field 'Node.level'
        db.delete_column('philo_node', 'level')

        # Deleting field 'Template.lft'
        db.delete_column('philo_template', 'lft')

        # Deleting field 'Template.rght'
        db.delete_column('philo_template', 'rght')

        # Deleting field 'Template.tree_id'
        db.delete_column('philo_template', 'tree_id')

        # Deleting field 'Template.level'
        db.delete_column('philo_template', 'level')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0010_auto__add_field_redirect_target_node__add_field_redirect_url_or_subpat
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'Redirect.target_node'
        db.add_column('philo_redirect', 'target_node', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='philo_redirect_related', null=True, to=orm['philo.Node']), keep_default=False)

        # Adding field 'Redirect.url_or_subpath'
        db.add_column('philo_redirect', 'url_or_subpath', self.gf('django.db.models.fields.CharField')(default='', max_length=200, blank=True), keep_default=False)

        # Adding field 'Redirect.reversing_parameters'
        db.add_column('philo_redirect', 'reversing_parameters', self.gf('philo.models.fields.JSONField')(default='null', blank=True), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'Redirect.target_node'
        db.delete_column('philo_redirect', 'target_node_id')

        # Deleting field 'Redirect.url_or_subpath'
        db.delete_column('philo_redirect', 'url_or_subpath')

        # Deleting field 'Redirect.reversing_parameters'
        db.delete_column('philo_redirect', 'reversing_parameters_json')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'"})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0011_move_target_url
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

	def forwards(self, orm):
		"Write your forwards methods here."
		for redirect in orm.Redirect.objects.all():
			redirect.url_or_subpath = redirect.target
			redirect.save()


	def backwards(self, orm):
		"This will cause data loss and is not advisable. Blurg!"
		for redirect in orm.Redirect.objects.all():
			redirect.target = redirect.url_or_subpath
			redirect.save()


	models = {
		'contenttypes.contenttype': {
			'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
			'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
		},
		'philo.attribute': {
			'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
			'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
			'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.collection': {
			'Meta': {'object_name': 'Collection'},
			'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.collectionmember': {
			'Meta': {'object_name': 'CollectionMember'},
			'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
		},
		'philo.contentlet': {
			'Meta': {'object_name': 'Contentlet'},
			'content': ('philo.models.fields.TemplateField', [], {}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
		},
		'philo.contentreference': {
			'Meta': {'object_name': 'ContentReference'},
			'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
		},
		'philo.file': {
			'Meta': {'object_name': 'File'},
			'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.foreignkeyvalue': {
			'Meta': {'object_name': 'ForeignKeyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.jsonvalue': {
			'Meta': {'object_name': 'JSONValue'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'value': ('philo.models.fields.JSONField', [], {'default': "'null'"})
		},
		'philo.manytomanyvalue': {
			'Meta': {'object_name': 'ManyToManyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
		},
		'philo.node': {
			'Meta': {'object_name': 'Node'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
			'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
		},
		'philo.page': {
			'Meta': {'object_name': 'Page'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.redirect': {
			'Meta': {'object_name': 'Redirect'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
			'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
			'target': ('django.db.models.fields.CharField', [], {'max_length': '200'}),
			'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
		},
		'philo.tag': {
			'Meta': {'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
		},
		'philo.template': {
			'Meta': {'object_name': 'Template'},
			'code': ('philo.models.fields.TemplateField', [], {}),
			'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
		}
	}

	complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0012_auto__del_field_redirect_target
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting field 'Redirect.target'
        db.delete_column('philo_redirect', 'target')


    def backwards(self, orm):
        
        # Adding field 'Redirect.target'
        db.add_column('philo_redirect', 'target', self.gf('django.db.models.fields.CharField')(default='', max_length=200), keep_default=False)


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'"})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0013_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'Attribute', fields ['entity_object_id']
        db.create_index('philo_attribute', ['entity_object_id'])

        # Adding index on 'Attribute', fields ['value_object_id']
        db.create_index('philo_attribute', ['value_object_id'])

        # Adding index on 'Attribute', fields ['key']
        db.create_index('philo_attribute', ['key'])


    def backwards(self, orm):
        
        # Removing index on 'Attribute', fields ['entity_object_id']
        db.delete_index('philo_attribute', ['entity_object_id'])

        # Removing index on 'Attribute', fields ['value_object_id']
        db.delete_index('philo_attribute', ['value_object_id'])

        # Removing index on 'Attribute', fields ['key']
        db.delete_index('philo_attribute', ['key'])


    models = {
        'contenttypes.contenttype': {
            'Meta': {'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'"})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0014_auto
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding index on 'Contentlet', fields ['name']
        db.create_index('philo_contentlet', ['name'])

        # Adding index on 'JSONValue', fields ['value']
        db.create_index('philo_jsonvalue', ['value_json'])

        # Adding index on 'ForeignKeyValue', fields ['object_id']
        db.create_index('philo_foreignkeyvalue', ['object_id'])

        # Adding index on 'ContentReference', fields ['name']
        db.create_index('philo_contentreference', ['name'])


    def backwards(self, orm):
        
        # Removing index on 'ContentReference', fields ['name']
        db.delete_index('philo_contentreference', ['name'])

        # Removing index on 'ForeignKeyValue', fields ['object_id']
        db.delete_index('philo_foreignkeyvalue', ['object_id'])

        # Removing index on 'JSONValue', fields ['value']
        db.delete_index('philo_jsonvalue', ['value_json'])

        # Removing index on 'Contentlet', fields ['name']
        db.delete_index('philo_contentlet', ['name'])


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'node_view_set'", 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0015_auto__add_unique_node_slug_parent__add_unique_template_slug_parent
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding unique constraint on 'Node', fields ['slug', 'parent']
        db.create_unique('philo_node', ['slug', 'parent_id'])

        # Adding unique constraint on 'Template', fields ['slug', 'parent']
        db.create_unique('philo_template', ['slug', 'parent_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'Template', fields ['slug', 'parent']
        db.delete_unique('philo_template', ['slug', 'parent_id'])

        # Removing unique constraint on 'Node', fields ['slug', 'parent']
        db.delete_unique('philo_node', ['slug', 'parent_id'])


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0016_auto__add_field_file_name
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding field 'File.name'
        db.add_column('philo_file', 'name', self.gf('django.db.models.fields.CharField')(default='<Generated name>', max_length=255), keep_default=False)


    def backwards(self, orm):
        
        # Deleting field 'File.name'
        db.delete_column('philo_file', 'name')


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0017_generate_filenames
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

	def forwards(self, orm):
		"Write your forwards methods here."
		for f in orm.File.objects.filter(name="<Generated name>"):
			f.name = f.file.name
			f.save()


	def backwards(self, orm):
		"Write your backwards methods here."
		pass


	models = {
		'contenttypes.contenttype': {
			'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
			'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
		},
		'philo.attribute': {
			'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
			'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
			'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.collection': {
			'Meta': {'object_name': 'Collection'},
			'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.collectionmember': {
			'Meta': {'object_name': 'CollectionMember'},
			'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
		},
		'philo.contentlet': {
			'Meta': {'object_name': 'Contentlet'},
			'content': ('philo.models.fields.TemplateField', [], {}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
		},
		'philo.contentreference': {
			'Meta': {'object_name': 'ContentReference'},
			'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
		},
		'philo.file': {
			'Meta': {'object_name': 'File'},
			'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.foreignkeyvalue': {
			'Meta': {'object_name': 'ForeignKeyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.jsonvalue': {
			'Meta': {'object_name': 'JSONValue'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
		},
		'philo.manytomanyvalue': {
			'Meta': {'object_name': 'ManyToManyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
		},
		'philo.node': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.page': {
			'Meta': {'object_name': 'Page'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.redirect': {
			'Meta': {'object_name': 'Redirect'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
			'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
			'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
		},
		'philo.tag': {
			'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
		},
		'philo.template': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
			'code': ('philo.models.fields.TemplateField', [], {}),
			'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
		}
	}

	complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0018_auto__chg_field_node_view_object_id__chg_field_node_view_content_type
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Changing field 'Node.view_object_id'
        db.alter_column('philo_node', 'view_object_id', self.gf('django.db.models.fields.PositiveIntegerField')(null=True))

        # Changing field 'Node.view_content_type'
        db.alter_column('philo_node', 'view_content_type_id', self.gf('django.db.models.fields.related.ForeignKey')(null=True, to=orm['contenttypes.ContentType']))


    def backwards(self, orm):
        
        # User chose to not deal with backwards NULL issues for 'Node.view_object_id'
        raise RuntimeError("Cannot reverse this migration. 'Node.view_object_id' and its values cannot be restored.")

        # User chose to not deal with backwards NULL issues for 'Node.view_content_type'
        raise RuntimeError("Cannot reverse this migration. 'Node.view_content_type' and its values cannot be restored.")


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.tag': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
        },
        'philo.template': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = 0019_to_taggit
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

	def forwards(self, orm):
		"Write your forwards methods here."
		# If any tags are longer than 100, this will result in some data loss.
		PhiloTag = orm['philo.Tag']
		Tag = orm['taggit.Tag']
		
		for tag in PhiloTag.objects.all():
			Tag.objects.get_or_create(name=tag.name, slug=tag.slug)


	def backwards(self, orm):
		"Write your backwards methods here."
		pass


	models = {
		'contenttypes.contenttype': {
			'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
			'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
		},
		'philo.attribute': {
			'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
			'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
			'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.collection': {
			'Meta': {'object_name': 'Collection'},
			'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.collectionmember': {
			'Meta': {'object_name': 'CollectionMember'},
			'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
		},
		'philo.contentlet': {
			'Meta': {'object_name': 'Contentlet'},
			'content': ('philo.models.fields.TemplateField', [], {}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
		},
		'philo.contentreference': {
			'Meta': {'object_name': 'ContentReference'},
			'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
		},
		'philo.file': {
			'Meta': {'object_name': 'File'},
			'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.foreignkeyvalue': {
			'Meta': {'object_name': 'ForeignKeyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.jsonvalue': {
			'Meta': {'object_name': 'JSONValue'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
		},
		'philo.manytomanyvalue': {
			'Meta': {'object_name': 'ManyToManyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
		},
		'philo.node': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.page': {
			'Meta': {'object_name': 'Page'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.redirect': {
			'Meta': {'object_name': 'Redirect'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
			'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
			'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
		},
		'philo.tag': {
			'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
		},
		'philo.template': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
			'code': ('philo.models.fields.TemplateField', [], {}),
			'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
		},
		'taggit.tag': {
			'Meta': {'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
		},
		'taggit.taggeditem': {
			'Meta': {'object_name': 'TaggedItem'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_tagged_items'", 'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
			'tag': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_items'", 'to': "orm['taggit.Tag']"})
		}
	}

	complete_apps = ['taggit', 'philo']

########NEW FILE########
__FILENAME__ = 0020_from_taggit
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

	def forwards(self, orm):
		"Write your forwards methods here."
		pass


	def backwards(self, orm):
		"Write your backwards methods here."
		PhiloTag = orm['philo.Tag']
		Tag = orm['taggit.Tag']
		
		for tag in Tag.objects.all():
			PhiloTag.objects.get_or_create(name=tag.name, slug=tag.slug)


	models = {
		'contenttypes.contenttype': {
			'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
			'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
		},
		'philo.attribute': {
			'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
			'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
			'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.collection': {
			'Meta': {'object_name': 'Collection'},
			'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.collectionmember': {
			'Meta': {'object_name': 'CollectionMember'},
			'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
		},
		'philo.contentlet': {
			'Meta': {'object_name': 'Contentlet'},
			'content': ('philo.models.fields.TemplateField', [], {}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
		},
		'philo.contentreference': {
			'Meta': {'object_name': 'ContentReference'},
			'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
			'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
		},
		'philo.file': {
			'Meta': {'object_name': 'File'},
			'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.foreignkeyvalue': {
			'Meta': {'object_name': 'ForeignKeyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
		},
		'philo.jsonvalue': {
			'Meta': {'object_name': 'JSONValue'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
		},
		'philo.manytomanyvalue': {
			'Meta': {'object_name': 'ManyToManyValue'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
		},
		'philo.node': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
			'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
		},
		'philo.page': {
			'Meta': {'object_name': 'Page'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
			'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
		},
		'philo.redirect': {
			'Meta': {'object_name': 'Redirect'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
			'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
			'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
			'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
		},
		'philo.tag': {
			'Meta': {'ordering': "('name',)", 'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '255', 'db_index': 'True'})
		},
		'philo.template': {
			'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
			'code': ('philo.models.fields.TemplateField', [], {}),
			'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
			'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
			'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
			'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
			'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
		},
		'taggit.tag': {
			'Meta': {'object_name': 'Tag'},
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
			'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '100', 'db_index': 'True'})
		},
		'taggit.taggeditem': {
			'Meta': {'object_name': 'TaggedItem'},
			'content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_tagged_items'", 'to': "orm['contenttypes.ContentType']"}),
			'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
			'object_id': ('django.db.models.fields.IntegerField', [], {'db_index': 'True'}),
			'tag': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'taggit_taggeditem_items'", 'to': "orm['taggit.Tag']"})
		}
	}

	complete_apps = ['taggit', 'philo']

########NEW FILE########
__FILENAME__ = 0021_auto__del_tag
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Deleting model 'Tag'
        db.delete_table('philo_tag')


    def backwards(self, orm):
        
        # Adding model 'Tag'
        db.create_table('philo_tag', (
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=255, unique=True, db_index=True)),
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('philo', ['Tag'])


    models = {
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'philo.attribute': {
            'Meta': {'unique_together': "(('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))", 'object_name': 'Attribute'},
            'entity_content_type': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'attribute_entity_set'", 'to': "orm['contenttypes.ContentType']"}),
            'entity_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'key': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'value_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'attribute_value_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'value_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.collection': {
            'Meta': {'object_name': 'Collection'},
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.collectionmember': {
            'Meta': {'object_name': 'CollectionMember'},
            'collection': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'members'", 'to': "orm['philo.Collection']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'index': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'member_content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'member_object_id': ('django.db.models.fields.PositiveIntegerField', [], {})
        },
        'philo.contentlet': {
            'Meta': {'object_name': 'Contentlet'},
            'content': ('philo.models.fields.TemplateField', [], {}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentlets'", 'to': "orm['philo.Page']"})
        },
        'philo.contentreference': {
            'Meta': {'object_name': 'ContentReference'},
            'content_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'page': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'contentreferences'", 'to': "orm['philo.Page']"})
        },
        'philo.file': {
            'Meta': {'object_name': 'File'},
            'file': ('django.db.models.fields.files.FileField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.foreignkeyvalue': {
            'Meta': {'object_name': 'ForeignKeyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'object_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True', 'null': 'True', 'blank': 'True'})
        },
        'philo.jsonvalue': {
            'Meta': {'object_name': 'JSONValue'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'value': ('philo.models.fields.JSONField', [], {'default': "'null'", 'db_index': 'True'})
        },
        'philo.manytomanyvalue': {
            'Meta': {'object_name': 'ManyToManyValue'},
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'values': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['philo.ForeignKeyValue']", 'null': 'True', 'blank': 'True'})
        },
        'philo.node': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Node'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'view_content_type': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'node_view_set'", 'null': 'True', 'to': "orm['contenttypes.ContentType']"}),
            'view_object_id': ('django.db.models.fields.PositiveIntegerField', [], {'null': 'True', 'blank': 'True'})
        },
        'philo.page': {
            'Meta': {'object_name': 'Page'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'template': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'pages'", 'to': "orm['philo.Template']"}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'philo.redirect': {
            'Meta': {'object_name': 'Redirect'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'reversing_parameters': ('philo.models.fields.JSONField', [], {'blank': 'True'}),
            'status_code': ('django.db.models.fields.IntegerField', [], {'default': '302'}),
            'target_node': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'philo_redirect_related'", 'null': 'True', 'to': "orm['philo.Node']"}),
            'url_or_subpath': ('django.db.models.fields.CharField', [], {'max_length': '200', 'blank': 'True'})
        },
        'philo.template': {
            'Meta': {'unique_together': "(('parent', 'slug'),)", 'object_name': 'Template'},
            'code': ('philo.models.fields.TemplateField', [], {}),
            'documentation': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'level': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'lft': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'default': "'text/html'", 'max_length': '255'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'children'", 'null': 'True', 'to': "orm['philo.Template']"}),
            'rght': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'db_index': 'True'}),
            'tree_id': ('django.db.models.fields.PositiveIntegerField', [], {'db_index': 'True'})
        }
    }

    complete_apps = ['philo']

########NEW FILE########
__FILENAME__ = base
from django import forms
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.core.exceptions import ValidationError
from django.core.validators import RegexValidator
from django.db import models
from django.utils import simplejson as json
from django.utils.encoding import force_unicode
from mptt.models import MPTTModel, MPTTModelBase, MPTTOptions

from philo.exceptions import AncestorDoesNotExist
from philo.models.fields import JSONField
from philo.signals import entity_class_prepared
from philo.utils import ContentTypeRegistryLimiter, ContentTypeSubclassLimiter
from philo.utils.entities import AttributeMapper, TreeAttributeMapper
from philo.validators import json_validator


__all__ = ('value_content_type_limiter', 'register_value_model', 'unregister_value_model', 'JSONValue', 'ForeignKeyValue', 'ManyToManyValue', 'Attribute', 'Entity', 'TreeEntity', 'SlugTreeEntity')


#: An instance of :class:`.ContentTypeRegistryLimiter` which is used to track the content types which can be related to by :class:`ForeignKeyValue`\ s and :class:`ManyToManyValue`\ s.
value_content_type_limiter = ContentTypeRegistryLimiter()


def register_value_model(model):
	"""Registers a model as a valid content type for a :class:`ForeignKeyValue` or :class:`ManyToManyValue` through the :data:`value_content_type_limiter`."""
	value_content_type_limiter.register_class(model)


def unregister_value_model(model):
	"""Registers a model as a valid content type for a :class:`ForeignKeyValue` or :class:`ManyToManyValue` through the :data:`value_content_type_limiter`."""
	value_content_type_limiter.unregister_class(model)


class AttributeValue(models.Model):
	"""
	This is an abstract base class for models that can be used as values for :class:`Attribute`\ s.
	
	AttributeValue subclasses are expected to supply access to a clean version of their value through an attribute called "value".
	
	"""
	
	#: :class:`GenericRelation` to :class:`Attribute`
	attribute_set = generic.GenericRelation('Attribute', content_type_field='value_content_type', object_id_field='value_object_id')
	
	def set_value(self, value):
		"""Given a ``value``, sets the appropriate fields so that it can be correctly stored in the database."""
		raise NotImplementedError
	
	def value_formfields(self, **kwargs):
		"""
		Returns any formfields that would be used to construct an instance of this value.
		
		:returns: A dictionary mapping field names to formfields.
		
		"""
		
		raise NotImplementedError
	
	def construct_instance(self, **kwargs):
		"""Applies cleaned data from the formfields generated by valid_formfields to oneself."""
		raise NotImplementedError
	
	def __unicode__(self):
		return unicode(self.value)
	
	class Meta:
		abstract = True


#: An instance of :class:`.ContentTypeSubclassLimiter` which is used to track the content types which are considered valid value models for an :class:`Attribute`.
attribute_value_limiter = ContentTypeSubclassLimiter(AttributeValue)


class JSONValue(AttributeValue):
	"""Stores a python object as a json string."""
	value = JSONField(verbose_name='Value (JSON)', help_text='This value must be valid JSON.', default='null', db_index=True)
	
	def __unicode__(self):
		return force_unicode(self.value)
	
	def value_formfields(self):
		kwargs = {'initial': self.value_json}
		field = self._meta.get_field('value')
		return {field.name: field.formfield(**kwargs)}
	
	def construct_instance(self, **kwargs):
		field_name = self._meta.get_field('value').name
		self.set_value(kwargs.pop(field_name, None))
	
	def set_value(self, value):
		self.value = value
	
	class Meta:
		app_label = 'philo'


class ForeignKeyValue(AttributeValue):
	"""Stores a generic relationship to an instance of any value content type (as defined by the :data:`value_content_type_limiter`)."""
	content_type = models.ForeignKey(ContentType, limit_choices_to=value_content_type_limiter, verbose_name='Value type', null=True, blank=True)
	object_id = models.PositiveIntegerField(verbose_name='Value ID', null=True, blank=True, db_index=True)
	value = generic.GenericForeignKey()
	
	def value_formfields(self):
		field = self._meta.get_field('content_type')
		fields = {field.name: field.formfield(initial=getattr(self.content_type, 'pk', None))}
		
		if self.content_type:
			kwargs = {
				'initial': self.object_id,
				'required': False,
				'queryset': self.content_type.model_class()._default_manager.all()
			}
			fields['value'] = forms.ModelChoiceField(**kwargs)
		return fields
	
	def construct_instance(self, **kwargs):
		field_name = self._meta.get_field('content_type').name
		ct = kwargs.pop(field_name, None)
		if ct is None or ct != self.content_type:
			self.object_id = None
			self.content_type = ct
		else:
			value = kwargs.pop('value', None)
			self.set_value(value)
			if value is None:
				self.content_type = ct
	
	def set_value(self, value):
		self.value = value
	
	class Meta:
		app_label = 'philo'


class ManyToManyValue(AttributeValue):
	"""Stores a generic relationship to many instances of any value content type (as defined by the :data:`value_content_type_limiter`)."""
	content_type = models.ForeignKey(ContentType, limit_choices_to=value_content_type_limiter, verbose_name='Value type', null=True, blank=True)
	values = models.ManyToManyField(ForeignKeyValue, blank=True, null=True)
	
	def get_object_ids(self):
		return self.values.values_list('object_id', flat=True)
	object_ids = property(get_object_ids)
	
	def set_value(self, value):
		# Value must be a queryset. Watch out for ModelMultipleChoiceField;
		# it returns its value as a list if empty.
		
		self.content_type = ContentType.objects.get_for_model(value.model)
		
		# Before we can fiddle with the many-to-many to foreignkeyvalues, we need
		# a pk.
		if self.pk is None:
			self.save()
		
		object_ids = value.values_list('id', flat=True)
		
		# These lines shouldn't be necessary; however, if object_ids is an EmptyQuerySet,
		# the code (specifically the object_id__in query) won't work without them. Unclear why...
		# TODO: is this still the case?
		if not object_ids:
			self.values.all().delete()
		else:
			self.values.exclude(object_id__in=object_ids, content_type=self.content_type).delete()
			
			current_ids = self.object_ids
			
			for object_id in object_ids:
				if object_id in current_ids:
					continue
				self.values.create(content_type=self.content_type, object_id=object_id)
	
	def get_value(self):
		if self.content_type is None:
			return None
		
		# HACK to be safely explicit until http://code.djangoproject.com/ticket/15145 is resolved
		object_ids = self.object_ids
		manager = self.content_type.model_class()._default_manager
		if not object_ids:
			return manager.none()
		return manager.filter(id__in=self.object_ids)
	
	value = property(get_value, set_value)
	
	def value_formfields(self):
		field = self._meta.get_field('content_type')
		fields = {field.name: field.formfield(initial=getattr(self.content_type, 'pk', None))}
		
		if self.content_type:
			kwargs = {
				'initial': self.object_ids,
				'required': False,
				'queryset': self.content_type.model_class()._default_manager.all()
			}
			fields['value'] = forms.ModelMultipleChoiceField(**kwargs)
		return fields
	
	def construct_instance(self, **kwargs):
		field_name = self._meta.get_field('content_type').name
		ct = kwargs.pop(field_name, None)
		if ct is None or ct != self.content_type:
			self.values.clear()
			self.content_type = ct
		else:
			value = kwargs.get('value', None)
			if not value:
				value = self.content_type.model_class()._default_manager.none()
			self.set_value(value)
	construct_instance.alters_data = True
	
	class Meta:
		app_label = 'philo'


class Attribute(models.Model):
	"""
	:class:`Attribute`\ s exist primarily to let arbitrary data be attached to arbitrary model instances without altering the database schema and without guaranteeing that the data will be available on every instance of that model.
	
	Generally, :class:`Attribute`\ s will not be accessed as models; instead, they will be accessed through the :attr:`Entity.attributes` property, which allows direct dictionary getting and setting of the value of an :class:`Attribute` with its key.
	
	"""
	entity_content_type = models.ForeignKey(ContentType, related_name='attribute_entity_set', verbose_name='Entity type')
	entity_object_id = models.PositiveIntegerField(verbose_name='Entity ID', db_index=True)
	
	#: :class:`GenericForeignKey` to anything (generally an instance of an Entity subclass).
	entity = generic.GenericForeignKey('entity_content_type', 'entity_object_id')
	
	value_content_type = models.ForeignKey(ContentType, related_name='attribute_value_set', limit_choices_to=attribute_value_limiter, verbose_name='Value type', null=True, blank=True)
	value_object_id = models.PositiveIntegerField(verbose_name='Value ID', null=True, blank=True, db_index=True)
	
	#: :class:`GenericForeignKey` to an instance of a subclass of :class:`AttributeValue` as determined by the :data:`attribute_value_limiter`.
	value = generic.GenericForeignKey('value_content_type', 'value_object_id')
	
	#: :class:`CharField` containing a key (up to 255 characters) consisting of alphanumeric characters and underscores.
	key = models.CharField(max_length=255, validators=[RegexValidator("\w+")], help_text="Must contain one or more alphanumeric characters or underscores.", db_index=True)
	
	def __unicode__(self):
		return u'"%s": %s' % (self.key, self.value)
	
	def set_value(self, value, value_class=JSONValue):
		"""Given a value and a value class, sets up self.value appropriately."""
		if isinstance(self.value, value_class):
			val = self.value
		else:
			if isinstance(self.value, models.Model):
				self.value.delete()
			val = value_class()
		
		val.set_value(value)
		val.save()
		
		self.value = val
		self.save()
	
	class Meta:
		app_label = 'philo'
		unique_together = (('key', 'entity_content_type', 'entity_object_id'), ('value_content_type', 'value_object_id'))


class EntityOptions(object):
	def __init__(self, options):
		if options is not None:
			for key, value in options.__dict__.items():
				setattr(self, key, value)
		if not hasattr(self, 'proxy_fields'):
			self.proxy_fields = []
	
	def add_proxy_field(self, proxy_field):
		self.proxy_fields.append(proxy_field)


class EntityBase(models.base.ModelBase):
	def __new__(cls, name, bases, attrs):
		entity_meta = attrs.pop('EntityMeta', None)
		new = super(EntityBase, cls).__new__(cls, name, bases, attrs)
		new.add_to_class('_entity_meta', EntityOptions(entity_meta))
		entity_class_prepared.send(sender=new)
		return new


class Entity(models.Model):
	"""An abstract class that simplifies access to related attributes. Most models provided by Philo subclass Entity."""
	__metaclass__ = EntityBase
	
	attribute_set = generic.GenericRelation(Attribute, content_type_field='entity_content_type', object_id_field='entity_object_id')
	
	def get_attribute_mapper(self, mapper=AttributeMapper):
		"""
		Returns an :class:`.AttributeMapper` which can be used to retrieve related :class:`Attribute`\ s' values directly.

		Example::

			>>> attr = entity.attribute_set.get(key='spam')
			>>> attr.value.value
			u'eggs'
			>>> entity.attributes['spam']
			u'eggs'
		
		"""
		return mapper(self)
	
	@property
	def attributes(self):
		if not hasattr(self, '_attributes'):
			self._attributes = self.get_attribute_mapper()
		return self._attributes
	
	class Meta:
		abstract = True


class TreeEntityBase(MPTTModelBase, EntityBase):
	def __new__(meta, name, bases, attrs):
		attrs['_mptt_meta'] = MPTTOptions(attrs.pop('MPTTMeta', None))
		cls = EntityBase.__new__(meta, name, bases, attrs)
		
		return meta.register(cls)


class TreeEntityManager(models.Manager):
	use_for_related_fields = True
	
	def get_with_path(self, path, root=None, absolute_result=True, pathsep='/', field='pk'):
		"""
		If ``absolute_result`` is ``True``, returns the object at ``path`` (starting at ``root``) or raises an :class:`~django.core.exceptions.ObjectDoesNotExist` exception. Otherwise, returns a tuple containing the deepest object found along ``path`` (or ``root`` if no deeper object is found) and the remainder of the path after that object as a string (or None if there is no remaining path).
		
		.. note:: If you are looking for something with an exact path, it is faster to use absolute_result=True, unless the path depth is over ~40, in which case the high cost of the absolute query may make a binary search (i.e. non-absolute) faster.
		
		.. note:: SQLite allows max of 64 tables in one join. That means the binary search will only work on paths with a max depth of 127 and the absolute fetch will only work to a max depth of (surprise!) 63. Larger depths could be handled, but since the common use case will not have a tree structure that deep, they are not.
		
		:param path: The path of the object
		:param root: The object which will be considered the root of the search
		:param absolute_result: Whether to return an absolute result or do a binary search
		:param pathsep: The path separator used in ``path``
		:param field: The field on the model which should be queried for ``path`` segment matching.
		:returns: An instance if ``absolute_result`` is ``True`` or an (instance, remaining_path) tuple otherwise.
		:raises django.core.exceptions.ObjectDoesNotExist: if no object can be found matching the input parameters.
		
		"""
		
		segments = path.split(pathsep)
		
		# Clean out blank segments. Handles multiple consecutive pathseps.
		while True:
			try:
				segments.remove('')
			except ValueError:
				break
		
		# Special-case a lack of segments. No queries necessary.
		if not segments:
			if root is not None:
				if absolute_result:
					return root
				return root, None
			else:
				raise self.model.DoesNotExist('%s matching query does not exist.' % self.model._meta.object_name)
		
		def make_query_kwargs(segments, root):
			kwargs = {}
			prefix = ""
			revsegs = list(segments)
			revsegs.reverse()
			
			for segment in revsegs:
				kwargs["%s%s__exact" % (prefix, field)] = segment
				prefix += "parent__"
			
			if prefix:
				kwargs[prefix[:-2]] = root
			
			return kwargs
		
		def find_obj(segments, depth, deepest_found=None):
			if deepest_found is None:
				deepest_level = 0
			elif root is None:
				deepest_level = deepest_found.get_level() + 1
			else:
				deepest_level = deepest_found.get_level() - root.get_level()
			try:
				obj = self.get(**make_query_kwargs(segments[deepest_level:depth], deepest_found or root))
			except self.model.DoesNotExist:
				if not deepest_level and depth > 1:
					# make sure there's a root node...
					depth = 1
				else:
					# Try finding one with half the path since the deepest find.
					depth = (deepest_level + depth)/2
				
				if deepest_level == depth:
					# This should happen if nothing is found with any part of the given path.
					if root is not None and deepest_found is None:
						return root, pathsep.join(segments)
					raise
				
				return find_obj(segments, depth, deepest_found)
			else:
				# Yay! Found one!
				if root is None:
					deepest_level = obj.get_level() + 1
				else:
					deepest_level = obj.get_level() - root.get_level()
				
				# Could there be a deeper one?
				if obj.is_leaf_node():
					return obj, pathsep.join(segments[deepest_level:]) or None
				
				depth += (len(segments) - depth)/2 or len(segments) - depth
				
				if depth > deepest_level + obj.get_descendant_count():
					depth = deepest_level + obj.get_descendant_count()
				
				if deepest_level == depth:
					return obj, pathsep.join(segments[deepest_level:]) or None
				
				try:
					return find_obj(segments, depth, obj)
				except self.model.DoesNotExist:
					# Then this was the deepest.
					return obj, pathsep.join(segments[deepest_level:])
		
		if absolute_result:
			return self.get(**make_query_kwargs(segments, root))
		
		# Try a modified binary search algorithm. Feed the root in so that query complexity
		# can be reduced. It might be possible to weight the search towards the beginning
		# of the path, since short paths are more likely, but how far forward? It would
		# need to shift depending on len(segments) - perhaps logarithmically?
		return find_obj(segments, len(segments)/2 or len(segments))


class TreeEntity(Entity, MPTTModel):
	"""An abstract subclass of Entity which represents a tree relationship."""
	
	__metaclass__ = TreeEntityBase
	objects = TreeEntityManager()
	parent = models.ForeignKey('self', related_name='children', null=True, blank=True)
	
	def get_path(self, root=None, pathsep='/', field='pk', memoize=True):
		"""
		:param root: Only return the path since this object.
		:param pathsep: The path separator to use when constructing an instance's path
		:param field: The field to pull path information from for each ancestor.
		:param memoize: Whether to use memoized results. Since, in most cases, the ancestors of a TreeEntity will not change over the course of an instance's lifetime, this defaults to ``True``.
		:returns: A string representation of an object's path.
		
		"""
		
		if root == self:
			return ''
		
		parent_id = getattr(self, "%s_id" % self._mptt_meta.parent_attr)
		if getattr(root, 'pk', None) == parent_id:
			return getattr(self, field, '?')
		
		if root is not None and not self.is_descendant_of(root):
			raise AncestorDoesNotExist(root)
		
		if memoize:
			memo_args = (parent_id, getattr(root, 'pk', None), pathsep, getattr(self, field, '?'))
			try:
				return self._path_memo[memo_args]
			except AttributeError:
				self._path_memo = {}
			except KeyError:
				pass
		
		qs = self.get_ancestors(include_self=True)
		
		if root is not None:
			qs = qs.filter(**{'%s__gt' % self._mptt_meta.level_attr: root.get_level()})
		
		path = pathsep.join([getattr(parent, field, '?') for parent in qs])
		
		if memoize:
			self._path_memo[memo_args] = path
		
		return path
	path = property(get_path)
	
	def get_attribute_mapper(self, mapper=None):
		"""
		Returns a :class:`.TreeAttributeMapper` or :class:`.AttributeMapper` which can be used to retrieve related :class:`Attribute`\ s' values directly. If an :class:`Attribute` with a given key is not related to the :class:`Entity`, then the mapper will check the parent's attributes.

		Example::

			>>> attr = entity.attribute_set.get(key='spam')
			DoesNotExist: Attribute matching query does not exist.
			>>> attr = entity.parent.attribute_set.get(key='spam')
			>>> attr.value.value
			u'eggs'
			>>> entity.attributes['spam']
			u'eggs'
		
		"""
		if mapper is None:
			if getattr(self, "%s_id" % self._mptt_meta.parent_attr):
				mapper = TreeAttributeMapper
			else:
				mapper = AttributeMapper
		return super(TreeEntity, self).get_attribute_mapper(mapper)
	
	def __unicode__(self):
		return self.path
	
	class Meta:
		abstract = True


class SlugTreeEntityManager(TreeEntityManager):
	def get_with_path(self, path, root=None, absolute_result=True, pathsep='/', field='slug'):
		return super(SlugTreeEntityManager, self).get_with_path(path, root, absolute_result, pathsep, field)


class SlugTreeEntity(TreeEntity):
	objects = SlugTreeEntityManager()
	slug = models.SlugField(max_length=255)
	
	def get_path(self, root=None, pathsep='/', field='slug', memoize=True):
		return super(SlugTreeEntity, self).get_path(root, pathsep, field, memoize)
	path = property(get_path)
	
	def clean(self):
		if getattr(self, "%s_id" % self._mptt_meta.parent_attr) is None:
			try:
				self._default_manager.exclude(pk=self.pk).get(slug=self.slug, parent__isnull=True)
			except self.DoesNotExist:
				pass
			else:
				raise ValidationError(self.unique_error_message(self.__class__, ('parent', 'slug')))
	
	class Meta:
		unique_together = ('parent', 'slug')
		abstract = True
########NEW FILE########
__FILENAME__ = collections
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.db import models

from philo.models.base import value_content_type_limiter, register_value_model
from philo.utils import fattr


__all__ = ('Collection', 'CollectionMember')


class Collection(models.Model):
	"""
	Collections are curated ordered groupings of arbitrary models.
	
	"""
	#: :class:`CharField` with max_length 255
	name = models.CharField(max_length=255)
	#: Optional :class:`TextField`
	description = models.TextField(blank=True, null=True)
	
	@fattr(short_description='Members')
	def get_count(self):
		"""Returns the number of items in the collection."""
		return self.members.count()
	
	def __unicode__(self):
		return self.name
	
	class Meta:
		app_label = 'philo'


class CollectionMemberManager(models.Manager):
	use_for_related_fields = True

	def with_model(self, model):
		"""
		Given a model class or instance, returns a queryset of all instances of that model which have collection members in this manager's scope.
		
		Example::
		
			>>> from philo.models import Collection
			>>> from django.contrib.auth.models import User
			>>> collection = Collection.objects.get(name="Foo")
			>>> collection.members.all()
			[<CollectionMember: Foo - user1>, <CollectionMember: Foo - user2>, <CollectionMember: Foo - Spam & Eggs>]
			>>> collection.members.with_model(User)
			[<User: user1>, <User: user2>]
		
		"""
		return model._default_manager.filter(pk__in=self.filter(member_content_type=ContentType.objects.get_for_model(model)).values_list('member_object_id', flat=True))


class CollectionMember(models.Model):
	"""
	The collection member model represents a generic link from a :class:`Collection` to an arbitrary model instance with an attached order.
	
	"""
	#: A :class:`CollectionMemberManager` instance
	objects = CollectionMemberManager()
	#: :class:`ForeignKey` to a :class:`Collection` instance.
	collection = models.ForeignKey(Collection, related_name='members')
	#: The numerical index of the item within the collection (optional).
	index = models.PositiveIntegerField(verbose_name='Index', help_text='This will determine the ordering of the item within the collection. (Optional)', null=True, blank=True)
	member_content_type = models.ForeignKey(ContentType, limit_choices_to=value_content_type_limiter, verbose_name='Member type')
	member_object_id = models.PositiveIntegerField(verbose_name='Member ID')
	#: :class:`GenericForeignKey` to an arbitrary model instance.
	member = generic.GenericForeignKey('member_content_type', 'member_object_id')
	
	def __unicode__(self):
		return u'%s - %s' % (self.collection, self.member)
	
	class Meta:
		app_label = 'philo'


register_value_model(Collection)
########NEW FILE########
__FILENAME__ = entities
import datetime
from itertools import tee

from django import forms
from django.core.exceptions import FieldError, ValidationError
from django.db import models
from django.db.models.fields import NOT_PROVIDED
from django.utils.text import capfirst

from philo.models import ManyToManyValue, JSONValue, ForeignKeyValue, Attribute, Entity
from philo.signals import entity_class_prepared


__all__ = ('JSONAttribute', 'ForeignKeyAttribute', 'ManyToManyAttribute')


ATTRIBUTE_REGISTRY = '_attribute_registry'


class AttributeProxyField(object):
	"""
	:class:`AttributeProxyField`\ s can be assigned as fields on a subclass of :class:`philo.models.base.Entity`. They act like any other model fields, but instead of saving their data to the model's table, they save it to :class:`.Attribute`\ s related to a model instance. Additionally, a new :class:`.Attribute` will be created for an instance if and only if the field's value has been set. This is relevant i.e. for :class:`.PassthroughAttributeMapper`\ s and :class:`.TreeAttributeMapper`\ s, where even an :class:`.Attribute` with a value of ``None`` will prevent a passthrough.
	
	Example::
	
		class Thing(Entity):
			numbers = models.PositiveIntegerField()
			improvised = JSONAttribute(models.BooleanField)
	
	:param attribute_key: The key of the attribute that will be used to store this field's value, if it is different than the field's name.
	
	The remaining parameters have the same meaning as for ordinary model fields.
	
	"""
	def __init__(self, attribute_key=None, verbose_name=None, help_text=None, default=NOT_PROVIDED, editable=True, choices=None, *args, **kwargs):
		self.attribute_key = attribute_key
		self.verbose_name = verbose_name
		self.help_text = help_text
		self.default = default
		self.editable = editable
		self._choices = choices or []
	
	def actually_contribute_to_class(self, sender, **kwargs):
		sender._entity_meta.add_proxy_field(self)
		setattr(sender, self.name, AttributeFieldDescriptor(self))
		opts = sender._entity_meta
		if not hasattr(opts, '_has_attribute_fields'):
			opts._has_attribute_fields = True
			models.signals.post_save.connect(process_attribute_fields, sender=sender)
	
	def contribute_to_class(self, cls, name):
		if self.attribute_key is None:
			self.attribute_key = name
		if issubclass(cls, Entity):
			self.name = self.attname = name
			self.model = cls
			if self.verbose_name is None and name:
				self.verbose_name = name.replace('_', ' ')
			entity_class_prepared.connect(self.actually_contribute_to_class, sender=cls)
		else:
			raise FieldError('%s instances can only be declared on Entity subclasses.' % self.__class__.__name__)
	
	def formfield(self, form_class=forms.CharField, **kwargs):
		"""
		Returns a form field capable of accepting values for the :class:`AttributeProxyField`.
		
		"""
		defaults = {
			'required': False,
			'label': capfirst(self.verbose_name),
			'help_text': self.help_text
		}
		if self.has_default():
			defaults['initial'] = self.default
		defaults.update(kwargs)
		return form_class(**defaults)
	
	def value_from_object(self, obj):
		"""Returns the value of this field in the given model instance."""
		return getattr(obj, self.name)
	
	def get_storage_value(self, value):
		"""Final conversion of ``value`` before it gets stored on an :class:`.Entity` instance. This will be called during :meth:`.EntityForm.save`."""
		return value
	
	def validate_value(self, value):
		"Raise an appropriate exception if ``value`` is not valid for this :class:`AttributeProxyField`."
		pass
	
	def has_default(self):
		"""Returns ``True`` if a default value was provided and ``False`` otherwise."""
		return self.default is not NOT_PROVIDED
	
	def _get_choices(self):
		"""Returns the choices passed into the constructor."""
		if hasattr(self._choices, 'next'):
			choices, self._choices = tee(self._choices)
			return choices
		else:
			return self._choices
	choices = property(_get_choices)
	
	@property
	def value_class(self):
		"""Each :class:`AttributeProxyField` subclass can define a value_class to use for creation of new :class:`.AttributeValue`\ s"""
		raise AttributeError("value_class must be defined on %s subclasses." % self.__class__.__name__)


class AttributeFieldDescriptor(object):
	def __init__(self, field):
		self.field = field
	
	def get_registry(self, instance):
		if ATTRIBUTE_REGISTRY not in instance.__dict__:
			instance.__dict__[ATTRIBUTE_REGISTRY] = {'added': set(), 'removed': set()}
		return instance.__dict__[ATTRIBUTE_REGISTRY]
	
	def __get__(self, instance, owner):
		if instance is None:
			return self
		
		if self.field.name not in instance.__dict__:
			instance.__dict__[self.field.name] = instance.attributes.get(self.field.attribute_key, None)
		
		return instance.__dict__[self.field.name]
	
	def __set__(self, instance, value):
		if instance is None:
			raise AttributeError("%s must be accessed via instance" % self.field.name)
		
		self.field.validate_value(value)
		instance.__dict__[self.field.name] = value
		
		registry = self.get_registry(instance)
		registry['added'].add(self.field)
		registry['removed'].discard(self.field)
	
	def __delete__(self, instance):
		del instance.__dict__[self.field.name]
		
		registry = self.get_registry(instance)
		registry['added'].discard(self.field)
		registry['removed'].add(self.field)


def process_attribute_fields(sender, instance, created, **kwargs):
	"""This function is attached to each :class:`Entity` subclass's post_save signal. Any :class:`Attribute`\ s managed by :class:`AttributeProxyField`\ s which have been removed will be deleted, and any new attributes will be created."""
	if ATTRIBUTE_REGISTRY in instance.__dict__:
		registry = instance.__dict__[ATTRIBUTE_REGISTRY]
		instance.attribute_set.filter(key__in=[field.attribute_key for field in registry['removed']]).delete()
		
		for field in registry['added']:
			# TODO: Should this perhaps just use instance.attributes[field.attribute_key] = getattr(instance, field.name, None)?
			# (Would eliminate the need for field.value_class.)
			try:
				attribute = instance.attribute_set.get(key=field.attribute_key)
			except Attribute.DoesNotExist:
				attribute = Attribute()
				attribute.entity = instance
				attribute.key = field.attribute_key
			attribute.set_value(value=getattr(instance, field.name, None), value_class=field.value_class)
		del instance.__dict__[ATTRIBUTE_REGISTRY]


class JSONAttribute(AttributeProxyField):
	"""
	Handles an :class:`.Attribute` with a :class:`.JSONValue`.
	
	:param field_template: A django form field instance that will be used to guide rendering and interpret values. For example, using :class:`django.forms.BooleanField` will make this field render as a checkbox.
	
	"""
	
	value_class = JSONValue
	
	def __init__(self, field_template=None, **kwargs):
		super(JSONAttribute, self).__init__(**kwargs)
		if field_template is None:
			field_template = models.CharField(max_length=255)
		self.field_template = field_template
	
	def formfield(self, **kwargs):
		defaults = {
			'required': False,
			'label': capfirst(self.verbose_name),
			'help_text': self.help_text
		}
		if self.has_default():
			defaults['initial'] = self.default
		defaults.update(kwargs)
		return self.field_template.formfield(**defaults)
	
	def value_from_object(self, obj):
		"""If the field template is a :class:`DateField` or a :class:`DateTimeField`, this will convert the default return value to a datetime instance."""
		value = super(JSONAttribute, self).value_from_object(obj)
		if isinstance(self.field_template, (models.DateField, models.DateTimeField)):
			try:
				value = self.field_template.to_python(value)
			except ValidationError:
				value = None
		return value
	
	def get_storage_value(self, value):
		"""If ``value`` is a :class:`datetime.datetime` instance, this will convert it to a format which can be stored as correct JSON."""
		if isinstance(value, datetime.datetime):
			return value.strftime("%Y-%m-%d %H:%M:%S")
		if isinstance(value, datetime.date):
			return value.strftime("%Y-%m-%d")
		return value


class ForeignKeyAttribute(AttributeProxyField):
	"""
	Handles an :class:`.Attribute` with a :class:`.ForeignKeyValue`.
	
	:param limit_choices_to: A :class:`Q` object, dictionary, or :class:`ContentTypeLimiter <philo.utils>` to restrict the queryset for the :class:`ForeignKeyAttribute`.
	
	"""
	value_class = ForeignKeyValue
	
	def __init__(self, model, limit_choices_to=None, **kwargs):
		super(ForeignKeyAttribute, self).__init__(**kwargs)
		# Spoof being a rel from a ForeignKey for admin widgets.
		self.to = model
		if limit_choices_to is None:
			limit_choices_to = {}
		self.limit_choices_to = limit_choices_to
	
	def validate_value(self, value):
		if value is not None and not isinstance(value, self.to) :
			raise TypeError("The '%s' attribute can only be set to an instance of %s or None." % (self.name, self.to.__name__))
	
	def formfield(self, form_class=forms.ModelChoiceField, **kwargs):
		defaults = {
			'queryset': self.to._default_manager.complex_filter(self.limit_choices_to)
		}
		defaults.update(kwargs)
		return super(ForeignKeyAttribute, self).formfield(form_class=form_class, **defaults)
	
	def value_from_object(self, obj):
		"""Converts the default value type (a model instance) to a pk."""
		relobj = super(ForeignKeyAttribute, self).value_from_object(obj)
		return getattr(relobj, 'pk', None)
	
	def get_related_field(self):
		# Spoof being a rel from a ForeignKey for admin widgets.
		return self.to._meta.pk


class ManyToManyAttribute(ForeignKeyAttribute):
	"""
	Handles an :class:`.Attribute` with a :class:`.ManyToManyValue`.
	
	:param limit_choices_to: A :class:`Q` object, dictionary, or :class:`ContentTypeLimiter <philo.utils>` to restrict the queryset for the :class:`ManyToManyAttribute`.
	
	"""
	value_class = ManyToManyValue
	
	def validate_value(self, value):
		if not isinstance(value, models.query.QuerySet) or value.model != self.to:
			raise TypeError("The '%s' attribute can only be set to a %s QuerySet." % (self.name, self.to.__name__))
	
	def formfield(self, form_class=forms.ModelMultipleChoiceField, **kwargs):
		return super(ManyToManyAttribute, self).formfield(form_class=form_class, **kwargs)
	
	def value_from_object(self, obj):
		"""Converts the default value type (a queryset) to a list of pks."""
		qs = super(ForeignKeyAttribute, self).value_from_object(obj)
		try:
			return qs.values_list('pk', flat=True)
		except:
			return []
########NEW FILE########
__FILENAME__ = nodes
from inspect import getargspec
import mimetypes
from os.path import basename

from django.conf import settings
from django.contrib.contenttypes import generic
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.models import Site, RequestSite
from django.core.cache import cache
from django.core.exceptions import ValidationError
from django.core.servers.basehttp import FileWrapper
from django.core.urlresolvers import resolve, clear_url_caches, reverse, NoReverseMatch
from django.db import models
from django.http import HttpResponse, HttpResponseServerError, HttpResponseRedirect, Http404
from django.utils.encoding import smart_str

from philo.exceptions import MIDDLEWARE_NOT_CONFIGURED, ViewCanNotProvideSubpath, ViewDoesNotProvideSubpaths
from philo.models.base import SlugTreeEntity, Entity, register_value_model
from philo.models.fields import JSONField
from philo.utils import ContentTypeSubclassLimiter
from philo.utils.entities import LazyPassthroughAttributeMapper
from philo.signals import view_about_to_render, view_finished_rendering


__all__ = ('Node', 'View', 'MultiView', 'Redirect', 'File')


_view_content_type_limiter = ContentTypeSubclassLimiter(None)
CACHE_PHILO_ROOT = getattr(settings, "PHILO_CACHE_PHILO_ROOT", True)


class Node(SlugTreeEntity):
	"""
	:class:`Node`\ s are the basic building blocks of a website using Philo. They define the URL hierarchy and connect each URL to a :class:`View` subclass instance which is used to generate an HttpResponse.
	
	"""
	view_content_type = models.ForeignKey(ContentType, related_name='node_view_set', limit_choices_to=_view_content_type_limiter, blank=True, null=True)
	view_object_id = models.PositiveIntegerField(blank=True, null=True)
	#: :class:`GenericForeignKey` to a non-abstract subclass of :class:`View`
	view = generic.GenericForeignKey('view_content_type', 'view_object_id')
	
	@property
	def accepts_subpath(self):
		"""A property shortcut for :attr:`self.view.accepts_subpath <View.accepts_subpath>`"""
		if self.view_object_id and self.view_content_type_id:
			return ContentType.objects.get_for_id(self.view_content_type_id).model_class().accepts_subpath
		return False
	
	def handles_subpath(self, subpath):
		if self.view_object_id and self.view_content_type_id:
			return ContentType.objects.get_for_id(self.view_content_type_id).model_class().handles_subpath(subpath)
		return False
	
	def render_to_response(self, request, extra_context=None):
		"""This is a shortcut method for :meth:`View.render_to_response`"""
		if self.view_object_id and self.view_content_type_id:
			view_model = ContentType.objects.get_for_id(self.view_content_type_id).model_class()
			self.view = view_model._default_manager.get(pk=self.view_object_id)
			return self.view.render_to_response(request, extra_context)
		raise Http404
	
	def get_absolute_url(self, request=None, with_domain=False, secure=False):
		"""
		This is essentially a shortcut for calling :meth:`construct_url` without a subpath.
		
		:returns: The absolute url of the node on the current site.
		
		"""
		return self.construct_url(request=request, with_domain=with_domain, secure=secure)
	
	def construct_url(self, subpath="/", request=None, with_domain=False, secure=False):
		"""
		This method will do its best to construct a URL based on the Node's location. If with_domain is True, that URL will include a domain and a protocol; if secure is True as well, the protocol will be https. The request will be used to construct a domain in cases where a call to :meth:`Site.objects.get_current` fails.
		
		Node urls will not contain a trailing slash unless a subpath is provided which ends with a trailing slash. Subpaths are expected to begin with a slash, as if returned by :func:`django.core.urlresolvers.reverse`.
		
		Because this method will be called frequently and will always try to reverse ``philo-root``, the results of that reversal will be cached by default. This can be disabled by setting :setting:`PHILO_CACHE_PHILO_ROOT` to ``False``.
		
		:meth:`construct_url` may raise the following exceptions:
		
		- :class:`NoReverseMatch` if "philo-root" is not reversable -- for example, if :mod:`philo.urls` is not included anywhere in your urlpatterns.
		- :class:`Site.DoesNotExist <ObjectDoesNotExist>` if with_domain is True but no :class:`Site` or :class:`RequestSite` can be built.
		- :class:`~philo.exceptions.AncestorDoesNotExist` if the root node of the site isn't an ancestor of the node constructing the URL.
		
		:param string subpath: The subpath to be constructed beyond beyond the node's URL.
		:param request: :class:`HttpRequest` instance. Will be used to construct a :class:`RequestSite` if :meth:`Site.objects.get_current` fails.
		:param with_domain: Whether the constructed URL should include a domain name and protocol.
		:param secure: Whether the protocol, if included, should be http:// or https://.
		:returns: A constructed url for accessing the given subpath of the current node instance.
		
		"""
		# Try reversing philo-root first, since we can't do anything if that fails.
		if CACHE_PHILO_ROOT:
			key = "CACHE_PHILO_ROOT__" + settings.ROOT_URLCONF
			root_url = cache.get(key)
			if root_url is None:
				root_url = reverse('philo-root')
				cache.set(key, root_url)
		else:
			root_url = reverse('philo-root')
		
		try:
			current_site = Site.objects.get_current()
		except Site.DoesNotExist:
			if request is not None:
				current_site = RequestSite(request)
			elif with_domain:
				# If they want a domain and we can't figure one out,
				# best to reraise the error to let them know.
				raise
			else:
				current_site = None
		
		root = getattr(current_site, 'root_node', None)
		path = self.get_path(root=root)
		
		if current_site and with_domain:
			domain = "http%s://%s" % (secure and "s" or "", current_site.domain)
		else:
			domain = ""
		
		if not path or subpath == "/":
			subpath = subpath[1:]
		
		return '%s%s%s%s' % (domain, root_url, path, subpath)
	
	class Meta(SlugTreeEntity.Meta):
		app_label = 'philo'


# the following line enables the selection of a node as the root for a given django.contrib.sites Site object
models.ForeignKey(Node, related_name='sites', null=True, blank=True).contribute_to_class(Site, 'root_node')


class View(Entity):
	"""
	:class:`View` is an abstract model that represents an item which can be "rendered", generally in response to an :class:`HttpRequest`.
	
	"""
	#: A generic relation back to nodes.
	nodes = generic.GenericRelation(Node, content_type_field='view_content_type', object_id_field='view_object_id')
	
	#: An attribute on the class which defines whether this :class:`View` can handle subpaths. Default: ``False``
	accepts_subpath = False
	
	@classmethod
	def handles_subpath(cls, subpath):
		"""Returns True if the :class:`View` handles the given subpath, and False otherwise."""
		if not cls.accepts_subpath and subpath != "/":
			return False
		return True
	
	def reverse(self, view_name=None, args=None, kwargs=None, node=None, obj=None):
		"""
		If :attr:`accepts_subpath` is True, try to reverse a URL using the given parameters using ``self`` as the urlconf.
		
		If ``obj`` is provided, :meth:`get_reverse_params` will be called and the results will be combined with any ``view_name``, ``args``, and ``kwargs`` that may have been passed in.
		
		:param view_name: The name of the view to be reversed.
		:param args: Extra args for reversing the view.
		:param kwargs: A dictionary of arguments for reversing the view.
		:param node: The node whose subpath this is.
		:param obj: An object to be passed to :meth:`get_reverse_params` to generate a view_name, args, and kwargs for reversal.
		:returns: A subpath beyond the node that reverses the view, or an absolute url that reverses the view if a node was passed in.
		:except philo.exceptions.ViewDoesNotProvideSubpaths: if :attr:`accepts_subpath` is False
		:except philo.exceptions.ViewCanNotProvideSubpath: if a reversal is not possible.
		
		"""
		if not self.accepts_subpath:
			raise ViewDoesNotProvideSubpaths
		
		if obj is not None:
			# Perhaps just override instead of combining?
			obj_view_name, obj_args, obj_kwargs = self.get_reverse_params(obj)
			if view_name is None:
				view_name = obj_view_name
			args = list(obj_args) + list(args or [])
			obj_kwargs.update(kwargs or {})
			kwargs = obj_kwargs
		
		try:
			subpath = reverse(view_name, urlconf=self, args=args or [], kwargs=kwargs or {})
		except NoReverseMatch, e:
			raise ViewCanNotProvideSubpath(e.message)
		
		if node is not None:
			return node.construct_url(subpath)
		return subpath
	
	def get_reverse_params(self, obj):
		"""
		This method is not implemented on the base class. It should return a (``view_name``, ``args``, ``kwargs``) tuple suitable for reversing a url for the given ``obj`` using ``self`` as the urlconf. If a reversal will not be possible, this method should raise :class:`~philo.exceptions.ViewCanNotProvideSubpath`.
		
		"""
		raise NotImplementedError("View subclasses must implement get_reverse_params to support subpaths.")
	
	def attributes_with_node(self, node, mapper=LazyPassthroughAttributeMapper):
		"""
		Returns a :class:`LazyPassthroughAttributeMapper` which can be used to directly retrieve the values of :class:`Attribute`\ s related to the :class:`View`, falling back on the :class:`Attribute`\ s of the passed-in :class:`Node` and its ancestors.
		
		"""
		return mapper((self, node))
	
	def render_to_response(self, request, extra_context=None):
		"""
		Renders the :class:`View` as an :class:`HttpResponse`. This will raise :const:`~philo.exceptions.MIDDLEWARE_NOT_CONFIGURED` if the `request` doesn't have an attached :class:`Node`. This can happen if the :class:`~philo.middleware.RequestNodeMiddleware` is not in :setting:`settings.MIDDLEWARE_CLASSES` or if it is not functioning correctly.
		
		:meth:`render_to_response` will send the :data:`~philo.signals.view_about_to_render` signal, then call :meth:`actually_render_to_response`, and finally send the :data:`~philo.signals.view_finished_rendering` signal before returning the ``response``.

		"""
		if not hasattr(request, 'node'):
			raise MIDDLEWARE_NOT_CONFIGURED
		
		extra_context = extra_context or {}
		view_about_to_render.send(sender=self, request=request, extra_context=extra_context)
		response = self.actually_render_to_response(request, extra_context)
		view_finished_rendering.send(sender=self, response=response)
		return response
	
	def actually_render_to_response(self, request, extra_context=None):
		"""Concrete subclasses must override this method to provide the business logic for turning a ``request`` and ``extra_context`` into an :class:`HttpResponse`."""
		raise NotImplementedError('View subclasses must implement actually_render_to_response.')
	
	class Meta:
		abstract = True


_view_content_type_limiter.cls = View


class MultiView(View):
	"""
	:class:`MultiView` is an abstract model which represents a section of related pages - for example, a :class:`~philo.contrib.penfield.BlogView` might have a foreign key to :class:`Page`\ s for an index, an entry detail, an entry archive by day, and so on. :class:`!MultiView` subclasses :class:`View`, and defines the following additional methods and attributes:
	
	"""
	#: Same as :attr:`View.accepts_subpath`. Default: ``True``
	accepts_subpath = True
	
	@property
	def urlpatterns(self):
		"""Returns urlpatterns that point to views (generally methods on the class). :class:`MultiView`\ s can be thought of as "managing" these subpaths."""
		raise NotImplementedError("MultiView subclasses must implement urlpatterns.")
	
	def actually_render_to_response(self, request, extra_context=None):
		"""
		Resolves the remaining subpath left after finding this :class:`View`'s node using :attr:`self.urlpatterns <urlpatterns>` and renders the view function (or method) found with the appropriate args and kwargs.
		
		"""
		clear_url_caches()
		subpath = request.node._subpath
		view, args, kwargs = resolve(subpath, urlconf=self)
		view_args = getargspec(view)
		if extra_context is not None and ('extra_context' in view_args[0] or view_args[2] is not None):
			if 'extra_context' in kwargs:
				extra_context.update(kwargs['extra_context'])
			kwargs['extra_context'] = extra_context
		return view(request, *args, **kwargs)
	
	def get_context(self):
		"""Hook for providing instance-specific context - such as the value of a Field - to any view methods on the instance."""
		return {}
	
	def basic_view(self, field_name):
		"""
		Given the name of a field on the class, accesses the value of
		that field and treats it as a ``View`` instance. Creates a
		basic context based on self.get_context() and any extra_context
		that was passed in, then calls the ``View`` instance's
		render_to_response() method. This method is meant to be called
		to return a view function appropriate for urlpatterns.
		
		:param field_name: The name of a field on the instance which contains a :class:`View` subclass instance.
		:returns: A simple view function.
		
		Example::
			
			class Foo(Multiview):
				page = models.ForeignKey(Page)
				
				@property
				def urlpatterns(self):
					urlpatterns = patterns('',
						url(r'^$', self.basic_view('page'))
					)
					return urlpatterns
		
		"""
		field = self._meta.get_field(field_name)
		view = getattr(self, field.name, None)
		
		def inner(request, extra_context=None, **kwargs):
			if not view:
				raise Http404
			context = self.get_context()
			context.update(extra_context or {})
			return view.render_to_response(request, extra_context=context)
		
		return inner
	
	class Meta:
		abstract = True


class TargetURLModel(models.Model):
	"""An abstract parent class for models which deal in targeting a url."""
	#: An optional :class:`ForeignKey` to a :class:`.Node`. If provided, that node will be used as the basis for the redirect.
	target_node = models.ForeignKey(Node, blank=True, null=True, related_name="%(app_label)s_%(class)s_related")
	#: A :class:`CharField` which may contain an absolute or relative URL, or the name of a node's subpath.
	url_or_subpath = models.CharField(max_length=200, blank=True, help_text="Point to this url or, if a node is defined and accepts subpaths, this subpath of the node.")
	#: A :class:`~philo.models.fields.JSONField` instance. If the value of :attr:`reversing_parameters` is not None, the :attr:`url_or_subpath` will be treated as the name of a view to be reversed. The value of :attr:`reversing_parameters` will be passed into the reversal as args if it is a list or as kwargs if it is a dictionary. Otherwise it will be ignored.
	reversing_parameters = JSONField(blank=True, help_text="If reversing parameters are defined, url_or_subpath will instead be interpreted as the view name to be reversed.")
	
	def clean(self):
		if not self.target_node and not self.url_or_subpath:
			raise ValidationError("Either a target node or a url must be defined.")
		
		if self.reversing_parameters and not (self.url_or_subpath or self.target_node):
			raise ValidationError("Reversing parameters require either a view name or a target node.")
		
		try:
			self.get_target_url()
		except (NoReverseMatch, ViewCanNotProvideSubpath), e:
			raise ValidationError(e.message)
		
		super(TargetURLModel, self).clean()
	
	def get_reverse_params(self):
		params = self.reversing_parameters
		args = kwargs = None
		if isinstance(params, list):
			args = params
		elif isinstance(params, dict):
			# Convert unicode keys to strings for Python < 2.6.5. Compare
			# http://stackoverflow.com/questions/4598604/how-to-pass-unicode-keywords-to-kwargs
			kwargs = dict([(smart_str(k, 'ascii'), v) for k, v in params.items()])
		return self.url_or_subpath, args, kwargs
	
	def get_target_url(self, memoize=True):
		"""Calculates and returns the target url based on the :attr:`target_node`, :attr:`url_or_subpath`, and :attr:`reversing_parameters`. The results will be memoized by default; this can be prevented by passing in ``memoize=False``."""
		if memoize:
			memo_args = (self.target_node_id, self.url_or_subpath, self.reversing_parameters_json)
			try:
				return self._target_url_memo[memo_args]
			except AttributeError:
				self._target_url_memo = {}
			except KeyError:
				pass
		
		node = self.target_node
		if node is not None and node.accepts_subpath and self.url_or_subpath:
			if self.reversing_parameters is not None:
				view_name, args, kwargs = self.get_reverse_params()
				subpath = node.view.reverse(view_name, args=args, kwargs=kwargs)
			else:
				subpath = self.url_or_subpath
				if subpath[0] != '/':
					subpath = '/' + subpath
			target_url = node.construct_url(subpath)
		elif node is not None:
			target_url = node.get_absolute_url()
		else:
			if self.reversing_parameters is not None:
				view_name, args, kwargs = self.get_reverse_params()
				target_url = reverse(view_name, args=args, kwargs=kwargs)
			else:
				target_url = self.url_or_subpath
		
		if memoize:
			self._target_url_memo[memo_args] = target_url
		return target_url
	target_url = property(get_target_url)
	
	class Meta:
		abstract = True


class Redirect(TargetURLModel, View):
	"""Represents a 301 or 302 redirect to a different url on an absolute or relative path."""
	#: A choices tuple of redirect status codes (temporary or permanent).
	STATUS_CODES = (
		(302, 'Temporary'),
		(301, 'Permanent'),
	)
	#: An :class:`IntegerField` which uses :attr:`STATUS_CODES` as its choices. Determines whether the redirect is considered temporary or permanent.
	status_code = models.IntegerField(choices=STATUS_CODES, default=302, verbose_name='redirect type')
	
	def actually_render_to_response(self, request, extra_context=None):
		"""Returns an :class:`HttpResponseRedirect` to :attr:`self.target_url`."""
		response = HttpResponseRedirect(self.target_url)
		response.status_code = self.status_code
		return response
	
	class Meta:
		app_label = 'philo'


class File(View):
	"""Stores an arbitrary file."""
	#: The name of the uploaded file. This is meant for finding the file again later, not for display.
	name = models.CharField(max_length=255)
	#: Defines the mimetype of the uploaded file. This will not be validated. If no mimetype is provided, it will be automatically generated based on the filename.
	mimetype = models.CharField(max_length=255, blank=True)
	#: Contains the uploaded file. Files are uploaded to ``philo/files/%Y/%m/%d``.
	file = models.FileField(upload_to='philo/files/%Y/%m/%d')
	
	def clean(self):
		if not self.mimetype:
			self.mimetype = mimetypes.guess_type(self.file.name, strict=False)[0]
			if self.mimetype is None:
				raise ValidationError("Unknown file type.")
	
	def actually_render_to_response(self, request, extra_context=None):
		wrapper = FileWrapper(self.file)
		response = HttpResponse(wrapper, content_type=self.mimetype)
		response['Content-Length'] = self.file.size
		response['Content-Disposition'] = "inline; filename=%s" % basename(self.file.name)
		return response
	
	class Meta:
		app_label = 'philo'
	
	def __unicode__(self):
		"""Returns the value of :attr:`File.name`."""
		return self.name


register_value_model(Node)
########NEW FILE########
__FILENAME__ = pages
# encoding: utf-8
"""
:class:`Page`\ s are the most frequently used :class:`.View` subclass. They define a basic HTML page and its associated content. Each :class:`Page` renders itself according to a :class:`Template`. The :class:`Template` may contain :ttag:`container` tags, which define related :class:`Contentlet`\ s and :class:`ContentReference`\ s for any page using that :class:`Template`.

"""

from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.core.exceptions import ValidationError
from django.db import models
from django.http import HttpResponse
from django.template import Context, RequestContext, Template as DjangoTemplate

from philo.models.base import SlugTreeEntity, register_value_model
from philo.models.fields import TemplateField
from philo.models.nodes import View
from philo.signals import page_about_to_render_to_string, page_finished_rendering_to_string
from philo.utils import templates


__all__ = ('Template', 'Page', 'Contentlet', 'ContentReference')


class Template(SlugTreeEntity):
	"""Represents a database-driven django template."""
	#: The name of the template. Used for organization and debugging.
	name = models.CharField(max_length=255)
	#: Can be used to let users know what the template is meant to be used for.
	documentation = models.TextField(null=True, blank=True)
	#: Defines the mimetype of the template. This is not validated. Default: ``text/html``.
	mimetype = models.CharField(max_length=255, default=getattr(settings, 'DEFAULT_CONTENT_TYPE', 'text/html'))
	#: An insecure :class:`~philo.models.fields.TemplateField` containing the django template code for this template.
	code = TemplateField(secure=False, verbose_name='django template code')
	
	def get_containers(self):
		"""
		Returns a tuple where the first item is a list of names of contentlets referenced by containers, and the second item is a list of tuples of names and contenttypes of contentreferences referenced by containers. This will break if there is a recursive extends or includes in the template code. Due to the use of an empty Context, any extends or include tags with dynamic arguments probably won't work.
		
		"""
		template = DjangoTemplate(self.code)
		return templates.get_containers(template)
	containers = property(get_containers)
	
	def __unicode__(self):
		"""Returns the value of the :attr:`name` field."""
		return self.name
	
	class Meta(SlugTreeEntity.Meta):
		app_label = 'philo'


class Page(View):
	"""
	Represents a page - something which is rendered according to a :class:`Template`. The page will have a number of related :class:`Contentlet`\ s and :class:`ContentReference`\ s depending on the template selected - but these will appear only after the page has been saved with that template.
	
	"""
	#: A :class:`ForeignKey` to the :class:`Template` used to render this :class:`Page`.
	template = models.ForeignKey(Template, related_name='pages')
	#: The name of this page. Chances are this will be used for organization - i.e. finding the page in a list of pages - rather than for display.
	title = models.CharField(max_length=255)
	
	def get_containers(self):
		"""
		Returns the results :attr:`~Template.containers` for the related template. This is a tuple containing the specs of all :ttag:`container`\ s in the :class:`Template`'s code. The value will be cached on the instance so that multiple accesses will be less expensive.
		
		"""
		if not hasattr(self, '_containers'):
			self._containers = self.template.containers
		return self._containers
	containers = property(get_containers)
	
	def render_to_string(self, request=None, extra_context=None):
		"""
		In addition to rendering as an :class:`HttpResponse`, a :class:`Page` can also render as a string. This means, for example, that :class:`Page`\ s can be used to render emails or other non-HTML content with the same :ttag:`container`-based functionality as is used for HTML.
		
		The :class:`Page` will add itself to the context as ``page`` and its :attr:`~.Entity.attributes` as ``attributes``. If a request is provided, then :class:`request.node <.Node>` will also be added to the context as ``node`` and ``attributes`` will be set to the result of calling :meth:`~.View.attributes_with_node` with that :class:`.Node`.
		
		"""
		context = {}
		context.update(extra_context or {})
		context.update({'page': self, 'attributes': self.attributes})
		template = DjangoTemplate(self.template.code)
		if request:
			context.update({'node': request.node, 'attributes': self.attributes_with_node(request.node)})
			page_about_to_render_to_string.send(sender=self, request=request, extra_context=context)
			string = template.render(RequestContext(request, context))
		else:
			page_about_to_render_to_string.send(sender=self, request=request, extra_context=context)
		 	string = template.render(Context(context))
		page_finished_rendering_to_string.send(sender=self, string=string)
		return string
	
	def actually_render_to_response(self, request, extra_context=None):
		"""Returns an :class:`HttpResponse` with the content of the :meth:`render_to_string` method and the mimetype set to the :attr:`~Template.mimetype` of the related :class:`Template`."""
		return HttpResponse(self.render_to_string(request, extra_context), mimetype=self.template.mimetype)
	
	def __unicode__(self):
		"""Returns the value of :attr:`title`"""
		return self.title
	
	def clean_fields(self, exclude=None):
		"""
		This is an override of the default model clean_fields method. Essentially, in addition to validating the fields, this method validates the :class:`Template` instance that is used to render this :class:`Page`. This is useful for catching template errors before they show up as 500 errors on a live site.
		
		"""
		if exclude is None:
			exclude = []
		
		try:
			super(Page, self).clean_fields(exclude)
		except ValidationError, e:
			errors = e.message_dict
		else:
			errors = {}
		
		if 'template' not in errors and 'template' not in exclude:
			try:
				self.template.clean_fields()
				self.template.clean()
			except ValidationError, e:
				errors['template'] = e.messages
		
		if errors:
			raise ValidationError(errors)
	
	class Meta:
		app_label = 'philo'


class Contentlet(models.Model):
	"""Represents a piece of content on a page. This content is treated as a secure :class:`~philo.models.fields.TemplateField`."""
	#: The page which this :class:`Contentlet` is related to.
	page = models.ForeignKey(Page, related_name='contentlets')
	#: This represents the name of the container as defined by a :ttag:`container` tag.
	name = models.CharField(max_length=255, db_index=True)
	#: A secure :class:`~philo.models.fields.TemplateField` holding the content for this :class:`Contentlet`. Note that actually using this field as a template requires use of the :ttag:`include_string` template tag.
	content = TemplateField()
	
	def __unicode__(self):
		"""Returns the value of the :attr:`name` field."""
		return self.name
	
	class Meta:
		app_label = 'philo'


class ContentReference(models.Model):
	"""Represents a model instance related to a page."""
	#: The page which this :class:`ContentReference` is related to.
	page = models.ForeignKey(Page, related_name='contentreferences')
	#: This represents the name of the container as defined by a :ttag:`container` tag.
	name = models.CharField(max_length=255, db_index=True)
	content_type = models.ForeignKey(ContentType, verbose_name='Content type')
	content_id = models.PositiveIntegerField(verbose_name='Content ID', blank=True, null=True)
	#: A :class:`GenericForeignKey` to a model instance. The content type of this instance is defined by the :ttag:`container` tag which defines this :class:`ContentReference`.
	content = generic.GenericForeignKey('content_type', 'content_id')
	
	def __unicode__(self):
		"""Returns the value of the :attr:`name` field."""
		return self.name
	
	class Meta:
		app_label = 'philo'


register_value_model(Template)
register_value_model(Page)
########NEW FILE########
__FILENAME__ = signals
from django.dispatch import Signal


#: Sent whenever an Entity subclass has been "prepared" -- that is, after the processing necessary to make :mod:`.AttributeProxyField`\ s work has been completed. This will fire after :obj:`django.db.models.signals.class_prepared`.
#:
#: Arguments that are sent with this signal:
#: 
#: ``sender``
#: 	The model class.
entity_class_prepared = Signal(providing_args=['class'])

#: Sent when a :class:`~philo.models.nodes.View` instance is about to render. This allows you, for example, to modify the ``extra_context`` dictionary used in rendering.
#:
#: Arguments that are sent with this signal:
#:
#: ``sender``
#: 	The :class:`~philo.models.nodes.View` instance
#:
#: ``request``
#: 	The :class:`HttpRequest` instance which the :class:`~philo.models.nodes.View` is rendering in response to.
#:
#: ``extra_context``
#: 	A dictionary which will be passed into :meth:`~philo.models.nodes.View.actually_render_to_response`.
view_about_to_render = Signal(providing_args=['request', 'extra_context'])

#: Sent when a view instance has finished rendering.
#:
#: Arguments that are sent with this signal:
#:
#: ``sender``
#: 	The :class:`~philo.models.nodes.View` instance
#:
#: ``response``
#: 	The :class:`HttpResponse` instance which :class:`~philo.models.nodes.View` view has rendered to.
view_finished_rendering = Signal(providing_args=['response'])

#: Sent when a :class:`~philo.models.pages.Page` instance is about to render as a string. If the :class:`~philo.models.pages.Page` is rendering as a response, this signal is sent after :obj:`view_about_to_render` and serves a similar function. However, there are situations where a :class:`~philo.models.pages.Page` may be rendered as a string without being rendered as a response afterwards.
#:
#: Arguments that are sent with this signal:
#:
#: ``sender``
#: 	The :class:`~philo.models.pages.Page` instance
#:
#: ``request``
#: 	The :class:`HttpRequest` instance which the :class:`~philo.models.pages.Page` is rendering in response to (if any).
#:
#: ``extra_context``
#: 	A dictionary which will be passed into the :class:`Template` context.
page_about_to_render_to_string = Signal(providing_args=['request', 'extra_context'])

#: Sent when a :class:`~philo.models.pages.Page` instance has just finished rendering as a string. If the :class:`~philo.models.pages.Page` is rendering as a response, this signal is sent before :obj:`view_finished_rendering` and serves a similar function. However, there are situations where a :class:`~philo.models.pages.Page` may be rendered as a string without being rendered as a response afterwards.
#:
#: Arguments that are sent with this signal:
#:
#: ``sender``
#: 	The :class:`~philo.models.pages.Page` instance
#:
#: ``string``
#: 	The string which the :class:`~philo.models.pages.Page` has rendered to.
page_finished_rendering_to_string = Signal(providing_args=['string'])
########NEW FILE########
__FILENAME__ = collections
"""
The collection template tags are automatically included as builtins if :mod:`philo` is an installed app.

"""

from django import template
from django.conf import settings
from django.contrib.contenttypes.models import ContentType


register = template.Library()


class MembersofNode(template.Node):
	def __init__(self, collection, model, as_var):
		self.collection = template.Variable(collection)
		self.model = model
		self.as_var = as_var
		
	def render(self, context):
		try:
			collection = self.collection.resolve(context)
			context[self.as_var] = collection.members.with_model(self.model)
		except:
			pass
		return ''


@register.tag
def membersof(parser, token):
	"""
	Given a collection and a content type, sets the results of :meth:`collection.members.with_model <.CollectionMemberManager.with_model>` as a variable in the context.
	
	Usage::
	
		{% membersof <collection> with <app_label>.<model_name> as <var> %}
	
	"""
	params=token.split_contents()
	tag = params[0]
	
	if len(params) < 6:
		raise template.TemplateSyntaxError('"%s" template tag requires six parameters' % tag)
		
	if params[2] != 'with':
		raise template.TemplateSyntaxError('"%s" template tag requires the third parameter to be "with"' % tag)
	
	try:
		app_label, model = params[3].strip('"').split('.')
		ct = ContentType.objects.get_by_natural_key(app_label, model)
	except ValueError:
		raise template.TemplateSyntaxError('"%s" template tag option "with" requires an argument of the form app_label.model (see django.contrib.contenttypes)' % tag)
	except ContentType.DoesNotExist:
		raise template.TemplateSyntaxError('"%s" template tag option "with" requires an argument of the form app_label.model which refers to an installed content type (see django.contrib.contenttypes)' % tag)
		
	if params[4] != 'as':
		raise template.TemplateSyntaxError('"%s" template tag requires the fifth parameter to be "as"' % tag)
	
	return MembersofNode(collection=params[1], model=ct.model_class(), as_var=params[5])
########NEW FILE########
__FILENAME__ = containers
"""
The container template tags are automatically included as builtins if :mod:`philo` is an installed app.

"""

from django import template
from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.core.exceptions import ObjectDoesNotExist
from django.db.models import Q
from django.utils.safestring import SafeUnicode, mark_safe


register = template.Library()


CONTAINER_CONTEXT_KEY = 'philo_container_context'


class ContainerContext(object):
	def __init__(self, page):
		self.page = page
	
	def get_contentlets(self):
		if not hasattr(self, '_contentlets'):
			self._contentlets = dict(((c.name, c) for c in self.page.contentlets.all()))
		return self._contentlets
	
	def get_references(self):
		if not hasattr(self, '_references'):
			references = self.page.contentreferences.all()
			self._references = dict((((c.name, ContentType.objects.get_for_id(c.content_type_id)), c) for c in references))
		return self._references


class ContainerNode(template.Node):
	def __init__(self, name, references=None, as_var=None):
		self.name = name
		self.as_var = as_var
		self.references = references
	
	def render(self, context):
		container_content = self.get_container_content(context)
		
		if self.as_var:
			context[self.as_var] = container_content
			return ''
		
		return container_content
	
	def get_container_content(self, context):
		try:
			container_context = context.render_context[CONTAINER_CONTEXT_KEY]
		except KeyError:
			try:
				page = context['page']
			except KeyError:
				return settings.TEMPLATE_STRING_IF_INVALID
			
			container_context = ContainerContext(page)
			context.render_context[CONTAINER_CONTEXT_KEY] = container_context
		
		if self.references:
			# Then it's a content reference.
			try:
				contentreference = container_context.get_references()[(self.name, self.references)]
			except KeyError:
				content = ''
			else:
				content = contentreference.content
		else:
			# Otherwise it's a contentlet.
			try:
				contentlet = container_context.get_contentlets()[self.name]
			except KeyError:
				content = ''
			else:
				content = contentlet.content
		return content


@register.tag
def container(parser, token):
	"""
	If a template using this tag is used to render a :class:`.Page`, that :class:`.Page` will have associated content which can be set in the admin interface. If a content type is referenced, then a :class:`.ContentReference` object will be created; otherwise, a :class:`.Contentlet` object will be created.
	
	Usage::
	
		{% container <name> [[references <app_label>.<model_name>] as <variable>] %}
	
	"""
	params = token.split_contents()
	if len(params) >= 2:
		tag = params[0]
		name = params[1].strip('"')
		references = None
		as_var = None
		if len(params) > 2:
			remaining_tokens = params[2:]
			while remaining_tokens:
				option_token = remaining_tokens.pop(0)
				if option_token == 'references':
					try:
						app_label, model = remaining_tokens.pop(0).strip('"').split('.')
						references = ContentType.objects.get_by_natural_key(app_label, model)
					except IndexError:
						raise template.TemplateSyntaxError('"%s" template tag option "references" requires an argument specifying a content type' % tag)
					except ValueError:
						raise template.TemplateSyntaxError('"%s" template tag option "references" requires an argument of the form app_label.model (see django.contrib.contenttypes)' % tag)
					except ObjectDoesNotExist:
						raise template.TemplateSyntaxError('"%s" template tag option "references" requires an argument of the form app_label.model which refers to an installed content type (see django.contrib.contenttypes)' % tag)
				elif option_token == 'as':
					try:
						as_var = remaining_tokens.pop(0)
					except IndexError:
						raise template.TemplateSyntaxError('"%s" template tag option "as" requires an argument specifying a variable name' % tag)
			if references and not as_var:
				raise template.TemplateSyntaxError('"%s" template tags using "references" option require additional use of the "as" option specifying a variable name' % tag)
		return ContainerNode(name, references, as_var)
		
	else: # error
		raise template.TemplateSyntaxError('"%s" template tag provided without arguments (at least one required)' % tag)

########NEW FILE########
__FILENAME__ = embed
"""
The embed template tags are automatically included as builtins if :mod:`philo` is an installed app.

"""
from django import template
from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.template.loader_tags import ExtendsNode, BlockContext, BLOCK_CONTEXT_KEY, TextNode, BlockNode

from philo.utils.templates import LOADED_TEMPLATE_ATTR


register = template.Library()
EMBED_CONTEXT_KEY = 'embed_context'


class EmbedContext(object):
	"Inspired by django.template.loader_tags.BlockContext."
	def __init__(self):
		self.embeds = {}
		self.rendered = []
	
	def add_embeds(self, embeds):
		for content_type, embed_list in embeds.iteritems():
			if content_type in self.embeds:
				self.embeds[content_type] = embed_list + self.embeds[content_type]
			else:
				self.embeds[content_type] = embed_list
	
	def get_embed_template(self, embed, context):
		"""To return a template for an embed node, find the node's position in the stack
		and then progress up the stack until a template-defining node is found
		"""
		ct = embed.get_content_type(context)
		embeds = self.embeds[ct]
		embeds = embeds[:embeds.index(embed)][::-1]
		for e in embeds:
			template = e.get_template(context)
			if template:
				return template
		
		# No template was found in the current render_context - but perhaps one level up? Or more?
		# We may be in an inclusion tag.
		self_found = False
		for context_dict in context.render_context.dicts[::-1]:
			if not self_found:
				if self in context_dict.values():
					self_found = True
					continue
			elif EMBED_CONTEXT_KEY not in context_dict:
				continue
			else:
				embed_context = context_dict[EMBED_CONTEXT_KEY]
				# We can tell where we are in the list of embeds by which have already been rendered.
				embeds = embed_context.embeds[ct][:len(embed_context.rendered)][::-1]
				for e in embeds:
					template = e.get_template(context)
					if template:
						return template
		
		raise IndexError


# Override ExtendsNode render method to have it handle EmbedNodes
# similarly to BlockNodes.
old_extends_node_init = ExtendsNode.__init__


def get_embed_dict(embed_list, context):
	embeds = {}
	for e in embed_list:
		ct = e.get_content_type(context)
		if ct is None:
			# Then the embed doesn't exist for this context.
			continue
		if ct not in embeds:
			embeds[ct] = [e]
		else:
			embeds[ct].append(e)
	return embeds


def extends_node_init(self, nodelist, *args, **kwargs):
	self.embed_list = nodelist.get_nodes_by_type(ConstantEmbedNode)
	old_extends_node_init(self, nodelist, *args, **kwargs)


def render_extends_node(self, context):
	compiled_parent = self.get_parent(context)
	embeds = get_embed_dict(self.embed_list, context)
	
	if BLOCK_CONTEXT_KEY not in context.render_context:
		context.render_context[BLOCK_CONTEXT_KEY] = BlockContext()
	block_context = context.render_context[BLOCK_CONTEXT_KEY]
	
	if EMBED_CONTEXT_KEY not in context.render_context:
		context.render_context[EMBED_CONTEXT_KEY] = EmbedContext()
	embed_context = context.render_context[EMBED_CONTEXT_KEY]
	
	# Add the block nodes from this node to the block context
	# Do the equivalent for embed nodes
	block_context.add_blocks(self.blocks)
	embed_context.add_embeds(embeds)
	
	# If this block's parent doesn't have an extends node it is the root,
	# and its block nodes also need to be added to the block context.
	for node in compiled_parent.nodelist:
		# The ExtendsNode has to be the first non-text node.
		if not isinstance(node, TextNode):
			if not isinstance(node, ExtendsNode):
				blocks = dict([(n.name, n) for n in compiled_parent.nodelist.get_nodes_by_type(BlockNode)])
				block_context.add_blocks(blocks)
				embeds = get_embed_dict(compiled_parent.nodelist.get_nodes_by_type(ConstantEmbedNode), context)
				embed_context.add_embeds(embeds)
			break
	
	# Explicitly render all direct embed children of this node.
	if self.embed_list:
		for node in self.nodelist:
			if isinstance(node, ConstantEmbedNode):
				node.render(context)
	
	# Call Template._render explicitly so the parser context stays
	# the same.
	return compiled_parent._render(context)


ExtendsNode.__init__ = extends_node_init
ExtendsNode.render = render_extends_node


class ConstantEmbedNode(template.Node):
	"""Analogous to the ConstantIncludeNode, this node precompiles several variables necessary for correct rendering - namely the referenced instance or the included template."""
	def __init__(self, content_type, object_pk=None, template_name=None, kwargs=None):
		assert template_name is not None or object_pk is not None
		self.content_type = content_type
		
		kwargs = kwargs or {}
		for k, v in kwargs.items():
			kwargs[k] = v
		self.kwargs = kwargs
		
		if object_pk is not None:
			self.instance = self.compile_instance(object_pk)
		else:
			self.instance = None
		
		if template_name is not None:
			self.template = self.compile_template(template_name[1:-1])
		else:
			self.template = None
	
	def compile_instance(self, object_pk):
		model = self.content_type.model_class()
		try:
			return model.objects.get(pk=object_pk)
		except model.DoesNotExist:
			if not hasattr(self, 'object_pk') and settings.TEMPLATE_DEBUG:
				# Then it's a constant node.
				raise
			return False
	
	def get_instance(self, context):
		return self.instance
	
	def compile_template(self, template_name):
		try:
			return template.loader.get_template(template_name)
		except template.TemplateDoesNotExist:
			if hasattr(self, 'template') and settings.TEMPLATE_DEBUG:
				# Then it's a constant node.
				raise
			return False
	
	def get_template(self, context):
		return self.template
	
	def get_content_type(self, context):
		return self.content_type
	
	def check_context(self, context):
		if EMBED_CONTEXT_KEY not in context.render_context:
			context.render_context[EMBED_CONTEXT_KEY] = EmbedContext()
		embed_context = context.render_context[EMBED_CONTEXT_KEY]
		
		ct = self.get_content_type(context)
		if ct not in embed_context.embeds:
			embed_context.embeds[ct] = [self]
		elif self not in embed_context.embeds[ct]:
			embed_context.embeds[ct].append(self)
	
	def mark_rendered_for(self, context):
		context.render_context[EMBED_CONTEXT_KEY].rendered.append(self)
	
	def render(self, context):
		self.check_context(context)
		
		template = self.get_template(context)
		if template is not None:
			self.mark_rendered_for(context)
			if template is False:
				return settings.TEMPLATE_STRING_IF_INVALID
			return ''
		
		# Otherwise an instance should be available. Render the instance with the appropriate template!
		instance = self.get_instance(context)
		if instance is None or instance is False:
			self.mark_rendered_for(context)
			return settings.TEMPLATE_STRING_IF_INVALID
		
		return self.render_instance(context, instance)
	
	def render_instance(self, context, instance):
		try:
			t = context.render_context[EMBED_CONTEXT_KEY].get_embed_template(self, context)
		except (KeyError, IndexError):
			self.mark_rendered_for(context)
			return settings.TEMPLATE_STRING_IF_INVALID
		
		context.push()
		context['embedded'] = instance
		for k, v in self.kwargs.items():
			context[k] = v.resolve(context)
		t_rendered = t.render(context)
		context.pop()
		self.mark_rendered_for(context)
		return t_rendered


class EmbedNode(ConstantEmbedNode):
	def __init__(self, content_type, object_pk=None, template_name=None, kwargs=None):
		assert template_name is not None or object_pk is not None
		self.content_type = content_type
		self.kwargs = kwargs or {}
		
		if object_pk is not None:
			self.object_pk = object_pk
		else:
			self.object_pk = None
		
		if template_name is not None:
			self.template_name = template_name
		else:
			self.template_name = None
	
	def get_instance(self, context):
		if self.object_pk is None:
			return None
		return self.compile_instance(self.object_pk.resolve(context))
	
	def get_template(self, context):
		if self.template_name is None:
			return None
		return self.compile_template(self.template_name.resolve(context))


class InstanceEmbedNode(EmbedNode):
	def __init__(self, instance, kwargs=None):
		self.instance = instance
		self.kwargs = kwargs or {}
	
	def get_template(self, context):
		return None
	
	def get_instance(self, context):
		return self.instance.resolve(context)
	
	def get_content_type(self, context):
		instance = self.get_instance(context)
		if not instance:
			return None
		return ContentType.objects.get_for_model(instance)


def get_embedded(self):
	return self.template


setattr(ConstantEmbedNode, LOADED_TEMPLATE_ATTR, property(get_embedded))


def parse_content_type(bit, tagname):
	try:
		app_label, model = bit.split('.')
	except ValueError:
		raise template.TemplateSyntaxError('"%s" template tag expects the first argument to be of the form app_label.model' % tagname)
	try:
		ct = ContentType.objects.get_by_natural_key(app_label, model)
	except ContentType.DoesNotExist:
		raise template.TemplateSyntaxError('"%s" template tag requires an argument of the form app_label.model which refers to an installed content type (see django.contrib.contenttypes)' % tagname)
	return ct


@register.tag
def embed(parser, token):
	"""
	The {% embed %} tag can be used in two ways.
	
	First, to set which template will be used to render a particular model. This declaration can be placed in a base template and will propagate into all templates that extend that template.
	
	Syntax::
	
		{% embed <app_label>.<model_name> with <template> %}
	
	Second, to embed a specific model instance in the document with a template specified earlier in the template or in a parent template using the first syntax. The instance can be specified as a content type and pk or as a context variable. Any kwargs provided will be passed into the context of the template.
	
	Syntax::
	
		{% embed (<app_label>.<model_name> <object_pk> || <instance>) [<argname>=<value> ...] %}
	
	"""
	bits = token.split_contents()
	tag = bits.pop(0)
	
	if len(bits) < 1:
		raise template.TemplateSyntaxError('"%s" template tag must have at least two arguments.' % tag)
	
	if len(bits) == 3 and bits[-2] == 'with':
		ct = parse_content_type(bits[0], tag)
		
		if bits[2][0] in ['"', "'"] and bits[2][0] == bits[2][-1]:
			return ConstantEmbedNode(ct, template_name=bits[2])
		return EmbedNode(ct, template_name=bits[2])
	
	# Otherwise they're trying to embed a certain instance.
	kwargs = {}
	try:
		bit = bits.pop()
		while '=' in bit:
			k, v = bit.split('=')
			kwargs[k] = parser.compile_filter(v)
			bit = bits.pop()
		bits.append(bit)
	except IndexError:
		raise template.TemplateSyntaxError('"%s" template tag expects at least one non-keyword argument when embedding instances.')
	
	if len(bits) == 1:
		instance = parser.compile_filter(bits[0])
		return InstanceEmbedNode(instance, kwargs)
	elif len(bits) > 2:
		raise template.TemplateSyntaxError('"%s" template tag expects at most 2 non-keyword arguments when embedding instances.')
	ct = parse_content_type(bits[0], tag)
	pk = bits[1]
	
	try:
		int(pk)
	except ValueError:
		return EmbedNode(ct, object_pk=parser.compile_filter(pk), kwargs=kwargs)
	else:
		return ConstantEmbedNode(ct, object_pk=pk, kwargs=kwargs)
########NEW FILE########
__FILENAME__ = include_string
from django import template
from django.conf import settings


register = template.Library()


class IncludeStringNode(template.Node):
	def __init__(self, string):
		self.string = string
	
	def render(self, context):
		try:
			t = template.Template(self.string.resolve(context))
			return t.render(context)
		except template.TemplateSyntaxError:
			if settings.TEMPLATE_DEBUG:
				raise
			return settings.TEMPLATE_STRING_IF_INVALID
		except:
			return settings.TEMPLATE_STRING_IF_INVALID


@register.tag
def include_string(parser, token):
	"""
	Include a flat string by interpreting it as a template. The compiled template will be rendered with the current context.
	
	Usage::
	
		{% include_string <template_code> %}
	
	"""
	bits = token.split_contents()
	if len(bits) != 2:
		raise TemplateSyntaxError("%r tag takes one argument: the template string to be included" % bits[0])
 	string = parser.compile_filter(bits[1])
	return IncludeStringNode(string)
########NEW FILE########
__FILENAME__ = nodes
"""
The node template tags are automatically included as builtins if :mod:`philo` is an installed app.

"""

from django import template
from django.conf import settings
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse, NoReverseMatch
from django.template.defaulttags import kwarg_re
from django.utils.encoding import smart_str

from philo.exceptions import ViewCanNotProvideSubpath


register = template.Library()


class NodeURLNode(template.Node):
	def __init__(self, node, as_var, with_obj=None, view_name=None, args=None, kwargs=None):
		self.as_var = as_var
		self.view_name = view_name
		
		# Because the following variables have already been compiled as filters if they exist, they don't need to be re-scanned as template variables.
		self.node = node
		self.with_obj = with_obj
		self.args = args
		self.kwargs = kwargs
	
	def render(self, context):
		if self.node:
			node = self.node.resolve(context)
		else:
			node = context.get('node', None)
		
		if not node:
			return settings.TEMPLATE_STRING_IF_INVALID
		
		if self.with_obj is None and self.view_name is None:
			url = node.get_absolute_url()
		else:
			if not node.accepts_subpath:
				return settings.TEMPLATE_STRING_IF_INVALID
			
			if self.with_obj is not None:
				try:
					view_name, args, kwargs = node.view.get_reverse_params(self.with_obj.resolve(context))
				except ViewCanNotProvideSubpath:
					return settings.TEMPLATE_STRING_IF_INVALID
			else: # self.view_name is not None
				view_name = self.view_name
				args = [arg.resolve(context) for arg in self.args]
				kwargs = dict([(smart_str(k, 'ascii'), v.resolve(context)) for k, v in self.kwargs.items()])
			
			url = ''
			try:
				subpath = reverse(view_name, urlconf=node.view, args=args, kwargs=kwargs)
			except NoReverseMatch:
				if self.as_var is None:
					if settings.TEMPLATE_DEBUG:
						raise
					return settings.TEMPLATE_STRING_IF_INVALID
			else:
				url = node.construct_url(subpath)
		
		if self.as_var:
			context[self.as_var] = url
			return ''
		else:
			return url


@register.tag
def node_url(parser, token):
	"""
	The :ttag:`node_url` tag allows access to :meth:`.View.reverse` from a template for a :class:`.Node`. By default, the :class:`.Node` that is used for the call is pulled from the context variable ``node``; however, this can be overridden with the ``[for <node>]`` option.
	
	Usage::
	
		{% node_url [for <node>] [as <var>] %}
		{% node_url with <obj> [for <node>] [as <var>] %}
		{% node_url <view_name> [<arg1> [<arg2> ...] ] [for <node>] [as <var>] %}
		{% node_url <view_name> [<key1>=<value1> [<key2>=<value2> ...] ] [for <node>] [as <var>] %}
	
	"""
	params = token.split_contents()
	tag = params[0]
	as_var = None
	with_obj = None
	node = None
	params = params[1:]
	
	if len(params) >= 2 and params[-2] == 'as':
		as_var = params[-1]
		params = params[:-2]
	
	if len(params) >= 2 and params[-2] == 'for':
		node = parser.compile_filter(params[-1])
		params = params[:-2]
	
	if len(params) >= 2 and params[-2] == 'with':
		with_obj = parser.compile_filter(params[-1])
		params = params[:-2]
	
	if with_obj is not None:
		if params:
			raise template.TemplateSyntaxError('`%s` template tag accepts no arguments or keyword arguments if with <obj> is specified.' % tag)
		return NodeURLNode(with_obj=with_obj, node=node, as_var=as_var)
	
	if params:
		args = []
		kwargs = {}
		view_name = params.pop(0)
		for param in params:
			match = kwarg_re.match(param)
			if not match:
				raise TemplateSyntaxError("Malformed arguments to `%s` tag" % tag)
			name, value = match.groups()
			if name:
				kwargs[name] = parser.compile_filter(value)
			else:
				args.append(parser.compile_filter(value))
		return NodeURLNode(view_name=view_name, args=args, kwargs=kwargs, node=node, as_var=as_var)
	
	return NodeURLNode(node=node, as_var=as_var)
########NEW FILE########
__FILENAME__ = tests
import sys
import traceback

from django import template
from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.db import connection, models
from django.template import loader
from django.template.loaders import cached
from django.test import TestCase
from django.test.utils import setup_test_template_loader, restore_template_loaders
from django.utils.datastructures import SortedDict

from philo.exceptions import AncestorDoesNotExist
from philo.models import Node, Page, Template, Tag


class TemplateTestCase(TestCase):
	fixtures = ['test_fixtures.json']
	
	def test_templates(self):
		"Tests to make sure that embed behaves with complex includes and extends"
		template_tests = self.get_template_tests()
		
		# Register our custom template loader. Shamelessly cribbed from django/tests/regressiontests/templates/tests.py:384.
		cache_loader = setup_test_template_loader(
			dict([(name, t[0]) for name, t in template_tests.iteritems()]),
			use_cached_loader=True,
		)
		
		failures = []
		tests = template_tests.items()
		tests.sort()
		
		# Turn TEMPLATE_DEBUG off, because tests assume that.
		old_td, settings.TEMPLATE_DEBUG = settings.TEMPLATE_DEBUG, False
		
		# Set TEMPLATE_STRING_IF_INVALID to a known string.
		old_invalid = settings.TEMPLATE_STRING_IF_INVALID
		expected_invalid_str = 'INVALID'
		
		# Run tests
		for name, vals in tests:
			xx, context, result = vals
			try:
				test_template = loader.get_template(name)
				output = test_template.render(template.Context(context))
			except Exception:
				exc_type, exc_value, exc_tb = sys.exc_info()
				if exc_type != result:
					tb = '\n'.join(traceback.format_exception(exc_type, exc_value, exc_tb))
					failures.append("Template test %s -- FAILED. Got %s, exception: %s\n%s" % (name, exc_type, exc_value, tb))
				continue
			if output != result:
				failures.append("Template test %s -- FAILED. Expected %r, got %r" % (name, result, output))
		
		# Cleanup
		settings.TEMPLATE_DEBUG = old_td
		settings.TEMPLATE_STRING_IF_INVALID = old_invalid
		restore_template_loaders()
		
		self.assertEqual(failures, [], "Tests failed:\n%s\n%s" % ('-'*70, ("\n%s\n" % ('-'*70)).join(failures)))
	
	
	def get_template_tests(self):
		# SYNTAX --
		# 'template_name': ('template contents', 'context dict', 'expected string output' or Exception class)
		embedded = Tag.objects.get(pk=1)
		return {
			# EMBED INCLUSION HANDLING
			
			'embed01': ('{{ embedded.name|safe }}', {'embedded': embedded}, embedded.name),
			'embed02': ('{{ embedded.name|safe }}{{ var1 }}{{ var2 }}', {'embedded': embedded}, embedded.name),
			'embed03': ('{{ embedded.name|safe }} is a lie!', {'embedded': embedded}, '%s is a lie!' % embedded.name),
			
			# Simple template structure with embed
			'simple01': ('{% embed philo.tag with "embed01" %}{% embed philo.tag 1 %}Simple{% block one %}{% endblock %}', {'embedded': embedded}, '%sSimple' % embedded.name),
			'simple02': ('{% extends "simple01" %}', {}, '%sSimple' % embedded.name),
			'simple03': ('{% embed philo.tag with "embed000" %}', {}, settings.TEMPLATE_STRING_IF_INVALID),
			'simple04': ('{% embed philo.tag 1 %}', {}, settings.TEMPLATE_STRING_IF_INVALID),
			'simple05': ('{% embed philo.tag with "embed01" %}{% embed embedded %}', {'embedded': embedded}, embedded.name),
			
			# Kwargs
			'kwargs01': ('{% embed philo.tag with "embed02" %}{% embed philo.tag 1 var1="hi" var2=lo %}', {'lo': 'lo'}, '%shilo' % embedded.name),
			
			# Filters/variables
			'filters01': ('{% embed philo.tag with "embed02" %}{% embed philo.tag 1 var1=hi|first var2=lo|slice:"3" %}', {'hi': ["These", "words"], 'lo': 'lower'}, '%sTheselow' % embedded.name),
			'filters02': ('{% embed philo.tag with "embed01" %}{% embed philo.tag entry %}', {'entry': 1}, embedded.name),
			
			# Blocky structure
			'block01': ('{% block one %}Hello{% endblock %}', {}, 'Hello'),
			'block02': ('{% extends "simple01" %}{% block one %}{% embed philo.tag 1 %}{% endblock %}', {}, "%sSimple%s" % (embedded.name, embedded.name)),
			'block03': ('{% extends "simple01" %}{% embed philo.tag with "embed03" %}{% block one %}{% embed philo.tag 1 %}{% endblock %}', {}, "%sSimple%s is a lie!" % (embedded.name, embedded.name)),
			
			# Blocks and includes
			'block-include01': ('{% extends "simple01" %}{% embed philo.tag with "embed03" %}{% block one %}{% include "simple01" %}{% embed philo.tag 1 %}{% endblock %}', {}, "%sSimple%sSimple%s is a lie!" % (embedded.name, embedded.name, embedded.name)),
			'block-include02': ('{% extends "simple01" %}{% block one %}{% include "simple04" %}{% embed philo.tag with "embed03" %}{% include "simple04" %}{% embed philo.tag 1 %}{% endblock %}', {}, "%sSimple%s%s is a lie!%s is a lie!" % (embedded.name, embedded.name, embedded.name, embedded.name)),
			
			# Tests for more complex situations...
			'complex01': ('{% block one %}{% endblock %}complex{% block two %}{% endblock %}', {}, 'complex'),
			'complex02': ('{% extends "complex01" %}', {}, 'complex'),
			'complex03': ('{% extends "complex02" %}{% embed philo.tag with "embed01" %}', {}, 'complex'),
			'complex04': ('{% extends "complex03" %}{% block one %}{% embed philo.tag 1 %}{% endblock %}', {}, '%scomplex' % embedded.name),
			'complex05': ('{% extends "complex03" %}{% block one %}{% include "simple04" %}{% endblock %}', {}, '%scomplex' % embedded.name),
		}


class NodeURLTestCase(TestCase):
	"""Tests the features of the node_url template tag."""
	urls = 'philo.urls'
	fixtures = ['test_fixtures.json']
	
	def setUp(self):
		self.templates = [
				("{% node_url %}", "/root/second"),
				("{% node_url for node2 %}", "/root/second2"),
				("{% node_url as hello %}<p>{{ hello|slice:'1:' }}</p>", "<p>root/second</p>"),
				("{% node_url for nodes|first %}", "/root"),
		]
		
		nodes = Node.objects.all()
		
		self.context = template.Context({
			'node': nodes.get(slug='second'),
			'node2': nodes.get(slug='second2'),
			'nodes': nodes,
		})
	
	def test_nodeurl(self):
		for string, result in self.templates:
			self.assertEqual(template.Template(string).render(self.context), result)

class TreePathTestCase(TestCase):
	urls = 'philo.urls'
	fixtures = ['test_fixtures.json']
	
	def assertQueryLimit(self, max, expected_result, *args, **kwargs):
		# As a rough measure of efficiency, limit the number of queries required for a given operation.
		settings.DEBUG = True
		call = kwargs.pop('callable', Node.objects.get_with_path)
		try:
			queries = len(connection.queries)
			if isinstance(expected_result, type) and issubclass(expected_result, Exception):
				self.assertRaises(expected_result, call, *args, **kwargs)
			else:
				self.assertEqual(call(*args, **kwargs), expected_result)
			queries = len(connection.queries) - queries
			if queries > max:
				raise AssertionError('"%d" unexpectedly not less than or equal to "%s"' % (queries, max))
		finally:
			settings.DEBUG = False
	
	def test_get_with_path(self):
		root = Node.objects.get(slug='root')
		third = Node.objects.get(slug='third')
		second2 = Node.objects.get(slug='second2')
		fifth = Node.objects.get(slug='fifth')
		e = Node.DoesNotExist
		
		# Empty segments
		self.assertQueryLimit(0, root, '', root=root)
		self.assertQueryLimit(0, e, '')
		self.assertQueryLimit(0, (root, None), '', root=root, absolute_result=False)
		
		# Absolute result
		self.assertQueryLimit(1, third, 'root/second/third')
		self.assertQueryLimit(1, third, 'second/third', root=root)
		self.assertQueryLimit(1, third, 'root//////second/third///')
		
		self.assertQueryLimit(1, e, 'root/secont/third')
		self.assertQueryLimit(1, e, 'second/third')
		
		# Non-absolute result (binary search)
		self.assertQueryLimit(2, (second2, 'sub/path/tail'), 'root/second2/sub/path/tail', absolute_result=False)
		self.assertQueryLimit(3, (second2, 'sub'), 'root/second2/sub/', absolute_result=False)
		self.assertQueryLimit(2, e, 'invalid/path/1/2/3/4/5/6/7/8/9/1/2/3/4/5/6/7/8/9/0', absolute_result=False)
		self.assertQueryLimit(1, (root, None), 'root', absolute_result=False)
		self.assertQueryLimit(2, (second2, None), 'root/second2', absolute_result=False)
		self.assertQueryLimit(3, (third, None), 'root/second/third', absolute_result=False)
		
		# with root != None
		self.assertQueryLimit(1, (second2, None), 'second2', root=root, absolute_result=False)
		self.assertQueryLimit(2, (third, None), 'second/third', root=root, absolute_result=False)
		
		# Eliminate trailing slash
		self.assertQueryLimit(2, (second2, 'sub/path/tail'), 'root/second2/sub/path/tail/', absolute_result=False)
		
		# Speed increase for leaf nodes - should this be tested?
		self.assertQueryLimit(1, (fifth, 'sub/path/tail/len/five'), 'root/second/third/fourth/fifth/sub/path/tail/len/five', absolute_result=False)
	
	def test_get_path(self):
		root = Node.objects.get(slug='root')
		root2 = Node.objects.get(slug='root')
		third = Node.objects.get(slug='third')
		second2 = Node.objects.get(slug='second2')
		fifth = Node.objects.get(slug='fifth')
		e = AncestorDoesNotExist
		
		self.assertQueryLimit(0, 'root', callable=root.get_path)
		self.assertQueryLimit(0, '', root2, callable=root.get_path)
		self.assertQueryLimit(1, 'root/second/third', callable=third.get_path)
		self.assertQueryLimit(1, 'second/third', root, callable=third.get_path)
		self.assertQueryLimit(1, e, third, callable=second2.get_path)
		self.assertQueryLimit(1, '? - ?', root, ' - ', 'title', callable=third.get_path)


class ContainerTestCase(TestCase):
	def test_simple_containers(self):
		t = Template(code="{% container one %}{% container two %}{% container three %}{% container two %}")
		contentlet_specs, contentreference_specs = t.containers
		self.assertEqual(len(contentreference_specs.keyOrder), 0)
		self.assertEqual(contentlet_specs, ['one', 'two', 'three'])
		
		ct = ContentType.objects.get_for_model(Tag)
		t = Template(code="{% container one references philo.tag as tag1 %}{% container two references philo.tag as tag2 %}{% container one references philo.tag as tag1 %}")
		contentlet_specs, contentreference_specs = t.containers
		self.assertEqual(len(contentlet_specs), 0)
		self.assertEqual(contentreference_specs, SortedDict([('one', ct), ('two', ct)]))

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls.defaults import patterns, url

from philo.views import node_view


urlpatterns = patterns('',
	url(r'^$', node_view, kwargs={'path': '/'}, name='philo-root'),
	url(r'^(?P<path>.*)$', node_view, name='philo-node-by-path')
)

########NEW FILE########
__FILENAME__ = entities
from functools import partial
from UserDict import DictMixin

from django.db import models
from django.contrib.contenttypes.models import ContentType

from philo.utils.lazycompat import SimpleLazyObject


### AttributeMappers


class AttributeMapper(object, DictMixin):
	"""
	Given an :class:`~philo.models.base.Entity` subclass instance, this class allows dictionary-style access to the :class:`~philo.models.base.Entity`'s :class:`~philo.models.base.Attribute`\ s. In order to prevent unnecessary queries, the :class:`AttributeMapper` will cache all :class:`~philo.models.base.Attribute`\ s and the associated python values when it is first accessed.
	
	:param entity: The :class:`~philo.models.base.Entity` subclass instance whose :class:`~philo.models.base.Attribute`\ s will be made accessible.
	
	"""
	def __init__(self, entity):
		self.entity = entity
		self.clear_cache()
	
	def __getitem__(self, key):
		"""Returns the ultimate python value of the :class:`~philo.models.base.Attribute` with the given ``key`` from the cache, populating the cache if necessary."""
		if not self._cache_filled:
			self._fill_cache()
		return self._cache[key]
	
	def __setitem__(self, key, value):
		"""Given a python value, sets the value of the :class:`~philo.models.base.Attribute` with the given ``key`` to that value."""
		# Prevent circular import.
		from philo.models.base import JSONValue, ForeignKeyValue, ManyToManyValue, Attribute
		old_attr = self.get_attribute(key)
		if old_attr and old_attr.entity_content_type == ContentType.objects.get_for_model(self.entity) and old_attr.entity_object_id == self.entity.pk:
			attribute = old_attr
		else:
			attribute = Attribute(key=key)
			attribute.entity = self.entity
			attribute.full_clean()
		
		if isinstance(value, models.query.QuerySet):
			value_class = ManyToManyValue
		elif isinstance(value, models.Model):
			value_class = ForeignKeyValue
		else:
			value_class = JSONValue
		
		attribute.set_value(value=value, value_class=value_class)
		self._cache[key] = attribute.value.value
		self._attributes_cache[key] = attribute
	
	def get_attributes(self):
		"""Returns an iterable of all of the :class:`~philo.models.base.Entity`'s :class:`~philo.models.base.Attribute`\ s."""
		return self.entity.attribute_set.all()
	
	def get_attribute(self, key, default=None):
		"""Returns the :class:`~philo.models.base.Attribute` instance with the given ``key`` from the cache, populating the cache if necessary, or ``default`` if no such attribute is found."""
		if not self._cache_filled:
			self._fill_cache()
		return self._attributes_cache.get(key, default)
	
	def keys(self):
		"""Returns the keys from the cache, first populating the cache if necessary."""
		if not self._cache_filled:
			self._fill_cache()
		return self._cache.keys()
	
	def items(self):
		"""Returns the items from the cache, first populating the cache if necessary."""
		if not self._cache_filled:
			self._fill_cache()
		return self._cache.items()
	
	def values(self):
		"""Returns the values from the cache, first populating the cache if necessary."""
		if not self._cache_filled:
			self._fill_cache()
		return self._cache.values()
	
	def _fill_cache(self):
		if self._cache_filled:
			return
		
		attributes = self.get_attributes()
		value_lookups = {}
		
		for a in attributes:
			value_lookups.setdefault(a.value_content_type_id, []).append(a.value_object_id)
			self._attributes_cache[a.key] = a
		
		values_bulk = dict(((ct_pk, SimpleLazyObject(partial(ContentType.objects.get_for_id(ct_pk).model_class().objects.in_bulk, pks))) for ct_pk, pks in value_lookups.items()))
		
		cache = {}
		
		for a in attributes:
			cache[a.key] = SimpleLazyObject(partial(self._lazy_value_from_bulk, values_bulk, a))
			a._value_cache = cache[a.key]
		
		self._cache.update(cache)
		self._cache_filled = True
	
	def _lazy_value_from_bulk(self, bulk, attribute):
		v = bulk[attribute.value_content_type_id].get(attribute.value_object_id)
		return getattr(v, 'value', None)
	
	def clear_cache(self):
		"""Clears the cache."""
		self._cache = {}
		self._attributes_cache = {}
		self._cache_filled = False


class LazyAttributeMapperMixin(object):
	"""In some cases, it may be that only one attribute value needs to be fetched. In this case, it is more efficient to avoid populating the cache whenever possible. This mixin overrides the :meth:`__getitem__` and :meth:`get_attribute` methods to prevent their populating the cache. If the cache has been populated (i.e. through :meth:`keys`, :meth:`values`, etc.), then the value or attribute will simply be returned from the cache."""
	def __getitem__(self, key):
		if key not in self._cache and not self._cache_filled:
			self._add_to_cache(key)
		return self._cache[key]
	
	def get_attribute(self, key, default=None):
		if key not in self._attributes_cache and not self._cache_filled:
			self._add_to_cache(key)
		return self._attributes_cache.get(key, default)
	
	def _raw_get_attribute(self, key):
		return self.get_attributes().get(key=key)
	
	def _add_to_cache(self, key):
		from philo.models.base import Attribute
		try:
			attr = self._raw_get_attribute(key)
		except Attribute.DoesNotExist:
			raise KeyError
		else:
			val = getattr(attr.value, 'value', None)
			self._cache[key] = val
			self._attributes_cache[key] = attr


class LazyAttributeMapper(LazyAttributeMapperMixin, AttributeMapper):
	def get_attributes(self):
		return super(LazyAttributeMapper, self).get_attributes().exclude(key__in=self._cache.keys())


class TreeAttributeMapper(AttributeMapper):
	"""The :class:`~philo.models.base.TreeEntity` class allows the inheritance of :class:`~philo.models.base.Attribute`\ s down the tree. This mapper will return the most recently declared :class:`~philo.models.base.Attribute` among the :class:`~philo.models.base.TreeEntity`'s ancestors or set an attribute on the :class:`~philo.models.base.Entity` it is attached to."""
	def get_attributes(self):
		"""Returns a list of :class:`~philo.models.base.Attribute`\ s sorted by increasing parent level. When used to populate the cache, this will cause :class:`~philo.models.base.Attribute`\ s on the root to be overwritten by those on its children, etc."""
		from philo.models import Attribute
		ancestors = dict(self.entity.get_ancestors(include_self=True).values_list('pk', 'level'))
		ct = ContentType.objects.get_for_model(self.entity)
		attrs = Attribute.objects.filter(entity_content_type=ct, entity_object_id__in=ancestors.keys())
		return sorted(attrs, key=lambda x: ancestors[x.entity_object_id])


class LazyTreeAttributeMapper(LazyAttributeMapperMixin, TreeAttributeMapper):
	def get_attributes(self):
		from philo.models import Attribute
		ancestors = dict(self.entity.get_ancestors(include_self=True).values_list('pk', 'level'))
		ct = ContentType.objects.get_for_model(self.entity)
		attrs = Attribute.objects.filter(entity_content_type=ct, entity_object_id__in=ancestors.keys()).exclude(key__in=self._cache.keys())
		return sorted(attrs, key=lambda x: ancestors[x.entity_object_id])
	
	def _raw_get_attribute(self, key):
		from philo.models import Attribute
		ancestors = dict(self.entity.get_ancestors(include_self=True).values_list('pk', 'level'))
		ct = ContentType.objects.get_for_model(self.entity)
		try:
			attrs = Attribute.objects.filter(entity_content_type=ct, entity_object_id__in=ancestors.keys(), key=key)
			sorted_attrs = sorted(attrs, key=lambda x: ancestors[x.entity_object_id], reverse=True)
			return sorted_attrs[0]
		except IndexError:
			raise Attribute.DoesNotExist


class PassthroughAttributeMapper(AttributeMapper):
	"""
	Given an iterable of :class:`Entities <philo.models.base.Entity>`, this mapper will fetch an :class:`AttributeMapper` for each one. Lookups will return the value from the first :class:`AttributeMapper` which has an entry for a given key. Assignments will be made to the first :class:`.Entity` in the iterable.
	
	:param entities: An iterable of :class:`.Entity` subclass instances.
	
	"""
	def __init__(self, entities):
		self._attributes = [e.attributes for e in entities]
		super(PassthroughAttributeMapper, self).__init__(self._attributes[0].entity)
	
	def _fill_cache(self):
		if self._cache_filled:
			return
		
		for a in reversed(self._attributes):
			a._fill_cache()
			self._attributes_cache.update(a._attributes_cache)
			self._cache.update(a._cache)
		
		self._cache_filled = True
	
	def get_attributes(self):
		raise NotImplementedError
	
	def clear_cache(self):
		super(PassthroughAttributeMapper, self).clear_cache()
		for a in self._attributes:
			a.clear_cache()


class LazyPassthroughAttributeMapper(LazyAttributeMapperMixin, PassthroughAttributeMapper):
	"""The :class:`LazyPassthroughAttributeMapper` is lazy in that it tries to avoid accessing the :class:`AttributeMapper`\ s that it uses for lookups. However, those :class:`AttributeMapper`\ s may or may not be lazy themselves."""
	def _raw_get_attribute(self, key):
		from philo.models import Attribute
		for a in self._attributes:
			attr = a.get_attribute(key)
			if attr is not None:
				return attr
		raise Attribute.DoesNotExist
########NEW FILE########
__FILENAME__ = lazycompat
try:
	from django.utils.functional import empty, LazyObject, SimpleLazyObject
except ImportError:
	# Supply LazyObject and SimpleLazyObject for django < r16308
	import operator
	
	
	empty = object()
	def new_method_proxy(func):
		def inner(self, *args):
			if self._wrapped is empty:
				self._setup()
			return func(self._wrapped, *args)
		return inner

	class LazyObject(object):
		"""
		A wrapper for another class that can be used to delay instantiation of the
		wrapped class.

		By subclassing, you have the opportunity to intercept and alter the
		instantiation. If you don't need to do that, use SimpleLazyObject.
		"""
		def __init__(self):
			self._wrapped = empty

		__getattr__ = new_method_proxy(getattr)

		def __setattr__(self, name, value):
			if name == "_wrapped":
				# Assign to __dict__ to avoid infinite __setattr__ loops.
				self.__dict__["_wrapped"] = value
			else:
				if self._wrapped is empty:
					self._setup()
				setattr(self._wrapped, name, value)

		def __delattr__(self, name):
			if name == "_wrapped":
				raise TypeError("can't delete _wrapped.")
			if self._wrapped is empty:
				self._setup()
			delattr(self._wrapped, name)

		def _setup(self):
			"""
			Must be implemented by subclasses to initialise the wrapped object.
			"""
			raise NotImplementedError

		# introspection support:
		__members__ = property(lambda self: self.__dir__())
		__dir__ = new_method_proxy(dir)


	class SimpleLazyObject(LazyObject):
		"""
		A lazy object initialised from any function.

		Designed for compound objects of unknown type. For builtins or objects of
		known type, use django.utils.functional.lazy.
		"""
		def __init__(self, func):
			"""
			Pass in a callable that returns the object to be wrapped.

			If copies are made of the resulting SimpleLazyObject, which can happen
			in various circumstances within Django, then you must ensure that the
			callable can be safely run more than once and will return the same
			value.
			"""
			self.__dict__['_setupfunc'] = func
			super(SimpleLazyObject, self).__init__()

		def _setup(self):
			self._wrapped = self._setupfunc()

		__str__ = new_method_proxy(str)
		__unicode__ = new_method_proxy(unicode)

		def __deepcopy__(self, memo):
			if self._wrapped is empty:
				# We have to use SimpleLazyObject, not self.__class__, because the
				# latter is proxied.
				result = SimpleLazyObject(self._setupfunc)
				memo[id(self)] = result
				return result
			else:
				import copy
				return copy.deepcopy(self._wrapped, memo)

		# Need to pretend to be the wrapped class, for the sake of objects that care
		# about this (especially in equality tests)
		__class__ = property(new_method_proxy(operator.attrgetter("__class__")))
		__eq__ = new_method_proxy(operator.eq)
		__hash__ = new_method_proxy(hash)
		__nonzero__ = new_method_proxy(bool)
########NEW FILE########
__FILENAME__ = registry
from django.core.validators import slug_re
from django.template.defaultfilters import slugify
from django.utils.encoding import smart_str


class RegistryIterator(object):
	"""
	Wraps the iterator returned by calling ``getattr(registry, iterattr)`` to provide late instantiation of the wrapped iterator and to allow copying of the iterator for even later instantiation.
	
	:param registry: The object which provides the iterator at ``iterattr``.
	:param iterattr: The name of the method on ``registry`` that provides the iterator.
	:param transform: A function which will be called on each result from the wrapped iterator before it is returned.
	
	"""
	def __init__(self, registry, iterattr='__iter__', transform=lambda x:x):
		if not hasattr(registry, iterattr):
			raise AttributeError("Registry has no attribute %s" % iterattr)
		self.registry = registry
		self.iterattr = iterattr
		self.transform = transform
	
	def __iter__(self):
		return self
	
	def next(self):
		if not hasattr(self, '_iter'):
			self._iter = getattr(self.registry, self.iterattr)()
		
		return self.transform(self._iter.next())
	
	def copy(self):
		"""Returns a fresh copy of this iterator."""
		return self.__class__(self.registry, self.iterattr, self.transform)


class RegistrationError(Exception):
	"""Raised if there is a problem registering a object with a :class:`Registry`"""
	pass


class Registry(object):
	"""Holds a registry of arbitrary objects by slug."""
	
	def __init__(self):
		self._registry = {}
	
	def register(self, obj, slug=None, verbose_name=None):
		"""
		Register an object with the registry.
		
		:param obj: The object to register.
		:param slug: The slug which will be used to register the object. If ``slug`` is ``None``, it will be generated from ``verbose_name`` or looked for at ``obj.slug``.
		:param verbose_name: The verbose name for the object. If ``verbose_name`` is ``None``, it will be looked for at ``obj.verbose_name``.
		:raises: :class:`RegistrationError` if a different object is already registered with ``slug``, or if ``slug`` is not a valid slug.
		
		"""
		verbose_name = verbose_name if verbose_name is not None else obj.verbose_name
		
		if slug is None:
			slug = getattr(obj, 'slug', slugify(verbose_name))
		slug = smart_str(slug)
		
		if not slug_re.search(slug):
			raise RegistrationError(u"%s is not a valid slug." % slug)
		
		
		if slug in self._registry:
			reg = self._registry[slug]
			if reg['obj'] != obj:
				raise RegistrationError(u"A different object is already registered as `%s`" % slug)
		else:
			self._registry[slug] = {
				'obj': obj,
				'verbose_name': verbose_name
			}
	
	def unregister(self, obj, slug=None):
		"""
		Unregister an object from the registry.
		
		:param obj: The object to unregister.
		:param slug: If provided, the object will only be removed if it was registered with ``slug``. If not provided, the object will be unregistered no matter what slug it was registered with.
		:raises: :class:`RegistrationError` if ``slug`` is provided and an object other than ``obj`` is registered as ``slug``.
		
		"""
		if slug is not None:
			if slug in self._registry:
				if self._registry[slug]['obj'] == obj:
					del self._registry[slug]
				else:
					raise RegistrationError(u"`%s` is not registered as `%s`" % (obj, slug))
		else:
			for slug, reg in self.items():
				if obj == reg:
					del self._registry[slug]
	
	def items(self):
		"""Returns a list of (slug, obj) items in the registry."""
		return [(slug, self[slug]) for slug in self._registry]
	
	def values(self):
		"""Returns a list of objects in the registry."""
		return [self[slug] for slug in self._registry]
	
	def iteritems(self):
		"""Returns a :class:`RegistryIterator` over the (slug, obj) pairs in the registry."""
		return RegistryIterator(self._registry, 'iteritems', lambda x: (x[0], x[1]['obj']))
	
	def itervalues(self):
		"""Returns a :class:`RegistryIterator` over the objects in the registry."""
		return RegistryIterator(self._registry, 'itervalues', lambda x: x['obj'])
	
	def iterchoices(self):
		"""Returns a :class:`RegistryIterator` over (slug, verbose_name) pairs for the registry."""
		return RegistryIterator(self._registry, 'iteritems', lambda x: (x[0], x[1]['verbose_name']))
	choices = property(iterchoices)
	
	def get(self, key, default=None):
		"""Returns the object registered with ``key`` or ``default`` if no object was registered."""
		try:
			return self[key]
		except KeyError:
			return default
	
	def get_slug(self, obj, default=None):
		"""Returns the slug used to register ``obj`` or ``default`` if ``obj`` was not registered."""
		for slug, reg in self.iteritems():
			if obj == reg:
				return slug
		return default
	
	def __getitem__(self, key):
		"""Returns the obj registered with ``key``."""
		return self._registry[key]['obj']
	
	def __iter__(self):
		"""Returns an iterator over the keys in the registry."""
		return self._registry.__iter__()
	
	def __contains__(self, item):
		return self._registry.__contains__(item)
########NEW FILE########
__FILENAME__ = templates
import itertools

from django.template import TextNode, VariableNode, Context
from django.template.loader_tags import BlockNode, ExtendsNode, BlockContext, ConstantIncludeNode
from django.utils.datastructures import SortedDict

from philo.templatetags.containers import ContainerNode


LOADED_TEMPLATE_ATTR = '_philo_loaded_template'
BLANK_CONTEXT = Context()


def get_extended(self):
	return self.get_parent(BLANK_CONTEXT)


def get_included(self):
	return self.template


# We ignore the IncludeNode because it will never work in a blank context.
setattr(ExtendsNode, LOADED_TEMPLATE_ATTR, property(get_extended))
setattr(ConstantIncludeNode, LOADED_TEMPLATE_ATTR, property(get_included))


def get_containers(template):
		# Build a tree of the templates we're using, placing the root template first.
		levels = build_extension_tree(template.nodelist)
		
		contentlet_specs = []
		contentreference_specs = SortedDict()
		blocks = {}
		
		for level in reversed(levels):
			level.initialize()
			contentlet_specs.extend(itertools.ifilter(lambda x: x not in contentlet_specs, level.contentlet_specs))
			contentreference_specs.update(level.contentreference_specs)
			for name, block in level.blocks.items():
				if block.block_super:
					blocks.setdefault(name, []).append(block)
				else:
					blocks[name] = [block]
		
		for block_list in blocks.values():
			for block in block_list:
				block.initialize()
				contentlet_specs.extend(itertools.ifilter(lambda x: x not in contentlet_specs, block.contentlet_specs))
				contentreference_specs.update(block.contentreference_specs)
		
		return contentlet_specs, contentreference_specs


class LazyContainerFinder(object):
	def __init__(self, nodes, extends=False):
		self.nodes = nodes
		self.initialized = False
		self.contentlet_specs = []
		self.contentreference_specs = SortedDict()
		self.blocks = {}
		self.block_super = False
		self.extends = extends
	
	def process(self, nodelist):
		for node in nodelist:
			if self.extends:
				if isinstance(node, BlockNode):
					self.blocks[node.name] = block = LazyContainerFinder(node.nodelist)
					block.initialize()
					self.blocks.update(block.blocks)
				continue
			
			if isinstance(node, ContainerNode):
				if not node.references:
					self.contentlet_specs.append(node.name)
				else:
					if node.name not in self.contentreference_specs.keys():
						self.contentreference_specs[node.name] = node.references
				continue
			
			if isinstance(node, VariableNode):
				if node.filter_expression.var.lookups == (u'block', u'super'):
					self.block_super = True
			
			if hasattr(node, 'child_nodelists'):
				for nodelist_name in node.child_nodelists:
					if hasattr(node, nodelist_name):
						nodelist = getattr(node, nodelist_name)
						self.process(nodelist)
			
			# LOADED_TEMPLATE_ATTR contains the name of an attribute philo uses to declare a
			# node as rendering an additional template. Philo monkeypatches the attribute onto
			# the relevant default nodes and declares it on any native nodes.
			if hasattr(node, LOADED_TEMPLATE_ATTR):
				loaded_template = getattr(node, LOADED_TEMPLATE_ATTR)
				if loaded_template:
					nodelist = loaded_template.nodelist
					self.process(nodelist)
	
	def initialize(self):
		if not self.initialized:
			self.process(self.nodes)
			self.initialized = True


def build_extension_tree(nodelist):
	nodelists = []
	extends = None
	for node in nodelist:
		if not isinstance(node, TextNode):
			if isinstance(node, ExtendsNode):
				extends = node
			break
	
	if extends:
		if extends.nodelist:
			nodelists.append(LazyContainerFinder(extends.nodelist, extends=True))
		loaded_template = getattr(extends, LOADED_TEMPLATE_ATTR)
		nodelists.extend(build_extension_tree(loaded_template.nodelist))
	else:
		# Base case: root.
		nodelists.append(LazyContainerFinder(nodelist))
	return nodelists
########NEW FILE########
__FILENAME__ = validators
import re

from django.core.exceptions import ValidationError
from django.template import Template, Parser, Lexer, TOKEN_BLOCK, TOKEN_VAR, TemplateSyntaxError
from django.utils import simplejson as json
from django.utils.html import escape, mark_safe
from django.utils.translation import ugettext_lazy as _

from philo.utils.templates import LOADED_TEMPLATE_ATTR


#: Tags which are considered insecure and are therefore always disallowed by secure :class:`TemplateValidator` instances.
INSECURE_TAGS = (
	'load',
	'extends',
	'include',
	'debug',
)


def json_validator(value):
	"""Validates whether ``value`` is a valid json string."""
	try:
		json.loads(value)
	except Exception, e:
		raise ValidationError(u'JSON decode error: %s' % e)


class TemplateValidationParser(Parser):
	def __init__(self, tokens, allow=None, disallow=None, secure=True):
		super(TemplateValidationParser, self).__init__(tokens)
		
		allow, disallow = set(allow or []), set(disallow or [])
		
		if secure:
			disallow |= set(INSECURE_TAGS)
		
		self.allow, self.disallow, self.secure = allow, disallow, secure
	
	def parse(self, parse_until=None):
		if parse_until is None:
			parse_until = []
		
		nodelist = self.create_nodelist()
		while self.tokens:
			token = self.next_token()
			# We only need to parse var and block tokens.
			if token.token_type == TOKEN_VAR:
				if not token.contents:
					self.empty_variable(token)
				
				filter_expression = self.compile_filter(token.contents)
				var_node = self.create_variable_node(filter_expression)
				self.extend_nodelist(nodelist, var_node,token)
			elif token.token_type == TOKEN_BLOCK:
				if token.contents in parse_until:
					# put token back on token list so calling code knows why it terminated
					self.prepend_token(token)
					return nodelist
				
				try:
					command = token.contents.split()[0]
				except IndexError:
					self.empty_block_tag(token)
				
				if (self.allow and command not in self.allow) or (self.disallow and command in self.disallow):
					self.disallowed_tag(command)
				
				self.enter_command(command, token)
				
				try:
					compile_func = self.tags[command]
				except KeyError:
					self.invalid_block_tag(token, command, parse_until)
				
				try:
					compiled_result = compile_func(self, token)
				except TemplateSyntaxError, e:
					if not self.compile_function_error(token, e):
						raise
				
				self.extend_nodelist(nodelist, compiled_result, token)
				self.exit_command()
		
		if parse_until:
			self.unclosed_block_tag(parse_until)
		
		return nodelist
	
	def disallowed_tag(self, command):
		if self.secure and command in INSECURE_TAGS:
			raise ValidationError('Tag "%s" is not permitted for security reasons.' % command)
		raise ValidationError('Tag "%s" is not permitted here.' % command)


def linebreak_iter(template_source):
	# Cribbed from django/views/debug.py:18
	yield 0
	p = template_source.find('\n')
	while p >= 0:
		yield p+1
		p = template_source.find('\n', p+1)
	yield len(template_source) + 1


class TemplateValidator(object): 
	"""
	Validates whether a string represents valid Django template code.
	
	:param allow: ``None`` or an iterable of tag names which are explicitly allowed. If provided, tags whose names are not in the iterable will cause a ValidationError to be raised if they are used in the template code.
	:param disallow: ``None`` or an iterable of tag names which are explicitly allowed. If provided, tags whose names are in the iterable will cause a ValidationError to be raised if they are used in the template code. If a tag's name is in ``allow`` and ``disallow``, it will be disallowed.
	:param secure: If the validator is set to secure, it will automatically disallow the tag names listed in :const:`INSECURE_TAGS`. Defaults to ``True``.
	
	"""
	def __init__(self, allow=None, disallow=None, secure=True):
		self.allow = allow
		self.disallow = disallow
		self.secure = secure
	
	def __call__(self, value):
		try:
			self.validate_template(value)
		except ValidationError:
			raise
		except Exception, e:
			if hasattr(e, 'source') and isinstance(e, TemplateSyntaxError):
				origin, (start, end) = e.source
				template_source = origin.reload()
				upto = 0
				for num, next in enumerate(linebreak_iter(template_source)):
					if start >= upto and end <= next:
						raise ValidationError(mark_safe("Template code invalid: \"%s\" (%s:%d).<br />%s" % (escape(template_source[start:end]), origin.loadname, num, e)))
					upto = next
			raise ValidationError("Template code invalid. Error was: %s: %s" % (e.__class__.__name__, e))
	
	def validate_template(self, template_string):
		# We want to tokenize like normal, then use a custom parser.
		lexer = Lexer(template_string, None)
		tokens = lexer.tokenize()
		parser = TemplateValidationParser(tokens, self.allow, self.disallow, self.secure)
		
		for node in parser.parse():
			template = getattr(node, LOADED_TEMPLATE_ATTR, None)
########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.core.urlresolvers import resolve
from django.http import Http404, HttpResponseRedirect
from django.views.decorators.vary import vary_on_headers

from philo.exceptions import MIDDLEWARE_NOT_CONFIGURED


@vary_on_headers('Accept')
def node_view(request, path=None, **kwargs):
	"""
	:func:`node_view` handles incoming requests by checking to make sure that:
	
	- the request has an attached :class:`.Node`.
	- the attached :class:`~philo.models.nodes.Node` handles any remaining path beyond its location.
	
	If these conditions are not met, then :func:`node_view` will either raise :exc:`Http404` or, if it seems like the address was mistyped (for example missing a trailing slash), return an :class:`HttpResponseRedirect` to the correct address.
	
	Otherwise, :func:`node_view` will call the :class:`.Node`'s :meth:`~.Node.render_to_response` method, passing ``kwargs`` in as the ``extra_context``.
	
	"""
	if "philo.middleware.RequestNodeMiddleware" not in settings.MIDDLEWARE_CLASSES:
		raise MIDDLEWARE_NOT_CONFIGURED
	
	if not request.node:
		if settings.APPEND_SLASH and request.path != "/":
			path = request.path
			
			if path[-1] == "/":
				path = path[:-1]
			else:
				path += "/"
			
			view, args, kwargs = resolve(path)
			if view != node_view:
				return HttpResponseRedirect(path)
		raise Http404
	
	node = request.node
	subpath = request.node._subpath
	
	# Explicitly disallow trailing slashes if we are otherwise at a node's url.
	if node._path != "/" and node._path[-1] == "/" and subpath == "/":
		return HttpResponseRedirect(node.get_absolute_url())
	
	if not node.handles_subpath(subpath):
		# If the subpath isn't handled, check settings.APPEND_SLASH. If
		# it's True, try to correct the subpath.
		if not settings.APPEND_SLASH:
			raise Http404
		
		if subpath[-1] == "/":
			subpath = subpath[:-1]
		else:
			subpath += "/"
		
		redirect_url = node.construct_url(subpath)
		
		if node.handles_subpath(subpath):
			return HttpResponseRedirect(redirect_url)
		
		# Perhaps there is a non-philo view at this address. Can we
		# resolve *something* there besides node_view? If not,
		# raise a 404.
		view, args, kwargs = resolve(redirect_url)
		
		if view == node_view:
			raise Http404
		else:
			return HttpResponseRedirect(redirect_url)
	
	return node.render_to_response(request, kwargs)
########NEW FILE########
