__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Nereid documentation build configuration file, created by
# sphinx-quickstart on Fri Jun  1 07:41:51 2012.
#
# This file is execfile()d with the current directory set to its containing
# dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.insert(0, os.path.abspath('..'))
sys.path.append(os.path.abspath('_themes'))

# -- General configuration ---------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = [
    'sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.viewcode'
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Nereid'
copyright = u'2012, Openlabs Technologies & Consulting (P) Limited'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The full version, including alpha/beta/rc tags.
import pkg_resources
try:
    release = pkg_resources.get_distribution('trytond_nereid').version
except pkg_resources.DistributionNotFound:
    print 'To build the documentation, The distribution information of Nereid'
    print 'Has to be available.  Either install the package into your'
    print 'development environment or run "setup.py develop" to setup the'
    print 'metadata.  A virtualenv is recommended!'
    sys.exit(1)
del pkg_resources

# The short X.Y version.
version = '.'.join(release.split('.')[:2])

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role(used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output -------------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'flask'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ['_themes']

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
html_logo = '_static/logo.png'

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
html_sidebars = {
    'index': ['sidebarintro.html', 'sourcelink.html', 'searchbox.html'],
}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'Nereiddoc'


# -- Options for LaTeX output ------------------------------------------------

latex_elements = {  # noqa
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass[howto/manual]).
latex_documents = [
    ('index', 'Nereid.tex', u'Nereid Documentation',
        u'Openlabs Technologies \\& Consulting (P) Limited', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ------------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'nereid', u'Nereid Documentation',
     [u'Openlabs Technologies & Consulting (P) Limited'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output ----------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
    ('index', 'Nereid', u'Nereid Documentation',
        u'Openlabs Technologies & Consulting (P) Limited', 'Nereid',
        'One line description of project.', 'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'


# -- Options for Epub output -------------------------------------------------

# Bibliographic Dublin Core info.
epub_title = u'Nereid'
epub_author = u'Openlabs Technologies & Consulting (P) Limited'
epub_publisher = u'Openlabs Technologies & Consulting (P) Limited'
epub_copyright = u'2012, Openlabs Technologies & Consulting (P) Limited'

# The language of the text. It defaults to the language option
# or en if the language is not set.
#epub_language = ''

# The scheme of the identifier. Typical schemes are ISBN or URL.
#epub_scheme = ''

# The unique identifier of the text. This can be a ISBN number
# or the project homepage.
#epub_identifier = ''

# A unique identification for the text.
#epub_uid = ''

# A tuple containing the cover image and cover page html template filenames.
#epub_cover = ()

# HTML files that should be inserted before the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_pre_files = []

# HTML files shat should be inserted after the pages created by sphinx.
# The format is a list of tuples containing the path and title.
#epub_post_files = []

# A list of files that should not be packed into the epub file.
#epub_exclude_files = []

# The depth of the table of contents in toc.ncx.
#epub_tocdepth = 3

# Allow duplicate toc entries.
#epub_tocdup = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {
    'http://docs.python.org/': None,
    'flask': ('http://flask.pocoo.org/docs/', None),

}


# --- Tryton specific configuration ----
from trytond.config import CONFIG
CONFIG.options['db_type'] = 'sqlite'
CONFIG.options['data_path'] = '/tmp/temp_tryton_data/'

########NEW FILE########
__FILENAME__ = application
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.

from __future__ import with_statement

import os  # noqa
import warnings
import inspect

from flask import Flask
from flask.config import ConfigAttribute
from flask.globals import _request_ctx_stack
from flask.helpers import locked_cached_property
from jinja2 import MemcachedBytecodeCache
from werkzeug import import_string
from flask_wtf.csrf import CsrfProtect
import flask.ext.login
from flask.ext.login import LoginManager

from trytond import backend
from trytond.pool import Pool
from trytond.cache import Cache
from trytond.config import CONFIG
from trytond.modules import register_classes
from trytond.transaction import Transaction

from .wrappers import Request, Response
from .session import NereidSessionInterface
from .templating import nereid_default_template_ctx_processor, \
    NEREID_TEMPLATE_FILTERS, ModuleTemplateLoader, LazyRenderer
from .helpers import url_for, root_transaction_if_required
from .ctx import RequestContext
from .signals import transaction_start, transaction_stop


class Nereid(Flask):
    """
    ...

    Unlike typical web frameworks and their APIs, nereid depends more on
    configuration and not direct python modules written along the APIs
    Most of the functional code will remain on the modules installed on
    Tryton, and the database configurations.

    ...

    """
    #: The class that is used for request objects.  See
    #: :class:`~nereid.wrappers.Request`
    #: for more information.
    request_class = Request

    #: The class that is used for response objects.  See
    #: :class:`~nereid.wrappers.Response` for more information.
    response_class = Response

    #: the session interface to use.  By default an instance of
    #: :class:`~nereid.session.NereidSessionInterface` is used here.
    session_interface = NereidSessionInterface()

    #: An internal attribute to hold the Tryton model pool to avoid being
    #: initialised at every request as it is quite expensive to do so.
    #: To access the pool from modules, use the :meth:`pool`
    _pool = None

    #: The attribute holds a connection to the database backend.
    _database = None

    #: Configuration file for Tryton. The path to the configuration file
    #: can be specified and will be loaded when the application is
    #: initialised
    tryton_configfile = ConfigAttribute('TRYTON_CONFIG')

    #: The location where the translations of the template are stored
    translations_path = ConfigAttribute('TRANSLATIONS_PATH')

    #: The name of the database to connect to on initialisation
    database_name = ConfigAttribute('DATABASE_NAME')

    #: The default timeout to use if the timeout is not explicitly
    #: specified in the set or set many argument
    cache_default_timeout = ConfigAttribute('CACHE_DEFAULT_TIMEOUT')

    #: the maximum number of items the cache stores before it starts
    #: deleting some items.
    #: Applies for: SimpleCache, FileSystemCache
    cache_threshold = ConfigAttribute('CACHE_THRESHOLD')

    #: a prefix that is added before all keys. This makes it possible
    #: to use the same memcached server for different applications.
    #: Applies for: MecachedCache, GAEMemcachedCache
    #: If key_prefix is none the value of site is used as key
    cache_key_prefix = ConfigAttribute('CACHE_KEY_PREFIX')

    #: a list or tuple of server addresses or alternatively a
    #: `memcache.Client` or a compatible client.
    cache_memcached_servers = ConfigAttribute('CACHE_MEMCACHED_SERVERS')

    #: The directory where cache files are stored if FileSystemCache is used
    cache_dir = ConfigAttribute('CACHE_DIR')

    #: The type of cache to use. The type must be a full specification of
    #: the module so that an import can be made. Examples for werkzeug
    #: backends are given below
    #:
    #:  NullCache - werkzeug.contrib.cache.NullCache (default)
    #:  SimpleCache - werkzeug.contrib.cache.SimpleCache
    #:  MemcachedCache - werkzeug.contrib.cache.MemcachedCache
    #:  GAEMemcachedCache -  werkzeug.contrib.cache.GAEMemcachedCache
    #:  FileSystemCache - werkzeug.contrib.cache.FileSystemCache
    cache_type = ConfigAttribute('CACHE_TYPE')

    #: If a custom cache backend unknown to Nereid is used, then
    #: the arguments that are needed for the initialisation
    #: of the cache could be passed here as a `dict`
    cache_init_kwargs = ConfigAttribute('CACHE_INIT_KWARGS')

    #: boolean attribute to indicate if the initialisation of backend
    #: connection and other nereid support features are loaded. The
    #: application can work only after the initialisation is done.
    #: It is not advisable to set this manually, instead call the
    #: :meth:`initialise`
    initialised = False

    #: Prefix the name of the website to the template name sutomatically
    #: This feature would be deprecated in future in lieu of writing
    #: Jinja2 Loaders which could offer this behavior. This is set to False
    #: by default. For backward compatibility of loading templates from
    #: a template folder which has website names as subfolders, set this
    #: to True
    #:
    #: .. versionadded:: 2.8.0.4
    template_prefix_website_name = ConfigAttribute(
        'TEMPLATE_PREFIX_WEBSITE_NAME'
    )

    #: Time in seconds for which the token is valid.
    token_validity_duration = ConfigAttribute(
        'TOKEN_VALIDITY_DURATION'
    )

    def __init__(self, **config):
        """
        The import_name is forced into `Nereid`
        """
        super(Nereid, self).__init__('nereid', **config)

        # Update the defaults for config attributes introduced by nereid
        self.config.update({
            'TRYTON_CONFIG': None,
            'TEMPLATE_PREFIX_WEBSITE_NAME': True,
            'TOKEN_VALIDITY_DURATION': 60 * 60,

            'CACHE_TYPE': 'werkzeug.contrib.cache.NullCache',
            'CACHE_DEFAULT_TIMEOUT': 300,
            'CACHE_THRESHOLD': 500,
            'CACHE_INIT_KWARGS': {},
            'CACHE_KEY_PREFIX': '',
        })

    def initialise(self):
        """
        The application needs initialisation to load the database
        connection etc. In previous versions this was done with the
        initialisation of the class in the __init__ method. This is
        now separated into this function.
        """
        #: Check if the secret key is defined, if not raise an
        #: exception since it is required
        assert self.secret_key, 'Secret Key is not defined in config'

        #: Load the cache
        self.load_cache()

        #: Initialise the CSRF handling
        self.csrf_protection = CsrfProtect()
        self.csrf_protection.init_app(self)

        self.view_functions['static'] = self.send_static_file

        # Backend initialisation
        self.load_backend()

        #: Initialise the login handler
        login_manager = LoginManager()
        login_manager.user_loader(self._pool.get('nereid.user').load_user)
        login_manager.header_loader(
            self._pool.get('nereid.user').load_user_from_header
        )
        login_manager.token_loader(
            self._pool.get('nereid.user').load_user_from_token
        )
        login_manager.unauthorized_handler(
            self._pool.get('nereid.user').unauthorized_handler
        )
        login_manager.login_view = "nereid.website.login"
        login_manager.anonymous_user = self._pool.get('nereid.user.anonymous')
        login_manager.init_app(self)

        self.login_manager = login_manager

        # Monkey patch the url_for method from flask-login to use
        # the nereid specific url_for
        flask.ext.login.url_for = url_for

        self.add_ctx_processors_from_db()

        # Add the additional template context processors
        self.template_context_processors[None].append(
            nereid_default_template_ctx_processor
        )

        # Finally set the initialised attribute
        self.initialised = True

    def get_urls(self):
        """
        Return the URL rules for routes formed by decorating methods with the
        :func:`~nereid.helpers.route` decorator.

        This method goes through all the models and their methods in the pool
        of the loaded database and looks for the `_url_rules` attribute in
        them. If there are URLs defined, it is added to the url map.
        """
        rules = []
        models = Pool._pool[self.database_name]['model']

        for model_name, model in models.iteritems():
            for f_name, f in inspect.getmembers(
                    model, predicate=inspect.ismethod):

                if not hasattr(f, '_url_rules'):
                    continue

                for rule in f._url_rules:
                    rules.append(
                        self.url_rule_class(
                            rule[0],
                            endpoint='.'.join([model_name, f_name]),
                            **rule[1]
                        )
                    )

        return rules

    def load_cache(self):
        """
        Load the cache and assign the Cache interface to
        """
        BackendClass = import_string(self.cache_type)

        if self.cache_type == 'werkzeug.contrib.cache.NullCache':
            self.cache = BackendClass(self.cache_default_timeout)
        elif self.cache_type == 'werkzeug.contrib.cache.SimpleCache':
            self.cache = BackendClass(
                self.cache_threshold, self.cache_default_timeout)
        elif self.cache_type == 'werkzeug.contrib.cache.MemcachedCache':
            self.cache = BackendClass(
                self.cache_memcached_servers,
                self.cache_default_timeout,
                self.cache_key_prefix)
        elif self.cache_type == 'werkzeug.contrib.cache.GAEMemcachedCache':
            self.cache = BackendClass(
                self.cache_default_timeout,
                self.cache_key_prefix)
        elif self.cache_type == 'werkzeug.contrib.cache.FileSystemCache':
            self.cache = BackendClass(
                self.cache_dir,
                self.cache_threshold,
                self.cache_default_timeout)
        else:
            self.cache = BackendClass(**self.cache_init_kwargs)

    def load_backend(self):
        """
        This method loads the configuration file if specified and
        also connects to the backend, initialising the pool on the go
        """
        if self.tryton_configfile is not None:
            warnings.warn(DeprecationWarning(
                'TRYTON_CONFIG configuration will be deprecated in future.'
            ))
            CONFIG.update_etc(self.tryton_configfile)

        CONFIG.set_timezone()

        register_classes()

        # Load and initialise pool
        Database = backend.get('Database')
        self._database = Database(self.database_name).connect()
        self._pool = Pool(self.database_name)
        self._pool.init()

    @property
    def pool(self):
        """
        A proxy to the _pool
        """
        return self._pool

    @property
    def database(self):
        """
        Return connection to Database backend of tryton
        """
        return self._database

    @root_transaction_if_required
    def add_ctx_processors_from_db(self):
        """
        Adds template context processors registers with the model
        nereid.template.context_processor
        """
        ctx_processor_obj = self.pool.get('nereid.template.context_processor')

        db_ctx_processors = ctx_processor_obj.get_processors()
        if None in db_ctx_processors:
            self.template_context_processors[None].extend(
                db_ctx_processors.pop(None)
            )
        self.template_context_processors.update(db_ctx_processors)

    def request_context(self, environ):
        return RequestContext(self, environ)

    @root_transaction_if_required
    def create_url_adapter(self, request):
        """Creates a URL adapter for the given request.  The URL adapter
        is created at a point where the request context is not yet set up
        so the request is passed explicitly.

        """
        if request is not None:

            Website = Pool().get('nereid.website')

            website = Website.get_from_host(request.host)
            rv = website.get_url_adapter(self).bind_to_environ(
                request.environ,
                server_name=self.config['SERVER_NAME']
            )
            return rv

    def dispatch_request(self):
        """
        Does the request dispatching.  Matches the URL and returns the
        return value of the view or error handler.  This does not have to
        be a response object.
        """
        DatabaseOperationalError = backend.get('DatabaseOperationalError')

        req = _request_ctx_stack.top.request
        if req.routing_exception is not None:
            self.raise_routing_exception(req)

        rule = req.url_rule
        # if we provide automatic options for this URL and the
        # request came with the OPTIONS method, reply automatically
        if getattr(rule, 'provide_automatic_options', False) \
           and req.method == 'OPTIONS':
            return self.make_default_options_response()

        Cache.clean(self.database_name)

        with Transaction().start(self.database_name, 0, readonly=True):
            Website = Pool().get('nereid.website')
            website = Website.get_from_host(req.host)

            user, company = website.application_user.id, website.company.id

        for count in range(int(CONFIG['retry']), -1, -1):
            with Transaction().start(
                    self.database_name,
                    user, context={'company': company}) as txn:
                try:
                    transaction_start.send(self)
                    rv = self._dispatch_request(req)
                    txn.cursor.commit()
                except DatabaseOperationalError:
                    # Strict transaction handling may cause this.
                    # Rollback and Retry the whole transaction if within
                    # max retries, or raise exception and quit.
                    txn.cursor.rollback()
                    if count:
                        continue
                    raise
                except Exception:
                    # Rollback and raise any other exception
                    txn.cursor.rollback()
                    raise
                else:
                    return rv
                finally:
                    transaction_stop.send(self)

    def _dispatch_request(self, req):
        """
        Implement the nereid specific _dispatch
        """

        language = 'en_US'
        if req.nereid_website:
            # If this is a request specific to a website
            # then take the locale from the website
            language = req.nereid_locale.language.code

        with Transaction().set_context(language=language):

            # pop locale if specified in the view_args
            req.view_args.pop('locale', None)

            # otherwise dispatch to the handler for that endpoint
            if req.url_rule.endpoint in self.view_functions:
                meth = self.view_functions[req.url_rule.endpoint]
            else:
                model, method = req.url_rule.endpoint.rsplit('.', 1)
                meth = getattr(Pool().get(model), method)

            if not hasattr(meth, 'im_self') or meth.im_self:
                # static or class method
                result = meth(**req.view_args)
            else:
                # instance method, extract active_id from the url
                # arguments and pass the model instance as first argument
                model = Pool().get(req.url_rule.endpoint.rsplit('.', 1)[0])
                i = model(req.view_args.pop('active_id'))
                result = meth(i, **req.view_args)

            if isinstance(result, LazyRenderer):
                result = (
                    unicode(result), result.status, result.headers
                )

            return result

    def create_jinja_environment(self):
        """
        Extend the default jinja environment that is created. Also
        the environment returned here should be specific to the current
        website.
        """
        rv = super(Nereid, self).create_jinja_environment()

        # Add the custom extensions specific to nereid
        rv.add_extension('jinja2.ext.i18n')
        rv.add_extension('nereid.templating.FragmentCacheExtension')

        rv.filters.update(**NEREID_TEMPLATE_FILTERS)

        # add the locale sensitive url_for of nereid
        rv.globals.update(url_for=url_for)

        if self.cache:
            # Setup the bytecode cache
            rv.bytecode_cache = MemcachedBytecodeCache(self.cache)
            # Setup for fragmented caching
            rv.fragment_cache = self.cache
            rv.fragment_cache_prefix = self.cache_key_prefix + "-frag-"

        # Install the gettext callables
        from .contrib.locale import TrytonTranslations
        translations = TrytonTranslations(module=None, ttype='nereid_template')
        rv.install_gettext_callables(
            translations.gettext, translations.ngettext
        )
        return rv

    @locked_cached_property
    def jinja_loader(self):
        """
        Creates the loader for the Jinja2 Environment
        """
        return ModuleTemplateLoader(
            self.database_name, searchpath=self.template_folder,
        )

    def select_jinja_autoescape(self, filename):
        """
        Returns `True` if autoescaping should be active for the given
        template name.
        """
        if filename is None:
            return False
        if filename.endswith(('.jinja',)):
            return True
        return super(Nereid, self).select_jinja_autoescape(filename)

    @property
    def guest_user(self):
        warnings.warn(DeprecationWarning(
            "guest_user as an attribute will be deprecated.\n"
            "Use request.nereid_website.guest_user.id instead"
        ))
        from .globals import request
        return request.nereid_website.guest_user.id

########NEW FILE########
__FILENAME__ = caching
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from functools import wraps
from hashlib import md5
import inspect
from warnings import warn
warn(DeprecationWarning("This API will be deprecated"))

from flask.globals import current_app


class Cache(object):
    """
    Implements a Cache with helper utils

    This is implemented using __slots__ based optimisation
    and reimplements most arguments already in the application.
    However, this will increase performance as cache related
    operations will then not depend on a dictionary lookup, which
    is one of the most expensive python operations.

    :param app: Instance of application. Values for cache are
                fetched from there
    """
    __slots__ = tuple()

    def add(self, key, value, timeout=None):
        "Proxy function for internal cache object."
        return current_app.cache.add(key, value, timeout)

    def clear(self):
        "Proxy function for internal cache object."
        return current_app.cache.clear()

    def dec(self, key, delta=1):
        "Proxy function for internal cache object."
        return current_app.cache.dec(key, delta)

    def delete(self, key):
        "Proxy function for internal cache object."
        return current_app.cache.delete(key)

    def delete_many(self, *keys):
        "Proxy function for internal cache object."
        return current_app.cache.delete_many(*keys)

    def get(self, key):
        "Proxy function for internal cache object."
        return current_app.cache.get(key)

    def get_dict(self, *keys):
        "Proxy function for internal cache object."
        return current_app.cache.get_dict(*keys)

    def get_many(self, *keys):
        "Proxy function for internal cache object."
        return current_app.cache.get_many(*keys)

    def inc(self, key, delta=1):
        "Proxy function for internal cache object."
        return current_app.cache.inc(key, delta)

    def set(self, key, value, timeout=None):
        "Proxy function for internal cache object."
        return current_app.cache.set(key, value, timeout)

    def set_many(self, mapping, timeout=None):
        "Proxy function for internal cache object."
        return current_app.cache.set_many(mapping, timeout)

    def cache(self, key, timeout=None, unless=None):
        """
        Decorator to use as caching function

        :copyright: (c) 2010 by Thadeus Burgess.

        :param timeout: Time in seconds to retain cached value
        :param key_prefix: Key to use for cache.
        :param unless: Callable for truth testing. If provided, the
                       callable is called with no arguments and if true,
                       caching operation will be cancelled.
        """
        def decorator(function):
            @wraps(function)
            def wrapper(*args, **kwargs):
                if callable(unless) and unless() is True:
                    return function(*args, **kwargs)

                rv = current_app.cache.get(key)

                if rv is None:
                    rv = function(*args, **kwargs)
                    current_app.cache.set(key, rv, timeout)
                return rv
            return wrapper
        return decorator

    def memoize(self, key, timeout=None, unless=None):
        """
        Decorator to use as caching function but also evaluates
        the arguments

        :copyright: (c) 2010 by Thadeus Burgess.

        :param timeout: Time in seconds to retain cached value
        :param key_prefix: Key to use for cache.
        :param unless: Callable for truth testing. If provided, the
                       callable is called with no arguments and if true,
                       caching operation will be cancelled
        """
        def decorator(function):
            arg_names = inspect.getargspec(function)[0]

            @wraps(function)
            def wrapper(*args, **kwargs):
                if callable(unless) and unless() is True:
                    return function(*args, **kwargs)

                kwargs_origin = kwargs.copy()
                kwargs.update(dict(zip(arg_names, args)))
                kwargs = kwargs.items()
                kwargs.sort()

                hash = md5()
                hash.update(key + repr(kwargs))
                cache_key = hash.hexdigest()

                rv = current_app.cache.get(cache_key)

                if rv is None:
                    rv = function(*args, **kwargs_origin)
                    current_app.cache.set(cache_key, rv, timeout)
                return rv
            return wrapper
        return decorator

    def memoize_method(self, key, timeout=None, unless=None):
        """
        Decorator to use as caching function but also evaluates
        the arguments

        :copyright: (c) 2010 by Thadeus Burgess.

        :param timeout: Time in seconds to retain cached value
        :param key_prefix: Key to use for cache.
        :param unless: Callable for truth testing. If provided, the
                       callable is called with no arguments and if true,
                       caching operation will be cancelled
        """
        def decorator(function):
            arg_names = inspect.getargspec(function)[0]

            @wraps(function)
            def wrapper(*args, **kwargs):
                if callable(unless) and unless() is True:
                    return function(*args, **kwargs)

                kwargs_origin = kwargs.copy()
                kwargs.update(dict(zip(arg_names, args)))
                kwargs.pop('self')
                kwargs = kwargs.items()
                kwargs.sort()

                hash = md5()
                hash.update(key + repr(args[1:]) + repr(kwargs))
                cache_key = hash.hexdigest()

                rv = current_app.cache.get(cache_key)

                if rv is None:
                    rv = function(*args, **kwargs_origin)
                    current_app.cache.set(cache_key, rv, timeout)
                return rv
            return wrapper
        return decorator

########NEW FILE########
__FILENAME__ = config
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import imp

from flask.config import ConfigAttribute, Config as ConfigBase  # noqa


class Config(ConfigBase):
    "Configuration without the root_path"

    def __init__(self, defaults=None):
        dict.__init__(self, defaults or {})

    def from_pyfile(self, filename):
        """
        Updates the values in the config from a Python file.  This function
        behaves as if the file was imported as module with the
        :meth:`from_object` function.

        :param filename: the filename of the config.  This can either be an
                         absolute filename or a filename relative to the
                         root path.
        """
        d = imp.new_module('config')
        d.__file__ = filename
        try:
            execfile(filename, d.__dict__)
        except IOError, e:
            e.strerror = 'Unable to load configuration file (%s)' % e.strerror
            raise
        self.from_object(d)

########NEW FILE########
__FILENAME__ = locale
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import gettext

import flask.ext.babel
from speaklater import is_lazy_string, make_lazy_string
from flask.ext.babel import Babel  # noqa
from babel import Locale
from pytz import timezone
from nereid.globals import _request_ctx_stack
from trytond.pool import Pool
from trytond.transaction import Transaction


class TrytonTranslations(gettext.NullTranslations, object):
    """
    An extended translation catalog class that uses tryton's
    IRTranslation system.

    The ttype in tryton ir.translation works more like a message domain and
    hence the domain in the catalog represents one of the ttypes introduced
    by nereid.

    .. note::

        The ir.translation module does not have the capability to handle
        ngettext well as there is no option to have multiple strings. The
        extraction system will create each message separately.
    """

    def __init__(self, module, ttype='nereid'):
        self.module = module
        self.plural = lambda n: int(n != 1)
        self.ttype = ttype
        super(TrytonTranslations, self).__init__(fp=None)

    def ugettext(self, message):
        """Translates a string with the current locale
        ::

            gettext(u'Hello World!')
        """
        IRTranslation = Pool().get('ir.translation')

        rv = IRTranslation.get_translation_4_nereid(
            self.module, self.ttype, Transaction().language, message
        )
        return (rv or message)

    def lazy_ugettext(self, message, **variables):
        """Translates a string with the current locale and passes in the
        given keyword arguments as mapping to a string formatting string.

        ::

            lazy_ugettext(u'Hello World!')
            lazy_ugettext(u'Hello %(name)s!', name='World')
        """
        return self.ugettext(message) % variables

    def ungettext(self, singular, plural, n, **variables):
        """
        Translates a string with the current locale
        """
        IRTranslation = Pool().get('ir.translation')

        if self.plural(n):
            message = plural
        else:
            message = singular
        rv = IRTranslation.get_translation_4_nereid(
            self.module, self.ttype, Transaction().language, message
        )
        return (rv or message)

    def lazy_ungettext(self, singular, plural, n, **variables):
        """Translates a string with the current locale and passes in the
        given keyword arguments as mapping to a string formatting string.
        The `num` parameter is used to dispatch between singular and various
        plural forms of the message.  It is available in the format string
        as ``%(num)d`` or ``%(num)s``.  The source language should be
        English or a similar language which only has one plural form.

        ::

            lazy_ungettext(u'%(num)d Apple', u'%(num)d Apples', num=len(apples))
        """
        variables.setdefault('num', n)
        return self.ugettext(
            self.ungettext(singular, plural, n)
        ) % variables

    gettext = ugettext
    ngettext = ungettext


def get_translations():
    """
    Returns the correct gettext translations that should be used for
    this request.  This will never fail and return a dummy translation
    object if used outside of the request or if a translation cannot be
    found.
    """
    ctx = _request_ctx_stack.top
    if ctx is None:
        return None
    translations = getattr(ctx, 'babel_translations', None)
    if translations is None:
        translations = TrytonTranslations(module=None, ttype='nereid_template')
        ctx.babel_translations = translations
    return translations


flask.ext.babel.get_translations = get_translations


def get_locale():
    """
    Returns the locale that should be used for this request as
    `babel.Locale` object.  This returns `None` if used outside of
    a request.
    """
    ctx = _request_ctx_stack.top
    if ctx is None:
        return None
    locale = getattr(ctx, 'babel_locale', None)

    if locale is None:
        babel = ctx.app.extensions['babel']
        if babel.locale_selector_func is None:
            rv = ctx.request.nereid_language.code
        else:
            rv = babel.locale_selector_func()

        if rv is None:
            locale = babel.default_locale
        else:
            locale = Locale.parse(rv)
        ctx.babel_locale = locale
    return locale

flask.ext.babel.get_locale = get_locale


def get_timezone():
    """
    Returns the timezone that should be used for this request as
    `pytz.timezone` object.  This returns `None` if used outside of
    a request.
    """
    ctx = _request_ctx_stack.top
    tzinfo = getattr(ctx, 'babel_tzinfo', None)
    if tzinfo is None:
        babel = ctx.app.extensions['babel']
        if babel.timezone_selector_func is None:
            tzinfo = ctx.request.nereid_website.timezone
            if ctx.request.nereid_user.timezone:
                tzinfo = timezone(ctx.request.nereid_user.timezone)
        else:
            rv = babel.timezone_selector_func()
            if rv is None:
                tzinfo = babel.default_timezone
            else:
                if isinstance(rv, basestring):
                    tzinfo = timezone(rv)
                else:
                    tzinfo = rv
        ctx.babel_tzinfo = tzinfo
    return tzinfo

flask.ext.babel.get_timezone = get_timezone


def make_lazy_gettext(module):
    """
    Given a module name, return a lazy gettext function which is
    lazily evaluated.

    A typical usage pattern would be::

        from nereid.contrib.i18n import make_lazy_gettext

        _ = make_lazy_gettext('module_name')

    """
    def lazy_gettext(string, **variables):
        if is_lazy_string(string):
            return string
        translations = TrytonTranslations(module, 'nereid')
        return make_lazy_string(
            translations.lazy_ugettext, string, **variables
        )
    return lazy_gettext


def make_lazy_ngettext(module):
    """
    Given a module name, return a lazy gettext function which is
    lazily evaluated.

    A typical usage pattern would be::

        from nereid.contrib.i18n import make_lazy_gettext

        ngettext = make_lazy_ngettext('module_name')

    """
    def lazy_gettext(singular, plural, number, **variables):
        translations = TrytonTranslations(module, 'nereid')
        return make_lazy_string(
            translations.lazy_ungettext, singular, plural, number, **variables
        )
    return lazy_gettext

########NEW FILE########
__FILENAME__ = pagination
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from math import ceil
from werkzeug.utils import cached_property


class BasePagination(object):
    """
    General purpose paginator for doing pagination

    With an empty dataset assert the attributes
    >>> p = Pagination(1, 3, [])
    >>> p.count
    0
    >>> p.pages
    0
    >>> p.begin_count
    0
    >>> p.end_count
    0

    Test with a range(1, 10)
    >>> p = Pagination(1, 3, range(1, 10))
    >>> p.count
    9
    >>> p.all_items()
    [1, 2, 3, 4, 5, 6, 7, 8, 9]
    >>> p.pages
    3
    >>> p.begin_count
    1
    >>> p.end_count
    3

    """

    def __init__(self, page, per_page, data=None):
        """
        :param per_page: Items per page
        :param page: The page to be displayed
        :param data: The data table
        """
        self.per_page = per_page
        self.page = page
        self.data = data if data is not None else []

    @property
    def count(self):
        "Returns the count of data"
        return len(self.data)

    def all_items(self):
        """Returns complete set of items"""
        return self.data

    def items(self):
        """Returns the list of items in current page
        """
        return self.data[self.offset:self.offset + self.per_page]

    def __iter__(self):
        for item in self.items():
            yield item

    def __len__(self):
        return self.count

    def serialize(self):
        return {
            "count": self.count,
            "pages": self.pages,
            "page": self.page,
            "per_page": self.per_page,
            "items": self.items(),
        }

    @property
    def prev(self):
        """Returns a :class:`Pagination` object for the previous page."""
        return Pagination(self.page - 1, self.per_page, self.data)

    def next(self):
        """Returns a :class:`Pagination` object for the next page."""
        return Pagination(self.page + 1, self.per_page, self.data)

    #: Attributes below this may not require modifications in general cases

    def iter_pages(
            self, left_edge=2, left_current=2, right_current=2, right_edge=2
    ):
        """
        Iterates over the page numbers in the pagination.  The four
        parameters control the thresholds how many numbers should be produced
        from the sides.  Skipped page numbers are represented as `None`.
        This is how you could render such a pagination in the templates:

        .. sourcecode:: html+jinja

            {% macro render_pagination(pagination, endpoint) %}
                <div class=pagination>
                {%- for page in pagination.iter_pages() %}
                    {% if page %}
                        {% if page != pagination.page %}
                            <a href="{{ url_for(endpoint, page=page) }}">
                              {{ page }}
                            </a>
                        {% else %}
                            <strong>{{ page }}</strong>
                        {% endif %}
                    {% else %}
                        <span class=ellipsis>â€¦</span>
                    {% endif %}
                {%- endfor %}
                </div>
            {% endmacro %}
        """
        last = 0
        for num in xrange(1, self.pages + 1):
            if num <= left_edge or \
                (num > self.page - left_current - 1 and
                    num < self.page + right_current) or \
                    num > self.pages - right_edge:
                if last + 1 != num:
                    yield None
                yield num
                last = num

    offset = property(lambda self: (self.page - 1) * self.per_page)

    prev_num = property(lambda self: self.page - 1)
    has_prev = property(lambda self: self.page > 1)

    next_num = property(lambda self: self.page + 1)
    has_next = property(lambda self: self.page < self.pages)

    pages = property(lambda self: int(ceil(self.count / float(self.per_page))))

    begin_count = property(lambda self: min([
        ((self.page - 1) * self.per_page) + 1,
        self.count]))
    end_count = property(lambda self: min(
        self.begin_count + self.per_page - 1, self.count))


class Pagination(BasePagination):
    """
    General purpose paginator for doing pagination which can be used by
    passing a search domain .Remember that this means the query will be built
    and executed and passed on which could be slower than writing native SQL
    queries. While this fits into most use cases, if you would like to use
    a SQL query rather than a domain use :class:QueryPagination instead
    """

    # The counting of all possible records can be really expensive if you
    # have too many records and the selectivity of the query is low. For
    # example -  a query to display all products in a website would be quick
    # in displaying the products but slow in building the navigation. So in
    # cases where this could be frequent, the value of count may be cached and
    # assigned to this variable
    _count = None

    def __init__(self, obj, domain, page, per_page, order=None):
        """
        :param obj: The object itself. pass self within tryton object
        :param domain: Domain for search in tryton
        :param per_page: Items per page
        :param page: The page to be displayed
        """
        self.obj = obj
        self.domain = domain
        self.order = order
        super(Pagination, self).__init__(page, per_page)

    @cached_property
    def count(self):
        """
        Returns the count of entries
        """
        if self.ids_domain():
            return len(self.domain[0][2])
        if self._count is not None:
            return self._count
        return self.obj.search(domain=self.domain, count=True)

    def all_items(self):
        """Returns complete set of items"""
        if self.ids_domain():
            ids = self.domain[0][2]
        else:
            ids = self.obj.search(self.domain)
        return self.obj.browse(ids)

    def ids_domain(self):
        """
        Returns True if the domain has only IDs and can skip SQL fetch
        to directly browse the records. Else a False is returned
        """
        return (len(self.domain) == 1) and \
            (self.domain[0][0] == 'id') and \
            (self.domain[0][1] == 'in') and \
            (self.order is None)

    def serialize(self, purpose=None):
        rv = super(Pagination, self).serialize()
        if hasattr(self.obj, 'serialize'):
            rv['items'] = [item.serialize(purpose) for item in self.items()]
        elif hasattr(self.obj, '_json'):
            # older style _json methods
            rv['items'] = [item._json() for item in self.items()]
        else:
            rv['items'] = [
                {
                    'id': item.id,
                    'rec_name': item.rec_name,
                } for item in self.items()
            ]
        return rv

    def items(self):
        """
        Returns the list of browse records of items in the page
        """
        if self.ids_domain():
            ids = self.domain[0][2][self.offset:self.offset + self.per_page]
        else:
            ids = self.obj.search(
                self.domain, offset=self.offset, limit=self.per_page,
                order=self.order
            )
        return self.obj.browse(ids)

    @property
    def prev(self, error_out=False):
        """Returns a :class:`Pagination` object for the previous page."""
        return self.obj.paginate(self.page - 1, self.per_page, error_out)

    def next(self, error_out=False):
        """Returns a :class:`Pagination` object for the next page."""
        return self.obj.paginate(self.page + 1, self.per_page, error_out)


class QueryPagination(BasePagination):
    """A fast implementation of pagination which uses a SQL query for
    generating the IDS and hence the pagination"""

    def __init__(self, obj, search_query, count_query, page, per_page):
        """
        :param search_query: Query to be used for search. It must not include
                             an OFFSET or LIMIT as they would be automatically
                             added to the query
        :param count_query: Query to be used to get the count of the pagination
                            use a query like `SELECT 1234 AS id` for a query
                            where you do not want to manipulate the count
        :param per_page: Items per page
        :param page: The page to be displayed
        """
        self.obj = obj
        self.search_query = search_query
        self.count_query = count_query
        super(QueryPagination, self).__init__(page, per_page)

    @cached_property
    def count(self):
        "Return the count of the Items"
        from trytond.transaction import Transaction
        with Transaction().new_cursor() as transaction:
            transaction.cursor.execute(self.count_query)
            return transaction.cursor.fetchone()[0]

    def all_items(self):
        """Returns complete set of items"""
        from trytond.transaction import Transaction
        with Transaction().new_cursor() as transaction:
            transaction.cursor.execute(self.search_query)
            rv = [x[0] for x in transaction.cursor.fetchall()]
        return self.obj.browse(rv)

    def items(self):
        """
        Returns the list of browse records of items in the page
        """
        from trytond.transaction import Transaction
        limit_string = ' LIMIT %d' % self.per_page
        offset_string = ' OFFSET %d' % self.offset
        with Transaction().new_cursor() as transaction:
            transaction.cursor.execute(''.join([
                self.search_query, limit_string, offset_string
            ]))
            rv = [x[0] for x in transaction.cursor.fetchall()]
        return self.obj.browse(rv)

########NEW FILE########
__FILENAME__ = sitemap
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from math import ceil
from tempfile import NamedTemporaryFile

import pytz
from lxml import etree
from lxml.builder import E
from nereid.helpers import send_file, url_for
from werkzeug.utils import cached_property


class SitemapIndex(object):
    """
    A collection of Sitemap objects

    To add a sitemap index to one of your objects do the following:

    class Product(ModelSQL, ModelView):
        __name__ = "product.product"

        @classmethod
        def sitemap_index(cls):
            index = SitemapIndex(
                cls, cls.search_domain
                )
            return index.render()

        @classmethod
        def sitemap(cls, page):
            sitemap_section = SitemapSection(
                cls, cls.search_domain, page
                )
            return sitemap_section.render()

        def get_absolute_url(self, **kwargs):
            "Return the full_path of the current object"
            return url_for('product.product.render',
                uri=self.uri, **kwargs)
    """
    #: Batch Size: The number of URLs per sitemap page
    batch_size = 1000

    def __init__(self, model, domain, cache_timeout=60 * 60 * 24):
        """
        A collection of SitemapSection objects which are automatically
        generated based on the

        :param collection: An iterable of tuples with the name of the model
                           and the domain. Example

        ...>>> product_obj = pool.get('product.product')
        ...>>> sitemap = Sitemap(
        ...        product_obj, [('displayed_on_eshop', '=', True)])
        """
        self.model = model
        self.domain = domain
        self.cache_timeout = cache_timeout

    def render(self):
        with NamedTemporaryFile(suffix=".xml") as buffer:
            buffer.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            buffer.write('<sitemapindex ')
            buffer.write(
                'xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">\n'
            )
            for page in xrange(1, self.page_count + 1):
                loc = '<sitemap><loc>%s</loc></sitemap>\n'
                method = '%s.sitemap' % self.model.__name__
                buffer.write(loc % url_for(method, page=page, _external=True))
            buffer.write('</sitemapindex>')
            return send_file(buffer.name, cache_timeout=self.cache_timeout)

    @cached_property
    def count(self):
        """
        Returns the number of items of the object
        """
        max_id = self.model.search(
            self.domain, order=[('id', 'DESC')], limit=1
        )
        return max_id and max_id[0].id or 0

    @cached_property
    def page_count(self):
        """
        Returns the number of pages that will exist for the sitemap index
        >>> int(ceil(1.00/50000.00))
        1
        >>> int(ceil(50000.00/50000.00))
        1
        >>> int(ceil(50001.00/50000.00))
        2
        >>> int(ceil(100000.00/50000.00))
        2
        >>> int(ceil(100001.00/50000.00))
        3
        """
        return int(ceil(float(self.count) / float(self.batch_size)))


class SitemapSection(object):
    """
    A SitemapSection class is a simple Python class that represents a
    "section" of  entries in your sitemap. For example, one Sitemap class could
    represent all the entries of your weblog, while another could represent all
    of the events in your events calendar.

    In the simplest case, all these sections get lumped together into one
    `sitemap.xml`, but it's also possible to use the framework to generate a
    sitemap index that references individual sitemap files, one per section.

    The implementation though inspired by the Django project, is heavily
    influenced around the design of the Tryton project.


    How to use::

        Step 1: Create a method name sitemap for each model that needs to use
                a sitemap. Example:

                class Product(ModelSQL, ModelView):
                    __name__ = "product.product"

                    @classmethod
                    def sitemap(cls, page):
                        sitemap_section = SitemapSection(
                            cls, cls.search_domain, page
                            )
                        return sitemap_section.render()

                    def get_absolute_url(self, **kwargs):
                        "Return the full_path of the current object"
                        return url_for('product.product.render',
                            uri=self.uri, **kwargs)


    :param model: The Tryton model/object from which the pagination needs to
                  be generated. Passing `self` from the calling object's method
                  would be the usual way you will have to pass this argument
    :param domain: The domain expression which should be searched against in
                   the model
    :param page: The page of the sitemap.
    """

    #: The timeout in seconds for the headers, which would be respceted by
    #: intermediate cache servers.
    cache_timeout = 60 * 60 * 24

    #: Indicates how frequently the page is likely to change. This value
    #: provides general information to search engines and may not correlate
    #: exactly to how often they crawl the page. Valid values are:
    #:
    #:     always
    #:     hourly
    #:     daily
    #:     weekly
    #:     monthly
    #:     yearly
    #:     never
    #:
    #: The value "always" should be used to describe documents that change
    #: each time they are accessed. The value "never" should be used to
    #: describe archived URLs. Please note that the value of this tag is
    #: considered a hint and not a command.
    #:
    #: Even though search engine crawlers may consider this information when
    #: making decisions, they may crawl pages marked "hourly" less frequently
    #: than that, and they may crawl pages marked "yearly" more frequently
    #: than that. Crawlers may periodically crawl pages marked "never" so that
    #: they can handle unexpected changes to those pages.
    #:
    #: Defaults to 'never'
    changefreq = 'never'

    #: The priority of this URL relative to other URLs on your site. Valid
    #: values range from 0.0 to 1.0. This value does not affect how your pages
    #: are compared to pages on other sitesÃ¢â‚¬â€it only lets the search engines
    #:  know which pages you deem most important for the crawlers.
    #:
    #: A default priority of 0.5 is assumed by the protocol.
    #:
    #: Please note that the priority you assign to a page is not likely to
    #: influence the position of your URLs in a search engine's result pages.
    #: Search engines may use this information when selecting between URLs on
    #: the same site, so you can use this tag to increase the likelihood that
    #: your most important pages are present in a search index.
    #:
    #: Also, please note that assigning a high priority to all of the URLs on
    #: your site is not likely to help you. Since the priority is relative, it
    #: is only used to select between URLs on your site.
    priority = 0.5

    #: It is really memory intensive to call complete records and generate site
    #: maps from them if the collection is large. Hence the queries may be
    #: divided into batches of this size
    batch_size = 1000

    min_id = property(lambda self: (self.page - 1) * self.batch_size)
    max_id = property(lambda self: self.min_id + self.batch_size)

    def __init__(self, model, domain, page):
        self.model = model
        self.domain = domain
        self.page = page

    def __iter__(self):
        """
        The default implementation searches for the domain and finds the
        ids and generates xml for it
        """
        domain = [('id', '>', self.min_id), ('id', '<=', self.max_id)]
        domain = domain + self.domain

        ids = self.model.search(domain)
        for id in ids:
            record = self.model(id)
            yield(self.get_url_xml(record))
            del record

    def render(self):
        """
        This method writes the sitemap directly into the response as a
        stream using the ResponseStream
        """
        with NamedTemporaryFile(suffix=".xml") as buffer:
            buffer.write('<?xml version="1.0" encoding="UTF-8"?>\n')
            buffer.write(
                '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">'
                '\n'
            )
            for line in self:
                buffer.write(etree.tostring(line) + u'\n')
            buffer.write('</urlset>')
            return send_file(buffer.name, cache_timeout=self.cache_timeout)

    def get_url_xml(self, item):
        """
        Returns the etree node for the specific item
        """
        return E(
            'url',
            E('loc', self.loc(item)),
            E('lastmod', self.lastmod(item)),
            E('changefreq', self.changefreq),
            E('priority', str(self.priority)),
        )

    def loc(self, item):
        """
        URL of the page. This URL must begin with the protocol
        (such as http) and end with a trailing slash, if the application
        requires it. This value must be less than 2,048 characters.

        The URL can probably be generated using url_for and with external
        as True to generate absolute URLs

        Default: returns the absolute url of the object

        :param item: Instance of the item.
        """
        return item.get_absolute_url(_external=True)

    def lastmod(self, item):
        """
        The date of last modification of the file. This date should be in
        W3C Datetime format. This format allows you to omit the time portion,
        if desired, and use YYYY-MM-DD. Note that this tag is separate from
        the If-Modified-Since (304) header the server can return, and
        search engines may use the information from both sources differently.

        The default implementation fetches the write_date of the record and
        returns it in the W3C Datetime format

        Note: This attribute is optional and ignored if value is None
        """
        timestamp = item.write_date or item.create_date
        timestamp_in_utc = pytz.utc.localize(timestamp)
        return timestamp_in_utc.isoformat()

########NEW FILE########
__FILENAME__ = ctx
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from flask.ctx import RequestContext as RequestContextBase
from flask.ctx import has_request_context  # noqa


class RequestContext(RequestContextBase):
    """
    The request context contains all request relevant information.  It is
    created at the beginning of the request and pushed to the
    `_request_ctx_stack` and removed at the end of it.  It will create the
    URL adapter and request object for the WSGI environment provided.
    """

    def __init__(self, app, environ, request=None):
        super(RequestContext, self).__init__(app, environ, request)
        self.transaction = None
        self.cache = app.cache

########NEW FILE########
__FILENAME__ = exceptions
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from werkzeug.exceptions import NotFound


class WebsiteNotFound(NotFound):
    description = 'The requested website was not found on the server.'

########NEW FILE########
__FILENAME__ = globals
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from flask.globals import (_request_ctx_stack, current_app,  # noqa
    request, session, g, LocalProxy, _find_app)
from flask.ext.login import current_user                     # noqa


def _find_cache():
    """
    The application context will be automatically handled by
    _find_app method in flask
    """
    app = _find_app()
    return app.cache

cache = LocalProxy(_find_cache)

########NEW FILE########
__FILENAME__ = helpers
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import os
import posixpath
import mimetypes
from time import time
from zlib import adler32
import re
import warnings
import unicodedata
from functools import wraps
from hashlib import md5

import trytond.modules
from trytond.transaction import Transaction
from trytond.config import CONFIG
from speaklater import is_lazy_string
from flask.helpers import (_PackageBoundObject, locked_cached_property,  # noqa
        get_flashed_messages, flash as _flash, url_for as flask_url_for)
from werkzeug import Headers, wrap_file, redirect, abort
from werkzeug.exceptions import NotFound
from flask.ext.login import login_required      # noqa

from .globals import current_app, request


_SLUGIFY_STRIP_RE = re.compile(r'[^\w\s-]')
_SLUGIFY_HYPHENATE_RE = re.compile(r'[-\s]+')


def url_for(endpoint, **values):
    """
    Generates a URL to the given endpoint with the method provided.
    The endpoint is relative to the active module if modules are in use.

    The functionality is documented in `flask.helpers.url_for`

    In addition to the arguments provided by flask, nereid allows the locale
    of the url to be generated to be specified using the locale attribute.
    The default value of locale is the locale of the current request.

    For example::

        url_for('nereid.website.home', locale='en-us')

    """
    if '_secure' in values and '_scheme' not in values:
        warnings.warn(
            "_secure argument will be deprecated in favor of _scheme",
            DeprecationWarning, stacklevel=2
        )
        values['_external'] = True
        values['_scheme'] = 'https'
        values.pop('_secure')

    if 'language' in values:
        warnings.warn(
            "language argument is deprecated in favor of locale",
            DeprecationWarning, stacklevel=2
        )

    if 'locale' not in values and request.nereid_website.locales:
        values['locale'] = request.nereid_locale.code

    return flask_url_for(endpoint, **values)


def secure(function):
    @wraps(function)
    def decorated_function(*args, **kwargs):
        if not request.is_secure:
            return redirect(request.url.replace('http://', 'https://'))
        else:
            return function(*args, **kwargs)
    return decorated_function


class permissions_required(object):
    """
    Decorator helper to check if the specified permissions
    rest with the user
    """
    def __init__(self, perm_all=None, perm_any=None):
        self.perm_all = frozenset(perm_all if perm_all else [])
        self.perm_any = frozenset(perm_any if perm_any else [])

    def __call__(self, function):
        @wraps(function)
        def wrapper(*args, **kwargs):
            if request.nereid_user.has_permissions(
                    self.perm_all, self.perm_any
            ):
                return function(*args, **kwargs)
            abort(403)
        return wrapper


def send_from_directory(directory, filename, **options):
    """
    Send a file from a given directory with :func:`send_file`.  This
    is a secure way to quickly expose static files from an upload folder
    or something similar.

    Example usage::

        def download_file(self, filename):
            return send_from_directory(app.config['UPLOAD_FOLDER'],
                                       filename, as_attachment=True)

    .. admonition:: Sending files and Performance

       It is strongly recommended to activate either `X-Sendfile` support in
       your webserver or (if no authentication happens) to tell the webserver
       to serve files for the given path on its own without calling into the
       web application for improved performance.

    :param directory: the directory where all the files are stored.
    :param filename: the filename relative to that directory to
                     download.
    :param options: optional keyword arguments that are directly
                    forwarded to :func:`send_file`.
    """
    filename = posixpath.normpath(filename)
    if filename.startswith(('/', '../')):
        raise NotFound()
    filename = os.path.join(directory, filename)
    if not os.path.isfile(filename):
        raise NotFound()
    return send_file(filename, conditional=True, **options)


def send_file(filename_or_fp, mimetype=None, as_attachment=False,
              attachment_filename=None, add_etags=True,
              cache_timeout=60 * 60 * 12, conditional=False):
    """
    Sends the contents of a file to the client.  This will use the
    most efficient method available and configured.  By default it will
    try to use the WSGI server's file_wrapper support.  Alternatively
    you can set the application's :attr:`~Flask.use_x_sendfile` attribute
    to ``True`` to directly emit an `X-Sendfile` header.  This however
    requires support of the underlying webserver for `X-Sendfile`.

    By default it will try to guess the mimetype for you, but you can
    also explicitly provide one.  For extra security you probably want
    to sent certain files as attachment (HTML for instance).  The mimetype
    guessing requires a `filename` or an `attachment_filename` to be
    provided.

    Please never pass filenames to this function from user sources without
    checking them first.  Something like this is usually sufficient to
    avoid security problems::

        if '..' in filename or filename.startswith('/'):
            abort(404)

    :param filename_or_fp: the filename of the file to send.  This is
                           relative to the :attr:`~nereid.root_path` if a
                           relative path is specified.
                           Alternatively a file object might be provided
                           in which case `X-Sendfile` might not work and
                           fall back to the traditional method.  Make sure
                           that the file pointer is positioned at the start
                           of data to send before calling :func:`send_file`.
    :param mimetype: the mimetype of the file if provided, otherwise
                     auto detection happens.
    :param as_attachment: set to `True` if you want to send this file with
                          a ``Content-Disposition: attachment`` header.
    :param attachment_filename: the filename for the attachment if it
                                differs from the file's filename.
    :param add_etags: set to `False` to disable attaching of etags.
    :param conditional: set to `True` to enable conditional responses.
    :param cache_timeout: the timeout in seconds for the headers.
    """
    mtime = None
    if isinstance(filename_or_fp, basestring):
        filename = filename_or_fp
        file = None
    else:
        from warnings import warn
        file = filename_or_fp
        filename = getattr(file, 'name', None)

        # XXX: this behaviour is now deprecated because it was unreliable.
        # removed in Flask 1.0
        if not attachment_filename and not mimetype and \
                isinstance(filename, basestring):
            warn(
                DeprecationWarning(
                    'The filename support for file objects passed to '
                    'send_file is not deprecated. Pass an attach_filename '
                    'if you want mimetypes to be guessed.'
                ), stacklevel=2
            )
        if add_etags:
            warn(
                DeprecationWarning(
                    'In future flask releases etags will no longer be '
                    'generated for file objects passed to the send_file '
                    'function because this behaviour was unreliable. Pass '
                    'filenames instead if possible, otherwise attach an etag '
                    'yourself based on another value'
                ), stacklevel=2
            )

    if filename is not None:
        if not os.path.isabs(filename):
            filename = os.path.join(
                CONFIG['data_path'],
                current_app.database_name,
                filename)
    if mimetype is None and (filename or attachment_filename):
        mimetype = mimetypes.guess_type(filename or attachment_filename)[0]
    if mimetype is None:
        mimetype = 'application/octet-stream'

    headers = Headers()
    if as_attachment:
        if attachment_filename is None:
            if filename is None:
                raise TypeError('filename unavailable, required for '
                                'sending as attachment')
            attachment_filename = os.path.basename(filename)
        headers.add('Content-Disposition', 'attachment',
                    filename=attachment_filename)

    if current_app.use_x_sendfile and filename:
        if file is not None:
            file.close()
        headers['X-Sendfile'] = filename
        data = None
    else:
        if file is None:
            file = open(filename, 'rb')
            mtime = os.path.getmtime(filename)
        data = wrap_file(request.environ, file)

    rv = current_app.response_class(data, mimetype=mimetype, headers=headers,
                                    direct_passthrough=True)

    # if we know the file modification date, we can store it as the
    # current time to better support conditional requests.  Werkzeug
    # as of 0.6.1 will override this value however in the conditional
    # response with the current time.  This will be fixed in Werkzeug
    # with a new release, however many WSGI servers will still emit
    # a separate date header.
    if mtime is not None:
        rv.date = int(mtime)

    rv.cache_control.public = True
    if cache_timeout:
        rv.cache_control.max_age = cache_timeout
        rv.expires = int(time() + cache_timeout)

    if add_etags and filename is not None:
        rv.set_etag('nereid-%s-%s-%s' % (
            os.path.getmtime(filename),
            os.path.getsize(filename),
            adler32(filename) & 0xffffffff
        ))
        if conditional:
            rv = rv.make_conditional(request)
            # make sure we don't send x-sendfile for servers that
            # ignore the 304 status code for x-sendfile.
            if rv.status_code == 304:
                rv.headers.pop('x-sendfile', None)
    return rv


def slugify(value):
    """
    Normalizes string, converts to lowercase, removes non-alpha characters,
    and converts spaces to hyphens.

    From Django's "django/template/defaultfilters.py".

    Source : http://code.activestate.com/recipes/577257/ (r2)

    >>> slugify('Sharoon Thomas')
    u'sharoon-thomas'
    >>> slugify('Sharoon ThomÃ¥s')
    u'sharoon-thoms'
    >>> slugify(u'Sharoon ThomÃ¥s')
    u'sharoon-thomas'
    """
    if not isinstance(value, unicode):
        value = unicode(value, errors='ignore')
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')
    value = unicode(_SLUGIFY_STRIP_RE.sub('', value).strip().lower())
    return _SLUGIFY_HYPHENATE_RE.sub('-', value)


def _rst_to_html_filter(value):
    """
    Converts RST text to HTML
    ~~~~~~~~~~~~~~~~~~~~~~~~~
    This uses docutils, if the library is missing, then the
    original text is returned

    Loading to environment::
             from jinja2 import Environment
             env = Environment()
             env.filters['rst'] = rst_to_html
             template = env.from_string("Welcome {{name|rst}}")
             template.render(name="**Sharoon**")
    """
    try:
        from docutils import core
        parts = core.publish_parts(source=value, writer_name='html')
        return parts['body_pre_docinfo'] + parts['fragment']
    except Exception:
        return value


def key_from_list(list_of_args):
    """
    Builds a key from a list of arguments which could be used for caching
    The key s constructed as an md5 hash
    """
    hash = md5()
    hash.update(repr(list_of_args))
    return hash.hexdigest()


def get_website_from_host(http_host):
    """Try to find the website name from the HTTP_HOST name"""
    return http_host.split(':')[0]


def make_crumbs(browse_record, endpoint, add_home=True, max_depth=10,
                field_map_changes=None, root_ids=None):
    """
    Makes bread crumbs for a given browse record based on the field
    parent of the browse record

    :param browse_record: The browse record of the object from which upward
                          tracing of crumbs need to be done
    :param endpoint: The endpoint against which the urls have to be generated
    :param add_home: If provided will add home and home url as the first item
    :param max_depth: Maximum depth of the crumbs
    :param field_map_changes: A dictionary/list of key value pair (tuples) to
                              update the default field_map. Only the changing
                              entries need to be provided.
    :param root_ids: IDs of root nodes where the recursion to a parent node
                     will need to be stopped. If not specified the recursion
                     continues upto the max_depth. Expects a list or tuple of
                     ids.

    .. versionchanged:: 0.3
        Added root_ids
    """
    field_map = dict(
        parent_field='parent',
        uri_field='uri',
        title_field='title',
    )
    if field_map_changes is not None:
        field_map.update(field_map_changes)
    if root_ids is None:
        root_ids = tuple()

    def recurse(node, level=1):
        if level > max_depth or not node:
            return []
        data_pair = (
            url_for(endpoint, uri=getattr(node, field_map['uri_field'])),
            getattr(node, field_map['title_field'])
        )
        if node.id in root_ids:
            return [data_pair]
        else:
            return [data_pair] + recurse(
                getattr(node, field_map['parent_field']), level + 1
            )

    items = recurse(browse_record)

    if add_home:
        items.append((url_for('nereid.website.home'), 'Home'))

    # The bread crumb is now in reverse order with home at end, reverse it
    items.reverse()

    return items


def root_transaction_if_required(function):
    """
    Starts a root transaction if one is not there. This behavior is used when
    run from tests cases which manage the transaction on its own.
    """
    @wraps(function)
    def decorated_function(self, *args, **kwargs):

        transaction = None
        if Transaction().cursor is None:
            # Start transaction since cursor is None
            transaction = Transaction().start(
                self.database_name, 0, readonly=True
            )
        try:
            return function(self, *args, **kwargs)
        finally:
            if transaction is not None:
                Transaction().stop()

    return decorated_function


def flash(message, category='message'):
    """
    Lazy strings are no real strings so pickling them results in strange issues.
    Pickling cannot be avoided because of the way sessions work. Hence, this
    special flash function converts lazy strings to unicode content.

    .. versionadded:: 3.0.4.1

    :param message: the message to be flashed.
    :param category: the category for the message.  The following values
                     are recommended: ``'message'`` for any kind of message,
                     ``'error'`` for errors, ``'info'`` for information
                     messages and ``'warning'`` for warnings.  However any
                     kind of string can be used as category.
    """
    if is_lazy_string(message):
        message = unicode(message)
    return _flash(message, category)


def route(rule, **options):
    """Like :meth:`Flask.route` but for nereid.

    .. versionadded:: 3.0.7.0

    Unlike the implementation in flask and flask.blueprint route decorator does
    not require an existing nereid application or a blueprint instance. Instead
    the decorator adds an attribute to the method called `_url_rules`.

    .. code-block:: python
        :emphasize-lines: 1,7

        from nereid import route

        class Product:
            __name__ = 'product.product'

            @classmethod
            @route('/product/<uri>')
            def render_product(cls, uri):
                ...
                return 'Product Information'

    """
    def decorator(f):
        if not hasattr(f, '_url_rules'):
            f._url_rules = []
        f._url_rules.append((rule, options))
        return f
    return decorator


def get_version():
    """
    Return the version of nereid by looking up the version as read by the
    tryton module loader.
    """
    return trytond.modules.get_module_info('nereid')['version']

########NEW FILE########
__FILENAME__ = logging
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
# Flake8: noqa

from flask.logging import create_logger

########NEW FILE########
__FILENAME__ = routing
# -*- coding: utf-8 -*-
"""
    The host matching URL Map seems to be matching hosts well but fails in
    generating/building URLs when there are same endpoints.

    This patch makes strict host matching to ensure nothing skips host
    matching.

    Also see: https://github.com/mitsuhiko/werkzeug/issues/488

    :copyright: (c) 2014 by Openlabs Technologies & Consulting (P) Limited
    :license: BSD, see LICENSE for more details.
"""
from werkzeug import routing


class Map(routing.Map):
    def _partial_build(self, endpoint, values, method, append_unknown):
        """Helper for :meth:`build`.  Returns subdomain and path for the
        rule that accepts this endpoint, values and method.

        :internal:
        """
        # in case the method is none, try with the default method first
        if method is None:
            rv = self._partial_build(endpoint, values, self.default_method,
                                     append_unknown)
            if rv is not None:
                return rv

        host = self.map.host_matching and self.server_name or self.subdomain

        # default method did not match or a specific method is passed,
        # check all and go with first result.
        for rule in self.map._rules_by_endpoint.get(endpoint, ()):
            if rule.suitable_for(values, method, host):
                rv = rule.build(values, append_unknown)
                if rv is not None:
                    return rv


class Rule(routing.Rule):

    def suitable_for(self, values, method=None, host=None):
        """Check if the dict of values has enough data for url generation.

        :internal:
        """
        rv = super(Rule, self).build(values, method)

        # if host matching is enabled and the hosts dont match, then
        # this is not a suitable match
        if rv and self.map and self.map.host_matching and self.host != host:
            return False

        return rv

########NEW FILE########
__FILENAME__ = session
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from warnings import warn
warn(DeprecationWarning("Use nereid.sessions instead"))

from .sessions import (Session, NullSession, MemcachedSessionStore,  # noqa
    NereidSessionInterface)

########NEW FILE########
__FILENAME__ = sessions
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from datetime import datetime  # noqa

from flask.sessions import SessionInterface, SessionMixin
from werkzeug.contrib.sessions import Session as SessionBase, SessionStore
from flask.globals import current_app


class Session(SessionBase, SessionMixin):
    "Nereid Default Session Object"


class NullSession(Session):
    """
    Class used to generate nicer error messages if sessions are not
    available.  Will still allow read-only access to the empty session
    but fail on setting.
    """

    def _fail(self, *args, **kwargs):
        raise RuntimeError('the session is unavailable because no secret '
                           'key was set.  Set the secret_key on the '
                           'application to something unique and secret.')
    __setitem__ = __delitem__ = clear = pop = popitem = \
        update = setdefault = _fail
    del _fail


class MemcachedSessionStore(SessionStore):
    """
    Session store that stores session on memcached

    :param session_class: The session class to use.
    Defaults to :class:`Session`.
    """
    def __init__(self, session_class=Session):
        SessionStore.__init__(self, session_class)

    def save(self, session):
        """
        Updates the session
        """
        current_app.cache.set(
            session.sid, dict(session), 30 * 24 * 60 * 60
        )

    def delete(self, session):
        """
        Deletes the session
        """
        current_app.cache.delete(session.sid)

    def get(self, sid):
        """
        Returns session
        """
        if not self.is_valid_key(sid):
            return self.new()
        session_data = current_app.cache.get(sid)
        if session_data is None:
            session_data = {}
        return self.session_class(session_data, sid, False)

    def list(self):
        """
        Lists all sessions in the store
        """
        raise Exception("Not implemented yet")


class NereidSessionInterface(SessionInterface):
    """Session Management Class"""

    session_store = MemcachedSessionStore()
    null_session_class = NullSession

    def open_session(self, app, request):
        """
        Creates or opens a new session.

        :param request: an instance of :attr:`request_class`.
        """
        sid = request.cookies.get(app.session_cookie_name, None)
        if sid:
            return self.session_store.get(sid)
        else:
            return self.session_store.new()

    def save_session(self, app, session, response):
        """
        Saves the session if it needs updates.  For the default
        implementation, check :meth:`open_session`.

        :param session: the session to be saved
        :param response: an instance of :attr:`response_class`
        """
        if session.should_save:
            self.session_store.save(session)
            expires = self.get_expiration_time(app, session)
            domain = self.get_cookie_domain(app)

            from nereid.globals import request
            sid = request.cookies.get(app.session_cookie_name, None)
            if session.sid != sid:
                # The only information in the session is the sid, and the
                # only reason why a cookie should be set again is if that
                # has changed
                response.set_cookie(
                    app.session_cookie_name, session.sid,
                    expires=expires, httponly=False, domain=domain
                )

########NEW FILE########
__FILENAME__ = signals
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from flask.signals import (template_rendered, request_started,  # noqa
    request_finished, got_request_exception, _signals,
    request_tearing_down)


#: Login signal
#:  - This signal is triggered when a succesful login takes place
login = _signals.signal('login')

#: Failed Login
#:  - This signal is raised when a login fails
failed_login = _signals.signal('failed-login')

#: Logout
#: Triggered when a logout occurs
logout = _signals.signal('logout')

#: Registration
#: Triggered when a user registers
registration = _signals.signal('registration')


transaction_start = _signals.signal('nereid.transaction.start')
transaction_stop = _signals.signal('nereid.transaction.stop')

########NEW FILE########
__FILENAME__ = templating
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import os
import contextlib
from decimal import Decimal

from flask.templating import render_template as flask_render_template
from jinja2 import (BaseLoader, TemplateNotFound, nodes, Template,  # noqa
        ChoiceLoader, FileSystemLoader, BaseLoader)
from speaklater import _LazyString
from jinja2.ext import Extension
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.MIMEBase import MIMEBase
from email.header import Header
from email import Encoders, Charset
import trytond.tools as tools
from trytond.transaction import Transaction

from .globals import request, current_app  # noqa
from .helpers import _rst_to_html_filter, make_crumbs


# Override python's weird assumption that utf-8 text should be encoded with
# base64, and instead use quoted-printable (for both subject and body).  I
# can't figure out a way to specify QP (quoted-printable) instead of base64 in
# a way that doesn't modify global state. :-(
#
# wordeology.com/computer/how-to-send-good-unicode-email-with-python.html
Charset.add_charset('utf-8', Charset.QP, Charset.QP, 'utf-8')


class LazyRenderer(_LazyString):
    """
    A Lazy Rendering object which when called renders the template
    with the current context.

    >>> lazy_render_object = LazyRenderer('template.html', {'a': 1})

    You can change the context by setting values to the contex dictionary

    >>> lazy_render_object.context['a'] = 100

    You can also change the template(s) that should be rendered

    >>> lazy_render_object.template_name_or_list = "another-template.html"

    or even, change it into an iterable of templates

    >>> lazy_render_object.template_name_or_list = ['t1.html', 't2.html']

    The template can be rendered and serialized to unicode by calling

    >>> unicode(lazy_render_object)

    The status code or header can also be set on the lazy renderer

    >>> lazy_render_object.sattus = 201
    >>> lazy_render_object.headers['X-Some-Header'] = 'header value'

    .. note::

        If the template renders objects which depend on the application,
        request or a tryton transaction context (like an active record),
        the call must be made within those contexts.
    """

    __slots__ = ('template_name_or_list', 'context', 'headers', 'status')

    def __init__(self, template_name_or_list, context, headers=None):
        """
        :param template_name_or_list: the name of the template to be
                                      rendered, or an iterable with template
                                      names the first one existing will be
                                      rendered
        :param context: the variables that should be available in the
                        context of the template.
        """
        self.template_name_or_list = template_name_or_list
        self.context = context
        self.headers = {}
        self.status = 200

    @property
    def value(self):
        """
        Return the rendered template with the current context
        """
        return flask_render_template(
            self.template_name_or_list, **self.context
        )

    def __getstate__(self):
        return (
            self.template_name_or_list,
            self.context,
            self.headers,
            self.status,
        )

    def __setstate__(self, tup):
        self.template_name_or_list, self.context, \
                self.headers, self.status = tup


def render_template(template_name_or_list, **context):
    """
    Returns a lazy renderer object which renders a template from the
    template folder with the given context. The returned object is an instance
    of :class:`LazyRenderer` which has all magic methods implemented to make
    the object look as close as possible to an unicode object.

    LazyRenderer objects are automatically converted into response objects
    by the WSGI dispatcher into a rendered string by the make_response method.

    :param template_name_or_list: the name of the template to be
                                  rendered, or an iterable with template names
                                  the first one existing will be rendered
    :param context: the variables that should be available in the
                    context of the template.
    """
    if current_app.template_prefix_website_name and \
            isinstance(template_name_or_list, basestring):
        template_name_or_list = [
            '/'.join([request.nereid_website.name, template_name_or_list]),
            template_name_or_list
        ]
    return LazyRenderer(template_name_or_list, context)


def nereid_default_template_ctx_processor():
    """Add Decimal and make_crumbs to template context"""
    return dict(
        Decimal=Decimal,
        make_crumbs=make_crumbs,
    )


NEREID_TEMPLATE_FILTERS = dict(
    rst=_rst_to_html_filter,
)


class ModuleTemplateLoader(ChoiceLoader):
    '''
    This loader works like the `ChoiceLoader` and loads templates from
    a filesystem path (optional) followed by the template folders in the
    tryton module path. The template folders are ordered by the same
    order in which Tryton arranges modules based on the dependencies.

    The optional keyword argument searchpath could be used to specify
    local folder which contains templates which may override the templates
    bundled into nereid modules.

    :param database_name: The name of the Tryton database. This is required
                          since the modules installed in a database is what
                          matters and not the modules in the site-packages
    :param searchpath: Optional filesystem path where templates that override
                       templates bundled with nereid are located.

    .. versionadded:: 2.8.0.4

    .. versionchanged:: 2.8.0.6

        Does not accept prefixing of site name anymore
    '''
    def __init__(
            self, database_name=None, searchpath=None):
        self.database_name = database_name
        self.searchpath = searchpath
        self._loaders = None

    @property
    def loaders(self):
        '''
        Lazy load the loaders
        '''
        if self._loaders is None:
            self._loaders = []

            if not Transaction().cursor:
                contextmanager = Transaction().start(self.database_name, 0)
            else:
                contextmanager = contextlib.nested(
                    Transaction().set_user(0),
                    Transaction().reset_context()
                )
            with contextmanager:
                cursor = Transaction().cursor
                cursor.execute(
                    "SELECT name FROM ir_module_module "
                    "WHERE state = 'installed'"
                )
                installed_module_list = [name for (name,) in cursor.fetchall()]

            if self.searchpath is not None:
                self._loaders.append(FileSystemLoader(self.searchpath))

            # Look into the module graph and check if they have template
            # folders and if they do add them too
            from trytond.modules import create_graph, get_module_list, \
                MODULES_PATH, EGG_MODULES

            packages = list(create_graph(get_module_list())[0])[::-1]
            for package in packages:
                if package.name not in installed_module_list:
                    # If the module is not installed in the current database
                    # then don't load the templates either to be consistent
                    # with Tryton's modularity
                    continue
                if package.name in EGG_MODULES:
                    # trytond.tools has a good helper which allows resources to
                    # be loaded from the installed site packages. Just use it
                    # to load the tryton.cfg file which is guaranteed to exist
                    # and from it lookup the directory. From here, its just
                    # another searchpath for the loader.
                    f = tools.file_open(
                        os.path.join(package.name, 'tryton.cfg')
                    )
                    template_dir = os.path.join(
                        os.path.dirname(f.name), 'templates'
                    )
                else:
                    template_dir = os.path.join(
                        MODULES_PATH, package.name, 'templates'
                    )
                if os.path.isdir(template_dir):
                    # Add to FS Loader only if the folder exists
                    self._loaders.append(FileSystemLoader(template_dir))

        return self._loaders


class FragmentCacheExtension(Extension):
    # a set of names that trigger the extension.
    tags = set(['cache'])

    def __init__(self, environment):
        super(FragmentCacheExtension, self).__init__(environment)

        # add the defaults to the environment
        environment.extend(
            fragment_cache_prefix='',
            fragment_cache=None
        )

    def parse(self, parser):
        # the first token is the token that started the tag.  In our case
        # we only listen to ``'cache'`` so this will be a name token with
        # `cache` as value.  We get the line number so that we can give
        # that line number to the nodes we create by hand.
        lineno = parser.stream.next().lineno

        # now we parse a single expression that is used as cache key.
        args = [parser.parse_expression()]

        # if there is a comma, the user provided a timeout.  If not use
        # None as second parameter.
        if parser.stream.skip_if('comma'):
            args.append(parser.parse_expression())
        else:
            args.append(nodes.Const(None))

        # now we parse the body of the cache block up to `endcache` and
        # drop the needle (which would always be `endcache` in that case)
        body = parser.parse_statements(['name:endcache'], drop_needle=True)

        # now return a `CallBlock` node that calls our _cache_support
        # helper method on this extension.
        return nodes.CallBlock(self.call_method('_cache_support', args),
                               [], [], body).set_lineno(lineno)

    def _cache_support(self, name, timeout, caller):
        """Helper callback."""
        key = self.environment.fragment_cache_prefix + name

        # try to load the block from the cache
        # if there is no fragment in the cache, render it and store
        # it in the cache.
        rv = self.environment.fragment_cache.get(key)
        if rv is not None:
            return rv
        rv = caller()
        self.environment.fragment_cache.add(key, rv, timeout)
        return rv


def render_email(
        from_email, to, subject, text_template=None, html_template=None,
        cc=None, attachments=None, **context):
    """
    Read the templates for email messages, format them, construct
    the email from them and return the corresponding email message
    object.

    :param from_email: Email From
    :param to: Email IDs of direct recepients
    :param subject: Email subject
    :param text_template: <Text email template path>
    :param html_template: <HTML email template path>
    :param cc: Email IDs of Cc recepients
    :param attachments: A dict of filename:string as key value pair
                        [preferable file buffer streams]
    :param context: Context to be sent to template rendering

    :return: Email multipart instance or Text/HTML part
    """
    if not (text_template or html_template):
        raise Exception("Atleast HTML or TEXT template is required")

    # Create the body of the message (a plain-text and an HTML version).
    # text is your plain-text email
    # html is your html version of the email
    # if the reciever is able to view html emails then only the html
    # email will be displayed
    if attachments:
        msg = MIMEMultipart('mixed')
    else:
        msg = MIMEMultipart('alternative')
    if text_template:
        if isinstance(text_template, Template):
            text = text_template.render(**context)
        else:
            text = unicode(render_template(text_template, **context))
        text_part = MIMEText(text.encode("utf-8"), 'plain', _charset="UTF-8")
        msg.attach(text_part)
    if html_template:
        if isinstance(html_template, Template):
            html = html_template.render(**context)
        else:
            html = unicode(render_template(html_template, **context))
        html_part = MIMEText(html.encode("utf-8"), 'html', _charset="UTF-8")
        msg.attach(html_part)

    if text_template and not (html_template or attachments):
        msg = text_part
    elif html_template and not (text_template or attachments):
        msg = html_part

    if attachments:
        for filename, content in attachments.items():
            part = MIMEBase('application', "octet-stream")
            part.set_payload(content)
            Encoders.encode_base64(part)
            # XXX: Filename might have to be encoded with utf-8,
            # i.e., part's encoding or with email's encoding
            part.add_header(
                'Content-Disposition', 'attachment; filename="%s"' % filename
            )
            msg.attach(part)

    # We need to use Header objects here instead of just assigning the strings
    # in order to get our headers properly encoded (with QP).
    msg['Subject'] = Header(unicode(subject), 'ISO-8859-1')
    msg['From'] = Header(unicode(from_email), 'ISO-8859-1')
    msg['To'] = Header(unicode(to), 'ISO-8859-1')
    if cc:
        msg['Cc'] = Header(unicode(cc), 'ISO-8859-1')

    return msg

########NEW FILE########
__FILENAME__ = testing
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from contextlib import contextmanager

import jinja2
import unittest
from nereid.sessions import Session
from nereid.contrib.locale import Babel
from werkzeug.contrib.sessions import FilesystemSessionStore

from nereid import Nereid
from flask.globals import _request_ctx_stack


class NereidTestApp(Nereid):
    """
    A Nereid app which works by removing transaction handling around the wsgi
    app
    """

    def __init__(self, **config):
        super(NereidTestApp, self).__init__(**config)
        self.config['WTF_CSRF_ENABLED'] = False

    @property
    def root_transaction(self):
        """
        There is no need of a separate root transaction as everything could
        be loaded in the transaction context provided in the test case
        """
        @contextmanager
        def do_nothing():
            yield
        return do_nothing()

    def load_backend(self):
        """
        Just reuse the pool and DB already loaded by the tryton test loader
        """
        from trytond.tests.test_tryton import DB, POOL
        self._database = DB
        self._pool = POOL

    def dispatch_request(self):
        """
        Skip the transaction handling and call the _dispatch_request
        """
        req = _request_ctx_stack.top.request
        if req.routing_exception is not None:
            self.raise_routing_exception(req)

        rule = req.url_rule
        # if we provide automatic options for this URL and the
        # request came with the OPTIONS method, reply automatically
        if getattr(rule, 'provide_automatic_options', False) \
           and req.method == 'OPTIONS':
            return self.make_default_options_response()

        return self._dispatch_request(req)


class NereidTestCase(unittest.TestCase):

    @property
    def _templates(self):
        if hasattr(self, 'templates'):
            return self.templates
        return {}

    def get_app(self, **options):
        app = NereidTestApp()
        if 'SECRET_KEY' not in options:
            options['SECRET_KEY'] = 'secret-key'
        app.config.update(options)
        from trytond.tests.test_tryton import DB_NAME
        app.config['DATABASE_NAME'] = DB_NAME
        app.config['DEBUG'] = True
        app.session_interface.session_store = \
            FilesystemSessionStore('/tmp', session_class=Session)

        # loaders is usually lazy loaded
        # Pre-fetch it so that the instance attribute _loaders will exist
        app.jinja_loader.loaders
        app.jinja_loader._loaders.insert(0, jinja2.DictLoader(self._templates))

        # Initialise the app now
        app.initialise()

        # Load babel as its a required extension anyway
        Babel(app)
        return app

########NEW FILE########
__FILENAME__ = test_dispatch
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import os
import unittest
from contextlib import contextmanager

import trytond.tests.test_tryton
from trytond import backend
from trytond.config import CONFIG
from trytond.transaction import Transaction
from trytond.tests.test_tryton import POOL, USER, DB, DB_NAME, CONTEXT
from werkzeug.contrib.sessions import FilesystemSessionStore
from nereid import Nereid
from nereid.signals import transaction_start
from nereid.sessions import Session
from nereid.contrib.locale import Babel

from test_templates import BaseTestCase


class NereidTestApp(Nereid):
    """
    A custom Nereid Subclass which uses the transaction handling as it is the
    subject of this test.
    """

    @property
    def root_transaction(self):
        """
        There is no need of a separate root transaction as everything could
        be loaded in the transaction context provided in the test case
        """
        @contextmanager
        def do_nothing():
            yield
        return do_nothing()

    def load_backend(self):
        """
        Just reuse the pool and DB already loaded by the tryton test loader
        """
        self._database = DB
        self._pool = POOL


class TestDispatcherRetry(BaseTestCase):
    """
    Test the transaction retry mechanism in dispatcher

    This test will end up committing code and hence it should be the last test
    in a test suite as there would be certain side effects.
    """
    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid_test')
        super(TestDispatcherRetry, self).setUp()

        self.error_counter = 0

    def get_app(self, **options):
        app = NereidTestApp(
            template_folder=os.path.abspath(
                os.path.join(os.path.dirname(__file__), 'templates')
            )
        )
        if 'SECRET_KEY' not in options:
            options['SECRET_KEY'] = 'secret-key'
        app.config['TEMPLATE_PREFIX_WEBSITE_NAME'] = False
        app.config.update(options)
        app.config['DATABASE_NAME'] = DB_NAME
        app.config['DEBUG'] = True
        app.session_interface.session_store = \
            FilesystemSessionStore('/tmp', session_class=Session)

        # Initialise the app now
        app.initialise()

        # Load babel as its a required extension anyway
        Babel(app)
        return app

    def test_0010_test_failure_counter(self):
        context = CONTEXT.copy()
        with Transaction().start(DB_NAME, USER, context=context) as txn:
            self.setup_defaults()
            app = self.get_app()

            txn.cursor.commit()

        DatabaseOperationalError = backend.get('DatabaseOperationalError')

        @transaction_start.connect
        def incr_error_count(app):
            """
            Subscribe to the transaction_start to increment the counter
            """
            self.error_counter += 1

        CONFIG['retry'] = 4

        with app.test_client() as c:
            try:
                c.get('fail-with-transaction-error')
            except DatabaseOperationalError:
                self.assertEqual(self.error_counter, 5)


def suite():
    "Nereid Dispatcher test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests([
        unittest.TestLoader().loadTestsFromTestCase(TestDispatcherRetry),
    ])
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_helpers
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import unittest
import warnings

from test_templates import BaseTestCase
from trytond.tests.test_tryton import USER, DB_NAME, CONTEXT
from trytond.transaction import Transaction
from nereid import url_for


class TestURLfor(BaseTestCase):
    """
    Test the functionality of the url_for helper
    """

    def test_0010_simple(self):
        """
        Generate a simple URL
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                self.assertEqual(url_for('nereid.website.home'), '/')

    def test_0020_external(self):
        """
        Create an external URL
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                self.assertEqual(
                    url_for('nereid.website.home', _external=True),
                    'http://localhost/'
                )

    def test_0030_schema(self):
        """
        Change the schema to https
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                self.assertEqual(
                    url_for('nereid.website.home',
                            _external=True, _scheme='https'),
                    'https://localhost/'
                )

            with app.test_request_context('/'):
                # Check for the to be deprecated _secure argument
                with warnings.catch_warnings(record=True) as w:
                    self.assertEqual(
                        url_for('nereid.website.home', _secure=True),
                        'https://localhost/'
                    )
                    self.assertEqual(len(w), 1)


def suite():
    "Nereid Helpers test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests([
        unittest.TestLoader().loadTestsFromTestCase(TestURLfor),
    ])
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_pagination
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import unittest

import trytond.tests.test_tryton
from trytond.transaction import Transaction
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from nereid.contrib.pagination import Pagination, BasePagination


class TestPagination(unittest.TestCase):

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_user_obj = POOL.get('nereid.user')
        self.company_obj = POOL.get('company.company')
        self.party_obj = POOL.get('party.party')
        self.currency_obj = POOL.get('currency.currency')
        self.address_obj = POOL.get('party.address')

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'party': self.party,
            'currency': usd,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])

    def test_0010_base_pagination(self):
        """
        Test basic pagination
        """
        pagination = BasePagination(1, 3, [])
        self.assertEqual(pagination.count, 0)
        self.assertEqual(pagination.pages, 0)
        self.assertEqual(pagination.begin_count, 0)
        self.assertEqual(pagination.end_count, 0)

        pagination = BasePagination(1, 3, range(1, 10))
        self.assertEqual(pagination.count, 9)
        self.assertEqual(pagination.pages, 3)
        self.assertEqual(pagination.begin_count, 1)
        self.assertEqual(pagination.end_count, 3)
        self.assertEqual(pagination.all_items(), [1, 2, 3, 4, 5, 6, 7, 8, 9])

    def test_0020_model_pagination(self):
        """
        Test pagination for models
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()

            # Create a 100 nereid users
            for id in xrange(0, 100):
                self.nereid_user_obj.create([{
                    'party': self.guest_party,
                    'display_name': 'User %s' % id,
                    'email': 'user-%s@openlabs.co.in' % id,
                    'password': 'password',
                    'company': self.company.id,
                }])

            pagination = Pagination(self.nereid_user_obj, [], 1, 10)
            self.assertEqual(pagination.count, 100)
            self.assertEqual(pagination.pages, 10)
            self.assertEqual(pagination.begin_count, 1)
            self.assertEqual(pagination.end_count, 10)

    def test_0030_model_pagination_serialization(self):
        """
        Test serialization of pagination for models
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()

            # Create a 100 nereid users
            for id in xrange(0, 100):
                self.nereid_user_obj.create([{
                    'party': self.guest_party,
                    'display_name': 'User %s' % id,
                    'email': 'user-%s@openlabs.co.in' % id,
                    'password': 'password',
                    'company': self.company.id,
                }])

            pagination = Pagination(self.nereid_user_obj, [], 1, 10)
            serialized = pagination.serialize()

            self.assertEqual(serialized['count'], 100)
            self.assertEqual(serialized['pages'], 10)
            self.assertEqual(serialized['page'], 1)
            self.assertEqual(len(serialized['items']), 10)

            self.assert_('display_name' in serialized['items'][0])

    def test_0040_model_pagination_serialization(self):
        """
        Test serialization of pagination for model which does not have
        serialize method
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()

            # Create a 100 addresses
            for id in xrange(0, 100):
                self.address_obj.create([{
                    'party': self.guest_party,
                    'name': 'User %s' % id,
                }])

            pagination = Pagination(self.address_obj, [], 1, 10)
            serialized = pagination.serialize()

            self.assert_('id' in serialized['items'][0])
            self.assert_('rec_name' in serialized['items'][0])

    # TODO: Test the order handling of serialization

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_signals
# -*- coding: utf-8 -*-
"""
    flask.testsuite.signals
    ~~~~~~~~~~~~~~~~~~~~~~~

    Signalling.

    :copyright: (c) 2011 by Armin Ronacher.
    :copyright: (c) 2014 by Openlabs Technologies & Consulting (P) LTD.
    :license: BSD, see LICENSE for more details.
"""
import unittest

from test_templates import BaseTestCase
from trytond.tests.test_tryton import USER, DB_NAME, CONTEXT, POOL
from trytond.transaction import Transaction

import flask
import nereid
from nereid import route


class SignalsTestCase(BaseTestCase):

    def test_template_rendered(self):

        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            # Patch the home page method
            @route('/')
            def home_func():
                return nereid.render_template(
                    'home.jinja', whiskey=42
                )
            app.view_functions['nereid.website.home'] = home_func

            recorded = []

            def record(sender, template, context):
                recorded.append((template, context))

            flask.template_rendered.connect(record, app)
            try:
                app.test_client().get('/')
                self.assertEqual(len(recorded), 1)
                template, context = recorded[0]
                self.assertEqual(template.name, 'home.jinja')
                self.assertEqual(context['whiskey'], 42)
            finally:
                flask.template_rendered.disconnect(record, app)

    def test_request_signals(self):
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()
            calls = []

            def before_request_signal(sender):
                calls.append('before-signal')

            def after_request_signal(sender, response):
                self.assertEqual(response.data, b'stuff')
                calls.append('after-signal')

            @app.before_request
            def before_request_handler():
                calls.append('before-handler')

            @app.after_request
            def after_request_handler(response):
                calls.append('after-handler')
                response.data = 'stuff'
                return response

            # Patch the home page method
            @route('/')
            def home_func():
                calls.append('handler')
                return 'ignored anyway'

            app.view_functions['nereid.website.home'] = home_func

            flask.request_started.connect(before_request_signal, app)
            flask.request_finished.connect(after_request_signal, app)

            try:
                rv = app.test_client().get('/')
                self.assertEqual(rv.data, b'stuff')

                self.assertEqual(
                    calls, [
                        'before-signal', 'before-handler', 'handler',
                        'after-handler', 'after-signal'
                    ]
                )
            finally:
                flask.request_started.disconnect(before_request_signal, app)
                flask.request_finished.disconnect(after_request_signal, app)

    def test_request_exception_signal(self):
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()
            app.config['DEBUG'] = False
            recorded = []

            # Patch the home page method
            @route('/')
            def home_func():
                1 // 0

            app.view_functions['nereid.website.home'] = home_func

            def record(sender, exception):
                recorded.append(exception)

            flask.got_request_exception.connect(record, app)
            try:
                self.assertEqual(
                    app.test_client().get('/').status_code, 500
                )
                self.assertEqual(len(recorded), 1)
                assert isinstance(recorded[0], ZeroDivisionError)
            finally:
                flask.got_request_exception.disconnect(record, app)

    def test_appcontext_signals(self):
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()
            recorded = []

            def record_push(sender, **kwargs):
                recorded.append('push')

            def record_pop(sender, **kwargs):
                recorded.append('pop')

            @app.route('/')
            def index():
                return 'Hello'

            flask.appcontext_pushed.connect(record_push, app)
            flask.appcontext_popped.connect(record_pop, app)
            try:
                with app.test_client() as c:
                    rv = c.get('/')
                    self.assertEqual(rv.data, b'Hello')
                    self.assertEqual(recorded, ['push'])
                self.assertEqual(recorded, ['push', 'pop'])
            finally:
                flask.appcontext_pushed.disconnect(record_push, app)
                flask.appcontext_popped.disconnect(record_pop, app)

    def test_flash_signal(self):
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()
            app.config['SECRET_KEY'] = 'secret'

            # Patch the home page method
            @route('/')
            def home_func():
                flask.flash('This is a flash message', category='notice')
                return nereid.render_template(
                    'home.jinja', whiskey=42
                )
            app.view_functions['nereid.website.home'] = home_func

            recorded = []

            def record(sender, message, category):
                recorded.append((message, category))

            flask.message_flashed.connect(record, app)
            try:
                client = app.test_client()
                with client.session_transaction():
                    client.get('/')
                    self.assertEqual(len(recorded), 1)
                    message, category = recorded[0]
                    self.assertEqual(message, 'This is a flash message')
                    self.assertEqual(category, 'notice')
            finally:
                flask.message_flashed.disconnect(record, app)

    @classmethod
    def tearDownClass(cls):
        POOL.init(update=True)


def suite():
    "Nereid Helpers test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests([
        unittest.TestLoader().loadTestsFromTestCase(SignalsTestCase),
    ])
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_templates
# -*- coding: utf-8 -*-
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import os
import unittest
import pickle
from email.header import decode_header

import pycountry
import trytond.tests.test_tryton
from trytond.transaction import Transaction
from trytond.backend.sqlite.database import Database as SQLiteDatabase  # noqa
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from nereid import render_template, LazyRenderer, render_email
from nereid.testing import NereidTestCase, NereidTestApp
from nereid.sessions import Session
from nereid.contrib.locale import Babel
from werkzeug.contrib.sessions import FilesystemSessionStore


class BaseTestCase(NereidTestCase):

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.nereid_website_locale_obj = POOL.get('nereid.website.locale')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.currency_obj = POOL.get('currency.currency')
        self.language_obj = POOL.get('ir.lang')
        self.country_obj = POOL.get('country.country')
        self.subdivision_obj = POOL.get('country.subdivision')
        self.party_obj = POOL.get('party.party')

    def create_countries(self, count=5):
        """
        Create some sample countries and subdivisions
        """
        for country in list(pycountry.countries)[0:count]:
            country_id, = self.country_obj.create([{
                'name': country.name,
                'code': country.alpha2,
            }])
            try:
                divisions = pycountry.subdivisions.get(
                    country_code=country.alpha2
                )
            except KeyError:
                pass
            else:
                self.subdivision_obj.create([{
                    'country': country_id,
                    'name': subdivision.name,
                    'code': subdivision.code,
                    'type': subdivision.type.lower(),
                } for subdivision in list(divisions)[0:count]])

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'party': self.party,
            'currency': usd,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])
        self.create_countries()
        self.available_countries = self.country_obj.search([], limit=5)

        url_map_id, = self.url_map_obj.search([], limit=1)
        en_us, = self.language_obj.search([('code', '=', 'en_US')])
        currency, = self.currency_obj.search([('code', '=', 'USD')])
        locale, = self.nereid_website_locale_obj.create([{
            'code': 'en_US',
            'language': en_us,
            'currency': currency,
        }])
        self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map_id,
            'company': self.company,
            'application_user': USER,
            'default_locale': locale,
            'guest_user': self.guest_user,
            'countries': [('set', self.available_countries)],
        }])

    def get_app(self, **options):
        app = NereidTestApp(
            template_folder=os.path.abspath(
                os.path.join(os.path.dirname(__file__), 'templates')
            )
        )
        if 'SECRET_KEY' not in options:
            options['SECRET_KEY'] = 'secret-key'
        app.config['TEMPLATE_PREFIX_WEBSITE_NAME'] = False
        app.config.update(options)
        app.config['DATABASE_NAME'] = DB_NAME
        app.config['DEBUG'] = True
        app.session_interface.session_store = \
            FilesystemSessionStore('/tmp', session_class=Session)

        # Initialise the app now
        app.initialise()

        # Load babel as its a required extension anyway
        Babel(app)
        return app


class TestTemplateLoading(BaseTestCase):
    '''
    Test the loading of templates
    '''

    def test_0005_loaders(self):
        '''
        Confirm the paths in the loaders
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            # There must be two loaders, one from the searchpath
            # relative to this folder and the other from
            # nereid package
            self.assertEqual(len(app.jinja_loader.loaders), 2)

    def test_0010_local_loading(self):
        '''
        Render template from local searchpath
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                self.assertEqual(
                    render_template('from-local.html'),
                    'from-local-folder'
                )

    def test_0020_module_loading(self):
        '''
        Render template from module templates searchpath
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                self.assertEqual(
                    render_template('tests/from-module.html'),
                    'from-module'
                )

    def test_0030_local_overwrites_module(self):
        '''
        Look for a template which has a local presence and also
        in the package, but the one rendered is from the local folder
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                self.assertEqual(
                    render_template('tests/exists-both.html'),
                    'content-from-local'
                )

    def test_0040_inheritance(self):
        '''Test if templates are read in the order of the tryton
        module dependency graph. To test this we install the test
        module now and then try to load a template which is different
        with the test module.
        '''
        trytond.tests.test_tryton.install_module('nereid_test')

        with Transaction().start(DB_NAME, USER, CONTEXT) as txn:  # noqa
            # Add nereid_test also to list of modules installed so
            # that it is also added to the templates path

            self.setup_defaults()
            app = self.get_app()

            self.assertEqual(len(app.jinja_loader.loaders), 3)

            with app.test_request_context('/'):
                self.assertEqual(
                    render_template('tests/from-module.html'),
                    'from-nereid-test-module'
                )

    def test_0050_prefix_loader(self):
        """
        Test the SiteNamePrefixLoader
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app(
                TEMPLATE_PREFIX_WEBSITE_NAME=True
            )

            with app.test_request_context('/'):
                self.assertEqual(
                    render_template('site-specific-template.html'),
                    'content-from-localhost-site-specific-template'
                )

    def test_0060_render_email(self):
        '''
        Render Email with template from local searchpath
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            sender = u'Sender <sender@openlabs.co.in>'

            with app.test_request_context('/'):
                email_message = render_email(
                    sender, u'reciever@openlabs.co.in',
                    u'Dummy subject of email', text_template='from-local.html',
                    cc=u'cc@openlabs.co.in'
                )
                self.assertEqual(
                    decode_header(email_message['From'])[0],
                    (sender, None)
                )
                self.assertEqual(
                    decode_header(email_message['Subject'])[0],
                    ('Dummy subject of email', None)
                )

    def test_0070_render_email_unicode(self):
        '''
        Render email with unicode in Subject, From and To.
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            sender = u'CÃ©dric Krier <cedric.krier@b2ck.com>'

            with app.test_request_context('/'):
                email_message = render_email(
                    sender,
                    u'reciever@openlabs.co.in',
                    u'Dummy subject Ã¸f email',
                    text_template='from-local.html',
                    cc=u'cc@openlabs.co.in'
                )
                self.assertEqual(
                    decode_header(email_message['From'])[0],
                    (sender.encode('ISO-8859-1'), 'iso-8859-1')
                )
                self.assertEqual(
                    decode_header(email_message['Subject'])[0],
                    (
                        u'Dummy subject Ã¸f email'.encode('iso-8859-1'),
                        'iso-8859-1'
                    )
                )
                self.assertEqual(
                    decode_header(email_message['To'])[0],
                    (u'reciever@openlabs.co.in'.encode('UTF-8'), None)
                )


class TestLazyRendering(BaseTestCase):
    '''
    Test the lazy rendering of templates
    '''

    def test_0010_change_context(self):
        '''
        Render template from local searchpath
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                self.assertEqual(
                    render_template(
                        'tests/test-changing-context.html',
                        variable="a"
                    ), 'a'
                )
                lazy_template = render_template(
                    'tests/test-changing-context.html',
                    variable="a"
                )
                self.assertTrue(
                    isinstance(lazy_template, LazyRenderer)
                )

                # Now change the value of the variable in the context and
                # see if the template renders with the new value
                lazy_template.context['variable'] = "b"
                self.assertEqual(lazy_template, "b")

                # Make a unicode of the same template
                unicode_of_response = unicode(lazy_template)
                self.assertEqual(unicode_of_response, "b")
                self.assertTrue(
                    isinstance(unicode_of_response, unicode)
                )

    def test_0020_pickling(self):
        '''
        Test if the lazy rendering object can be pickled and rendered
        with a totally different context (when no application, request
        or transaction bound objects are present).
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                response = render_template(
                    'tests/test-changing-context.html',
                    variable="a"
                )
                self.assertEqual(response, 'a')
                pickled_response = pickle.dumps(response)

        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_request_context('/'):
                response = pickle.loads(pickled_response)
                self.assertEqual(response, 'a')

    def test_0030_simple_render(self):
        '''
        Simply render a template.
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/registration')
                self.assertEqual(response.status_code, 200)

    def test_0040_headers(self):
        '''
        Change registrations headers and check
        '''
        trytond.tests.test_tryton.install_module('nereid_test')
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/test-lazy-renderer')
                self.assertEqual(response.headers['X-Test-Header'], 'TestValue')
                self.assertEqual(response.status_code, 201)


def suite():
    "Nereid Template Loading test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests([
        unittest.TestLoader().loadTestsFromTestCase(TestTemplateLoading),
        unittest.TestLoader().loadTestsFromTestCase(TestLazyRendering),
    ])
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = wrappers
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import warnings

from werkzeug._internal import _missing
from flask.wrappers import Request as RequestBase, Response as ResponseBase
from flask.ext.login import current_user

from .globals import current_app, request
from .signals import transaction_stop


class cached_property(object):
    """A decorator that converts a function into a lazy property.  The
    function wrapped is called the first time to retrieve the result
    and then that calculated result is used the next time you access
    the value::

        class Foo(object):

            @cached_property
            def foo(self):
                # calculate something important here
                return 42

    The class has to have a `__dictcache__` in order for this property to
    work.

    If the transaction has changed then the cache is invalidated

    Based on werkzeug.utils.cached_property
    """

    # implementation detail: this property is implemented as non-data
    # descriptor.  non-data descriptors are only invoked if there is
    # no entry with the same name in the instance's __dictcache__.
    # this allows us to completely get rid of the access function call
    # overhead.  If one choses to invoke __get__ by hand the property
    # will still work as expected because the lookup logic is replicated
    # in __get__ for manual invocation.

    def __init__(self, func, name=None, doc=None):
        self.__name__ = name or func.__name__
        self.__module__ = func.__module__
        self.__doc__ = doc or func.__doc__
        self.func = func

    def __get__(self, obj, type=None):
        if obj is None:
            return self
        value = obj.__dictcache__.get(self.__name__, _missing)
        if value is _missing:
            value = self.func(obj)
            obj.__dictcache__[self.__name__] = value
        return value


class Request(RequestBase):
    "Request Object"

    def __init__(self, *args, **kwargs):
        super(Request, self).__init__(*args, **kwargs)
        self.__dictcache__ = {}

    @staticmethod
    @transaction_stop.connect
    def clear_dictcache(app):
        """
        Clears the dictcache which stored the cached values of the records
        below.
        """
        request.__dictcache__ = {}

    @cached_property
    def nereid_website(self):
        """Fetch the Browse Record of current website."""
        if self.url_rule is None:
            return None
        Website = current_app.pool.get('nereid.website')
        return Website.get_from_host(self.host)

    @cached_property
    def nereid_user(self):
        """Fetch the browse record of current user or None."""
        warnings.warn(
            "request.nereid_user will be deprecated. "
            "Use `nereid.current_user` proxy instead.",
            DeprecationWarning, stacklevel=2
        )
        return current_user

    @cached_property
    def nereid_currency(self):
        """
        Return a browse record for the currency.
        """
        return self.nereid_locale.currency

    @cached_property
    def nereid_locale(self):
        """
        Returns the active record of the current locale.
        The locale could either be from the URL if the locale was specified
        in the URL, or the default locale from the website.
        """
        if self.view_args and 'locale' in self.view_args:
            for locale in self.nereid_website.locales:
                if locale.code == self.view_args['locale']:
                    return locale

        # Return the default locale
        return self.nereid_website.default_locale

    @cached_property
    def nereid_language(self):
        """
        Return a active record for the language.
        """
        return self.nereid_locale.language

    @cached_property
    def is_guest_user(self):
        """Return true if the user is guest."""
        warnings.warn(
            "request.is_guest_user will be deprecated. "
            "Use `nereid.current_user` proxy and "
            "current_user.is_anonymous instead",
            DeprecationWarning, stacklevel=2
        )
        return current_user.is_anonymous()

    @property
    def is_json(self):
        """Indicates if this request is JSON or not.  By default a request
        is considered to include JSON data if the mimetype is
        ``application/json`` or ``application/*+json``.

        This feature is forward ported from flask 0.11. When flask is released
        this will be removed from nereid code

        .. versionadded:: 3.0.4.0
        """
        mt = self.mimetype
        if mt == 'application/json':
            return True
        if mt.startswith('application/') and mt.endswith('+json'):
            return True
        return False


class Response(ResponseBase):
    pass

########NEW FILE########
__FILENAME__ = configuration
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from trytond.model import ModelView
from trytond.wizard import Wizard, StateView, Button, StateTransition
from trytond.pool import PoolMeta

__all__ = ['NereidConfigStart', 'NereidConfig']
__metaclass__ = PoolMeta


class NereidConfigStart(ModelView):
    'Nereid Config'
    __name__ = 'nereid.website.config.start'


class NereidConfig(Wizard):
    'Configure Nereid'
    __name__ = 'nereid.website.config'
    start = StateView(
        'nereid.website.config.start',
        'nereid.website_config_start_view_form', [
            Button('Cancel', 'end', 'tryton-cancel'),
            Button('Ok', 'website', 'tryton-ok', True),
        ]
    )
    website = StateView(
        'nereid.website',
        'nereid.website_view_form', [
            Button('Cancel', 'end', 'tryton-cancel'),
            Button('Add', 'add', 'tryton-ok', True),
        ]
    )
    add = StateTransition()

    def transition_add(self):
        """
        Add website during transition and close the wizard.
        """
        self.website.save()
        return 'end'

########NEW FILE########
__FILENAME__ = country
# -*- coding: utf-8 -*-
"""
    Country

    :copyright: (c) 2014 by Openlabs Technologies & Consulting (P) Limited
    :license: BSD, see LICENSE for more details.
"""
from trytond.pool import PoolMeta, Pool
from nereid import jsonify, route

__metaclass__ = PoolMeta

__all__ = ['Country', 'Subdivision']


class Country:
    "Country"

    __name__ = 'country.country'

    @classmethod
    @route("/all-countries", methods=["GET"])
    def get_all_countries(cls):
        """
        Returns serialized list of all countries
        """
        return jsonify(countries=[
            country.serialize() for country in cls.search([])
        ])

    def serialize(self, purpose=None):
        """
        Serialize country data
        """
        return {
            'id': self.id,
            'name': self.name,
            'code': self.code
        }

    @route("/countries/<int:active_id>/subdivisions", methods=["GET"])
    def get_subdivisions(self):
        """
        Returns serialized list of all subdivisions for current country
        """
        Subdivision = Pool().get('country.subdivision')

        subdivisions = Subdivision.search([('country', '=', self.id)])
        return jsonify(
            result=[s.serialize() for s in subdivisions]
        )


class Subdivision:
    "Subdivision"

    __name__ = 'country.subdivision'

    def serialize(self, purpose=None):
        """
        Serialize subdivision data
        """
        return {
            'id': self.id,
            'name': self.name,
            'code': self.code,
        }

########NEW FILE########
__FILENAME__ = currency
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from trytond.model import ModelView, ModelSQL
from nereid import request

__all__ = ['Currency']


class Currency(ModelSQL, ModelView):
    '''Currency Manipulation for core.'''
    __name__ = 'currency.currency'

    @classmethod
    def convert(cls, amount):
        """A helper method which converts the amount from the currency of the
        company which owns the current website to the currency of the current
        session.
        """
        return cls.compute(
            request.nereid_website.company.currency,
            amount,
            request.nereid_currency
        )

    @classmethod
    def context_processor(cls):
        """Register compute as convert template context function.

        Usage:
            {{ compute(from_currency, amount, to_currency, round) }}
        Eg: convert
        """
        return {
            'compute': cls.compute,
            'convert': cls.convert
        }

########NEW FILE########
__FILENAME__ = i18n
# -*- coding: utf-8 -*-
'''

    Internationalisation for Nereid

    :copyright: (c) 2010-2014 by Openlabs Technologies & Consulting (P) Ltd.
    :license: GPLv3, see LICENSE for more details

'''
from nereid.contrib.locale import make_lazy_gettext, make_lazy_ngettext


_, N_ = make_lazy_gettext('nereid'), make_lazy_ngettext('nereid')

########NEW FILE########
__FILENAME__ = party
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import warnings
from flask_wtf import Form
from wtforms import TextField, IntegerField, SelectField, validators
from werkzeug import redirect, abort
from jinja2 import TemplateNotFound

from nereid import request, url_for, render_template, login_required, flash, \
    jsonify, route
from trytond.model import ModelView, ModelSQL, fields
from trytond.pool import Pool, PoolMeta
from trytond.transaction import Transaction
from trytond import backend
from sql import As, Literal, Column
from .user import RegistrationForm
from .i18n import _

__all__ = ['Address', 'Party', 'ContactMechanism']


class AddressForm(Form):
    """
    A form resembling the party.address
    """
    name = TextField(_('Name'), [validators.Required(), ])
    street = TextField(_('Street'), [validators.Required(), ])
    streetbis = TextField(_('Street (Bis)'))
    zip = TextField(_('Post Code'), [validators.Required(), ])
    city = TextField(_('City'), [validators.Required(), ])
    country = SelectField(_('Country'), [validators.Required(), ], coerce=int)
    subdivision = IntegerField(_('State/County'), [validators.Required()])
    email = TextField(_('Email'))
    phone = TextField(_('Phone'))


class Address:
    """Party Address"""
    __name__ = 'party.address'
    __metaclass__ = PoolMeta

    registration_form = RegistrationForm

    phone = fields.Function(fields.Char('Phone'), 'get_address_mechanism')
    email = fields.Function(fields.Char('E-Mail'), 'get_address_mechanism')

    @classmethod
    def __register__(cls, module_name):
        pool = Pool()
        Party = pool.get('party.party')
        ContactMechanism = pool.get('party.contact_mechanism')
        TableHandler = backend.get('TableHandler')
        cursor = Transaction().cursor
        table = TableHandler(cursor, cls, module_name)
        party = Party.__table__()
        address = cls.__table__()
        mechanism = ContactMechanism.__table__()

        super(Address, cls).__register__(module_name)

        # Migration from 2.8: move phone and email to contact mechanisms
        for column in ['email', 'phone']:
            if table.column_exist(column):
                join = address.join(
                    party, condition=(party.id == address.party)
                )
                select = join.select(
                    address.create_date, address.create_uid,
                    address.write_date, address.write_uid,
                    As(Literal(column), 'type'),
                    As(Column(address, column), 'value'), address.party,
                    As(Literal(True), 'active'),
                    where=(Column(address, column) != '')
                )
                insert = mechanism.insert(
                    columns=[
                            mechanism.create_date,
                            mechanism.create_uid, mechanism.write_date,
                            mechanism.write_uid, mechanism.type,
                            mechanism.value, mechanism.party, mechanism.active,
                    ], values=select)
                cursor.execute(*insert)

                table.column_rename(column, '%s_deprecated' % column)

    def get_address_mechanism(self, name):
        for mechanism in self.party.contact_mechanisms:
            if mechanism.type == name:
                return mechanism.value
        return ''

    @classmethod
    def get_address_form(cls, address=None):
        """
        Return an initialised Address form that can be validated and used to
        create/update addresses

        :param address: If an active record is provided it is used to autofill
                        the form.
        """
        if address:
            form = AddressForm(
                request.form,
                name=address.name,
                street=address.street,
                streetbis=address.streetbis,
                zip=address.zip,
                city=address.city,
                country=address.country and address.country.id,
                subdivision=address.subdivision and address.subdivision.id,
                email=address.email,
                phone=address.phone
            )
        else:
            address_name = "" if request.nereid_user.is_anonymous() else \
                request.nereid_user.display_name
            form = AddressForm(request.form, name=address_name)

        # Prefill the available countries
        countries = [
            (c.id, c.name) for c in request.nereid_website.countries
        ]
        form.country.choices = countries

        return form

    @classmethod
    @route("/create-address", methods=["GET", "POST"])
    @login_required
    def create_address(cls):
        """
        Create an address for the current nereid_user

        GET
        ~~~

        Return an address creation form

        POST
        ~~~~

        Creates an address and redirects to the address view. If a next_url
        is provided, redirects there.

        .. version_added: 3.0.3.0
        """
        form = cls.get_address_form()

        if request.method == 'POST' and form.validate():
            party = request.nereid_user.party
            address, = cls.create([{
                'name': form.name.data,
                'street': form.street.data,
                'streetbis': form.streetbis.data,
                'zip': form.zip.data,
                'city': form.city.data,
                'country': form.country.data,
                'subdivision': form.subdivision.data,
                'party': party.id,
            }])
            if form.email.data:
                party.add_contact_mechanism_if_not_exists(
                    'email', form.email.data
                )
            if form.phone.data:
                party.add_contact_mechanism_if_not_exists(
                    'phone', form.phone.data
                )
            return redirect(url_for('party.address.view_address'))

        try:
            return render_template('address-add.jinja', form=form)
        except TemplateNotFound:
            # The address-add template was introduced in 3.0.3.0
            # so just raise a deprecation warning till 3.2.X and then
            # expect the use of address-add template
            warnings.warn(
                "address-add.jinja template not found. "
                "Will be required in future versions",
                DeprecationWarning
            )
            return render_template('address-edit.jinja', form=form)

    @classmethod
    @route("/save-new-address", methods=["GET", "POST"])
    @route("/edit-address/<int:address>", methods=["GET", "POST"])
    @login_required
    def edit_address(cls, address=None):
        """
        Edit an Address

        POST will update an existing address.
        GET will return a existing address edit form.

        .. version_changed:: 3.0.3.0

            For creating new address use the create_address handled instead of
            this one. The functionality would be deprecated in 3.2.X

        :param address: ID of the address
        """
        if address is None:
            warnings.warn(
                "Address creation will be deprecated from edit_address handler."
                " Use party.address.create_address instead",
                DeprecationWarning
            )
            return cls.create_address()

        form = cls.get_address_form()

        if address not in (a.id for a in request.nereid_user.party.addresses):
            # Check if the address is in the list of addresses of the
            # current user's party
            abort(403)

        address = cls(address)

        if request.method == 'POST' and form.validate():
            party = request.nereid_user.party
            cls.write([address], {
                'name': form.name.data,
                'street': form.street.data,
                'streetbis': form.streetbis.data,
                'zip': form.zip.data,
                'city': form.city.data,
                'country': form.country.data,
                'subdivision': form.subdivision.data,
            })
            if form.email.data:
                party.add_contact_mechanism_if_not_exists(
                    'email', form.email.data
                )
            if form.phone.data:
                party.add_contact_mechanism_if_not_exists(
                    'phone', form.phone.data
                )
            return redirect(url_for('party.address.view_address'))

        elif request.method == 'GET' and address:
            # Its an edit of existing address, prefill data
            form = cls.get_address_form(address)

        return render_template('address-edit.jinja', form=form, address=address)

    @classmethod
    @route("/view-address", methods=["GET"])
    @login_required
    def view_address(cls):
        "View the addresses of user"
        return render_template('address.jinja')


class Party(ModelSQL, ModelView):
    "Party"
    __name__ = 'party.party'

    nereid_users = fields.One2Many('nereid.user', 'party', 'Nereid Users')

    def add_contact_mechanism_if_not_exists(self, type, value):
        """
        Adds a contact mechanism to the party if it does not exist

        :return: The created contact mechanism or the one which existed
        """
        ContactMechanism = Pool().get('party.contact_mechanism')

        mechanisms = ContactMechanism.search([
            ('party', '=', self.id),
            ('type', '=', type),
            ('value', '=', value),
        ])
        if not mechanisms:
            mechanisms = ContactMechanism.create([{
                'party': self.id,
                'type': type,
                'value': value,
            }])
        return mechanisms[0]


class ContactMechanismForm(Form):
    type = SelectField('Type', [validators.Required()])
    value = TextField('Value', [validators.Required()])
    comment = TextField('Comment')


class ContactMechanism(ModelSQL, ModelView):
    """
    Allow modification of contact mechanisms
    """
    __name__ = "party.contact_mechanism"

    @classmethod
    def get_form(cls):
        """
        Returns the contact mechanism form
        """
        from trytond.modules.party import contact_mechanism
        form = ContactMechanismForm()
        form.type.choices = contact_mechanism._TYPES
        return form

    @classmethod
    @route("/contact-mechanisms/add", methods=["POST"])
    @login_required
    def add(cls):
        """
        Adds a contact mechanism to the party's contact mechanisms
        """
        form = cls.get_form()
        if form.validate_on_submit():
            cls.create([{
                'party': request.nereid_user.party.id,
                'type': form.type.data,
                'value': form.value.data,
                'comment': form.comment.data,
            }])
            if request.is_xhr:
                return jsonify({'success': True})
            return redirect(request.referrer)

        if request.is_xhr:
            return jsonify({'success': False})
        else:
            for field, messages in form.errors:
                flash("<br>".join(messages), "Field %s" % field)
            return redirect(request.referrer)

    @route("/contact-mechanisms/<int:active_id>", methods=["POST", "DELETE"])
    @login_required
    def remove(self):
        """
        DELETE: Removes the current contact mechanism
        """
        ContactMechanism = Pool().get('party.contact_mechanism')

        if self.party == request.nereid_user.party:
            ContactMechanism.delete([self])
        else:
            abort(403)
        if request.is_xhr:
            return jsonify({
                'success': True
            })
        return redirect(request.referrer)

########NEW FILE########
__FILENAME__ = static_file
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import os
import urllib

from nereid import route
from nereid.helpers import slugify, send_file, url_for
from nereid.globals import _request_ctx_stack
from werkzeug import abort

from trytond.model import ModelSQL, ModelView, fields
from trytond.config import CONFIG
from trytond.transaction import Transaction
from trytond.pyson import Eval, Not, Equal

__all__ = ['NereidStaticFolder', 'NereidStaticFile']


class NereidStaticFolder(ModelSQL, ModelView):
    "Static folder for Nereid"
    __name__ = "nereid.static.folder"
    _rec_name = 'folder_name'

    folder_name = fields.Char(
        'Folder Name', required=True, select=1,
        on_change_with=['name', 'folder_name']
    )
    description = fields.Char('Description', select=1)
    files = fields.One2Many('nereid.static.file', 'folder', 'Files')

    @classmethod
    def __setup__(cls):
        super(NereidStaticFolder, cls).__setup__()
        cls._sql_constraints += [
            ('unique_folder', 'UNIQUE(folder_name)',
             'Folder name needs to be unique')
        ]
        cls._error_messages.update({
            'invalid_folder_name': """Invalid folder name:
                (1) '.' in folder name (OR)
                (2) folder name begins with '/'""",
            'folder_cannot_change': "Folder name cannot be changed"
        })

    def on_change_with_folder_name(self):
        """
        Fills the name field with a slugified name
        """
        if self.get('name'):
            if not self.get('folder_name'):
                self['folder_name'] = slugify(self['name'])
            return self['folder_name']

    @classmethod
    def validate(cls, folders):
        """
        Validates the records.

        :param folders: active record list of folders
        """
        super(NereidStaticFolder, cls).validate(folders)
        for folder in folders:
            folder.check_folder_name()

    def check_folder_name(self):
        '''
        Check the validity of folder name
        Allowing the use of / or . will be risky as that could
        eventually lead to previlege escalation
        '''
        if ('.' in self.folder_name) or (self.folder_name.startswith('/')):
            self.raise_user_error('invalid_folder_name')

    @classmethod
    def write(cls, folders, vals):
        """
        Check if the folder_name has been modified.
        If yes, raise an error.

        :param vals: values of the current record
        """
        if vals.get('folder_name'):
            # TODO: Support this feature in future versions
            cls.raise_user_error('folder_cannot_change')
        return super(NereidStaticFolder, cls).write(folders, vals)


class NereidStaticFile(ModelSQL, ModelView):
    "Static files for Nereid"
    __name__ = "nereid.static.file"

    name = fields.Char('File Name', select=True, required=True)
    folder = fields.Many2One(
        'nereid.static.folder', 'Folder', select=True, required=True
    )
    type = fields.Selection([
        ('local', 'Local File'),
        ('remote', 'Remote File'),
    ], 'File Type')

    #: URL of the remote file if the :attr:`type` is remote
    remote_path = fields.Char(
        'Remote File', select=True, translate=True,
        states={
            'required': Equal(Eval('type'), 'remote'),
            'invisible': Not(Equal(Eval('type'), 'remote'))
        }
    )

    #: This function field returns the field contents. This is useful if the
    #: field is going to be displayed on the clients.
    file_binary = fields.Function(
        fields.Binary('File', filename='name'),
        'get_file_binary', 'set_file_binary',
    )

    #: Full path to the file in the filesystem
    file_path = fields.Function(fields.Char('File Path'), 'get_file_path')

    #: URL that can be used to idenfity the resource. Note that the value
    #: of this field is available only when called within a request context.
    #: In other words the URL is valid only when called in a nereid request.
    url = fields.Function(fields.Char('URL'), 'get_url')

    @classmethod
    def __setup__(cls):
        super(NereidStaticFile, cls).__setup__()
        cls._sql_constraints += [
            ('name_folder_uniq', 'UNIQUE(name, folder)',
                'The Name of the Static File must be unique in a folder.!'),
        ]
        cls._error_messages.update({
            'invalid_file_name': """Invalid file name:
                (1) '..' in file name (OR)
                (2) file name contains '/'""",
        })

    @staticmethod
    def default_type():
        return 'local'

    def get_url(self, name):
        """Return the url if within an active request context or return
        False values
        """
        if _request_ctx_stack.top is None:
            return None

        if self.type == 'local':
            return url_for(
                'nereid.static.file.send_static_file',
                folder=self.folder.folder_name, name=self.name
            )
        elif self.type == 'remote':
            return self.remote_path

    @staticmethod
    def get_nereid_base_path():
        """
        Returns base path for nereid, where all the static files would be
        stored.

        By Default it is:

        <Tryton Data Path>/<Database Name>/nereid
        """
        cursor = Transaction().cursor
        return os.path.join(
            CONFIG['data_path'], cursor.database_name, "nereid"
        )

    def _set_file_binary(self, value):
        """
        Setter for static file that stores file in file system

        :param value: The value to set
        """
        if self.type == 'local':
            file_binary = buffer(value)
            # If the folder does not exist, create it recursively
            directory = os.path.dirname(self.file_path)
            if not os.path.isdir(directory):
                os.makedirs(directory)
            with open(self.file_path, 'wb') as file_writer:
                file_writer.write(file_binary)

    @classmethod
    def set_file_binary(cls, files, name, value):
        """
        Setter for the functional binary field.

        :param files: Records
        :param name: Ignored
        :param value: The file buffer
        """
        for static_file in files:
            static_file._set_file_binary(value)

    def get_file_binary(self, name):
        '''
        Getter for the binary_file field. This fetches the file from the
        file system, coverts it to buffer and returns it.

        :param name: Field name
        :return: File buffer
        '''
        location = self.file_path if self.type == 'local' \
            else urllib.urlretrieve(self.remote_path)[0]
        with open(location, 'rb') as file_reader:
            return buffer(file_reader.read())

    def get_file_path(self, name):
        """
        Returns the full path to the file in the file system

        :param name: Field name
        :return: File path
        """
        return os.path.abspath(
            os.path.join(
                self.get_nereid_base_path(),
                self.folder.folder_name, self.name
            )) \
            if self.type == 'local' else self.remote_path

    @classmethod
    def validate(cls, files):
        """
        Validates the records.

        :param files: active record list of static files
        """
        super(NereidStaticFile, cls).validate(files)
        for file in files:
            file.check_file_name()

    def check_file_name(self):
        '''
        Check the validity of folder name
        Allowing the use of / or . will be risky as that could
        eventually lead to previlege escalation
        '''
        if ('..' in self.name) or ('/' in self.name):
            self.raise_user_error("invalid_file_name")

    @classmethod
    @route("/static-file/<folder>/<name>", methods=["GET"])
    def send_static_file(cls, folder, name):
        """
        Invokes the send_file method in nereid.helpers to send a file as the
        response to the request. The file is sent in a way which is as
        efficient as possible. For example nereid will use the X-Send_file
        header to make nginx send the file if possible.

        :param folder: folder_name of the folder
        :param name: name of the file
        """
        # TODO: Separate this search and find into separate cached method

        files = cls.search([
            ('folder.folder_name', '=', folder),
            ('name', '=', name)
        ])
        if not files:
            abort(404)
        return send_file(files[0].file_path)

########NEW FILE########
__FILENAME__ = template
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
from trytond.model import ModelView, ModelSQL, fields
from trytond.pool import Pool

__all__ = ['ContextProcessors']


class ContextProcessors(ModelSQL, ModelView):
    "Temlate Context Processor Registry"
    __name__ = 'nereid.template.context_processor'
    _rec_name = 'method'

    method = fields.Char(
        'Method', required=True,
        help="Context processor method in <model>.<method>"
    )
    model = fields.Char(
        'Model',
        help="This will restrict the loading when URLs with"
        " the model are called"
    )

    @classmethod
    def get_processors(cls):
        """
        Return the list of processors. Separate function
        since its important to have caching on this
        """
        result = {}
        ctx_processors = cls.search([])
        for ctx_proc in ctx_processors:
            model, method = ctx_proc.method.rsplit('.', 1)
            ctx_proc_as_func = getattr(Pool().get(model), method)
            result.setdefault(ctx_proc.model or None, []).append(
                ctx_proc_as_func)
        return result

########NEW FILE########
__FILENAME__ = test_address
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import json
import unittest

import pycountry
from mock import patch
import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from trytond.transaction import Transaction
from trytond.config import CONFIG
from nereid.testing import NereidTestCase

CONFIG['smtp_server'] = 'smtpserver'
CONFIG['smtp_user'] = 'test@xyz.com'
CONFIG['smtp_password'] = 'testpassword'
CONFIG['smtp_port'] = 587
CONFIG['smtp_tls'] = True
CONFIG['smtp_from'] = 'from@xyz.com'


class TestAddress(NereidTestCase):
    'Test Address'

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.nereid_website_locale_obj = POOL.get('nereid.website.locale')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.currency_obj = POOL.get('currency.currency')
        self.language_obj = POOL.get('ir.lang')
        self.country_obj = POOL.get('country.country')
        self.subdivision_obj = POOL.get('country.subdivision')
        self.party_obj = POOL.get('party.party')
        self.address_obj = POOL.get('party.address')
        self.contact_mech_obj = POOL.get('party.contact_mechanism')

        self.templates = {
            'home.jinja': '{{get_flashed_messages()}}',
            'login.jinja':
            '{{ login_form.errors }} {{get_flashed_messages()}}',
            'registration.jinja':
            '{{ form.errors }} {{get_flashed_messages()}}',
            'reset-password.jinja': '',
            'change-password.jinja':
            '{{ change_password_form.errors }}',
            'address-edit.jinja':
            'Address Edit {% if address %}ID:{{ address.id }}{% endif %}'
            '{{ form.errors }}',
            'address.jinja': '',
            'account.jinja': '',
            'emails/activation-text.jinja': 'activation-email-text',
            'emails/activation-html.jinja': 'activation-email-html',
            'emails/reset-text.jinja': 'reset-email-text',
            'emails/reset-html.jinja': 'reset-email-html',
        }

        # Patch SMTP Lib
        self.smtplib_patcher = patch('smtplib.SMTP')
        self.PatchedSMTP = self.smtplib_patcher.start()

    def tearDown(self):
        # Unpatch SMTP Lib
        self.smtplib_patcher.stop()

    def create_countries(self, count=5):
        """
        Create some sample countries and subdivisions
        """
        for country in list(pycountry.countries)[0:count]:
            country_id, = self.country_obj.create([{
                'name': country.name,
                'code': country.alpha2,
            }])
            try:
                divisions = pycountry.subdivisions.get(
                    country_code=country.alpha2
                )
            except KeyError:
                pass
            else:
                self.subdivision_obj.create([{
                    'country': country_id,
                    'name': subdivision.name,
                    'code': subdivision.code,
                    'type': subdivision.type.lower(),
                } for subdivision in list(divisions)[0:count]])

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'party': self.party,
            'currency': usd,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])
        party, = self.party_obj.create([{
            'name': 'Registered User',
        }])
        self.registered_user, = self.nereid_user_obj.create([{
            'party': party,
            'display_name': 'Registered User',
            'email': 'email@example.com',
            'password': 'password',
            'company': self.company,
        }])

        self.create_countries()
        self.available_countries = self.country_obj.search([], limit=5)

        url_map_id, = self.url_map_obj.search([], limit=1)
        en_us, = self.language_obj.search([('code', '=', 'en_US')])
        currency, = self.currency_obj.search([('code', '=', 'USD')])
        locale, = self.nereid_website_locale_obj.create([{
            'code': 'en_US',
            'language': en_us,
            'currency': currency,
        }])
        self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map_id,
            'company': self.company,
            'application_user': USER,
            'default_locale': locale,
            'locales': [('add', [locale.id])],
            'guest_user': self.guest_user,
            'countries': [('set', self.available_countries)],
        }])

    def get_template_source(self, name):
        """
        Return templates
        """
        return self.templates.get(name)

    # XXX: Due for deprecation in 3.2.X
    def test_0010_add_address(self):
        """
        Add an address for the user
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            registered_user = self.registered_user

            address_data = {
                'name': 'Name',
                'street': 'Street',
                'streetbis': 'StreetBis',
                'zip': 'zip',
                'city': 'City',
                'email': 'email@example.com',
                'phone': '1234567890',
                'country': self.available_countries[0].id,
                'subdivision': self.country_obj(
                    self.available_countries[0]).subdivisions[0].id,
            }

            with app.test_client() as c:
                response = c.post(
                    '/en_US/login',
                    data={
                        'email': 'email@example.com',
                        'password': 'password',
                    }
                )
                self.assertEqual(response.status_code, 302)  # Login success

                # Assert that the user has only 1 address, which gets created
                # automatically with the party
                self.assertEqual(len(registered_user.party.addresses), 1)
                existing_address, = registered_user.party.addresses

                # POST and a new address must be created
                response = c.post('/en_US/save-new-address', data=address_data)
                self.assertEqual(response.status_code, 302)

                # Re browse the record
                registered_user = self.nereid_user_obj(
                    self.registered_user.id
                )
                # Check if the user has two addresses now
                self.assertEqual(len(registered_user.party.addresses), 2)
                for address in registered_user.party.addresses:
                    if address != existing_address:
                        break
                else:
                    self.fail("New address not found")

                self.assertEqual(address.name, address_data['name'])
                self.assertEqual(address.street, address_data['street'])
                self.assertEqual(address.streetbis, address_data['streetbis'])
                self.assertEqual(address.zip, address_data['zip'])
                self.assertEqual(address.city, address_data['city'])
                self.assertEqual(address.email, address_data['email'])
                self.assertEqual(address.phone, address_data['phone'])
                self.assertEqual(address.country.id, address_data['country'])
                self.assertEqual(
                    address.subdivision.id, address_data['subdivision']
                )

    def test_0015_add_address(self):
        """
        Add an address for the user.

        The create_address method was introduced in 3.0.3.0
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            registered_user = self.registered_user

            address_data = {
                'name': 'Name',
                'street': 'Street',
                'streetbis': 'StreetBis',
                'zip': 'zip',
                'city': 'City',
                'email': 'email@example.com',
                'phone': '1234567890',
                'country': self.available_countries[0].id,
                'subdivision': self.country_obj(
                    self.available_countries[0]).subdivisions[0].id,
            }

            with app.test_client() as c:
                response = c.post(
                    '/en_US/login',
                    data={
                        'email': 'email@example.com',
                        'password': 'password',
                    }
                )
                self.assertEqual(response.status_code, 302)  # Login success

                # Assert that the user has only 1 address, which gets created
                # automatically with the party
                self.assertEqual(len(registered_user.party.addresses), 1)
                existing_address, = registered_user.party.addresses

                # POST and a new address must be created
                response = c.post('/en_US/create-address', data=address_data)
                self.assertEqual(response.status_code, 302)

                # Re browse the record
                registered_user = self.nereid_user_obj(
                    self.registered_user.id
                )
                # Check if the user has two addresses now
                self.assertEqual(len(registered_user.party.addresses), 2)
                for address in registered_user.party.addresses:
                    if address != existing_address:
                        break
                else:
                    self.fail("New address not found")

                self.assertEqual(address.name, address_data['name'])
                self.assertEqual(address.street, address_data['street'])
                self.assertEqual(address.streetbis, address_data['streetbis'])
                self.assertEqual(address.zip, address_data['zip'])
                self.assertEqual(address.city, address_data['city'])
                self.assertEqual(address.email, address_data['email'])
                self.assertEqual(address.phone, address_data['phone'])
                self.assertEqual(address.country.id, address_data['country'])
                self.assertEqual(
                    address.subdivision.id, address_data['subdivision']
                )

    def test_0020_edit_address(self):
        """
        Edit an address for the user
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            registered_user = self.registered_user
            address_data = {
                'name': 'Name',
                'street': 'Street',
                'streetbis': 'StreetBis',
                'zip': 'zip',
                'city': 'City',
                'email': 'email@example.com',
                'phone': '1234567890',
                'country': self.available_countries[0].id,
                'subdivision': self.country_obj(
                        self.available_countries[0]).subdivisions[0].id,
            }

            with app.test_client() as c:
                response = c.post(
                    '/en_US/login',
                    data={
                        'email': 'email@example.com',
                        'password': 'password',
                    }
                )
                self.assertEqual(response.status_code, 302)  # Login success

                # Assert that the user has only 1 address, which gets created
                # automatically with the party
                self.assertEqual(len(registered_user.party.addresses), 1)
                existing_address, = registered_user.party.addresses

                response = c.get(
                    '/en_US/edit-address/%d' % existing_address.id
                )
                self.assertTrue('ID:%s' % existing_address.id in response.data)

                # POST to the existing address must updatethe existing address
                response = c.post(
                    '/en_US/edit-address/%d' % existing_address.id,
                    data=address_data
                )
                self.assertEqual(response.status_code, 302)

                # Assert that the user has only 1 address, which gets created
                # automatically with the party
                self.assertEqual(len(registered_user.party.addresses), 1)

                address = self.address_obj(existing_address.id)
                self.assertEqual(address.name, address_data['name'])
                self.assertEqual(address.street, address_data['street'])
                self.assertEqual(address.streetbis, address_data['streetbis'])
                self.assertEqual(address.zip, address_data['zip'])
                self.assertEqual(address.city, address_data['city'])
                self.assertEqual(address.email, address_data['email'])
                self.assertEqual(address.phone, address_data['phone'])
                self.assertEqual(address.country.id, address_data['country'])
                self.assertEqual(
                    address.subdivision.id, address_data['subdivision']
                )

    def test_0030_view_addresses(self):
        """
        Display a list of all addresses
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                response = c.post(
                    '/en_US/login',
                    data={
                        'email': 'email@example.com',
                        'password': 'password',
                    }
                )
                self.assertEqual(response.status_code, 302)  # Login success

            with app.test_client() as c:
                response = c.get('/en_US/view-address')
                self.assertEqual(response.status_code, 302)  # Redir to login

    def test_0040_country_list(self):
        """
        Check if the website countries are there in country list
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()
            with app.test_client() as c:
                response = c.get('/en_US/countries')
                self.assertEqual(response.status_code, 200)  # Login success
                self.assertEqual(len(json.loads(response.data)['result']), 5)

    def test_0050_subdivision_list(self):
        """
        Check if a country's subdivisions are returned
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            # Set in :meth:`setup_defaults`
            countries = filter(
                lambda c: c.subdivisions, self.available_countries
            )
            country = countries[0]

            with app.test_client() as c:
                response = c.get('/en_US/subdivisions?country=%d' % country)
                self.assertNotEqual(
                    len(json.loads(response.data)['result']), 0
                )

    def test_0060_contact_mechanism(self):
        """
        Add an contact mechanism for the user.
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            contact_data = {
                'party': self.registered_user.party.id,
                'type': 'irc',
                'value': 'Value',
                'comment': 'Comment',
            }

            with app.test_client() as c:
                response = c.post(
                    '/en_US/login',
                    data={
                        'email': 'email@example.com',
                        'password': 'password',
                    }
                )
                self.assertEqual(response.status_code, 302)  # Login success

                # Add a new contact mechanism
                response = c.post(
                    '/en_US/contact-mechanisms/add', data=contact_data
                )
                self.assertEqual(response.status_code, 302)

                self.assertEqual(
                    len(self.registered_user.party.contact_mechanisms), 1
                )
                self.assertEqual(contact_data['type'], 'irc')
                self.assertEqual(contact_data['value'], 'Value')
                self.assertEqual(contact_data['comment'], 'Comment')


def suite():
    "Nereid test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestAddress)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_auth
#!/usr/bin/env python
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import urllib
import unittest
import base64
import json

from mock import patch
import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from trytond.transaction import Transaction
from trytond.tools import get_smtp_server
from trytond.config import CONFIG
from nereid.testing import NereidTestCase
from nereid import permissions_required
from werkzeug.exceptions import Forbidden

CONFIG['smtp_from'] = 'from@xyz.com'


class TestAuth(NereidTestCase):
    """
    Test Authentication Layer
    """

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.nereid_website_locale_obj = POOL.get('nereid.website.locale')
        self.nereid_permission_obj = POOL.get('nereid.permission')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.currency_obj = POOL.get('currency.currency')
        self.language_obj = POOL.get('ir.lang')
        self.party_obj = POOL.get('party.party')

        # Patch SMTP Lib
        self.smtplib_patcher = patch('smtplib.SMTP', autospec=True)
        self.PatchedSMTP = self.smtplib_patcher.start()
        self.mocked_smtp_instance = self.PatchedSMTP.return_value

    def tearDown(self):
        # Unpatch SMTP Lib
        self.smtplib_patcher.stop()

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'party': self.party,
            'currency': usd,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])

        url_map, = self.url_map_obj.search([], limit=1)
        en_us, = self.language_obj.search([('code', '=', 'en_US')])
        currency, = self.currency_obj.search([('code', '=', 'USD')])
        locale, = self.nereid_website_locale_obj.create([{
            'code': 'en_US',
            'language': en_us,
            'currency': currency,
        }])
        self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map,
            'company': self.company,
            'application_user': USER,
            'default_locale': locale,
            'guest_user': self.guest_user,
        }])
        self.templates = {
            'home.jinja': '{{get_flashed_messages()}}',
            'login.jinja':
            '{{ login_form.errors }} {{get_flashed_messages()}}',
            'registration.jinja':
            '{{ form.errors }} {{get_flashed_messages()}}',
            'reset-password.jinja': '{{get_flashed_messages()}}',
            'change-password.jinja':
            '''{{ change_password_form.errors }}
            {{get_flashed_messages()}}''',
            'address-edit.jinja': 'Address Edit {{ form.errors }}',
            'address.jinja': '',
            'account.jinja': '',
            'profile.jinja': '{{ request.nereid_user.display_name }}',
            'emails/activation-text.jinja': 'activation-email-text',
            'emails/activation-html.jinja': 'activation-email-html',
            'emails/reset-text.jinja': 'reset-email-text',
            'emails/reset-html.jinja': 'reset-email-html',
        }

    def get_template_source(self, name):
        """
        Return templates
        """

        return self.templates.get(name)

    def test_0005_mock_setup(self):
        assert get_smtp_server() is self.PatchedSMTP.return_value

    def test_0010_register(self):
        """
        Registration must create a new party
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/registration')
                self.assertEqual(response.status_code, 200)   # GET Request

                data = {
                    'name': 'Registered User',
                    'email': 'regd_user@openlabs.co.in',
                    'password': 'password'
                }
                # Post with missing password
                response = c.post('/registration', data=data)
                self.assertEqual(response.status_code, 200)  # Form rejected

                data['confirm'] = 'password'
                response = c.post('/registration', data=data)
                self.assertEqual(response.status_code, 302)

                self.assertEqual(
                    self.mocked_smtp_instance.sendmail.call_count, 1
                )
                self.assertEqual(
                    self.mocked_smtp_instance.sendmail.call_args[0][0],
                    CONFIG['smtp_from']
                )
                self.assertEqual(
                    self.mocked_smtp_instance.sendmail.call_args[0][1],
                    [data['email']]
                )

            self.assertEqual(
                self.party_obj.search(
                    [('name', '=', data['name'])], count=True
                ), 1
            )

            with Transaction().set_context(active_test=False):
                self.assertEqual(
                    self.nereid_user_obj.search(
                        [('email', '=', data['email'])], count=True
                    ), 1
                )

            # Try to register the same user again
            response = c.post('/registration', data=data)
            self.assertEqual(response.status_code, 200)
            self.assertTrue(
                "A registration already exists with this email" in response.data
            )

    def test_0015_register_json(self):
        """
        Registration must create a new party.

        Same as registration test but with json data
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/registration')
                self.assertEqual(response.status_code, 200)   # GET Request

                data = {
                    'name': 'Registered User',
                    'email': 'regd_user@openlabs.co.in',
                    'password': 'password'
                }
                # Post with missing password
                response = c.post(
                    '/registration', data=json.dumps(data),
                    content_type='application/json'
                )
                self.assertEqual(response.status_code, 400)  # Form rejected

                data['confirm'] = 'password'
                response = c.post(
                    '/registration',
                    data=json.dumps(data),
                    content_type='application/json'
                )
                self.assertEqual(response.status_code, 201)

                self.assertEqual(
                    self.mocked_smtp_instance.sendmail.call_count, 1
                )
                self.assertEqual(
                    self.mocked_smtp_instance.sendmail.call_args[0][0],
                    CONFIG['smtp_from']
                )
                self.assertEqual(
                    self.mocked_smtp_instance.sendmail.call_args[0][1],
                    [data['email']]
                )

            self.assertEqual(
                self.party_obj.search(
                    [('name', '=', data['name'])], count=True
                ), 1
            )

            with Transaction().set_context(active_test=False):
                self.assertEqual(
                    self.nereid_user_obj.search(
                        [('email', '=', data['email'])], count=True
                    ), 1
                )

            # Try to register the same user again
            response = c.post(
                '/registration',
                data=json.dumps(data),
                content_type='application/json'
            )
            self.assertEqual(response.status_code, 400)
            self.assertTrue(
                "A registration already exists with this email" in response.data
            )

    def test_0015_match_password(self):
        """
        Assert that matching of password works
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            usd, = self.currency_obj.create([{
                'name': 'US Dollar',
                'code': 'USD',
                'symbol': '$',
            }])
            party, = self.party_obj.create([{
                'name': 'Openlabs',
            }])
            company, = self.company_obj.create([{
                'party': party,
                'currency': usd,
            }])
            registered_user_party = self.party_obj(name='Registered User')
            registered_user_party.save()
            registered_user, = self.nereid_user_obj.create([{
                'party': registered_user_party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': company,
            }])
            self.assertTrue(registered_user.match_password('password'))

    def test_0015_verify_email(self):
        """
        Check that the verification of email is working
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                data = {
                    'name': 'Registered User',
                    'email': 'regd_user@openlabs.co.in',
                    'password': 'password',
                    'confirm': 'password',
                }
                data['confirm'] = 'password'
                response = c.post('/registration', data=data)
                self.assertEqual(response.status_code, 302)

                with Transaction().set_context(active_test=False):
                    registered_user, = self.nereid_user_obj.search(
                        [('email', '=', data['email'])]
                    )
                self.assertFalse(registered_user.email_verified)

                # Verify the email with invaild code
                invalid_code = "thisisinvalidcode"
                response = c.get(
                    '/verify-email/%s/%s' %
                    (registered_user.id, invalid_code)
                )
                self.assertEqual(response.status_code, 302)
                self.assertFalse(registered_user.email_verified)

                # verify the email
                response = c.get(registered_user.get_email_verification_link())
                self.assertEqual(response.status_code, 302)

                # Email should now be verified
                self.assertTrue(registered_user.email_verified)

    def test_0020_activation(self):
        """
        Activation must happen before login is possible
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                data = {
                    'name': 'Registered User',
                    'email': 'regd_user@openlabs.co.in',
                    'password': 'password',
                    'confirm': 'password',
                }
                data['confirm'] = 'password'
                response = c.post('/registration', data=data)
                self.assertEqual(response.status_code, 302)

                with Transaction().set_context(active_test=False):
                    registered_user, = self.nereid_user_obj.search(
                        [('email', '=', data['email'])]
                    )
                self.assertFalse(registered_user.active)

                # Login should fail since there is activation code
                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': data['password'],
                    }
                )
                self.assertEqual(response.status_code, 200)
                self.assertTrue(
                    "Your account has not been activated yet" in response.data
                )

                # Activate the account
                response = c.get(registered_user.get_activation_link())
                self.assertEqual(response.status_code, 302)
                registered_user = self.nereid_user_obj(registered_user.id)

                # The account must be active
                self.assertTrue(registered_user.active)
                # Email should be verified
                self.assertTrue(registered_user.email_verified)

                # Login should work
                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': data['password'],
                    }
                )
                registered_user = self.nereid_user_obj(registered_user.id)
                self.assertEqual(response.status_code, 302)

    def test_0030_change_password(self):
        """
        Check password changing functionality
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                # try the page without login
                response = c.get('/change-password')
                self.assertEqual(response.status_code, 302)

                # try the post without login
                response = c.post('/change-password', data={
                    'password': data['password'],
                    'confirm': data['password']
                })
                self.assertEqual(response.status_code, 302)

                # Login now
                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': data['password']
                    })
                self.assertEqual(response.status_code, 302)

                # send wrong password confirm
                response = c.post('/change-password', data={
                    'password': 'new-password',
                    'confirm': 'password'
                })
                self.assertEqual(response.status_code, 200)
                self.assertTrue("Passwords must match" in response.data)

                # send correct password confirm but not old password
                response = c.post('/change-password', data={
                    'password': 'new-password',
                    'confirm': 'new-password'
                })
                self.assertEqual(response.status_code, 200)

                # send correct password confirm but not old password
                response = c.post('/change-password', data={
                    'old_password': 'passw',
                    'password': 'new-password',
                    'confirm': 'new-password'
                })
                self.assertEqual(response.status_code, 200)
                self.assertTrue(
                    "The current password you entered is invalid"
                    in response.data
                )

                response = c.post('/change-password', data={
                    'old_password': data['password'],
                    'password': 'new-password',
                    'confirm': 'new-password'
                })
                self.assertEqual(response.status_code, 302)
                response = c.get('/')

                # Login now using new password
                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': 'new-password'
                    })
                self.assertEqual(response.status_code, 302)

    def test_0040_reset_account(self):
        """
        Allow resetting password of the user
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            regd_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:

                # Try reset without login and page should render
                response = c.get('/reset-account')
                self.assertEqual(response.status_code, 200)

                # Try resetting password through email
                response = c.post('/reset-account', data={
                    'email': data['email'],
                })
                self.assertEqual(response.status_code, 302)

                # A successful login after requesting activation code should
                # not do anything but just allow login
                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': data['password'],
                    }
                )
                self.assertEqual(response.status_code, 302)

            with app.test_client() as c:
                # Try to reset again - with good intentions
                response = c.post('/reset-account', data={
                    'email': data['email'],
                })
                self.assertEqual(response.status_code, 302)

                # Try to reset password with invalid code
                invalid_code = 'thisistheinvalidcode'
                response = c.post(
                    '/new-password/%s/%s' % (regd_user.id, invalid_code),
                    data={
                        'password': 'reset-password',
                        'confirm': 'reset-password'
                    }
                )
                self.assertEqual(response.status_code, 302)

                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': 'reset-password'
                    }
                )
                self.assertEqual(response.status_code, 200)  # Login rejected

                # Reset password with valid code
                response = c.post(regd_user.get_reset_password_link(), data={
                    'password': 'reset-password',
                    'confirm': 'reset-password'
                })
                self.assertEqual(response.status_code, 302)

                regd_user = self.nereid_user_obj(regd_user.id)

                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': 'wrong-password'
                    }
                )
                self.assertEqual(response.status_code, 200)     # Login rejected

                response = c.post(
                    '/login',
                    data={
                        'email': data['email'],
                        'password': 'reset-password'
                    }
                )
                self.assertEqual(response.status_code, 302)     # Login approved

            with app.test_client() as c:
                # Try to reset again - with bad intentions

                # Bad request because there is no email
                response = c.post('/reset-account', data={})
                self.assertEqual(response.status_code, 400)

                # Bad request because there is empty email
                response = c.post('/reset-account', data={'email': ''})
                self.assertEqual(response.status_code, 200)
                self.assertTrue(
                    'Invalid email address' in response.data
                )

            data = {
                'party': party,
                'display_name': 'User without email',
                'email': '',
                'password': 'password',
                'company': self.company,
            }
            email_less_user, = self.nereid_user_obj.create([data.copy()])
            with app.test_client() as c:
                # Bad request because there is empty email
                # this is a special case where there is an user
                # with empty email
                response = c.post('/reset-account', data={'email': ''})
                self.assertEqual(response.status_code, 200)
                self.assertTrue(
                    'Invalid email address' in response.data
                )

    def test_0050_logout(self):
        """
        Check for logout
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                response = c.get("/account")
                self.assertEqual(response.status_code, 302)

                # Login and check again
                response = c.post(
                    '/login',
                    data={'email': data['email'], 'password': data['password']}
                )
                self.assertEqual(response.status_code, 302)

                response = c.get("/account")
                self.assertEqual(response.status_code, 200)

                response = c.get("/logout")
                self.assertEqual(response.status_code, 302)

                response = c.get("/account")
                self.assertEqual(response.status_code, 302)

    def test_0060_has_perm(self):
        """Test the has_perm decorator
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            @permissions_required(['admin'])
            def test_permission_1():
                return True

            with app.test_request_context():
                self.assertRaises(Forbidden, test_permission_1)

            perm_admin, = self.nereid_permission_obj.create([{
                'name': 'Admin',
                'value': 'admin',
            }])
            perm_nereid_admin, = self.nereid_permission_obj.create([{
                'name': 'Nereid Admin',
                'value': 'nereid_admin',
            }])

    def test_0070_gravatar(self):
        """
        Check if the gravatar is returned by the profile picture
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            self.templates['home.jinja'] = """
            {{ request.nereid_user.get_profile_picture() }}
            """

            with app.test_client() as c:
                response = c.get('/')
                self.assertTrue(
                    'http://www.gravatar.com/avatar/' in response.data
                )

    def test_0090_profile(self):
        """
        Test the profile functionality
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                response = c.get('/me')
                self.assertEqual(response.status_code, 302)

                # Login and check again
                response = c.post(
                    '/login',
                    data={'email': data['email'], 'password': data['password']}
                )
                response = c.get('/me')
                self.assertEqual(response.data, data['display_name'])

                # Change the display name of the user
                response = c.post(
                    '/me', data={
                        'display_name': 'Regd User',
                        'timezone': 'UTC',
                        'email': 'cannot@openlabs.co.in',
                    }
                )
                self.assertEqual(response.status_code, 200)
                self.assertEqual(response.data, 'Regd User')

    def test_0100_has_permission(self):
        '''
        Test the functionality of has_permissions
        '''
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            p1, p2, p3, p4 = self.nereid_permission_obj.create([
                {'name': 'p1', 'value': 'nereid.perm1'},
                {'name': 'p2', 'value': 'nereid.perm2'},
                {'name': 'p3', 'value': 'nereid.perm3'},
                {'name': 'p4', 'value': 'nereid.perm4'},
            ])
            self.nereid_user_obj.write(
                [self.guest_user],
                {
                    'permissions': [
                        ('add', [p1, p2])
                    ]
                }
            )

            # all = [], any = [] = True
            self.assertTrue(self.guest_user.has_permissions())

            # all = [p1, p2], any = [] == True
            self.assertTrue(self.guest_user.has_permissions(
                perm_all=[p1.value, p2.value]
            ))

            # all = [p1, p2], any = [p3, p4] == False
            self.assertFalse(self.guest_user.has_permissions(
                perm_all=[p1.value, p2.value],
                perm_any=[p3.value, p4.value]
            ))

            # all = [p1, p3], any = [] == False
            self.assertFalse(self.guest_user.has_permissions(
                perm_all=[p1.value, p3.value],
            ))

            # all = [p1, p3], any = [p1, p3, p4] == False
            self.assertFalse(self.guest_user.has_permissions(
                perm_all=[p1.value, p3.value],
                perm_any=[p1.value, p3.value, p4.value]
            ))

            # all = [p1, p2], any = [p1, p3, p4] == True
            self.assertTrue(self.guest_user.has_permissions(
                perm_all=[p1.value, p2.value],
                perm_any=[p1.value, p3.value, p4.value]
            ))

            # all = [], any = [p1, p2, p3] == True
            self.assertTrue(self.guest_user.has_permissions(
                perm_any=[p1.value, p2.value, p3.value]
            ))

            # all = [], any = [p3, p4] == False
            self.assertFalse(self.guest_user.has_permissions(
                perm_any=[p3.value, p4.value]
            ))

    def test_0110_user_management(self):
        """
        ensure that the cookie gets cleared if the user in session
        is invalid.
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                # Login and check again
                response = c.post(
                    '/login',
                    data={'email': data['email'], 'password': data['password']}
                )
                response = c.get('/me')
                self.assertEqual(response.data, data['display_name'])

                # Delete the user
                self.nereid_user_obj.delete([nereid_user])

                response = c.get('/me')
                self.assertEqual(response.status_code, 302)

    def test_200_basic_authentication(self):
        """
        Test if basic authentication works
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                # Login without any auth
                response = c.get('/me')
                self.assertEqual(response.status_code, 302)

                # Login with wrong basic auth
                basic_auth = base64.b64encode(b'email@example.com:oops')
                response = c.get('/me', headers={
                    'Authorization': 'Basic ' +
                    basic_auth.decode('utf-8').strip('\r\n')
                })
                self.assertEqual(response.status_code, 302)

                # Send the same request with correct basic authentication
                basic_auth = base64.b64encode(b'email@example.com:password')
                response = c.get(
                    '/me', headers={
                        'Authorization': 'Basic ' + basic_auth.decode(
                            'utf-8').strip('\r\n')
                    }
                )
                self.assertEqual(response.data, data['display_name'])

    def test_210_token_authentication(self):
        """
        Test if token authentication works
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                # Login without any auth
                response = c.get('/me')
                self.assertEqual(response.status_code, 302)

                # Login with wrong token auth
                token = "something i thought would just work ;-)"
                response = c.get('/me', headers={
                    'Authorization': 'token ' + token
                })
                self.assertEqual(response.status_code, 302)

                # Send the same request with correct token authentication
                response = c.get(
                    '/me', headers={
                        'Authorization': 'token ' + nereid_user.get_auth_token()
                    }
                )
                self.assertEqual(response.data, data['display_name'])

                # Send the same request with correct token authentication
                # but using capital 'T' in 'Token'
                response = c.get(
                    '/me', headers={
                        'Authorization': 'Token ' + nereid_user.get_auth_token()
                    }
                )
                self.assertEqual(response.data, data['display_name'])

    def test_0300_test_is_guest_user(self):
        """
        Ensure that is_guest_user works
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            self.templates['home.jinja'] = '{{ request.is_guest_user }}'

            with app.test_client() as c:
                self.assertEqual(c.get('/').data, 'True')
                c.post(
                    '/login',
                    data={'email': data['email'], 'password': data['password']}
                )
                self.assertEqual(c.get('/').data, 'False')

    def test_0400_auth_xhr_wrong(self):
        """
        Ensure that auth in XHR sends the right results
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                self.assertEqual(c.get('/me').status_code, 302)

                rv = c.post(
                    '/login',
                    data={'email': data['email'], 'password': 'wrong'},
                    headers={'X-Requested-With': 'XMLHTTPRequest'}
                )
                self.assertEqual(rv.status_code, 401)
                self.assertEqual(
                    json.loads(rv.data), {'message': 'Bad credentials'}
                )
                self.assertEqual(c.get('/me').status_code, 302)

    def test_0410_auth_xhr_valid(self):
        """
        Ensure that auth in XHR sends the right results
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                self.assertEqual(c.get('/me').status_code, 302)

                rv = c.post(
                    '/login',
                    data={'email': data['email'], 'password': data['password']},
                    headers={'X-Requested-With': 'XMLHTTPRequest'}
                )
                self.assertEqual(rv.status_code, 200)
                data = json.loads(rv.data)

                self.assertTrue(data['success'])
                self.assertTrue('user' in data)

                self.assertEqual(c.get('/me').status_code, 200)

    def test_0420_auth_token_basic(self):
        """
        Try to get authentication token with basic auth
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                self.assertEqual(c.get('/me').status_code, 302)

                # wrong credentials first
                basic_auth = base64.b64encode(b'email@example.com:oops')
                rv = c.post('/login/token', headers={
                    'Authorization': 'Basic ' +
                        basic_auth.decode('utf-8').strip('\r\n'),
                    'X-Requested-With': 'XMLHTTPRequest',
                })
                self.assertEqual(rv.status_code, 401)
                self.assertEqual(
                    json.loads(rv.data), {'message': 'Bad credentials'}
                )

                # Send right credentials
                basic_auth = base64.b64encode(b'email@example.com:password')
                rv = c.post('/login/token', headers={
                    'Authorization': 'Basic ' +
                        basic_auth.decode('utf-8').strip('\r\n'),
                    'X-Requested-With': 'XMLHTTPRequest',
                })
                self.assertEqual(rv.status_code, 200)
                data = json.loads(rv.data)

                self.assertTrue('user' in data)
                self.assertTrue('token' in data)

    def test_0430_remember_me(self):
        """
        Ensure that remember me in login is working
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            party, = self.party_obj.create([{'name': 'Registered user'}])
            data = {
                'party': party,
                'display_name': 'Registered User',
                'email': 'email@example.com',
                'password': 'password',
                'company': self.company,
            }
            nereid_user, = self.nereid_user_obj.create([data.copy()])

            with app.test_client() as c:
                response = c.post(
                    '/login',
                    data={
                        'email': data['email'], 'password': data['password'],
                        'remember': ''
                    }
                )
                self.assertEqual(response.status_code, 302)

                response = c.get('/me')
                self.assertEqual(response.status_code, 200)

                with c.session_transaction() as sess:
                    sess.clear()

                response = c.get("/me")
                self.assertEqual(response.status_code, 302)
                self.assertEqual(
                        urllib.unquote(response.location),
                        'http://localhost/login?next=/me'
                )

                response = c.post(
                    '/login',
                    data={
                        'email': data['email'], 'password': data['password'],
                        'remember': 'True'
                    }
                )
                self.assertEqual(response.status_code, 302)

                response = c.get("/me")
                self.assertEqual(response.status_code, 200)

                with c.session_transaction() as sess:
                    sess.clear()

                response = c.get("/me")
                self.assertEqual(response.status_code, 200)


def suite():
    "Nereid test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestAuth)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_country
# -*- coding: utf-8 -*-
"""
    Test Country

    :copyright: (c) 2014 by Openlabs Technologies & Consulting (P) Limited
    :license: BSD, see LICENSE for more details.
"""
import json
import unittest
from decimal import Decimal

import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from nereid.testing import NereidTestCase
from trytond.transaction import Transaction


class TestCountry(NereidTestCase):
    """
    Test Country
    """

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.nereid_website_locale_obj = POOL.get('nereid.website.locale')
        self.nereid_permission_obj = POOL.get('nereid.permission')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.currency_obj = POOL.get('currency.currency')
        self.language_obj = POOL.get('ir.lang')
        self.party_obj = POOL.get('party.party')
        self.Country = POOL.get('country.country')
        self.Subdivision = POOL.get('country.subdivision')

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
            'rates': [('create', [{'rate': Decimal('1')}])],
        }])
        eur, = self.currency_obj.create([{
            'name': 'Euro',
            'code': 'EUR',
            'symbol': 'E',
            'rates': [('create', [{'rate': Decimal('2')}])],
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'currency': usd,
            'party': self.party,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])
        c1, = self.currency_obj.create([{
            'code': 'C1',
            'symbol': 'C1',
            'name': 'Currency 1',
            'rates': [('create', [{'rate': Decimal('10')}])],

        }])
        c2, = self.currency_obj.create([{
            'code': 'C2',
            'symbol': 'C2',
            'name': 'Currency 2',
            'rates': [('create', [{'rate': Decimal('20')}])],
        }])
        self.lang_currency, = self.currency_obj.create([{
            'code': 'C3',
            'symbol': 'C3',
            'name': 'Currency 3',
            'rates': [('create', [{'rate': Decimal('30')}])],
        }])
        self.currency_obj.create([{
            'code': 'C4',
            'symbol': 'C4',
            'name': 'Currency 4',
            'rates': [('create', [{'rate': Decimal('40')}])],
        }])
        self.website_currencies = [c1, c2]
        url_map, = self.url_map_obj.search([], limit=1)
        self.en_us, = self.language_obj.search([('code', '=', 'en_US')])
        self.es_es, = self.language_obj.search([('code', '=', 'es_ES')])
        self.usd, = self.currency_obj.search([('code', '=', 'USD')])
        self.eur, = self.currency_obj.search([('code', '=', 'EUR')])
        locale_en_us, locale_es_es = self.nereid_website_locale_obj.create([{
            'code': 'en_US',
            'language': self.en_us,
            'currency': self.usd,
        }, {
            'code': 'es_ES',
            'language': self.es_es,
            'currency': self.eur,
        }])
        self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map,
            'company': self.company,
            'application_user': USER,
            'default_locale': locale_en_us.id,
            'guest_user': self.guest_user.id,
            'currencies': [('set', self.website_currencies)],
        }])
        self.templates = {
            'home.jinja': '{{ "hell" }}',
        }

    def test_0010_all_countries(self):
        """
        Check list of json serialized countries
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            self.Country.create([{
                'name': 'India',
                'code': 'IN'
            }, {
                'name': 'Australia',
                'code': 'AU',
            }])

            with app.test_client() as c:
                rv = c.get('/all-countries')
                self.assertEqual(rv.status_code, 200)
                data = json.loads(rv.data)
                self.assertEqual(len(data['countries']), 2)

    def test_0010_subdivisions(self):
        """
        Check subdivisons for given country
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            country1, country2, = self.Country.create([{
                'name': 'India',
                'code': 'IN'
            }, {
                'name': 'Australia',
                'code': 'AU',
            }])

            # Create subdivision only for country1
            self.Subdivision.create([{
                'country': country1.id,
                'code': 'IN-OR',
                'name': 'Orissa',
                'type': 'state',
            }])

            with app.test_client() as c:
                rv = c.get('/countries/%d/subdivisions' % country1.id)
                self.assertEqual(rv.status_code, 200)
                data = json.loads(rv.data)
                self.assertEqual(len(data['result']), 1)
                self.assertTrue(data['result'][0]['name'] == 'Orissa')
                self.assertTrue(data['result'][0]['code'] == 'IN-OR')

                rv = c.get('/countries/%d/subdivisions' % country2.id)
                self.assertEqual(rv.status_code, 200)
                data = json.loads(rv.data)
                self.assertEqual(len(data['result']), 0)


def suite():
    "Country test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestCountry)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_currency
#!/usr/bin/env python
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import unittest
from decimal import Decimal

import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from nereid.testing import NereidTestCase
from trytond.transaction import Transaction


class TestCurrency(NereidTestCase):
    """
    Test Currency
    """

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.nereid_website_locale_obj = POOL.get('nereid.website.locale')
        self.nereid_permission_obj = POOL.get('nereid.permission')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.currency_obj = POOL.get('currency.currency')
        self.language_obj = POOL.get('ir.lang')
        self.party_obj = POOL.get('party.party')

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
            'rates': [('create', [{'rate': Decimal('1')}])],
        }])
        eur, = self.currency_obj.create([{
            'name': 'Euro',
            'code': 'EUR',
            'symbol': 'E',
            'rates': [('create', [{'rate': Decimal('2')}])],
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'currency': usd,
            'party': self.party,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])
        c1, = self.currency_obj.create([{
            'code': 'C1',
            'symbol': 'C1',
            'name': 'Currency 1',
            'rates': [('create', [{'rate': Decimal('10')}])],

        }])
        c2, = self.currency_obj.create([{
            'code': 'C2',
            'symbol': 'C2',
            'name': 'Currency 2',
            'rates': [('create', [{'rate': Decimal('20')}])],
        }])
        self.lang_currency, = self.currency_obj.create([{
            'code': 'C3',
            'symbol': 'C3',
            'name': 'Currency 3',
            'rates': [('create', [{'rate': Decimal('30')}])],
        }])
        self.currency_obj.create([{
            'code': 'C4',
            'symbol': 'C4',
            'name': 'Currency 4',
            'rates': [('create', [{'rate': Decimal('40')}])],
        }])
        self.website_currencies = [c1, c2]
        url_map, = self.url_map_obj.search([], limit=1)
        self.en_us, = self.language_obj.search([('code', '=', 'en_US')])
        self.es_es, = self.language_obj.search([('code', '=', 'es_ES')])
        self.usd, = self.currency_obj.search([('code', '=', 'USD')])
        self.eur, = self.currency_obj.search([('code', '=', 'EUR')])
        locale_en_us, locale_es_es = self.nereid_website_locale_obj.create([{
            'code': 'en_US',
            'language': self.en_us,
            'currency': self.usd,
        }, {
            'code': 'es_ES',
            'language': self.es_es,
            'currency': self.eur,
        }])
        self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map,
            'company': self.company,
            'application_user': USER,
            'default_locale': locale_en_us.id,
            'locales': [('add', [locale_en_us.id, locale_es_es.id])],
            'guest_user': self.guest_user.id,
            'currencies': [('set', self.website_currencies)],
        }])
        self.templates = {
            'home.jinja': '{{ request.nereid_currency.id }}',
        }

    def get_template_source(self, name):
        """
        Return templates
        """
        return self.templates.get(name)

    def test_0010_currency_from_default_locale(self):
        """
        Do not set a currency for the language, and the fail over of
        picking currency from default locale.
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                rv = c.get('/en_us/')
                self.assertEqual(rv.status_code, 200)

            self.assertEqual(int(rv.data), self.usd.id)

            with app.test_request_context('/en_us/'):
                self.assertEqual(
                    self.currency_obj.convert(Decimal('100')), Decimal('100')
                )

    def test_0020_currency_from_locale(self):
        """
        Test and ensure that the currency is based on the locale
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                rv = c.get('/en_US/')
                self.assertEqual(rv.status_code, 200)
                self.assertEqual(int(rv.data), int(self.usd.id))

                rv = c.get('/es_ES/')
                self.assertEqual(rv.status_code, 200)
                self.assertEqual(int(rv.data), int(self.eur.id))

            with app.test_request_context('/en_US/'):
                self.assertEqual(
                    self.currency_obj.convert(Decimal('100')), Decimal('100')
                )

            with app.test_request_context('/es_ES/'):
                self.assertEqual(
                    self.currency_obj.convert(Decimal('100')), Decimal('200')
                )


def suite():
    "Currency test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestCurrency)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_i18n
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""

    Test the Internationalisation

    :copyright: (c) 2012-2013 by Openlabs Technologies & Consulting (P) Ltd.
    :license: GPLv3, see LICENSE for more details.
"""
import unittest

import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from nereid.testing import NereidTestCase
from nereid import render_template
from trytond.transaction import Transaction
from nereid.contrib.locale import make_lazy_gettext, make_lazy_ngettext

_ = make_lazy_gettext('nereid')
ngettext = make_lazy_ngettext('nereid')


class TestI18N(NereidTestCase):
    """
    Test the internationalisation
    """

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid_test')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.nereid_website_locale_obj = POOL.get('nereid.website.locale')
        self.nereid_permission_obj = POOL.get('nereid.permission')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.currency_obj = POOL.get('currency.currency')
        self.language_obj = POOL.get('ir.lang')
        self.party_obj = POOL.get('party.party')

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, eur = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
        }, {
            'name': 'Euro',
            'code': 'EUR',
            'symbol': 'â‚¬',
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'party': self.party,
            'currency': usd,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])
        url_map_id, = self.url_map_obj.search([], limit=1)
        en_us, = self.language_obj.search([('code', '=', 'en_US')])
        fr_fr, = self.language_obj.search([('code', '=', 'fr_FR')])
        usd, = self.currency_obj.search([('code', '=', 'USD')])
        locale, = self.nereid_website_locale_obj.create([{
            'code': 'en_US',
            'language': en_us,
            'currency': usd,
        }])
        locale_fr_FR, = self.nereid_website_locale_obj.create([{
            'code': 'fr_FR',
            'language': fr_fr,
            'currency': eur,
        }])
        self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map_id,
            'company': self.company.id,
            'application_user': USER,
            'default_locale': locale,
            'locales': [('add', [locale.id, locale_fr_FR.id])],
            'guest_user': self.guest_user.id,
        }])

    def set_translations(self):
        """
        Sets the translations
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')

        session_id, _, _ = TranslationSet.create()
        set_wizard = TranslationSet(session_id)
        set_wizard.transition_set_()

    def update_translations(self, language_code):
        """
        Update the translations for the language
        """
        TranslationUpdate = POOL.get('ir.translation.update', type='wizard')
        IRLanguage = POOL.get('ir.lang')

        session_id, _, _ = TranslationUpdate.create()
        update_wizard = TranslationUpdate(session_id)

        # set fr_FR  as translatable
        language, = IRLanguage.search([
            ('code', '=', language_code)
        ], limit=1)
        language.translatable = True
        language.save()

        update_wizard.start.language = language
        update_wizard.do_update(update_wizard.update.get_action())

    def get_template_source(self, name):
        """
        Return templates
        """
        templates = {
            'home.jinja': '{{get_flashed_messages()}}',
        }
        return templates.get(name)

    def test_0010_simple_txn(self):
        """
        Test if the translations work in a simple env
        """
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            s = _("en_US")
            self.assertEqual(s, u'en_US')

            # install translations
            self.set_translations()
            self.update_translations('fr_FR')

            # without setting a tranlsation looking for it gives en_US
            with Transaction().set_context(language="fr_FR"):
                self.assertEqual(s, u'en_US')

            # write a translation for it
            translation, = IRTranslation.search([
                ('module', '=', 'nereid'),
                ('src', '=', 'en_US'),
                ('lang', '=', 'fr_FR')
            ])
            translation.value = 'fr_FR'
            translation.save()

            with Transaction().set_context(language="fr_FR"):
                self.assertEqual(s, u'fr_FR')

    def test_0020_kwargs(self):
        """
        Test if kwargs work
        """
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            s = _("Hi %(name)s", name="Sharoon")
            self.assertEqual(s, u"Hi Sharoon")

            # install translations
            self.set_translations()
            self.update_translations('fr_FR')

            # without setting a tranlsation looking for it gives en_US
            with Transaction().set_context(language="fr_FR"):
                self.assertEqual(s, u'Hi Sharoon')

            # write a translation for it
            translation, = IRTranslation.search([
                ('module', '=', 'nereid'),
                ('src', '=', 'Hi %(name)s'),
                ('lang', '=', 'fr_FR')
            ])
            translation.value = 'Bonjour %(name)s'
            translation.save()

            with Transaction().set_context(language="fr_FR"):
                self.assertEqual(s, u'Bonjour Sharoon')

    def test_0030_ngettext(self):
        """
        Test if ngettext work
        """
        IRTranslation = POOL.get('ir.translation')

        singular = ngettext("%(num)d apple", "%(num)d apples", 1)
        plural = ngettext("%(num)d apple", "%(num)d apples", 2)

        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.assertEqual(singular, u"1 apple")
            self.assertEqual(plural, u"2 apples")

            # install translations
            self.set_translations()
            self.update_translations('fr_FR')

            # without setting a tranlsation looking for it gives en_US
            with Transaction().set_context(language="fr_FR"):
                self.assertEqual(singular, u"1 apple")
                self.assertEqual(plural, u"2 apples")

            # write a translation for singular
            translations = IRTranslation.search([
                ('module', '=', 'nereid'),
                ('src', '=', '%(num)d apple'),
                ('lang', '=', 'fr_FR')
            ])
            for translation in translations:
                translation.value = '%(num)d pomme'
                translation.save()

            # write a translation for it
            translations = IRTranslation.search([
                ('module', '=', 'nereid'),
                ('src', '=', '%(num)d apples'),
                ('lang', '=', 'fr_FR')
            ])
            for translation in translations:
                translation.value = '%(num)d pommes'
                translation.save()

            with Transaction().set_context(language="fr_FR"):
                self.assertEqual(singular, u"1 pomme")
                self.assertEqual(plural, u"2 pommes")

    def test_0110_template(self):
        """
        Test the working of translations in templates
        """
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            class User(object):
                def __init__(self, username):
                    self.username = username

                def __html__(self):
                    return self.username

            user = User('Sharoon')

            template_context = {
                'user': user,
                'username': user.username,
                'list': [1],
                'objname': _('name'),
                'apples': [1, 2],
            }

            def check_en_us(rv):
                self.assertTrue('There is 1 name object.' in rv)
                self.assertTrue('2 apples' in rv)
                self.assertTrue('<p>Hello Sharoon!</p>' in rv)

            def check_fr_fr(rv):
                self.assertTrue('There is 1 name in fr_FR object.' in rv)
                self.assertTrue('2 pommes' in rv)
                self.assertTrue('<p>Bonjour Sharoon!</p>' in rv)

            with app.test_request_context('/en_US/'):
                rv = unicode(render_template(
                    'tests/translation-test.html',
                    **template_context
                ))
                check_en_us(rv)

                with Transaction().set_context(language="fr_FR"):
                    # No translations set yet, so same thing
                    rv = unicode(render_template(
                        'tests/translation-test.html',
                        **template_context
                    ))
                    check_en_us(rv)

            # install translations
            self.set_translations()
            self.update_translations('fr_FR')

            # write french translations
            translation, = IRTranslation.search([
                ('module', '=', 'nereid_test'),
                ('type', '=', 'nereid_template'),
                ('src', '=', 'Hello %(username)s!'),
                ('lang', '=', 'fr_FR')
            ])
            translation.value = 'Bonjour %(username)s!'
            translation.save()

            translation, = IRTranslation.search([
                ('module', '=', 'nereid_test'),
                ('type', '=', 'nereid_template'),
                ('src', '=', '%(num)d apples'),
                ('lang', '=', 'fr_FR')
            ])
            translation.value = '%(num)d pommes'
            translation.save()

            translation, = IRTranslation.search([
                ('module', '=', 'nereid_test'),
                ('type', '=', 'nereid_template'),
                ('src', '=', 'Hello %(name)s!'),
                ('lang', '=', 'fr_FR')
            ])
            translation.value = 'Bonjour %(name)s!'
            translation.save()

            translation, = IRTranslation.search([
                ('module', '=', 'nereid'),
                ('name', '=', 'tests/test_i18n.py'),
                ('src', '=', 'name'),
                ('lang', '=', 'fr_FR')
            ])
            translation.value = 'name in fr_FR'
            translation.save()

            with app.test_request_context('/fr_FR/'):
                with Transaction().set_context(language="fr_FR"):
                    rv = unicode(render_template(
                        'tests/translation-test.html',
                        **template_context
                    ))
                    check_fr_fr(rv)


def suite():
    "Nereid test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestI18N)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_routing
# This file is part of Tryton & Nereid. The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import unittest
from decimal import Decimal

import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from trytond.transaction import Transaction
from nereid.testing import NereidTestCase


class TestRouting(NereidTestCase):
    'Test URL Routing'

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.locale_obj = POOL.get('nereid.website.locale')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.language_obj = POOL.get('ir.lang')
        self.currency_obj = POOL.get('currency.currency')
        self.country_obj = POOL.get('country.country')
        self.subdivision_obj = POOL.get('country.subdivision')
        self.party_obj = POOL.get('party.party')

        self.templates = {
            'home.jinja': '{{ Transaction().language }}',
        }

    def setup_defaults(self):
        """
        Setup the defaults
        """
        self.usd, self.eur = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
        }, {
            'name': 'Euro',
            'code': 'EUR',
            'symbol': 'E',
            'rates': [('create', [{'rate': Decimal('2')}])],
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'party': self.party,
            'currency': self.usd,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])
        party, = self.party_obj.create([{
            'name': 'Registered User',
        }])
        self.registered_user, = self.nereid_user_obj.create([{
            'party': party,
            'display_name': 'Registered User',
            'email': 'email@example.com',
            'password': 'password',
            'company': self.company,
        }])

        url_map_id, = self.url_map_obj.search([], limit=1)

        self.en_us, = self.language_obj.search([('code', '=', 'en_US')])
        self.es_es, = self.language_obj.search([('code', '=', 'es_ES')])
        self.locale_en_us, self.locale_es_es = self.locale_obj.create([{
            'code': 'en_US',
            'language': self.en_us,
            'currency': self.usd,
        }, {
            'code': 'es_ES',
            'language': self.es_es,
            'currency': self.eur,
        }])

        self.nereid_website, = self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map_id,
            'company': self.company,
            'application_user': USER,
            'default_locale': self.locale_en_us,
            'locales': [('add', [self.locale_en_us.id, self.locale_es_es.id])],
            'guest_user': self.guest_user,
        }])

    def get_template_source(self, name):
        """
        Return templates
        """
        return self.templates.get(name)

    def get_app(self):
        """
        Inject transaction into the template context for the home template
        """
        app = super(TestRouting, self).get_app()
        app.jinja_env.globals['Transaction'] = Transaction
        return app

    def test_0010_home_with_locales(self):
        """
        When accessing / for website with locales defined, there should be a
        redirect to the /locale
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/')
                self.assertEqual(response.status_code, 301)
                self.assertEqual(
                    response.location,
                    'http://localhost/%s' % self.locale_en_us.code
                )

            # Change the default locale to es_ES and then check
            self.nereid_website.default_locale = self.locale_es_es
            self.nereid_website.save()
            self.nereid_website.clear_url_adapter_cache()

            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/')
                self.assertEqual(response.status_code, 301)
                self.assertEqual(
                    response.location,
                    'http://localhost/%s' % self.locale_es_es.code
                )

    def test_0020_home_without_locales(self):
        """
        When accessed without locales the site should return 200 on /
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()

            # unset the locales
            self.nereid_website.locales = []
            self.nereid_website.save()

            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/')
                self.assertEqual(response.status_code, 200)
                self.assertEqual(response.data, 'en_US')

    def test_0030_lang_context_with_locale(self):
        """
        Test that the language available in the context is the right one
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/en_US/')
                self.assertEqual(response.data, 'en_US')

            with app.test_client() as c:
                response = c.get('/es_ES/')
                self.assertEqual(response.data, 'es_ES')

    def test_0040_lang_context_without_locale(self):
        """
        Test that the language available in the context is the right one
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()
            self.nereid_website.locales = []
            self.nereid_website.save()
            app = self.get_app()

            with app.test_client() as c:
                response = c.get('/')
                self.assertEqual(response.data, 'en_US')

            # Change the default locale to es_ES and then check
            self.nereid_website.default_locale = self.locale_es_es
            self.nereid_website.save()

            with app.test_client() as c:
                response = c.get('/')
                self.assertEqual(response.data, 'es_ES')


def suite():
    "Nereid test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestRouting)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_static_file
#!/usr/bin/env python
# -*- coding: utf-8 -*-
"""
    test_static_file

    Test the static file feature of nereid

    :copyright: (c) 2012-2013 by Openlabs Technologies & Consulting (P) LTD
    :license: GPLv3, see LICENSE for more details.
"""
import unittest

import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from trytond.transaction import Transaction
from trytond.pool import PoolMeta, Pool
from trytond.config import CONFIG
from nereid.testing import NereidTestCase
from nereid import render_template, route

CONFIG['smtp_server'] = 'smtpserver'
CONFIG['smtp_user'] = 'test@xyz.com'
CONFIG['smtp_password'] = 'testpassword'
CONFIG['smtp_port'] = 587
CONFIG['smtp_tls'] = True
CONFIG['smtp_from'] = 'from@xyz.com'
CONFIG.options['data_path'] = '/tmp/temp_tryton_data/'


class StaticFileServingHomePage:
    __metaclass__ = PoolMeta
    __name__ = 'nereid.website'

    @classmethod
    @route('/static-file-test')
    def static_file_test(cls):
        static_file_obj = Pool().get('nereid.static.file')

        static_file, = static_file_obj.search([])
        return render_template(
            'home.jinja',
            static_file_obj=static_file_obj,
            static_file_id=static_file.id
        )


class TestStaticFile(NereidTestCase):

    @classmethod
    def setUpClass(cls):
        Pool.register(
            StaticFileServingHomePage,
            module='nereid', type_='model'
        )
        POOL.init(update=True)

    @classmethod
    def tearDownClss(cls):
        mpool = Pool.classes['model'].setdefault('nereid', [])
        mpool.remove(StaticFileServingHomePage)
        POOL.init(update=True)

    def setUp(self):
        trytond.tests.test_tryton.install_module('nereid')

        self.nereid_website_obj = POOL.get('nereid.website')
        self.nereid_website_locale_obj = POOL.get('nereid.website.locale')
        self.nereid_user_obj = POOL.get('nereid.user')
        self.url_map_obj = POOL.get('nereid.url_map')
        self.company_obj = POOL.get('company.company')
        self.currency_obj = POOL.get('currency.currency')
        self.language_obj = POOL.get('ir.lang')
        self.country_obj = POOL.get('country.country')
        self.subdivision_obj = POOL.get('country.subdivision')
        self.party_obj = POOL.get('party.party')
        self.address_obj = POOL.get('party.address')
        self.contact_mech_obj = POOL.get('party.contact_mechanism')
        self.static_file_obj = POOL.get('nereid.static.file')
        self.static_folder_obj = POOL.get('nereid.static.folder')

        self.templates = {
            'home.jinja':
            '''
            {% set static_file = static_file_obj(static_file_id) %}
            {{ static_file.url }}
            ''',
        }

    def setup_defaults(self):
        """
        Setup the defaults
        """
        usd, = self.currency_obj.create([{
            'name': 'US Dollar',
            'code': 'USD',
            'symbol': '$',
        }])
        self.party, = self.party_obj.create([{
            'name': 'Openlabs',
        }])
        self.company, = self.company_obj.create([{
            'party': self.party,
            'currency': usd,
        }])
        self.guest_party, = self.party_obj.create([{
            'name': 'Guest User',
        }])
        self.guest_user, = self.nereid_user_obj.create([{
            'party': self.guest_party,
            'display_name': 'Guest User',
            'email': 'guest@openlabs.co.in',
            'password': 'password',
            'company': self.company.id,
        }])

        url_map_id, = self.url_map_obj.search([], limit=1)
        en_us, = self.language_obj.search([('code', '=', 'en_US')])
        currency, = self.currency_obj.search([('code', '=', 'USD')])
        locale, = self.nereid_website_locale_obj.create([{
            'code': 'en_US',
            'language': en_us,
            'currency': currency,
        }])
        self.nereid_website_obj.create([{
            'name': 'localhost',
            'url_map': url_map_id,
            'company': self.company,
            'application_user': USER,
            'default_locale': locale,
            'locales': [('add', [locale.id])],
            'guest_user': self.guest_user,
        }])

    def create_static_file(self, file_buffer):
        """
        Creates the static file for testing
        """
        folder_id, = self.static_folder_obj.create([{
            'folder_name': 'test',
            'description': 'Test Folder'
        }])

        return self.static_file_obj.create([{
            'name': 'test.png',
            'folder': folder_id,
            'file_binary': file_buffer,
        }])[0]

    def test_0010_static_file(self):
        """
        Create a static folder, and a static file
        And check if it can be fetched
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()

            file_buffer = buffer('test-content')
            static_file = self.create_static_file(file_buffer)
            self.assertEqual(static_file.file_binary, file_buffer)

            app = self.get_app()

            with app.test_client() as c:
                rv = c.get('/en_US/static-file/test/test.png')
                self.assertEqual(rv.status_code, 200)
                self.assertEqual(rv.data, 'test-content')
                self.assertEqual(rv.headers['Content-Type'], 'image/png')

    def test_0020_static_file_url(self):
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()

            file_buffer = buffer('test-content')
            file = self.create_static_file(file_buffer)
            self.assertFalse(file.url)

            app = self.get_app()
            with app.test_client() as c:
                rv = c.get('/en_US/static-file-test')
                self.assertEqual(rv.status_code, 200)
                self.assertTrue('/en_US/static-file/test/test.png' in rv.data)

    def test_0030_static_file_remote_url(self):
        """
        Test a static file with remote type
        """
        with Transaction().start(DB_NAME, USER, CONTEXT):
            self.setup_defaults()

            folder_id, = self.static_folder_obj.create([{
                'folder_name': 'test',
                'description': 'Test Folder'
            }])
            file, = self.static_file_obj.create([{
                'name': 'remote.png',
                'folder': folder_id,
                'type': 'remote',
                'remote_path': 'http://openlabs.co.in/logo.png',
            }])
            self.assertFalse(file.url)

            app = self.get_app()
            with app.test_client() as c:
                rv = c.get('/en_US/static-file-test')
                self.assertEqual(rv.status_code, 200)
                self.assertTrue(
                    'http://openlabs.co.in/logo.png' in rv.data
                )


def suite():
    "Nereid test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestStaticFile)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = test_translation
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import unittest
import trytond.tests.test_tryton
from trytond.tests.test_tryton import POOL, USER, DB_NAME, CONTEXT
from trytond.transaction import Transaction
from nereid.testing import NereidTestCase


class TestTranslation(NereidTestCase):
    'Test Translation'

    def setUp(self):
        # Install the test module which has bundled translations which can
        # be used for this test
        trytond.tests.test_tryton.install_module('nereid_test')

    def test_0010_nereid_template_extraction(self):
        """
        Test translation extaction from nereid templates
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            count_before = IRTranslation.search([
                ('type', '=', 'nereid_template')
            ], count=True)
            self.assertEqual(count_before, 0)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            count_after = IRTranslation.search([
                ('type', '=', 'nereid_template')
            ], count=True)

            self.assertTrue(count_after > count_before)

    def test_0020_nereid_code_extraction(self):
        """
        Ensure that templates are extracted from the code
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            count_before = IRTranslation.search([
                ('type', '=', 'nereid')
            ], count=True)
            self.assertEqual(count_before, 0)

            # Set the nereid translations alone
            set_wizard.set_nereid()

            count_after = IRTranslation.search([
                ('type', '=', 'nereid')
            ], count=True)

            self.assertTrue(count_after > count_before)

    def test_0030_wtforms_builtin_extraction(self):
        """
        Ensure that the builtin messages from wtforms are also extracted
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            count_before = IRTranslation.search([
                ('type', '=', 'wtforms')
            ], count=True)
            self.assertEqual(count_before, 0)

            # Set the wtforms translations alone
            set_wizard.set_wtforms()

            count_after = IRTranslation.search([
                ('type', '=', 'wtforms')
            ], count=True)

            self.assertTrue(count_after > count_before)

    def test_0040_template_gettext_using_(self):
        """
        Test for gettext without comment using _
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            # gettext with no comments and using _
            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', 'gettext')
            ])
            self.assertEqual(translation.comments, None)
            self.assertEqual(translation.res_id, 7)

    def test_0050_template_gettext_2(self):
        """
        Test for gettext with comment before it
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', 'gettext with comment b4')
            ])
            self.assertEqual(translation.comments, translation.src)
            self.assertEqual(translation.res_id, 10)

    def test_0060_template_gettext_3(self):
        """
        Test for gettext with comment inline
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', 'gettext with comment inline')
            ])
            self.assertEqual(translation.comments, translation.src)
            self.assertEqual(translation.res_id, 12)

    def test_0070_template_gettext_4(self):
        """
        Test for gettext using gettext instead of _
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', 'Hello World!')
            ])
            self.assertEqual(translation.comments, None)
            self.assertEqual(translation.res_id, 17)

    def test_0080_template_ngettext(self):
        """
        Test for ngettext
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', '%(num)d apple')
            ])
            self.assertEqual(translation.res_id, 20)

            # Look for plural
            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', '%(num)d apples')
            ])
            self.assertEqual(translation.res_id, 20)

    def test_0090_template_trans_tag(self):
        """
        Test for {% trans %}Hola {{ user }}!{% endtrans %} tag

        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            # XXX: See how {{ user }} changed to %(user)s
            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', 'Hello %(username)s!'),
            ])
            self.assertEqual(
                translation.comments, 'Translation with trans tag'
            )
            self.assertEqual(translation.res_id, 23)

    def test_0100_template_trans_tag_with_expr(self):
        """
        Test for
        {% trans user=user.username %}Hello {{ user }}!{% endtrans %} tag
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            # XXX: See how {{ user }} changed to %(user)s
            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', '=', 'Hello %(name)s!')
            ])
            self.assertEqual(
                translation.comments, 'Translation with an expression'
            )
            self.assertEqual(translation.res_id, 26)

    def test_0110_template_trans_tag_plural(self):
        """
        Test for

        {% trans count=list|length %}
        There is {{ count }} {{ name }} object.
        {% pluralize %}
        There are {{ count }} {{ name }} objects.
        {% endtrans %}

        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        IRTranslation = POOL.get('ir.translation')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)

            # Set the nereid_template translations alone
            set_wizard.set_nereid_template()

            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', 'ilike', '%There is %(count)s %(objname)s object.%'),
            ])
            self.assertEqual(
                translation.comments, 'trans tag with pluralisation'
            )
            self.assertEqual(translation.res_id, 29)

            # now look for the plural
            translation, = IRTranslation.search([
                ('type', '=', 'nereid_template'),
                ('module', '=', 'nereid_test'),
                ('src', 'ilike', '%There are %(count)s %(objname)s objects.%'),
            ])
            self.assertEqual(
                translation.comments, 'trans tag with pluralisation'
            )
            self.assertEqual(translation.res_id, 29)

    def test_0200_translation_clean(self):
        """
        Check if the cleaning of translations work
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        TranslationClean = POOL.get('ir.translation.clean', type='wizard')
        IRTranslation = POOL.get('ir.translation')
        IRModule = POOL.get('ir.module.module')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            # First create all the translations
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)
            set_wizard.transition_set_()

            # Uninstall nereid_test and there should be no translations
            # belonging to that module with type as nereid or
            # nereid_template
            nereid_test, = IRModule.search([('name', '=', 'nereid_test')])
            nereid_test.state = 'uninstalled'
            nereid_test.save()

            session_id, _, _ = TranslationClean.create()
            clean_wizard = TranslationClean(session_id)
            clean_wizard.transition_clean()

            count = IRTranslation.search([
                ('module', '=', 'nereid_test'),
                ('type', 'in', ('nereid', 'nereid_template'))
            ], count=True)
            self.assertEqual(count, 0)

    def test_0300_translation_update(self):
        """
        Check if the update does not break this functionality
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        TranslationUpdate = POOL.get('ir.translation.update', type='wizard')
        IRTranslation = POOL.get('ir.translation')
        IRLanguage = POOL.get('ir.lang')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            # First create all the translations
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)
            set_wizard.transition_set_()

            # set an additional language as translatable
            new_lang, = IRLanguage.search([
                ('translatable', '=', False)
            ], limit=1)
            new_lang.translatable = True
            new_lang.save()

            count_before = IRTranslation.search([], count=True)

            # Now update the translations
            session_id, _, _ = TranslationUpdate.create()
            update_wizard = TranslationUpdate(session_id)

            update_wizard.start.language = new_lang
            update_wizard.do_update(update_wizard.update.get_action())

            # check the count now
            count_after = IRTranslation.search([], count=True)
            self.assertEqual(count_after, count_before * 2)

    def test_0400_translation_export(self):
        """
        Export the translations and test
        """
        TranslationSet = POOL.get('ir.translation.set', type='wizard')
        TranslationUpdate = POOL.get('ir.translation.update', type='wizard')
        IRTranslation = POOL.get('ir.translation')
        IRLanguage = POOL.get('ir.lang')

        with Transaction().start(DB_NAME, USER, CONTEXT):
            # First create all the translations
            session_id, _, _ = TranslationSet.create()
            set_wizard = TranslationSet(session_id)
            set_wizard.transition_set_()

            # set an additional language as translatable
            new_lang, = IRLanguage.search([
                ('translatable', '=', False)
            ], limit=1)
            new_lang.translatable = True
            new_lang.save()

            # Now update the translations
            session_id, _, _ = TranslationUpdate.create()
            update_wizard = TranslationUpdate(session_id)

            update_wizard.start.language = new_lang
            update_wizard.do_update(update_wizard.update.get_action())

            # TODO: Check the contents of the po file
            IRTranslation.translation_export(new_lang.code, 'nereid_test')
            IRTranslation.translation_export(new_lang.code, 'nereid')


def suite():
    "Nereid test suite"
    test_suite = unittest.TestSuite()
    test_suite.addTests(
        unittest.TestLoader().loadTestsFromTestCase(TestTranslation)
    )
    return test_suite


if __name__ == '__main__':
    unittest.TextTestRunner(verbosity=2).run(suite())

########NEW FILE########
__FILENAME__ = translation
# -*- coding: utf-8 -*-
'''

    Add Translation support for Nereid

    :copyright: (c) 2013-14 by Openlabs Technologies & Consulting (P) Ltd.
    :copyright: (c) 2011-2012 NaN Projectes de Programari Lliure, S.L.
    :license: BSD, see LICENSE for more details

    This work is mostly inspired by the jasper_reports module of the tryton
    spain community.

'''
import os
import polib
import contextlib

import wtforms
from jinja2 import FileSystemLoader
from jinja2.ext import babel_extract, GETTEXT_FUNCTIONS
from babel.messages.extract import extract_from_dir
from trytond.model import fields
from trytond.wizard import Wizard
from trytond.transaction import Transaction
from trytond.pool import Pool, PoolMeta
from trytond.cache import Cache
from trytond.tools import file_open
from trytond.const import RECORD_CACHE_SIZE
from trytond.ir.translation import TrytonPOFile

__all__ = [
    'Translation',
    'TranslationSet',
    'TranslationUpdate',
    'TranslationClean',
]

__metaclass__ = PoolMeta


class Translation:
    __name__ = 'ir.translation'

    comments = fields.Text(
        'Comments', readonly=True,
        help='Comments/Hints for translator'
    )

    @classmethod
    def __setup__(cls):
        super(Translation, cls).__setup__()
        new_types = [
            ('nereid_template', 'Nereid Template'),
            ('wtforms', 'WTforms built-in Messages'),
            ('nereid', 'Nereid Code'),
        ]
        for nereid_type in new_types:
            if nereid_type not in cls.type.selection:
                cls.type.selection.append(nereid_type)

    @classmethod
    def translation_import(cls, lang, module, po_path):
        pool = Pool()
        ModelData = pool.get('ir.model.data')
        models_data = ModelData.search([
            ('module', '=', module),
        ])
        fs_id2prop = {}
        for model_data in models_data:
            fs_id2prop.setdefault(model_data.model, {})
            fs_id2prop[model_data.model][model_data.fs_id] = \
                (model_data.db_id, model_data.noupdate)
            for extra_model in cls.extra_model_data(model_data):
                fs_id2prop.setdefault(extra_model, {})
                fs_id2prop[extra_model][model_data.fs_id] = \
                    (model_data.db_id, model_data.noupdate)

        translations = set()
        to_create = []
        pofile = polib.pofile(po_path)

        id2translation = {}
        key2ids = {}
        module_translations = cls.search([
            ('lang', '=', lang),
            ('module', '=', module),
        ], order=[])
        for translation in module_translations:
            if translation.type in (
                    'odt', 'view', 'wizard_button',
                    'selection', 'error',
                    'nereid_template', 'wtforms', 'nereid'):
                key = (
                    translation.name,
                    translation.res_id,
                    translation.type,
                    translation.src,
                )
            elif translation.type in ('field', 'model', 'help'):
                key = (translation.name, translation.res_id, translation.type)
            else:
                raise Exception(
                    'Unknown translation type: %s' % translation.type
                )
            key2ids.setdefault(key, []).append(translation.id)
            if len(module_translations) <= RECORD_CACHE_SIZE:
                id2translation[translation.id] = translation

        def override_translation(ressource_id, new_translation, fuzzy):
            res_id_module, res_id = ressource_id.split('.')
            if res_id:
                model_data, = ModelData.search([
                    ('module', '=', res_id_module),
                    ('fs_id', '=', res_id),
                ])
                res_id = model_data.db_id
            else:
                res_id = -1
            with contextlib.nested(
                    Transaction().set_user(0),
                    Transaction().set_context(module=res_id_module)):
                translation, = cls.search([
                    ('name', '=', name),
                    ('res_id', '=', res_id),
                    ('lang', '=', lang),
                    ('type', '=', ttype),
                    ('module', '=', res_id_module),
                ])
                if translation.value != new_translation:
                    translation.value = new_translation
                    translation.overriding_module = module
                    translation.fuzzy = fuzzy
                    translation.save()

        # Make a first loop to retreive translation ids in the right order to
        # get better read locality and a full usage of the cache.
        translation_ids = []
        if len(module_translations) <= RECORD_CACHE_SIZE:
            processes = (True,)
        else:
            processes = (False, True)
        for processing in processes:
            if processing and len(module_translations) > RECORD_CACHE_SIZE:
                id2translation = dict(
                    (t.id, t) for t in cls.browse(translation_ids)
                )
            for entry in pofile:
                ttype, name, res_id = entry.msgctxt.split(':')
                src = entry.msgid
                value = entry.msgstr
                fuzzy = 'fuzzy' in entry.flags
                noupdate = False

                if '.' in res_id:
                    override_translation(res_id, value, fuzzy)
                    continue

                model = name.split(',')[0]
                if (model in fs_id2prop
                        and res_id in fs_id2prop[model]):
                    res_id, noupdate = fs_id2prop[model][res_id]

                if res_id:
                    try:
                        res_id = int(res_id)
                    except ValueError:
                        continue
                if not res_id:
                    res_id = -1

                if ttype in (
                        'odt', 'view', 'wizard_button', 'selection',
                        'error', 'nereid', 'nereid_template',
                        'wtforms'):
                    key = (name, res_id, ttype, src)
                elif ttype in('field', 'model', 'help'):
                    key = (name, res_id, ttype)
                else:
                    raise Exception('Unknown translation type: %s' % ttype)
                ids = key2ids.get(key, [])

                if not processing:
                    translation_ids.extend(ids)
                    continue

                with contextlib.nested(
                        Transaction().set_user(0),
                        Transaction().set_context(module=module)):
                    if not ids:
                        to_create.append({
                            'name': name,
                            'res_id': res_id,
                            'lang': lang,
                            'type': ttype,
                            'src': src,
                            'value': value,
                            'fuzzy': fuzzy,
                            'module': module,
                            'overriding_module': None,
                        })
                    else:
                        translations2 = []
                        for translation_id in ids:
                            translation = id2translation[translation_id]
                            if translation.value != value \
                                    or translation.fuzzy != fuzzy:
                                translations2.append(translation)
                        if translations2 and not noupdate:
                            cls.write(translations2, {
                                'value': value,
                                'fuzzy': fuzzy,
                            })
                        translations |= set(cls.browse(ids))

        if to_create:
            translations |= set(cls.create(to_create))

        if translations:
            all_translations = set(cls.search([
                ('module', '=', module),
                ('lang', '=', lang),
            ]))
            translations_to_delete = all_translations - translations
            cls.delete(list(translations_to_delete))
        return len(translations)

    @classmethod
    def translation_export(cls, lang, module):
        """
        Override the entire method just to avoid lookup for nereid
        related functionality.
        """
        pool = Pool()
        ModelData = pool.get('ir.model.data')
        Config = pool.get('ir.configuration')

        models_data = ModelData.search([
            ('module', '=', module),
        ])
        db_id2fs_id = {}
        for model_data in models_data:
            db_id2fs_id.setdefault(model_data.model, {})
            db_id2fs_id[model_data.model][model_data.db_id] = model_data.fs_id
            for extra_model in cls.extra_model_data(model_data):
                db_id2fs_id.setdefault(extra_model, {})
                db_id2fs_id[extra_model][model_data.db_id] = model_data.fs_id

        pofile = TrytonPOFile(wrapwidth=78)
        pofile.metadata = {
            'Content-Type': 'text/plain; charset=utf-8',
        }

        with Transaction().set_context(language=Config.get_language()):
            translations = cls.search([
                ('lang', '=', lang),
                ('module', '=', module),
            ], order=[])
        for translation in translations:
            if (translation.overriding_module
                    and translation.overriding_module != module):
                cls.raise_user_error('translation_overridden', {
                    'name': translation.name,
                    'name': translation.overriding_module,
                })
            flags = [] if not translation.fuzzy else ['fuzzy']
            trans_ctxt = '%(type)s:%(name)s:' % {
                'type': translation.type,
                'name': translation.name,
            }
            res_id = translation.res_id

            # This is the line where logic change is introduced by nereid
            nereid_types = ('nereid', 'nereid_template', 'wtforms')
            if res_id >= 0 and \
                    translation.type not in nereid_types:
                model, _ = translation.name.split(',')
                if model in db_id2fs_id:
                    res_id = db_id2fs_id[model].get(res_id)
                else:
                    continue
                trans_ctxt += '%s' % res_id
            entry = polib.POEntry(
                msgid=(translation.src or ''),
                msgstr=(translation.value or ''),
                msgctxt=trans_ctxt,
                flags=flags
            )
            pofile.append(entry)

        if pofile:
            pofile.sort()
            return unicode(pofile).encode('utf-8')
        else:
            return

    _nereid_translation_cache = Cache(
        'ir.translation', size_limit=10240, context=False
    )

    @classmethod
    def get_translation_4_nereid(cls, module, ttype, lang, source):
        "Return translation for source"
        ttype = unicode(ttype)
        lang = unicode(lang)
        source = unicode(source)

        cache_key = (lang, ttype, source, module)

        trans = cls._nereid_translation_cache.get(cache_key, -1)
        if trans != -1:
            return trans

        cursor = Transaction().cursor
        table = cls.__table__()
        where = (
            (table.lang == lang)
            & (table.type == ttype)
            & (table.value != '')
            & (table.value != None)
            & (table.fuzzy == False)
            & (table.src == source)
        )
        if module is not None:
            where &= (table.module == module)

        cursor.execute(*table.select(table.value, where=where))
        res = cursor.fetchone()
        if res:
            cls._nereid_translation_cache.set(cache_key, res[0])
            return res[0]
        else:
            cls._nereid_translation_cache.set(cache_key, False)
            return None

    @classmethod
    def delete(cls, translations):
        cls._nereid_translation_cache.clear()
        return super(Translation, cls).delete(translations)

    @classmethod
    def create(cls, vlist):
        cls._nereid_translation_cache.clear()
        return super(Translation, cls).create(vlist)

    @classmethod
    def write(cls, translations, values):
        cls._nereid_translation_cache.clear()
        return super(Translation, cls).write(translations, values)


class TranslationSet:
    __name__ = "ir.translation.set"

    def transition_set_(self):
        state = super(TranslationSet, self).transition_set_()
        self.set_nereid_template()
        self.set_wtforms()
        self.set_nereid()
        return state

    @classmethod
    def _get_nereid_template_extract_options(cls):
        """
        a dictionary of additional options that can be passed on to
        `jinja2.ext.babel_extract`.
        """
        return {
            'extensions': ','.join([
                'jinja2.ext.i18n',
                'nereid.templating.FragmentCacheExtension'
            ]),
        }

    @classmethod
    def _get_installed_module_directories(cls):
        """
        A generator that yields tuples of the format (module_name, directory)
        for every installed module in the current database
        """
        from trytond.modules import create_graph, get_module_list, \
            MODULES_PATH, EGG_MODULES

        IrModule = Pool().get('ir.module.module')

        packages = list(create_graph(get_module_list())[0])[::-1]
        installed_module_list = map(
            lambda module: module.name,
            IrModule.search([('state', '=', 'installed')])
        )

        for package in packages:
            if package.name not in installed_module_list:
                # this package is not installed as a module in this
                # database and hence the tranlation is not relevant
                continue
            if package.name in EGG_MODULES:
                # trytond.tools has a good helper which allows resources to
                # be loaded from the installed site packages. Just use it
                # to load the tryton.cfg file which is guaranteed to exist
                # and from it lookup the directory. From here, its just
                # another searchpath for the loader.
                f = file_open(os.path.join(package.name, 'tryton.cfg'))
                module_dir = os.path.dirname(f.name)
            else:
                module_dir = os.path.join(MODULES_PATH, package.name)

            yield package.name, module_dir

    @classmethod
    def _get_nereid_template_messages(cls):
        """
        Extract localizable strings from the templates of installed modules.

        For every string found this function yields a
        `(module, template, lineno, function, message)` tuple, where:

        * module is the name of the module in which the template is found
        * template is the name of the template in which message was found
        * lineno is the number of the line on which the string was found,
        * function is the name of the gettext function used (if the string
          was extracted from embedded Python code), and
        * message is the string itself (a unicode object, or a tuple of
          unicode objects for functions with multiple string arguments).
        * comments List of Translation comments if any. Comments in the code
          should have a prefix `trans:`. Example::

              {{ _(Welcome) }} {# trans: In the top banner #}
        """
        extract_options = cls._get_nereid_template_extract_options()

        for module, directory in cls._get_installed_module_directories():
            template_dir = os.path.join(directory, 'templates')
            if not os.path.isdir(template_dir):
                # The template directory does not exist. Just continue
                continue

            # now that there is a template directory, load the templates
            # using a simple filesystem loader and load all the
            # translations from it.
            loader = FileSystemLoader(template_dir)
            for template in loader.list_templates():
                file_obj = open(loader.get_source({}, template)[1])
                for message_tuple in babel_extract(
                        file_obj, GETTEXT_FUNCTIONS,
                        ['trans:'], extract_options):
                    yield (module, template) + message_tuple

    def set_nereid_template(self):
        """
        Loads all nereid templates translatable strings into the database. The
        templates loaded are only the ones which are bundled with the tryton
        modules and available in the site packages.
        """
        pool = Pool()
        Translation = pool.get('ir.translation')
        to_create = []
        for module, template, lineno, function, messages, comments in \
                self._get_nereid_template_messages():

            if isinstance(messages, basestring):
                # messages could be a tuple if the function is ngettext
                # where the messages for singular and plural are given as
                # a tuple.
                #
                # So convert basestrings to tuples
                messages = (messages, )

            for message in messages:
                translations = Translation.search([
                    ('lang', '=', 'en_US'),
                    ('type', '=', 'nereid_template'),
                    ('name', '=', template),
                    ('src', '=', message),
                    ('module', '=', module),
                ], limit=1)
                if translations:
                    continue
                to_create.append({
                    'name': template,
                    'res_id': lineno,
                    'lang': 'en_US',
                    'src': message,
                    'type': 'nereid_template',
                    'module': module,
                    'comments': comments and '\n'.join(comments) or None,
                })
        if to_create:
            Translation.create(to_create)

    def set_wtforms(self):
        """
        There are some messages in WTForms which are provided by the framework,
        namely default validator messages and errors occuring during the
        processing (data coercion) stage. For example, in the case of the
        IntegerField, if someone entered a value which was not valid as
        an integer, then a message like â€œNot a valid integer valueâ€ would be
        displayed.
        """
        pool = Pool()
        Translation = pool.get('ir.translation')
        to_create = []
        for (filename, lineno, messages, comments, context) in \
                extract_from_dir(os.path.dirname(wtforms.__file__)):

            if isinstance(messages, basestring):
                # messages could be a tuple if the function is ngettext
                # where the messages for singular and plural are given as
                # a tuple.
                #
                # So convert basestrings to tuples
                messages = (messages, )

            for message in messages:
                translations = Translation.search([
                    ('lang', '=', 'en_US'),
                    ('type', '=', 'wtforms'),
                    ('name', '=', filename),
                    ('src', '=', message),
                    ('module', '=', 'nereid'),
                ], limit=1)
                if translations:
                    continue
                to_create.append({
                    'name': filename,
                    'res_id': lineno,
                    'lang': 'en_US',
                    'src': message,
                    'type': 'wtforms',
                    'module': 'nereid',
                    'comments': comments and '\n'.join(comments) or None,
                })
        if to_create:
            Translation.create(to_create)

    def set_nereid(self):
        """
        There are messages within the tryton code used in flash messages,
        returned responses etc. This is spread over the codebase and this
        function extracts the translation strings from code of installed
        modules.
        """
        pool = Pool()
        Translation = pool.get('ir.translation')
        to_create = []

        for module, directory in self._get_installed_module_directories():
            for (filename, lineno, messages, comments, context) in \
                    extract_from_dir(directory,):

                if isinstance(messages, basestring):
                    # messages could be a tuple if the function is ngettext
                    # where the messages for singular and plural are given as
                    # a tuple.
                    #
                    # So convert basestrings to tuples
                    messages = (messages, )

                for message in messages:
                    translations = Translation.search([
                        ('lang', '=', 'en_US'),
                        ('type', '=', 'nereid'),
                        ('name', '=', filename),
                        ('src', '=', message),
                        ('module', '=', module),
                    ], limit=1)
                    if translations:
                        continue
                    to_create.append({
                        'name': filename,
                        'res_id': lineno,
                        'lang': 'en_US',
                        'src': message,
                        'type': 'nereid',
                        'module': module,
                        'comments': comments and '\n'.join(comments) or None,
                    })
        if to_create:
            Translation.create(to_create)


class TranslationUpdate:
    __name__ = "ir.translation.update"

    def do_update(self, action):
        pool = Pool()
        Translation = pool.get('ir.translation')

        cursor = Transaction().cursor
        lang = self.start.language.code
        translation = Translation.__table__()

        types = ['nereid_template', 'wtforms', 'nereid']
        columns = [
            translation.name.as_('name'),
            translation.res_id.as_('res_id'),
            translation.type.as_('type'),
            translation.src.as_('src'),
            translation.module.as_('module'),
            translation.comments.as_('comments'),
        ]
        cursor.execute(*(
            translation.select(
                *columns,
                where=(translation.lang == 'en_US')
                & translation.type.in_(types))
            - translation.select(
                *columns,
                where=(translation.lang == lang)
                & translation.type.in_(types))
        ))
        to_create = []
        for row in cursor.dictfetchall():
            to_create.append({
                'name': row['name'],
                'res_id': row['res_id'],
                'lang': lang,
                'type': row['type'],
                'src': row['src'],
                'module': row['module'],
                'comments': row['comments'],
            })
        if to_create:
            with Transaction().set_user(0):
                Translation.create(to_create)
        return super(TranslationUpdate, self).do_update(action)


class TranslationClean(Wizard):
    "Clean translation"
    __name__ = 'ir.translation.clean'

    @staticmethod
    def _clean_nereid_template(translation):
        """
        Clean the template translations if the module is not installed, or if
        the template is not there.
        """
        TranslationSet = Pool().get('ir.translation.set', type='wizard')
        installed_modules = TranslationSet._get_installed_module_directories()

        # Clean if the module is not installed anymore
        for module, directory in installed_modules:
            if translation.module == module:
                break
        else:
            return True

        # Clean if the template directory does not exist
        template_dir = os.path.join(directory, 'templates')
        if not os.path.isdir(template_dir):
            return True

        # Clean if the template is not found
        loader = FileSystemLoader(template_dir)
        if translation.name not in loader.list_templates():
            return True

    @staticmethod
    def _clean_wtforms(translation):
        """
        Clean the translation if nereid is not installed
        """
        TranslationSet = Pool().get('ir.translation.set', type='wizard')
        installed_modules = TranslationSet._get_installed_module_directories()

        # Clean if the module is not installed anymore
        for module, directory in installed_modules:
            if translation.module == module:
                break
        else:
            return True

    @staticmethod
    def _clean_nereid(translation):
        """
        Remove the nereid translations if the module is not installed
        """
        TranslationSet = Pool().get('ir.translation.set', type='wizard')
        installed_modules = TranslationSet._get_installed_module_directories()

        # Clean if the module is not installed anymore
        for module, directory in installed_modules:
            if translation.module == module:
                break
        else:
            return True

########NEW FILE########
__FILENAME__ = urls
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import warnings

from trytond.model import ModelView, ModelSQL, fields

__all__ = ['URLMap', 'URLRule', 'URLRuleDefaults']


class URLMap(ModelSQL, ModelView):
    """
    URL Map
    ~~~~~~~

    A collection of URLs for a website. This is analogous to werkzeug's
    URL Map.

    .. warning::

        Defining URLs int he database (using XML) will be deprecated in 3.2.1.0
        Use the `route` decorator to route instead.

        See: https://github.com/openlabs/nereid/issues/178

    :param name: Name of the URL Map
    :param default_subdomain: Default subdomain for URLs in this Map
    :param active: Whether the URL Map is active or not.

    Rules:
    ~~~~~~
    :param rules: O2M URLRules

    Advanced:
    ~~~~~~~~~
    :param charset: default value - utf-8
    :param strict_slashes: Boolean field if / in url map is taken seriously
    :param unique_urls: Enable `redirect_defaults` in the URL Map and
                        redirects the defaults to the URL
    """
    __name__ = "nereid.url_map"

    name = fields.Char(
        'Name', required=True, select=True,
    )
    default_subdomain = fields.Char(
        'Default Subdomain',
    )
    rules = fields.One2Many(
        'nereid.url_rule',
        'url_map',
        'Rules'
    )
    charset = fields.Char('Char Set')
    strict_slashes = fields.Boolean('Strict Slashes')
    unique_urls = fields.Boolean('Unique URLs')
    active = fields.Boolean('Active')

    @staticmethod
    def default_active():
        "By default URL is active"
        return True

    @staticmethod
    def default_charset():
        "By default characterset is utf-8"
        return 'utf-8'

    def get_rules_arguments(self):
        """
        Constructs a list of dictionary of arguments needed
        for URL Rule construction. A wrapper around the
            URL RULE get_rule_arguments
        """
        rule_args = []
        for rule in self.rules:
            rule_args.append(rule.get_rule_arguments())

        if rule_args:
            warnings.warn(
                "Use of XML/Database to bind URLs to view function will be "
                "deprecated in version 3.2.1.0.\n\n"
                "Use the route decorator instead.\n\n"
                "See: https://github.com/openlabs/nereid/issues/178",
                DeprecationWarning
            )

        return rule_args


class URLRule(ModelSQL, ModelView):
    """
    URL Rule
    ~~~~~~~~

    A rule that represents a single URL pattern

    .. warning::

        Defining URLs int he database (using XML) will be deprecated in 3.2.1.0.
        Use the `route` decorator to route instead.

        See: https://github.com/openlabs/nereid/issues/178

    :param path: Path of the URL
    :param name: Name of the URL. This is used for reverse mapping, hence
                 needs to be unique
    :param handler: The handler of this URL or the target model.method
                     which is called. The representation is::

        <model>.<method>

    For example: To call list_parties method in party.party use:

        party.party.list_parties

    The signature of the method being called should be:

        def method(self, **arguments):
            return "Hello World"

    where request is the request object and arguments is the dictionary
    of the values generated from the match of the URL

    :param active: Whether the website is active or not.

    Advanced
    ~~~~~~~~~

    :param defaults: Defaults of the URL (O2M - URLRuleDefaults)

    :param method: POST, GET,
    :param only_for_generation: URL will not be mapped, but can be used
            for URL generation. Example for static pages, where content
            delivery is managed by apache, but URL generation is necessary
    :param redirect_to: (M2O self) Another URL to which the redirect has to
            be done
    :param sequence: Numeric sequence of the URL Map.
    :param url_map: Relation field for url_rule o2m
    """
    __name__ = "nereid.url_rule"
    _rec_name = 'rule'

    rule = fields.Char('Rule', required=True, select=True,)
    endpoint = fields.Char('Endpoint', select=True,)
    active = fields.Boolean('Active')
    defaults = fields.One2Many('nereid.url_rule_defaults', 'rule', 'Defaults')

    # Supported HTTP methods
    http_method_get = fields.Boolean('GET')
    http_method_post = fields.Boolean('POST')
    http_method_patch = fields.Boolean('PATCH')
    http_method_put = fields.Boolean('PUT')
    http_method_delete = fields.Boolean('DELETE')

    only_for_genaration = fields.Boolean('Only for Generation')
    redirect_to = fields.Char('Redirect To')
    sequence = fields.Integer('Sequence', required=True,)
    url_map = fields.Many2One('nereid.url_map', 'URL Map')

    @classmethod
    def __setup__(cls):
        super(URLRule, cls).__setup__()
        cls._order.insert(0, ('sequence', 'ASC'))

    @staticmethod
    def default_active():
        return True

    @staticmethod
    def default_http_method_get():
        return True

    def get_http_methods(self):
        """
        Returns an iterable of HTTP methods that the URL has to support.

        .. versionchanged: 3.0.4.0

            OPTIONS is not implicitly added

        .. versionadded: 2.4.0.6
        """
        methods = ['OPTIONS']
        if self.http_method_get:
            methods.append('GET')
        if self.http_method_post:
            methods.append('POST')
        if self.http_method_put:
            methods.append('PUT')
        if self.http_method_delete:
            methods.append('DELETE')
        if self.http_method_patch:
            methods.append('PATCH')
        return methods

    def get_rule_arguments(self):
        """
        Return the arguments of a Rule in the corresponding format
        """
        defaults = dict(
            [(i.key, i.value) for i in self.defaults]
        )
        return {
            'rule': self.rule,
            'endpoint': self.endpoint,
            'methods': self.get_http_methods(),
            'build_only': self.only_for_genaration,
            'defaults': defaults,
            'redirect_to': self.redirect_to or None,
        }


class URLRuleDefaults(ModelSQL, ModelView):
    """
    Defaults for the URL

    .. warning::

        Defining URLs int he database (using XML) will be deprecated in 3.2.1.0.
        Use the `route` decorator to route instead.

        See: https://github.com/openlabs/nereid/issues/178

    :param key: The char for the default's key
    :param value: The Value for the default's Value
    :param Rule: M2O Rule
    """
    __name__ = "nereid.url_rule_defaults"
    _rec_name = 'key'

    key = fields.Char('Key', required=True, select=True)
    value = fields.Char('Value', required=True, select=True)
    rule = fields.Many2One(
        'nereid.url_rule', 'Rule', required=True,
        select=True
    )

########NEW FILE########
__FILENAME__ = user
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.
import random
import string
import urllib
import base64

try:
    import hashlib
except ImportError:
    hashlib = None
    import sha

import pytz
from flask_wtf import Form, RecaptchaField
from wtforms import TextField, SelectField, validators, PasswordField
from flask.ext.login import logout_user, AnonymousUserMixin, login_url
from werkzeug import redirect, abort

from nereid import request, url_for, render_template, login_required, flash, \
    jsonify, route
from nereid.ctx import has_request_context
from nereid.globals import current_app
from nereid.signals import registration
from nereid.templating import render_email
from trytond.model import ModelView, ModelSQL, fields
from trytond.pool import Pool
from trytond.pyson import Eval, Bool, Not
from trytond.transaction import Transaction
from trytond.config import CONFIG
from trytond.tools import get_smtp_server
from trytond import backend
from itsdangerous import URLSafeSerializer, TimestampSigner, SignatureExpired, \
    BadSignature, TimedJSONWebSignatureSerializer
from .i18n import _

__all__ = ['NereidUser', 'NereidAnonymousUser', 'Permission', 'UserPermission']


class RegistrationForm(Form):
    "Simple Registration form"
    name = TextField(_('Name'), [validators.Required(), ])
    email = TextField(_('e-mail'), [validators.Required(), validators.Email()])
    password = PasswordField(_('New Password'), [
        validators.Required(),
        validators.EqualTo('confirm', message=_('Passwords must match'))])
    confirm = PasswordField(_('Confirm Password'))

    if 're_captcha_public' in CONFIG.options:
        captcha = RecaptchaField(
            public_key=CONFIG.options['re_captcha_public'],
            private_key=CONFIG.options['re_captcha_private'],
            secure=True
        )


class NewPasswordForm(Form):
    """
    Form to set a new password
    """
    password = PasswordField(_('New Password'), [
        validators.Required(),
        validators.EqualTo('confirm', message=_('Passwords must match'))])
    confirm = PasswordField(_('Repeat Password'))


class ChangePasswordForm(NewPasswordForm):
    """
    Form to change the password
    """
    old_password = PasswordField(_('Old Password'), [validators.Required()])


STATES = {
    'readonly': Not(Bool(Eval('active'))),
}


class ProfileForm(Form):
    """User Profile Form"""
    display_name = TextField(
        'Display Name', [validators.Required(), ],
        description="Your display name"
    )
    timezone = SelectField(
        'Timezone',
        choices=[(tz, tz) for tz in pytz.common_timezones],
        coerce=unicode, description="Your timezone"
    )
    email = TextField(
        'Email', [validators.Required(), validators.Email()],
        description="Your Login Email. This Cannot be edited."
    )


class NereidUser(ModelSQL, ModelView):
    """
    Nereid Users
    """
    __name__ = "nereid.user"
    _rec_name = 'display_name'

    party = fields.Many2One(
        'party.party', 'Party', required=True,
        ondelete='CASCADE', select=1
    )

    display_name = fields.Char('Display Name', required=True)

    #: The email of the user is also the login name/username of the user
    email = fields.Char("e-Mail", select=1)

    #: The password is the user password + the salt, which is
    #: then hashed together
    password = fields.Sha('Password')

    #: The salt which was used to make the hash is separately
    #: stored. Needed for
    salt = fields.Char('Salt', size=8)

    # The company of the website(s) to which the user is affiliated. This
    # allows websites of the same company to share authentication/users. It
    # does not make business or technical sense to have website of multiple
    # companies share the authentication.
    #
    # .. versionchanged:: 0.3
    #     Company is mandatory
    company = fields.Many2One('company.company', 'Company', required=True)

    timezone = fields.Selection(
        [(x, x) for x in pytz.common_timezones], 'Timezone', translate=False
    )

    permissions = fields.Many2Many(
        'nereid.permission-nereid.user',
        'nereid_user', 'permission', 'Permissions'
    )

    email_verified = fields.Boolean("Email Verified")
    active = fields.Boolean('Active')

    @staticmethod
    def default_email_verified():
        return False

    @staticmethod
    def default_active():
        """
        If the user gets created from the web the activation should happen
        through the activation link. However, users created from tryton
        interface are activated by default
        """
        if has_request_context():
            return False
        return True

    @classmethod
    def __register__(cls, module_name):
        TableHandler = backend.get("TableHandler")
        table = TableHandler(Transaction().cursor, cls, module_name)
        user = cls.__table__()

        super(NereidUser, cls).__register__(module_name)

        # Migrations
        if table.column_exist('activation_code'):
            # Migration for activation_code field
            # Set the email_verification and active based on activation code
            user.update(
                columns=[user.active, user.email_verified],
                values=[True, True],
                where=(user.activation_code == None)
            )
            # Finally drop the column
            table.drop_column('activation_code', exception=True)

    def serialize(self, purpose=None):
        """
        Return a JSON serializable object that represents this record
        """
        return {
            'id': self.id,
            'email': self.email,
            'display_name': self.display_name,
            'permissions': list(self.get_permissions()),
        }

    def get_permissions(self):
        """
        Returns all the permissions as a list of names
        """
        # TODO: Cache this value for each user to avoid hitting the database
        # everytime.
        return frozenset([p.value for p in self.permissions])

    def has_permissions(self, perm_all=None, perm_any=None):
        """Check if the user has all required permissions in perm_all and
        has any permission from perm_any for access

        :param perm_all: A set/frozenset of all permission values/keywords.
        :param perm_any: A set/frozenset of any permission values/keywords.

        :return: True/False
        """
        if not perm_all and not perm_any:
            # Access allowed if no permission is required
            return True
        if not isinstance(perm_all, (set, frozenset)):
            perm_all = frozenset(perm_all if perm_all else [])
        if not isinstance(perm_any, (set, frozenset)):
            perm_any = frozenset(perm_any if perm_any else [])
        current_user_permissions = self.get_permissions()

        if perm_all and not perm_all.issubset(current_user_permissions):
            return False
        if perm_any and not perm_any.intersection(current_user_permissions):
            return False
        return True

    @staticmethod
    def default_timezone():
        return "UTC"

    @staticmethod
    def default_company():
        return Transaction().context.get('company') or False

    @classmethod
    def __setup__(cls):
        super(NereidUser, cls).__setup__()
        cls._sql_constraints += [
            ('unique_email_company', 'UNIQUE(email, company)',
                'Email must be unique in a company'),
        ]

    @property
    def _signer(self):
        return TimestampSigner(current_app.secret_key)

    @property
    def _serializer(self):
        return URLSafeSerializer(current_app.secret_key)

    def _get_sign(self, salt):
        """
        Returns a timestampsigned, url_serialized sign  with a salt
        'verification'.
        """
        return self._signer.sign(self._serializer.dumps(self.id, salt=salt))

    def get_email_verification_link(self, **options):
        """
        Returns an email verification link for the user
        """
        return url_for(
            'nereid.user.verify_email',
            sign=self._get_sign('verification'),
            active_id=self.id,
            **options
        )

    def get_activation_link(self, **options):
        """
        Returns an activation link for the user
        """
        return url_for(
            'nereid.user.activate',
            sign=self._get_sign('activation'),
            active_id=self.id,
            **options
        )

    def get_reset_password_link(self, **options):
        """
        Returns a password reset link for the user
        """
        return url_for(
            'nereid.user.new_password',
            sign=self._get_sign('reset-password'),
            active_id=self.id,
            **options
        )

    @route("/verify-email/<int:active_id>/<sign>", methods=["GET"])
    def verify_email(self, sign, max_age=24 * 60 * 60):
        """
        Verifies the email and redirects to home page. This is a method in
        addition to the activate method which activates the account in addition
        to verifying the email.
        """
        try:
            unsigned = self._serializer.loads(
                self._signer.unsign(sign, max_age=max_age),
                salt='verification'
            )
        except SignatureExpired:
            flash(_("The verification link has expired"))
        except BadSignature:
            flash(_("The verification token is invalid!"))
        else:
            if self.id == unsigned:
                self.email_verified = True
                self.save()
                flash(_("Your email has been verified!"))
            else:
                flash(_("The verification token is invalid!"))
        return redirect(url_for('nereid.website.home'))

    @staticmethod
    def get_registration_form():
        """
        Returns a registration form for use in the site

        .. tip::

            Configuration of re_captcha

            Remember to forward X-Real-IP in the case of Proxy servers

        """
        # Add re_captcha if the configuration has such an option
        if 're_captcha_public' in CONFIG.options:
            registration_form = RegistrationForm(
                captcha={'ip_address': request.remote_addr}
            )
        else:
            registration_form = RegistrationForm()

        return registration_form

    @classmethod
    @route("/registration", methods=["GET", "POST"])
    def registration(cls):
        """
        Invokes registration of an user
        """
        Party = Pool().get('party.party')

        registration_form = cls.get_registration_form()

        if registration_form.validate_on_submit():
            with Transaction().set_context(active_test=False):
                existing = cls.search([
                    ('email', '=', registration_form.email.data),
                    ('company', '=', request.nereid_website.company.id),
                ])
            if existing:
                message = _(
                    'A registration already exists with this email. '
                    'Please contact customer care'
                )
                if request.is_xhr or request.is_json:
                    return jsonify(message=unicode(message)), 400
                else:
                    flash(message)
            else:
                party = Party(name=registration_form.name.data)
                party.addresses = []
                party.save()
                nereid_user = cls(**{
                    'party': party.id,
                    'display_name': registration_form.name.data,
                    'email': registration_form.email.data,
                    'password': registration_form.password.data,
                    'company': request.nereid_website.company.id,
                }
                )
                nereid_user.save()
                registration.send(nereid_user)
                nereid_user.send_activation_email()
                message = _(
                    'Registration Complete. Check your email for activation'
                )
                if request.is_xhr or request.is_json:
                    return jsonify(message=unicode(message)), 201
                else:
                    flash(message)
                return redirect(
                    request.args.get('next', url_for('nereid.website.home'))
                )

        if registration_form.errors and (request.is_xhr or request.is_json):
            return jsonify({
                'message': unicode(_('Form has errors')),
                'errors': registration_form.errors,
            }), 400

        return render_template('registration.jinja', form=registration_form)

    def send_activation_email(self):
        """
        Send an activation email to the user

        :param nereid_user: The browse record of the user
        """
        email_message = render_email(
            CONFIG['smtp_from'], self.email, _('Account Activation'),
            text_template='emails/activation-text.jinja',
            html_template='emails/activation-html.jinja',
            nereid_user=self
        )
        server = get_smtp_server()
        server.sendmail(
            CONFIG['smtp_from'], [self.email], email_message.as_string()
        )
        server.quit()

    @classmethod
    @route("/change-password", methods=["GET", "POST"])
    @login_required
    def change_password(cls):
        """
        Changes the password

        .. tip::
            On changing the password, the user is logged out and the login page
            is thrown at the user
        """
        form = ChangePasswordForm(request.form)

        if request.method == 'POST' and form.validate():
            if request.nereid_user.match_password(form.old_password.data):
                cls.write(
                    [request.nereid_user],
                    {'password': form.password.data}
                )
                flash(
                    _('Your password has been successfully changed! '
                        'Please login again')
                )
                logout_user()
                return redirect(url_for('nereid.website.login'))
            else:
                flash(_("The current password you entered is invalid"))

        return render_template(
            'change-password.jinja', change_password_form=form
        )

    @route("/new-password/<int:active_id>/<sign>", methods=["GET", "POST"])
    def new_password(self, sign, max_age=24 * 60 * 60):
        """Create a new password

        This is intended to be used when a user requests for a password reset.
        The link sent out to reset the password will be a timestamped sign
        which is validated for max_age before allowing the user to set the
        new password.
        """
        form = NewPasswordForm(request.form)

        if request.method == 'POST' and form.validate():
            try:
                unsigned = self._serializer.loads(
                    self._signer.unsign(sign, max_age=max_age),
                    salt='reset-password'
                )
            except SignatureExpired:
                flash(_("The password reset link has expired"))
            except BadSignature:
                flash(_('Invalid reset password code'))
            else:
                if not self.id == unsigned:
                    current_app.logger.debug('Invalid reset password code')
                    abort(403)

                self.write([self], {'password': form.password.data})
                flash(_(
                    'Your password has been successfully changed! '
                    'Please login again'))
            return redirect(url_for('nereid.website.login'))

        return render_template(
            'new-password.jinja', password_form=form, sign=sign, user=self
        )

    @route("/activate-account/<int:active_id>/<sign>", methods=["GET"])
    def activate(self, sign, max_age=24 * 60 * 60):
        """A web request handler for activation of the user account. This
        method verifies the email and if it succeeds, activates the account.

        If your workflow requires a manual approval of every account, override
        this to not activate an account, or make a no op out of this method.

        If all what you require is verification of email, `verify_email` method
        could be used.
        """
        try:
            unsigned = self._serializer.loads(
                self._signer.unsign(sign, max_age=max_age),
                salt='activation'
            )
        except SignatureExpired:
            flash(_("The activation link has expired"))
        except BadSignature:
            flash(_("The activation token is invalid!"))
        else:
            if self.id == unsigned:
                self.active = True
                self.email_verified = True
                self.save()
                flash(_('Your account has been activated. Please login now.'))
            else:
                flash(_('Invalid Activation Code'))

        return redirect(url_for('nereid.website.login'))

    @classmethod
    @route("/reset-account", methods=["GET", "POST"])
    def reset_account(cls):
        """
        Reset the password for the user.

        .. tip::
            This does NOT reset the password, but just creates an activation
            code and sends the link to the email of the user. If the user uses
            the link, he can change his password.
        """
        if request.method == 'POST':
            user_ids = cls.search(
                [
                    ('email', '=', request.form['email']),
                    ('company', '=', request.nereid_website.company.id),
                ]
            )

            if not user_ids or not request.form['email']:
                flash(_('Invalid email address'))
                return render_template('reset-password.jinja')

            nereid_user, = user_ids
            nereid_user.send_reset_email()
            flash(_('An email has been sent to your account for resetting'
                    ' your credentials'))
            return redirect(url_for('nereid.website.login'))

        return render_template('reset-password.jinja')

    def send_reset_email(self):
        """
        Send an account reset email to the user

        :param nereid_user: The browse record of the user
        """
        email_message = render_email(
            CONFIG['smtp_from'], self.email, _('Account Password Reset'),
            text_template='emails/reset-text.jinja',
            html_template='emails/reset-html.jinja',
            nereid_user=self
        )
        server = get_smtp_server()
        server.sendmail(
            CONFIG['smtp_from'], [self.email], email_message.as_string()
        )
        server.quit()

    def match_password(self, password):
        """
        Checks if 'password' is the same as the current users password.

        :param password: The password of the user (string or unicode)
        :return: True or False
        """
        password += self.salt or ''
        if isinstance(password, unicode):
            password = password.encode('utf-8')
        if hashlib:
            digest = hashlib.sha1(password).hexdigest()
        else:
            digest = sha.new(password).hexdigest()
        return (digest == self.password)

    @classmethod
    def authenticate(cls, email, password):
        """Assert credentials and if correct return the
        browse record of the user.

        .. versionchanged:: 3.0.4.0

            Does not check if the user account is active or not as that
            is not in the scope of 'authentication'.

        :param email: email of the user
        :param password: password of the user
        :return:
            Browse Record: Successful Login
            None: User cannot be found or wrong password
        """
        if not (email and password):
            return None
        with Transaction().set_context(active_test=False):
            users = cls.search([
                ('email', '=', email),
                ('company', '=', request.nereid_website.company.id),
            ])

        if not users:
            current_app.logger.debug("No user with email %s" % email)
            return None

        if len(users) > 1:
            current_app.logger.debug('%s has too many accounts' % email)
            return None

        user, = users
        if user.match_password(password):
            return user

        return None

    @classmethod
    def load_user(cls, user_id):
        """
        Implements the load_user method for Flask-Login

        :param user_id: Unicode ID of the user
        """
        try:
            with Transaction().set_context(active_test=False):
                user, = cls.search([('id', '=', int(user_id))])
        except ValueError:
            return None

        # Instead of returning the active record returned in the above search
        # we are creating a new record here. This is because the returned
        # active record seems to carry around the context setting of
        # active_test and any nested lookup from the record will result in
        # records being fetched which are inactive.
        return cls(int(user_id))

    @classmethod
    def load_user_from_header(cls, header_val):
        """
        Implements the header_loader method for Flask-Login

        :param header_val: Value of the header
        """
        # Basic authentication
        if header_val.startswith('Basic '):
            header_val = header_val.replace('Basic ', '', 1)
            try:
                header_val = base64.b64decode(header_val)
            except TypeError:
                pass
            else:
                return cls.authenticate(*header_val.split(':'))

        # TODO: Digest authentication

        # Token in Authorization header
        if header_val.startswith(('token ', 'Token ')):
            token = header_val \
                            .replace('token ', '', 1) \
                            .replace('Token ', '', 1)
            return cls.load_user_from_token(token)

    @classmethod
    def load_user_from_token(cls, token):
        """
        Implements the token_loader method for Flask-Login

        :param token: The token sent in the user's request
        """
        serializer = TimedJSONWebSignatureSerializer(
            current_app.secret_key,
            expires_in=current_app.token_validity_duration
        )

        try:
            data = serializer.loads(token)
        except SignatureExpired:
            return None     # valid token, but expired
        except BadSignature:
            return None     # invalid token

        user = cls(data['id'])
        if user.password != data['password']:
            # The password has been changed by the user. So the token
            # should also be invalid.
            return None

        return user

    def get_auth_token(self):
        """
        Return an authentication token for the user. The auth token uniquely
        identifies the user and includes the salted hash of the password, then
        encrypted with a Timed serializer.

        The token_validity_duration can be set in application configuration
        using TOKEN_VALIDITY_DURATION
        """
        serializer = TimedJSONWebSignatureSerializer(
            current_app.secret_key,
            expires_in=current_app.token_validity_duration
        )
        local_txn = None
        if Transaction().cursor is None:
            # Flask-Login can call get_auth_token outside the context
            # of a nereid transaction. If that is the case, launch a
            # new transaction here.
            local_txn = Transaction().start(
                current_app.database_name, 0, readonly=True
            )
            self = self.__class__(self.id)
        try:
            return serializer.dumps({'id': self.id, 'password': self.password})
        finally:
            if local_txn is not None:
                Transaction().stop()

    @classmethod
    def unauthorized_handler(cls):
        """
        This is called when the user is required to log in.

        If the request is XHR, then a JSON message with the status code 401
        is sent as response, else a redirect to the login page is returned.
        """
        if request.is_xhr:
            rv = jsonify(message="Bad credentials")
            rv.status_code = 401
            return rv
        return redirect(
            login_url(current_app.login_manager.login_view, request.url)
        )

    def is_authenticated(self):
        """
        Returns True if the user is authenticated, i.e. they have provided
        valid credentials. (Only authenticated users will fulfill the criteria
        of login_required.)
        """
        return bool(self.id)

    def is_active(self):
        return self.active

    def is_anonymous(self):
        return not self.id

    def get_id(self):
        return unicode(self.id)

    @staticmethod
    def _convert_values(values):
        """
        A helper method which looks if the password is specified in the values.
        If it is, then the salt is also made and added

        :param values: A dictionary of field: value pairs
        """
        if 'password' in values and values['password']:
            values['salt'] = ''.join(random.sample(
                string.ascii_letters + string.digits, 8))
            values['password'] += values['salt']

        return values

    @classmethod
    def create(cls, vlist):
        """
        Create, but add salt before saving

        :param vlist: List of dictionary of Values
        """
        vlist = [cls._convert_values(vals.copy()) for vals in vlist]
        return super(NereidUser, cls).create(vlist)

    @classmethod
    def write(cls, nereid_users, values):
        """
        Update salt before saving
        """
        return super(NereidUser, cls).write(
            nereid_users, cls._convert_values(values)
        )

    @staticmethod
    def get_gravatar_url(email, **kwargs):
        """
        Return a gravatar url for the given email

        :param email: e-mail of the user
        :param https: To get a secure URL
        :param default: The default image to return if there is no profile pic
                        For example a unisex avatar
        :param size: The size for the image
        """
        if kwargs.get('https', request.scheme == 'https'):
            url = 'https://secure.gravatar.com/avatar/%s?'
        else:
            url = 'http://www.gravatar.com/avatar/%s?'
        url = url % hashlib.md5(email.lower()).hexdigest()

        params = []
        default = kwargs.get('default', None)
        if default:
            params.append(('d', default))

        size = kwargs.get('size', None)
        if size:
            params.append(('s', str(size)))

        return url + urllib.urlencode(params)

    def get_profile_picture(self, **kwargs):
        """
        Return the url to the profile picture of the user.

        The default implementation fetches the profile image of the user from
        gravatar using :meth:`get_gravatar_url`
        """
        return self.get_gravatar_url(self.email, **kwargs)

    @staticmethod
    def aslocaltime(naive_date, local_tz_name=None):
        """
        Returns a localized time using `pytz.astimezone` method.

        :param naive_date: a naive datetime (datetime with no timezone
                           information), which is assumed to be the UTC time.
        :param local_tz_name: The timezone in which the date has to be returned
        :type local_tz_name: string

        :return: A datetime object with local time
        """

        utc_date = pytz.utc.localize(naive_date)

        if not local_tz_name:
            return utc_date

        local_tz = pytz.timezone(local_tz_name)
        if local_tz == pytz.utc:
            return utc_date

        return utc_date.astimezone(local_tz)

    def as_user_local_time(self, naive_date):
        """
        Returns a date localized in the user's timezone.

        :param naive_date: a naive datetime (datetime with no timezone
                           information), which is assumed to be the UTC time.
        """
        return self.aslocaltime(naive_date, self.timezone)

    @classmethod
    @route("/me", methods=["GET", "POST"])
    @login_required
    def profile(cls):
        """
        User profile
        """
        user_form = ProfileForm(obj=request.nereid_user)
        if user_form.validate_on_submit():
            cls.write(
                [request.nereid_user], {
                    'display_name': user_form.display_name.data,
                    'timezone': user_form.timezone.data,
                }
            )
            flash('Your profile has been updated.')

        if request.is_xhr or request.is_json:
            return jsonify(request.nereid_user.serialize())

        return render_template(
            'profile.jinja', user_form=user_form, active_type_name="general"
        )


class NereidAnonymousUser(AnonymousUserMixin, ModelView):
    """
    Nereid Anonymous User Object
    """
    __name__ = "nereid.user.anonymous"

    def has_permissions(self, perm_all=None, perm_any=None):
        """
        By default return that the user has no permissions.

        Downstream modules can change this behavior.
        """
        return False

    def get_profile_picture(self, **kwargs):
        """
        Returns the default gravatar mystery man silouette
        """
        User = Pool().get('nereid.user')
        kwargs['default'] = 'mm'
        return User.get_gravatar_url("does not matter", **kwargs)


class Permission(ModelSQL, ModelView):
    "Nereid Permissions"
    __name__ = 'nereid.permission'

    name = fields.Char('Name', required=True, select=True)
    value = fields.Char('Value', required=True, select=True)
    nereid_users = fields.Many2Many(
        'nereid.permission-nereid.user',
        'permission', 'nereid_user', 'Nereid Users'
    )

    @classmethod
    def __setup__(cls):
        super(Permission, cls).__setup__()
        cls._sql_constraints += [
            ('unique_value', 'UNIQUE(value)',
                'Permissions must be unique by value'),
        ]


class UserPermission(ModelSQL):
    "Nereid User Permissions"
    __name__ = 'nereid.permission-nereid.user'

    permission = fields.Many2One(
        'nereid.permission', 'Permission',
        ondelete='CASCADE', select=True, required=True
    )
    nereid_user = fields.Many2One(
        'nereid.user', 'User',
        ondelete='CASCADE', select=True, required=True
    )

########NEW FILE########
__FILENAME__ = website
# This file is part of Tryton.  The COPYRIGHT file at the top level of
# this repository contains the full copyright notices and license terms.

import pytz
from werkzeug import abort, redirect
from werkzeug.routing import Map, Submount
from flask_wtf import Form
from wtforms import TextField, PasswordField, validators, BooleanField
from flask.ext.login import login_user, logout_user

from nereid import jsonify, flash, render_template, url_for, cache, \
    current_user, route
from nereid.globals import request
from nereid.exceptions import WebsiteNotFound
from nereid.helpers import login_required, key_from_list, get_flashed_messages
from nereid.signals import failed_login
from trytond.model import ModelView, ModelSQL, fields
from trytond.transaction import Transaction
from trytond.pool import Pool
from trytond.cache import Cache

from .i18n import _

__all__ = ['WebSite', 'WebSiteLocale', 'WebsiteCountry',
           'WebsiteCurrency', 'WebsiteWebsiteLocale']


class LoginForm(Form):
    "Default Login Form"
    email = TextField(_('e-mail'), [validators.Required(), validators.Email()])
    password = PasswordField(_('Password'), [validators.Required()])
    remember = BooleanField(_('Remember me'), default=False)


class WebSite(ModelSQL, ModelView):
    """
    One of the most powerful features of Nereid is the ability to
    manage multiple websites from one back-end. A web site in nereid
    represents a collection or URLs, settings.

    :param name: Name of the web site
    :param base_url: The unique URL of the website, You cannot have two
                     websites, with the same base_url
    :param url_map: The active URL Map for the website (M2O URLMap)
    :param company: The company linked with the website.
    :param active: Whether the website is active or not.

    """
    __name__ = "nereid.website"

    #: The name field is used for both information and also as
    #: the site identifier for nereid. The WSGI application requires
    #: SITE argument. The SITE argument is then used to load URLs and
    #: other settings for the website. Needs to be unique
    name = fields.Char('Name', required=True, select=True)

    #: The URLMap is made as a different object which functions as a
    #: collection of Rules. This will allow easy replication of sites
    #: which perform with same URL structures but different templates
    url_map = fields.Many2One('nereid.url_map', 'URL Map', required=True)

    #: The company to which the website belongs. Useful when creating
    #: records like sale order which require a company to be present
    company = fields.Many2One('company.company', 'Company', required=True)

    active = fields.Boolean('Active')

    #: The list of countries this website operates in. Used for generating
    #: Countries list in the registration form etc.
    countries = fields.Many2Many(
        'nereid.website-country.country', 'website', 'country',
        'Countries Available')

    #: Allowed currencies in the website
    currencies = fields.Many2Many(
        'nereid.website-currency.currency',
        'website', 'currency', 'Currencies Available')

    #: Default locale
    default_locale = fields.Many2One(
        'nereid.website.locale', 'Default Locale',
        required=True
    )

    #: Allowed locales in the website
    locales = fields.Many2Many(
        'nereid.website-nereid.website.locale',
        'website', 'locale', 'Languages Available')

    #: The res.user with which the nereid application will be loaded
    #:  .. versionadded: 0.3
    application_user = fields.Many2One(
        'res.user', 'Application User', required=True
    )
    guest_user = fields.Many2One(
        'nereid.user', 'Guest user', required=True
    )

    timezone = fields.Selection(
        [(x, x) for x in pytz.common_timezones], 'Timezone', translate=False
    )

    @staticmethod
    def default_timezone():
        return 'UTC'

    @staticmethod
    def default_active():
        return True

    @staticmethod
    def default_url_map():
        ModelData = Pool().get('ir.model.data')

        return ModelData.get_id("nereid", "default_url_map")

    @staticmethod
    def default_company():
        return Transaction().context.get('company')

    @staticmethod
    def default_default_locale():
        ModelData = Pool().get('ir.model.data')

        if not Pool().test:
            return ModelData.get_id("nereid", "website_locale_en-us")

    @staticmethod
    def default_application_user():
        ModelData = Pool().get('ir.model.data')
        return ModelData.get_id("nereid", "web_user")

    @classmethod
    def __setup__(cls):
        super(WebSite, cls).__setup__()
        cls._sql_constraints = [
            ('name_uniq', 'UNIQUE(name)',
             'Another site with the same name already exists!')
        ]

    @classmethod
    @route("/countries", methods=["GET"])
    def country_list(cls):
        """
        Return the list of countries in JSON
        """
        return jsonify(result=[
            {'key': c.id, 'value': c.name}
            for c in request.nereid_website.countries
        ])

    @classmethod
    @route("/subdivisions", methods=["GET"])
    def subdivision_list(cls):
        """
        Return the list of states for given country
        """
        Subdivision = Pool().get('country.subdivision')

        country = int(request.args.get('country', 0))
        if country not in [c.id for c in request.nereid_website.countries]:
            abort(404)
        subdivisions = Subdivision.search([('country', '=', country)])
        return jsonify(
            result=[s.serialize() for s in subdivisions]
        )

    def get_urls(self, name):
        """
        Return complete list of URLs
        """
        URLMap = Pool().get('nereid.url_map')
        websites = self.search([('name', '=', name)])
        if not websites:
            raise RuntimeError("Website with Name %s not found" % name)

        return URLMap.get_rules_arguments(websites[0].url_map.id)

    def stats(self, **arguments):
        """
        Test method.
        """
        return u'Request: %s\nArguments: %s\nEnviron: %s\n' \
            % (request, arguments, request.environ)

    @classmethod
    @route('/')
    def home(cls):
        "A dummy home method which just renders home.jinja"
        return render_template('home.jinja')

    @classmethod
    @route('/login', methods=['GET', 'POST'])
    def login(cls):
        """
        Simple login based on the email and password

        Required post data see :class:LoginForm
        """
        login_form = LoginForm(request.form)

        if not request.is_guest_user and request.args.get('next'):
            return redirect(request.args['next'])

        if request.method == 'POST' and login_form.validate():
            NereidUser = Pool().get('nereid.user')
            user = NereidUser.authenticate(
                login_form.email.data, login_form.password.data
            )
            # Result can be the following:
            # 1 - Browse record of User (successful login)
            # 2 - None - Login failure without message
            # 3 - Any other false value (no message is shown. useful if you
            #       want to handle the message shown to user)
            if user:
                # NOTE: Translators leave %s as such
                flash(_("You are now logged in. Welcome %(name)s",
                        name=user.display_name))
                if login_user(user, remember=login_form.remember.data):
                    if request.is_xhr:
                        return jsonify({
                            'success': True,
                            'user': user.serialize(),
                        })
                    else:
                        return redirect(
                            request.values.get(
                                'next', url_for('nereid.website.home')
                            )
                        )
                else:
                    flash(_("Your account has not been activated yet!"))
            elif user is None:
                flash(_("Invalid login credentials"))

            failed_login.send(form=login_form)

            if request.is_xhr:
                rv = jsonify(message="Bad credentials")
                rv.status_code = 401
                return rv

        return render_template('login.jinja', login_form=login_form)

    @classmethod
    @route('/logout')
    def logout(cls):
        "Log the user out"
        logout_user()
        flash(
            _('You have been logged out successfully. Thanks for visiting us')
        )
        return redirect(
            request.args.get('next', url_for('nereid.website.home'))
        )

    @classmethod
    @login_required
    @route('/login/token', methods=['POST'])
    def get_auth_token(cls):
        """
        A method that returns a login token and user information in a json
        response. This should probably be called with basic authentication in
        the header. The token generated could then be used for subsequent
        requests.
        """
        return jsonify({
            'user': current_user.serialize(),
            'token': current_user.get_auth_token(),
        })

    @staticmethod
    def account_context():
        """This fills the account context for the template
        rendering my account. Additional modules might want to fill extra
        data into the context
        """
        return dict(
            user=request.nereid_user,
            party=request.nereid_user.party,
        )

    @classmethod
    @route("/account", methods=["GET"])
    @login_required
    def account(cls):
        return render_template('account.jinja', **cls.account_context())

    def get_currencies(self):
        """Returns available currencies for current site

        .. note::
            A special method is required so that the fetch can be speeded up,
            by pushing the categories to the central cache which cannot be
            done directly on a browse node.
        """
        cache_key = key_from_list([
            Transaction().cursor.dbname,
            Transaction().user,
            'nereid.website.get_currencies',
        ])
        # The website is automatically appended to the cache prefix
        rv = cache.get(cache_key)
        if rv is None:
            rv = [{
                'id': c.id,
                'name': c.name,
                'symbol': c.symbol,
            } for c in self.currencies
            ]
            cache.set(cache_key, rv, 60 * 60)
        return rv

    @staticmethod
    def _user_status():
        """Returns the commonly required status parameters of the user

        This method could be inherited and components could be added
        """
        rv = {
            'messages': map(unicode, get_flashed_messages()),
        }
        if request.is_guest_user:
            rv.update({
                'logged_id': False
            })
        else:
            rv.update({
                'logged_in': True,
                'name': request.nereid_user.display_name
            })
        return rv

    @classmethod
    @route("/user_status", methods=["GET"])
    def user_status(cls):
        """
        Returns a JSON of the user_status
        """
        return jsonify(status=cls._user_status())

    @classmethod
    def get_from_host(cls, host, silent=False):
        """
        Returns the website with name as given host

        If not silent a website not found error is raised.
        """
        try:
            website, = cls.search([('name', '=', host)])
        except ValueError:
            if not silent:
                raise WebsiteNotFound()
        else:
            return website

    _url_adapter_cache = Cache('nereid.website.url_adapter', context=False)

    @classmethod
    def clear_url_adapter_cache(cls, *args):
        """
        A method which conveniently clears the cache
        """
        cls._url_adapter_cache.clear()

    def get_url_adapter(self, app):
        """
        Returns the URL adapter for the website
        """
        cache_rv = self._url_adapter_cache.get(self.id)

        if cache_rv is not None:
            return cache_rv

        url_rules = app.get_urls()[:]

        # Add the static url
        url_rules.append(
            app.url_rule_class(
                app.static_url_path + '/<path:filename>',
                endpoint='static',
            )
        )

        for url_kwargs in self.url_map.get_rules_arguments():
            rule = app.url_rule_class(
                url_kwargs.pop('rule'),
                **url_kwargs
            )
            rule.provide_automatic_options = True
            url_rules.append(rule)   # Add rule to map

        url_map = Map()
        if self.locales:
            # Create the URL map with locale prefix
            url_map.add(
                app.url_rule_class(
                    '/', redirect_to='/%s' % self.default_locale.code,
                ),
            )
            url_map.add(Submount('/<locale>', url_rules))
        else:
            # Create a new map with the given URLs
            map(url_map.add, url_rules)

        # Add the rules from the application's url map filled through the
        # route decorator or otherwise
        for rule in app.url_map._rules:
            url_map.add(rule.empty())

        self._url_adapter_cache.set(self.id, url_map)

        return url_map


class WebSiteLocale(ModelSQL, ModelView):
    'Web Site Locale'
    __name__ = "nereid.website.locale"
    _rec_name = 'code'

    code = fields.Char('Code', required=True)
    language = fields.Many2One(
        'ir.lang', 'Default Language', required=True
    )
    currency = fields.Many2One(
        'currency.currency', 'Currency', ondelete='CASCADE', required=True
    )

    @classmethod
    def __setup__(cls):
        super(WebSiteLocale, cls).__setup__()
        cls._sql_constraints += [
            ('unique_code', 'UNIQUE(code)',
                'Code must be unique'),
        ]


class WebsiteCountry(ModelSQL):
    "Website Country Relations"
    __name__ = 'nereid.website-country.country'

    website = fields.Many2One('nereid.website', 'Website')
    country = fields.Many2One('country.country', 'Country')


class WebsiteCurrency(ModelSQL):
    "Currencies to be made available on website"
    __name__ = 'nereid.website-currency.currency'
    _table = 'website_currency_rel'

    website = fields.Many2One(
        'nereid.website', 'Website',
        ondelete='CASCADE', select=1, required=True)
    currency = fields.Many2One(
        'currency.currency', 'Currency',
        ondelete='CASCADE', select=1, required=True)


class WebsiteWebsiteLocale(ModelSQL):
    "Languages to be made available on website"
    __name__ = 'nereid.website-nereid.website.locale'
    _table = 'website_locale_rel'

    website = fields.Many2One(
        'nereid.website', 'Website',
        ondelete='CASCADE', select=1, required=True)
    locale = fields.Many2One(
        'nereid.website.locale', 'Locale',
        ondelete='CASCADE', select=1, required=True)

########NEW FILE########
