__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# nodeshot documentation build configuration file, created by
# sphinx-quickstart on Tue Nov 26 19:53:42 2013.
#
# This file is execfile()d with the current directory set to its
# containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys
import os

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.insert(0, os.path.abspath('.'))

# -- General configuration ------------------------------------------------

# If your documentation needs a minimal Sphinx version, state it here.
#needs_sphinx = '1.0'

# Add any Sphinx extension module names here, as strings. They can be
# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom
# ones.
extensions = [
    'sphinx.ext.todo',
    'sphinx.ext.coverage',
    'sphinx.ext.viewcode',
]

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8-sig'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'nodeshot'
copyright = u'2013, Federico Capoano'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = 'alpha'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of patterns, relative to source directory, that match files and
# directories to ignore when looking for source files.
exclude_patterns = ['_build']

# The reST default role (used for this markup: `text`) to use for all
# documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []

# If true, keep warnings as "system message" paragraphs in the built documents.
#keep_warnings = False


# -- Options for HTML output ----------------------------------------------

# The theme to use for HTML and HTML Help pages.  See the documentation for
# a list of builtin themes.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# Add any extra paths that contain custom files (such as robots.txt or
# .htaccess) here, relative to this directory. These files are copied
# directly to the root of the documentation.
#html_extra_path = []

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_domain_indices = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, "Created using Sphinx" is shown in the HTML footer. Default is True.
#html_show_sphinx = True

# If true, "(C) Copyright ..." is shown in the HTML footer. Default is True.
#html_show_copyright = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# This is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = None

# Output file base name for HTML help builder.
htmlhelp_basename = 'nodeshotdoc'


# -- Options for LaTeX output ---------------------------------------------

latex_elements = {
# The paper size ('letterpaper' or 'a4paper').
#'papersize': 'letterpaper',

# The font size ('10pt', '11pt' or '12pt').
#'pointsize': '10pt',

# Additional stuff for the LaTeX preamble.
#'preamble': '',
}

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title,
#  author, documentclass [howto, manual, or own class]).
latex_documents = [
  ('index', 'nodeshot.tex', u'nodeshot Documentation',
   u'Federico Capoano', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# If true, show page references after internal links.
#latex_show_pagerefs = False

# If true, show URL addresses after external links.
#latex_show_urls = False

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_domain_indices = True


# -- Options for manual page output ---------------------------------------

# One entry per manual page. List of tuples
# (source start file, name, description, authors, manual section).
man_pages = [
    ('index', 'nodeshot', u'nodeshot Documentation',
     [u'Federico Capoano'], 1)
]

# If true, show URL addresses after external links.
#man_show_urls = False


# -- Options for Texinfo output -------------------------------------------

# Grouping the document tree into Texinfo files. List of tuples
# (source start file, target name, title, author,
#  dir menu entry, description, category)
texinfo_documents = [
  ('index', 'nodeshot', u'nodeshot Documentation',
   u'Federico Capoano', 'nodeshot', 'One line description of project.',
   'Miscellaneous'),
]

# Documents to append as an appendix to all manuals.
#texinfo_appendices = []

# If false, no module index is generated.
#texinfo_domain_indices = True

# How to display URL addresses: 'footnote', 'no', or 'inline'.
#texinfo_show_urls = 'footnote'

# If true, do not generate a @detailmenu in the "Top" node's menu.
#texinfo_no_detailmenu = False

########NEW FILE########
__FILENAME__ = fabfile
import json

from fabric.api import *
from fabric.contrib.files import append
from fabric.colors import green

# Put host(s) configuration here or use -h switch on command line
# env.hosts = ''
# env.password = ''

git_repo = 'https://github.com/ninuxorg/nodeshot.git'


def initialize():
    if 'root_dir' not in globals():
        initialize_dirs()

def initialize_server():
    if 'server_name' not in globals():
        global server_name
        server_name = prompt('Server name: ')

def initialize_ssl():
    print(green("****************************************"))
    print(green("Please insert SSL certificate details..."))
    print(green("****************************************"))
    run ('mkdir -p /tmp/nodeshot_install')
    with cd('/tmp/nodeshot_install'):
        run ('openssl req -new -x509 -nodes -days 365 -out server.crt -keyout server.key')

def initialize_db():
    db_params = ('db_user','db_pass')
    for db_param in db_params:
        if db_param not in globals():
            global db_user
            global db_pass
            db_user = prompt('Set database user: ', default='nodeshot')
            db_pass = prompt('Set database user password: ', )

def initialize_dirs():
    global root_dir
    global deploy_dir
    global project_dir
    global project_name
    global virtual_env
    root_dir = prompt('Set install directory ( including trailing slash ): ', default='/var/www/')
    project_name = prompt('Set project name: ', default='myproject')
    deploy_dir = '%snodeshot/' % root_dir
    project_dir = '%sprojects/%s' % (deploy_dir,project_name)
    virtual_env = 'source %s/python/bin/activate'  % project_dir

def uninstall():
    initialize()
    with cd(project_dir):
        run('cat dependencies.txt | xargs apt-get -y purge')

def install():
    initialize()
    initialize_server()
    initialize_db()
    initialize_ssl()
    install_git()
    clone()
    install_dependencies()
    install_postfix()
    create_virtual_env()
    install_requirements()
    create_project()
    create_db()
    create_settings()
    sync_data() # Fails if settings are not correctly set
    create_admin()
    nginx_config()
    supervisor_config()
    redis_install()
    start_server()
    warning_message()

def update(**kwargs):
    global root_dir
    global deploy_dir
    global project_dir
    global project_name
    global virtual_env
    root_dir = kwargs.get('root_dir')
    project_name = kwargs.get('project_name')
    deploy_dir = '%snodeshot/' % root_dir
    project_dir = '%sprojects/%s' % (deploy_dir,project_name)
    virtual_env = 'source %s/python/bin/activate'  % project_dir
    pull()
    install_requirements()
    sync_data(update=True)
    start_server()

def clone():
    initialize()
    print(green("Cloning repository..."))
    with hide('stdout', 'stderr'):
        run('mkdir -p  %s' % root_dir)
        with cd (root_dir):
            run ('rm -rf nodeshot')
            run('git clone %s nodeshot --depth=0' % git_repo  )

def install_git():
    print(green("Installing Git..."))
    with hide('stdout', 'stderr'):
        run('apt-get -y install git-core')

def install_dependencies():
    initialize()
    print(green("Installing required packages. This may take a while..."))
    run('apt-get update')
    with hide( 'stdout', 'stderr'):
        with cd('%sINSTALL' % deploy_dir):
            run('cat dependencies.txt | xargs apt-get -y install')
        with cd('/tmp/nodeshot_install'):
            run('cp %sINSTALL/install* . && ./install_GEOS.sh && ./install_Postgis.sh' % deploy_dir )

def install_postfix():
    initialize()
    initialize_server()
    with hide( 'stdout', 'stderr'):
        with cd('%sINSTALL' % deploy_dir):
            run('export DEBIAN_FRONTEND=noninteractive && apt-get -y install postfix')
            run ('cp main.cf /etc/postfix/main.cf')
            run ('sed -i \'s#nodeshot.yourdomain.com#%s#g\' /etc/postfix/main.cf ' % server_name)

def pull():
    initialize()
    with cd (deploy_dir):
        run('pwd')
        run('git pull')

def create_virtual_env():
    initialize()
    print(green("Creating virtual env..."))
    with hide( 'stdout', 'stderr'):
        run ('mkdir -p %s' % project_dir)
        with cd (project_dir):
            run('virtualenv python')

def install_requirements():
    initialize()
    print(green("Installing requirements. This may take a while..."))
    with hide( 'stdout', 'stderr'):
        pip_command = 'python/bin/pip install -r %srequirements.txt' % deploy_dir
        pip_command_nodeshot = 'python/bin/pip install -U https://github.com/ninuxorg/nodeshot/tarball/master'
        distribute_command = 'python/bin/pip install -U distribute'
        with cd (project_dir):
            run( virtual_env + ' &&  ' + pip_command  + ' &&  ' + distribute_command)
            run( virtual_env + ' &&  ' + pip_command_nodeshot)

def create_project():
    initialize()
    print(green("Creating project..."))

    template_name = "%sINSTALL/project_template" % deploy_dir
    create_project_command = "django-admin.py startproject %s --template=%s ." % (project_name,template_name)
    with hide( 'stdout', 'stderr'):
        with cd (project_dir):
            run( virtual_env + ' &&  ' + create_project_command  )

def create_db():
    initialize_db()
    print(green("Configuring DB..."))
    with hide( 'stdout', 'stderr'):
        run ('su - postgres -c "createdb nodeshot"')
        run ('su - postgres -c "psql nodeshot -c \'CREATE EXTENSION hstore;\'"')
        run ('su - postgres -c "psql nodeshot -c \'CREATE EXTENSION postgis;\'"')
        run ('su - postgres -c "psql nodeshot -c \'CREATE EXTENSION postgis_topology;\'"')
        run ('su - postgres -c "createuser %s  -R -S -D "'  % db_user)
        run ('sudo -u postgres psql -U postgres -d postgres -c \"alter user %s with password \'%s\';\"' % (db_user,db_pass))
        run ('su - postgres -c "psql -c \'GRANT ALL PRIVILEGES ON DATABASE "nodeshot" to %s \'"' % db_user)

def create_settings():
    initialize()
    initialize_db()
    initialize_server()
    print(green("Creating Nodeshot config..."))

    with cd ('%s/%s' % (project_dir,project_name)):
        run ('sed -i \'s#<app_path>#%s#g\' local_settings_template.py ' % deploy_dir)
        run ('sed -i \'s#<user>#%s#g\' local_settings_template.py ' % db_user)
        run ('sed -i \'s#<password>#%s#g\' local_settings_template.py ' % db_pass)
        run ('sed -i \'s#<domain>#%s#g\' local_settings_template.py ' % server_name)
        run ('mv local_settings_template.py local_settings.py')

def sync_data(update=None):
    initialize()
    print(green("Initializing Nodeshot..."))
    virtual_env = 'source %s/python/bin/activate'  % project_dir
    sync_command = 'python manage.py syncdb --noinput && python manage.py migrate && python manage.py collectstatic --noinput'
    if update is not None:
        sync_command = 'python manage.py syncdb --noinput %s && python manage.py migrate && python manage.py collectstatic --noinput' % '--no-initial-data'
    with cd (project_dir):
        run('mkdir -p log'  )
        run('touch log/%s.error.log' % project_name )
        run('chmod 666 log/%s.error.log' % project_name)
        run( virtual_env + ' &&  ' + sync_command)

def create_admin():
    initialize()
    print(green("Creating Nodeshot admin account..."))

    create_admin_command = 'python manage.py loaddata %sINSTALL/admin_fixture.json' % deploy_dir
    with cd (project_dir):
        run( virtual_env + ' &&  ' + create_admin_command)

def nginx_config():
    initialize()
    initialize_server()
    print(green("Configuring Nginx..."))
    nginx_dir = '/etc/nginx/ssl'
    run ('mkdir -p %s' % nginx_dir)
    with cd (nginx_dir):
        print(green("Insert Certificate details..."))
        run ('cp /tmp/nodeshot_install/server.crt .')
        run ('cp /tmp/nodeshot_install/server.key .')

    run('cp /etc/nginx/uwsgi_params /etc/nginx/sites-available/')
    #run ('mkdir -p /var/www/nodeshot/public_html')

    run ('cp %sINSTALL/nodeshot.yourdomain.com /etc/nginx/sites-available/nodeshot.yourdomain.com' % deploy_dir)

    with cd('/etc/nginx/sites-available'):
        run ('sed \'s/nodeshot.yourdomain.com/%s/g\' nodeshot.yourdomain.com > %s' % (server_name,server_name))
        run ('sed -i \'s#PROJECT_PATH#%s#g\' %s ' % (project_dir,server_name))
        run ('sed -i \'s#PROJECT_NAME#%s#g\' %s ' % (project_name,server_name))
        run ('ln -s /etc/nginx/sites-available/%s /etc/nginx/sites-enabled/%s' % (server_name,server_name))

def supervisor_config():
    initialize()
    print(green("Configuring Supervisor..."))
    with hide( 'stdout', 'stderr'):
        run ('pip install uwsgi')
        with cd (project_dir):
            run ('cp %sINSTALL/uwsgi.ini .' % deploy_dir)
            run ('sed -i \'s#PROJECT_PATH#%s#g\' uwsgi.ini ' % project_dir)
            run ('sed -i \'s#PROJECT_NAME#%s#g\' uwsgi.ini ' % project_name)
        run ('cp %sINSTALL/uwsgi.conf /etc/supervisor/conf.d/uwsgi.conf' % deploy_dir)
        run ('cp %sINSTALL/celery.conf /etc/supervisor/conf.d/celery.conf' % deploy_dir)
        run ('cp %sINSTALL/celery-beat.conf /etc/supervisor/conf.d/celery-beat.conf' % deploy_dir)
        with cd ('/etc/supervisor/conf.d/'):
            run ('sed -i \'s#PROJECT_PATH#%s#g\' uwsgi.conf ' % project_dir)
            run ('sed -i \'s#PROJECT_PATH#%s#g\' celery.conf ' % project_dir)
            run ('sed -i \'s#PROJECT_NAME#%s#g\' celery.conf ' % project_name)
            run ('sed -i \'s#PROJECT_PATH#%s#g\' celery-beat.conf ' % project_dir)
            run ('sed -i \'s#PROJECT_NAME#%s#g\' celery-beat.conf ' % project_name)
        run('supervisorctl update')

def redis_install():
    initialize()
    print(green("Installing redis..."))
    with hide( 'stdout', 'stderr'):

        pip_command = 'python/bin/pip install -U celery[redis]'
        run('add-apt-repository -y ppa:chris-lea/redis-server')
        run('apt-get -y update')
        run('apt-get -y install redis-server')
        with cd (project_dir):
            run( virtual_env + ' &&  ' + pip_command)

def start_server():
    initialize()
    print(green("Starting Nodeshot server..."))
    with cd (project_dir):
        run('service nginx restart && supervisorctl restart all')
    print(green("Nodeshot server started"))
    print(green("Cleaning installation directory..."))
    run ('rm -rf /tmp/nodeshot_install')
    print(green("Installation completed"))

def warning_message():
    initialize_server()
    print(green("Cleaning installation directory..."))
    run ('rm -rf /tmp/nodeshot_install')
    print(green("\nINSTALLATION COMPLETED !\n"))
    print (green("############################################################"))
    print (green("                      WARNING:                     "))
    print (green(" Superuser is currently set as 'admin' with password 'admin'"))
    print (green(" Logon on %s/admin and change it " % server_name))
    print (green("############################################################"))

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "{{ project_name }}.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = local_settings_template
# Django local settings for nodeshot project.

APP_PATH = '<app_path>'
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'nodeshot',                      # Or path to database file if using sqlite3.
        'USER': '<user>',                      # Not used with sqlite3.
        'PASSWORD': '<password>',                  # Not used with sqlite3.
        'HOST': '127.0.0.1',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}
DOMAIN = '<domain>'



########NEW FILE########
__FILENAME__ = settings
# Django settings for nodeshot project.

import os
import sys

from local_settings import *

ALLOWED_HOSTS = ['*']
SECRET_KEY = '{{ secret_key }}'
DEBUG = False

SERVE_STATIC = DEBUG
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS


# uncomment if you need to use nodeshot.extra.oldimporter
#if 'test' not in sys.argv:
#    DATABASES['old_nodeshot'] = {
#       'ENGINE': 'django.db.backends.mysql',  # might be also postgresql or sqlite
#       'NAME': 'nodeshot',
#       'USER': 'nodeshot-readonly',
#       'PASSWORD': '*********',
#       'HOST': 'remote-ip',
#       'PORT': 'remote-port',
#    }
#    DATABASE_ROUTERS = [
#        'nodeshot.extra.oldimporter.db.DefaultRouter',
#        'nodeshot.extra.oldimporter.db.OldNodeshotRouter'
#    ]


# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'Europe/Rome'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-gb'

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

SITE_ID = 1
PROTOCOL = 'http' if DEBUG else 'https'
PORT = '8000' if DEBUG else None
SITE_URL = '%s://%s' % (PROTOCOL, DOMAIN)

if PORT and PORT not in ['80', '443']:
    SITE_URL = '%s:%s' % (SITE_URL, PORT)

SITE_ROOT = os.path.dirname(os.path.realpath(__file__))

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = '%s/media/' % SITE_ROOT

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '%s/media/' % SITE_URL

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = '%s/static/' % SITE_ROOT

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '%s/static/' % SITE_URL

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

if PROTOCOL == 'https':
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    os.environ['HTTPS'] = 'on'

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = '{{ project_name }}.urls' # 

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = '{{ project_name }}.wsgi.application'


TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.request",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages"
)

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',

    # PostgreSQL HStore extension support
    'django_hstore',

    # admin site
    'grappelli.dashboard',
    'grappelli',
    'filebrowser',
    'django.contrib.admin',

    # --- background jobs --- #
    'djcelery_email',  # Celery Django Email Backend

    # nodeshot
    'nodeshot.core.api',
    'nodeshot.core.layers',
    'nodeshot.core.nodes',
    'nodeshot.core.cms',
    'nodeshot.core.websockets',
    'nodeshot.interoperability',
    'nodeshot.community.participation',
    'nodeshot.community.notifications',
    'nodeshot.community.profiles',
    'nodeshot.community.mailing',
    'nodeshot.networking.net',
    'nodeshot.networking.links',
    'nodeshot.networking.services',
    'nodeshot.networking.hardware',
    'nodeshot.networking.connectors',
    'nodeshot.ui.default',
    'nodeshot.open311',
    'nodeshot.ui.open311_demo',

    # import data from old nodeshot version 0.9
    # needs python MySQL database driver
    # run "pip install MySQL-python"
    # you might need to run also a similar command according to your own OS distribution:
    # sudo apt-get install libmysqlclient-dev
    #'nodeshot.extra.oldimporter',

    # 3d parthy django apps
    'rest_framework',
    'rest_framework_swagger',
    'olwidget',  # geodjango better widgets
    'south',
    # 'debug_toolbar',
    'smuggler',
    'reversion',
    
    # django-cors-headers
    'corsheaders',

    # profiles and social networks
    'emailconfirmation',
    'social_auth',

    # other utilities
    # 'django_extensions',

    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
]

if 'nodeshot.community.profiles' in INSTALLED_APPS:
    AUTH_USER_MODEL = 'profiles.Profile'

# ------ DJANGO LOGGING ------ #

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'logfile': {
            'level': 'ERROR',
            'class':'logging.handlers.RotatingFileHandler',
            'formatter': 'verbose',
            'filename': SITE_ROOT + "/../log/{{ project_name }}.error.log",
            'maxBytes': 10485760,  # 10 MB
            'backupCount': 3,
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'django': {
            'handlers':['logfile'],
            'level':'ERROR',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins', 'logfile'],
            'level': 'ERROR',
            'propagate': True,
        },
        '': {
            'handlers': ['logfile'],
            'level': 'ERROR',
        },
    },
    'formatters': {
        'verbose': {
            'format': '\n\n[%(levelname)s %(asctime)s] module: %(module)s, process: %(process)d, thread: %(thread)d\n%(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
        'custom': {
            'format': '%(levelname)s %(asctime)s\n%(message)s'
        },
    },
}

# ------ DJANGO CACHE ------ #

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'TIMEOUT': 172800 if not DEBUG else 300,
        'OPTIONS': {
            'MAX_ENTRIES': 1000
        }
    }
}

# ------ EMAIL SETTINGS ------ #

# if you want a dummy SMTP server that logs outgoing emails but doesn't actually send them
# you have 2 options:
#     * python -m -smtpd -n -c DebuggingServer localhost:1025
#     * python manage.py mail_debug  (django-extensions must be installed)

#EMAIL_USE_TLS = True
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = 'your@email.org'
#EMAIL_HOST_PASSWORD = '***********'
EMAIL_PORT = 1025 if DEBUG else 25  # 1025 if you are in development mode, while 25 is usually the production port
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
SERVER_EMAIL = DEFAULT_FROM_EMAIL  # used for error reporting

# ------ CELERY ------ #

if DEBUG:
    # this app makes it possible to use django as a queue system for celery
    # so you don't need to install RabbitQM or Redis
    # pretty cool for development, but might not suffice for production if your system is heavily used
    # our suggestion is to switch only if you start experiencing issues
    INSTALLED_APPS.append('kombu.transport.django')
    BROKER_URL = 'django://'
    # synchronous behaviour for development
    # more info here: http://docs.celeryproject.org/en/latest/configuration.html#celery-always-eager
    CELERY_ALWAYS_EAGER = True
    CELERY_EAGER_PROPAGATES_EXCEPTIONS = True
else:
    # in production the default background queue manager is Redis
    BROKER_URL = 'redis://localhost:6379/0'
    CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
    BROKER_TRANSPORT_OPTIONS = {
        "visibility_timeout": 3600,  # 1 hour
        "fanout_prefix": True
    }
    # in production emails are sent in the background
    EMAIL_BACKEND = 'djcelery_email.backends.CeleryEmailBackend'

#from datetime import timedelta
#
#CELERYBEAT_SCHEDULE = {
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#    },
#    # example of how to synchronize one of the layers with a different periodicity
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(minutes=30),
#        'args': ('layer_slug',)
#    },
#    # example of how to synchronize all layers except two layers
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#        'kwargs': { 'exclude': 'layer1-slug,layer2-slug' }
#    },
#    'purge_notifications': {
#        'task': 'nodeshot.community.notifications.tasks.purge_notifications',
#        'schedule': timedelta(days=1),
#    }
#}

# ------ NODESHOT ------ #

# https://docs.djangoproject.com/en/dev/topics/i18n/translation/
# look for (ctrl + f) 'lambda' and you'll find why the following is needed
_ = lambda s: s

NODESHOT = {
    'SETTINGS': {
        # api prefix examples:
        #   * api/
        #   * api/v1/
        # leave blank to include api urls at root level, such as /nodes/, /layers/ and so on
        'API_PREFIX': 'api/v1/',
        'ACL_GLOBAL_EDITABLE': True,

        # the following is an example of possible granular ACL setting that can be specified
        #'ACL_NODES_NODE_EDITABLE': False,

        'LAYER_TEXT_HTML': True,
        'NODE_DESCRIPTION_HTML': True,

        'CONTACT_INWARD_LOG': True,
        'CONTACT_INWARD_MAXLENGTH': 2000,
        'CONTACT_INWARD_MINLENGTH': 15,
        'CONTACT_INWARD_REQUIRE_AUTH': False,
        'CONTACT_OUTWARD_MAXLENGTH': 9999,
        'CONTACT_OUTWARD_MINLENGTH': 50,
        'CONTACT_OUTWARD_STEP': 20,
        'CONTACT_OUTWARD_DELAY': 10,
        'CONTACT_OUTWARD_HTML': True,  # grappelli must be in INSTALLED_APPS, otherwise it won't work

        'PROFILE_EMAIL_CONFIRMATION': True,
        'PROFILE_REQUIRED_FIELDS': ['email'],

        'ADMIN_MAP_COORDS': [41.8934, 12.4960],  # lat, lng
        'ADMIN_MAP_ZOOM': 1,  # default zoom in the admin

        'REVERSION_LAYERS': True,  # activate django reversion for layers.Layer model
        'REVERSION_NODES': True,  # activate django reversion for nodes.Node model
    },
    'CHOICES': {
        'AVAILABLE_CRONJOBS': (
            ('00', _('midnight')),
            ('04', _('04:00 AM')),
        ),
        'ACCESS_LEVELS': {
            'registered': 1,
            'community': 2,
            'trusted': 3
        },
        'APPLICATION_PROTOCOLS': (
            ('http', 'http'),
            ('https', 'https'),
            ('ftp', 'FTP'),
            ('smb', 'Samba'),
            ('afp', 'Apple File Protocol'),
            ('git', 'Git'),
        )
    },
    # default values for the application or new database objects
    'DEFAULTS': {
        'NODE_PUBLISHED': True,
        'LAYER_ZOOM': 12,
        'LAYER_MINIMUM_DISTANCE': 0,
        'MAILING_SCHEDULE_OUTWARD': False,
        'ACL_GLOBAL': 'public',
        # default access_level value for app: services, model: Login
        'ACL_SERVICES_LOGIN': 'community',
        'NOTIFICATION_BOOLEAN_FIELDS': True,
        'NOTIFICATION_DISTANCE_FIELDS': 30
    },
    'API': {
        'APPS_ENABLED': [
            'nodeshot.core.nodes',
            'nodeshot.core.layers',
            'nodeshot.core.cms',
            'nodeshot.community.profiles',
            'nodeshot.community.participation',
            'nodeshot.community.notifications',
            'nodeshot.community.mailing',
            'nodeshot.networking.net',
            'nodeshot.networking.links',
            'nodeshot.networking.services',
            'nodeshot.open311'
        ]
    },
    'INTEROPERABILITY': [
        ('nodeshot.interoperability.synchronizers.Nodeshot', 'Nodeshot'),
        ('nodeshot.interoperability.synchronizers.GeoJson', 'GeoJSON'),
        ('nodeshot.interoperability.synchronizers.GeoRss', 'GeoRSS'),
        ('nodeshot.interoperability.synchronizers.OpenWISP', 'OpenWISP'),
        ('nodeshot.interoperability.synchronizers.OpenWISPCitySDK', 'OpenWISPCitySDK'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFI', 'Provincia WiFi'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFICitySDK', 'ProvinciaWIFICitySDK'),
    ],
    'NOTIFICATIONS': {
        'TEXTS': {
            'custom': None,
            'node_created': _('A new node with name "%(name)s" has been created.'),
            'node_status_changed': _('Status of node "%(name)s" has changed from "%(old_status)s" to "%(new_status)s".'),
            'your_node_status_changed': _('Status of your node "%(name)s" changed from "%(old_status)s" to "%(new_status)s".'),
            'node_deleted': _('Node "%(name)s" with ID #%(id)s was deleted.'),
        },
        # boolean: users can only turn on or off
        # distance: users can turn off (-1), turn on for all (0) or set a range of km (n)
        'USER_SETTING': {
            'node_created':             { 'type': 'distance', 'geo_field': 'geometry' },
            'node_status_changed':      { 'type': 'distance', 'geo_field': 'geometry' },
            'node_deleted':             { 'type': 'distance', 'geo_field': 'geometry' },
            'your_node_status_changed': { 'type': 'boolean' },
        },
        'ACTIONS': {
            'node_created': "reverse('api_node_details', args=[self.related_object.slug])",
            'node_status_changed': "reverse('api_node_details', args=[self.related_object.slug])",
            'your_node_status_changed': "reverse('api_node_details', args=[self.related_object.slug])",
        },
        'DELETE_OLD': 40,  # delete notifications older than specified days
        'REGISTRARS': (
            'nodeshot.community.notifications.registrars.nodes',
        )
    },
    'WEBSOCKETS': {
        'PUBLIC_PIPE': '%s/nodeshot.websockets.public' % os.path.dirname(SITE_ROOT),
        'PRIVATE_PIPE': '%s/nodeshot.websockets.private' % os.path.dirname(SITE_ROOT),
        'DOMAIN': DOMAIN,
        'LISTENING_ADDRESS': '0.0.0.0',  # set to 127.0.0.1 to accept only local calls (used for proxying to port 80 with nginx or apache mod_proxy)
        'LISTENING_PORT': 9090,
        'REGISTRARS': (
            'nodeshot.core.websockets.registrars.nodes',
        )
    },
    # list that will contain functions to disable and re-enable some signals
    # for large import of data notifications, websockets, participation counts and similar operations
    # might be temporarily disabled to avoid unnecessary database load
    'DISCONNECTABLE_SIGNALS': [],
    # settings for old nodeshot importer
    'OLD_IMPORTER':{
        'DEFAULT_LAYER': 30,
        'STATUS_MAPPING': {
            'a': 'active',
            'h': 'active',
            'ah': 'active',
            'p': 'potential',
            'default': 'potential'
        }
    },
    'NETENGINE_BACKENDS': [
        ('netengine.backends.ssh.AirOS', 'AirOS (SSH)'),
        ('netengine.backends.ssh.OpenWRT', 'OpenWRT (SSH)'),
        ('netengine.backends.snmp.AirOS', 'AirOS (SNMP)'),
    ],
    'OPEN311': {
        # Metadata for service discovery
        'DISCOVERY': {
            'changeset':'2014-02-03 14:18',
            'contact':'email or phone number for assistance',
            'key_service':'URL for api_key requests',
            'endpoints':[
                {
                    'specification':'http://wiki.open311.org/GeoReport_v2',
                    'url':'Public URL of your endpoint',
                    'changeset':'2014-02-03 09:01',
                    'type':'production',
                    'formats':[
                        'application/json'
                    ]
                },

            ]
        },
        # Do not change this unless you want to redefine Open311 service definitions
        'METADATA': 'true',
        'TYPE': 'realtime',
        # Change the following, according to the statuses you have configured in your model
        'STATUS' : {
            'potential': 'open',
            'planned': 'open',
            'active': 'closed',
        }
    }
}

NODESHOT['DEFAULTS']['CRONJOB'] = NODESHOT['CHOICES']['AVAILABLE_CRONJOBS'][0][0]

if 'test' in sys.argv:
    NODESHOT['NETENGINE_BACKENDS'].append(
        ('netengine.backends.Dummy', 'Dummy')
    )

# ------ GRAPPELLI ------ #

if 'grappelli' in INSTALLED_APPS:
    GRAPPELLI_ADMIN_TITLE = 'Nodeshot Admin'
    GRAPPELLI_INDEX_DASHBOARD = 'nodeshot.dashboard.NodeshotDashboard'

# ------ DEBUG TOOLBAR ------ #

INTERNAL_IPS = ('127.0.0.1', '::1',)  # ip addresses where you want to show the debug toolbar here
DEBUG_TOOLBAR_CONFIG = {
    'INTERCEPT_REDIRECTS': False,
}

# ------ UNIT TESTING SPEED UP ------ #

SOUTH_DATABASE_ADAPTERS = {'default': 'south.db.postgresql_psycopg2'}
SOUTH_TESTS_MIGRATE = False

if 'test' in sys.argv:
    CELERY_ALWAYS_EAGER = True

    PASSWORD_HASHERS = (
        'django.contrib.auth.hashers.MD5PasswordHasher',
        'django.contrib.auth.hashers.SHA1PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
        'django.contrib.auth.hashers.BCryptPasswordHasher',
    )

# ------ SOCIAL AUTH SETTINGS ------ #

if 'social_auth' in INSTALLED_APPS:
    MIDDLEWARE_CLASSES += ('social_auth.middleware.SocialAuthExceptionMiddleware',)

    # In Django 1.6, the default session serliazer has been switched to one based on JSON,
    # rather than pickles, to improve security. Django-openid-auth does not support this
    # because it attemps to store content that is not JSON serializable in sessions.
    # See https://docs.djangoproject.com/en/dev/releases/1.6/#default-session-serialization-switched-to-json
    # for details on the Django 1.6 change.
    SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'

    AUTHENTICATION_BACKENDS = (
        'django.contrib.auth.backends.ModelBackend',
        'nodeshot.community.profiles.backends.EmailBackend',
        'social_auth.backends.facebook.FacebookBackend',
        'social_auth.backends.google.GoogleBackend',
        'social_auth.backends.contrib.github.GithubBackend',
    )

    SOCIAL_AUTH_PIPELINE = (
        'social_auth.backends.pipeline.social.social_auth_user',
        #'social_auth.backends.pipeline.associate.associate_by_email',
        'social_auth.backends.pipeline.user.get_username',
        'social_auth.backends.pipeline.user.create_user',
        'social_auth.backends.pipeline.social.associate_user',
        'nodeshot.community.profiles.social_auth_extra.pipeline.load_extra_data',
        'social_auth.backends.pipeline.user.update_user_details'
    )

    SOCIAL_AUTH_ENABLED_BACKENDS = ('facebook', 'google', 'github')

    # register a new app:
    FACEBOOK_APP_ID = ''  # put your app id
    FACEBOOK_API_SECRET = ''
    FACEBOOK_EXTENDED_PERMISSIONS = ['email', 'user_about_me', 'user_birthday', 'user_hometown']

    # register a new app:
    GITHUB_APP_ID = ''
    GITHUB_API_SECRET = ''
    GITHUB_EXTENDED_PERMISSIONS = ['user:email']

    SOCIAL_AUTH_DEFAULT_USERNAME = 'new_social_auth_user'
    SOCIAL_AUTH_UUID_LENGTH = 3
    SOCIAL_AUTH_SESSION_EXPIRATION = False
    SOCIAL_AUTH_ASSOCIATE_BY_MAIL = True

    LOGIN_URL = '/'
    LOGIN_REDIRECT_URL = '/'
    LOGIN_ERROR_URL    = '/'

# ------ CORS-HEADERS SETTINGS ------ #

CORS_ORIGIN_ALLOW_ALL = True

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.conf import settings
from django.contrib import admin

admin.autodiscover()


urlpatterns = patterns('',
    # smuggler for fixture management
    # must be before admin url patterns
    url(r'^admin/', include('smuggler.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    url(r'', include('nodeshot.urls'))
)


if settings.DEBUG and settings.SERVE_STATIC:
    urlpatterns += patterns('django.contrib.staticfiles.views',
        url(r'^static/(?P<path>.*)$', 'serve'),
        url(r'^media/(?P<path>.*)$', 'serve'),
    )

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for nodeshot project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "{{ project_name }}.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.conf import settings
from django.contrib.auth import get_user_model
User = get_user_model()
from django.contrib import messages
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.admin import BaseAdmin
from nodeshot.core.layers.models import Layer
from .models import Inward, Outward

import os


class InwardAdmin(BaseAdmin):
    list_display  = ('from_email', 'from_name', 'to',  'status', 'added', 'updated')
    search_fields = ('from_email', 'from_name')
    # define the autocomplete_lookup_fields
    if 'grappelli' in settings.INSTALLED_APPS:
        autocomplete_lookup_fields = {
            'generic': [['content_type', 'object_id']],
        }


def send_now(modeladmin, request, queryset):
    """
    Send now action available in change outward list
    """
    objects = queryset
    for obj in objects:
        obj.send()
    send_now.short_description = _('Send selected messages now')
    # show message in the admin
    messages.info(request, _('Message sent successfully'))


class OutwardAdmin(BaseAdmin):
    list_display  = ('subject', 'status', 'is_scheduled', 'added', 'updated')
    list_filter   = ('status', 'is_scheduled')
    filter_horizontal = ['layers', 'users']
    search_fields = ('subject',)
    actions = [send_now]
    change_form_template = '%s/templates/admin/outward_change_form.html' % os.path.dirname(os.path.realpath(__file__))
    
    def formfield_for_manytomany(self, db_field, request, **kwargs):
        if db_field.name == 'layers':
            kwargs['queryset'] = Layer.objects.filter(is_external=False)
        if db_field.name == 'users':
            kwargs['queryset'] = User.objects.filter(is_active=True)
        return super(OutwardAdmin, self).formfield_for_manytomany(db_field, request, **kwargs)
    
    # Enable TinyMCE HTML Editor according to settings, defaults to True
    if (settings.NODESHOT['SETTINGS'].get('CONTACT_OUTWARD_HTML', True) is True):
        # enable editor for "description" only
        html_editor_fields = ['message']

admin.site.register(Inward, InwardAdmin)
admin.site.register(Outward, OutwardAdmin)

########NEW FILE########
__FILENAME__ = choices
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from nodeshot.core.base.utils import choicify


__all__ = [
    'AVAILABLE_CRONJOBS',
    'SCHEDULE_CHOICES',
    'FILTERING_CHOICES',
    'FILTER_CHOICES',
    'FILTERS',
    'OUTWARD_STATUS_CHOICES',
    'OUTWARD_STATUS',
    'GROUPS',
    'DEFAULT_GROUPS',
    'INWARD_STATUS_CHOICES'
]


try:
    AVAILABLE_CRONJOBS = settings.NODESHOT['CHOICES']['AVAILABLE_CRONJOBS']
except KeyError:
    AVAILABLE_CRONJOBS = (
        ('00', _('midnight')),
        ('04', _('04:00 AM')),
    )

SCHEDULE_CHOICES = (
    (0, _("Don't schedule, send immediately")),
    (1, _('Schedule')),
)

FILTERING_CHOICES = (
    (0, _('Send to all')),
    (1, _('Send accordingly to selected filters')),
)

FILTER_CHOICES = (
    (1, _('users of the selected groups')),
    (2, _('users which have a node in one of the selected layers')),
    (3, _('chosen users')),
)

# this is just for convenience and readability
FILTERS = {
    'groups': str(FILTER_CHOICES[0][0]),
    'layers': str(FILTER_CHOICES[1][0]),
    'users': str(FILTER_CHOICES[2][0])
}

OUTWARD_STATUS_CHOICES = (
    (-1, _('error')),
    (0, _('draft')),
    (1, _('scheduled')),
    (2, _('sent')),
    (3, _('cancelled'))
)

# this is just for convenience and readability
OUTWARD_STATUS = {
    'error': OUTWARD_STATUS_CHOICES[0][0],
    'draft': OUTWARD_STATUS_CHOICES[1][0],
    'scheduled': OUTWARD_STATUS_CHOICES[2][0],
    'sent': OUTWARD_STATUS_CHOICES[3][0],
    'cancelled': OUTWARD_STATUS_CHOICES[4][0]
}

GROUPS = []
DEFAULT_GROUPS = ''
# convert strings to integers
for group in choicify(settings.NODESHOT['CHOICES']['ACCESS_LEVELS']):
    GROUPS += [(int(group[0]), group[1])]
    DEFAULT_GROUPS += '%s,' % group[0]
GROUPS += [(0, _('super users'))]
DEFAULT_GROUPS += '0'

INWARD_STATUS_CHOICES = (
    (-1, _('Error')),
    (0, _('Not sent yet')),
    (1, _('Sent')),
    (2, _('Cancelled')),
)

########NEW FILE########
__FILENAME__ = inward
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.contrib.sites.models import Site
from django.core.validators import MaxLengthValidator, MinLengthValidator
from django.core.exceptions import ValidationError
from django.core.mail import EmailMessage
from django.conf import settings

from nodeshot.core.base.models import BaseDate

from .choices import INWARD_STATUS_CHOICES


user_app_label = settings.AUTH_USER_MODEL.split('.')[0]
user_model_name = settings.AUTH_USER_MODEL.split('.')[1]
limit = (
    models.Q(app_label='nodes', model='node') |
    models.Q(app_label=user_app_label, model=user_model_name.lower()) |
    models.Q(app_label='layers', model='layer')
)
USER_CAN_BE_BLANK = not settings.NODESHOT['SETTINGS']['CONTACT_INWARD_REQUIRE_AUTH']


class Inward(BaseDate):
    """
    Incoming messages from users
    """
    # could be a node, an user or a layer
    status = models.IntegerField(_('status'), choices=INWARD_STATUS_CHOICES, default=INWARD_STATUS_CHOICES[1][0])
    content_type = models.ForeignKey(ContentType, limit_choices_to=limit)
    object_id = models.PositiveIntegerField()
    to = generic.GenericForeignKey('content_type', 'object_id')
    user = models.ForeignKey(settings.AUTH_USER_MODEL, verbose_name=_('user'), blank=USER_CAN_BE_BLANK, null=True)
    from_name = models.CharField(_('name'), max_length=50, blank=True)
    from_email = models.EmailField(_('email'), max_length=50, blank=True)
    message = models.TextField(_('message'), validators=[
        MaxLengthValidator(settings.NODESHOT['SETTINGS']['CONTACT_INWARD_MAXLENGTH']),
        MinLengthValidator(settings.NODESHOT['SETTINGS']['CONTACT_INWARD_MINLENGTH'])
    ])
    ip = models.GenericIPAddressField(verbose_name=_('ip address'), blank=True, null=True)
    user_agent = models.CharField(max_length=255, blank=True)
    accept_language = models.CharField(max_length=255, blank=True)
    
    class Meta:
        verbose_name = _('Inward message')
        verbose_name_plural = _('Inward messages')
        app_label= 'mailing'
        ordering = ['-status']
    
    def __unicode__(self):
        return _(u'Message from %(from)s to %(to)s') % ({'from': self.from_name, 'to': self.content_type})
    
    def clean(self, *args, **kwargs):
        """ custom validation """
        if not self.user and (not self.from_name or not self.from_email):
            raise ValidationError(_('If sender is not specified from_name and from_email must be filled in'))
        
        # fill name and email
        if self.user:
            self.from_name = self.user.get_full_name()
            self.from_email = self.user.email
    
    def send(self):
        """
        Sends the email to the recipient
        If the sending fails will set the status of the instance to "error" and will log the error according to your project's django-logging configuration
        """
        if self.content_type.name == 'node':
            to = [self.to.user.email]
        elif self.content_type.name == 'layer':
            to = [self.to.email]
            # layer case is slightly special, mantainers need to be notified as well
            # TODO: consider making the mantainers able to switch off notifications
            for mantainer in self.to.mantainers.all().only('email'):
                to += [mantainer.email]
        else:
            to = [self.to.email]

        email = EmailMessage(
            # subject
            _('Contact request from %(sender)s - %(site)s') % {'sender': self.from_name, 'site': Site.objects.get(pk=settings.SITE_ID)},
            # message
            self.message,
            # from
            settings.DEFAULT_FROM_EMAIL,
            # to
            to,
            # reply-to header
            headers = {'Reply-To': self.from_email}
        )
        
        import socket
        # try sending email
        try:
            email.send()            
            self.status = 1
        # if error
        except socket.error as e:
            # log the error
            import logging
            log = logging.getLogger(__name__)
            error_msg = 'nodeshot.community.mailing.models.inward.send(): %s' % e
            log.error(error_msg)
            # set status of the instance as "error"
            self.status = -1
    
    def save(self, *args, **kwargs):
        """
        Custom save method
        """
        # fill name and email
        if self.user:
            self.from_name = self.user.get_full_name()
            self.from_email = self.user.email
        
        # if not sent yet
        if int(self.status) < 1:
            # tries sending email (will modify self.status!)
            self.send()
        
        # save in the database unless logging is explicitly turned off in the settings file
        if settings.NODESHOT['SETTINGS']['CONTACT_INWARD_LOG']:
            super(Inward, self).save(*args, **kwargs)

########NEW FILE########
__FILENAME__ = outward
import socket
import time

from django.db import models
from django.db.models import Q
from django.core.validators import MaxLengthValidator, MinLengthValidator
from django.core.exceptions import ValidationError
from django.core.mail import EmailMessage, EmailMultiAlternatives
from django.utils.translation import ugettext_lazy as _
from django.utils.html import strip_tags
from django.conf import settings
from django.contrib.auth import get_user_model

from nodeshot.core.base.models import BaseDate
from nodeshot.core.base.fields import MultiSelectField
from nodeshot.core.base.utils import now
from nodeshot.core.nodes.models import Node

from .choices import *


class Outward(BaseDate):
    """
    This is a tool that can be used to send out newsletters or important communications to your community.
    It's aimed to be useful and flexible.
    """
    status = models.IntegerField(_('status'), choices=OUTWARD_STATUS_CHOICES,
                                 default=OUTWARD_STATUS.get('draft'))
    subject = models.CharField(_('subject'), max_length=50)
    message = models.TextField(_('message'), validators=[
        MinLengthValidator(settings.NODESHOT['SETTINGS']['CONTACT_OUTWARD_MINLENGTH']),
        MaxLengthValidator(settings.NODESHOT['SETTINGS']['CONTACT_OUTWARD_MAXLENGTH'])        
    ])
    is_scheduled = models.SmallIntegerField(_('schedule sending'),
                                            choices=SCHEDULE_CHOICES,
                                            default=1 if settings.NODESHOT['DEFAULTS']['MAILING_SCHEDULE_OUTWARD'] is True else 0)
    scheduled_date = models.DateField(_('scheduled date'), blank=True, null=True)
    scheduled_time = models.CharField(_('scheduled time'), max_length=20,
                                      choices=AVAILABLE_CRONJOBS,
                                      default=settings.NODESHOT['DEFAULTS']['CRONJOB'],
                                      blank=True)
    is_filtered = models.SmallIntegerField(_('recipient filtering'),
                                           choices=FILTERING_CHOICES,
                                           default=0)
    filters = MultiSelectField(max_length=255, choices=FILTER_CHOICES,
                               blank=True,
                               help_text=_('specify recipient filters'))
    groups = MultiSelectField(max_length=255, choices=GROUPS,
                              default=DEFAULT_GROUPS,
                              blank=True,
                              help_text=_('filter specific groups of users'))
    
    if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
        layers = models.ManyToManyField('layers.Layer', verbose_name=_('layers'), blank=True)
    
    users = models.ManyToManyField(settings.AUTH_USER_MODEL, verbose_name=_('users'), blank=True)
    
    class Meta:
        verbose_name = _('Outward message')
        verbose_name_plural = _('Outward messages')
        app_label= 'mailing'
        ordering = ['status']
    
    def __unicode__(self):
        return '%s' % self.subject
    
    def get_recipients(self):
        """
        Determine recipients depending on selected filtering which can be either:
            * group based
            * layer based
            * user based
        
        Choosing "group" and "layer" filtering together has the effect of sending the message
        only to users for which the following conditions are both true:
            * have a node assigned to one of the selected layers
            * are part of any of the specified groups (eg: registered, community, trusted)
            
        The user based filtering has instead the effect of translating in an **OR** query. Here's a practical example:
        if selecting "group" and "user" filtering the message will be sent to all the users for which ANY of the following conditions is true:
            * are part of any of the specified groups (eg: registered, community, trusted)
            * selected users
        """
        # user model
        User = get_user_model()
        
        # prepare email list
        emails = []
        
        # the following code is a bit ugly. Considering the titanic amount of work required to build all
        # the cools functionalities that I have in my mind, I can't be bothered to waste time on making it nicer right now.
        # if you have ideas on how to improve it to make it cleaner and less cluttered, please join in
        # this method has unit tests written for it, therefore if you try to change it be sure to check unit tests do not fail after your changes
        # python manage.py test mailing
        
        # send to all case
        if not self.is_filtered:
            # retrieve only email DB column of all active users
            users = User.objects.filter(is_active=True).only('email')
            # loop over users list
            for user in users:
                # add email to the recipient list if not already there
                if not user.email in emails:
                    emails += [user.email]
        else:
            # selected users
            if FILTERS.get('users') in self.filters:
                # retrieve selected users
                users = self.users.all().only('email')
                # loop over selected users
                for user in users:
                    # add email to the recipient list if not already there
                    if not user.email in emails:
                        emails += [user.email]
            
            # Q is a django object for "complex" filtering queries (not that complex in this case)
            # init empty Q object that will be needed in case of group filtering
            q = Q()
            q2 = Q()
            
            # if group filtering is checked
            if FILTERS.get('groups') in self.filters:
                # loop over each group
                for group in self.groups:
                    # if not superusers
                    if group != '0':
                        # add the group to the Q object
                        # this means that the query will look for users of that specific group
                        q = q | Q(groups=int(group))
                        q2 = q2 | Q(user__groups=int(group))
                    else:
                        # this must be done manually because superusers is not a group but an attribute of the User model
                        q = q | Q(is_superuser=True)
                        q2 = q2 | Q(user__is_superuser=True)
            
            # plus users must be active
            q = q & Q(is_active=True)
            
            # if layer filtering is checked
            if FILTERS.get('layers') in self.filters:
                # retrieve non-external layers
                layers = self.layers.all().only('id')
                # init empty q3
                q3 = Q()
                # loop over layers to form q3 object
                for layer in layers:
                    q3 = q3 | Q(layer=layer)
                # q2: user group if present
                # q3: layers
                # retrieve nodes
                nodes = Node.objects.filter(q2 & q3)
                # loop over nodes of a layer and get their email
                for node in nodes:
                    # add email to the recipient list if not already there
                    if not node.user.email in emails:
                        emails += [node.user.email]
            # else if group filterins is checked but not layers
            elif FILTERS.get('groups') in self.filters and not FILTERS.get('layers')  in self.filters:
                # retrieve only email DB column of all active users
                users = User.objects.filter(q).only('email')
                # loop over users list
                for user in users:
                    # add email to the recipient list if not already there
                    if not user.email in emails:
                        emails += [user.email]
        
        return emails
    
    def send(self):
        """
        Sends the email to the recipients
        """
        # if it has already been sent don't send again
        if self.status is OUTWARD_STATUS.get('sent'):
            return False
        # determine recipients
        recipients = self.get_recipients()
        # init empty list that will contain django's email objects
        emails = []
        
        # prepare text plain if necessary
        if settings.NODESHOT['SETTINGS']['CONTACT_OUTWARD_HTML'] is True:
            # store plain text in var
            html_content = self.message
            # set EmailClass to EmailMultiAlternatives
            EmailClass = EmailMultiAlternatives
        else:
            EmailClass = EmailMessage
        
        # default message is plain text
        message = strip_tags(self.message)
        
        # loop over recipients and fill "emails" list
        for recipient in recipients:
            msg = EmailClass(
                # subject
                self.subject,
                # message
                message,
                # from
                settings.DEFAULT_FROM_EMAIL,
                # to
                [recipient],
            )
            if settings.NODESHOT['SETTINGS']['CONTACT_OUTWARD_HTML'] is True:
                msg.attach_alternative(html_content, "text/html")
            # prepare email object
            emails.append(msg)
        
        # try sending email
        try:
            # counter will count how many emails have been sent
            counter = 0
            for email in emails:
                # if step reached
                if counter == settings.NODESHOT['SETTINGS']['CONTACT_OUTWARD_STEP']:
                    # reset counter
                    counter = 0
                    # sleep
                    time.sleep(settings.NODESHOT['SETTINGS']['CONTACT_OUTWARD_DELAY'])
                # send email
                email.send()
                # increase counter
                counter += 1
        # if error (connection refused, SMTP down)
        except socket.error as e:
            # log the error
            from logging import error
            error('nodeshot.core.mailing.models.outward.send(): %s' % e)
            # set status of the instance as "error"
            self.status = OUTWARD_STATUS.get('error')
        # change status
        self.status = OUTWARD_STATUS.get('sent')
        # save
        self.save()
    
    def save(self, *args, **kwargs):
        """
        Custom save method
        """
        # change status to scheduled if necessary
        if self.is_scheduled and self.status is not OUTWARD_STATUS.get('scheduled'):
            self.status = OUTWARD_STATUS.get('scheduled')
        
        # call super.save()
        super(Outward, self).save(*args, **kwargs)
    
    def clean(self, *args, **kwargs):
        """
        Custom validation
        """
        if self.is_scheduled is 1 and (self.scheduled_date == '' or self.scheduled_date is None\
                                       or self.scheduled_time == '' or self.scheduled_time is None):
            raise ValidationError(_('If message is scheduled both fields "scheduled date" and "scheduled time" must be specified'))
        
        if self.is_scheduled is 1 and self.scheduled_date < now().date():
            raise ValidationError(_('The scheduled date is set to a past date'))
        
        if self.is_filtered is 1 and (len(self.filters) < 1 or self.filters == [''] or\
                                      self.filters == [u''] or self.filters == '' or self.filters is None):
            raise ValidationError(_('If "recipient filtering" is active one of the filtering options should be selected'))
        
        if self.is_filtered is 1 and FILTERS.get('groups') in self.filters and\
           (len(self.groups) < 1 or self.groups == [''] or self.groups == [u''] or self.groups == '' or self.groups is None):
            raise ValidationError(_('If group filtering is active at least one group of users should be selected'))
        
        # TODO: unfortunately layers and users can't be validated easily because they are a many2many field

########NEW FILE########
__FILENAME__ = serializers
from rest_framework import serializers

from .models import Inward


__all__ = [
    'InwardMessageSerializer',
]


class InwardMessageSerializer(serializers.ModelSerializer):
    """ status icons """
    
    class Meta:
        model = Inward
        read_only_fields = (
            'status', 'added', 'updated', 'content_type', 'object_id',
            'user', 'ip', 'user_agent', 'accept_language')
########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.community.mailing unit tests
"""

from django.test import TestCase
from django.utils.translation import ugettext_lazy as _
from django.core import mail
from django.core.urlresolvers import reverse
from django.core.exceptions import ValidationError
from django.db.models import Q
from django.contrib.auth.models import Group
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth import get_user_model
User = get_user_model()

from nodeshot.core.layers.models import Layer
from nodeshot.core.nodes.models import Node
from nodeshot.core.base.tests import user_fixtures

from .models import Inward, Outward
from .models.choices import GROUPS, FILTERS

import datetime
from django.utils.timezone import utc


class MailingTest(TestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json'
    ]
    
    def setUp(self):
        # create outward record
        self.message = Outward.objects.create(
            status=0,
            subject='test message',
            message='This is a test message, be sure this text is longer than the minimum required',
            is_scheduled=False,
            is_filtered=False
        )
        self.msg = Outward(
            status = 0,
            subject = 'This is a test',
            message = self.message.subject,
        )
        mail.outbox = []
    
    def test_inward_model(self):
        """ ensure inward model validation works as expected """
        message = Inward(message='this is a test to ensure inward model validation works as expected')
        
        content_type = ContentType.objects.only('id', 'model').get(model='node')
        message.content_type = content_type
        message.object_id = 1
        
        try:
            message.full_clean()
            self.fail('ValidationError not raised')
        except ValidationError as e:
            self.assertIn(_('If sender is not specified from_name and from_email must be filled in'), e.messages)
        
        user = User.objects.get(pk=1)
        
        message.user = user
        message.full_clean()
        
        self.assertEqual(message.from_name, user.get_full_name())
        self.assertEqual(message.from_email, user.email)
        
        message.user = None
        message.full_clean()
        
        message.user = user
        message.save()
        
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(message.status, 1)
    
    def test_contact_node_api(self):
        """ ensure contact node api works as expected """
        url = reverse('api_node_contact', args=['fusolab'])
        self.client.login(username='admin', password='tester')
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 405)
        
        response = self.client.post(url, { 'message': 'ensure contact node api works as expected' })
        self.assertEqual(response.status_code, 201)
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(Inward.objects.count(), 1)
    
    def test_contact_user_api(self):
        """ ensure contact user api works as expected """
        url = reverse('api_user_contact', args=['romano'])
        self.client.login(username='admin', password='tester')
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 405)
        
        response = self.client.post(url, { 'message': 'ensure contact user api works as expected' })
        self.assertEqual(response.status_code, 201)
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(Inward.objects.count(), 1)
    
    def test_contact_layer_api(self):
        """ ensure contact layer api works as expected """
        url = reverse('api_layer_contact', args=['rome'])
        self.client.login(username='admin', password='tester')
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 405)
        
        response = self.client.post(url, { 'message': 'ensure contact user api works as expected' })
        self.assertEqual(response.status_code, 201)
        self.assertEqual(len(mail.outbox), 1)
        self.assertEqual(Inward.objects.count(), 1)
        
        vienna = Layer.objects.get(slug='vienna')
        vienna.email = ''
        vienna.save()
        
        # cannot be contacted because no email nor mantainers specified
        url = reverse('api_layer_contact', args=['vienna'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 400)
        
        response = self.client.post(url, { 'message': 'ensure contact user api works as expected' })
        self.assertEqual(response.status_code, 400)
    
    def test_no_filter(self):
        """ *** Test no filtering, send to all *** """
        # count users
        users = User.objects.filter(is_active=True)
        recipients = self.message.get_recipients()
        
        # simplest case: send to all
        # fail if recipient list length and user list length differ
        self.assertEqual(len(recipients), len(users))
        # fail if user emails are not in recipients
        for user in users:
            self.assertTrue(user.email in recipients)
        
    def test_group_filtering(self):
        """ *** Test group filtering in multiple combinations *** """
        combinations = [
            '1','2','3','0',
            '1,2','1,3','1,0','2,3','2,0','3,0',
            '1,2,3','1,2,0','1,3,0','2,3,0',
            '1,2,3,0'
        ]
        # prepare record
        message = self.message
        message.is_filtered=True
        message.filters = '1'
        
        for combo in combinations:
            # test multiple groups
            groups = combo.split(',')
            # init empty Q
            q = Q()
            for group in groups:
                # if not superuser case
                if group != '0':
                    # add another group to the Q
                    q = q | Q(groups=group)
                # superuser case
                else:
                    # group 0 wouldn't be correct, therefore we use is_superuser=True 
                    q = q | Q(is_superuser=True)
            # and is_active = True
            q = q & Q(is_active=True)
            # retrieve users
            users = User.objects.filter(q)
            message.groups = combo
            recipients = message.get_recipients()
            # fail if recipient list length and user list length differ
            self.assertEqual(len(recipients), len(users))
            # fail if user emails are not in recipients
            for user in users:
                self.assertTrue(user.email in recipients)
    
    def test_layer_filtering(self):
        """ *** Test layer filtering in multiple combinations *** """
        combinations = [
            '1','2','3',
            '1,2','1,3','2,3',
            '1,2,3'
        ]
        # prepare record
        message = self.message
        message.is_filtered=True
        message.filters = '2'
        
        for combo in combinations:
            layers = combo.split(',')
            # init empty Q
            q = Q()
            for layer in layers:
                q = q | Q(layer=layer)
            # retrieve nodes
            nodes = Node.objects.filter(q)
            # layers id list
            message.layers = [int(layer) for layer in layers]
            # retrieve recipients according to model code
            recipients = message.get_recipients()
            # retrieve list of emails
            emails = []
            for node in nodes:
                if not node.user.email in emails:
                    emails += [node.user.email]
            # fail if recipient list length and user list length differ
            self.assertEqual(len(recipients), len(emails))
            # fail if user emails are not in recipients
            for email in emails:
                self.assertTrue(email in recipients)
        
    def test_user_filtering(self):
        """ *** Test recipient filtering by user *** """
        combinations = [
            '1','2','3','4','5','6','7','8',
            '1,2','2,3','3,4','5,6'
            '1,2,3','3,4,5','6,7,8'
            '1,2,3,4','5,6,7,8',
            '1,2,3,4,5,6,7,8'
        ]
        # prepare record
        message = self.message
        message.is_filtered=True
        message.filters = '3'
        
        for combo in combinations:
            # users id list
            users_string = combo.split(',')
            user_ids = [int(user) for user in users_string]
            # selected users
            message.users = user_ids
            # retrieve recipients according to the model code
            recipients = message.get_recipients()
            # init empty Q
            q = Q()
            # retrieve users
            for user in user_ids:
                q = q | Q(id=user)
            # only active users
            q = q & Q(is_active=True)
            users = User.objects.filter(q)
            # fail if recipient list length and user list length differ
            self.assertEqual(len(recipients), len(users))
            # fail if user emails are not in recipients
            for user in users:
                self.assertTrue(user.email in recipients)
    
    def test_group_and_layer_filtering(self):
        """ *** Test group & layer filtering in multiple combinations *** """
        combinations = [
            { 'groups': '1', 'layers': '1' },
            { 'groups': '2', 'layers': '2' },
            { 'groups': '1,2', 'layers': '1' },
            { 'groups': '1,2,3', 'layers': '1,2' },
            { 'groups': '1,2', 'layers': '1,2,3' },
            { 'groups': '3', 'layers': '1,2,3' }
        ]
        # prepare record
        message = self.message
        message.is_filtered=True
        message.filters = '1,2'
        
        for combo in combinations:
            groups = combo['groups'].split(',')
            layers = combo['layers'].split(',')
            
            # GROUPS
            q1 = Q()
            for group in groups:
                # if not superuser case
                if group != '0':
                    # add another group to the Q
                    q1 = q1 | Q(user__groups=group)
                # superuser case
                else:
                    # group 0 wouldn't be correct, therefore we use is_superuser=True 
                    q1 = q1 | Q(user__is_superuser=True)
            # and is_active = True
            q1 = q1 & Q(user__is_active=True)
            
            # LAYERS
            q2 = Q()
            for layer in layers:
                q2 = q2 | Q(layer=layer)
            # retrieve nodes
            nodes = Node.objects.filter(q1 & q2).select_related()
            
            # message group & layers
            message.groups = combo['groups']
            message.layers = [int(layer) for layer in layers]
            
            # retrieve recipients according to model code
            recipients = message.get_recipients()
            # retrieve list of emails
            emails = []
            for node in nodes:
                if not node.user.email in emails:
                    emails += [node.user.email]
            # fail if recipient list length and user list length differ
            self.assertEqual(len(recipients), len(emails))
            # fail if user emails are not in recipients
            for email in emails:
                self.assertTrue(email in recipients)
    
    def test_user_and_layer_filtering(self):
        """ *** Test recipient filtering by user & layers *** """
        combinations = [
            { 'users': '1', 'layers': '1' },
            { 'users': '2', 'layers': '2' },
            { 'users': '1,2', 'layers': '1' },
            { 'users': '1,2,3', 'layers': '1,2' },
            { 'users': '1,2', 'layers': '1,2,3' },
            { 'users': '3', 'layers': '1,2,3' },
            { 'users': '3,4,5,6,7', 'layers': '1' }
        ]
        # prepare record
        message = self.message
        message.is_filtered=True
        message.filters = '2,3'
        
        for combo in combinations:
            users = combo['users'].split(',')
            layers = combo['layers'].split(',')
            
            # ZONES
            q1 = Q()
            for layer in layers:
                q1 = q1 | Q(layer=layer)
            # retrieve nodes
            nodes = Node.objects.filter(q1).select_related()
            
            # prepare Q object for user query
            q2 = Q()
            for user in users:
                q2 = q2 | Q(pk=user)
            q2 = q2 & Q(is_active=True)
            
            # message users & layers
            message.users = [int(user) for user in users]
            message.layers = [int(layer) for layer in layers]
            
            # retrieve chosen users
            users = User.objects.filter(q2)
            
            # retrieve recipients according to model code
            recipients = message.get_recipients()
            
            # retrieve list of emails
            emails = []
            for node in nodes:
                if not node.user.email in emails:
                    emails.append(node.user.email)
            
            # add emails of selected users if necessary
            for user in users:
                if not user.email in emails:
                    emails.append(user.email)
            
            # fail if recipient list length and user list length differ
            self.assertEqual(len(recipients), len(emails))
            # fail if user emails are not in recipients
            for email in emails:
                self.assertTrue(email in recipients)
    
    # TODO:
    # test html/plain-text format
    
    def test_outward_validation_scheduled1(self):
        """ *** A scheduled message without any value for scheduled date and time should not pass validation *** """
        self.msg.is_scheduled = 1
        self.msg.scheduled_date = None
        self.msg.scheduled_time = None        
        self.assertRaises(ValidationError, self.msg.full_clean)
    
    def test_outward_validation_scheduled2(self):
        """ *** A scheduled message without any value for scheduled time should not pass validation *** """
        self.msg.is_scheduled = 1
        self.msg.scheduled_time = None
        self.msg.scheduled_date = datetime.datetime.utcnow().replace(tzinfo=utc).date() + datetime.timedelta(days=1)
        self.assertRaises(ValidationError, self.msg.full_clean)
    
    def test_outward_validation_scheduled3(self):
        """ *** A scheduled message without any value for scheduled date should not pass validation *** """
        self.msg.is_scheduled = 1
        self.msg.scheduled_date = None
        self.msg.scheduled_time = '00'
        self.assertRaises(ValidationError, self.msg.full_clean)
    
    def test_outward_validation_scheduled4(self):
        """ *** A scheduled message with both date and time should pass validation *** """
        self.msg.is_scheduled = 1
        self.msg.scheduled_date = datetime.datetime.utcnow().replace(tzinfo=utc).date() + datetime.timedelta(days=1)
        self.msg.scheduled_time = '00'
        self.msg.full_clean()
    
    def test_outward_validate_scheduled5(self):
        """ *** A new message with a past scheduled date should not pass validation *** """
        self.msg.is_scheduled = 1
        self.msg.scheduled_date = datetime.datetime.utcnow().replace(tzinfo=utc).date() - datetime.timedelta(days=1)
        self.msg.scheduled_time = '00'
        self.assertRaises(ValidationError, self.msg.full_clean)
        
    def test_outward_validate_filters1(self):
        """ *** A new message with is_filtered == True and no selected filter should not pass validation *** """
        self.msg.is_scheduled = 0
        self.msg.scheduled_date = None
        self.msg.scheduled_time = None
        self.msg.is_filtered = 1
        self.assertRaises(ValidationError, self.msg.full_clean)
    
    def test_outward_validate_filters2(self):
        """ *** A new message with group filtering active but not selected group should not pass validation *** """
        self.msg.is_scheduled = 0
        self.msg.is_filtered = 1
        self.msg.filters = '%s' % FILTERS.get('groups')
        self.msg.groups = ''
        self.assertRaises(ValidationError, self.msg.full_clean)
    
    # the following two validation routine require more cumbersome procedures ... can't be bothered right now!
    
    #def test_outward_validate_filters3(self):
    #    """ *** A new message with user filtering active but not selected group should not pass validation *** """
    #    self.msg.is_scheduled = 0
    #    self.msg.is_filtered = 1
    #    self.msg.filters = '%s' % FILTERS.get('users')
    #    self.msg.users = []
    #    self.assertRaises(ValidationError, self.msg.full_clean)
    #
    #def test_outward_validate_filters4(self):
    #    """ *** A new message with layer filtering active but not selected group should not pass validation *** """
    #    self.msg.is_scheduled = 0
    #    self.msg.is_filtered = 1
    #    self.msg.filters = '%s' % FILTERS.get('layers')
    #    self.msg.layers = []
    #    self.assertRaises(ValidationError, self.msg.full_clean)
    
    #def test_outward_plaintext(self):
    #    """ *** TODO: write a test that verifies email is correctly sent as plain text *** """
    #    self.assertEqual(False, True)
    #
    #def test_outward_html(self):
    #    """ *** TODO: write a test that verifies email is correctly sent both as plain text and HTML *** """
    #    self.assertEqual(False, True)
    #
    #def test_inward_validate_require_auth(self):
    #    """ *** TODO: write a test that verifies require auth for inward messages works correctly *** """
    #    self.assertEqual(False, True)
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.conf import settings


urlpatterns = patterns('nodeshot.community.mailing.views',
    # contact node
    url(r'^nodes/(?P<slug>[-\w]+)/contact/$', 'contact_node', name='api_node_contact'),
)


# contact layer
if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
    urlpatterns += patterns('nodeshot.community.mailing.views',
        url(r'^layers/(?P<slug>[-\w]+)/contact/$', 'contact_layer', name='api_layer_contact'),
    )


# contact user
if 'nodeshot.community.profiles' in settings.INSTALLED_APPS:
    urlpatterns += patterns('nodeshot.community.mailing.views',
        url(r'^profiles/(?P<username>[-.\w]+)/contact/$', 'contact_user', name='api_user_contact'),
    )




########NEW FILE########
__FILENAME__ = views
from django.http import Http404
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from django.contrib.contenttypes.models import ContentType
from django.conf import settings
from django.contrib.auth import get_user_model
User = get_user_model()

from rest_framework import generics, authentication, permissions
from rest_framework.response import Response

from nodeshot.core.nodes.models import Node

from .serializers import *
from .models import Inward


CONTACT_PERMISSIONS = (permissions.IsAuthenticated,) if settings.NODESHOT['SETTINGS']['CONTACT_INWARD_REQUIRE_AUTH'] else []


class ContactNode(generics.CreateAPIView):
    """
    Contact owner of specified node.
    
    Might require authentication depending on configuration.
    
    Name and email fields will be determined automatically if the user is authenticated.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = CONTACT_PERMISSIONS
    serializer_class = InwardMessageSerializer
    content_type = 'node'
    model = Node
    slug_field = 'slug'
    
    def is_contactable(self):
        return True
    
    def get_object(self, *args, **kwargs):
        try:
            self.recipient = self.model.objects.get(**{ self.slug_field: kwargs.get(self.slug_field, False) })
        except Node.DoesNotExist:
            raise Http404('Not Found')
        
        self.object = Inward()
    
    def get(self, request, *args, **kwargs):
        try:
            self.get_object(**kwargs)
        except Http404:
            return Response({ 'detail': _('Not Found') }, status=404)
        
        if not self.is_contactable():
            return Response({ 'detail': _('This resource cannot be contacted') }, status=400)
        
        return Response({ 'detail': _('Method Not Allowed') }, status=405)

    def post(self, request, *args, **kwargs):
        """
        Contact node owner.
        """
        try:
            self.get_object(**kwargs)
        except Http404:
            return Response({ 'detail': _('Not Found') }, status=404)
        
        if not self.is_contactable():
            return Response({ 'detail': _('This resource cannot be contacted') }, status=400)
        
        content_type = ContentType.objects.only('id', 'model').get(model=self.content_type)
        
        # shortcut
        data = request.DATA
        
        # init inward message
        message = Inward()
        # required fields
        message.content_type = content_type
        message.object_id = self.recipient.id
        message.message = data.get('message')
        
        # user info if authenticated
        if request.user.is_authenticated():
            message.user = request.user
        else:
            message.from_name = data.get('from_name')
            message.from_email = data.get('from_email')
        
        # additional user info
        message.ip = request.META.get('REMOTE_ADDR', '')
        message.user_agent = request.META.get('HTTP_USER_AGENT', '')
        message.accept_language = request.META.get('HTTP_ACCEPT_LANGUAGE', '')
        
        try:
            message.full_clean()
        except ValidationError, e:
            return Response(e.message_dict)
        
        message.save()
        
        if message.status >= 1:
            return Response({ 'details': _('Message sent successfully') }, status=201)
        else:
            return Response({ 'details': _('Something went wrong. The email was not sent.') }, status=500)

contact_node = ContactNode.as_view()


class ContactUser(ContactNode):
    """
    Contact specified user.
    
    Might require authentication depending on configuration.
    
    Name and email fields will be determined automatically if the user is authenticated.
    """
    content_type = User.__name__.lower()
    model = User
    slug_field = 'username'

contact_user = ContactUser.as_view()


if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
    
    from nodeshot.core.layers.models import Layer
    
    class ContactLayer(ContactNode):
        """
        Contact mantainers of specified Layer.
        
        Might require authentication depending on configuration.
        
        Name and email fields will be determined automatically if the user is authenticated.
        """
        content_type = 'layer'
        model = Layer
        slug_field = 'slug'
    
        def is_contactable(self):
            return bool(self.recipient.email or self.recipient.mantainers.count() > 1)
    
    contact_layer = ContactLayer.as_view()

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.conf import settings
from nodeshot.core.base.admin import BaseAdmin

from .models import *


class NotificationAdmin(BaseAdmin):
    list_display = ('to_user', 'type', 'text', 'is_read', 'added', 'updated')
    list_filter = ('type', 'is_read', 'added')
    
    raw_id_fields = ('from_user', 'to_user')
    autocomplete_lookup_fields = {
        'fk': ['from_user', 'to_user'],
    }


admin.site.register(Notification, NotificationAdmin)


if 'nodeshot.community.profiles' in settings.INSTALLED_APPS:
    
    class UserWebNotificationSettingsInline(admin.StackedInline):
        model = UserWebNotificationSettings
        extra = 1
    
    class UserEmailNotificationSettingsInline(admin.StackedInline):
        model = UserEmailNotificationSettings
        extra = 1
    
    from nodeshot.community.profiles.admin import UserAdmin
    
    additional_inlines = [UserWebNotificationSettingsInline, UserEmailNotificationSettingsInline]
    
    UserAdmin.inlines = UserAdmin.inlines + additional_inlines
########NEW FILE########
__FILENAME__ = purge_notifications
from django.core.management.base import BaseCommand
from django.conf import settings

from nodeshot.community.notifications.models import Notification
from nodeshot.core.base.utils import ago


class Command(BaseCommand):
    help = "Delete notifications older than settings.NODESHOT['NOTIFICATIONS']['DELETE_OLD']"

    def retrieve_old_notifications(self):
        """
        Retrieve notifications older than X days, where X is specified in settings
        """
        
        date = ago(days=settings.NODESHOT['NOTIFICATIONS'].get('DELETE_OLD', 40))
        
        return Notification.objects.filter(added__lte=date)
    
    def output(self, message):
        self.stdout.write('%s\n\r' % message) 

    def handle(self, *args, **options):
        """ Purge notifications """
        # retrieve layers
        notifications = self.retrieve_old_notifications()
        count = len(notifications)
        
        if count > 0:
            self.output('found %d notifications to purge...' % count)
            notifications.delete()
            self.output('%d notifications deleted successfully.' % count)
        else:
            self.output('there are no old notifications to purge')

########NEW FILE########
__FILENAME__ = notification
from django.db import models
from django.utils.translation import ugettext_lazy as _, ugettext as __
from django.core.exceptions import ValidationError, ObjectDoesNotExist
from django.core.mail import send_mail
from django.core.urlresolvers import reverse, NoReverseMatch
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes import generic
from django.contrib.sites.models import Site
from django.conf import settings

from nodeshot.core.base.models import BaseDate

NOTIFICATION_TYPE_CHOICES = [(key, _(key)) for key,value in settings.NODESHOT['NOTIFICATIONS']['TEXTS'].iteritems()]


class Notification(BaseDate):
    """
    Notification Model
    """
    type = models.CharField(_('type'), max_length=64, choices=NOTIFICATION_TYPE_CHOICES)
    from_user = models.ForeignKey(settings.AUTH_USER_MODEL,
                                  verbose_name=_('from user'),
                                  related_name='notifications_sent',
                                  blank=True, null=True)
    to_user = models.ForeignKey(settings.AUTH_USER_MODEL,
                                verbose_name=_('to user'),
                                related_name='notifications_received')
    
    # generic foreign key "related_object" indicates whether the 
    # notification refers to any particular object
    content_type = models.ForeignKey(ContentType, blank=True, null=True)
    object_id = models.PositiveIntegerField(blank=True, null=True)
    related_object = generic.GenericForeignKey('content_type', 'object_id')
    
    text = models.CharField(_('text'), max_length=120, blank=True)    
    is_read = models. BooleanField(_('read?'), default=False)
    
    class Meta:
        app_label = 'notifications'
        ordering = ('-id',)
    
    def __unicode__(self):
        return 'notification #%s' % self.id
    
    def clean(self, *args, **kwargs):
        """ from_user and to_user must differ """
        if self.from_user and self.from_user_id == self.to_user_id:
            raise ValidationError(_('A user cannot send a notification to herself/himself'))
    
    def save(self, *args, **kwargs):
        """
        custom save method to send email and push notification
        """
        created = self.pk is None
        
        # save notification to database only if user settings allow it
        if self.check_user_settings(medium='web'):
            super(Notification, self).save(*args, **kwargs)
        
        if created:
            # send notifications through other mediums according to user settings
            self.send_notifications()
    
    def send_notifications(self):
        """ send notifications to recipient user according to her settings """
        self.send_email()
    
    def send_email(self):
        """ send email notification according to user settings """
        # send only if user notification setting is set to true
        if self.check_user_settings():
            send_mail(_(self.type), self.email_message, settings.DEFAULT_FROM_EMAIL, [self.to_user.email])
            return True
        else:
            # return false otherwise
            return False
    
    def send_mobile(self):
        """ send push notification according to user settings """
        raise NotImplementedError('mobile notifications not implemented yet')
    
    def check_user_settings(self, medium='email'):
        """
        Ensure user is ok with receiving this notification through the specified medium.
        Available mediums are 'web' and 'email', while 'mobile' notifications will
        hopefully be implemented in the future.
        """
        # custom notifications are always sent
        if self.type == 'custom':
            return True
        
        try:
            user_settings = getattr(self.to_user, '%s_notification_settings' % medium)
        except ObjectDoesNotExist:
            # user has no settings specified
            # TODO: it would be better to create the settings with default values
            return False
        
        user_setting_type = getattr(user_settings.__class__, self.type).user_setting_type
        
        if user_setting_type == 'boolean':
            return getattr(user_settings, self.type, True)
        elif user_setting_type == 'distance':
            value = getattr(user_settings, self.type, 0)
            # enabled for all related objects
            if value is 0:
                return True
            # disabled for all related objects
            elif value < 0:
                return False
            # enabled for related objects comprised in specified distance range in km
            else:
                Model = self.related_object.__class__
                geo_field = getattr(user_settings.__class__, self.type).geo_field
                geo_value = getattr(self.related_object, geo_field)
                km = value * 1000
                queryset = Model.objects.filter(**{
                    "user_id": self.to_user_id,
                    geo_field+"__distance_lte": (geo_value, km)
                })
                # if user has related object in a distance range less than or equal to
                # his prefered range (specified in number of km), return True and send the notification
                return queryset.count() >= 1
    
    @property
    def email_message(self):
        """ compose complete email message text """
        site = Site.objects.get(pk=settings.SITE_ID)
        url = "%s://%s/" % (getattr(settings, 'PROTOCOL', 'http'), site.domain)
        hello_text = __("Hi %s," % self.to_user.get_full_name())
        action_text = __("\n\nMore details here: %s") % url
        explain_text = __(
            "This is an automatic notification sent from from %s.\n"
            "If you want to stop receiving this notification edit your"
            "email notification settings here: %s") % (site.name, 'TODO')
        
        return "%s\n\n%s%s\n\n%s" % (hello_text, self.text, action_text, explain_text)

########NEW FILE########
__FILENAME__ = user_settings
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.conf import settings


def add_notifications(myclass):
    """
    Decorator which adds fields dynamically to User Notification Settings models.
    
    Each of the keys in the settings.NODESHOT['NOTIFICATIONS']['TEXTS'] dictionary
    are added as a field and DB column.
    """
    for key, value in settings.NODESHOT['NOTIFICATIONS']['TEXTS'].items():
        # custom notifications cannot be disabled
        if 'custom' in [key, value]:
            continue
        
        field_type = settings.NODESHOT['NOTIFICATIONS']['USER_SETTING'][key]['type']
        
        if field_type == 'boolean':
            field = models.BooleanField(_(key), default=settings.NODESHOT['DEFAULTS']['NOTIFICATION_BOOLEAN_FIELDS'])
        elif field_type == 'distance':
            field = models.IntegerField(
                _(key),
                default=settings.NODESHOT['DEFAULTS']['NOTIFICATION_DISTANCE_FIELDS'],
                help_text=_('-1 (less than 0): disabled; 0: enabled for all;\
                            1 (less than 0): enabled for those in the specified distance range (km)')
            )
            field.geo_field = settings.NODESHOT['NOTIFICATIONS']['USER_SETTING'][key]['geo_field']
        
        field.name = field.column = field.attname = key
        field.user_setting_type = field_type
        setattr(myclass, key, field)
        myclass.add_to_class(key, field)
    
    return myclass


@add_notifications
class UserWebNotificationSettings(models.Model):
    """
    User Web Notification Settings Model
    Takes care of tracking the user's web notification preferences
    (web notifications are the notifications displayed through the web interface)
    """
    user = models.OneToOneField(settings.AUTH_USER_MODEL,
                                verbose_name=_('user'),
                                related_name='web_notification_settings')
    
    class Meta:
        app_label = 'notifications'
        db_table = 'notifications_user_web_settings'
        verbose_name = _('user web notification settings')
        verbose_name_plural = _('user web notification settings')
    
    def __unicode__(self):
        return _('web notification settings for %s') % self.user


@add_notifications
class UserEmailNotificationSettings(models.Model):
    """
    User Email Notification Settings Model
    Takes care of tracking the user's email notification preferences
    """
    user = models.OneToOneField(settings.AUTH_USER_MODEL,
                                verbose_name=_('user'),
                                related_name='email_notification_settings')
    
    class Meta:
        app_label = 'notifications'
        db_table = 'notifications_user_email_settings'
        verbose_name = _('user email notification settings')
        verbose_name_plural = _('user email notification settings')
    
    def __unicode__(self):
        return _('email notification settings for %s') % self.user

########NEW FILE########
__FILENAME__ = nodes
from django.db.models.signals import post_save, pre_delete
from django.dispatch import receiver
from django.conf import settings
from django.contrib.auth import get_user_model
User = get_user_model()

from nodeshot.core.nodes.signals import node_status_changed
from nodeshot.core.nodes.models import Node

from ..models import Notification
from ..tasks import create_notifications


base_queryset = User.objects.filter(is_active=True)


def exclude_owner_of_node(node):
    if node.user_id is not None:
        return base_queryset.exclude(pk=node.user_id)
    else:
        return base_queryset 


# ------ NODE CREATED ------ #

@receiver(post_save, sender=Node)
def node_created_handler(sender, **kwargs):
    """ send notification when a new node is created according to users's settings """
    if kwargs['created']:
        obj = kwargs['instance']
        queryset = exclude_owner_of_node(obj)
        create_notifications.delay(**{
            "users": queryset,
            "notification_model": Notification,
            "notification_type": "node_created",
            "related_object": obj
        })


# ------ NODE STATUS CHANGED ------ #

@receiver(node_status_changed)
def node_status_changed_handler(**kwargs):
    """ send notification when the status of a node changes according to users's settings """
    obj = kwargs['instance']
    obj.old_status = kwargs['old_status'].name
    obj.new_status = kwargs['new_status'].name
    queryset = exclude_owner_of_node(obj)
    create_notifications.delay(**{
        "users": queryset,
        "notification_model": Notification,
        "notification_type": "node_status_changed",
        "related_object": obj
    })
    
    # if node has owner send a different notification to him
    if obj.user is not None:
        create_notifications.delay(**{
            "users": [obj.user],
            "notification_model": Notification,
            "notification_type": "node_own_status_changed",
            "related_object": obj
        })


# ------ NODE DELETED ------ #

@receiver(pre_delete, sender=Node)
def node_deleted_handler(sender, **kwargs):
    """ send notification when a node is deleted according to users's settings """
    obj = kwargs['instance']
    queryset = exclude_owner_of_node(obj)
    create_notifications.delay(**{
        "users": queryset,
        "notification_model": Notification,
        "notification_type": "node_deleted",
        "related_object": obj
    })


# ------ DISCONNECT UTILITY ------ #

def disconnect():
    """ disconnect signals """
    post_save.disconnect(node_created_handler, sender=Node)
    node_status_changed.disconnect(node_status_changed_handler)
    pre_delete.disconnect(node_deleted_handler, sender=Node)


def reconnect():
    """ reconnect signals """
    post_save.connect(node_created_handler, sender=Node)
    node_status_changed.connect(node_status_changed_handler)
    pre_delete.connect(node_deleted_handler, sender=Node)


settings.NODESHOT['DISCONNECTABLE_SIGNALS'].append(
    {
        'disconnect': disconnect,
        'reconnect': reconnect
    }
)
########NEW FILE########
__FILENAME__ = serializers
from rest_framework import serializers
from rest_framework.pagination import PaginationSerializer

from nodeshot.core.base.serializers import HyperlinkedField

from .models import *


__all__ = [
    'UnreadNotificationSerializer',
    'NotificationSerializer',
    'PaginatedNotificationSerializer',
    'EmailNotificationSettingsSerializer',
    'WebNotificationSettingsSerializer'
]


class UnreadNotificationSerializer(serializers.ModelSerializer):
    """
    Unread notification serializer
    """
    from_user_id = serializers.Field(source='from_user_id')
    from_user_detail = serializers.HyperlinkedRelatedField(
        source='from_user',
        view_name='api_profile_detail',
        read_only=True
    )
    related_object = serializers.SerializerMethodField('get_related_object')
    
    def get_related_object(self, obj):
        related = obj.related_object
        if related is not None:
            if hasattr(related, 'slug'):
                return related.slug
            else:
                return related.id
        return None
    
    class Meta:
        model = Notification
        fields = (
            'id', 'type', 'is_read', 'from_user_id',
            'from_user_detail', 'related_object',
            'text', 'added'
        )


class NotificationSerializer(UnreadNotificationSerializer):
    """
    Notification serializer
    """
    class Meta:
        model = Notification
        fields = (
            'id', 'type', 'is_read', 'from_user_id',
            'from_user_detail', 'related_object',
            'text', 'added'
        )


class PaginatedNotificationSerializer(PaginationSerializer):
    """
    Serializes page objects of notification querysets.
    """
    class Meta:
        object_serializer_class = NotificationSerializer


class EmailNotificationSettingsSerializer(serializers.ModelSerializer):
    """
    Email Notification Settings serializer
    """
    uri = HyperlinkedField(view_name='api_notification_email_settings')
    
    class Meta:
        model = UserEmailNotificationSettings
        exclude = ('id', 'user',)


class WebNotificationSettingsSerializer(serializers.ModelSerializer):
    """
    Web Notification Settings serializer
    """
    uri = HyperlinkedField(view_name='api_notification_email_settings')
    
    class Meta:
        model = UserWebNotificationSettings
        exclude = ('id', 'user',)

########NEW FILE########
__FILENAME__ = tasks
from celery import task

from django.core import management
from django.conf import settings


@task()
def purge_notifications():
    """
    deletes old notifications
    """
    management.call_command('purge_notifications')


# ------ Asynchronous tasks ------ #


@task
def create_notifications(users, notification_model, notification_type, related_object):
    """
    create notifications in a background job to avoid slowing down users
    """
    # shortcuts for readability
    Notification = notification_model
    
    # text
    additional = related_object.__dict__ if related_object else ''
    notification_text = settings.NODESHOT['NOTIFICATIONS']['TEXTS'][notification_type] % additional
    
    # loop users, notification settings check is done in Notification model
    for user in users:
        
        n = Notification(
            to_user=user,
            type=notification_type,
            text=notification_text
        )
        # attach related object if present
        if related_object:
            n.related_object = related_object
        # create notification and send according to user settings
        n.save()
########NEW FILE########
__FILENAME__ = tests
import simplejson as json

from django.test.client import Client
from django.core.urlresolvers import reverse
from django.core.exceptions import ValidationError
from django.core import mail, management
from django.conf import settings
from django.contrib.auth import get_user_model
User = get_user_model()

from nodeshot.core.base.tests import user_fixtures, BaseTestCase
from nodeshot.core.base.utils import ago
from nodeshot.core.nodes.models import Node

from .models import *
from .tasks import purge_notifications

# remove websockets from installed apps and disconnect signals
if 'nodeshot.core.websockets' in settings.INSTALLED_APPS:
    
    from importlib import import_module
    
    for registrar in settings.NODESHOT['WEBSOCKETS']['REGISTRARS']:
        module = import_module(registrar)
        module.disconnect()
    
    settings.NODESHOT['WEBSOCKETS']['REGISTRARS'] = []
    
    settings.INSTALLED_APPS = [app for app in settings.INSTALLED_APPS if app != 'nodeshot.core.websockets']


class TestNotification(BaseTestCase):
    """
    Test Notifications
    """
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
    ]
    
    def test_notification_to_herself(self):
        """ An user cannot send a notification to herself/himself """
        n = Notification(
            to_user_id=1,
            from_user_id=1,
            type='custom',
            text='test'
        )
        self.assertRaises(ValidationError, n.full_clean)
    
    def test_email_is_sent(self):
        """ Test custom notification is sent via email """
        n = Notification(
            to_user_id=1,
            from_user_id=2,
            type='custom',
            text='testing test'
        )
        n.save()
        
        self.assertEqual(Notification.objects.count(), 1)
        self.assertEqual(len(mail.outbox), 1)
        
        email_text = n.email_message
        self.assertIn('Hi', email_text)
        self.assertIn('testing test', email_text)
        self.assertIn('More details here', email_text)
        self.assertIn('This is an automatic notification sent from from', email_text)
    
    def test_purge_notifications(self):
        default_setting = settings.NODESHOT['NOTIFICATIONS']['DELETE_OLD']
        settings.NODESHOT['NOTIFICATIONS']['DELETE_OLD'] = 7
        
        n = Notification.objects.create(**{
            "to_user_id": 1,
            "type": "custom",
            "text": "testing"
        })
        # not enough old to be purged
        n.added = ago(days=3)
        n.save(auto_update=False)
        management.call_command('purge_notifications')
        # no notifications have been deleted
        self.assertEqual(Notification.objects.count(), 1)
        
        # enough old to be purged
        n.added = ago(days=14)
        n.save(auto_update=False)
        management.call_command('purge_notifications')
        self.assertEqual(Notification.objects.count(), 0)
        
        n = Notification.objects.create(**{
            "to_user_id": 1,
            "type": "custom",
            "text": "testing"
        })
        n.added = ago(days=14)
        n.save(auto_update=False)
        purge_notifications.delay()
    
    if 'nodeshot.community.notifications.registrars.nodes' in settings.NODESHOT['NOTIFICATIONS']['REGISTRARS']:
        def test_check_settings(self):
            n = Notification(**{
                "to_user_id": 4,
                "type": "node_own_status_changed",
            })
            self.assertEqual(n.check_user_settings(medium='web'), settings.NODESHOT['DEFAULTS']['NOTIFICATION_BOOLEAN_FIELDS'])
            self.assertTrue(n.check_user_settings(medium='email'), settings.NODESHOT['DEFAULTS']['NOTIFICATION_BOOLEAN_FIELDS'])
        
        def test_node_created_to_all(self):
            # set every user to receive notifications about any node created
            all_users = User.objects.all()
            
            for user in all_users:
                user.email_notification_settings.node_created = 0
                user.email_notification_settings.save()
                user.web_notification_settings.node_created = 0
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            
            # ensure all users except node owner have been notified about the node creation
            self.assertEqual(Notification.objects.count(), all_users.count()-1)
            self.assertEqual(len(mail.outbox), all_users.count()-1)
            
            # ensure owner notification object for owner has not been created in DB
            self.assertEqual(Notification.objects.filter(to_user_id=1).count(), 0)
        
        def test_node_created_to_all_web_noone_mail(self):
            all_users = User.objects.all()
            
            for user in all_users:
                # no one wants to receive emails
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.save()
                # everyone wants to receive web notifications about all nodes
                user.web_notification_settings.node_created = 0
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            
            # ensure all users except node owner have been notified about the node creation
            self.assertEqual(Notification.objects.count(), all_users.count()-1)
            self.assertEqual(len(mail.outbox), 0)
            
            # ensure owner notification object for owner has not been created in DB
            self.assertEqual(Notification.objects.filter(to_user_id=1).count(), 0)
        
        def test_node_created_to_all_email_noone_web(self):
            all_users = User.objects.all()
            
            for user in all_users:
                # no one wants to receive emails
                user.email_notification_settings.node_created = 0
                user.email_notification_settings.save()
                # everyone wants to receive web notifications about all nodes
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            
            # ensure all users except node owner have been notified about the node creation
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), all_users.count()-1)
        
        def test_node_created_to_noone(self):
            # set every user to NOT receive notifications about new nodes
            all_users = User.objects.all()
            
            for user in all_users:
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.save()
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            
            # ensure no notifications are created in the DB nor sent
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            # web notifications enabled
            for user in all_users:
                user.web_notification_settings.node_created = 0
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification 2',
                'slug': 'test-notification 2',
                'layer_id': 1,
                'geometry': 'POINT (-2.16 47.12)',
                'user_id': 1
            })
            
            # ensure notifications are created
            self.assertEqual(Notification.objects.count(), all_users.count()-1)
            # but emails not sent
            self.assertEqual(len(mail.outbox), 0)
        
        def test_node_created_distance(self):
            # set every user to NOT receive notifications about new nodes
            # disable email notifications for all users
            for user in User.objects.all():
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.node_deleted = -1
                user.email_notification_settings.save()
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.node_deleted = -1
                user.web_notification_settings.save()
            
            # creat node of user who will receive the notification
            fusolab = Node.objects.create(**{
                'name': 'a node in rome',
                'slug': 'a-node-in-rome',
                'layer_id': 1,
                'geometry': 'POINT (12.5822391919000012 41.8720419276999820)',
                'user_id': 4  # romano
            })
            # ensure no notifications have been created/sent
            self.assertEqual(len(mail.outbox), 0)
            self.assertEqual(Notification.objects.count(), 0)
            
            # enable notification in distance range only for romano
            user = User.objects.get(username='romano')
            user.email_notification_settings.node_created = 20  # 20 km
            user.email_notification_settings.save()
            user.web_notification_settings.node_created = 20
            user.web_notification_settings.save()
            
            # romano should receive a notification when this new near node is created
            near_node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (12.5454 41.8352)',
                'user_id': 1
            })
            
            # ensure 1 email is sent
            self.assertEqual(len(mail.outbox), 1)
            # ensure 1 notification is created
            self.assertEqual(Notification.objects.count(), 1)
            # ensure notification is directed towards him
            notification = Notification.objects.all().order_by('-id')[0]
            self.assertEqual(notification.to_user_id, 4)
            
            # a new node is created at a distance wich is too far for romano's preferences
            far_node = Node.objects.create(**{
                'name': 'too far',
                'slug': 'too far',
                'layer_id': 1,
                'geometry': 'POINT (13.100 41.401)',
                'user_id': 1
            })
            
            # ensure no notifications are created nor email sent
            self.assertEqual(Notification.objects.count(), 1)
            self.assertEqual(len(mail.outbox), 1)
            
            # RESET
            near_node.delete()
            far_node.delete()
            Notification.objects.all().delete()
            
            # romano now wants to be notified via email but doesn't want to see the web notification
            user.email_notification_settings.node_created = 20  # 20 km
            user.email_notification_settings.save()
            user.web_notification_settings.node_created = -1
            user.web_notification_settings.save()
            
            near_node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (12.5454 41.8352)',
                'user_id': 1
            })
            # ensure 1 email is sent
            self.assertEqual(len(mail.outbox), 2)
            # ensure 1 notification is created
            self.assertEqual(Notification.objects.count(), 0)
        
        def test_node_deleted_all(self):
            # set every user to receive notifications about any node deletion
            all_users = User.objects.all()
            
            for user in all_users:
                user.email_notification_settings.node_deleted = 0
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.save()
                user.web_notification_settings.node_deleted = 0
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            # ensure 0 notifications
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            node.delete()
            
            self.assertEqual(Notification.objects.count(), all_users.count()-1)
            self.assertEqual(len(mail.outbox), all_users.count()-1)
        
        def test_node_deleted_all_email_noone_web(self):
            all_users = User.objects.all()
            
            for user in all_users:
                user.email_notification_settings.node_deleted = 0
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.save()
                user.web_notification_settings.node_deleted = -1
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            # ensure 0 notifications
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            node.delete()
            
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), all_users.count()-1)
        
        def test_node_deleted_all_web_noone_email(self):
            all_users = User.objects.all()
            
            for user in all_users:
                user.email_notification_settings.node_deleted = -1
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.save()
                user.web_notification_settings.node_deleted = 0
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            # ensure 0 notifications
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            node.delete()
            
            self.assertEqual(Notification.objects.count(), all_users.count()-1)
            self.assertEqual(len(mail.outbox), 0)
        
        def test_node_deleted_distance(self):
            # set every user to NOT receive notifications about new nodes
            # disable email notifications for all users
            for user in User.objects.all():
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.node_deleted = -1
                user.email_notification_settings.save()
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.node_deleted = -1
                user.web_notification_settings.save()
            
            # create node of user who will receive the notification
            fusolab = Node.objects.create(**{
                'name': 'a node in rome',
                'slug': 'a-node-in-rome',
                'layer_id': 1,
                'geometry': 'POINT (12.5822391919000012 41.8720419276999820)',
                'user_id': 4  # romano
            })
            
            # enable notification in distance range only for romano
            user = User.objects.get(username='romano')
            user.email_notification_settings.node_deleted = 20  # 20 km
            user.email_notification_settings.save()
            user.web_notification_settings.node_deleted = 20
            user.web_notification_settings.save()
            
            # romano should receive a notification when this new near node is created
            near_node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (12.5454 41.8352)',
                'user_id': 1
            })
            
            # ensure 0 notifications
            self.assertEqual(len(mail.outbox), 0)
            self.assertEqual(Notification.objects.count(), 0)
            
            # delete node
            near_node.delete()
            
            # ensure 1 email is sent
            self.assertEqual(len(mail.outbox), 1)
            # ensure 1 notification is created
            self.assertEqual(Notification.objects.count(), 1)
            # ensure notification is directed towards him
            notification = Notification.objects.all().order_by('-id')[0]
            self.assertEqual(notification.to_user_id, 4)
            
            # a new node is created at a distance wich is too far for romano's preferences
            far_node = Node.objects.create(**{
                'name': 'too far',
                'slug': 'too far',
                'layer_id': 1,
                'geometry': 'POINT (13.100 41.401)',
                'user_id': 1
            })
            
            # ensure 0 notifications
            self.assertEqual(len(mail.outbox), 1)
            self.assertEqual(Notification.objects.count(), 1)
            
            far_node.delete()
            
            # ensure no additional notifications are created nor email sent
            self.assertEqual(Notification.objects.count(), 1)
            self.assertEqual(len(mail.outbox), 1)
            
            # RESET
            Notification.objects.all().delete()
            
            # romano now wants to be notified via email but doesn't want to see the web notification
            user.email_notification_settings.node_deleted = 20  # 20 km
            user.email_notification_settings.save()
            user.web_notification_settings.node_deleted = -1
            user.web_notification_settings.save()
            
            near_node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (12.5454 41.8352)',
                'user_id': 1
            })
            near_node.delete()
            # ensure 1 email is sent
            self.assertEqual(len(mail.outbox), 2)
            # ensure 1 notification is created
            self.assertEqual(Notification.objects.count(), 0)
            
            # RESET
            Notification.objects.all().delete()
            
            # yes to web no to email
            user.email_notification_settings.node_deleted = -1
            user.email_notification_settings.save()
            user.web_notification_settings.node_deleted = 20
            user.web_notification_settings.save()
            
            near_node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (12.5454 41.8352)',
                'user_id': 1
            })
            near_node.delete()
            # no additional mail sent
            self.assertEqual(len(mail.outbox), 2)
            # ensure 1 notification is created
            self.assertEqual(Notification.objects.count(), 1)
            # ensure notification is directed towards him
            notification = Notification.objects.all().order_by('-id')[0]
            self.assertEqual(notification.to_user_id, 4)
        
        def test_node_status_changed_all(self):
            all_users = User.objects.all()
            
            # all users receive notifications about status changes but no other notification
            for user in all_users:
                user.email_notification_settings.node_deleted = -1
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.node_status_changed = 0
                user.email_notification_settings.save()
                user.web_notification_settings.node_deleted = -1
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.node_status_changed = 0
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            # ensure 0 notifications
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            node.status_id = 3
            node.save()
            
            self.assertEqual(Notification.objects.filter(type='node_status_changed').count(), all_users.count()-1)
            self.assertEqual(Notification.objects.filter(type='node_own_status_changed').count(), 1)
            # ensure notification of type "node_own_status_changed" is directed towards owner
            notification = Notification.objects.filter(type='node_own_status_changed').order_by('-id')[0]
            self.assertEqual(notification.to_user_id, 1)
            self.assertEqual(len(mail.outbox), 8)  # all users have received emails
        
        def test_node_status_changed_all_email_noone_web(self):
            all_users = User.objects.all()
            
            for user in all_users:
                user.email_notification_settings.node_deleted = -1
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.node_status_changed = 0
                user.email_notification_settings.save()
                user.web_notification_settings.node_deleted = -1
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.node_status_changed = -1
                user.web_notification_settings.save()
            
            node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (-2.46 48.12)',
                'user_id': 1
            })
            # ensure 0 notifications
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            node.status_id = 3
            node.save()
            
            self.assertEqual(Notification.objects.filter(type='node_status_changed').count(), 0)
            self.assertEqual(Notification.objects.filter(type='node_own_status_changed').count(), 1)
            # ensure notification of type "node_own_status_changed" is directed towards owner
            notification = Notification.objects.filter(type='node_own_status_changed').order_by('-id')[0]
            self.assertEqual(notification.to_user_id, 1)
            self.assertEqual(len(mail.outbox), 8)  # all users have received emails
        
        def test_node_status_changed_distance(self):
            all_users = User.objects.all()
            
            # disable everything
            for user in all_users:
                user.email_notification_settings.node_deleted = -1
                user.email_notification_settings.node_created = -1
                user.email_notification_settings.node_status_changed = -1
                user.email_notification_settings.node_own_status_changed = False
                user.email_notification_settings.save()
                user.web_notification_settings.node_deleted = -1
                user.web_notification_settings.node_created = -1
                user.web_notification_settings.node_status_changed = -1
                user.web_notification_settings.node_own_status_changed = False
                user.web_notification_settings.save()
            
            # create node of user who will receive the notification
            fusolab = Node.objects.create(**{
                'name': 'a node in rome',
                'slug': 'a-node-in-rome',
                'layer_id': 1,
                'geometry': 'POINT (12.5822391919000012 41.8720419276999820)',
                'user_id': 4  # romano
            })
            # ensure 0 notifications
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            # enable notification in distance range only for romano
            user = User.objects.get(username='romano')
            user.email_notification_settings.node_status_changed = 20  # 20 km
            user.email_notification_settings.save()
            user.web_notification_settings.node_status_changed = 20
            user.web_notification_settings.save()
            
            # romano should receive a notification when this new near node is created
            near_node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (12.5454 41.8352)',
                'user_id': 1
            })
            # ensure 0 notifications
            self.assertEqual(Notification.objects.count(), 0)
            self.assertEqual(len(mail.outbox), 0)
            
            near_node.status_id = 3
            near_node.save()
            
            # ensure 1 email is sent
            self.assertEqual(len(mail.outbox), 1)
            # ensure 1 notification is created
            self.assertEqual(Notification.objects.count(), 1)
            self.assertEqual(Notification.objects.filter(type='node_status_changed').count(), 1)
            # ensure notification is directed towards romano
            notification = Notification.objects.all().order_by('-id')[0]
            self.assertEqual(notification.to_user_id, 4)
            
            # a new node is created at a distance wich is too far for romano's preferences
            far_node = Node.objects.create(**{
                'name': 'too far',
                'slug': 'too far',
                'layer_id': 1,
                'geometry': 'POINT (13.100 41.401)',
                'user_id': 1
            })
            
            far_node.status_id = 3
            far_node.save()
            
            # ensure no additional notifications are created nor email sent
            self.assertEqual(Notification.objects.count(), 1)
            self.assertEqual(len(mail.outbox), 1)
            
            # RESET
            near_node.delete()
            far_node.delete()
            Notification.objects.all().delete()
            
            # romano now wants to be notified via email but doesn't want to see the web notification
            user.email_notification_settings.node_status_changed = 20  # 20 km
            user.email_notification_settings.save()
            user.web_notification_settings.node_status_changed = -1
            user.web_notification_settings.save()
            
            near_node = Node.objects.create(**{
                'name': 'test notification',
                'slug': 'test-notification',
                'layer_id': 1,
                'geometry': 'POINT (12.5454 41.8352)',
                'user_id': 1
            })
            
            near_node.status_id = 3
            near_node.save()
            
            # ensure 1 email is sent
            self.assertEqual(len(mail.outbox), 2)
            # ensure 1 notification is created
            self.assertEqual(Notification.objects.count(), 0)
        
        def test_read_notifications_API(self):
            """ test read notification API operation """
            url = reverse('api_notification_list')
            
            # GET 403 unauthorized
            response = self.client.get(url)
            self.assertEqual(response.status_code, 403)
            
            self.client.login(username='romano', password='tester')
            
            response = self.client.get(url)
            self.assertContains(response, '[]')
            
            user = User.objects.get(pk=4)
            user.web_notification_settings.node_created = 0
            user.web_notification_settings.save()
            
            # generate a notification
            fusolab = Node.objects.create(**{
                'name': 'a node in rome',
                'slug': 'a-node-in-rome',
                'layer_id': 1,
                'geometry': 'POINT (12.5822391919000012 41.8720419276999820)',
                'user_id': 1  # admin
            })
            
            # test ?action=count
            response = self.client.get(url, { 'action': 'count' })
            self.assertContains(response, '{"count": 1}')
            
            # test ?read=false
            # retrieve notifications but do not mark as read
            response = self.client.get(url, { 'read': 'false' })
            self.assertEquals(1, len(response.data), 'expected 1 notification')
            
            # test ?read=true
            # repeating the request should still show 1 unread notification, but the read operation will mark them as read
            self.assertEqual(Notification.objects.filter(to_user_id=4, is_read=False).count(), 1)
            response = self.client.get(url)
            self.assertEquals(1, len(response.data))
            # repeating again should find 0 unread notifications
            response = self.client.get(url)
            self.assertContains(response, '[]')
            self.assertEqual(Notification.objects.filter(to_user_id=4, is_read=False).count(), 0)
            
            # test action=all
            response = self.client.get(url, { 'action': 'all' })
            notifications = response.data
            self.assertEquals(1, len(notifications['results']))
            self.assertContains(response, '"is_read"', msg_prefix="'read' should be a field on its own")
            
            # test pagination of action=all
            for i in range(1, 31):
                notification_text = 'testing notifications, iteration n. %d' % i
                n = Notification(
                    to_user_id=4,
                    type='custom',
                    text=notification_text
                )
                n.save()
            response = self.client.get(url, { 'action': 'all' })
            notifications = response.data
            self.assertEquals(31, notifications['count'])
            self.assertTrue(notifications['next'] is not None, 'expected a next page')
            self.assertTrue(notifications['previous'] is None, 'expected no previous page')
            response = self.client.get(notifications['next'])
            notifications = response.data
            self.assertTrue(notifications['previous'] is not None, 'expected a previous page')
            
            # test non expected action should default to unread
            response = self.client.get(url, { 'action': 'doesntexist' })
            self.assertEquals(30, len(response.data))
        
        def test_notification_detail_API(self):
            # set user #4 to receive notifications
            user = User.objects.get(pk=4)
            user.web_notification_settings.node_created = 0
            user.web_notification_settings.save()
            
            # generate a notification
            fusolab = Node.objects.create(**{
                'name': 'a node in rome',
                'slug': 'a-node-in-rome',
                'layer_id': 1,
                'geometry': 'POINT (12.5822391919000012 41.8720419276999820)',
                'user_id': 1  # admin
            })
            
            notification_id = Notification.objects.order_by('-id').all()[0].id
            
            # test notification detail
            url = reverse('api_notification_detail', args=[notification_id])
            
            # GET 403 unauthorized
            response = self.client.get(url)
            self.assertEqual(response.status_code, 403)
            
            # GET 404
            # login as wrong user
            self.client.login(username='registered', password='tester')
            response = self.client.get(url)
            self.assertEqual(response.status_code, 404)
            self.client.logout()
            
            # GET 200
            # login as right user
            self.client.login(username='romano', password='tester')
            response = self.client.get(url)
            self.assertEqual(response.status_code, 200)
            self.assertEqual(response.data['id'], notification_id)
        
        def test_email_notification_settings(self):
            """ ensure email notification settings endpoint works correctly """
            url = reverse('api_notification_email_settings')
            
            # GET 401: unauthenticated request should fail
            c = Client()
            response = c.get(url)
            self.assertContains(response, 'credentials', status_code=403)
            
            self.client.login(username='romano', password='tester')
            
            # GET 200
            response = self.client.get(url)
            self.assertEquals(200, response.status_code)
            self.assertContains(response, 'uri')
            self.assertContains(response, 'node_created')
            self.assertContains(response, 'node_status_changed')
            self.assertContains(response, 'node_own_status_changed')
            self.assertContains(response, 'node_deleted')
            
            # PATCH 200
            response = self.client.patch(url, { "node_own_status_changed": False })
            self.assertEquals(200, response.status_code)
            # check DB
            user = User.objects.get(username='romano')
            self.assertFalse(user.email_notification_settings.node_own_status_changed)
            
            # PUT 200
            response = self.client.put(url, json.dumps({
                "node_created": 50, 
                "node_status_changed": 50, 
                "node_own_status_changed": True, 
                "node_deleted": 50
            }), content_type='application/json')
            self.assertEquals(200, response.status_code)
            # check DB
            user = User.objects.get(username='romano')
            self.assertTrue(user.email_notification_settings.node_own_status_changed)
            self.assertEqual(user.email_notification_settings.node_created, 50)
            self.assertEqual(user.email_notification_settings.node_status_changed, 50)
            self.assertEqual(user.email_notification_settings.node_deleted, 50)
        
        def test_web_notification_settings(self):
            """ ensure web notification settings endpoint works correctly """
            url = reverse('api_notification_web_settings')
            
            # GET 401: unauthenticated request should fail
            c = Client()
            response = c.get(url)
            self.assertContains(response, 'credentials', status_code=403)
            
            self.client.login(username='romano', password='tester')
            
            # GET 200
            response = self.client.get(url)
            self.assertEquals(200, response.status_code)
            self.assertContains(response, 'uri')
            self.assertContains(response, 'node_created')
            self.assertContains(response, 'node_status_changed')
            self.assertContains(response, 'node_own_status_changed')
            self.assertContains(response, 'node_deleted')
            
            # PATCH 200
            response = self.client.patch(url, { "node_own_status_changed": False })
            self.assertEquals(200, response.status_code)
            # check DB
            user = User.objects.get(username='romano')
            self.assertFalse(user.web_notification_settings.node_own_status_changed)
            
            # PUT 200
            response = self.client.put(url, json.dumps({
                "node_created": 50, 
                "node_status_changed": 50, 
                "node_own_status_changed": True, 
                "node_deleted": 50
            }), content_type='application/json')
            self.assertEquals(200, response.status_code)
            # check DB
            user = User.objects.get(username='romano')
            self.assertTrue(user.web_notification_settings.node_own_status_changed)
            self.assertEqual(user.web_notification_settings.node_created, 50)
            self.assertEqual(user.web_notification_settings.node_status_changed, 50)
            self.assertEqual(user.web_notification_settings.node_deleted, 50)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url

urlpatterns = patterns('nodeshot.community.notifications.views',
    url(r'^account/notifications/$', 'notification_list', name='api_notification_list'),
    url(r'^account/notifications/(?P<pk>[0-9]+)/$', 'notification_detail', name='api_notification_detail'),
    
    # email settings
    url(r'^account/notifications/email-settings/$',
        'notification_email_settings',
        name='api_notification_email_settings'),
    
    # web settings
    url(r'^account/notifications/web-settings/$',
        'notification_web_settings',
        name='api_notification_web_settings'),
)

########NEW FILE########
__FILENAME__ = views
from rest_framework import generics, permissions, authentication
from rest_framework.response import Response

from .models import *
from .serializers import *


class NotificationList(generics.ListAPIView):
    """
    Retrieve a list of notifications of the current user.
    
    **Available variations through querystring parameters:**
    
     * `action=unread`: default behaviour, retrieve unread notifications and mark them as read
     * `action=unread&read=false`: retrieve unread notifications without marking them as read
     * `action=count`: retrieve count of unread notifications without marking them as read
     * `action=all`: retrieve all notifications with pagination
        * `limit=<n>`: specify number of items per page (defaults to 30)
        * `limit=0`: turns off pagination
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticated,)
    paginate_by = 30
    paginate_by_param = 'limit'
    serializer_class = NotificationSerializer
    pagination_serializer_class = PaginatedNotificationSerializer
    queryset = Notification.objects.select_related('from_user')
    
    def get_queryset(self):
        """ filter only notifications of current user """
        return self.queryset.filter(to_user=self.request.user)
    
    def get(self, request, format=None):
        """ get HTTP method """
        action = request.QUERY_PARAMS.get('action', 'unread')
        # action can be only "unread" (default), "count" and "all"
        action = action if action == 'count' or action == 'all' else 'unread'
        # mark as read parameter, defaults to true
        mark_as_read = request.QUERY_PARAMS.get('read', 'true') == 'true'
        # queryset
        notifications = self.get_queryset().filter(to_user=request.user)
        # pass to specific action
        return getattr(self, 'get_%s' % action)(request, notifications, mark_as_read)
    
    def get_unread(self, request, notifications, mark_as_read):
        """ return unread notifications and mark as read (unless read=false param is passed)"""
        notifications = notifications.filter(is_read=False)
        data = UnreadNotificationSerializer(notifications, many=True).data
        # if True mark retrieve unread notifications as read (default behaviour)
        if mark_as_read:
            notifications.update(is_read=True)
        return Response(data)
    
    def get_count(self, request, notifications, mark_as_read=False):
        """ return count of unread notification """
        data = { 'count': notifications.filter(is_read=False).count() }
        return Response(data)
    
    def get_all(self, request, notifications, mark_as_read=False):
        """ return all notifications with pagination """
        notifications = notifications
        return self.list(request, notifications)

notification_list = NotificationList.as_view()


class NotificationDetail(generics.RetrieveAPIView):
    """
    Retrieve specific notification of current user.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticated,)
    serializer_class = NotificationSerializer
    queryset = Notification.objects.select_related('from_user')
    
    def get_queryset(self):
        """ filter only notifications of current user """
        return self.queryset.filter(to_user=self.request.user)

notification_detail = NotificationDetail.as_view()


# ------ User Notification Settings ------ #


class EmailNotificationSettings(generics.RetrieveUpdateAPIView):
    """
    Retrieve Email Notification settings.
    
    ### PUT & PATCH
    
    Edit Email Notification settings.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticated,)
    serializer_class = EmailNotificationSettingsSerializer
    model = UserEmailNotificationSettings
    
    def get_queryset(self):
        return self.model.objects.get(user_id=self.request.user.id)
        
    def get_object(self, queryset=None):
        """ get privacy settings of current user """
        try:
            obj = self.get_queryset()
        except self.model.DoesNotExist:
            raise Http404()
        self.check_object_permissions(self.request, obj)
        return obj

notification_email_settings = EmailNotificationSettings.as_view()


class WebNotificationSettings(EmailNotificationSettings):
    """
    Retrieve Web Notification settings.
    
    ### PUT & PATCH
    
    Edit Web Notification settings.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticated,)
    serializer_class = WebNotificationSettingsSerializer
    model = UserWebNotificationSettings

notification_web_settings = WebNotificationSettings.as_view()

########NEW FILE########
__FILENAME__ = admin
from django.contrib.gis import admin
from django.conf import settings

from nodeshot.core.base.admin import BaseTabularInline

from .models import *


admin.site.register(Rating)
admin.site.register(Comment)
admin.site.register(Vote)


# ------ EXTEND LAYER ADMIN ------ #

if 'nodeshot.core.layers' in settings.INSTALLED_APPS:

    from nodeshot.core.layers.admin import LayerAdmin
    
    class LayerSettingsInline(admin.TabularInline):
        model = LayerParticipationSettings
        extra = 1
    
    LayerAdmin.inlines.append(LayerSettingsInline)


# ------ EXTEND NODE ADMIN ------ #

from nodeshot.core.nodes.admin import NodeAdmin


class NodeSettingsInline(admin.TabularInline):
    model = NodeParticipationSettings
    extra = 1


class CommentInline(BaseTabularInline):
    model = Comment
    extra = 1 


class RatingInline(BaseTabularInline):
    model = Rating
    extra = 1 


class VoteInline(BaseTabularInline):
    model = Vote
    extra = 1 


additional_inlines = [NodeSettingsInline]

if settings.DEBUG:
    additional_inlines += [CommentInline, RatingInline, VoteInline]

NodeAdmin.inlines = NodeAdmin.inlines + additional_inlines

########NEW FILE########
__FILENAME__ = base
from django.db import models


class UpdateCountsMixin(models.Model):
    """
    Updates node_rating_count record each time an
    Instance of an extended model is created or deleted
    """
    
    class Meta:
        abstract = True
    
    def update_count(self):
        """ this method needs to be overwritten """
        pass
    
    def save(self, *args, **kwargs):
        """ custom save method to update counts """
        # the following lines determines if the comment is being created or not
        # in case the comment exists the pk attribute is an int
        created = type(self.pk) is not int
        
        super(UpdateCountsMixin, self).save(*args, **kwargs)
        
        # this operation must be performed after the parent save
        if created:
            self.update_count()
    
    def delete(self, *args, **kwargs):
        """ custom delete method to update counts """
        super(UpdateCountsMixin, self).delete(*args, **kwargs)
        self.update_count()

########NEW FILE########
__FILENAME__ = comment
from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from django.core.exceptions import ValidationError

from nodeshot.core.base.models import BaseDate
from .base import UpdateCountsMixin


class Comment(UpdateCountsMixin, BaseDate):
    """
    Comment model
    """
    node = models.ForeignKey('nodes.Node')
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    text = models.CharField(_('Comment text'), max_length=255)
    
    class Meta:
        app_label = 'participation'
        db_table = 'participation_comment'
        ordering = ['id']
    
    def __unicode__(self):
        return self.text
    
    def update_count(self):
        """ updates comment count """
        node_rating_count = self.node.rating_count
        node_rating_count.comment_count = self.node.comment_set.count()
        node_rating_count.save()
    
    def clean(self , *args, **kwargs):
        """
        Check if comments can be inserted for parent node or parent layer
        """
        # check done only for new nodes!
        if not self.pk:
            node = self.node
            
            # ensure comments for this node are allowed
            if  node.participation_settings.comments_allowed is False:
                raise ValidationError("Comments not allowed for this node")
            
            # ensure comments for this layer are allowed
            if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
                layer = node.layer
                if  layer.participation_settings.comments_allowed is False:
                    raise ValidationError("Comments not allowed for this layer")

########NEW FILE########
__FILENAME__ = layer_participation_settings
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.layers.models import Layer


class LayerParticipationSettings(models.Model):
    """
    Layer settings regarding participation
    """
    layer = models.OneToOneField(Layer, related_name='layer_participation_settings')
    # settings
    voting_allowed = models.BooleanField(_('voting allowed?'), default=True)
    rating_allowed = models.BooleanField(_('rating allowed?'), default=True)
    comments_allowed = models.BooleanField(_('comments allowed?'), default=True)
    
    def __unicode__(self):
        return _('Participation settings for layer %s' % self.layer.name)

    class Meta:
        app_label = 'participation'
        db_table = 'participation_layer_settings'
        verbose_name_plural = "participation_layer_settings"
    

########NEW FILE########
__FILENAME__ = node_participation_settings
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.nodes.models import Node


class NodeParticipationSettings(models.Model):
    """
    Node Participation Settings
    """
    node = models.OneToOneField(Node, related_name='node_participation_settings')
    # settings
    voting_allowed = models.BooleanField(_('voting allowed?'), default=True)
    rating_allowed = models.BooleanField(_('rating allowed?'), default=True)
    comments_allowed = models.BooleanField(_('comments allowed?'), default=True)

    def __unicode__(self):
        return _('Participation settings for node %s' % self.node.name)

    class Meta:
        app_label = 'participation'
        db_table = 'participation_node_settings'
        verbose_name_plural = "participation_node_settings"

########NEW FILE########
__FILENAME__ = node_rating_count
from django.db import models

from nodeshot.core.nodes.models import Node


class NodeRatingCount(models.Model):
    """
    Node Rating Count
    Keep track of participation counts of nodes.
    """
    node = models.OneToOneField(Node)
    likes = models.IntegerField(default=0)
    dislikes = models.IntegerField(default=0)
    rating_count = models.IntegerField(default=0)
    rating_avg = models.FloatField(default=0.0)
    comment_count = models.IntegerField(default=0)
    
    def __unicode__(self):
        return self.node.name
    
    class Meta:
        app_label = 'participation'
        db_table = 'participation_node_counts'
########NEW FILE########
__FILENAME__ = rating
from django.db import models
from django.db.models import Avg
from django.utils.translation import ugettext_lazy as _
from django.conf import settings
from django.core.exceptions import ValidationError

from nodeshot.core.base.models import BaseDate
from nodeshot.core.nodes.models import Node
from nodeshot.core.layers.models import Layer

from .base import UpdateCountsMixin


class Rating(UpdateCountsMixin, BaseDate):
    """
    Rating model
    """
    # rating choices from 1 to 10
    RATING_CHOICES = [(n, '%d' % n) for n in range(1, 11)]
    
    node = models.ForeignKey(Node)
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    value = models.IntegerField(_('rating value'), choices=RATING_CHOICES)
    
    class Meta:
        app_label = 'participation'
        unique_together = (("node", "user"),)
    
    def __unicode__(self):
        return _('rating #%d for node %s') % (self.pk, self.node.name)
    
    def update_count(self):
        """ updates rating count and rating average """
        node_rating_count = self.node.rating_count
        node_rating_count.rating_count = self.node.rating_set.count()
        node_rating_count.rating_avg = self.node.rating_set.aggregate(rate=Avg('value'))['rate']
        
        # if all ratings are deleted the value will be None!
        if node_rating_count.rating_avg is None:
            # set to 0 otherwise we'll get an exception
            node_rating_count.rating_avg = 0

        node_rating_count.save()
    
    def clean(self , *args, **kwargs):
        """
        Check if rating can be inserted for parent node or parent layer
        """
        if not self.pk:
            node = self.node
            layer= Layer.objects.get(pk=node.layer_id)
            if  layer.participation_settings.rating_allowed is not True:
                raise ValidationError  ("Rating not allowed for this layer")
            if  node.participation_settings.rating_allowed is not True:
                raise ValidationError  ("Rating not allowed for this node")

########NEW FILE########
__FILENAME__ = vote
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.conf import settings
from django.core.exceptions import ValidationError

from nodeshot.core.base.models import BaseDate

from .base import UpdateCountsMixin


class Vote(UpdateCountsMixin, BaseDate):
    """
    Vote model
    Like or dislike feature
    """
    
    VOTING_CHOICES = (
        (1, 'Like'),
        (-1, 'Dislike'),
    )
    
    node = models.ForeignKey('nodes.Node')
    user = models.ForeignKey(settings.AUTH_USER_MODEL)
    # TODO: this should also be called "value" instead of "vote"
    vote = models.IntegerField(choices=VOTING_CHOICES)
    
    class Meta:
        app_label = 'participation'
        unique_together = (("node", "user"),)
    
    def __unicode__(self):
        return _('vote #%d for node %s') % (self.pk, self.node.name)
    
    def update_count(self):
        """ updates likes and dislikes count """
        node_rating_count = self.node.rating_count
        node_rating_count.likes = self.node.vote_set.filter(vote=1).count()
        node_rating_count.dislikes = self.node.vote_set.filter(vote=-1).count()
        node_rating_count.save()
      
    def clean(self , *args, **kwargs):
        """
        Check if votes can be inserted for parent node or parent layer
        """
        if not self.pk:
            # ensure voting for this node is allowed
            if self.node.participation_settings.voting_allowed is not True:
                raise ValidationError("Voting not allowed for this node")
            
            if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
                layer = self.node.layer
                
                # ensure voting for this layer is allowed
                if layer.participation_settings.voting_allowed is not True:
                    raise ValidationError("Voting not allowed for this layer")

########NEW FILE########
__FILENAME__ = serializers
from django.contrib.auth import get_user_model
User = get_user_model()

from rest_framework import serializers, pagination

from nodeshot.core.nodes.models import Node
from nodeshot.community.profiles.serializers import ProfileRelationSerializer
from .models import *


__all__ = [
    'CommentAddSerializer',
    'CommentListSerializer',
    'CommentSerializer',
    'NodeCommentSerializer',
    'ParticipationSerializer',
    'NodeParticipationSerializer',
    'RatingListSerializer',
    'RatingAddSerializer' ,
    'VoteListSerializer',
    'VoteAddSerializer',
    'LinksSerializer',
    'PaginationSerializer',
    'NodeParticipationSettingsSerializer',
    'NodeSettingsSerializer',
    'LayerParticipationSettingsSerializer',
    'LayerSettingsSerializer'
]



class LinksSerializer(serializers.Serializer):
    next = pagination.NextPageField(source='*')
    prev = pagination.PreviousPageField(source='*')


class PaginationSerializer(pagination.BasePaginationSerializer):
    links = LinksSerializer(source='*')  # Takes the page object as the source
    total_results = serializers.Field(source='paginator.count')
    results_field = 'nodes'


class CommentAddSerializer(serializers.ModelSerializer):
    class Meta:
        model = Comment
        fields= ('node', 'user', 'text', )


class CommentListSerializer(serializers.ModelSerializer):
    """ Comment serializer """
    node = serializers.Field(source='node.name')
    username = serializers.Field(source='user.username')

    class Meta:
        model = Comment
        fields = ('node', 'username', 'text', 'added')
        read_only_fields = ('added',)


class CommentSerializer(serializers.ModelSerializer):
    username = serializers.Field(source='user.username')

    class Meta:
        model = Comment
        fields = ('username', 'text', 'added',)


class NodeCommentSerializer(serializers.ModelSerializer):
    comments = CommentSerializer(source='comment_set')

    class Meta:
        model = Node
        fields = ('name', 'description', 'comments')


class CommentRelationSerializer(serializers.ModelSerializer):
    """ display user info """
    user = ProfileRelationSerializer(source='user')

    class Meta:
        model = Comment
        fields = ('user', 'text', 'added',)


class RatingAddSerializer(serializers.ModelSerializer):
    class Meta:
        model = Rating
        fields= ('node', 'user', 'value', )


class RatingListSerializer(serializers.ModelSerializer):
    """ Rating serializer """
    node = serializers.Field(source='node.name')
    username = serializers.Field(source='user.username')

    class Meta:
        model = Rating
        fields = ('node', 'username', 'value',)
        read_only_fields = ('added',)


class VoteAddSerializer(serializers.ModelSerializer):
    class Meta:
        model = Vote
        fields= ('node', 'user', 'vote', )


class VoteListSerializer(serializers.ModelSerializer):
    """ Votes serializer """
    node = serializers.Field(source='node.name')
    username = serializers.Field(source='user.username')

    class Meta:
        model = Vote
        fields = ('node', 'username', 'vote',)
        read_only_fields = ('added',)


class ParticipationSerializer(serializers.ModelSerializer):
    class Meta:
        model = NodeRatingCount
        fields = ('likes', 'dislikes', 'rating_count',
                  'rating_avg', 'comment_count')


class NodeParticipationSerializer(serializers.ModelSerializer):
    """ Node participation details """
    participation = ParticipationSerializer(source='noderatingcount')

    class Meta:
        model=Node
        fields= ('name', 'slug', 'address', 'participation')


class NodeSettingsSerializer(serializers.ModelSerializer):
    class Meta:
        model = NodeParticipationSettings
        fields = ('voting_allowed', 'rating_allowed', 'comments_allowed',)


class NodeParticipationSettingsSerializer(serializers.ModelSerializer):
    """ Node participation settings """
    participation_settings = NodeSettingsSerializer(source='node_participation_settings')

    class Meta:
        model = Node
        fields = ('name', 'slug', 'address', 'participation_settings')


class LayerSettingsSerializer(serializers.ModelSerializer):
    class Meta:
        model = LayerParticipationSettings
        fields = ('voting_allowed', 'rating_allowed', 'comments_allowed',)


class LayerParticipationSettingsSerializer(serializers.ModelSerializer):
    """ Layer participation settings"""
    participation_settings = LayerSettingsSerializer(source='layer_participation_settings')

    class Meta:
        model=Node
        fields= ('name', 'slug', 'participation_settings')


# ------ Add relationship to ExtensibleNodeSerializer ------ #

from nodeshot.core.nodes.serializers import ExtensibleNodeSerializer

ExtensibleNodeSerializer.add_relationship(
    'comments',
    serializer=CommentRelationSerializer,
    many=True,
    queryset='obj.comment_set.all()'
)

ExtensibleNodeSerializer.add_relationship(
    'counts',
    serializer=ParticipationSerializer,
    queryset='obj.noderatingcount'
)

ExtensibleNodeSerializer.add_relationship(
    'votes_url',
    view_name='api_node_votes',
    lookup_field='slug'
)

ExtensibleNodeSerializer.add_relationship(
    'ratings_url',
    view_name='api_node_ratings',
    lookup_field='slug'
)

ExtensibleNodeSerializer.add_relationship(
    'comments_url',
    view_name='api_node_comments',
    lookup_field='slug'
)

def has_already_voted(obj, request):
    """
    Determines if current logged-in user has already voted on a node
    returns 1 if user has already liked
    returns -1 if user has already disliked
    returns False if user hasn't voted or if not authenticated
    """
    if request.user.is_authenticated():
        v = Vote.objects.filter(node_id=obj.id, user_id=request.user.id)
        try:
            return v[0].vote
        except IndexError:
            pass
    # hasn't voted yet or not authenticated
    return False

ExtensibleNodeSerializer.add_relationship(
    'has_already_voted',
    function=has_already_voted
)

########NEW FILE########
__FILENAME__ = tasks
from celery import task


# ------ Asynchronous tasks ------ #


@task
def create_related_object(model, kwargs):
    """
    create object with specified kwargs in background
    """
    model.objects.create(**kwargs)
########NEW FILE########
__FILENAME__ = tests
"""
Unit tests for participation app
"""
from django.contrib.auth import get_user_model
User = get_user_model()
from django.test import TestCase
from django.core.urlresolvers import reverse

import simplejson as json

from nodeshot.core.nodes.models import Node
from nodeshot.core.layers.models import Layer
from nodeshot.core.base.tests import user_fixtures

from .models import Comment, Rating, Vote


class ParticipationModelsTest(TestCase):
    """ Models tests """
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_images.json'
    ]
    
    def test_added_methods(self):
        node = Node.objects.get(pk=1)
        # ensure noderatingcount related object is automatically created with signals
        node.rating_count
        node.participation_settings
        node.layer.participation_settings
    
    def test_update_comment_count(self):
        """
        Comment count should be updated when a comment is created or deleted
        """
        # ensure comment count is 0
        node = Node.objects.get(pk=1)
        self.assertEqual(0, node.rating_count.comment_count)
        # create a new comment
        comment = Comment(node_id=1, user_id=1, text='test comment')
        comment.save()
        # now should have incremented by 1
        node = Node.objects.get(pk=1)
        self.assertEqual(1, node.rating_count.comment_count)
        
        # delete comment and ensure the count gets back to 0
        comment.delete()
        node = Node.objects.get(pk=1)
        self.assertEqual(0, node.rating_count.comment_count)
    
    def test_update_rating_count(self):
        """
        Rating count and average should be updated when a rating is created or deleted
        """
        # ensure rating count is 0
        node = Node.objects.get(pk=1)
        self.assertEqual(0, node.rating_count.rating_count)
        self.assertEqual(0, node.rating_count.rating_avg)
        # create a new rating
        rating = Rating(node_id=1, user_id=1, value=10)
        rating.save()
        # now should have incremented by 1 and average should be 10
        node = Node.objects.get(pk=1)
        self.assertEqual(1, node.rating_count.rating_count)
        self.assertEqual(10, node.rating_count.rating_avg)
        
        # delete rating and ensure the counts get back to 0
        rating.delete()
        node = Node.objects.get(pk=1)
        self.assertEqual(0, node.rating_count.rating_count)
        self.assertEqual(0, node.rating_count.rating_avg)
    
    def test_update_vote_count(self):
        """
        Likes and dislikes count should be updated when a vote is created or deleted
        """
        # ensure likes and dislikes count are 0
        node = Node.objects.get(pk=1)
        self.assertEqual(0, node.rating_count.likes)
        self.assertEqual(0, node.rating_count.dislikes)
        # create a new like
        like = Vote(node_id=1, user_id=1, vote=1)
        like.save()
        # likes should have incremented by 1
        node = Node.objects.get(pk=1)
        self.assertEqual(1, node.rating_count.likes)
        self.assertEqual(0, node.rating_count.dislikes)
        # create a new dislike
        dislike = Vote(node_id=1, user_id=2, vote=-1)
        dislike.save()
        # dislikes should have incremented by 1
        node = Node.objects.get(pk=1)
        self.assertEqual(1, node.rating_count.likes)
        self.assertEqual(1, node.rating_count.dislikes)
        
        # delete like and count should get back to 0
        like.delete()
        node = Node.objects.get(pk=1)
        self.assertEqual(0, node.rating_count.likes)
        self.assertEqual(1, node.rating_count.dislikes)
        
        # delete dislike and count should get back to 0
        dislike.delete()
        node = Node.objects.get(pk=1)
        self.assertEqual(0, node.rating_count.likes)
        self.assertEqual(0, node.rating_count.dislikes)
        
    def test_node_comment_api(self):
        """
        Comments endpoint should be reachable with GET and return 404 if object is not found.
        POST method allowed
        """
        node = Node.objects.get(pk=1)
        node_slug = node.slug
        node_id = node.id
        node2 = Node.objects.get(pk=2)
        node2_slug = node2.slug
        fake_node_slug = "idontexist"
        layer = Layer.objects.get(pk=node.layer_id)
        
        url = reverse('api_node_comments', args=[node_slug])
        url2 = reverse('api_node_comments', args=[node2_slug])
        wrong_url = reverse('api_node_comments', args=[fake_node_slug])
        
        # api_node_comments
        
        # GET
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        
        # add two comments to two different nodes for testing purposes
        comment1 = Comment.objects.create(node=node, user_id=1, text='node 1, user 1')
        comment2 = Comment.objects.create(node=node2, user_id=2, text='node 2, user 2')
        
        # ensure the right amounts of comments are loaded!
        response = self.client.get(url)
        self.assertEqual(len(json.loads(response.content)), Comment.objects.filter(node=node).count())
        
        response = self.client.get(wrong_url)
        self.assertEqual(response.status_code, 404)       
        
        # POST
        
        login = self.client.login(username='admin', password='tester')
        good_post_data = { "text": "test_comment" }
        bad_post_data = { "node": 100, "text": "test_comment_bad", "user": 2 }
        
        # wrong slug -- 404
        response = self.client.post(wrong_url, good_post_data)
        self.assertEqual(response.status_code, 404)
        
        # correct POST data and correct slug -- 201
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # POST 201 - ensure additional post data "user" and "node" are ignored
        response = self.client.post(url, bad_post_data)
        self.assertEqual(response.status_code, 201)
        comment_dict = json.loads(response.content)
        self.assertEqual(comment_dict['user'], 1)
        self.assertEqual(comment_dict['node'], 1)
        self.assertEqual(comment_dict['text'], "test_comment_bad")
        
        # POSTing a comment for node2
        response = self.client.post(url2, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # GET should not return both the comments inserted above     
        response = self.client.get(url)
        comments = json.loads(response.content)
        node_comments_count = Comment.objects.filter(node_id=node_id).count()
        self.assertEqual(node_comments_count, len(comments))
        
        # Comments not allowed on layer
        node.layer.participation_settings.comments_allowed = False
        node.layer.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        node.layer.participation_settings.comments_allowed = True
        node.layer.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # Comments not allowed on node
        node.participation_settings.comments_allowed = False
        node.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        node.participation_settings.comments_allowed = True
        node.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # User not allowed -- 403
        self.client.logout()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 403)
    
    def test_ratings_api(self):
        """
        Ratings endpoint should be reachable only with POST and return 404 if object is not found.
        """
        node = Node.objects.get(pk=1)
        node_slug = node.slug
        fake_node_slug = "idontexist"
        node_id = node.id
        layer = Layer.objects.get(pk=node.layer_id)
        
        url = reverse('api_node_ratings', args=[node_slug])
        wrong_url = reverse('api_node_ratings', args=[fake_node_slug])
        
        # api_node_ratings
        
        # GET not allowed -- 405
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 405)
        
        # POST
        
        login = self.client.login(username='admin', password='tester')
        good_post_data = { "value": "5" }
                
        #wrong slug -- 404
        response = self.client.post(wrong_url, good_post_data)
        self.assertEqual(response.status_code, 404)
        
        #wrong POST data (wrong rating) -- 400
        bad_post_data= {"node": 1, "value": "12", "user": 2}
        response = self.client.post(url, bad_post_data)
        self.assertEqual(response.status_code, 400)
        
        #Correct  POST data and correct slug-- 201
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # POST 400 - user rating again fails because 'value' and 'user' are unique_together
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        
        # POST 201 - ensure additional post data "user" and "node" are ignored
        # Tested as a different user or 400 would be returned because 'value' and 'user' are unique_together
        login = self.client.login(username='romano', password='tester')
        bad_post_data = { "node": 100, "value": "10", "user": 2 }
        response = self.client.post(url, bad_post_data)
        self.assertEqual(response.status_code, 201)
        ratings_dict = json.loads(response.content)
        self.assertEqual(ratings_dict['user'], 4)
        self.assertEqual(ratings_dict['node'], 1)
        self.assertEqual(ratings_dict['value'], 10)
        
        # Rating not allowed on layer 
        # Tested as a different user or 400 would be returned because 'value' and 'user' are unique_together
        self.client.logout()
        login = self.client.login(username='pisano', password='tester')
        node.layer.participation_settings.rating_allowed = False
        node.layer.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        node.layer.participation_settings.rating_allowed = True
        node.layer.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # Rating not allowed on node
        # Tested as a different user or 400 would be returned because 'value' and 'user' are unique_together
        self.client.logout()
        login = self.client.login(username='viterbese', password='tester')
        node.participation_settings.rating_allowed = False
        node.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        node.participation_settings.rating_allowed = True
        node.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        #User not allowed -- 403
        self.client.logout()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 403)
        
    def test_votes_api(self):    
        """
        Vote endpoint should be reachable only with POST and return 404 if object is not found.
        """
      
        node = Node.objects.get(pk=1)
        node_slug = node.slug
        fake_node_slug = "idontexist"
        node_id = node.id
        layer = Layer.objects.get(pk=node.layer_id)
        
        url = reverse('api_node_votes', args=[node_slug])
        wrong_url = reverse('api_node_votes', args=[fake_node_slug])
        
        # api_node_votes
        
        # GET not allowed -- 405
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 405)
        
        # POST
        
        login=self.client.login(username='admin', password='tester')
        good_post_data= { "vote": "1" }
        
        # wrong slug -- 404
        response = self.client.post(wrong_url, good_post_data)
        self.assertEqual(response.status_code, 404)
        
        # wrong POST data (wrong vote) -- 400
        bad_post_data= { "vote": "3" }
        response = self.client.post(url, bad_post_data)
        self.assertEqual(response.status_code, 400)
        
        # Correct  POST data and correct slug -- 201
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # POST 400 - repeating the same vote fails because unique_together
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        
        # POST 400 - repeating the same vote trying to change user and node fails
        # cos node and user params are ignored, so the system returns 400 because
        # this user has already voted that node
        bad_post_data = { "node": 100, "vote": "1", "user": 3 }
        response = self.client.post(url, bad_post_data)
        self.assertEqual(response.status_code, 400)
        
        # POST 201 - ensure additional post data "user" and "node" are ignored
        response = self.client.post(reverse('api_node_votes', args=['eigenlab']), bad_post_data)
        self.assertEqual(response.status_code, 201)
        votes_dict = json.loads(response.content)
        self.assertEqual(votes_dict['user'], 1)
        self.assertEqual(votes_dict['node'], 2)
        self.assertEqual(votes_dict['vote'], 1)
        
        url = reverse('api_node_votes', args=['tulug'])
        node = Node.objects.get(slug='tulug')
        
        # Voting not allowed on layer
        node.layer.participation_settings.voting_allowed = False
        node.layer.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        node.layer.participation_settings.voting_allowed = True
        node.layer.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # delete last vote
        vote = Vote.objects.all().order_by('-id')[0]
        vote.delete()
        
        # Voting not allowed on node
        node.participation_settings.voting_allowed = False
        node.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 400)
        node.participation_settings.voting_allowed = True
        node.participation_settings.save()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 201)
        
        # User not allowed -- 403
        self.client.logout()
        response = self.client.post(url, good_post_data)
        self.assertEqual(response.status_code, 403)
        
    def test_layer_comments_api(self, *args,**kwargs):
        """
        Layer comments endpoint should be reachable only with GET and return 404 if object is not found.
        """
        layer = Layer.objects.get(pk=1)
        layer_slug = layer.slug
        fake_layer_slug = "idontexist"
        url = reverse('api_layer_nodes_comments', args=[layer_slug])
        wrong_url = reverse('api_layer_nodes_comments', args=[fake_layer_slug])
        
        # api_layer_nodes_comments
        
        # GET
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        response = self.client.get(wrong_url)
        self.assertEqual(response.status_code, 404)
        
        # POST not allowed -- 405
        
        login=self.client.login(username='admin', password='tester')
        response = self.client.post(url)
        self.assertEqual(response.status_code, 405) 
        
    def test_layer_participation_api(self, *args,**kwargs):
        """
        Layer participation endpoint should be reachable only with GET and return 404 if object is not found.
        """
        layer = Layer.objects.get(pk=1)
        layer_slug = layer.slug
        fake_layer_slug = "idontexist"
        url = reverse('api_layer_nodes_participation', args=[layer_slug])
        wrong_url = reverse('api_layer_nodes_participation', args=[fake_layer_slug])
        
        # api_layer_nodes_participation
        
        # GET
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        response = self.client.get(wrong_url)
        self.assertEqual(response.status_code, 404)
        
        # POST not allowed -- 405
        
        login=self.client.login(username='admin', password='tester')
        response = self.client.post(url)
        self.assertEqual(response.status_code, 405)   
        
    def test_node_participation_api(self):
        """
        Participation endpoint should be reachable only with GET and return 404 if object is not found.
        """
        node = Node.objects.get(pk=1)
        node_slug = node.slug
        fake_node_slug = "idontexist"
        url = reverse('api_node_participation', args=[node_slug])
        wrong_url = reverse('api_node_participation', args=[fake_node_slug])
        
        # api_node_participation
        
        # GET
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        participation_dict = json.loads(response.content)
        likes_count=node.noderatingcount.likes
        dislikes_count=node.noderatingcount.dislikes
        comment_count=node.noderatingcount.comment_count
        rating_count=node.noderatingcount.rating_count
        rating_avg=node.noderatingcount.rating_avg
        self.assertEqual(participation_dict['participation']['likes'], likes_count)
        self.assertEqual(participation_dict['participation']['dislikes'], dislikes_count)
        self.assertEqual(participation_dict['participation']['comment_count'], comment_count)
        self.assertEqual(participation_dict['participation']['rating_count'], rating_count)
        self.assertEqual(participation_dict['participation']['rating_avg'], rating_avg)
        response = self.client.get(wrong_url)
        self.assertEqual(response.status_code, 404)
        
        # POST not allowed -- 405
        
        login=self.client.login(username='admin', password='tester')
        response = self.client.post(url)
        self.assertEqual(response.status_code, 405)
    
    def test_has_already_voted_on_node(self):
        node = Node.objects.get(pk=1)
        url = reverse('api_node_details', args=[node.slug])
        
        # logged out expects False
        self.client.logout()
        response = self.client.get(url)
        self.assertEqual(response.data['relationships']['has_already_voted'], False)
        
        # logged in not voted yet expects False
        self.client.login(username='admin', password='tester')
        response = self.client.get(url)
        self.assertEqual(response.data['relationships']['has_already_voted'], False)
        
        # has already liked expects 1
        v = Vote.objects.create(node_id=node.id, user_id=1, vote=1)
        response = self.client.get(url)
        self.assertEqual(response.data['relationships']['has_already_voted'], 1)
        
        # has already disliked expects -1
        v.delete()
        v = Vote.objects.create(node_id=node.id, user_id=1, vote=-1)
        response = self.client.get(url)
        self.assertEqual(response.data['relationships']['has_already_voted'], -1)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.community.participation.views',
    url(r'^layers/(?P<slug>[-\w]+)/comments/$', 'layer_nodes_comments', name='api_layer_nodes_comments'),
    url(r'^layers/(?P<slug>[-\w]+)/participation/$', 'layer_nodes_participation', name='api_layer_nodes_participation'),
    url(r'^comments/$', 'all_nodes_comments', name='api_all_nodes_comments'),
    url(r'^participation/$','all_nodes_participation', name='api_all_nodes_participation'),
    url(r'^nodes/(?P<slug>[-\w]+)/comments/$', 'node_comments',name='api_node_comments'),
    url(r'^nodes/(?P<slug>[-\w]+)/ratings/$', 'node_ratings',name='api_node_ratings'),
    url(r'^nodes/(?P<slug>[-\w]+)/votes/$', 'node_votes',name='api_node_votes'),
    url(r'^nodes/(?P<slug>[-\w]+)/participation/$', 'node_participation', name= 'api_node_participation'),
    url(r'^nodes/(?P<slug>[-\w]+)/participation_settings/$', 'node_participation_settings', name= 'api_node_participation_settings'),
    url(r'^layers/(?P<slug>[-\w]+)/participation_settings/$', 'layer_participation_settings', name= 'api_layer_participation_settings'),
)

########NEW FILE########
__FILENAME__ = views
from django.http import Http404
from django.utils.translation import ugettext_lazy as _
from django.contrib.auth import get_user_model
User = get_user_model()

from rest_framework import permissions, authentication, generics

from .models import Rating, Vote, Comment
from .serializers import *

from nodeshot.core.base.mixins import CustomDataMixin
from nodeshot.core.nodes.models import Node
from nodeshot.core.layers.models import Layer


def get_queryset_or_404(queryset, kwargs):
    """
    Checks if object returned by queryset exists
    """
    # ensure exists
    try:
        obj = queryset.get(**kwargs)
    except Exception:
        raise Http404(_('Not found'))
    
    return obj

    
class AllNodesParticipationList(generics.ListAPIView):
    """
    Retrieve participation details for all nodes
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    model = Node
    serializer_class= NodeParticipationSerializer
    pagination_serializer_class = PaginationSerializer
    paginate_by_param = 'limit'
    paginate_by = 10

all_nodes_participation= AllNodesParticipationList.as_view()


class AllNodesCommentList(generics.ListAPIView):
    """
    Retrieve comments  for all nodes
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    model = Node
    serializer_class= NodeCommentSerializer
    pagination_serializer_class = PaginationSerializer
    paginate_by_param = 'limit'
    paginate_by = 10
    
all_nodes_comments= AllNodesCommentList.as_view()

 
class LayerNodesCommentList(generics.ListAPIView):
    """
    Retrieve comments  for all nodes of a layer
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    model = Node
    serializer_class= NodeCommentSerializer
    
    def get(self, request, *args, **kwargs):
        """
        Get comments of specified existing layer
        or otherwise return 404
        """
        # ensure layer exists
        layer = get_queryset_or_404(Layer.objects.published(), { 'slug': self.kwargs.get('slug', None) })
        
        # Get queryset of nodes related to layer
        self.queryset = Node.objects.published().filter(layer_id=layer.id)
        
        return self.list(request, *args, **kwargs)

layer_nodes_comments= LayerNodesCommentList.as_view()


class LayerNodesParticipationList(generics.ListAPIView):
    """
    Retrieve participation details for all nodes of a layer
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    model = Node
    serializer_class= NodeParticipationSerializer
    
    def get(self,request,*args,**kwargs):
        """
        Get comments of specified existing layer
        or otherwise return 404
        """
        # ensure layer exists
        layer = get_queryset_or_404(Layer.objects.published(), { 'slug': self.kwargs.get('slug', None) })
        
        # Get queryset of nodes related to layer
        self.queryset = Node.objects.published().filter(layer_id=layer.id)
        
        return self.list(request, *args, **kwargs)
    
layer_nodes_participation= LayerNodesParticipationList.as_view()


class NodeParticipationDetail(generics.RetrieveAPIView):
    """
    Retrieve participation details for a node
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    model = Node
    serializer_class = NodeParticipationSerializer
    
node_participation = NodeParticipationDetail.as_view()


class NodeParticipationSettingsDetail(generics.RetrieveAPIView):
    """
    Retrieve participation settings for a node
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    model = Node
    serializer_class = NodeParticipationSettingsSerializer
    
node_participation_settings = NodeParticipationSettingsDetail.as_view()


class LayerParticipationSettingsDetail(generics.RetrieveAPIView):
    """
    Retrieve participation settings for a layer
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    model = Layer
    serializer_class = LayerParticipationSettingsSerializer
    
layer_participation_settings = LayerParticipationSettingsDetail.as_view() 


class NodeCommentList(CustomDataMixin, generics.ListCreateAPIView):
    """
    Retrieve a **list** of comments for the specified node
    
    ### POST
    
    Add a comment to the specified node
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    serializer_class = CommentListSerializer
    serializer_custom_class = CommentAddSerializer
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'node': self.node.id,
            'user': self.request.user.id
        }
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure node exists and store it in an instance attribute
            * change queryset to return only comments of current node
        """
        super(NodeCommentList, self).initial(request, *args, **kwargs)
        
        # ensure node exists
        self.node = get_queryset_or_404(Node.objects.published(), { 'slug': self.kwargs.get('slug', None) })
        
        # return only comments of current node
        self.queryset = Comment.objects.filter(node_id=self.node.id)
    
node_comments = NodeCommentList.as_view()    


class NodeRatingList(CustomDataMixin, generics.CreateAPIView):
    """
    Not allowed
    
    ### POST
    
    Add a rating for the specified node
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    serializer_class = RatingListSerializer
    serializer_custom_class = RatingAddSerializer
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'node': self.node.id,
            'user': self.request.user.id
        }
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure node exists and store it in an instance attribute
            * change queryset to return only comments of current node
        """
        super(NodeRatingList, self).initial(request, *args, **kwargs)
        
        # ensure node exists
        self.node = get_queryset_or_404(Node.objects.published(), { 'slug': self.kwargs.get('slug', None) })
        
        # return only comments of current node
        self.queryset = Rating.objects.filter(node_id=self.node.id)
    
node_ratings = NodeRatingList.as_view() 


class NodeVotesList(CustomDataMixin, generics.CreateAPIView):
    """
    Add a vote for the specified node
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    serializer_class = VoteListSerializer
    serializer_custom_class = VoteAddSerializer
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'node': self.node.id,
            'user': self.request.user.id
        }
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure node exists and store it in an instance attribute
            * change queryset to return only comments of current node
        """
        super(NodeVotesList, self).initial(request, *args, **kwargs)
        
        # ensure node exists
        self.node = get_queryset_or_404(Node.objects.published(), { 'slug': self.kwargs.get('slug', None) })
        
        # return only comments of current node
        self.queryset = Vote.objects.filter(node_id=self.node.id)

node_votes = NodeVotesList.as_view()

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin as BaseUserAdmin
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from django.contrib.auth.forms import UserChangeForm as BaseChangeForm
from django.contrib.auth.forms import UserCreationForm as BaseCreationForm
from django.contrib.auth.forms import AdminPasswordChangeForm as BasePasswordChangeForm
from django.forms import ValidationError

from nodeshot.core.base.admin import BaseStackedInline
from .models import SocialLink, Profile, PasswordReset


# --- User management forms --- #


class UserChangeForm(BaseChangeForm):
    class Meta:
        model = Profile


class UserCreationForm(BaseCreationForm):
    
    # this happens to be needed, at least in django 1.6.2
    # http://stackoverflow.com/questions/16953302/django-custom-user-model-in-admin-relation-auth-user-does-not-exist
    def clean_username(self):
        username = self.cleaned_data["username"]
        try:
            Profile.objects.get(username=username)
        except Profile.DoesNotExist:
            return username
        raise ValidationError(self.error_messages['duplicate_username'])
    
    class Meta:
        model = Profile


class AdminPasswordChangeForm(BasePasswordChangeForm):
    class Meta:
        model = Profile


# --- Admin --- #


class ProfileSocialLinksInline(BaseStackedInline):
    model = SocialLink
    extra = 0

USER_ADMIN_INLINES = [ProfileSocialLinksInline]


if 'social_auth' in settings.INSTALLED_APPS:
    from social_auth.models import UserSocialAuth
    
    class SocialAuthInline(admin.StackedInline):
        model = UserSocialAuth
        extra = 0
    
    USER_ADMIN_INLINES.append(SocialAuthInline)


class UserAdmin(BaseUserAdmin):
    list_display = (
        'username',
        'email',
        'first_name',
        'last_name',
        'is_active',
        'date_joined',
        'last_login',
        'is_staff',
        'is_superuser'
    )
    inlines = USER_ADMIN_INLINES
    ordering = ['-is_staff', '-date_joined']
    search_fields = ('email', 'username', 'first_name', 'last_name')
    list_filter = ('is_active', 'is_staff', 'is_superuser')
    
    form = UserChangeForm
    add_form = UserCreationForm
    change_password_form = AdminPasswordChangeForm
    
    fieldsets = [
        [None, {'fields': ('username', 'password')}],
        [_('Personal info'), {'fields': [
            'first_name', 'last_name', 'email',
            'birth_date', 'address', 'city', 'country',
            'gender', 'about'
        ]}],
        [_('Permissions'), {'fields': ('is_active', 'is_staff', 'is_superuser',
                                       'groups', 'user_permissions')}],
        [_('Important dates'), {'fields': ('last_login', 'date_joined')}],
    ]


if settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True):
    from emailconfirmation.models import EmailAddress
    
    class EmailAddressInline(admin.StackedInline):
        model = EmailAddress
        extra = 0
    
    UserAdmin.inlines = [EmailAddressInline] + UserAdmin.inlines
    UserAdmin.fieldsets[1][1]['fields'].remove('email')


class PasswordResetAdmin(admin.ModelAdmin):
    pass
    list_display = ('user', 'timestamp', 'reset', 'temp_key')


admin.site.register(Profile, UserAdmin)
admin.site.register(PasswordReset, PasswordResetAdmin)
########NEW FILE########
__FILENAME__ = backends
from django.contrib.auth.backends import ModelBackend
from django.contrib.auth import get_user_model


class EmailBackend(ModelBackend):
    """
    Authenticates against user email.
    """

    def authenticate(self, username=None, password=None, **kwargs):
        UserModel = get_user_model()
        try:
            user = UserModel.objects.get(email=username)
            if user.check_password(password):
                return user
        except UserModel.DoesNotExist:
            return None
########NEW FILE########
__FILENAME__ = forms
from django import forms
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from django.contrib.auth import get_user_model
User = get_user_model()

from .models import PasswordReset

PROFILE_EMAIL_CONFIRMATION = settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True)

if PROFILE_EMAIL_CONFIRMATION:
    from emailconfirmation.models import EmailAddress


__all__ = [
    'ResetPasswordForm',
    'ResetPasswordKeyForm'
]


class ResetPasswordForm(forms.Form):
    
    email = forms.EmailField(
        label = _("Email"),
        required = True,
        widget = forms.TextInput(attrs={"size":"30"})
    )
    
    def clean_email(self):
        """ ensure email is in the database """
        if PROFILE_EMAIL_CONFIRMATION:
            condition = EmailAddress.objects.filter(email__iexact=self.cleaned_data["email"], verified=True).count() == 0
        else:
            condition = User.objects.get(email__iexact=self.cleaned_data["email"], is_active=True).count() == 0
        
        if condition is True:
            raise forms.ValidationError(_("Email address not verified for any user account"))
        
        return self.cleaned_data["email"]
    
    def save(self, **kwargs):
        PasswordReset.objects.create_for_user(self.cleaned_dat["email"])
        return self.cleaned_data["email"]


class ResetPasswordKeyForm(forms.Form):
    
    password1 = forms.CharField(
        label = _("New Password"),
        widget = forms.PasswordInput(render_value=False)
    )
    password2 = forms.CharField(
        label = _("New Password (again)"),
        widget = forms.PasswordInput(render_value=False)
    )
    
    def __init__(self, *args, **kwargs):
        self.user = kwargs.pop("user", None)
        self.temp_key = kwargs.pop("temp_key", None)
        super(ResetPasswordKeyForm, self).__init__(*args, **kwargs)
    
    def clean_password2(self):
        if "password1" in self.cleaned_data and "password2" in self.cleaned_data:
            if self.cleaned_data["password1"] != self.cleaned_data["password2"]:
                raise forms.ValidationError(_("Password confirmation mismatch."))
        return self.cleaned_data["password2"]
    
    def save(self):
        # set the new user password
        user = self.user
        user.set_password(self.cleaned_data["password1"])
        user.save()
        # mark password reset object as reset
        PasswordReset.objects.filter(temp_key=self.temp_key).update(reset=True)
########NEW FILE########
__FILENAME__ = html_views
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.http import Http404
from django.shortcuts import render_to_response, get_object_or_404, redirect
from django.template import RequestContext
from django.utils.http import base36_to_int
from django.utils.translation import ugettext
from django.contrib import messages
from django.contrib.auth.tokens import default_token_generator
from django.contrib.auth import get_user_model
User = get_user_model()

from .forms import ResetPasswordKeyForm


def group_and_bridge(kwargs):
    """
    Given kwargs from the view (with view specific keys popped) pull out the
    bridge and fetch group from database.
    """
    
    bridge = kwargs.pop("bridge", None)
    
    if bridge:
        try:
            group = bridge.get_group(**kwargs)
        except ObjectDoesNotExist:
            raise Http404
    else:
        group = None
    
    return group, bridge


def group_context(group, bridge):
    # @@@ use bridge
    return {
        "group": group,
    }


def password_reset_from_key(request, uidb36, key, **kwargs):
    
    form_class = kwargs.get("form_class", ResetPasswordKeyForm)
    template_name = kwargs.get("template_name", "profiles/password_reset_from_key.html")
    token_generator = kwargs.get("token_generator", default_token_generator)
    
    group, bridge = group_and_bridge(kwargs)
    ctx = group_context(group, bridge)
    
    # pull out user
    try:
        uid_int = base36_to_int(uidb36)
    except ValueError:
        raise Http404
    
    user = get_object_or_404(User, id=uid_int)
    
    if token_generator.check_token(user, key):
        if request.method == "POST":
            password_reset_key_form = form_class(request.POST, user=user, temp_key=key)
            if password_reset_key_form.is_valid():
                password_reset_key_form.save()
                messages.add_message(request, messages.SUCCESS,
                    ugettext(u"Password successfully changed.")
                )
                password_reset_key_form = None
        else:
            password_reset_key_form = form_class()
        ctx.update({
            "form": password_reset_key_form,
        })
    else:
        ctx.update({
            "token_fail": True,
        })
    
    return render_to_response(template_name, RequestContext(request, ctx))


if settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True):

    from emailconfirmation.models import EmailConfirmation, EmailAddress
    from django.contrib.auth import login
    
    def confirm_email(request, confirmation_key):
        """ confirm email view """
        confirmation_key = confirmation_key.lower()
        
        # get email confirmation or 404
        email_confirmation = get_object_or_404(EmailConfirmation, key=confirmation_key)
        
        # make primary if no other primary addresses for this user
        make_primary = EmailAddress.objects.filter(user_id=email_confirmation.email_address.user_id, primary=True).count() <= 0
        
        # confirm email
        email_address = EmailConfirmation.objects.confirm_email(confirmation_key, make_primary=make_primary)
        
        # log in the user if not already authenticated
        if not request.user.is_authenticated():
            user = email_address.user
            user.backend = 'django.contrib.auth.backends.ModelBackend'
            login(request, user)
        
        return redirect(settings.SITE_URL)

########NEW FILE########
__FILENAME__ = password_reset
from django.db import models
from django.conf import settings
from django.utils.translation import gettext_lazy as _

from django.utils.http import int_to_base36
from django.contrib.sites.models import Site
from django.template.loader import render_to_string
from django.core.mail import send_mail
from django.contrib.auth.tokens import default_token_generator as token_generator

from nodeshot.core.base.utils import now

from .profile import Profile as User


class PasswordResetManager(models.Manager):
    """ Password Reset Manager """
    
    def create_for_user(self, user):
        """ create password reset for specified user """
        # support passing email address too
        if type(user) is unicode:
            user = User.objects.get(email=user)
        
        temp_key = token_generator.make_token(user)
            
        # save it to the password reset model
        password_reset = PasswordReset(user=user, temp_key=temp_key)
        password_reset.save()
        
        current_site = Site.objects.get_current()
        domain = unicode(current_site.domain)
        
        # send the password reset email
        subject = _("Password reset email sent")
        message = render_to_string("profiles/email_messages/password_reset_key_message.txt", {
            "user": user,
            "uid": int_to_base36(user.id),
            "temp_key": temp_key,
            "domain": domain,
        })
        send_mail(subject, message, settings.DEFAULT_FROM_EMAIL, [user.email])
        
        return password_reset


class PasswordReset(models.Model):
    """
    Password reset Key
    """
    user = models.ForeignKey(User, verbose_name=_("user"))
    
    temp_key = models.CharField(_("temp_key"), max_length=100)
    timestamp = models.DateTimeField(_("timestamp"), default=now)
    reset = models.BooleanField(_("reset yet?"), default=False)
    
    objects = PasswordResetManager()
    
    class Meta:
        verbose_name = _('password reset')
        verbose_name_plural = _('password resets')
        app_label = 'profiles'
    
    def __unicode__(self):
        return "%s (key=%s, reset=%r)" % (
            self.user.username,
            self.temp_key,
            self.reset
        )
########NEW FILE########
__FILENAME__ = profile
from django.db import models
from django.core import validators
from django.core.mail import send_mail
from django.contrib.auth.models import AbstractBaseUser, PermissionsMixin, UserManager
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from nodeshot.core.base.utils import now
from ..signals import password_changed

import re


SEX_CHOICES = (
    ('M', _('male')),
    ('F', _('female'))
)


class Profile(AbstractBaseUser, PermissionsMixin):
    """
    User Profile Model
    Contains personal info of a user
    """
    # 254 maximum character for username makes it possible
    username = models.CharField(
        _('username'),
        max_length=254,
        unique=True,
        db_index=True,
        help_text=_('Required. 30 characters or fewer.\
                    Letters, numbers and @/./+/-/_ characters'),
        validators=[
            validators.RegexValidator(
                re.compile('^[\w.@+-]+$'),
                _('Enter a valid username.'),
                'invalid'
            )
        ]
    )
    email = models.EmailField(_('primary email address'), blank=True, unique=True, db_index=True)
    first_name = models.CharField(_('first name'), max_length=30, blank=True)
    last_name = models.CharField(_('last name'), max_length=30, blank=True)
    
    # added fields
    about = models.TextField(_('about me'), blank=True)
    gender = models.CharField(_('gender'), max_length=1, choices=SEX_CHOICES, blank=True)
    birth_date = models.DateField(_('birth date'), blank=True, null=True)
    address = models.CharField(_('address'), max_length=150, blank=True)
    city = models.CharField(_('city'), max_length=30, blank=True)
    country = models.CharField(_('country'), max_length=30, blank=True)
    
    is_staff = models.BooleanField(_('staff status'), default=False,
                                   help_text=_('Designates whether the user can log into this admin site.'))
    is_active = models.BooleanField(
        _('active'),
        default=True,
        help_text=_('Designates whether this user should be treated as active.\
                    Unselect this instead of deleting accounts.')
    )
    date_joined = models.DateTimeField(_('date joined'), default=now)

    objects = UserManager()

    USERNAME_FIELD = 'username'
    REQUIRED_FIELDS = settings.NODESHOT['SETTINGS'].get('PROFILE_REQUIRED_FIELDS', ['email'])

    class Meta:
        verbose_name = _('user')
        verbose_name_plural = _('users')
        app_label = 'profiles'
    
    def __unicode__(self):
        return self.username
    
    def save(self, *args, **kwargs):
        """ ensure instance has usable password when created """
        if not self.pk and self.has_usable_password() is False:
            self.set_password(self.password)
        
        super(Profile, self).save(*args, **kwargs)

    def get_full_name(self):
        """
        Returns the first_name plus the last_name, with a space in between.
        """
        full_name = '%s %s' % (self.first_name, self.last_name)
        return full_name.strip()

    def get_short_name(self):
        "Returns the short name for the user."
        return self.first_name

    def email_user(self, subject, message, from_email=None):
        """
        Sends an email to this User.
        """
        send_mail(subject, message, from_email, [self.email])
    
    def add_email(self):
        """
        Add email to DB and sends a confirmation mail if PROFILE_EMAL_CONFIRMATION is True
        """
        if settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True):
            from emailconfirmation.models import EmailAddress
            self.is_active = False
            self.save()
            EmailAddress.objects.add_email(self, self.email)
            return True
        else:
            return False
    
    def change_password(self, new_password):
        """
        Changes password and sends a signal
        """
        self.set_password(new_password)
        self.save()
        password_changed.send(sender=self.__class__, user=self)
    
    if 'grappelli' in settings.INSTALLED_APPS:
        @staticmethod
        def autocomplete_search_fields():
            return (
                'username__icontains',
                'first_name__icontains',
                'last_name__icontains',
                'email__icontains'
            )

########NEW FILE########
__FILENAME__ = social_link
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from . import Profile


class SocialLink(BaseDate):
    """
    External links like website or social network profiles
    """
    user = models.ForeignKey(Profile, verbose_name=_('user'))
    url = models.URLField(_('url'))
    description = models.CharField(_('description'), max_length=128, blank=True)
    
    class Meta:
        app_label = 'profiles'
        db_table = 'profiles_social_links'
        unique_together = ('user', 'url')
    
    def __unicode__(self):
        return self.url

########NEW FILE########
__FILENAME__ = permissions
from rest_framework import permissions
from .models import Profile


__all__ = [
    'IsProfileOwner',
    'IsNotAuthenticated'
]


class IsProfileOwner(permissions.IsAuthenticated):
    """
    Restrict edit to owners only
    """
    def has_object_permission(self, request, view, obj=None):
        # in edit request restrict permission to profile owner only
        if (request.method in ['PUT', 'PATCH']) and obj is not None:
            model = obj.__class__.__name__
            
            user_id = obj.id
            
            # in case of social link view
            if model == 'SocialLink':
                user_id = obj.user.id
            
            return request.user.id == user_id
        else:
            return True
    
    def has_permission(self, request, view):
        """ applies to social-link-list """
        if request.method == 'POST':
            user = Profile.objects.only('id', 'username').get(username=view.kwargs['username'])
            return request.user.id == user.id
        
        return True


class IsNotAuthenticated(permissions.IsAuthenticated):
    """
    Restrict access only to unauthenticated users.
    """
    def has_permission(self, request, view, obj=None):
        if request.user and request.user.is_authenticated():
            return False
        else:
            return True
########NEW FILE########
__FILENAME__ = serializers
import hashlib

from django.utils.translation import ugettext_lazy as _
from django.contrib.auth import authenticate
from django.conf import settings

from rest_framework import serializers
from rest_framework.reverse import reverse

from nodeshot.core.base.serializers import ExtraFieldSerializer, HyperlinkedField
from .models import Profile as User
from .models import PasswordReset, SocialLink

PROFILE_EMAIL_CONFIRMATION = settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True)
PASSWORD_MAX_LENGTH = User._meta.get_field('password').max_length
NOTIFICATIONS_INSTALLED = 'nodeshot.community.notifications' in settings.INSTALLED_APPS

if PROFILE_EMAIL_CONFIRMATION:
    from emailconfirmation.models import EmailAddress


__all__ = [
    'LoginSerializer',
    'ProfileSerializer',
    'ProfileCreateSerializer',
    'ProfileRelationSerializer',
    'AccountSerializer',
    'ChangePasswordSerializer',
    'ResetPasswordSerializer',
    'ResetPasswordKeySerializer',
    'SocialLinkSerializer',
    'SocialLinkAddSerializer'
]


class LoginSerializer(serializers.Serializer):
    username = serializers.CharField(max_length=User._meta.get_field('username').max_length)
    password = serializers.CharField(max_length=PASSWORD_MAX_LENGTH)
    remember = serializers.BooleanField(default=True, help_text = _("If checked you will stay logged in for 3 weeks"))
    
    def user_credentials(self, attrs):
        """
        Provides the credentials required to authenticate the user for login.
        """
        credentials = {}
        credentials["username"] = attrs["username"]
        credentials["password"] = attrs["password"]
        return credentials
    
    def validate(self, attrs):
        """ checks if login credentials are correct """
        user = authenticate(**self.user_credentials(attrs))
        
        if user:
            if user.is_active:
                self.instance = user
            else:
                raise serializers.ValidationError(_("This account is currently inactive."))
        else:
            error = _("Ivalid login credentials.")
            raise serializers.ValidationError(error)
        return attrs


class SocialLinkSerializer(serializers.ModelSerializer):
    user = serializers.Field(source='user.username')
    details = serializers.SerializerMethodField('get_detail_url')
    
    def get_detail_url(self, obj):
        """ return detail url """
        request = self.context.get('request', None)
        format = self.context.get('format', None)
        args = [obj.user.username, obj.pk]
        return reverse('api_user_social_links_detail', args=args, request=request, format=format)
    
    class Meta:
        model = SocialLink
        fields = ('id', 'user', 'url', 'description', 'added', 'updated', 'details')
        read_only_fields = ('added', 'updated',)


class SocialLinkAddSerializer(serializers.ModelSerializer):
    class Meta:
        model = SocialLink
        read_only_fields = ('added', 'updated', )


class ProfileSerializer(serializers.ModelSerializer):
    """ Profile Serializer for visualization """
    details = serializers.HyperlinkedIdentityField(lookup_field='username', view_name='api_profile_detail')
    avatar = serializers.SerializerMethodField('get_avatar')
    full_name = serializers.SerializerMethodField('get_full_name')
    location = serializers.SerializerMethodField('get_location')
    social_links_url = serializers.HyperlinkedIdentityField(lookup_field='username', view_name='api_user_social_links_list')
    social_links = SocialLinkSerializer(source='sociallink_set', many=True, read_only=True)
    
    if 'nodeshot.core.nodes' in settings.INSTALLED_APPS:
        nodes = serializers.HyperlinkedIdentityField(view_name='api_user_nodes', slug_field='username')
    
    def get_avatar(self, obj):
        """ avatar from gravatar.com """
        return 'http://www.gravatar.com/avatar/%s' % hashlib.md5(obj.email).hexdigest()
    
    def get_full_name(self, obj):
        """ user's full name """
        return obj.get_full_name()
    
    def get_location(self, obj):
        """ return user's location """
        if not obj.city and not obj.country:
            return None
        elif obj.city and obj.country:
            return '%s, %s' % (obj.city, obj.country)
        elif obj.city or obj.country:
            return obj.city or obj.country
    
    class Meta:
        model = User
        fields = [
            'details', 'id',
            'username', 'full_name', 'first_name', 'last_name',
            'about', 'gender', 'birth_date', 'address', 'city',
            'country', 'location',
            'date_joined', 'last_login', 'avatar',
        ]
        
        if 'nodeshot.core.nodes' in settings.INSTALLED_APPS:
            fields.append('nodes')
            
        fields += ['social_links_url', 'social_links']
            
        read_only_fields = (
            'username',
            'date_joined',
            'last_login'
        )


class ProfileCreateSerializer(ExtraFieldSerializer):
    """ Profile Serializer for User Creation """
    password_confirmation = serializers.CharField(label=_('password_confirmation'),
                                                  max_length=PASSWORD_MAX_LENGTH)
    email = serializers.CharField(source='email', required='email' in User.REQUIRED_FIELDS)
    
    def validate_password_confirmation(self, attrs, source):
        """
        password_confirmation check
        """
        password_confirmation = attrs[source]
        password = attrs['password']
        
        if password_confirmation != password:
            raise serializers.ValidationError(_('Password confirmation mismatch'))
        
        return attrs
    
    class Meta:
        model = User
        fields = (
            'id',
            # required
            'username', 'email', 'password', 'password_confirmation',
            # optional
            'first_name', 'last_name', 'about', 'gender',
            'birth_date', 'address', 'city', 'country'
        )
        non_native_fields = ('password_confirmation', )


class ProfileRelationSerializer(ProfileSerializer):
    """ Profile Serializer used for linking """
    class Meta:
        model = User
        fields = ('id', 'username', 'full_name', 'city', 'country', 'avatar', 'details')


# ------ Add user info to ExtensibleNodeSerializer ------ #

from nodeshot.core.nodes.base import ExtensibleNodeSerializer

ExtensibleNodeSerializer.add_relationship(
    name='user',
    serializer=ProfileRelationSerializer,
    queryset='obj.user'
)


class AccountSerializer(serializers.ModelSerializer):
    """ Account serializer """
    profile = serializers.HyperlinkedIdentityField(
        lookup_field='username',
        view_name='api_profile_detail'
    )
    social_links = serializers.HyperlinkedIdentityField(
        lookup_field='username',
        view_name='api_user_social_links_list'
    )
    change_password = HyperlinkedField(
        view_name='api_account_password_change'
    )
    logout = HyperlinkedField(view_name='api_account_logout')
    
    if PROFILE_EMAIL_CONFIRMATION:
        email_addresses = HyperlinkedField(view_name='api_account_email_list')
    
    if NOTIFICATIONS_INSTALLED:
        web_notification_settings = HyperlinkedField(
            view_name='api_notification_web_settings'
        )
        email_notification_settings = HyperlinkedField(
            view_name='api_notification_email_settings'
        )
    
    class Meta:
        model = User
        fields = ['profile', 'social_links', 'change_password', 'logout']
        
        if PROFILE_EMAIL_CONFIRMATION:
            fields += ['email_addresses']
        
        if NOTIFICATIONS_INSTALLED:
            fields += ['web_notification_settings', 'email_notification_settings']


class ChangePasswordSerializer(serializers.Serializer):
    """
    Change password serializer
    """
    current_password = serializers.CharField(
        help_text=_('Current Password'),
        max_length=PASSWORD_MAX_LENGTH,
        required=False  # optional because users subscribed from social network won't have a password set
    )
    password1 = serializers.CharField(
        help_text = _('New Password'),
        max_length=PASSWORD_MAX_LENGTH
    )
    password2 = serializers.CharField(
        help_text = _('New Password (confirmation)'),
        max_length=PASSWORD_MAX_LENGTH
    )
    
    def validate_current_password(self, attrs, source):
        """
        current password check
        """
        if self.object.has_usable_password() and not self.object.check_password(attrs.get("current_password")):
            raise serializers.ValidationError(_('Current password is not correct'))
        
        return attrs
    
    def validate_password2(self, attrs, source):
        """
        password_confirmation check
        """
        password_confirmation = attrs[source]
        password = attrs['password1']
        
        if password_confirmation != password:
            raise serializers.ValidationError(_('Password confirmation mismatch'))
        
        return attrs
    
    def restore_object(self, attrs, instance=None):
        """ change password """
        if instance is not None:
            instance.change_password(attrs.get('password2'))
            return instance
        
        return User(**attrs)


class ResetPasswordSerializer(serializers.Serializer):
    email = serializers.EmailField(required = True)
    
    def validate_email(self, attrs, source):
        """ ensure email is in the database """
        if PROFILE_EMAIL_CONFIRMATION:
            condition = EmailAddress.objects.filter(email__iexact=attrs["email"], verified=True).count() == 0
        else:
            condition = User.objects.get(email__iexact=attrs["email"], is_active=True).count() == 0
        
        if condition is True:
            raise serializers.ValidationError(_("Email address not verified for any user account"))
        
        return attrs
    
    def restore_object(self, attrs, instance=None):
        """ create password reset for user """
        password_reset = PasswordReset.objects.create_for_user(attrs["email"])
        
        return password_reset


class ResetPasswordKeySerializer(serializers.Serializer):
    password1 = serializers.CharField(
        help_text = _('New Password'),
        max_length=PASSWORD_MAX_LENGTH
    )
    password2 = serializers.CharField(
        help_text = _('New Password (confirmation)'),
        max_length=PASSWORD_MAX_LENGTH
    )
    
    def validate_password2(self, attrs, source):
        """
        password2 check
        """
        password_confirmation = attrs[source]
        password = attrs['password1']
        
        if password_confirmation != password:
            raise serializers.ValidationError(_('Password confirmation mismatch'))
        
        return attrs
    
    def restore_object(self, attrs, instance):
        """ change password """
        user = instance.user
        user.set_password(attrs["password1"])
        user.save()
        # mark password reset object as reset
        instance.reset = True
        instance.save()
        
        return instance


# email addresses
if PROFILE_EMAIL_CONFIRMATION:
    
    __all__ += [
        'EmailSerializer',
        'EmailAddSerializer',
        'EmailEditSerializer'
    ]
    
    class EmailSerializer(serializers.ModelSerializer):
        details = serializers.HyperlinkedIdentityField(lookup_field='pk', view_name='api_account_email_detail')
        resend_confirmation = serializers.SerializerMethodField('get_resend_confirmation')
    
        def get_resend_confirmation(self, obj):
            """ return resend_confirmation url """
            if obj.verified:
                return False
            request = self.context.get('request', None)
            format = self.context.get('format', None)
            return reverse('api_account_email_resend_confirmation',
                           args=[obj.pk], request=request, format=format)
        
        class Meta:
            model = EmailAddress
            fields = ('id', 'email', 'verified', 'primary', 'details', 'resend_confirmation')
            read_only_fields = ('verified', 'primary')
    
    
    class EmailAddSerializer(serializers.ModelSerializer):
        class Meta:
            model = EmailAddress
            read_only_fields = ('verified', 'primary')
    
    
    class EmailEditSerializer(EmailSerializer):
        def validate_primary(self, attrs, source):
            """
            primary field validation
            """
            primary = attrs[source]
            verified = self.object.verified
            
            if primary is True and verified is False:
                raise serializers.ValidationError(_('Email address cannot be made primary if it is not verified first'))
            
            if primary is False and verified is True:
                primary_addresses = EmailAddress.objects.filter(user=self.object.user, primary=True)
                
                if primary_addresses.count() == 1 and primary_addresses[0].pk == self.object.pk:
                    raise serializers.ValidationError(_('You must have at least one primary address.'))
            
            return attrs
        
        class Meta:
            model = EmailAddress
            fields = ('id', 'email', 'verified', 'primary', 'resend_confirmation')
            read_only_fields = ('verified', 'email')

########NEW FILE########
__FILENAME__ = signals
import django.dispatch


user_logged_in = django.dispatch.Signal(providing_args=["request", "user"])
password_changed = django.dispatch.Signal(providing_args=["user",])
########NEW FILE########
__FILENAME__ = github
"""
Fixed Github Backend for social auth
"""

from social_auth.backends.contrib.github import GithubBackend as BaseGithubBackend,\
                                                GithubAuth


class GithubBackend(BaseGithubBackend):
    """Github OAuth authentication backend"""

    def get_user_details(self, response):
        """Return user details from Github account"""
        name = response.get('name') or ''
        details = {'username': response.get('login')}

        try:
            email = self._fetch_emails(response.get('access_token'))[0]
            if isinstance(email, dict):
                email = email['email']
        except IndexError:
            details['email'] = ''
        else:
            details['email'] = email

        try:
            # GitHub doesn't separate first and last names. Let's try.
            first_name, last_name = name.split(' ', 1)
        except ValueError:
            details['first_name'] = name
        else:
            details['first_name'] = first_name
            details['last_name'] = last_name
        return details


# Backend definition
BACKENDS = {
    'github': GithubAuth,
}

########NEW FILE########
__FILENAME__ = openwisp
"""
OpenWISP OAuth support.
"""
from urllib import urlencode
import simplejson as json

from django.conf import settings
from django.core.exceptions import ImproperlyConfigured

from social_auth.utils import dsa_urlopen
from social_auth.backends import BaseOAuth2, OAuthBackend


# OpenWISP configuration
try:
    OPENWISP_BASE_URL = settings.OPENWISP_BASE_URL
except AttributeError:
    raise ImproperlyConfigured('missing settings.OPENWISP_BASE_URL')

OPENWISP_AUTHORIZATION_URL = '%s/oauth/authorize' % OPENWISP_BASE_URL
OPENWISP_ACCESS_TOKEN_URL = '%s/oauth/access_token' % OPENWISP_BASE_URL
OPENWISP_USER_DATA_URL = '%s/oauth/account_details.json' % OPENWISP_BASE_URL


class OpenWISPBackend(OAuthBackend):
    """OpenWISP OAuth authentication backend"""
    name = 'openwisp'
    # Default extra data to store
    EXTRA_DATA = [
        ('id', 'id'),
        ('expires', 'expires')
    ]

    def get_user_details(self, response):
        """Return user details from OpenWISP account"""
        return {
            'username': response.get('username'),
            'email': response.get('email'),
            'first_name': response.get('first_name'),
            'last_name': response.get('last_name'),
            'birth_date': response.get('birth_date'),
        }



class OpenWISPAuth(BaseOAuth2):
    """OpenWISP OAuth2 mechanism"""
    AUTHORIZATION_URL = OPENWISP_AUTHORIZATION_URL
    ACCESS_TOKEN_URL = OPENWISP_ACCESS_TOKEN_URL
    AUTH_BACKEND = OpenWISPBackend
    SETTINGS_KEY_NAME = 'OPENWISP_APP_ID'
    SETTINGS_SECRET_NAME = 'OPENWISP_API_SECRET'
    SCOPE_SEPARATOR = ','
    SCOPE_VAR_NAME = 'OPENWISP_EXTENDED_PERMISSIONS'

    def user_data(self, access_token, *args, **kwargs):
        """Loads user data from service"""
        url = OPENWISP_USER_DATA_URL + '?' + urlencode({
            'access_token': access_token
        })

        try:
            data = json.load(dsa_urlopen(url))
        except ValueError:
            data = None
        
        return data

# Backend definition
BACKENDS = {
    'openwisp': OpenWISPAuth,
}

########NEW FILE########
__FILENAME__ = pipeline
import requests
import simplejson as json
from datetime import datetime

from django.conf import settings
from social_auth.models import UserSocialAuth

PROFILE_EMAIL_CONFIRMATION = settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True)

if PROFILE_EMAIL_CONFIRMATION:
    from emailconfirmation.models import EmailAddress


def load_extra_data(backend, details, response, uid, user, social_user=None,
                    *args, **kwargs):
    """Load extra data from provider and store it on current UserSocialAuth
    extra_data field.
    """
    social_user = social_user or \
                  UserSocialAuth.get_social_auth(backend.name, uid)
    
    if kwargs['is_new'] and PROFILE_EMAIL_CONFIRMATION:
        emailaddress = EmailAddress(**{
            'user': user,
            'email': user.email,
            'verified': True,
            'primary': True
        })
        emailaddress.save()
    
    if social_user:
        extra_data = backend.extra_data(user, uid, response, details)
        if kwargs.get('original_email') and 'email' not in extra_data:
            extra_data['email'] = kwargs.get('original_email')
        if extra_data and social_user.extra_data != extra_data:
            if social_user.extra_data:
                social_user.extra_data.update(extra_data)
            else:
                social_user.extra_data = extra_data
            social_user.save()
        
        if backend.name == 'facebook' and kwargs['is_new']:
            response = json.loads(requests.get('https://graph.facebook.com/%s?access_token=%s' % (extra_data['id'], extra_data['access_token'])).content)
            
            try:
                user.city, user.country = response.get('hometown').get('name').split(', ')
            except AttributeError:
                pass
            
            try:
                user.birth_date = datetime.strptime(response.get('birthday'), '%m/%d/%Y').date()
            except AttributeError:
                pass
 
            user.save()
        
        return {'social_user': social_user}

########NEW FILE########
__FILENAME__ = tests
"""
ndoeshot.contrib.profiles tests
"""

import simplejson as json

from django.test import TestCase
from django.test.client import Client
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext_lazy as _
from django.utils.http import int_to_base36
from django.core import mail
from django.conf import settings
from django.forms import ValidationError

PROFILE_EMAIL_CONFIRMATION = settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True)
if PROFILE_EMAIL_CONFIRMATION:
    from nodeshot.core.nodes.models import Node
    from emailconfirmation.models import EmailAddress, EmailConfirmation

from .models import Profile as User
from .models import PasswordReset, SocialLink


class ProfilesTest(TestCase):
    fixtures = [
        'initial_data.json',
        'test_profiles.json',
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
    ]
    
    def setUp(self):
        self.fusolab = Node.objects.get(slug='fusolab')
        self.client.login(username='registered', password='tester')
        mail.outbox = []
    
    def test_new_users_have_default_group(self):
        """ users should have a default group when created """
        # ensure owner of node fusolab has at least one group
        self.assertEqual(self.fusolab.user.groups.count(), 1)
        
        # create new user and check if it has any group
        new_user = User(username='new_user_test', email='new_user@testing.com', password='tester', is_active=True)
        new_user.save()
        # retrieve again from DB just in case...
        new_user = User.objects.get(username='new_user_test')
        self.assertEqual(new_user.groups.filter(name='registered').count(), 1)
    
    def test_user_admin(self):
        self.client.logout()
        self.client.login(username='admin', password='tester')
        
        # create new user through admin
        url = reverse('admin:profiles_profile_add')
        with self.assertRaises(ValidationError):
            response = self.client.post(url, {
                'username': 'testing',
                'password': 'password',
                'password2': 'password'
            })
    
    def test_profile_list_API(self):
        """ test new user creation through the API """
        url = reverse('api_profile_list')
        
        un_auth_client = Client()
        
        # GET 401
        response = un_auth_client.get(url)
        self.assertEqual(401, response.status_code)
        
        # GET 200
        response = self.client.get(url)
        self.assertContains(response, 'username')
        self.assertNotContains(response, 'password_confirmation')
        
        # POST 400: missing required field
        self.client.logout()
        new_user = {
            "username": "new_user_test",
            "email": "new_user@testing.com",
            "password": "new_user_test"
        }
        response = self.client.post(url, json.dumps(new_user), content_type='application/json')
        self.assertContains(response, 'password_confirmation', status_code=400)
        
        # POST 400: Password confirmation mismatch
        new_user['password_confirmation'] = 'WRONG'
        response = self.client.post(url, json.dumps(new_user), content_type='application/json')
        self.assertContains(response, _('Password confirmation mismatch'), status_code=400)
        
        # POST 201: Created
        new_user['password_confirmation'] = 'new_user_test'
        response = self.client.post(url, json.dumps(new_user), content_type='application/json')
        self.assertNotContains(response, 'password_confirmation', status_code=201)
        
        user = User.objects.get(username='new_user_test')
        self.assertEqual(user.is_active, not PROFILE_EMAIL_CONFIRMATION)
        # ensure password is hashed
        self.assertTrue(user.has_usable_password())
        
        if PROFILE_EMAIL_CONFIRMATION:
            email_address = EmailAddress.objects.get(email='new_user@testing.com')
            self.assertFalse(email_address.verified)
            self.assertEqual(email_address.emailconfirmation_set.count(), 1)
            
            key = email_address.emailconfirmation_set.all()[0].key
            confirmation_url = reverse('emailconfirmation_confirm_email', args=[key])
            response = self.client.get(confirmation_url)
            self.assertEqual(response.status_code, 302)
            self.assertIn('_auth_user_id', self.client.session)
            
            user = User.objects.get(username='new_user_test')
            self.assertEqual(user.is_active, True)
            
            # retrieve from DB again
            email_address = EmailAddress.objects.get(email='new_user@testing.com')
            self.assertTrue(email_address.verified)
            self.assertTrue(email_address.primary)
    
    def test_profile_detail_API(self):
        """ test new user creation through the API """
        url = reverse('api_profile_detail', args=['registered'])
        
        # GET 200
        response = self.client.get(url)
        self.assertContains(response, 'username')
        self.assertNotContains(response, 'password')
        self.assertNotContains(response, 'email')
        
        # PUT 200
        profile = {
            "first_name": "Registered",
            "last_name": "User",
            "about": "Lorem ipsum dolor...",
            "gender": "M",
            "birth_date": "1987-03-23",
            "address": "Via Prova 1",
            "city": "Rome",
            "country": "Italy"
        }
        response = self.client.put(url, json.dumps(profile), content_type='application/json')
        self.assertEqual(response.status_code, 200)
        user = User.objects.get(username='registered')
        self.assertEqual(user.first_name, 'Registered')
        self.assertEqual(user.last_name, 'User')
        self.assertEqual(user.about, 'Lorem ipsum dolor...')
        self.assertEqual(user.gender, 'M')
        self.assertEqual(user.birth_date.strftime('%Y-%m-%d'), '1987-03-23')
        self.assertEqual(user.address, 'Via Prova 1')
        self.assertEqual(user.city, 'Rome')
        self.assertEqual(user.country, 'Italy')
        
        # PUT 403
        # try modifying another user's profile
        url = reverse('api_profile_detail', args=['romano'])
        response = self.client.put(url, json.dumps(profile), content_type='application/json')
        self.assertEqual(response.status_code, 403)
        
        self.client.logout()
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
    
    def test_profile_detail_API_get_location(self):
        url = reverse('api_profile_detail', args=['registered'])
        user = User.objects.get(username='registered')
        
        # expects None
        user.city = ''
        user.country = ''
        user.save()
        response = self.client.get(url)
        self.assertEqual(response.data['location'], None)
        
        # expects City, Country
        user.city = 'Rome'
        user.country = 'Italy'
        user.save()
        response = self.client.get(url)
        self.assertEqual(response.data['location'], 'Rome, Italy')
        
        # expects City
        user.city = 'Rome'
        user.country = ''
        user.save()
        response = self.client.get(url)
        self.assertEqual(response.data['location'], 'Rome')
        
        # expects Country
        user.city = ''
        user.country = 'Italy'
        user.save()
        response = self.client.get(url)
        self.assertEqual(response.data['location'], 'Italy')
    
    def test_account_detail_API(self):
        url = reverse('api_account_detail')
        
        un_auth_client = Client()
        
        # GET 401
        response = un_auth_client.get(url)
        self.assertEqual(401, response.status_code)
        
        # GET 200
        response = self.client.get(url)
        self.assertContains(response, 'profile')
        self.assertContains(response, 'change_password')
    
    def test_account_password_change_API(self):
        url = reverse('api_account_password_change')
        
        un_auth_client = Client()
        
        # GET 401
        response = un_auth_client.get(url)
        self.assertEqual(401, response.status_code)
        
        # GET 405
        response = self.client.get(url)
        self.assertEqual(405, response.status_code)
        
        # POST 400: wrong current password
        new_password = {}
        response = self.client.post(url, new_password)
        self.assertContains(response, 'current_password', status_code=400)
        self.assertContains(response, 'password1', status_code=400)
        self.assertContains(response, 'password2', status_code=400)
        
        # POST 400: wrong current password
        new_password = {
            "current_password": "wrong",
            "password1": "new_password",
            "password2": "new_password"
        }
        response = self.client.post(url, new_password)
        self.assertContains(response, 'Current password', status_code=400)
        
        # POST 400: password mismatch
        new_password = {
            "current_password": "tester",
            "password1": "new_password",
            "password2": "wrong"
        }
        response = self.client.post(url, new_password)
        self.assertContains(response, 'mismatch', status_code=400)
        
        # POST 200: password changed
        new_password = {
            "current_password": "tester",
            "password1": "new_password",
            "password2": "new_password"
        }
        response = self.client.post(url, new_password)
        self.assertContains(response, 'successfully')
        
        # ensure password has really changed
        user = User.objects.get(username='registered')
        self.assertEqual(user.check_password('new_password'), True)
        
        self.client.logout()
        self.client.login(username='registered', password='new_password')
        
        # GET 405 again
        response = self.client.get(url)
        self.assertEqual(405, response.status_code)
    
    def test_account_password_reset_API(self):
        url = reverse('api_account_password_reset')
        
        # GET 403 - user must not be authenticated
        response = self.client.get(url)
        self.assertEqual(403, response.status_code)
        
        self.client.logout()
        
        # GET 405
        response = self.client.get(url)
        self.assertEqual(405, response.status_code)
        
        # POST 400: missing required field
        response = self.client.post(url)
        self.assertContains(response, 'required', status_code=400)
        
        # POST 400: email not found in the DB
        response = self.client.post(url, { 'email': 'imnotin@the.db' })
        self.assertContains(response, 'address not verified for any', status_code=400)
        
        # POST 200
        user = User.objects.get(username='registered')
        
        if PROFILE_EMAIL_CONFIRMATION:
            email_address = EmailAddress(user=user, email=user.email, verified=True, primary=True)
            email_address.save()
        
        response = self.client.post(url, { 'email': user.email })
        self.assertEqual(200, response.status_code)
        
        self.assertEqual(PasswordReset.objects.filter(user=user).count(), 1, 'dummy email outbox should contain 1 email message')
        self.assertEqual(len(mail.outbox), 1, 'dummy email outbox should contain 1 email message')
        
        password_reset = PasswordReset.objects.get(user=user)
        
        uid_36 = int_to_base36(user.id)
        url = reverse('api_account_password_reset_key',
                      kwargs={ 'uidb36': uid_36, 'key': password_reset.temp_key })
        
        # POST 400: wrong password
        params = { 'password1': 'new_password', 'password2': 'wrong' }
        response = self.client.post(url, params)
        self.assertContains(response, '"password2"', status_code=400)
        
        # correct
        params['password2'] = 'new_password'
        response = self.client.post(url, json.dumps(params), content_type='application/json')
        self.assertContains(response, '"detail"')
        
        # ensure password has been changed
        user = User.objects.get(username='registered')
        self.assertTrue(user.check_password('new_password'))
        
        # ensure password reset object has been used
        password_reset = PasswordReset.objects.get(user=user)
        self.assertTrue(password_reset.reset)
        
        # request a new password reset key
        response = self.client.post(reverse('api_account_password_reset'), { 'email': user.email })
        self.assertEqual(200, response.status_code)
        
        # test HTML version of password reset from key
        password_reset = PasswordReset.objects.get(user=user, reset=False)
        uid = int_to_base36(password_reset.user_id)
        key = password_reset.temp_key
        url = reverse('account_password_reset_key', args=[uid, key])
        
        response = self.client.get(url)
        self.assertEqual(200, response.status_code)
        
        response = self.client.post(url, { 'password1': 'changed', 'password2': 'changed' } )
        self.assertEqual(200, response.status_code)
        
        # ensure password has been changed
        user = User.objects.get(username='registered')
        self.assertTrue(user.check_password('changed'))
        
        # ensure password reset object has been used
        password_reset = PasswordReset.objects.filter(user=user).order_by('-id')[0]
        self.assertTrue(password_reset.reset)
    
    def test_account_login(self):
        url = reverse('api_account_login')
        
        # GET 403: already loggedin
        response = self.client.get(url)
        self.assertEqual(403, response.status_code)
        
        self.client.logout()
        
        # POST 400 invalid credentials
        response = self.client.post(url, { "username": "wrong", "password": "wrong" })
        self.assertContains(response, 'Ivalid login credentials', status_code=400)
        
        # POST 400 missing credentials
        response = self.client.post(url)
        self.assertContains(response, 'required', status_code=400)
        
        # POST 200 login successfull
        response = self.client.post(url, { "username": "registered", "password": "tester" })
        self.assertContains(response, 'successful')
        
        # GET 403: already loggedin
        response = self.client.get(url)
        self.assertEqual(403, response.status_code)
        
        self.client.logout()
        
        # POST 200 login successfull with email
        response = self.client.post(url, { "username": "registered@registered.org", "password": "tester" })
        self.assertContains(response, 'successful')
    
    def test_account_login_inactive(self):
        url = reverse('api_account_login')
        self.client.logout()
        
        # disable user
        user = User.objects.get(username='registered')
        user.is_active = False
        user.save()
        # expect 400
        response = self.client.post(url, { "username": "registered", "password": "tester" })
        self.assertContains(response, 'inactive', status_code=400)
        
        # re-enable user
        user.is_active = True
        user.save()
        # expect 200 login successfull
        response = self.client.post(url, { "username": "registered", "password": "tester" })
        self.assertContains(response, 'successful')
    
    def test_account_logout(self):
        url = reverse('api_account_logout')
        account_url = reverse('api_account_detail')
        
        # GET 405
        response = self.client.get(url)
        self.assertEqual(405, response.status_code)
        
        # Ensure is authenticated
        response = self.client.get(account_url)
        self.assertEqual(200, response.status_code)
        
        # POST 200
        response = self.client.post(url)
        self.assertEqual(200, response.status_code)
        
        # Ensure is NOT authenticated
        response = self.client.get(account_url)
        self.assertEqual(401, response.status_code)
    
    def test_social_links_api(self):
        url = reverse('api_user_social_links_list', args=['romano'])
        
        # GET 200
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        
        # POST 403 - only profile owner can submit new links to his profile
        response = self.client.post(url, { 'url': 'http://mywebsite.com', 'description': 'mywebsite' })
        self.assertEqual(response.status_code, 403)
        
        # POST 201
        self.client.login(username='romano', password='tester')
        response = self.client.post(url, { 'url': 'http://mywebsite.com', 'description': 'mywebsite' })
        self.assertEqual(response.status_code, 201)
        
        self.assertEqual(SocialLink.objects.count(), 1)
        
        url = reverse('api_user_social_links_detail', args=['romano', 1])
        
        # GET 200
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        
        data = json.dumps({ 'url': 'http://changed.com', 'description': 'changed' })
        
        # PUT 200
        response = self.client.put(url, data=data, content_type='application/json')
        self.assertEqual(response.status_code, 200)
        
        self.client.logout()
        self.client.login(username='registered', password='tester')
        
        # POST 403 - only profile owner can edit
        response = self.client.put(url, data=data, content_type='application/json')
        self.assertEqual(response.status_code, 403)
    
    if 'nodeshot.core.nodes' in settings.INSTALLED_APPS:
        def test_user_nodes(self):
            url = reverse('api_user_nodes', args=['romano'])
            
            response = self.client.get(url)
            self.assertEqual(200, response.status_code)
            
            response = self.client.post(url)
            self.assertEqual(405, response.status_code)
    
    if PROFILE_EMAIL_CONFIRMATION:
        def test_account_email_api(self):
            list_url = reverse('api_account_email_list')
            
            # GET 401 - unauthorized because not authenticated
            c = Client()
            response = c.get(list_url)
            self.assertEqual(401, response.status_code)
            
            # GET 200
            response = self.client.get(list_url)
            self.assertEqual(200, response.status_code)
            
            # POST 400 - wrong input data
            response = self.client.post(list_url)
            self.assertEqual(400, response.status_code)
            
            # POST 201
            user = User.objects.get(username='registered')
            email_addresses_count = EmailAddress.objects.filter(user=user).count()
            response = self.client.post(list_url, { 'email': 'testing@test.com' })
            self.assertEqual(201, response.status_code)
            self.assertEqual(EmailAddress.objects.filter(user=user).count(), email_addresses_count + 1)
            # ensure is not verified nor primary
            email_address = EmailAddress.objects.filter(user=user).order_by('-id')[0]
            self.assertFalse(email_address.primary)
            self.assertFalse(email_address.verified)
            # ensure email has been sent
            self.assertEqual(len(mail.outbox), 1)
            # get email confirmation object
            email_confirmation = EmailConfirmation.objects.filter(email_address=email_address)[0]
            
            detail_url = reverse('api_account_email_detail', args=[email_address.pk])
            
            # GET detail 200
            response = self.client.get(detail_url)
            self.assertEqual(200, response.status_code)
            self.assertNotEqual(response.data['resend_confirmation'], False)
            
            # PUT 400 - can't make primary an unverified email address
            response = self.client.put(detail_url, data=json.dumps({ 'primary': True }), content_type='application/json')
            self.assertContains(response, _('Email address cannot be made primary if it is not verified first'), status_code=400)
            
            # POST resend confirmation
            resend_confirmation_url = reverse('api_account_email_resend_confirmation', args=[email_address.pk])
            response = self.client.post(resend_confirmation_url)
            self.assertEqual(200, response.status_code)
            # ensure email has been sent
            self.assertEqual(len(mail.outbox), 2)
            # get email confirmation object
            email_confirmation = EmailConfirmation.objects.filter(email_address=email_address).order_by('-id')[0]
            
            # verify email
            confirmation_url = reverse('emailconfirmation_confirm_email', args=[email_confirmation.key])
            response = self.client.get(confirmation_url)
            self.assertEqual(response.status_code, 302)
            
            # ensure verified and primary
            email_address = EmailAddress.objects.get(user=user, email='testing@test.com')
            self.assertTrue(email_address.primary)
            self.assertTrue(email_address.verified)
            
            # PUT 400 - can't unprimary
            response = self.client.put(detail_url, data=json.dumps({ 'primary': False }), content_type='application/json')
            self.assertContains(response, _('You must have at least one primary address.'), status_code=400)
            
            # DELETE 400 - can't delete because only 1 address
            response = self.client.delete(detail_url)
            self.assertEqual(response.status_code, 400)
            
            # try to resend confirmation, should return error
            resend_confirmation_url = reverse('api_account_email_resend_confirmation', args=[email_address.pk])
            response = self.client.post(resend_confirmation_url)
            self.assertEqual(400, response.status_code)
            
            # add a new email address
            response = self.client.post(list_url, { 'email': 'mynewemailaddress@test.com' })
            self.assertEqual(201, response.status_code)
            self.assertEqual(len(mail.outbox), 3)
            
            # verify new email
            email_address = EmailAddress.objects.get(user=user, email='mynewemailaddress@test.com')
            email_confirmation = EmailConfirmation.objects.filter(email_address=email_address).order_by('-id')[0]
            confirmation_url = reverse('emailconfirmation_confirm_email', args=[email_confirmation.key])
            response = self.client.get(confirmation_url)
            self.assertEqual(response.status_code, 302)
            
            # ensure is verified but not primary
            email_address = EmailAddress.objects.get(user=user, email='mynewemailaddress@test.com')
            self.assertFalse(email_address.primary)
            self.assertTrue(email_address.verified)
            
            detail_url = reverse('api_account_email_detail', args=[email_address.pk])
            
            # PUT 200 - make primary and ensure other one is not primary anymore
            response = self.client.put(detail_url, data=json.dumps({ 'primary': True }), content_type='application/json')
            self.assertEqual(response.status_code, 200)
            # ensure is primary
            email_address = EmailAddress.objects.get(user=user, email='mynewemailaddress@test.com')
            self.assertTrue(email_address.primary)
            # ensure previous one is primary
            email_address = EmailAddress.objects.get(user=user, email='testing@test.com')
            self.assertFalse(email_address.primary)
            
            # DELETE 400 - can't delete primary address
            response = self.client.delete(detail_url)
            self.assertEqual(response.status_code, 400)
            
            # DELETE 204 - delete the other email address
            detail_url = reverse('api_account_email_detail', args=[email_address.pk])
            response = self.client.delete(detail_url)
            self.assertEqual(response.status_code, 204)
            self.assertEqual(EmailAddress.objects.filter(user=user, email='testing@test.com').count(), 0)
    
    def test_password_confirmation_field_in_html(self):
        url = reverse('api_profile_list')
        response = self.client.get(url, HTTP_ACCEPT='text/html')
        
        self.assertContains(response, 'password:</label>')
        self.assertContains(response, 'password_confirmation:</label>')
    
    def test_delete_user(self):
        User.objects.all().delete()
        self.assertEqual(User.objects.count(), 0)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.conf import settings


urlpatterns = patterns('nodeshot.community.profiles.views',
    url(r'^profiles/$', 'profile_list', name='api_profile_list'),
    url(r'^profiles/(?P<username>[-.\w]+)/$', 'profile_detail', name='api_profile_detail'),
    url(r'^profiles/(?P<username>[-.\w]+)/nodes/$', 'user_nodes', name='api_user_nodes'),
    url(r'^profiles/(?P<username>[-.\w]+)/social-links/$', 'user_social_links_list', name='api_user_social_links_list'),
    url(r'^profiles/(?P<username>[-.\w]+)/social-links/(?P<pk>[0-9]+)/$', 'user_social_links_detail', name='api_user_social_links_detail'),
    
    url(r'^account/$', 'account_detail', name='api_account_detail'),
    url(r'^account/login/$', 'account_login', name='api_account_login'),
    url(r'^account/logout/$', 'account_logout', name='api_account_logout'),
    
    url(r'^account/password/$', 'account_password_change', name='api_account_password_change'),
    url(r'^account/password/reset/$', 'account_password_reset', name='api_account_password_reset'),
    url(r'^account/password/reset/(?P<uidb36>[0-9A-Za-z]+)-(?P<key>.+)/$', 'account_password_reset_key', name='api_account_password_reset_key'),
)


# email addresses
if settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True):
    urlpatterns += patterns('nodeshot.community.profiles.views',
        url(r'^account/email/$', 'account_email_list', name='api_account_email_list'),
        url(r'^account/email/(?P<pk>[0-9]+)/$', 'account_email_detail', name='api_account_email_detail'),
        url(r'^account/email/(?P<pk>[0-9]+)/resend-confirmation/$', 'account_email_resend_confirmation', name='api_account_email_resend_confirmation'),
    )

########NEW FILE########
__FILENAME__ = views
from django.http import Http404
from django.contrib.auth import login, logout
from django.utils.http import base36_to_int
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from rest_framework import generics
from rest_framework import exceptions
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.authentication import TokenAuthentication, SessionAuthentication
from rest_framework.permissions import IsAuthenticatedOrReadOnly, IsAuthenticated

from nodeshot.core.base.mixins import ListSerializerMixin, CustomDataMixin
from nodeshot.core.base.utils import Hider
from nodeshot.core.nodes.views import NodeList

from .models import Profile, PasswordReset, SocialLink
from .serializers import *
from .permissions import *


# ------ User Profile ------ #


class ProfileList(generics.ListCreateAPIView):
    """
    Return profile of current authenticated user or return 401.
    
    ### POST
    
    Create a new user account.
    Sends a confirmation mail if if PROFILE_EMAL_CONFIRMATION setting is True.
    
    **Required Fields**:
    
     * username
     * email
     * password
     * password_confirmation
    
    ** Optional Fields **
    
     * first_name
     * last_name
     * about
     * gender
     * birth_date
     * address
     * city
     * country
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    model = Profile
    serializer_class = ProfileCreateSerializer
    
    # custom
    serializer_reader_class = ProfileSerializer
    
    def get(self, request, *args, **kwargs):
        """ return profile of current user if authenticated otherwise 401 """
        serializer = self.serializer_reader_class
        
        if request.user.is_authenticated():
            return Response(serializer(request.user, context=self.get_serializer_context()).data)
        else:
            return Response({ 'detail': _('Authentication credentials were not provided') }, status=401)
    
    def post_save(self, obj, created):
        """
        Send email confirmation according to configuration
        """
        super(ProfileList, self).post_save(obj)
        
        if created:
            obj.add_email()

profile_list = ProfileList.as_view()


class ProfileDetail(generics.RetrieveUpdateAPIView):
    """
    Retrieve specified profile.
    
    ### PUT & PATCH
    
    Update profile.
    
    **Permissions**: only profile owner can edit.
    
    **Editable fields**
    
     * first_name
     * last_name
     * about
     * gender
     * birth_date
     * address
     * city
     * country
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsAuthenticatedOrReadOnly, IsProfileOwner)
    model = Profile
    serializer_class = ProfileSerializer
    lookup_field = 'username'    

profile_detail = ProfileDetail.as_view()


# ------ User Nodes ------ #


if 'nodeshot.core.nodes' in settings.INSTALLED_APPS:

    class UserNodes(ListSerializerMixin, NodeList):
        """
        Retrieve list of nodes of the specified user
        
        Parameters:
        
         * `search=<word>`: search <word> in name of nodes of specified layer
         * `limit=<n>`: specify number of items per page (defaults to 40)
         * `limit=0`: turns off pagination
        """
        def get_queryset(self):
            try:
                self.user = Profile.objects.get(username=self.kwargs['username'])
            except Profile.DoesNotExist:
                raise Http404(_('User not found'))
            
            return super(UserNodes, self).get_queryset().filter(user_id=self.user.id)
        
        def get(self, request, *args, **kwargs):
            """ Retrieve list of nodes of the specified user """
            # ListSerializerMixin.list returns a serializer object
            nodes = self.list(request, *args, **kwargs)
            
            content = ProfileSerializer(self.user, context=self.get_serializer_context()).data
            content['nodes'] = nodes.data
            
            return Response(content)
        
        post = Hider()
    
    user_nodes = UserNodes.as_view()


# ------ User Social Links ------ #


class SocialLinkMixin(object):
    """
    Current user queryset
    """
    queryset = SocialLink.objects.select_related('user').only(
        'id', 'user', 'user__username', 'url', 'description', 'added', 'updated'
    )
    
    def get_queryset(self):
        try:
            self.user = Profile.objects.only('id', 'username').get(username=self.kwargs['username'])
        except Profile.DoesNotExist:
            raise Http404(_('User not found'))
        
        return super(SocialLinkMixin, self).get_queryset().filter(user_id=self.user.id)


class UserSocialLinksList(CustomDataMixin, SocialLinkMixin, generics.ListCreateAPIView):
    """
    Get social links of a user
    
    ### POST
    
    Insert new social link. Profile owner only.
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsAuthenticatedOrReadOnly, IsProfileOwner)
    serializer_class = SocialLinkSerializer
    serializer_custom_class = SocialLinkAddSerializer
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'user': self.request.user.id
        }

user_social_links_list = UserSocialLinksList.as_view()


class UserSocialLinksDetail(SocialLinkMixin, generics.RetrieveUpdateDestroyAPIView):
    """
    Get specified social link
    
    ### PUT & PATCH
    
    Edit existing social link. Profile owner only.
    
    ### DELETE
    
    Delete social link. Profile owner only.
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsAuthenticatedOrReadOnly, IsProfileOwner)
    serializer_class = SocialLinkSerializer
    model = SocialLink

user_social_links_detail = UserSocialLinksDetail.as_view()


# ------ Account ------ #


class AccountLogin(generics.GenericAPIView):
    """
    Log in
    
    **Parameters**:
    
     * username
     * password
     * remember
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsNotAuthenticated, )
    serializer_class = LoginSerializer
    
    def post(self, request, format=None):
        """ authenticate """
        serializer = self.serializer_class(data=request.DATA)
        
        if serializer.is_valid():
            login(request, serializer.instance)
        
            if request.DATA.get('remember'):
                # TODO: remember configurable
                request.session.set_expiry(60 * 60 * 24 * 7 * 3)
            else:
                request.session.set_expiry(0)
                
            return Response({
                'detail': _(u'Logged in successfully'),
                'user': ProfileRelationSerializer(
                    serializer.instance,
                    context={ 'request': request }
                ).data
            })
        
        return Response(serializer.errors, status=400)
    
    def permission_denied(self, request):
        raise exceptions.PermissionDenied(_("You are already authenticated"))

account_login = AccountLogin.as_view()


class AccountLogout(APIView):
    """
    Log out
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsAuthenticated, )
    
    def post(self, request, format=None):
        """ clear session """
        logout(request)
        return Response({ 'detail': _(u'Logged out successfully') })

account_logout = AccountLogout.as_view()


class AccountDetail(generics.GenericAPIView):
    """
    Retrieve profile of current user or return 401 if not authenticated.
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsAuthenticated, )
    serializer_class = AccountSerializer
    
    def get(self, request, format=None):
        """ Retrieve profile of current user or return 401 if not authenticated. """
        serializer = self.serializer_class(request.user, context=self.get_serializer_context())
        return Response(serializer.data)

account_detail = AccountDetail.as_view()


# ------ Account Password ------ #


class AccountPassword(generics.GenericAPIView):
    """
    Change password of the current user.
    
    **Accepted parameters:**
    
     * current_password
     * password1
     * password2
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsAuthenticated,)
    serializer_class = ChangePasswordSerializer
    
    def post(self, request, format=None):
        """ validate password change operation and return result """
        serializer_class = self.get_serializer_class()
        serializer = serializer_class(data=request.DATA, instance=request.user)
        
        if serializer.is_valid():
            serializer.save()
            return Response({ 'detail': _(u'Password successfully changed') })
        
        return Response(serializer.errors, status=400)

account_password_change = AccountPassword.as_view()


class PasswordResetRequestKey(generics.GenericAPIView):
    """
    Sends an email to the user email address with a link to reset his password.
    
    **TODO:** the key should be sent via push notification too.
    
    **Accepted parameters:**
    
     * email
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsNotAuthenticated, )
    serializer_class = ResetPasswordSerializer
    
    def post(self, request, format=None):
        # init form with POST data
        serializer = self.serializer_class(data=request.DATA)
        # validate
        if serializer.is_valid():
            serializer.save()
            return Response({
                'detail': _(u'We just sent you the link with which you will able to reset your password at %s') % request.DATA.get('email')
            })
        # in case of errors
        return Response(serializer.errors, status=400)
    
    def permission_denied(self, request):
        raise exceptions.PermissionDenied(_("You can't reset your password if you are already authenticated"))

account_password_reset = PasswordResetRequestKey.as_view()


class PasswordResetFromKey(generics.GenericAPIView):
    """
    Reset password from key.
    
    **The key must be part of the URL**!
    
    **Accepted parameters:**
    
     * password1
     * password2
    """
    authentication_classes = (TokenAuthentication, SessionAuthentication)
    permission_classes = (IsNotAuthenticated, )
    serializer_class = ResetPasswordKeySerializer
    
    def post(self, request, uidb36, key, format=None):
        # pull out user
        try:
            uid_int = base36_to_int(uidb36)
            password_reset_key = PasswordReset.objects.get(user_id=uid_int, temp_key=key, reset=False)
        except (ValueError, PasswordReset.DoesNotExist, AttributeError):
            return Response({ 'errors': _(u'Key Not Found') }, status=404)
        
        serializer = ResetPasswordKeySerializer(
            data=request.DATA,
            instance=password_reset_key
        )
        
        # validate
        if serializer.is_valid():
            serializer.save()
            return Response({ 'detail': _(u'Password successfully changed.') })
        # in case of errors
        return Response(serializer.errors, status=400)
    
    def permission_denied(self, request):
        raise exceptions.PermissionDenied(_("You can't reset your password if you are already authenticated"))

account_password_reset_key = PasswordResetFromKey.as_view()


# ------ Account Email ------ #


if settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True):
    
    from emailconfirmation.models import EmailAddress, EmailConfirmation
    
    class AccountEmailList(CustomDataMixin, generics.ListCreateAPIView):
        """
        Get email addresses of current authenticated user.
        
        ### POST
        
        Add new email address.
        """
        authentication_classes = (TokenAuthentication, SessionAuthentication)
        permission_classes = (IsAuthenticated,)
        serializer_class = EmailSerializer
        serializer_custom_class = EmailAddSerializer
        model = EmailAddress
        
        def get_queryset(self):
            return self.model.objects.filter(user=self.request.user)
        
        def get_custom_data(self):
            """ additional request.DATA """
            return {
                'user': self.request.user.id
            }
        
        def post_save(self, obj, created):
            """
            Send email confirmation
            """
            super(AccountEmailList, self).post_save(obj)
            
            if created:
                EmailConfirmation.objects.send_confirmation(obj)
    
    account_email_list = AccountEmailList.as_view()
    
    
    class AccountEmailDetail(generics.RetrieveUpdateDestroyAPIView):
        """
        Get specified email object.
        
        ### PUT & PATCH
        
        Make primary.
        
        ### DELETE
        
        Delete email address
        """
        authentication_classes = (TokenAuthentication, SessionAuthentication)
        permission_classes = (IsAuthenticated,)
        serializer_class = EmailEditSerializer
        model = EmailAddress
        
        def get_queryset(self):
            return self.model.objects.filter(user=self.request.user)
        
        def pre_save(self, obj):
            """
            make_primary
            """
            if obj.primary:
                obj.set_as_primary()
            
            super(AccountEmailDetail, self).pre_save(obj)
        
        def delete(self, request, *args, **kwargs):
            """ can't delete if only 1 email address """
            if self.get_object().primary:
                return Response({ 'error': _("You can't delete your primary address")}, status=400)
            elif EmailAddress.objects.filter(user=request.user).count() <= 1:
                return Response({ 'error': _("You can't delete your only email address")}, status=400)
            
            return self.destroy(request, *args, **kwargs)
    
    account_email_detail = AccountEmailDetail.as_view()
    
    
    class ResendEmailConfirmation(APIView):
        """ Resend email confirmation """
        authentication_classes = (TokenAuthentication, SessionAuthentication)
        permission_classes = (IsAuthenticated,)
        
        def post(self, request, *args, **kwargs):
            """
            Resend email confirmation
            """
            try:
                email_address = EmailAddress.objects.get(user=request.user, pk=kwargs.get('pk', None))
            except EmailAddress.DoesNotExist:
                return Response({ 'detail': _('Not Found') }, status=404)
            
            if email_address.verified:
                return Response({ 'error': _('Email address %s already verified' % email_address.email )}, status=400)
            
            EmailConfirmation.objects.send_confirmation(email_address)
            
            return Response({ 'detail': _('Email confirmation sent to %s' % email_address.email )})
    
    account_email_resend_confirmation = ResendEmailConfirmation.as_view()

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.core.api unit tests
"""

from django.test import TestCase
from django.core.urlresolvers import reverse
from django.core.exceptions import ImproperlyConfigured


class ParticipationModelsTest(TestCase):
    """ Models tests """
    
    fixtures = [
        'initial_data.json',
    ]
    
    def test_root_endpoint(self):
        """
        Root endpoint should be reachable
        """
        response = self.client.get(reverse('api_root_endpoint'))
        self.assertEqual(response.status_code, 200)
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.conf import settings


urlpatterns = patterns('nodeshot.core.api.views',
    url(r'^%s$' % settings.NODESHOT['SETTINGS']['API_PREFIX'], 'root_endpoint', name='api_root_endpoint'),
)

if 'rest_framework_swagger' in settings.INSTALLED_APPS:
    urlpatterns += patterns('',
        url(r'^%sdocs/' % settings.NODESHOT['SETTINGS']['API_PREFIX'], include('rest_framework_swagger.urls'))
    )

# loop over all the strings listed in settings.NODESHOT['API']['APPS_ENABLED]
for app_path in settings.NODESHOT['API']['APPS_ENABLED']:
    
    # enable only API modules listed in INSTALLED_APPS
    if app_path not in settings.INSTALLED_APPS:
        # fail silently
        continue
    
    # determine import path for url patterns
    module_path = '%s.urls' % app_path
    
    urlpatterns += patterns('',
        url(r'^%s' % settings.NODESHOT['SETTINGS']['API_PREFIX'], include(module_path))
    )

########NEW FILE########
__FILENAME__ = views
from django.core.urlresolvers import NoReverseMatch

from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework.reverse import reverse

from .urls import urlpatterns


@api_view(('GET',))
def root_endpoint(request, format=None):
    """
    List of all the available resources of this RESTful API.
    """
    endpoints = []
    
    # loop over url modules
    for urlmodule in urlpatterns:
        
        # is it a urlconf module?
        try:
            urlmodule.urlconf_module
            is_urlconf_module = True
        except AttributeError:
            is_urlconf_module = False
        
        # if url is really a urlmodule
        if is_urlconf_module:
            
            # loop over urls of that module
            for url in urlmodule.urlconf_module.urlpatterns:
                
                # TODO: configurable skip url in settings
                # skip api-docs url
                if url.name in ['django.swagger.resources.view']:
                    continue
                
                # try adding url to list of urls to show
                try:
                    endpoints.append({
                        'name': url.name.replace('api_', ''),
                        'url': reverse(url.name, request=request, format=format)
                    })
                # urls of object details will fail silently (eg: /nodes/<slug>/)
                except NoReverseMatch:
                    pass
                
    
    return Response(endpoints)
########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.contrib.gis.geos import Point
from django.core.exceptions import ImproperlyConfigured
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

GEODJANGO_IMPROVED_WIDGETS = 'olwidget' in settings.INSTALLED_APPS


if GEODJANGO_IMPROVED_WIDGETS:
    from olwidget.admin import GeoModelAdmin
else:
    from django.contrib.gis.admin import ModelAdmin as GeoModelAdmin


def _get_geodjango_map_coords():
    """ point to be used by geodjango """
    try:
        lat, lng = settings.NODESHOT['SETTINGS']['ADMIN_MAP_COORDS']
    except KeyError:
        raise ImproperlyConfigured("missing NODESHOT['SETTINGS']['ADMIN_MAP_COORDS'] in settings")
    
    point = Point(lng, lat, srid=4326)
    
    if GEODJANGO_IMPROVED_WIDGETS:
        return (lat, lng)
    else:
        point.transform(900913)
        return point
    
def _get_geodjango_map_zoom():
    """ zoom level to be used by geodjango """
    try:
        return settings.NODESHOT['SETTINGS']['ADMIN_MAP_ZOOM']
    except KeyError:
        raise ImproperlyConfigured("missing NODESHOT['SETTINGS']['ADMIN_MAP_ZOOM'] in settings")


class BaseAdmin(admin.ModelAdmin):
    """
    Abstract administration model for BaseDate models.
        * 'added' and 'updated' fields readonly
        * save-on-top button enabled by default
    """
    save_on_top = True
    readonly_fields = ['added', 'updated']
    
    html_editor_fields = []
    
    # preload tinymce editor static files
    if 'grappelli' in settings.INSTALLED_APPS:  
        class Media:
            js = [
                '%sgrappelli/tinymce/jscripts/tiny_mce/tiny_mce.js' % settings.STATIC_URL,
                '%sgrappelli/tinymce_setup/tinymce_setup_ns.js' % settings.STATIC_URL,
            ]
        
        # enable editor for "node description" only
        def formfield_for_dbfield(self, db_field, **kwargs):
            field = super(BaseAdmin, self).formfield_for_dbfield(db_field, **kwargs)
            
            if db_field.name in self.html_editor_fields:
                field.widget.attrs['class'] = 'html-editor %s' % field.widget.attrs.get('class', '')
            
            return field


class BaseGeoAdmin(BaseAdmin, GeoModelAdmin):
    """
    BaseAdmin + Geodjango support
    """
    if GEODJANGO_IMPROVED_WIDGETS:
        lat, lng = _get_geodjango_map_coords()
        options = {
            'layers': [
                'osm.mapnik',
                'google.streets',
                'google.physical',
                'google.satellite',
                'google.hybrid',
            ],
            'default_lat': lat,
            'default_lon': lng,
            'default_zoom': _get_geodjango_map_zoom(),
            'hide_textarea': not settings.DEBUG,  # TODO: this might be configured in the future
        }
    else:
        default_lon, default_lat = _get_geodjango_map_coords()
        default_zoom = _get_geodjango_map_zoom()


class PublishActionsAdminMixin(object):
    """
    Admin mixin that adds 2 actions in the admin list:
        * publish objects
        * unpublish objects
    """
    actions = ['publish_action', 'unpublish_action']

    def publish_action(self, request, queryset):
        rows_updated = queryset.update(is_published=True)
        
        if rows_updated == 1:
            message_bit = _("1 item was")
        else:
            message_bit = _("%s items were") % rows_updated
            
        self.message_user(request, _("%s successfully published.") % message_bit)
        
    publish_action.short_description = _("Publish selected items")
    
    def unpublish_action(self, request, queryset):
        rows_updated = queryset.update(is_published=False)
        
        if rows_updated == 1:
            message_bit = _("1 item was")
        else:
            message_bit = _("%s items were") % rows_updated
        
        self.message_user(request, _("%s successfully unpublished.") % message_bit)
    
    unpublish_action.short_description = _("Unpublish selected items")


class BaseStackedInline(admin.StackedInline):
    readonly_fields = ['added', 'updated']
    extra = 0


class BaseTabularInline(admin.TabularInline):
    readonly_fields = ['added', 'updated']
    extra = 0

########NEW FILE########
__FILENAME__ = choices
from django.conf import settings


TIME_ZONES = (
    ('GMT-12', '(GMT-12:00) International Date Line West'),
    ('GMT-11', '(GMT-11:00) Midway Island, Samoa'),
    ('GMT-10', '(GMT-10:00) Hawaii'),
    ('GMT-9', '(GMT-9:00) Alaska'),
    ('GMT-8', '(GMT-8:00) Pacific Standard Time'),
    ('GMT-7', '(GMT-7:00) Mountain Standard Time'),
    ('GMT-6', '(GMT-6:00) Central Standard Time'),
    ('GMT-5', '(GMT-5:00) Eastern Standard Time'),
    ('GMT-4:30', '(GMT-4:30) Caracas'),
    ('GMT-4', '(GMT-4:00) Eastern Caribbean Time'),
    ('GMT-3:30', '(GMT-3:30) Newfoundland'),
    ('GMT-3', '(GMT-3:00) Greenland, Buenos Aires'),
    ('GMT-2', '(GMT-2:00) Mid-Atlantic'),
    ('GMT-1', '(GMT-1:00) Cape Verde Time'),
    ('GMT', '(GMT) Western Europe Time'),
    ('GMT+1', '(GMT+1:00) Central European Time'),
    ('GMT+2', '(GMT+2:00) Eastern European Time'),
    ('GMT+3', '(GMT+3:00) Baghdad, Riyadh, Moscow, St. Petersburg'),
    ('GMT+3:30', '(GMT+3:30) Tehran'),
    ('GMT+4:00', '(GMT+4:00) Abu Dhabi, Muscat, Baku, Tbilisi'),
    ('GMT+4:30', '(GMT+4:30) Kabul'),
    ('GMT+5', '(GMT+5:00) Ekaterinburg, Islamabad, Karachi, Tashkent'),
    ('GMT+5:30', '(GMT+5:30) Bombay, Calcutta, Madras, New Delhi'),
    ('GMT+5:45', '(GMT+5:45) Kathmandu'),
    ('GMT+6:00', '(GMT+6:00) Almaty, Dhaka, Colombo'),
    ('GMT+7:', '(GMT+7:00) Bangkok, Hanoi, Jakarta'),
    ('GMT+8', '(GMT+8:00) Beijing, Perth, Singapore, Hong Kong'),
    ('GMT+9', '(GMT+9:00) Tokyo, Seoul, Osaka, Sapporo, Yakutsk'),
    ('GMT+9:30', '(GMT+9:30) Adelaide, Darwin'),
    ('GMT+10', '(GMT+10:00) Eastern Australia, Guam, Vladivostok'),
    ('GMT+11', '(GMT+11:00) Magadan, Solomon Islands, New Caledonia'),
    ('GMT+12', '(GMT+12:00) Auckland, Wellington, Fiji, Kamchatka'),
)

ACCESS_LEVELS = settings.NODESHOT['CHOICES']['ACCESS_LEVELS'].copy()
ACCESS_LEVELS['public'] = 0

PLANNED_STATUS = (
    (0, 'pending'),
    (1, 'completed'),
    (-1, 'cancelled')
)

# from 0 to 18
MAP_ZOOM = (
    [(n, n) for n in range(0, 19)]
)

########NEW FILE########
__FILENAME__ = exceptions
"""
nodeshot custom exceptions
"""


class DependencyError(Exception):
    """
    Unmet dependency
    """
    pass


########NEW FILE########
__FILENAME__ = fields
# snippet "MultiSelectField with comma separated values (Field + FormField)"
# http://djangosnippets.org/snippets/2753/

# New version of this snippet http://djangosnippets.org/snippets/1200/
# tested with Django 1.4

from django import forms
from django.db import models
from django.utils.text import capfirst
from django.core import exceptions
from django.conf import settings


class MultiSelectFormField(forms.MultipleChoiceField):
    widget = forms.CheckboxSelectMultiple
 
    def __init__(self, *args, **kwargs):
        self.max_choices = kwargs.pop('max_choices', 0)
        super(MultiSelectFormField, self).__init__(*args, **kwargs)
 
    def clean(self, value):
        if not value and self.required:
            raise forms.ValidationError(self.error_messages['required'])
        # if value and self.max_choices and len(value) > self.max_choices:
        #     raise forms.ValidationError('You must select a maximum of %s choice%s.'
        #             % (apnumber(self.max_choices), pluralize(self.max_choices)))
        return value

 
class MultiSelectField(models.Field):
    __metaclass__ = models.SubfieldBase
 
    def get_internal_type(self):
        return "CharField"
 
    def get_choices_default(self):
        return self.get_choices(include_blank=False)
 
    def _get_FIELD_display(self, field):
        value = getattr(self, field.attname)
        choicedict = dict(field.choices)
        return choicedict.get(value, value)
 
    def formfield(self, **kwargs):
        # don't call super, as that overrides default widget if it has choices
        defaults = {'required': not self.blank, 'label': capfirst(self.verbose_name),
                    'help_text': self.help_text, 'choices': self.choices}
        if self.has_default():
            defaults['initial'] = self.get_default()
        defaults.update(kwargs)
        return MultiSelectFormField(**defaults)

    def get_prep_value(self, value):
        return value

    def get_db_prep_value(self, value, connection=None, prepared=False):
        if isinstance(value, basestring):
            return value
        elif isinstance(value, list):
            return ",".join(value)
 
    def to_python(self, value):
        if value is not None:
            return value if isinstance(value, list) else value.split(',')
        return ''

    def contribute_to_class(self, cls, name):
        super(MultiSelectField, self).contribute_to_class(cls, name)
        if self.choices:
            func = lambda self, fieldname = name, choicedict = dict(self.choices): ",".join([
                choicedict.get(value, value) for value in getattr(self, fieldname)
            ])
            setattr(cls, 'get_%s_display' % self.name, func)
 
    def validate(self, value, model_instance):
        arr_choices = self.get_choices_selected(self.get_choices_default())
        try:
            for opt_select in value:
                if (int(opt_select) not in arr_choices):  # the int() here is for comparing with integer choices
                    raise exceptions.ValidationError(self.error_messages['invalid_choice'] % value)
        except ValueError:
            if not self.blank:
                raise exceptions.ValidationError(self.error_messages['invalid_choice'] % value)
        return
 
    def get_choices_selected(self, arr_choices=''):
        if not arr_choices:
            return False
        list = []
        for choice_selected in arr_choices:
            list.append(choice_selected[0])
        return list
 
    def value_to_string(self, obj):
        value = self._get_val_from_obj(obj)
        return self.get_db_prep_value(value)


# taken from django-colorful
# https://github.com/charettes/django-colorful
import re
from django.forms.fields import RegexField
from .widgets import ColorFieldWidget

RGB_REGEX = re.compile('^#?((?:[0-F]{3}){1,2})$', re.IGNORECASE)

class RGBColorField(models.CharField):

    widget = ColorFieldWidget

    def __init__(self, *args, **kwargs):
        kwargs['max_length'] = 7
        super(RGBColorField, self).__init__(*args, **kwargs)

    def formfield(self, **kwargs):
        kwargs.update({
                       'form_class': RegexField,
                       'widget': self.widget,
                       'regex': RGB_REGEX
                       })
        return super(RGBColorField, self).formfield(**kwargs)


# needed for South compatibility
if 'south' in settings.INSTALLED_APPS:
    from south.modelsinspector import add_introspection_rules
    add_introspection_rules([], ["^coop\.utils\.fields\.MultiSelectField"])
    add_introspection_rules([], ["^nodeshot\.core\.base\.fields\.RGBColorField"])


# rest_framework MacAddressField
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from rest_framework.fields import WritableField


# rest_framework HStoreDictionaryField
from django_hstore.fields import HStoreDict
from django_hstore.exceptions import HStoreDictException


class HStoreDictionaryField(WritableField):
    """
    A field to handle HStore Dictionary field as a string
    """
    
    def from_native(self, value):
        if value:
            try:
                return HStoreDict(value)
            except HStoreDictException as e:
                raise ValidationError(_('Invalid JSON: %s' % e.json_error_message))
        else:
            return None

    def to_native(self, value):
        if isinstance(value, dict) or value is None:
            return value
        
        value = HStoreDict(value)

        return value

########NEW FILE########
__FILENAME__ = managers
from django.db.models import Manager
from django.contrib.gis.db.models import GeoManager
from django.db.models.query import QuerySet
from django.contrib.gis.db.models.query import GeoQuerySet

from django_hstore.query import HStoreQuerySet, HStoreGeoQuerySet
from django_hstore.managers import HStoreManager, HStoreGeoManager

from nodeshot.core.base.choices import ACCESS_LEVELS


# -------- MIXINS -------- #


class BaseUtilityMixin(object):
    """ add some goodies for development """
    
    def slice(self, order_by='pk', n=None):
        """ return n objects according to specified ordering """
        if n is not None and n < 0:
            raise ValueError('slice parameter cannot be negative')
        
        queryset = self.order_by(order_by)
        
        if n is None:
            return queryset[0]
        else:
            return queryset[0:n]
    
    def find(self, pk):
        return self.get(pk=pk)


class PublishedMixin(BaseUtilityMixin):
    """ adds published filter to queryset """
    
    def published(self):
        """ return only published items """
        return self.filter(is_published=True)


class ACLMixin(BaseUtilityMixin):
    """ adds acl filters to queryset """
    
    def access_level_up_to(self, access_level):
        """ returns all items that have an access level equal or lower than the one specified """
        # if access_level is number
        if isinstance(access_level, int):
            value = access_level
        # else if is string get the numeric value
        else:
            value = ACCESS_LEVELS.get(access_level)
        # return queryset
        return self.filter(access_level__lte=value)
    
    def accessible_to(self, user):
        """
        returns all the items that are accessible to the specified user
        if user is not authenticated will return public items
        
        :param user: an user instance
        """
        if user.is_superuser:
            try:
                queryset = self.get_query_set()
            except AttributeError:
                queryset = self
        elif user.is_authenticated():
            # get user group (higher id)
            group = user.groups.all().order_by('-id')[0]
            queryset = self.filter(access_level__lte=ACCESS_LEVELS.get(group.name))
        else:
            queryset = self.filter(access_level__lte=ACCESS_LEVELS.get('public'))
        return queryset


class ExtendedManagerMixin(BaseUtilityMixin):
    """ add this mixin to add  support for chainable custom methods to your manager """
    
    def __getattr__(self, attr, *args):
        try:
            return getattr(self.__class__, attr, *args)
        except AttributeError:
            return getattr(self.get_query_set(), attr, *args)


# -------- QUERYSETS -------- #


class PublishedQuerySet(QuerySet, PublishedMixin):
    """ Custom queryset to filter only published items """
    pass


class GeoPublishedQuerySet(GeoQuerySet, PublishedMixin):
    """ PublishedQuerySet with GeoDjango queryset """
    pass


class AccessLevelQuerySet(QuerySet, ACLMixin):
    """ Custom queryset to filter depending on access levels """
    pass


class GeoAccessLevelQuerySet(GeoQuerySet, ACLMixin):
    """ AccessLevelQuerySet with GeoDjango queryset """
    pass


class AccessLevelPublishedQuerySet(QuerySet, ACLMixin, PublishedMixin):
    """ AccessLevelQuerySet and PublishedQuerySet """
    pass


class GeoAccessLevelPublishedQuerySet(GeoQuerySet, ACLMixin, PublishedMixin):
    """ AccessLevelQuerySet, PublishedQuerySet with GeoDjango queryset """
    pass


class HStoreAccessLevelQuerySet(HStoreQuerySet, ACLMixin):
    """ HStoreQuerySet, ACLMixin queryset """
    pass


class HStoreGeoPublishedQuerySet(HStoreGeoQuerySet, PublishedMixin):
    """ HStoreGeoQuerySet and PublishedMixin """
    pass


class HStoreGeoAccessLevelQuerySet(HStoreGeoQuerySet, ACLMixin):
    """ HStoreGeoQuerySet and AccessLevel """
    pass


class HStoreGeoAccessLevelPublishedQuerySet(HStoreGeoQuerySet, ACLMixin, PublishedMixin):
    """ HStoreGeoQuerySet, AccessLevelQuerySet, PublishedQuerySet with GeoDjango queryset """
    pass



# -------- MANAGERS -------- #


class NodeshotDefaultManager(Manager, ExtendedManagerMixin):
    """ Simple Manager that implements the BaseUtilityMixin methods """
    pass


class PublishedManager(Manager, ExtendedManagerMixin, PublishedMixin):
    """ Returns published items """
    
    def get_query_set(self): 
        return PublishedQuerySet(self.model, using=self._db)


class GeoPublishedManager(GeoManager, ExtendedManagerMixin, PublishedMixin):
    """ PublishedManager and GeoManager in one """
    
    def get_query_set(self): 
        return GeoPublishedQuerySet(self.model, using=self._db)


class GeoAccessLevelManager(GeoManager, ExtendedManagerMixin, ACLMixin):
    """ AccessLevelManager + Geodjango manager """
    
    def get_query_set(self): 
        return GeoAccessLevelQuerySet(self.model, using=self._db)


class AccessLevelManager(Manager, ExtendedManagerMixin, ACLMixin):
    """ Manager to filter depending on access level """

    def get_query_set(self): 
        return AccessLevelQuerySet(self.model, using=self._db)


class AccessLevelPublishedManager(Manager, ExtendedManagerMixin, ACLMixin, PublishedMixin):
    """
    AccessLeveManager and Publishedmanager in one
    """
    
    def get_query_set(self): 
        return AccessLevelPublishedQuerySet(self.model, using=self._db)


class GeoAccessLevelPublishedManager(GeoManager, ExtendedManagerMixin, ACLMixin, PublishedMixin):
    """
    GeoManager, AccessLeveManager and Publishedmanager in one
    """
    
    def get_query_set(self): 
        return GeoAccessLevelPublishedQuerySet(self.model, using=self._db)


class HStoreNodeshotManager(HStoreManager, ExtendedManagerMixin):
    """ HStoreManager + ExtendedManagerMixin """
    pass


class HStoreAccessLevelManager(HStoreManager, ExtendedManagerMixin, ACLMixin):
    """
    HStoreManager and AccessLeveManager in one
    """
    
    def get_query_set(self): 
        return HStoreAccessLevelQuerySet(self.model, using=self._db)


class HStoreGeoPublishedManager(HStoreGeoManager, ExtendedManagerMixin, PublishedMixin):
    """
    HStoreGeoManager and PublishedMixin in one
    """
    
    def get_query_set(self): 
        return HStoreGeoPublishedQuerySet(self.model, using=self._db)


class HStoreGeoAccessLevelManager(HStoreGeoManager, ExtendedManagerMixin, ACLMixin):
    """
    HStoreGeoManager and AccessLeveManager in one
    """
    
    def get_query_set(self): 
        return HStoreGeoAccessLevelQuerySet(self.model, using=self._db)


class HStoreGeoAccessLevelPublishedManager(HStoreGeoManager, ExtendedManagerMixin, ACLMixin, PublishedMixin):
    """
    HStoreManager, GeoManager, AccessLeveManager and Publishedmanager in one
    """
    
    def get_query_set(self): 
        return HStoreGeoAccessLevelPublishedQuerySet(self.model, using=self._db)

########NEW FILE########
__FILENAME__ = mixins
"""
reusable restframework mixins for API views
"""

import reversion
import warnings

from django.http import Http404

from rest_framework.response import Response


class ACLMixin(object):
    """ implements ACL in views """
    
    def get_queryset(self):
        """
        Returns only objects which are accessible to the current user.
        If user is not authenticated all public objects will be returned.
        
        Model must implement AccessLevelManager!
        """
        return self.queryset.accessible_to(user=self.request.user)


class CustomDataMixin(object):
    """
    Implements custom data in views
    
    Must implement:
        * self.serializer_custom_class: a custom serializer
        * self.get_custom_data(): method that specifies the custom data to pass to the custom serializer
    """
    
    def get_custom_data(self):
        """ automatically determine user on creation """
        raise NotImplementedError('CustomDataMixin needs a get_custom_data method')
    
    def get_custom_serializer(self, **kwargs):
        """ returns the custom serializer class """
        try:
            serializer_class = self.serializer_custom_class
        except AttributeError:
            serializer_class = self.get_serializer
        
        return serializer_class(**kwargs)
    
    def create(self, request, *args, **kwargs):
        """ custom create method """
        # copy request.DATA
        data = request.DATA.copy()
        
        # get the additional data
        additional_data = self.get_custom_data()
        
        # merge the two
        custom_data = dict(data.items() + additional_data.items())
        
        # pass custom data to serializer_custom_class
        serializer = self.get_custom_serializer(data=custom_data,
                                                files=request.FILES,
                                                context=self.get_serializer_context())

        if serializer.is_valid():
            self.pre_save(serializer.object)
            self.object = serializer.save(force_insert=True)
            self.post_save(self.object, created=True)
            headers = self.get_success_headers(serializer.data)
            return Response(serializer.data, status=201, headers=headers)

        return Response(serializer.errors, status=400)


class ListSerializerMixin(object):
    """
    Modification of rest_framework.mixins.ListModelMixin
    List method returns serializer object instead of Response
    """
    
    def list(self, request, *args, **kwargs):
        self.object_list = self.filter_queryset(self.get_queryset())

        # Default is to allow empty querysets.  This can be altered by setting
        # `.allow_empty = False`, to raise 404 errors on empty querysets.
        if not self.allow_empty and not self.object_list:
            warnings.warn(
                'The `allow_empty` parameter is due to be deprecated. '
                'To use `allow_empty=False` style behavior, You should override '
                '`get_queryset()` and explicitly raise a 404 on empty querysets.',
                PendingDeprecationWarning
            )
            class_name = self.__class__.__name__
            error_msg = self.empty_error % {'class_name': class_name}
            raise Http404(error_msg)

        # Switch between paginated or standard style responses
        page = self.paginate_queryset(self.object_list)
        if page is not None:
            serializer = self.get_pagination_serializer(page)
        else:
            serializer = self.get_serializer(self.object_list, many=True)
        
        return serializer


class RevisionUpdate(object):
    """
    Mixin that adds compatibility with django reversion for PUT and PATCH requests
    """
    
    def put(self, request, *args, **kwargs):
        """ custom put method to support django-reversion """       
        with reversion.create_revision():            
            reversion.set_user(request.user)
            reversion.set_comment('changed through the RESTful API from ip %s' % request.META['REMOTE_ADDR'])
            return self.update(request, *args, **kwargs)

    def patch(self, request, *args, **kwargs):
        """ custom patch method to support django-reversion """       
        with reversion.create_revision():            
            reversion.set_user(request.user)
            reversion.set_comment('changed through the RESTful API from ip %s' % request.META['REMOTE_ADDR'])
            kwargs['partial'] = True
            return self.update(request, *args, **kwargs)


class RevisionCreate(object):
    """
    Mixin that adds compatibility with django reversion for POST requests
    """
    
    def post(self, request, *args, **kwargs):
        """ custom put method to support django-reversion """       
        with reversion.create_revision():            
            reversion.set_user(request.user)
            reversion.set_comment('created through the RESTful API from ip %s' % request.META['REMOTE_ADDR'])
            return self.create(request, *args, **kwargs)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from .choices import ACCESS_LEVELS
from .utils import choicify, now


class BaseShortcut(models.Model):
    """
    Abstract Model providing shortcuts to main manager methods
    Handy for shell prototyping
    """
    
    class Meta:
        abstract = True
        
    @classmethod
    def all(cls):
        return cls.objects.all()
    
    @classmethod
    def filter(cls, *args, **kwargs):
        return cls.objects.filter(*args, **kwargs)
    
    @classmethod
    def exclude(cls, *args, **kwargs):
        return cls.objects.exclude(*args, **kwargs)
    
    @classmethod
    def count(cls, *args, **kwargs):
        return cls.objects.count(*args, **kwargs)
    
    # --- custom methods, copying Rails :) --- #
    
    @classmethod
    def last(cls):
        return cls.objects.last()
    
    @classmethod
    def first(cls):
        return cls.objects.first()
    
    @classmethod
    def find(cls, pk):
        return cls.objects.find(pk)


class BaseDate(BaseShortcut):
    """
    Base Abstract Model that provides:
        * an added field that automatically sets the insert date
        * an updated field which updates itself automatically
    We don't use django's autoaddnow=True because that makes the fields not visible in the admin.
    """
    added = models.DateTimeField(_('created on'), default=now())
    updated = models.DateTimeField(_('updated on'), default=now())

    class Meta:
        abstract = True
    
    def save(self, *args, **kwargs):
        """
        automatically update updated date field
        """
        # auto fill updated field with current time unless explicitly disabled
        auto_update = kwargs.get('auto_update', True)
        if auto_update:
            self.updated = now()
        
        # remove eventual auto_update
        if 'auto_update' in kwargs:
            kwargs.pop('auto_update')
        
        super(BaseDate, self).save(*args, **kwargs)


class BaseAccessLevel(BaseDate):
    """
    Base Abstract Model that extends BaseDate and provides
    an additional field for access level management.
    The field default and editable attributes value can be
    overriden by adding some directives in the settings file.
    
    DEFAULT VALUE
        To edit the default value for the access_level field of a certain
        model you will have to add the following setting in the settings.py file:
    
        NODESHOT['DEFAULTS']['ACL_{APP_NAME}_{MODEL_NAME}'] = 'public'
    
        where {APP_NAME} is the uppercase name of an app like "nodes" or "network"
        and {MODEL_NAME} is the uppercase name of a model like "Node" or "Device"
        The values will have to be one of the possible values specified in
        "nodeshot.core.base.choices.ACCESS_LEVELS"
        The possible values are public or the id of the group saved in the database
        (default ones are 1 for registered, 2 for community and 3 for trusted)
        
        For the cases in which no setting is specified the fallback setting
        NODESHOT['DEFAULTS']['ACL_GLOBAL'] will be used.
    
    EDITABLE
        If you want to disable the possibility to edit the access_level field
        for a given model you will have to add the following settings in the settings.py file:
        
        NODESHOT['DEFAULTS']['ACL_{APP_NAME}_{MODEL_NAME}_EDITABLE'] = False
        
        where {APP_NAME} is the uppercase name of an app like "nodes" or "network"
        and {MODEL_NAME} is the uppercase name of a model like "Node" or "Device"
        
        For the cases in which no setting is specified the fallback setting
        NODESHOT['DEFAULTS']['ACL_GLOBAL_EDITABLE'] will be used.
    
    """
    access_level = models.SmallIntegerField(_('access level'), choices=choicify(ACCESS_LEVELS), default=ACCESS_LEVELS.get('public'))
    
    class Meta:
        abstract = True
    
    def __init__(self, *args, **kwargs):
        """
        Determines default value for field "access_level" and determines if is editable
        In the case the field is not editable it won't show up at all
        """
        
        # {APP_NAME}_{MODEL_NAME}, eg: NODES_NODE, SERVICES_SERVICE, NETWORK_IP
        app_descriptor = '%s_%s' % (self._meta.app_label.upper(), self._meta.object_name.upper())
        
        try:
            # looks up in settings.py
            # example NODESHOT['DEFAULTS']['ACL_NETWORK_NODE']
            ACL_DEFAULT = ACCESS_LEVELS.get(settings.NODESHOT['DEFAULTS']['ACL_%s' % app_descriptor])
        except KeyError:
            # if setting is not found use the global setting 
            ACL_DEFAULT = ACCESS_LEVELS.get(settings.NODESHOT['DEFAULTS']['ACL_GLOBAL'])
        
        try:
            # looks up in settings.py
            # example NODESHOT['SETTINGS']['ACL_NETWORK_NODE_EDITABLE']
            ACL_EDITABLE = settings.NODESHOT['SETTINGS']['ACL_%s_EDITABLE' % app_descriptor]
        except KeyError:
            # if setting is not found use the global setting 
            ACL_EDITABLE = settings.NODESHOT['SETTINGS']['ACL_GLOBAL_EDITABLE']
        
        # set "default" and "editable" attributes
        self._meta.get_field('access_level').default = ACL_DEFAULT
        self._meta.get_field('access_level').editable = ACL_EDITABLE
        
        # call super __init__
        super(BaseAccessLevel, self).__init__(*args, **kwargs)


class BaseOrdered(models.Model):
    """
    Ordered Model provides functions for ordering objects in the Django Admin
    """
    order = models.PositiveIntegerField(blank=True, help_text=_('Leave blank to set as last'))

    class Meta:
        ordering = ["order"]
        abstract = True
    
    def get_auto_order_queryset(self):
        return self.__class__.objects.all()
    
    def save(self, *args, **kwargs):
        """ if order left blank """
        if self.order == '' or self.order is None:
            try:
                self.order = self.get_auto_order_queryset().order_by("-order")[0].order + 1
            except IndexError:
                self.order = 0
        super(BaseOrdered, self).save()


class BaseOrderedACL(BaseOrdered, BaseAccessLevel):
    
    class Meta:
        ordering = ["order"]
        abstract = True

########NEW FILE########
__FILENAME__ = serializers
from django.core.urlresolvers import NoReverseMatch

from rest_framework import serializers
from rest_framework.fields import Field
from rest_framework.reverse import reverse


class ExtraFieldSerializerOptions(serializers.ModelSerializerOptions):
    """
    Meta class options for ExtraFieldSerializerOptions
    """
    def __init__(self, meta):
        super(ExtraFieldSerializerOptions, self).__init__(meta)
        self.non_native_fields = getattr(meta, 'non_native_fields', ())


# TODO: rename / remove
class ExtraFieldSerializer(serializers.ModelSerializer):
    """
    ModelSerializer in which non native extra fields can be specified.
    """
    
    _options_class = ExtraFieldSerializerOptions
    
    def restore_object(self, attrs, instance=None):
        """
        Deserialize a dictionary of attributes into an object instance.
        You should override this method to control how deserialized objects
        are instantiated.
        """
        for field in self.opts.non_native_fields:
            attrs.pop(field)
        
        return super(ExtraFieldSerializer, self).restore_object(attrs, instance)
    
    def to_native(self, obj):
        """
        Serialize objects -> primitives.
        """
        ret = self._dict_class()
        ret.fields = self._dict_class()

        for field_name, field in self.fields.items():
            if field.read_only and obj is None:
               continue
            field.initialize(parent=self, field_name=field_name)
            key = self.get_field_key(field_name)
            
            # skips to next iteration but permits to show the field in API browser
            try:
                value = field.field_to_native(obj, field_name)
            except AttributeError as e:
                if field_name in self.opts.non_native_fields:
                    continue
                else:
                    raise AttributeError(e.message)
            
            method = getattr(self, 'transform_%s' % field_name, None)
            if callable(method):
                value = method(obj, value)
            if not getattr(field, 'write_only', False):
                ret[key] = value
            ret.fields[key] = self.augment_field(field, field_name, key, value)

        return ret


class DynamicRelationshipsMixin(object):
    """
    Django Rest Framework Serializer Mixin
    which adds the possibility to dynamically add relationships to a serializer.
    
    To add a relationship, use the class method "add_relationship", this way:
    
    >>> SerializerName.add_relationship('relationship_name', 'view_name', 'lookup_field')
    
    for example:    
    
    >>> from nodeshot.core.nodes.serializers import NodeDetailSerializer
    >>> NodeDetailSerializer.add_relationship(**{
        'name': 'comments',
        'view_name': 'api_node_comments',
        'lookup_field': 'slug'
    })
    """
    _relationships = {}
    
    @classmethod
    def add_relationship(_class, name,
                         view_name=None, lookup_field=None,
                         serializer=None, many=False, queryset=None,
                         function=None):
        """ adds a relationship to serializer
        :param name: relationship name (dictionary key)
        :type name: str
        :param view_name: view name as specified in urls.py
        :type view_name: str
        :param lookup_field: lookup field, usually slug or id/pk
        :type lookup_field: str
        :param serializer: Serializer class to use for relationship
        :type serializer: Serializer
        :param many: indicates if it's a list or a single element, defaults to False
        :type many: bool
        :param queryset: queryset string representation to use for the serializer
        :type queryset: QuerySet
        :param function: function that returns the value to display (dict, list or str)
        :type function: function(obj, request)
        :returns: None
        """
        if view_name is not None and lookup_field is not None:
            _class._relationships[name] = {
                'type': 'link',
                'view_name': view_name,
                'lookup_field': lookup_field
            }
        elif serializer is not None and queryset is not None:
            _class._relationships[name] = {
                'type': 'serializer',
                'serializer': serializer,
                'many': many,
                'queryset': queryset
            }
        elif function is not None:
            _class._relationships[name] = {
                'type': 'function',
                'function': function
            }
        else:
            raise ValueError('missing arguments, either pass view_name and lookup_field or serializer and queryset')
    
    def get_lookup_value(self, obj, string):
        if '.' in string:
            if '()' in string:
                string = string.replace('()', '')
                is_method = True
            else:
                is_method = False
            levels = string.split('.')
            value = getattr(obj, levels.pop(0))
            if value is not None:
                for level in levels:
                    value = getattr(value, level)
                if is_method:
                    return value()
                else:
                    return value
            else:
                return None
        else:
            return getattr(obj, string)
    
    def get_relationships(self, obj):
        request = self.context['request']
        format = self.context['format']
        relationships = {}
        
        # loop over private _relationship attribute
        for key, options in self._relationships.iteritems():
            # if relationship is a link
            if options['type'] == 'link':
                # get lookup value
                lookup_value = self.get_lookup_value(obj, options['lookup_field'])
                # get URL
                value = reverse(options['view_name'],
                                args=[lookup_value],
                                request=request,
                                format=format)
            # if relationship is a serializer
            elif options['type'] == 'serializer':
                queryset = eval(options['queryset'])
                # get serializer representation
                value = options['serializer'](instance=queryset,
                                              context=self.context,
                                              many=options['many']).data
            elif options['type'] == 'function':
                value = options['function'](obj, request)
            else:
                raise ValueError('type %s not recognized' % options['type'])
            # populate new dictionary with value
            relationships[key] = value
        return relationships


class HyperlinkedField(Field):
    """
    Represents the instance, or a property on the instance, using hyperlinking.
    """
    read_only = True

    def __init__(self, *args, **kwargs):
        self.view_name = kwargs.pop('view_name', None)
        # Optionally the format of the target hyperlink may be specified
        self.format = kwargs.pop('format', None)
        # Optionally specify arguments
        self.view_args = kwargs.pop('view_args', None)

        super(HyperlinkedField, self).__init__(*args, **kwargs)

    def field_to_native(self, obj, field_name):
        request = self.context.get('request', None)
        format = self.context.get('format', None)
        view_name = self.view_name

        # By default use whatever format is given for the current context
        # unless the target is a different type to the source.
        if format and self.format and self.format != format:
            format = self.format

        try:
            return reverse(view_name, args=self.view_args, request=request, format=format)
        except NoReverseMatch:
            pass

        raise Exception('Could not resolve URL for field using view name "%s"' % view_name)


class GeoJSONDefaultObjectSerializer(serializers.Field):
    """
    If no object serializer is specified, then this serializer will be applied
    as the default.
    """

    def __init__(self, source=None, context=None):
        # Note: Swallow context kwarg - only required for eg. ModelSerializer.
        super(GeoJSONDefaultObjectSerializer, self).__init__(source=source)


class GeoJSONPaginationSerializerOptions(serializers.SerializerOptions):
    """
    An object that stores the options that may be provided to a
    pagination serializer by using the inner `Meta` class.

    Accessible on the instance as `serializer.opts`.
    """
    def __init__(self, meta):
        super(GeoJSONPaginationSerializerOptions, self).__init__(meta)
        self.object_serializer_class = getattr(meta, 'object_serializer_class',
                                               GeoJSONDefaultObjectSerializer)


class GeoJSONBasePaginationSerializer(serializers.Serializer):
    """
    A custom class for geojson serializers. 
    """
    _options_class = GeoJSONPaginationSerializerOptions
    results_field = 'features'

    def __init__(self, *args, **kwargs):
        """
        Override init to add in the object serializer field on-the-fly.
        """
        super(GeoJSONBasePaginationSerializer, self).__init__(*args, **kwargs)
        results_field = self.results_field
        object_serializer = self.opts.object_serializer_class
        if 'context' in kwargs:
            context_kwarg = {'context': kwargs['context']}
        else:
            context_kwarg = {}
            
        self.fields[results_field] = object_serializer(source='object_list', **context_kwarg)


class GeoJSONPaginationSerializer(GeoJSONBasePaginationSerializer):
    """
    A geoJSON implementation of a pagination serializer.
    """
    type = serializers.SerializerMethodField('get_type')
    
    def get_type(self,obj):
        """ returns FeatureCollection type for geojson """
        
        return "FeatureCollection"

########NEW FILE########
__FILENAME__ = tests
from django.test.client import FakePayload, MULTIPART_CONTENT
from django.test.client import Client as BaseClient
from django.test import TestCase
from django.conf import settings

from urlparse import urlparse, urlsplit


if 'nodeshot.community.profiles' in settings.INSTALLED_APPS:
    user_fixtures = 'test_profiles.json'
else:
    user_fixtures = 'test_users.json'


### --- Add patch method, for Django < 1.5 --- ###


class Client(BaseClient):
    """
    Construct a second test client which can do PATCH requests.
    """
    def patch(self, path, data={}, content_type=MULTIPART_CONTENT, **extra):
        "Construct a PATCH request."
 
        patch_data = self._encode_data(data, content_type)
 
        parsed = urlparse(path)
        r = {
            'CONTENT_LENGTH': len(patch_data),
            'CONTENT_TYPE':   content_type,
            'PATH_INFO':      self._get_path(parsed),
            'QUERY_STRING':   parsed[4],
            'REQUEST_METHOD': 'PATCH',
            'wsgi.input':     FakePayload(patch_data),
        }
        r.update(extra)
        return self.request(**r)


class BaseTestCase(TestCase):
    """
    Test case with a client that can do patch requests
    """
    
    client_class = Client
########NEW FILE########
__FILENAME__ = utils
from django.utils.translation import ugettext_lazy as _
from django.utils.translation import ugettext
from django.utils.timezone import utc
from django.conf import settings

from datetime import datetime, timedelta
from .exceptions import DependencyError


__all__ = [
    'Hider',
    'check_dependencies',
    'choicify',
    'get_key_by_value',
    'now',
    'now_after',
    'after',
]


class Hider(object):
    def __get__(self,instance,owner):
        raise AttributeError("Hidden attrbute")

    def __set__(self, obj, val):
        raise AttributeError("Hidden attribute")


def check_dependencies(dependencies, module):
    """
    Ensure dependencies of a module are listed in settings.INSTALLED_APPS
    
    :dependencies string | list: list of dependencies to check
    :module string: string representing the path to the current app
    """
    if type(dependencies) == str:
        dependencies = [dependencies]
    elif type(dependencies) != list:
        raise TypeError('dependencies argument must be of type list or string')
    
    for dependency in dependencies:
        if dependency not in settings.INSTALLED_APPS:
            raise DependencyError('%s depends on %s, which should be in settings.INSTALLED_APPS' % (module, dependency))


def choicify(dictionary):
    """
    Converts a readable python dictionary into a django model/form
    choice structure (list of tuples) ordered based on the values of each key
    
    :param dictionary: the dictionary to convert
    """
    # get order of the fields
    ordered_fields = sorted(dictionary, key=dictionary.get)
    choices = []
    # loop over each field
    for field in ordered_fields:
        # build tuple (value, i18n_key)
        row = (dictionary[field], _(field.replace('_', ' ')))
        # append tuple to choices
        choices.append(row)
    # return django sorted choices
    return choices


def get_key_by_value(dictionary, search_value):
    """
    searchs a value in a dicionary and returns the key of the first occurrence
    
    :param dictionary: dictionary to search in
    :param search_value: value to search for
    """
    for key, value in dictionary.iteritems():
        if value == search_value:
            return ugettext(key)


def pause_disconnectable_signals():
    """
    Disconnects non critical signals like notifications, websockets and stuff like that.
    Use when managing large chunks of nodes
    """
    for signal in settings.NODESHOT['DISCONNECTABLE_SIGNALS']:
        signal['disconnect']()


def resume_disconnectable_signals():
    """
    Reconnects non critical signals like notifications, websockets and stuff like that.
    Use when managing large chunks of nodes
    """
    for signal in settings.NODESHOT['DISCONNECTABLE_SIGNALS']:
        signal['reconnect']()


# time shortcuts

def now():
    """ returns the current date and time in UTC format (datetime object) """
    return datetime.utcnow().replace(tzinfo=utc)

def now_after(**kwargs):
    """ returns the current date and time plus the time (seconds, minutes, hours, days, years) specified """
    return now() + timedelta(**kwargs)

def ago(**kwargs):
    """ returns the current date and time minus the time (seconds, minutes, hours, days, years) specified """
    return now() - timedelta(**kwargs)

def after(date, **kwargs):
    """
    returns the result of the calculation of the date param plus the time (seconds, minutes, hours, days, years) specified
    
    :paramm datetime: datetime object to which add more time
    """
    return date + timedelta(**kwargs)

########NEW FILE########
__FILENAME__ = widgets
# -*- coding: utf-8 -*-
from django.utils.safestring import mark_safe
from django.utils.html import escape, conditional_escape
from django.utils.encoding import force_unicode
from django.forms.widgets import ClearableFileInput, CheckboxInput
from django.utils.translation import ugettext as _


class AdvancedFileInput(ClearableFileInput):
    """
    File Input Widget
    """

    def __init__(self, *args, **kwargs):

        self.url_length = kwargs.pop('url_length',30)
        self.preview = kwargs.pop('preview',True)
        self.image_width = kwargs.pop('image_width',200)
        super(AdvancedFileInput, self).__init__(*args, **kwargs)

    def render(self, name, value, attrs=None,):

        substitutions = {
            'initial_text': self.initial_text,
            'input_text': self.input_text,
            'clear_template': '',
            'clear_checkbox_label': self.clear_checkbox_label,
        }
        template = u'%(input)s'

        substitutions['input'] = super(ClearableFileInput, self).render(name, value, attrs)

        if value and hasattr(value, "url"):

            template = self.template_with_initial
            if self.preview:
                substitutions['initial'] = (u'<a href="{0}">{1}</a><br /><br />\
                <a href="{0}" target="_blank"><img src="{0}" alt="" width="{2}" /></a><br /><br />'.format
                    (escape(value.url),'...'+escape(force_unicode(value))[-self.url_length:],
                     self.image_width))
            else:
                substitutions['initial'] = (u'<a href="{0}">{1}</a>'.format
                    (escape(value.url),'...'+escape(force_unicode(value))[-self.url_length:]))
            if not self.is_required:
                checkbox_name = self.clear_checkbox_name(name)
                checkbox_id = self.clear_checkbox_id(checkbox_name)
                substitutions['clear_checkbox_name'] = conditional_escape(checkbox_name)
                substitutions['clear_checkbox_id'] = conditional_escape(checkbox_id)
                substitutions['clear'] = CheckboxInput().render(checkbox_name, False, attrs={'id': checkbox_id})
                substitutions['clear_template'] = self.template_with_clear % substitutions

        return mark_safe(template % substitutions)


# originally taken from django-colorful but adapted

from django.conf import settings
from django.forms.widgets import TextInput
from django.utils.safestring import SafeUnicode

try:
    url = settings.STATIC_URL
except AttributeError:
    try:
        url = settings.MEDIA_URL
    except AttributeError:
        url = ''

class ColorFieldWidget(TextInput):
    class Media:
        css = {
            'all': ("%scolorful/spectrum.css" % url,)
        }
        js  = ("%scolorful/spectrum.js" % url,)

    input_type = 'color'

    def render_script(self, id):
        return u'''<script type="text/javascript">
                    (function($){
                        $(document).ready(function(){
                            $('#%s').each(function(i, elm){
                                // Make sure html5 color element is not replaced
                                if(elm.type != 'color'){
                                    $(elm).spectrum({
                                        showInput: true,
                                        showInitial: true,
                                        cancelText: '%s',
                                        chooseText: '%s'
                                    });
                                }
                            });
                        });
                    })('django' in window ? django.jQuery : jQuery);
                </script>
                ''' % (id, _('cancel'), _('ok'))

    def render(self, name, value, attrs={}):
        if 'id' not in attrs:
            attrs['id'] = "#id_%s" % name
        render = super(ColorFieldWidget, self).render(name, value, attrs)
        return SafeUnicode(u"%s%s" % (render, self.render_script(attrs['id'])))

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.conf import settings

import reversion

from .models import Page, MenuItem


class PageAdmin(reversion.VersionAdmin):
    list_display = ('title', 'slug', 'is_published', 'access_level', 'added', 'updated')
    list_filter = ('is_published',)
    prepopulated_fields = { 'slug': ('title',) }
    readonly_fields = ("added", "updated")
    save_on_top = True
    search_fields = ['title', 'content']
    
    fieldsets = (
        (None, {
            'fields': ('title', 'slug', 'content')
        }),
        ('Settings', {
            'fields': ('access_level', 'is_published', 'added', 'updated')
        }),
        ('Meta tags (optional)', {
            'fields': ('meta_description', 'meta_keywords', 'meta_robots')
        }),
    )
    
    if 'grappelli' in settings.INSTALLED_APPS:
        
        class Media:
            js = [
                '%sgrappelli/tinymce/jscripts/tiny_mce/tiny_mce.js' % settings.STATIC_URL,
                '%sgrappelli/tinymce_setup/tinymce_setup_ns.js' % settings.STATIC_URL,
            ]
        
        # enable editor for "content" field only
        def formfield_for_dbfield(self, db_field, **kwargs):
            field = super(PageAdmin, self).formfield_for_dbfield(db_field, **kwargs)
            
            if db_field.name == 'content':
                field.widget.attrs['class'] = 'html-editor %s' % field.widget.attrs.get('class', '')
            
            return field


class MenuItemAdmin(reversion.VersionAdmin):
    list_display = ('name', 'url', 'order', 'is_published', 'access_level', 'added', 'updated')
    list_editable = ('order',)
    list_filter = ('is_published',)
    readonly_fields = ('added', 'updated')
    save_on_top = True
    
    fieldsets = (
        (None, {
            'fields': ('name', 'url')
        }),
        ('Settings', {
            'fields': ('access_level', 'is_published', 'order', 'added', 'updated')
        }),
    )

admin.site.register(Page, PageAdmin)
admin.site.register(MenuItem, MenuItemAdmin)

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseAccessLevel, BaseOrderedACL
from nodeshot.core.base.managers import AccessLevelPublishedManager


__all__ = ['Page', 'MenuItem']


ROBOTS_CHOICES = (
    ('index, follow', 'index, follow'),
    ('noindex, follow', 'noindex, follow'),
    ('index, nofollow', 'index, nofollow'),        
    ('noindex, nofollow', 'noindex, nofollow'),
)


class Page(BaseAccessLevel):
    """
    Page Model
    """
    title = models.CharField(_('title'), max_length=50)
    slug = models.SlugField(_('slug'), max_length=50, blank=True, unique=True)
    content = models.TextField(_('content'))
    is_published = models.BooleanField(default=True)
    
    # meta fields, optional
    meta_description = models.CharField(_('meta description'), max_length=255, blank=True)
    meta_keywords = models.CharField(_('meta keywords'), max_length=255, blank=True)
    meta_robots = models.CharField(max_length=50, choices=ROBOTS_CHOICES, default=ROBOTS_CHOICES[0][0])
    
    objects = AccessLevelPublishedManager()
    
    def __unicode__(self):
        return self.title


class MenuItem(BaseOrderedACL):
    """
    MenuItem Model
    """
    name = models.CharField(_('name'), max_length=50)
    url = models.CharField(_('url'), max_length=255)
    is_published = models.BooleanField(default=True)
    
    objects = AccessLevelPublishedManager()
    
    def __unicode__(self):
        return self.url


# ------ Signals ------ #


from django.dispatch import receiver
from django.db.models.signals import pre_delete, post_save
from django.core.cache import cache


@receiver(post_save, sender=Page)
@receiver(post_save, sender=MenuItem)
@receiver(pre_delete, sender=Page)
@receiver(pre_delete, sender=MenuItem)
def clear_cache(sender, **kwargs):
    cache.clear()

########NEW FILE########
__FILENAME__ = serializers
from rest_framework import serializers

from .models import *


__all__ = [
    'PageListSerializer',
    'PageDetailSerializer',
    'MenuSerializer'
]


class PageListSerializer(serializers.ModelSerializer):
    """
    Page List Serializer
    """
    
    details = serializers.HyperlinkedIdentityField(view_name='api_page_detail', slug_field='slug')
    
    class Meta:
        model = Page
        fields = ('title', 'slug', 'added', 'updated', 'details')


class PageDetailSerializer(PageListSerializer):
    """
    Page Detail Serializer
    """
    
    class Meta:
        model = Page
        fields = ('title', 'slug', 'content',
                  'meta_description', 'meta_keywords', 'meta_robots',
                  'added', 'updated', 'details')


class MenuSerializer(serializers.ModelSerializer):
    """
    Menu Serializer
    """
    
    class Meta:
        model = MenuItem
        fields = ('name', 'url', 'added', 'updated')

########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.core.cms unit tests
"""

import simplejson as json

from django.test import TestCase
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _

from nodeshot.core.base.tests import user_fixtures

from .models import *


class CMSTest(TestCase):

    fixtures = [
        'initial_data.json',
        user_fixtures,
    ]

    def setUp(self):
        pass

    def test_page_list(self):
        url = reverse('api_page_list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), Page.objects.count())

    def test_page_detail(self):
        url = reverse('api_page_detail', args=['privacy-policy'])
        response = self.client.get(url)
        self.assertContains(response, 'privacy-policy')

    def test_menu_list(self):
        url = reverse('api_menu_list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.core.cms.views',
    url(r'^pages/$', 'page_list', name='api_page_list'),
    url(r'^pages/(?P<slug>[-\w]+)/$', 'page_detail', name='api_page_detail'),
    url(r'^menu/$', 'menu_list', name='api_menu_list'),
)
########NEW FILE########
__FILENAME__ = views
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page

from rest_framework import generics, authentication

from nodeshot.core.base.mixins import ACLMixin

from .serializers import *
from .models import *


class PageList(ACLMixin, generics.ListAPIView):
    """
    Retrieve the list of all the available pages.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = Page.objects.published()
    serializer_class = PageListSerializer
    
    @method_decorator(cache_page(86400))  # cache for 1 day
    def dispatch(self, *args, **kwargs):
        return super(self.__class__, self).dispatch(*args, **kwargs)
    
page_list = PageList.as_view()


class PageDetail(ACLMixin, generics.RetrieveAPIView):
    """
    Retrieve specified page.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = Page.objects.published()
    serializer_class = PageDetailSerializer
    
    @method_decorator(cache_page(86400))  # cache for 1 day
    def dispatch(self, *args, **kwargs):
        return super(self.__class__, self).dispatch(*args, **kwargs)
    
page_detail = PageDetail.as_view()


# ------ Menu ------ #


class MenuList(ACLMixin, generics.ListAPIView):
    """
    Retrieve menu item list.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = MenuItem.objects.published()
    serializer_class = MenuSerializer
    
    @method_decorator(cache_page(86400))  # cache for 1 day
    def dispatch(self, *args, **kwargs):
        return super(self.__class__, self).dispatch(*args, **kwargs)
    
menu_list = MenuList.as_view()

########NEW FILE########
__FILENAME__ = admin
from django.contrib.gis import admin
from django.core.urlresolvers import reverse
from django.conf import settings
from django.utils.translation import ugettext as _

from nodeshot.core.base.admin import BaseGeoAdmin, PublishActionsAdminMixin
from models import Layer

REVERSION_ENABLED = settings.NODESHOT['SETTINGS'].get('REVERSION_LAYERS', True)

# enable django-reversion according to settings
if REVERSION_ENABLED:
    import reversion
    
    class GeoAdmin(BaseGeoAdmin, reversion.VersionAdmin):
        change_list_template = 'reversion_and_smuggler/change_list.html'
else:
    class GeoAdmin(BaseGeoAdmin):
        change_list_template = 'smuggler/change_list.html'


class LayerAdmin(PublishActionsAdminMixin, GeoAdmin):
    list_display = (
        'name', 'is_published', 'view_nodes',
        'organization', 'email', 'is_external',
        'new_nodes_allowed', 'added', 'updated'
    )
    list_filter   = ('is_external', 'is_published')
    search_fields = ('name', 'description', 'organization', 'email')
    filter_horizontal = ('mantainers',)
    prepopulated_fields = {'slug': ('name',)}
    inlines = []
    
    # django-grappelli usability improvements
    raw_id_fields = ('mantainers',)
    autocomplete_lookup_fields = {
        'm2m': ['mantainers'],
    }
    
    if settings.NODESHOT['SETTINGS'].get('LAYER_TEXT_HTML', True) is True:  
        # enable editor for "extended text description" only
        html_editor_fields = ['text']
    
    def view_nodes(self, obj):
        return '<a href="%s?layer__id__exact=%s">%s</a>' % (
            reverse('admin:nodes_node_changelist'),
            obj.pk,
            _('view nodes')
        )
    view_nodes.allow_tags = True
    
    def publish_action(self, request, queryset):
        super(LayerAdmin, self).publish_action(request, queryset)
        # unpublish all nodes of selected layers
        Layer.node_set.related.model.filter(layer__in=queryset).update(is_published=True)
    
    def unpublish_action(self, request, queryset):
        super(LayerAdmin, self).unpublish_action(request, queryset)
        # publish all nodes of selected layers
        Layer.node_set.related.model.filter(layer__in=queryset).update(is_published=False)


admin.site.register(Layer, LayerAdmin)

########NEW FILE########
__FILENAME__ = managers
from nodeshot.core.base.managers import GeoPublishedQuerySet
from django.conf import settings

if settings.NODESHOT['SETTINGS'].get('HSTORE', True):
    from nodeshot.core.base.managers import HStoreGeoPublishedManager as BaseLayerManager
else:
    from nodeshot.core.base.managers import GeoPublishedManager as BaseLayerManager


class ExternalMixin(object):
    """ Add method external() to your custom queryset or manager model """
    
    def external(self):
        """ return only external layers """
        return self.filter(is_external=True)


class ExternalQueryset(GeoPublishedQuerySet, ExternalMixin):
    """ filter external layers """
    pass


class LayerManager(BaseLayerManager, ExternalMixin):
    """ extends GeoPublishedManager to add external method """
    
    def get_query_set(self): 
        return ExternalQueryset(self.model, using=self._db)
########NEW FILE########
__FILENAME__ = layer
from django.contrib.gis.db import models
from django.utils.translation import ugettext_lazy as _
from django.core.exceptions import ValidationError, ObjectDoesNotExist
from django.contrib.gis.measure import D
from django.conf import settings

from django_hstore.fields import DictionaryField

from nodeshot.core.base.models import BaseDate
from nodeshot.core.base.choices import MAP_ZOOM
from nodeshot.core.nodes.models import Node

from ..managers import LayerManager
from ..signals import layer_is_published_changed


class Layer(BaseDate):
    """ Layer Model """
    name = models.CharField(_('name'), max_length=50, unique=True)
    slug = models.SlugField(max_length=50, db_index=True, unique=True)
    description = models.CharField(_('description'), max_length=250, blank=True, null=True,
                                   help_text=_('short description of this layer'))
    text = models.TextField(_('extended text'), blank=True, null=True,
                            help_text=_('extended description, specific instructions, links, ecc.'))
    
    # record management
    is_published = models.BooleanField(_('published'), default=True)
    is_external = models.BooleanField(_('is it external?'), default=False)
    
    # geographic related fields
    center = models.PointField(_('center coordinates'), null=True, blank=True)
    area = models.PolygonField(_('area'), null=True, blank=True)
    zoom = models.SmallIntegerField(_('default zoom level'), choices=MAP_ZOOM, default=settings.NODESHOT['DEFAULTS']['LAYER_ZOOM'])
    
    # organizational
    organization = models.CharField(_('organization'), help_text=_('Organization which is responsible to manage this layer'), max_length=255)
    website = models.URLField(_('Website'), blank=True, null=True)
    email = models.EmailField(_('email'),
                              help_text=_("""possibly an email address that delivers messages to all the active participants;
                                          if you don't have such an email you can add specific users in the "mantainers" field"""),
                              blank=True)
    mantainers = models.ManyToManyField(settings.AUTH_USER_MODEL,
                                        verbose_name=_('mantainers'),
                                        help_text=_('you can specify the users who are mantaining this layer so they will receive emails from the system'),
                                        blank=True)
    
    # settings
    minimum_distance = models.IntegerField(default=settings.NODESHOT['DEFAULTS']['LAYER_MINIMUM_DISTANCE'],
                                           help_text=_('minimum distance between nodes in meters, 0 means feature disabled'))
    new_nodes_allowed = models.BooleanField(_('new nodes allowed'), default=True, help_text=_('indicates whether users can add new nodes to this layer'))
    
    data = DictionaryField(_('extra data'), null=True, blank=True,\
                           help_text=_('store extra attributes in JSON string'))
        
    # default manager
    objects = LayerManager()
    
    # this is needed to check if the is_published is changing
    # explained here:
    # http://stackoverflow.com/questions/1355150/django-when-saving-how-can-you-check-if-a-field-has-changed
    _current_is_published = None
    
    class Meta:
        db_table = 'layers_layer'
        app_label= 'layers'
    
    def __unicode__(self):
        return '%s' % self.name
    
    def __init__(self, *args, **kwargs):
        """ Fill __current_is_published """
        super(Layer, self).__init__(*args, **kwargs)
        # set current is_published, but only if it is an existing layer
        if self.pk:
            self._current_is_published = self.is_published
    
    def save(self, *args, **kwargs):
        """
        intercepts changes to is_published and fires layer_is_published_changed signal
        """
        super(Layer, self).save(*args, **kwargs)
        
        # if is_published of an existing layer changes
        if self.pk and self.is_published != self._current_is_published:
            # send django signal
            layer_is_published_changed.send(
                sender=self.__class__,
                instance=self,
                old_is_published=self._current_is_published,
                new_is_published=self.is_published
            )
            # unpublish nodes
            self.update_nodes_published()
        
        # update _current_is_published
        self._current_is_published = self.is_published
    
    def update_nodes_published(self):
        """ publish or unpublish nodes of current layer """
        if self.pk:
            self.node_set.all().update(is_published=self.is_published)
    
    if 'grappelli' in settings.INSTALLED_APPS:
        @staticmethod
        def autocomplete_search_fields():
            return ('name__icontains', 'slug__icontains')


# ------ Add Layer related methods to Node class ------ #

@property
def intersecting_layers(self):
    return Layer.objects.filter(area__contains=self.point)

Node.intersecting_layers = intersecting_layers


# ------ Additional validation for Node model ------ #

def new_nodes_allowed_for_layer(self):
    """
    ensure new nodes are allowed for this layer
    """
    try:
        if not self.pk and not self.layer.new_nodes_allowed:
            raise ValidationError(_('New nodes are not allowed for this layer'))
    except ObjectDoesNotExist:
        # this happens if node.layer is None
        return

# TODO: thes features must be tested inside the layer's app code (nodeshot.core.layers.tests)
def node_layer_validation(self):
    """
    1. if minimum distance is specified, ensure node is not too close to other nodes;
    2. if layer defines an area, ensure node coordinates are contained in the area
    """
    try:
        minimum_distance = self.layer.minimum_distance
        geometry = self.geometry
        layer_area = self.layer.area
    except ObjectDoesNotExist:
        # this happens if node.layer is None 
        return
    
    # TODO - lower priority: do this check only when coordinates are changing
    if minimum_distance > 0:
        near_nodes = Node.objects.exclude(pk=self.id).filter(geometry__distance_lte=(geometry, D(m=minimum_distance))).count()
        if near_nodes > 0 :
            raise ValidationError(_('Distance between nodes cannot be less than %s meters') % minimum_distance)        
    
    if layer_area is not None and not layer_area.contains(geometry):
        raise ValidationError(_('Node must be inside layer area'))

Node.add_validation_method(new_nodes_allowed_for_layer)
Node.add_validation_method(node_layer_validation)

########NEW FILE########
__FILENAME__ = serializers
from rest_framework import serializers, pagination
from rest_framework_gis import serializers as geoserializers

from nodeshot.core.base.serializers import GeoJSONPaginationSerializer
from nodeshot.core.nodes.models import Node
from nodeshot.core.nodes.serializers import NodeListSerializer

from .models import Layer


__all__ = [
    'LayerDetailSerializer',
    'LayerListSerializer',
    'LayerNodeListSerializer',
    'GeoLayerListSerializer',
    'CustomNodeListSerializer',
    'PaginatedLayerListSerializer',
    'PaginatedGeojsonLayerListSerializer'
]


class LayerListSerializer(geoserializers.GeoModelSerializer):
    """
    Layer list
    """
    details = serializers.HyperlinkedIdentityField(view_name='api_layer_detail', slug_field='slug')
    nodes = serializers.HyperlinkedIdentityField(view_name='api_layer_nodes_list', slug_field='slug')
    geojson = serializers.HyperlinkedIdentityField(view_name='api_layer_nodes_geojson', slug_field='slug')
    
    class Meta:
        model = Layer

        fields= (
            'id', 'slug', 'name', 'center', 'area',
            'details', 'nodes', 'geojson'
        )


class PaginatedLayerListSerializer(pagination.PaginationSerializer):
    class Meta:
        object_serializer_class = LayerListSerializer


class PaginatedGeojsonLayerListSerializer(GeoJSONPaginationSerializer):
    class Meta:
        object_serializer_class = LayerListSerializer


class GeoLayerListSerializer(geoserializers.GeoFeatureModelSerializer, LayerListSerializer):
    class Meta:
        model = Layer
        geo_field = 'area'

        fields= ('id', 'name', 'slug')
        
        
class LayerDetailSerializer(LayerListSerializer):
    """
    Layer details
    """
    class Meta:
        model = Layer
        fields = ('name', 'center', 'area', 'zoom', 'is_external',
                  'description', 'text', 'organization', 'website', 'nodes', 'geojson')
        

class CustomNodeListSerializer(NodeListSerializer):
    class Meta:
        model = Node
        fields = [
            'name', 'slug', 'user',
            'geometry', 'elev', 'address', 'description',
            'updated', 'added', 'details'
        ]
        read_only_fields = ['added', 'updated']
        geo_field = 'geometry'


class LayerNodeListSerializer(LayerDetailSerializer):
    """
    Nodes of a Layer
    """
    class Meta:
        model = Layer

        fields = ('name', 'description', 'text', 'organization', 'website')

########NEW FILE########
__FILENAME__ = signals
import django.dispatch

layer_is_published_changed = django.dispatch.Signal(providing_args=["instance", "old_status", "new_status"])

########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.core.layers unit tests
"""

import simplejson as json

from django.test import TestCase
from django.core.exceptions import ValidationError
from django.core.urlresolvers import reverse
from django.utils.translation import ugettext as _
from django.contrib.gis.geos import GEOSGeometry

from nodeshot.core.base.tests import user_fixtures
from nodeshot.core.nodes.models import Node  # test additional validation added by layer model

from .models import Layer


class LayerTest(TestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json'
    ]
    
    def setUp(self):
        pass
    
    def test_layer_manager(self):
        """ test Layer custom Manager """
        # published() method
        layers_count = Layer.objects.all().count()
        published_layers_count = Layer.objects.published().count()
        self.assertEquals(published_layers_count, layers_count)
        
        # after unpublishing one layer we should get 1 less layer in total
        l = Layer.objects.get(pk=1)
        l.is_published = False
        l.save()
        layers_count = Layer.objects.all().count()
        published_layers_count = Layer.objects.published().count()
        self.assertEquals(published_layers_count, layers_count-1)
        
        # external() method
        self.assertEquals(Layer.objects.external().count(), Layer.objects.filter(is_external=True).count())
        
        # mix external and published
        count = Layer.objects.filter(is_external=True, is_published=True).count()
        self.assertEquals(Layer.objects.external().published().count(), count)
        self.assertEquals(Layer.objects.published().external().count(), count)
    
    def test_layer_new_nodes_allowed(self):
        layer = Layer.objects.get(pk=1)
        layer.new_nodes_allowed = False
        layer.area = None
        layer.minimum_distance = 0
        layer.save()
        
        # ensure changing an existing node works
        node = layer.node_set.all()[0]
        node.name = 'changed'
        node.save()
        # re-get from DB, just to be sure
        node = Node.objects.get(pk=node.pk)
        self.assertEqual(node.name, 'changed')
        
        # ensure new node cannot be added
        node = Node(**{
            'name': 'test new node',
            'slug': 'test-new-node',
            'layer': layer,
            'geometry': 'POINT (10.4389188797003565 43.7200020000987328)'
        })
        with self.assertRaises(ValidationError):
            node.full_clean()
        
        try:
            node.full_clean()
            assert()
        except ValidationError as e:
            self.assertIn(_('New nodes are not allowed for this layer'), e.messages)
    
    def test_layer_minimum_distance(self):
        """ ensure minimum distance settings works as expected """
        layer = Layer.objects.get(slug='rome')
        node = layer.node_set.all()[0]
        
        # creating node with same coordinates should not be an issue
        new_node = Node(**{
            'name': 'new_node',
            'slug': 'new_node',
            'layer': layer,
            'geometry': node.geometry
        })
        new_node.full_clean()
        new_node.save()
        
        layer.minimum_distance = 100
        layer.save()
        
        try:
            new_node.full_clean()
        except ValidationError as e:
            self.assertIn(_('Distance between nodes cannot be less than %s meters') % layer.minimum_distance, e.messages)
            return
        
        self.assertTrue(False, 'validation not working as expected')
    
    def test_layer_area_validation(self):
        """ ensure area validation works as expected """
        layer = Layer.objects.get(slug='rome')
        layer.area = GEOSGeometry('POLYGON ((12.19 41.92, 12.58 42.17, 12.82 41.86, 12.43 41.64, 12.43 41.65, 12.19 41.92))')
        layer.save()
        
        # creating node with same coordinates should not be an issue
        new_node = Node(**{
            'name': 'new_node',
            'slug': 'new_node',
            'layer': layer,
            'geometry': 'POINT (50.0 50.0)'
        })
        
        try:
            new_node.full_clean()
        except ValidationError as e:
            self.assertIn(_('Node must be inside layer area'), e.messages)
            return
        
        self.assertTrue(False, 'validation not working as expected')
    
    def test_layers_api(self,*args,**kwargs):
        """
        Layers endpoint should be reachable and return 404 if layer is not found.
        """
        layer = Layer.objects.get(pk=1)
        layer_slug = layer.slug
        fake_layer_slug = "idontexist"
        
        # api_layer list
        response = self.client.get(reverse('api_layer_list'))
        self.assertEqual(response.status_code, 200)
        
        # api's expecting slug in request,test with existing and fake slug
        # api_layer_detail
        response = self.client.get(reverse('api_layer_detail', args=[layer_slug]))
        self.assertEqual(response.status_code, 200)
        response = self.client.get(reverse('api_layer_detail', args=[fake_layer_slug]))
        self.assertEqual(response.status_code, 404)
        
        # api_layer_nodes
        response = self.client.get(reverse('api_layer_nodes_list', args=[layer_slug]))
        self.assertEqual(response.status_code, 200)
        response = self.client.get(reverse('api_layer_nodes_list', args=[fake_layer_slug]))
        self.assertEqual(response.status_code, 404)
        
        # api_layer_nodes_geojson
        response = self.client.get(reverse('api_layer_nodes_geojson', args=[layer_slug]))
        self.assertEqual(response.status_code, 200)
        response = self.client.get(reverse('api_layer_nodes_geojson', args=[fake_layer_slug]))
        self.assertEqual(response.status_code, 404)
        
    def test_layers_api_results(self,*args,**kwargs):
        """
        layers resources should return the expected number of objects
        """
        layer = Layer.objects.get(pk=1)
        layer_count = Layer.objects.all().count()
        layer_nodes = layer.node_set.count()
        layer_slug = layer.slug
        
        # api_layer list
        response = self.client.get(reverse('api_layer_list'))
        api_layer_count = len(response.data)
        self.assertEqual(api_layer_count, layer_count)
        
        # api_layer_nodes_list 
        response = self.client.get(reverse('api_layer_nodes_list', args=[layer_slug]))
        layer_public_nodes_count = Node.objects.filter(layer=layer).published().access_level_up_to('public').count()
        self.assertEqual(len(response.data['nodes']['results']), layer_public_nodes_count)
        
        # ensure number of elements is the expected, even by disabling layerinfo and pagination
        response = self.client.get(reverse('api_layer_nodes_list', args=[layer_slug]), { 'limit': 0, 'layerinfo': 'false' })
        self.assertEqual(len(response.data), layer_public_nodes_count)
        
        # api_layer_nodes_geojson
        response = self.client.get(reverse('api_layer_nodes_geojson', args=[layer_slug]), { 'limit': 0, 'layerinfo': 'true' })
        # each of 'features' values in geojson is a node
        self.assertEqual(len(response.data['nodes']['features']), layer_public_nodes_count)
        
        # test layer info geojson without layerinfo
        response = self.client.get(reverse('api_layer_nodes_geojson', args=[layer_slug]), { 'limit': 0 })
        # ensure "features" are at root level
        self.assertEqual(len(response.data['features']), layer_public_nodes_count)
        
    def test_layers_api_post(self):
        layer_count = Layer.objects.all().count()
        
        # POST to create, 400
        self.client.login(username='registered', password='tester')
        data = {
            "name": "test",
            "slug": "test", 
            "center": "POINT (38.1154075128999921 12.5107643007999929)", 
            "area": None
        }
        response = self.client.post(reverse('api_layer_list'), json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.assertEqual(layer_count, Layer.objects.all().count())
        
        # POST to create 200
        self.client.logout()
        self.client.login(username='admin', password='tester')
        response = self.client.post(reverse('api_layer_list'), json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(layer_count + 1, Layer.objects.all().count())
    
    def test_unpublish_layer_should_unpublish_nodes(self):
        layer = Layer.objects.first()
        layer.is_published = False
        layer.save()
        for node in layer.node_set.all():
            self.assertFalse(node.is_published)
        
        layer = Layer.objects.first()
        layer.is_published = True
        layer.save()
        for node in layer.node_set.all():
            self.assertTrue(node.is_published)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.core.layers.views',
    url(r'^layers/$', 'layer_list', name='api_layer_list'),
    url(r'^layers/(?P<slug>[-\w]+)/$', 'layer_detail', name='api_layer_detail'),
    url(r'^layers/(?P<slug>[-\w]+)/nodes/$', 'nodes_list', name='api_layer_nodes_list'),
    url(r'^layers/(?P<slug>[-\w]+)/nodes.geojson$', 'nodes_geojson_list', name='api_layer_nodes_geojson'),
    url(r'^layers.geojson$', 'layers_geojson_list', name='api_layer_geojson'),
)

########NEW FILE########
__FILENAME__ = views
from django.http import Http404
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from rest_framework import generics, permissions, authentication
from rest_framework.response import Response

from nodeshot.core.base.mixins import ListSerializerMixin
from nodeshot.core.base.utils import Hider
from nodeshot.core.nodes.views import NodeList
from nodeshot.core.nodes.serializers import NodeGeoSerializer

from .models import Layer
from .serializers import *

REVERSION_ENABLED = settings.NODESHOT['SETTINGS'].get('REVERSION_NODES', True)

if REVERSION_ENABLED:
    from nodeshot.core.base.mixins import RevisionCreate, RevisionUpdate
    
    class LayerListBase(RevisionCreate, generics.ListCreateAPIView):
        pass
    
    class LayerDetailBase(RevisionUpdate, generics.RetrieveUpdateAPIView):
        pass
else:
    class LayerListBase(generics.ListCreateAPIView):
        pass
    
    class LayerDetailBase(generics.RetrieveUpdateAPIView):
        pass


class LayerList(LayerListBase):
    """
    Retrieve list of all layers.
    
    ### POST
    
    Create new layer if authorized (admins and allowed users only).
    """
    model= Layer
    queryset = Layer.objects.published()
    permission_classes = (permissions.DjangoModelPermissionsOrAnonReadOnly, )
    authentication_classes = (authentication.SessionAuthentication,)
    serializer_class= LayerListSerializer
    pagination_serializer_class = PaginatedLayerListSerializer
    paginate_by_param = 'limit'
    paginate_by = None

layer_list = LayerList.as_view()


class LayerDetail(LayerDetailBase):
    """
    Retrieve details of specified layer.
    
    ### PUT & PATCH
    
    Edit specified layer
    """
    permission_classes = (permissions.DjangoModelPermissionsOrAnonReadOnly, )
    authentication_classes = (authentication.SessionAuthentication,)
    model= Layer
    queryset = Layer.objects.published()
    serializer_class= LayerDetailSerializer
    lookup_field = 'slug'

layer_detail = LayerDetail.as_view()

    
class LayerNodesList(ListSerializerMixin, NodeList):
    """  
    Retrieve list of nodes of the specified layer
    
    Parameters:
    
     * `search=<word>`: search <word> in name of nodes of specified layer
     * `limit=<n>`: specify number of items per page (defaults to 40)
     * `limit=0`: turns off pagination
     * `layerinfo`: true shows layer description and other info, false doesn't (defaults to true)
    """
    
    layer = None
    layer_info_default = True  # show layer info by default
    
    def get_layer(self):
        """ retrieve layer from DB """
        if self.layer:
            return
        try:
            self.layer = Layer.objects.get(slug=self.kwargs['slug'])
        except Layer.DoesNotExist:
            raise Http404(_('Layer not found'))
    
    def get_queryset(self):
        """ extend parent class queryset by filtering nodes of the specified layer """
        self.get_layer()
        return super(LayerNodesList, self).get_queryset().filter(layer_id=self.layer.id)
    
    def get_nodes(self, request, *args, **kwargs):
        """ this method might be overridden by other modules (eg: interoperability) """
        # ListSerializerMixin.list returns a serializer object
        return (self.list(request, *args, **kwargs)).data
    
    def get(self, request, *args, **kwargs):
        """ Retrieve list of nodes of the specified layer """
        self.get_layer()
        
        # get nodes of layer
        nodes = self.get_nodes(request, *args, **kwargs)
        
        # determine if layer info should be shown
        layer_info_default = str(self.layer_info_default).lower()  # convert boolean to string ("true" or "false")
        show_layer_info = (self.request.QUERY_PARAMS.get('layerinfo', layer_info_default) == 'true')  # is the get param true? if not is false
        
        # if layerinfo GET param is true show info about layer
        if show_layer_info:
            content = LayerNodeListSerializer(self.layer, context=self.get_serializer_context()).data
            content['nodes'] = self.get_nodes(request, *args, **kwargs)
        # otherwise just output nodes in GeoJSON format
        else:
            content = nodes
        
        return Response(content)
    
    post = Hider()

nodes_list = LayerNodesList.as_view()


class LayerNodesGeoJSONList(LayerNodesList):
    """
    Retrieve list of nodes of the specified layer in GeoJSON format.
    
    Parameters:
    
     * `search=<word>`: search <word> in name, slug, description and address of nodes
     * `limit=<n>`: specify number of items per page (defaults to 40)
     * `limit=0`: turns off pagination (default)
     * `layerinfo`: true shows layer description and other info, false doesn't (defaults to false)
    """
    
    serializer_class = NodeGeoSerializer
    paginate_by = 0
    layer_info_default = False  # don't show layer info by default
    
    def get(self, request, *args, **kwargs):
        """ Retrieve list of nodes of the specified layer in GeoJSON format. """
        # overwritten just to tweak the docstring for auto documentation purposes
        return super(LayerNodesGeoJSONList, self).get(request, *args, **kwargs)

nodes_geojson_list = LayerNodesGeoJSONList.as_view()


class LayerGeoJSONList(generics.ListAPIView):
    """
    Retrieve list of layers in GeoJSON format.
    Parameters:
    
     * `limit=<n>`: specify number of items per page (defaults to 40)
     * `limit=0`: turns off pagination
     * `page=<n>`: show page n
    """
    pagination_serializer_class = PaginatedGeojsonLayerListSerializer
    paginate_by_param = 'limit'
    paginate_by = 40
    serializer_class = GeoLayerListSerializer
    queryset = Layer.objects.published().exclude(area__isnull=True)

layers_geojson_list = LayerGeoJSONList.as_view()

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.db import models
from django.conf import settings

from nodeshot.core.nodes.models import *
from nodeshot.core.base.admin import BaseGeoAdmin, BaseStackedInline, PublishActionsAdminMixin
from nodeshot.core.base.widgets import AdvancedFileInput

REVERSION_ENABLED = settings.NODESHOT['SETTINGS'].get('REVERSION_NODES', True)

# enable django-reversion according to settings
if REVERSION_ENABLED:
    import reversion
    
    class GeoAdmin(BaseGeoAdmin, reversion.VersionAdmin):
        change_list_template = 'reversion_and_smuggler/change_list.html'
else:
    class GeoAdmin(BaseGeoAdmin):
        change_list_template = 'smuggler/change_list.html'


class ImageInline(BaseStackedInline):
    model = Image
    
    formfield_overrides = {
        models.ImageField: {'widget': AdvancedFileInput(image_width=250)},
    }
    
    if 'grappelli' in settings.INSTALLED_APPS:
        sortable_field_name = 'order'
        classes = ('grp-collapse grp-open', )


NODE_FILTERS = ['is_published', 'status', 'access_level', 'added', 'updated']
NODE_LIST_DISPLAY = ['name', 'user', 'status', 'access_level', 'is_published', 'added', 'updated']
NODE_FIELDS_LOOKEDUP = [
    'user__id', 'user__username',
    'status__id', 'status__name', 'status__is_default',
    'name', 'access_level', 'is_published', 'added', 'updated'
]

# include layer in filters if layers app installed
if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
    NODE_FILTERS.insert(0, 'layer')
    NODE_LIST_DISPLAY.insert(2, 'layer')
    NODE_FIELDS_LOOKEDUP += ['layer__id', 'layer__name']


class NodeAdmin(PublishActionsAdminMixin, GeoAdmin):
    list_display = NODE_LIST_DISPLAY
    list_filter = NODE_FILTERS
    list_select_related = True
    search_fields = ('name',)
    actions_on_bottom = True
    date_hierarchy = 'added'
    ordering = ('-id',)
    prepopulated_fields = {'slug': ('name',)}
    inlines = [ImageInline]
    
    # django-grappelli usability improvements
    raw_id_fields = ('layer', 'user')
    autocomplete_lookup_fields = {
        'fk': ('layer', 'user'),
    }
    
    def queryset(self, request):
        return super(NodeAdmin, self).queryset(request).select_related('user', 'layer', 'status')
    
    if settings.NODESHOT['SETTINGS'].get('NODE_DESCRIPTION_HTML', True) is True:  
        # enable editor for "node description" only
        html_editor_fields = ['description']


class StatusAdmin(admin.ModelAdmin):
    list_display  = ('name', 'slug', 'description', 'order', 'is_default')
    prepopulated_fields = {'slug': ('name',)}
    list_editable = ('order', )
    
    change_list_template = 'smuggler/change_list.html'


admin.site.register(Node, NodeAdmin)
admin.site.register(Status, StatusAdmin)

########NEW FILE########
__FILENAME__ = base
from django.utils.translation import ugettext_lazy as _
from rest_framework import serializers
from rest_framework_gis import serializers as geoserializers
from nodeshot.core.base.serializers import DynamicRelationshipsMixin


class ExtensibleNodeSerializer(DynamicRelationshipsMixin, geoserializers.GeoModelSerializer):
    """ node detail """
    user = serializers.Field(source='user.username')
    status = serializers.Field(source='status.slug')
    geometry = geoserializers.GeometryField(label=_('coordinates'))
    layer_name = serializers.Field(source='layer.name')
    access_level = serializers.Field(source='get_access_level_display')
    relationships = serializers.SerializerMethodField('get_relationships')
    
    # this is needed to avoid adding stuff to DynamicRelationshipsMixin
    _relationships = {}


########NEW FILE########
__FILENAME__ = 0001_initial
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Adding model 'Status'
        db.create_table('nodes_status', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('order', self.gf('django.db.models.fields.PositiveIntegerField')(blank=True)),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=75)),
            ('description', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('is_default', self.gf('django.db.models.fields.BooleanField')(default=False)),
        ))
        db.send_create_signal('nodes', ['Status'])

        # Adding model 'Node'
        db.create_table('nodes_node', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('added', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime(2014, 2, 24, 0, 0))),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime(2014, 2, 24, 0, 0))),
            ('access_level', self.gf('django.db.models.fields.SmallIntegerField')(default=0)),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=75)),
            ('slug', self.gf('django.db.models.fields.SlugField')(unique=True, max_length=75, blank=True)),
            ('status', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['nodes.Status'], null=True, blank=True)),
            ('is_published', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('layer', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['layers.Layer'])),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['profiles.Profile'], null=True, blank=True)),
            ('geometry', self.gf('django.contrib.gis.db.models.fields.GeometryField')()),
            ('elev', self.gf('django.db.models.fields.FloatField')(null=True, blank=True)),
            ('address', self.gf('django.db.models.fields.CharField')(max_length=150, null=True, blank=True)),
            ('description', self.gf('django.db.models.fields.TextField')(max_length=255, null=True, blank=True)),
            ('notes', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('data', self.gf(u'django_hstore.fields.DictionaryField')(null=True, blank=True)),
        ))
        db.send_create_signal('nodes', ['Node'])

        # Adding model 'Image'
        db.create_table('nodes_image', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('added', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime(2014, 2, 24, 0, 0))),
            ('updated', self.gf('django.db.models.fields.DateTimeField')(default=datetime.datetime(2014, 2, 24, 0, 0))),
            ('access_level', self.gf('django.db.models.fields.SmallIntegerField')(default=0)),
            ('order', self.gf('django.db.models.fields.PositiveIntegerField')(blank=True)),
            ('node', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['nodes.Node'])),
            ('file', self.gf('django.db.models.fields.files.ImageField')(max_length=100)),
            ('description', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
        ))
        db.send_create_signal('nodes', ['Image'])

        # Adding model 'StatusIcon'
        db.create_table('nodes_status_icon', (
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('status', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['nodes.Status'])),
            ('marker', self.gf('django.db.models.fields.CharField')(max_length=20)),
            ('layer', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['layers.Layer'], null=True, blank=True)),
            ('icon', self.gf('django.db.models.fields.files.ImageField')(max_length=100, null=True, blank=True)),
            ('background_color', self.gf('nodeshot.core.base.fields.RGBColorField')(max_length=7, blank=True)),
            ('foreground_color', self.gf('nodeshot.core.base.fields.RGBColorField')(max_length=7, blank=True)),
        ))
        db.send_create_signal('nodes', ['StatusIcon'])

        # Adding unique constraint on 'StatusIcon', fields ['status', 'layer']
        db.create_unique('nodes_status_icon', ['status_id', 'layer_id'])


    def backwards(self, orm):
        # Removing unique constraint on 'StatusIcon', fields ['status', 'layer']
        db.delete_unique('nodes_status_icon', ['status_id', 'layer_id'])

        # Deleting model 'Status'
        db.delete_table('nodes_status')

        # Deleting model 'Node'
        db.delete_table('nodes_node')

        # Deleting model 'Image'
        db.delete_table('nodes_image')

        # Deleting model 'StatusIcon'
        db.delete_table('nodes_status_icon')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'layers.layer': {
            'Meta': {'object_name': 'Layer'},
            'added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'area': ('django.contrib.gis.db.models.fields.PolygonField', [], {'null': 'True', 'blank': 'True'}),
            'center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'data': (u'django_hstore.fields.DictionaryField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '250', 'null': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_external': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_published': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'mantainers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['profiles.Profile']", 'symmetrical': 'False', 'blank': 'True'}),
            'minimum_distance': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '50'}),
            'new_nodes_allowed': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'organization': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'text': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'website': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'zoom': ('django.db.models.fields.SmallIntegerField', [], {'default': '12'})
        },
        'nodes.image': {
            'Meta': {'ordering': "['order']", 'object_name': 'Image'},
            'access_level': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'file': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'node': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['nodes.Node']"}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'})
        },
        'nodes.node': {
            'Meta': {'object_name': 'Node'},
            'access_level': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'address': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'data': (u'django_hstore.fields.DictionaryField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'elev': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_published': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'layer': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['layers.Layer']"}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '75'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '75', 'blank': 'True'}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['nodes.Status']", 'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['profiles.Profile']", 'null': 'True', 'blank': 'True'})
        },
        'nodes.status': {
            'Meta': {'ordering': "['order']", 'object_name': 'Status'},
            'description': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_default': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '75'})
        },
        'nodes.statusicon': {
            'Meta': {'unique_together': "(('status', 'layer'),)", 'object_name': 'StatusIcon', 'db_table': "'nodes_status_icon'"},
            'background_color': ('nodeshot.core.base.fields.RGBColorField', [], {'max_length': '7', 'blank': 'True'}),
            'foreground_color': ('nodeshot.core.base.fields.RGBColorField', [], {'max_length': '7', 'blank': 'True'}),
            'icon': ('django.db.models.fields.files.ImageField', [], {'max_length': '100', 'null': 'True', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'layer': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['layers.Layer']", 'null': 'True', 'blank': 'True'}),
            'marker': ('django.db.models.fields.CharField', [], {'max_length': '20'}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['nodes.Status']"})
        },
        'profiles.profile': {
            'Meta': {'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'address': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'birth_date': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'country': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'email': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'unique': 'True', 'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254', 'db_index': 'True'})
        }
    }

    complete_apps = ['nodes']
########NEW FILE########
__FILENAME__ = 0002_auto__del_statusicon__del_unique_statusicon_status_layer__add_field_st
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Removing unique constraint on 'StatusIcon', fields ['status', 'layer']
        db.delete_unique('nodes_status_icon', ['status_id', 'layer_id'])

        # Deleting model 'StatusIcon'
        db.delete_table('nodes_status_icon')

        # Adding field 'Status.stroke_width'
        db.add_column('nodes_status', 'stroke_width',
                      self.gf('django.db.models.fields.SmallIntegerField')(default=0),
                      keep_default=False)

        # Adding field 'Status.fill_color'
        db.add_column('nodes_status', 'fill_color',
                      self.gf('nodeshot.core.base.fields.RGBColorField')(default='', max_length=7, blank=True),
                      keep_default=False)

        # Adding field 'Status.stroke_color'
        db.add_column('nodes_status', 'stroke_color',
                      self.gf('nodeshot.core.base.fields.RGBColorField')(default='#000000', max_length=7, blank=True),
                      keep_default=False)

        # Adding field 'Status.text_color'
        db.add_column('nodes_status', 'text_color',
                      self.gf('nodeshot.core.base.fields.RGBColorField')(default='#FFFFFF', max_length=7, blank=True),
                      keep_default=False)


    def backwards(self, orm):
        # Adding model 'StatusIcon'
        db.create_table('nodes_status_icon', (
            ('status', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['nodes.Status'])),
            ('layer', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['layers.Layer'], null=True, blank=True)),
            ('marker', self.gf('django.db.models.fields.CharField')(max_length=20)),
            ('icon', self.gf('django.db.models.fields.files.ImageField')(max_length=100, null=True, blank=True)),
            ('background_color', self.gf('nodeshot.core.base.fields.RGBColorField')(max_length=7, blank=True)),
            (u'id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('foreground_color', self.gf('nodeshot.core.base.fields.RGBColorField')(max_length=7, blank=True)),
        ))
        db.send_create_signal('nodes', ['StatusIcon'])

        # Adding unique constraint on 'StatusIcon', fields ['status', 'layer']
        db.create_unique('nodes_status_icon', ['status_id', 'layer_id'])

        # Deleting field 'Status.stroke_width'
        db.delete_column('nodes_status', 'stroke_width')

        # Deleting field 'Status.fill_color'
        db.delete_column('nodes_status', 'fill_color')

        # Deleting field 'Status.stroke_color'
        db.delete_column('nodes_status', 'stroke_color')

        # Deleting field 'Status.text_color'
        db.delete_column('nodes_status', 'text_color')


    models = {
        u'auth.group': {
            'Meta': {'object_name': 'Group'},
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        u'auth.permission': {
            'Meta': {'ordering': "(u'content_type__app_label', u'content_type__model', u'codename')", 'unique_together': "((u'content_type', u'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': u"orm['contenttypes.ContentType']"}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        u'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'layers.layer': {
            'Meta': {'object_name': 'Layer'},
            'added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'area': ('django.contrib.gis.db.models.fields.PolygonField', [], {'null': 'True', 'blank': 'True'}),
            'center': ('django.contrib.gis.db.models.fields.PointField', [], {'null': 'True', 'blank': 'True'}),
            'data': (u'django_hstore.fields.DictionaryField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '250', 'null': 'True', 'blank': 'True'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_external': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_published': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'mantainers': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['profiles.Profile']", 'symmetrical': 'False', 'blank': 'True'}),
            'minimum_distance': ('django.db.models.fields.IntegerField', [], {'default': '0'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '50'}),
            'new_nodes_allowed': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'organization': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '50'}),
            'text': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'website': ('django.db.models.fields.URLField', [], {'max_length': '200', 'null': 'True', 'blank': 'True'}),
            'zoom': ('django.db.models.fields.SmallIntegerField', [], {'default': '12'})
        },
        'nodes.image': {
            'Meta': {'ordering': "['order']", 'object_name': 'Image'},
            'access_level': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'file': ('django.db.models.fields.files.ImageField', [], {'max_length': '100'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'node': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['nodes.Node']"}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'})
        },
        'nodes.node': {
            'Meta': {'object_name': 'Node'},
            'access_level': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'added': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'address': ('django.db.models.fields.CharField', [], {'max_length': '150', 'null': 'True', 'blank': 'True'}),
            'data': (u'django_hstore.fields.DictionaryField', [], {'null': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'elev': ('django.db.models.fields.FloatField', [], {'null': 'True', 'blank': 'True'}),
            'geometry': ('django.contrib.gis.db.models.fields.GeometryField', [], {}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_published': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'layer': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['layers.Layer']"}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '75'}),
            'notes': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '75', 'blank': 'True'}),
            'status': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['nodes.Status']", 'null': 'True', 'blank': 'True'}),
            'updated': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['profiles.Profile']", 'null': 'True', 'blank': 'True'})
        },
        'nodes.status': {
            'Meta': {'ordering': "['order']", 'object_name': 'Status'},
            'description': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'fill_color': ('nodeshot.core.base.fields.RGBColorField', [], {'max_length': '7', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_default': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'order': ('django.db.models.fields.PositiveIntegerField', [], {'blank': 'True'}),
            'slug': ('django.db.models.fields.SlugField', [], {'unique': 'True', 'max_length': '75'}),
            'stroke_color': ('nodeshot.core.base.fields.RGBColorField', [], {'default': "'#000000'", 'max_length': '7', 'blank': 'True'}),
            'stroke_width': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'text_color': ('nodeshot.core.base.fields.RGBColorField', [], {'default': "'#FFFFFF'", 'max_length': '7', 'blank': 'True'})
        },
        'profiles.profile': {
            'Meta': {'object_name': 'Profile'},
            'about': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'address': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'birth_date': ('django.db.models.fields.DateField', [], {'null': 'True', 'blank': 'True'}),
            'city': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'country': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime(2014, 2, 24, 0, 0)'}),
            'email': ('django.db.models.fields.EmailField', [], {'db_index': 'True', 'unique': 'True', 'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'gender': ('django.db.models.fields.CharField', [], {'max_length': '1', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            u'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': u"orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '254', 'db_index': 'True'})
        }
    }

    complete_apps = ['nodes']
########NEW FILE########
__FILENAME__ = image
import os

from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseOrderedACL
from nodeshot.core.base.managers import AccessLevelManager

from . import Node


class Image(BaseOrderedACL):
    """
    Images of a 'Node'
    """
    node = models.ForeignKey(Node, verbose_name=_('node'))
    file = models.ImageField(upload_to='nodes/', verbose_name=_('image'))
    description = models.CharField(_('description'), max_length=255, blank=True, null=True)
    
    # manager
    objects = AccessLevelManager()
    
    class Meta:
        db_table = 'nodes_image'
        app_label= 'nodes'
        permissions = (('can_view_image', 'Can view images'),)
        ordering = ['order']
    
    def __unicode__(self):
        return self.file.name
    
    def get_auto_order_queryset(self):
        """ overriding a BaseOrdered Abstract Model method """
        return self.__class__.objects.filter(node=self.node)
    
    def delete(self, *args, **kwargs):
        """ delete image when an image record is deleted """
        try:
            os.remove(self.file.file.name)
        # image does not exist
        except (OSError, IOError):
            pass
        
        super(Image, self).delete(*args, **kwargs)
    
########NEW FILE########
__FILENAME__ = node
from django.contrib.gis.db import models
from django.contrib.gis.geos.collections import GeometryCollection
from django.utils.translation import ugettext_lazy as _
from django.conf import settings
from django.template.defaultfilters import slugify

from nodeshot.core.base.models import BaseAccessLevel, BaseOrdered
from nodeshot.core.base.managers import HStoreGeoAccessLevelPublishedManager as NodeManager

from django_hstore.fields import DictionaryField

from ..signals import node_status_changed
from .status import Status

DEFAULT_NODE_PUBLISHED = settings.NODESHOT['DEFAULTS'].get('NODE_PUBLISHED', True)


class Node(BaseAccessLevel):
    """
    Nodes are generic geo-referenced records
    Can be assigned to 'Layers' if nodeshot.core.layers is installed
    Can belong to 'Users'
    """
    name = models.CharField(_('name'), max_length=75, unique=True)
    slug = models.SlugField(max_length=75, db_index=True, unique=True, blank=True)
    status = models.ForeignKey(Status, blank=True, null=True)
    is_published = models.BooleanField(default=DEFAULT_NODE_PUBLISHED)
    
    # TODO: find a way to move this in layers
    if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
        # layer might need to be able to be blank, would require custom validation
        layer = models.ForeignKey('layers.Layer')
    
    # owner, allow NULL
    user = models.ForeignKey(settings.AUTH_USER_MODEL, blank=True, null=True)
    
    # geographic information
    geometry = models.GeometryField(
        _('geometry'),
        help_text=_('geometry of the node (point, polygon, line)')
    )
    elev = models.FloatField(_('elevation'), blank=True, null=True)
    address = models.CharField(_('address'), max_length=150, blank=True, null=True)
    
    # descriptive information
    description = models.TextField(_('description'), max_length=255, blank=True, null=True)
    notes = models.TextField(_('notes'), blank=True, null=True,\
                             help_text=_('for internal use only'))
    
    data = DictionaryField(_('extra data'), null=True, blank=True,\
                           help_text=_('store extra attributes in JSON string'))
    
    # manager
    objects = NodeManager()
    
    # this is needed to check if the status is changing
    # explained here:
    # http://stackoverflow.com/questions/1355150/django-when-saving-how-can-you-check-if-a-field-has-changed
    _current_status = None
    
    # needed for extensible validation
    _additional_validation = []
    
    class Meta:
        db_table = 'nodes_node'
        app_label= 'nodes'
    
    def __unicode__(self):
        return '%s' % self.name
    
    def __init__(self, *args, **kwargs):
        """ Fill __current_status """
        super(Node, self).__init__(*args, **kwargs)
        # set current status, but only if it is an existing node
        if self.pk:
            self._current_status = self.status_id
    
    def clean(self , *args, **kwargs):
        """ call extensible validation """
        self.extensible_validation()
    
    def save(self, *args, **kwargs):
        """
        Custom save method does the following things:
            * converts geometry collections of just 1 item to that item (eg: a collection of 1 Point becomes a Point)
            * intercepts changes to status and fires node_status_changed signal
            * set default status
        """
        # auto generate slug
        if not self.slug:
            self.slug = slugify(self.name)
        
        # geometry collection check
        if isinstance(self.geometry, GeometryCollection) and 0 < len(self.geometry) < 2:
            self.geometry = self.geometry[0]
        
        # if no status specified
        if not self.status and not self.status_id:
            try:
                self.status = Status.objects.filter(is_default=True)[0]
            except IndexError:
                pass
        
        super(Node, self).save(*args, **kwargs)
        
        # if status of a node changes
        if (self.status and self._current_status and self.status.id != self._current_status) or\
            (self.status_id and self._current_status and self.status_id != self._current_status):
            # send django signal
            node_status_changed.send(
                sender=self.__class__,
                instance=self,
                old_status=Status.objects.get(pk=self._current_status),
                new_status=self.status
            )
        # update _current_status
        self._current_status = self.status_id
    
    def extensible_validation(self):
        """
        Execute additional validation that might be defined elsewhere in the code.
        Additional validation is introduced through the class method Node.add_validation_method()
        """
        # loop over additional validation method list
        for validation_method in self._additional_validation:
            # call each additional validation method
            getattr(self, validation_method)()
    
    @classmethod
    def add_validation_method(class_, method):
        """
        Extend validation of Node by adding a function to the _additional_validation list.
        The additional validation function will be called by the clean method
        
        :method function: function to be added to _additional_validation
        """
        method_name = method.func_name
        
        # add method name to additional validation method list
        class_._additional_validation.append(method_name)
        
        # add method to this class
        setattr(class_, method_name, method)
    
    @property
    def owner(self):
        return self.user
    
    @property
    def point(self):
        """ returns location of node. If node geometry is not a point a center  point will be returned """
        if not self.geometry:
            raise ValueError('geometry attribute must be set before trying to get point property')
        if self.geometry.geom_type == 'Point':
            return self.geometry
        else:
            try:
                # point_on_surface guarantees that the point is within the geometry
                return  self.geometry.point_on_surface
            except GEOSException:
                # fall back on centroid which may not be within the geometry
                # for example, a horseshoe shaped polygon
                return self.geometry.centroid
    
    if 'grappelli' in settings.INSTALLED_APPS:
        @staticmethod
        def autocomplete_search_fields():
            return ('name__icontains', 'slug__icontains', 'address__icontains')
    
    # some more properties are added by the layer app
    #  * intersecting_layers

########NEW FILE########
__FILENAME__ = status
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseOrdered
from nodeshot.core.base.fields import RGBColorField


class Status(BaseOrdered):
    """
    Status of a node, eg: active, potential, approved
    """
    name = models.CharField(_('name'), max_length=255,\
                            help_text=_('label for this status, eg: active, approved, proposed'))
    slug = models.SlugField(max_length=75, db_index=True, unique=True)
    description = models.CharField(_('description'), max_length=255,\
                                   help_text=_('this description will be used in the legend'))
    
    is_default = models.BooleanField(
        default=False,
        verbose_name=_('is default status?'),
        help_text=_('indicates whether this is the default status for new nodes;\
                    to change the default status to a new one just check and save,\
                    any other default will be automatically unchecked')
    )
    
    # map look and feel
    stroke_width = models.SmallIntegerField(
        blank=False,
        default=0,
        help_text=_('stroke of circles shown on map, set to 0 to disable')
    )
    fill_color = RGBColorField(_('fill colour'), blank=True)
    stroke_color = RGBColorField(_('stroke colour'), blank=True, default='#000000')
    text_color = RGBColorField(_('text colour'), blank=True, default='#FFFFFF')
    
    # needed to intercept changes to is_default
    _current_is_default = False
    
    class Meta:
        db_table = 'nodes_status'
        app_label= 'nodes'
        verbose_name = _('status')
        verbose_name_plural = _('status')
        ordering = ['order']
    
    def __unicode__(self):
        return self.name
    
    def __init__(self, *args, **kwargs):
        """ Fill _current_is_default """
        super(Status, self).__init__(*args, **kwargs)
        # set current is_default, but only if it is an existing status
        if self.pk:
            self._current_is_default = self.is_default
    
    def save(self, *args, **kwargs):
        """ intercepts changes to is_default """
        ignore_default_check = kwargs.pop('ignore_default_check', False)
        
        # if making this status the default one
        if self.is_default != self._current_is_default and self.is_default is True:
            # uncheck other default statuses first
            for status in self.__class__.objects.filter(is_default=True):
                status.is_default = False
                status.save(ignore_default_check=True)
        
        super(Status, self).save(*args, **kwargs)
        
        # in case there are no default statuses, make this one as the default one
        if self.__class__.objects.filter(is_default=True).count() == 0 and not ignore_default_check:
            self.is_default = True
            self.save()
        
        # update __current_status
        self._current_is_default = self.is_default
    
    @property
    def nodes_count(self):
        """ return number of published nodes with that status """
        return self.node_set.published().count()

########NEW FILE########
__FILENAME__ = permissions
from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    Object-level permission to only allow owners of an object to edit it.
    Assumes the model instance has an `owner` attribute.
    """

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request,
        # so we'll always allow GET, HEAD or OPTIONS requests.
        if request.method in permissions.SAFE_METHODS:
            return True
        
        action = ''
        
        if request.method in ['PUT', 'PATCH']:
            action = 'change'
        elif request.method in ['DELETE']:
            action = 'delete'
        elif request.method == 'POST':
            action = 'add'
        
        class_name = obj.__class__.__name__
        
        # if node
        if class_name == 'Node':
            owner = obj.user
        # if image
        elif class_name == 'Image':
            owner = obj.node.user
        
        # Instance must have an attribute named `owner`.
        return owner == request.user or request.user.has_perm('nodes.%s_%s' % (action, class_name.lower()))
########NEW FILE########
__FILENAME__ = serializers
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from rest_framework import serializers, pagination
from rest_framework.reverse import reverse
from rest_framework_gis import serializers as geoserializers

from nodeshot.core.base.serializers import GeoJSONPaginationSerializer
from .base import ExtensibleNodeSerializer
from .models import *

from nodeshot.core.base.fields import HStoreDictionaryField


__all__ = [
    'NodeListSerializer',
    'NodeCreatorSerializer',
    'NodeDetailSerializer',
    'NodeGeoSerializer',
    'PaginatedNodeListSerializer',
    'PaginatedGeojsonNodeListSerializer',
    'ImageListSerializer',
    'ImageAddSerializer',
    'ImageEditSerializer',
    'ImageRelationSerializer',
    'StatusListSerializer'
]

  
class NodeDetailSerializer(ExtensibleNodeSerializer):
    """ node detail """
    
    data = HStoreDictionaryField(required=False,
                                 label=_('extra data'),
                                 help_text=_('store extra attributes in JSON string'))
    
    layer = serializers.SlugRelatedField(slug_field='slug')
    
    class Meta:
        model = Node
        primary_fields = [
            'name', 'slug', 'status', 'user',
            'geometry', 'elev', 'address',
            'description', 'data'
        ]
            
        secondary_fields = [
            'access_level', 'layer', 'layer_name',
            'added', 'updated', 'relationships'
        ]
        
        fields = primary_fields + secondary_fields
        
        read_only_fields = ('added', 'updated')
        geo_field = 'geometry'


class NodeListSerializer(NodeDetailSerializer):
    """ node list """
    
    details = serializers.HyperlinkedIdentityField(view_name='api_node_details', slug_field='slug')
    
    class Meta:
        model = Node
        fields = [
            'name', 'slug', 'layer', 'layer_name', 'user', 'status',
            'geometry', 'elev', 'address', 'description', 'data',
            'updated', 'added', 'details'
        ]
        
        read_only_fields = ['added', 'updated']
        geo_field = 'geometry'
        id_field = 'slug'


class PaginatedNodeListSerializer(pagination.PaginationSerializer):
    class Meta:
        object_serializer_class = NodeListSerializer


class PaginatedGeojsonNodeListSerializer(GeoJSONPaginationSerializer):
    class Meta:
        object_serializer_class = NodeListSerializer
        

class NodeCreatorSerializer(NodeListSerializer):
    layer = serializers.WritableField(source='layer')


class NodeGeoSerializer(geoserializers.GeoFeatureModelSerializer, NodeListSerializer):
    pass


class ImageListSerializer(serializers.ModelSerializer):
    """ Serializer used to show list """
    
    file_url = serializers.SerializerMethodField('get_image_file')
    details = serializers.SerializerMethodField('get_uri')
    
    def get_image_file(self, obj):
        """ returns url to image file or empty string otherwise """
        url = ''
        
        if obj.file != '':
            url = '%s%s' % (settings.MEDIA_URL, obj.file)
        
        return url
    
    def get_uri(self, obj):
        """ returns uri of API image resource """
        args = {
            'slug': obj.node.slug,
            'pk': obj.pk
        }
        
        return reverse('api_node_image_detail', kwargs=args, request=self.context.get('request', None))
    
    class Meta:
        model = Image
        fields = (
            'id', 'file', 'file_url', 'description', 'order',
            'access_level', 'added', 'updated', 'details'
        )
        read_only_fields = ('added', 'updated')


class ImageAddSerializer(ImageListSerializer):
    """ Serializer for image creation """
    
    class Meta:
        model = Image
        fields = (
            'node', 'id', 'file', 'file_url', 'description', 'order',
            'access_level', 'added', 'updated', 'details'
        )


class ImageEditSerializer(ImageListSerializer):
    """ Serializer for image edit """
    
    class Meta:
        model = Image
        fields = ('id', 'file_url', 'description', 'order', 'access_level', 'added', 'updated', 'details')
        read_only_fields = ('file', 'added', 'updated')


class ImageRelationSerializer(ImageListSerializer):
    """ Serializer to reference images """
    
    class Meta:
        model = Image
        fields = ('id', 'file', 'file_url', 'description', 'added', 'updated')


ExtensibleNodeSerializer.add_relationship(
    'images',
    serializer=ImageRelationSerializer,
    many=True,
    queryset='obj.image_set.accessible_to(request.user).all()'
)


# --------- Status --------- #


class StatusListSerializer(serializers.ModelSerializer):
    """ status list """
    nodes_count = serializers.Field(source='nodes_count')
    
    class Meta:
        model = Status
        fields = [
            'name',
            'slug',
            'description',
            'is_default',
            'stroke_width',
            'fill_color',
            'stroke_color',
            'text_color',
            'nodes_count'
        ]

########NEW FILE########
__FILENAME__ = signals
import django.dispatch

node_status_changed = django.dispatch.Signal(providing_args=["instance", "old_status", "new_status"])
########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.core.nodes unit tests
"""

import os
import simplejson as json

from django.test import TestCase
from django.test.client import Client
from django.core.urlresolvers import reverse
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from django.contrib.auth.models import AnonymousUser
from django.contrib.gis.geos import GEOSGeometry
from django.contrib.gis.measure import D
from django.conf import settings
from django.contrib.auth import get_user_model
User = get_user_model()

from nodeshot.core.layers.models import Layer
from nodeshot.core.base.tests import user_fixtures, BaseTestCase

from .models import *


class ModelsTest(TestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_images.json'
    ]
    
    def test_status_model(self):
        """ test status model internal mechanism works correctly """
        for status in Status.objects.all():
            status.delete()
        
        testing = Status(name='testing', slug='testing', description='slug')
        testing.save()
        
        self.assertEqual(testing.order, 0)
        self.assertEqual(testing.is_default, True)
        
        active = Status(name='active', slug='active', description='active')
        active.save()
        
        self.assertEqual(active.order, 1)
        self.assertEqual(active.is_default, False)
        
        pending = Status(name='pending', slug='pending', description='pending')
        pending.save()
        
        self.assertEqual(pending.order, 2)
        self.assertEqual(pending.is_default, False)
        
        pending.is_default = True
        pending.save()
        
        default_statuses = Status.objects.filter(is_default=True)
        self.assertEqual(default_statuses.count(), 1)
        self.assertEqual(default_statuses[0].pk, pending.pk)
        
        unconfirmed = Status(name='unconfirmed', slug='unconfirmed', description='unconfirmed', is_default=True)
        unconfirmed.save()
        
        default_statuses = Status.objects.filter(is_default=True)
        self.assertEqual(default_statuses.count(), 1)
        self.assertEqual(default_statuses[0].pk, unconfirmed.pk)
    
    def test_current_status(self):
        """ test that node._current_status is none for new nodes """
        n = Node()
        self.failUnlessEqual(n._current_status, None, 'new node _current_status private attribute is different than None')
        n = Node.objects.all().order_by('-id')[0]
        self.failUnlessEqual(n._current_status, n.status.id, 'new node _current_status private attribute is different than status')
        n.status = Status.objects.get(pk=2)
        self.failIfEqual(n._current_status, n.status.id, 'new node _current_status private attribute is still equal to status')
        n.save()
        self.failUnlessEqual(n._current_status, n.status.id, 'new node _current_status private attribute is different than status')
        n.status_id = 3
        n.save()
        n = Node.objects.all().order_by('-id')[0]
        self.failUnlessEqual(n._current_status, n.status.id, 'new node _current_status private attribute is different than status')
    
    def test_node_manager(self):
        """ test manager methods of Node model """
        # published()
        Node.objects.published
        count = Node.objects.published().filter(layer=1).count()
        # no unplished nodes on that layer, so the count should be the same
        self.assertEqual(count, Node.objects.filter(layer=1).count())
        # unpublish the first
        node = Node.objects.published().filter(layer=1)[0]
        node.is_published = False
        node.save()
        # should be -1
        self.assertEqual(count-1, Node.objects.published().filter(layer=1).count())
        
        # Ensure GeoManager distance is available
        pnt = Node.objects.get(slug='pomezia').geometry
        Node.objects.filter(geometry__distance_lte=(pnt, 7000))
        
        # access level manager
        user = User.objects.get(pk=1, is_superuser=True)
        # superuser can see all nodes
        self.assertEqual(Node.objects.all().count(), Node.objects.accessible_to(user).count())
        # same but passing only user_id
        user_1 = User.objects.get(pk=1)
        self.assertEqual(Node.objects.all().count(), Node.objects.accessible_to(user_1).count())
        # simulate non authenticated user
        self.assertEqual(8, Node.objects.accessible_to(AnonymousUser()).count())
        # public nodes
        self.assertEqual(8, Node.objects.access_level_up_to('public').count())
        # public and registered
        self.assertEqual(9, Node.objects.access_level_up_to('registered').count())
        # public, registered and community
        self.assertEqual(10, Node.objects.access_level_up_to('community').count())
        
        ### --- START CHAINING! WOOOO --- ###
        # 9 because we unpublished one
        self.assertEqual(9, Node.objects.published().access_level_up_to('community').count())
        self.assertEqual(9, Node.objects.access_level_up_to('community').published().count())
        # user 1 is admin and can see all the nodes, published() is the same as writing filter(is_published=True)
        count = Node.objects.all().filter(is_published=True).count()
        self.assertEqual(count, Node.objects.published().accessible_to(user_1).count())
        self.assertEqual(count, Node.objects.accessible_to(user_1).published().count())
        # chain with geographic query
        count = Node.objects.all().filter(is_published=True).filter(layer_id=1).count()
        self.assertEqual(count, Node.objects.filter(geometry__distance_lte=(pnt, 70000)).accessible_to(user_1).published().count())
        self.assertEqual(count, Node.objects.accessible_to(user_1).filter(geometry__distance_lte=(pnt, 70000)).published().count())
        self.assertEqual(count, Node.objects.accessible_to(user_1).published().filter(geometry__distance_lte=(pnt, 70000)).count())
        self.assertEqual(count, Node.objects.filter(geometry__distance_lte=(pnt, 70000)).accessible_to(user_1).published().count())
        
        # slice, first, last, find
        self.assertEqual(Node.objects.last().__class__.__name__, 'Node')
        self.assertEqual(Node.objects.last(), Node.objects.order_by('-id')[0])
        
        self.assertEqual(Node.objects.first().__class__.__name__, 'Node')
        self.assertEqual(Node.objects.first(), Node.objects.order_by('id')[0])
        
        self.assertEqual(Node.objects.find(1), Node.objects.get(pk=1))
        
        self.assertEqual(list(Node.objects.slice('name', 5)), list(Node.objects.order_by('name')[0:5]))
        self.assertEqual(list(Node.objects.slice('-name', 5)), list(Node.objects.order_by('-name')[0:5]))
        
        # chained
        self.assertEqual(Node.objects.published().first(), Node.objects.filter(is_published=True).order_by('id')[0])
        self.assertEqual(Node.objects.published().last(), Node.objects.filter(is_published=True).order_by('-id')[0])
        
        self.assertEqual(
            Node.objects.published().access_level_up_to('public').first(),
            Node.objects.filter(is_published=True, access_level__lte=0).order_by('id')[0]
        )
        self.assertEqual(
            Node.objects.published().access_level_up_to('public').last(),
            Node.objects.filter(is_published=True, access_level__lte=0).order_by('-id')[0]
        )
    
    def test_autogenerate_slug(self):
        n = Node()
        n.name = 'Auto generate this'
        n.layer_id = 1
        n.geometry = 'POINT(12.509303756712 41.881163629853)'
        n.full_clean()
        
        n.save()
        
        n = Node.objects.get(pk=n.id)
        self.assertEqual(n.slug, 'auto-generate-this')
    
    def test_node_point(self):
        node = Node.objects.first()
        self.assertEqual(node.point, node.geometry)
        
        node = Node()
        with self.assertRaises(ValueError):
            node.point
    
    def test_image_manager(self):
        """ test manager methods of Image model """
        # admin can see all the images
        user_1 = User.objects.get(pk=1)
        self.assertEqual(Image.objects.all().count(), Image.objects.accessible_to(user_1).count())
    
    def test_image_auto_order(self):
        """ test image automatic ordering works correctly """
        # node #3 has already 2 images, therefore the new image auto order should be set to 2
        image = Image(node_id=3, file='test3.jpg')
        image.full_clean()
        image.save()
        self.assertEqual(image.order, 2)
        
        # node #2 does not have any image, therefore the new image auto order should be set to 0
        image = Image(node_id=2, file='test2.jpg')
        image.full_clean()
        image.save()
        self.assertEqual(image.order, 0)
    
    def test_geometry_collection_with_single_item(self):
        node = Node.objects.get(pk=1)
        node.geometry = GEOSGeometry("GEOMETRYCOLLECTION(POINT(12.509303756712 41.881163629853))")
        node.save()
        # fetch again cos geometry value is modified while saving
        node = Node.objects.get(pk=1)
        
        point = GEOSGeometry("POINT(12.509303756712 41.881163629853)")
        self.assertEqual(node.geometry, point)


### ------ API tests ------ ###


class APITest(BaseTestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_images.json'
    ]
    
    def test_node_list(self):
        """ test node list """
        url = reverse('api_node_list')
        
        # GET: 200
        response = self.client.get(url, { "limit": 0 })
        public_node_count = Node.objects.published().access_level_up_to('public').count()
        self.assertEqual(public_node_count, len(response.data['results']))
        
        node = {
            "layer": "rome",
            "name": "test distance", 
            "address": "via dei test",
            "description": "",
            "geometry": json.loads(GEOSGeometry("POINT (12.99 41.8720419277)").json),
            "data": { "is_test": True }
        }
        
        # POST: 403 - unauthenticated
        response = self.client.post(url, json.dumps(node), content_type='application/json')
        self.assertEqual(403, response.status_code)
        
        # POST: 201
        self.client.login(username='registered', password='tester')
        response = self.client.post(url, json.dumps(node), content_type='application/json')
        self.assertEqual(201, response.status_code)
        
        self.assertEqual(response.data['user'], 'registered')
        
        node = Node.objects.get(slug='test-distance')
        self.assertEqual(node.data, { 'is_test': 'true' })
        self.assertEqual(Node.objects.filter(data__contains={ "is_test": "true" }).count(), 1)
    
    def test_node_list_search(self):
        url = reverse('api_node_list')
        
        # GET: 200
        response = self.client.get(url, { "search": "Fusolab" })
        self.assertEqual(response.data['count'], 1)
    
    def test_delete_node(self):
        node = Node.objects.first()
        node.delete()
    
    def test_node_geojson_list(self):
        """ test node geojson list """
        url = reverse('api_node_gejson_list')
        
        # GET: 200
        response = self.client.get(url)
        self.assertEqual(200, response.status_code)
    
    def test_node_details(self):
        """ test node details """
        url = reverse('api_node_details', args=['fusolab'])
        
        # GET: 200
        response = self.client.get(url)
        self.assertEqual(200, response.status_code)
        node = response.data
        # images_url in node['images']
        self.assertTrue(isinstance(node['relationships']['images'], list))
        self.assertTrue(isinstance(node['relationships']['images'][0], dict))
        
        # PUT: 403 - must be logged in
        response = self.client.put(url)
        self.assertEqual(403, response.status_code)
        
        self.client.login(username='pisano', password='tester')
        # PUT: 403 - only owner can edit
        data = {
            "name": "Fusolab Rome test", 
            "slug": "fusolab", 
            "user": "romano",
            "elev": 80.0, 
            "address": "", 
            "description": "Fusolab test 2", 
            "access_level": "public",
            "layer": "rome",
            "geometry": json.loads(GEOSGeometry("POINT (12.582239191899999 41.872041927700003)").json)
        }
        response = self.client.put(url, json.dumps(data), content_type='application/json')
        self.assertEqual(403, response.status_code)
        
        self.client.logout()
        self.client.login(username='romano', password='tester')
        response = self.client.put(url, json.dumps(data), content_type='application/json')
        self.assertEqual(200, response.status_code)
        node = Node.objects.get(slug='fusolab')
        self.assertEqual(node.name, 'Fusolab Rome test')
        self.assertEqual(node.description, 'Fusolab test 2')
        
        # PATCH
        response = self.client.patch(url, { 'name': 'Patched Fusolab Name' })
        self.assertEqual(200, response.status_code)
        node = Node.objects.get(slug='fusolab')
        self.assertEqual(node.name, 'Patched Fusolab Name')
        self.client.logout()
        
        # CAN'T GET restricted if not authenticated
        fusolab = Node.objects.get(slug='fusolab')
        fusolab.access_level = 2
        fusolab.save()
        response = self.client.get(url)
        self.assertEqual(404, response.status_code)
        
        # Admin can get it
        self.client.login(username='admin', password='tester')
        response = self.client.get(url)
        self.assertEqual(200, response.status_code)
        
        # unpublished will return 404
        fusolab.is_published = False
        fusolab.save()
        response = self.client.get(url)
        self.assertEqual(404, response.status_code)
        
        fusolab.is_published = True
        fusolab.save()
        
        # DELETE 204
        response = self.client.delete(url)
        self.assertEqual(204, response.status_code)
        with self.assertRaises(Node.DoesNotExist):
            Node.objects.get(slug='fusolab')
    
    def test_node_images_relationship(self):
        url = reverse('api_node_details', args=['fusolab'])
        
        response = self.client.get(url)
        self.assertEqual(200, response.status_code)
        images = response.data['relationships']['images']
        public_image_count = Image.objects.access_level_up_to('public').filter(node__slug='fusolab').count()
        self.assertEqual(public_image_count, len(images))
        # admin can get more images
        self.client.login(username='admin', password='tester')
        response = self.client.get(url)
        images = response.data['relationships']['images']
        node_image_count = Image.objects.accessible_to(User.objects.get(pk=1)).filter(node__slug='fusolab').count()
        self.assertEqual(node_image_count, len(images))
    
    def test_node_images(self):
        """ test node images """
        url = reverse('api_node_images', args=['fusolab'])
        
        # GET: 200
        response = self.client.get(url)
        self.assertEqual(200, response.status_code)
        images = json.loads(response.content)
        public_image_count = Image.objects.access_level_up_to('public').filter(node__slug='fusolab').count()
        self.assertEqual(public_image_count, len(images))
        # admin can get more images
        self.client.login(username='admin', password='tester')
        response = self.client.get(url)
        images = json.loads(response.content)
        node_image_count = Image.objects.accessible_to(User.objects.get(pk=1)).filter(node__slug='fusolab').count()
        self.assertEqual(node_image_count, len(images))
        
        # GET: 404
        url = reverse('api_node_images', args=['idontexist'])
        response = self.client.get(url)
        self.assertEqual(404, response.status_code)
        
        # POST
        # todo
        login = self.client.login(username='admin', password='tester')
        good_post_data = { "description": "new image", "order": "" }
        bad_post_data = { "node": 100, "image": "jpeg99" ,"description" : "new image", "order": "" }
        url = reverse('api_node_images', args=['fusolab'])
        wrong_url = reverse('api_node_images', args=['idontexist'])
        
        # wrong slug -- 404
        response = self.client.post(wrong_url, good_post_data)
        self.assertEqual(response.status_code, 404)
        
        # correct POST data and correct slug -- 201
        with open("%s/templates/image_unit_test.gif" % os.path.dirname(os.path.realpath(__file__)), 'rb') as image_file:
            good_post_data['file'] = image_file
            response = self.client.post(url, good_post_data)
            self.assertEqual(response.status_code, 201)
            # ensure image name is in DB
            image = Image.objects.all().order_by('-id')[0]
            self.assertIn('image_unit_test', image.file.name)
            self.assertIn('.gif', image.file.name)
            # remove file
            os.remove(image.file.file.name)
        
        # POST 201 - ensure additional post data "user" and "node" are ignored
        with open("%s/templates/image_unit_test.gif" % os.path.dirname(os.path.realpath(__file__)), 'rb') as image_file:
            bad_post_data['file'] = image_file
            response = self.client.post(url, bad_post_data)
            self.assertEqual(response.status_code, 201)
            image_dict = json.loads(response.content)
            self.assertEqual(image_dict['node'], 1)
            self.assertEqual(image_dict['description'], "new image")
            # ensure image name is in DB
            image = Image.objects.all().order_by('-id')[0]
            self.assertIn('image_unit_test', image.file.name)
            # remove file
            os.remove(image.file.file.name)
        
        self.client.logout()
        self.client.login(username='pisano', password='tester')
        
        with open("%s/templates/image_unit_test.gif" % os.path.dirname(os.path.realpath(__file__)), 'rb') as image_file:
            good_post_data['file'] = image_file
            response = self.client.post(url, good_post_data)
            self.assertEqual(response.status_code, 403)
        
    def test_node_image_list_permissions(self):
        # GET protected image should return 404
        url = reverse('api_node_images', args=['hidden-rome'])
        response = self.client.get(url)
        self.assertEqual(404, response.status_code)
        
        self.client.login(username='admin', password='tester')
        response = self.client.get(url)
        self.assertEqual(200, response.status_code)
    
    def test_node_geometry_distance_and_area(self):
        """ test minimum distance check between nodes """
        self.client.login(username='admin', password='tester')
        
        url = reverse('api_node_list')
        
        json_data = {
            "layer": "rome",
            "name": "test_distance", 
            "slug": "test_distance", 
            "address": "via dei test", 
            "description": "",
            "geometry": json.loads(GEOSGeometry("POINT (12.5822391919000012 41.8720419276999820)").json), 
        }
        layer = Layer.objects.get(pk=1)
        layer.minimum_distance = 100
        layer.save()
        
        # Node coordinates don't respect minimum distance. Insert should fail because coords are near to already existing PoI ( fusolab )
        response = self.client.post(url, json.dumps(json_data), content_type='application/json')
        self.assertEqual(400, response.status_code)
        
        # Node coordinates respect minimum distance. Insert should succed
        json_data['geometry'] = json.loads(GEOSGeometry("POINT (12.7822391919 41.8720419277)").json);
        response = self.client.post(url, json.dumps(json_data), content_type='application/json')
        self.assertEqual(201, response.status_code)
        
        # Disable minimum distance control in layer and update node inserting coords too near. Insert should succed
        layer.minimum_distance = 0
        layer.save()
        json_data['geometry'] = json.loads(GEOSGeometry("POINT (12.5822391917 41.872042278)").json)
        n = Node.objects.get(slug='test_distance')
        node_slug = n.slug
        url = reverse('api_node_details', args=[node_slug])
        response = self.client.put(url, json.dumps(json_data), content_type='application/json')
        self.assertEqual(200, response.status_code)
        
        # re-enable minimum distance and update again with coords too near. Insert should fail
        layer.minimum_distance = 100
        layer.save()
        url = reverse('api_node_details', args=[node_slug])
        response = self.client.put(url, json.dumps(json_data), content_type='application/json')
        self.assertEqual(400, response.status_code)
        
        # Defining an area for the layer and testing if node is inside the area
        layer.area = GEOSGeometry('POLYGON ((12.19 41.92, 12.58 42.17, 12.82 41.86, 12.43 41.64, 12.43 41.65, 12.19 41.92))')
        layer.save()
        
        # Node update should fail because coords are outside layer area
        json_data['geometry'] = json.loads(GEOSGeometry("POINT (50 50)").json)
        url = reverse('api_node_details', args=[node_slug])
        response = self.client.put(url, json.dumps(json_data), content_type='application/json')
        self.assertEqual(400, response.status_code)
        
        # Node update should succeed because coords are inside layer area and respect minimum distance
        json_data['geometry'] = json.loads(GEOSGeometry("POINT (12.7822391919 41.8720419277)").json)
        url = reverse('api_node_details', args=[node_slug])
        response = self.client.put(url, json.dumps(json_data), content_type='application/json')
        self.assertEqual(200, response.status_code)
        
        # Node update should succeed because layer area is disabled
        layer.area = None
        layer.save()
        json_data['geometry'] = json.loads(GEOSGeometry("POINT (50 50)").json)
        url = reverse('api_node_details', args=[node_slug])
        response = self.client.put(url, json.dumps(json_data), content_type='application/json')
        self.assertEqual(200, response.status_code)
        
        # re-enable minimum distance 
        layer.minimum_distance = 100
        layer.save()
        
        # delete new nodes just added before
        n.delete()

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.core.nodes.views',
    url(r'^nodes/$', 'node_list', name='api_node_list'),
    url(r'^nodes.geojson$', 'geojson_list', name='api_node_gejson_list'),
    url(r'^nodes/(?P<slug>[-\w]+)/$', 'node_details', name='api_node_details'),
    
    # images
    url(r'^nodes/(?P<slug>[-\w]+)/images/$', 'node_images', name='api_node_images'),
    url(r'^nodes/(?P<slug>[-\w]+)/images/(?P<pk>[0-9]+)/$', 'node_image_detail', name='api_node_image_detail'),
    
    # status
    url(r'^status/$', 'status_list', name='api_status_list'),
)
########NEW FILE########
__FILENAME__ = views
from django.http import Http404
from django.utils.translation import ugettext_lazy as _
from django.utils.decorators import method_decorator
from django.views.decorators.cache import cache_page
from django.conf import settings
from django.db.models import Q, Count

from rest_framework import permissions, authentication, generics

from nodeshot.core.base.mixins import ACLMixin, CustomDataMixin
from nodeshot.core.base.utils import Hider

from .permissions import IsOwnerOrReadOnly
from .serializers import *
from .models import *

REVERSION_ENABLED = settings.NODESHOT['SETTINGS'].get('REVERSION_NODES', True)

if REVERSION_ENABLED:
    from nodeshot.core.base.mixins import RevisionCreate, RevisionUpdate
    
    class NodeListBase(ACLMixin, RevisionCreate, generics.ListCreateAPIView):
        pass
    
    class NodeDetailBase(ACLMixin, RevisionUpdate, generics.RetrieveUpdateDestroyAPIView):
        pass
else:
    class NodeListBase(ACLMixin, generics.ListCreateAPIView):
        pass
    
    class NodeDetailBase(ACLMixin, generics.RetrieveUpdateDestroyAPIView):
        pass


def get_queryset_or_404(queryset, kwargs):
    """
    Checks if object returned by queryset exists
    """
    # ensure exists
    try:
        obj = queryset.get(**kwargs)
    except Exception:
        raise Http404(_('Not found'))
    
    return obj


class NodeList(NodeListBase):
    """
    Retrieve list of all published nodes.
    
    Parameters:
    
     * `search=<word>`: search <word> in name, slug, description and address of nodes
     * `limit=<n>`: specify number of items per page (defaults to 50)
     * `limit=0`: turns off pagination
    
    ### POST
    
    Create a new node. Requires authentication.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    queryset = Node.objects.published()
    serializer_class = NodeListSerializer
    pagination_serializer_class = PaginatedNodeListSerializer
    paginate_by_param = 'limit'
    paginate_by = 50
    
    def pre_save(self, obj):
        """ automatically determine user on creation """
        if not obj.id:
            obj.user_id = self.request.user.id
    
    def get_queryset(self):
        """
        Optionally restricts the returned nodes
        by filtering against a `search` query parameter in the URL.
        """
        # retrieve all nodes which are published and accessible to current user
        # and use joins to retrieve related fields
        queryset = super(NodeList, self).get_queryset().select_related('layer', 'status', 'user')
        
        # retrieve value of querystring parameter "search"
        search = self.request.QUERY_PARAMS.get('search', None)
        
        if search is not None:
            search_query = (
                Q(name__icontains=search) |
                Q(slug__icontains=search) |
                Q(description__icontains=search) |
                Q(address__icontains=search)
            )
            # add instructions for search to queryset
            queryset = queryset.filter(search_query)
        
        return queryset
    
node_list = NodeList.as_view()
    
    
class NodeDetail(NodeDetailBase):
    """
    Retrieve details of specified node. Node must be published and accessible.
    
    ### DELETE
    
    Delete specified nodes. Must be authenticated as owner or admin.
    
    ### PUT & PATCH
    
    Edit node. Must be authenticated as owner or admin.
    """
    lookup_field = 'slug'
    model = Node
    serializer_class = NodeDetailSerializer
    authentication_classes = (authentication.SessionAuthentication, )
    permission_classes = (IsOwnerOrReadOnly, )
    queryset = Node.objects.published().select_related('user', 'layer')

node_details = NodeDetail.as_view()


class NodeGeoJSONList(NodeList):
    """
    Retrieve list of all published nodes in GeoJSON format.
    
    Parameters:
    
     * `search=<word>`: search <word> in name, slug, description and address of nodes
     * `limit=<n>`: specify number of items per page (defaults to 50)
     * `limit=0`: turns off pagination
     * `page=<n>`: show page n
    """
    pagination_serializer_class = PaginatedGeojsonNodeListSerializer
    paginate_by_param = 'limit'
    paginate_by = 50
    serializer_class = NodeGeoSerializer
    post = Hider()

geojson_list = NodeGeoJSONList.as_view()


# -------- Images -------- #


class NodeImageList(CustomDataMixin, generics.ListCreateAPIView):
    """
    Retrieve a list of images of the specified node.
    Node must exist and be published.
    
    ### POST
    
    Upload a new image.
    
    **Permissions:** only owner of a node can upload images.
    
    **Fields**:
    
     * `file`: binary file of the image, accepted file types are JPEG, PNG and GIF - **required**
     * `description`: description / caption of the image
     * `order`: order of the image, leave blank to set as last
     * `access_level`: determines who can see the image, defaults to public
    
    ### How do I upload an image?
    
    Set the content-type as **"multipart-formdata"** and send the file param as a binary stream.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    model = Image
    serializer_class = ImageListSerializer
    serializer_custom_class = ImageAddSerializer
    permission_classes = (IsOwnerOrReadOnly, )
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'node': self.node.id
        }
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure node exists and store it in an instance attribute
            * change queryset to return only images of current node
        """
        super(NodeImageList, self).initial(request, *args, **kwargs)
        
        # ensure node exists
        self.node = get_queryset_or_404(
            Node.objects.published().accessible_to(request.user),
            { 'slug': self.kwargs.get('slug', None) }
        )
        
        # check permissions on node (for image creation)
        self.check_object_permissions(request, self.node)
        
        # return only images of current node
        self.queryset = Image.objects.filter(node_id=self.node.id).accessible_to(self.request.user).select_related('node')

node_images = NodeImageList.as_view()


class ImageDetail(ACLMixin, generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve details of specified image.
    
    ### DELETE
    
    Delete specified nodes. Must be authenticated as owner or admin.
    
    ### PUT & PATCH
    
    Edit image.
    
    **Permissions:** only owner of a node can edit.
    
    Example of **JSON** representation that should be sent:
    
        {
            "description": "image caption", 
            "order": 3,
            "access_level": "public"
        }
    """
    model = Image
    queryset = Image.objects.all()
    serializer_class = ImageEditSerializer
    authentication_classes = (authentication.SessionAuthentication, )
    permission_classes = (IsOwnerOrReadOnly, )
    lookup_field = 'pk'
    
    def get_queryset(self):
        self.node = get_queryset_or_404(
            Node.objects.published().accessible_to(self.request.user),
            { 'slug': self.kwargs.get('slug', None) }
        )
        
        return super(ImageDetail, self).get_queryset().filter(node=self.node)

node_image_detail = ImageDetail.as_view()


# --------- Status ---------#


class StatusList(generics.ListAPIView):
    """
    Retrieve a list of all the available statuses and their relative icons/colors.
    """
    queryset = Status.objects.all()
    serializer_class = StatusListSerializer
    
    @method_decorator(cache_page(86400))  # cache for 1 day
    def dispatch(self, *args, **kwargs):
        return super(StatusList, self).dispatch(*args, **kwargs)
    
status_list = StatusList.as_view()

########NEW FILE########
__FILENAME__ = handlers
import uuid
import tornado.websocket


class WebSocketHandler(tornado.websocket.WebSocketHandler):
    """
    simple websocket server for bidirectional communication between client and server
    """
    
    # public means non authenticated
    # private means authenticated
    channels = {
        'public': {},
        'private': {}
    }
    
    def send_message(self, *args):
        """ alias to write_message """
        self.write_message(*args)
    
    def add_client(self, user_id=None):
        """
        Adds current instance to public or private channel.
        If user_id is specified it will be added to the private channel,
        If user_id is not specified it will be added to the public one instead.
        """
        if user_id is None:
            # generate a random uuid if it's an unauthenticated client
            self.channel = 'public'
            user_id = uuid.uuid1().hex
        else:
            self.channel = 'private'
        
        self.id = user_id
        self.channels[self.channel][self.id] = self
        print 'Client connected to the %s channel.' % self.channel
    
    def remove_client(self):
        """ removes a client """
        del self.channels[self.channel][self.id]
    
    @classmethod
    def broadcast(cls, message):
        """ broadcast message to all connected clients """
        clients = cls.get_clients()
        # loop over every client and send message
        for id, client in clients.iteritems():
            client.send_message(message)
    
    @classmethod
    def send_private_message(self, user_id, message):
        """
        Send a message to a specific client.
        Returns True if successful, False otherwise
        """
        try:
            client = self.channels['private'][str(user_id)]
        except KeyError:
            print '====debug===='
            print self.channels['private']
            print 'client with id %s not found' % user_id
            return False
        
        client.send_message(message)
        print 'message sent to client #%s' % user_id
        return True
    
    @classmethod
    def get_clients(self):
        """ return a merge of public and private clients """
        public = self.channels['public']
        private = self.channels['private']
        return dict(public.items() + private.items())
    
    def open(self):
        """ method which is called every time a new client connects """
        print 'Connection opened.'
        
        # retrieve user_id if specified
        user_id = self.get_argument("user_id", None)
        # add client to list of connected clients
        self.add_client(user_id)
        # welcome message
        self.send_message("Welcome to nodeshot websocket server.")
        # new client connected message
        client_count = len(self.get_clients().keys())
        new_client_message = 'New client connected, now we have %d %s!' % (client_count, 'client' if client_count <= 1 else 'clients')
        # broadcast new client connected message to all connected clients
        self.broadcast(new_client_message)
        
        print self.channels['private']

    def on_message(self, message):
        """ method which is called every time the server gets a message from a client """
        if message == "help":
            self.send_message("Need help, huh?")
        print 'Message received: \'%s\'' % message

    def on_close(self):
        """ method which is called every time a client disconnects """
        print 'Connection closed.'
        self.remove_client()
        
        client_count = len(self.get_clients().keys())
        new_client_message = '1 client disconnected, now we have %d %s!' % (client_count, 'client' if client_count <= 1 else 'clients')
        self.broadcast(new_client_message)

########NEW FILE########
__FILENAME__ = start_websocket_server
from django.core.management.base import BaseCommand

from nodeshot.core.websockets.server import start as start_server


class Command(BaseCommand):
    help = "Start Tornado WebSocket Server"

    def handle(self, *args, **options):
        """ Go baby go! """
        start_server()

########NEW FILE########
__FILENAME__ = models
"""
register websocket signals
"""

from django.conf import settings
from importlib import import_module


for registrar in settings.NODESHOT['WEBSOCKETS']['REGISTRARS']:
    import_module(registrar)
########NEW FILE########
__FILENAME__ = nodes
from django.db.models.signals import post_save, pre_delete
from django.dispatch import receiver
from django.conf import settings

from nodeshot.core.nodes.signals import node_status_changed
from nodeshot.core.nodes.models import Node

from ..tasks import send_message


# ------ NODE CREATED ------ #

@receiver(post_save, sender=Node)
def node_created_handler(sender, **kwargs):
    if kwargs['created']:
        obj = kwargs['instance']
        message = 'node "%s" has been added' % obj.name
        send_message.delay(message)

# ------ NODE STATUS CHANGED ------ #

@receiver(node_status_changed)
def node_status_changed_handler(**kwargs):
    obj = kwargs['instance']
    obj.old_status = kwargs['old_status'].name
    obj.new_status = kwargs['new_status'].name
    message = 'node "%s" changed its status from "%s" to "%s"' % (obj.name, obj.old_status, obj.new_status)
    send_message.delay(message)


# ------ NODE DELETED ------ #

@receiver(pre_delete, sender=Node)
def node_deleted_handler(sender, **kwargs):
    obj = kwargs['instance']
    message = 'node "%s" has been deleted' % obj.name
    send_message.delay(message)


# ------ DISCONNECT UTILITY ------ #

def disconnect():
    """ disconnect signals """
    post_save.disconnect(node_created_handler, sender=Node)
    node_status_changed.disconnect(node_status_changed_handler)
    pre_delete.disconnect(node_deleted_handler, sender=Node)


def reconnect():
    """ reconnect signals """
    post_save.connect(node_created_handler, sender=Node)
    node_status_changed.connect(node_status_changed_handler)
    pre_delete.connect(node_deleted_handler, sender=Node)


settings.NODESHOT['DISCONNECTABLE_SIGNALS'].append(
    {
        'disconnect': disconnect,
        'reconnect': reconnect
    }
)
########NEW FILE########
__FILENAME__ = notifications
import simplejson as json

from django.db.models.signals import post_save
from django.dispatch import receiver
from django.core.urlresolvers import reverse
from django.conf import settings

from nodeshot.community.notifications.models import Notification
from ..tasks import send_message


# ------ NEW NOTIFICATIONS ------ #

@receiver(post_save, sender=Notification)
def new_notification_handler(sender, **kwargs):
    if kwargs['created']:
        obj = kwargs['instance']
        message = {
            'user_id': str(obj.to_user.id),
            'model': 'notification',
            'type': obj.type,
            'url': reverse('api_notification_detail', args=[obj.id])
        }
        send_message(json.dumps(message), pipe='private')


# ------ DISCONNECT UTILITY ------ #

def disconnect():
    """ disconnect signals """
    post_save.disconnect(new_notification_handler, sender=Notification)


def reconnect():
    """ reconnect signals """
    post_save.connect(new_notification_handler, sender=Notification)


settings.NODESHOT['DISCONNECTABLE_SIGNALS'].append(
    {
        'disconnect': disconnect,
        'reconnect': reconnect
    }
)
########NEW FILE########
__FILENAME__ = server
import time
import simplejson as json
from threading import Thread

import tornado.web
import tornado.ioloop

from .handlers import WebSocketHandler
from . import ADDRESS, PORT, PUBLIC_PIPE, PRIVATE_PIPE  # contained in __init__.py


application = tornado.web.Application([
    (r'/', WebSocketHandler),
])


def public_broadcaster():
    """
    Thread which runs in parallel and constantly checks for new messages
    in the public pipe and broadcasts them publicly to all connected clients.
    """
    while __websocket_server_running__:
        pipein = open(PUBLIC_PIPE, 'r')
        line = pipein.readline().replace('\n', '').replace('\r', '')
        if line != '':
            WebSocketHandler.broadcast(line)
            print line
            
            remaining_lines = pipein.read()
            pipein.close()
            pipeout = open(PUBLIC_PIPE, 'w')
            pipeout.write(remaining_lines)
            pipeout.close()
        else:
            pipein.close()
        
        time.sleep(0.05)

public_broadcaster_thread = Thread(target=public_broadcaster, args=[])
public_broadcaster_thread.deamon = True


def private_messenger():
    """
    Thread which runs in parallel and constantly checks for new messages
    in the private pipe and sends them to the specific client.
    If client is not connected the message is discarded.
    """
    while __websocket_server_running__:
        pipein = open(PRIVATE_PIPE, 'r')
        line = pipein.readline().replace('\n', '').replace('\r', '')
        if line != '':
            message = json.loads(line)
            WebSocketHandler.send_private_message(user_id=message['user_id'],
                                                  message=message)
            print line
            
            remaining_lines = pipein.read()
            pipein.close()
            pipeout = open(PRIVATE_PIPE, 'w')
            pipeout.write(remaining_lines)
            pipeout.close()
        else:
            pipein.close()
        
        time.sleep(0.05)

private_messenger_thread = Thread(target=private_messenger, args=[])
private_messenger_thread.deamon = True


def start():    
    global __websocket_server_running__
    __websocket_server_running__ = True
    
    application.listen(PORT, address=ADDRESS)
    websocktserver = tornado.ioloop.IOLoop.instance()
    
    try:
        print "\nStarted Tornado Wesocket Server at ws://%s:%s\n" % (ADDRESS, PORT)
        
        public_broadcaster_thread.start()
        private_messenger_thread.start()
        websocktserver.start()
    # on exit
    except (KeyboardInterrupt, SystemExit):
        __websocket_server_running__ = False
        websocktserver.stop()
        
        print "\nStopped Tornado Wesocket Server\n"

########NEW FILE########
__FILENAME__ = tasks
from django.conf import settings
from celery import task


@task
def send_message(message, pipe='public'):
    """
    writes message to pipe
    """
    if pipe not in ['public', 'private']:
        raise ValueError('pipe argument can be only "public" or "private"')
    else:
        pipe = pipe.upper()
    
    pipe_path = settings.NODESHOT['WEBSOCKETS']['%s_PIPE' % pipe]
    
    # create file if it doesn't exist, append contents
    pipeout = open(pipe_path, 'a')
    
    pipeout.write('%s\n' % message)
    pipeout.close()

########NEW FILE########
__FILENAME__ = tests
from django.conf import settings

from nodeshot.core.base.tests import user_fixtures, BaseTestCase
from nodeshot.core.nodes.models import Node

from django.core import management


class TestWebsockets(BaseTestCase):
    """
    Test WebSockets
    """
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
    ]
    
    def test_start_websocket_server(self):
        self.assertTrue(False, 'TODO')
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url
from django.conf import settings


urlpatterns = patterns('',)


if settings.DEBUG:
    urlpatterns += patterns('nodeshot.core.websockets.views',
        url(r'^test/$', 'test', name='websocket_test'),
    )

########NEW FILE########
__FILENAME__ = views
from django.shortcuts import render_to_response
from django.template import RequestContext

from . import DOMAIN, PORT  # contained in __init__.py


def test(request):
    context = {
        'DOMAIN': DOMAIN,
        'PORT': PORT
    }
    return render_to_response('test.html', context,
                              context_instance=RequestContext(request))
########NEW FILE########
__FILENAME__ = dashboard
"""
This file was generated with the customdashboard management command and
contains the class for the main dashboard.

To activate your index dashboard add the following to your settings.py::
    GRAPPELLI_INDEX_DASHBOARD = 'nodeshot.dashboard.CustomIndexDashboard'
"""

from django.utils.translation import ugettext_lazy as _
from django.core.urlresolvers import reverse
from django.conf import settings

from grappelli.dashboard import modules, Dashboard
from grappelli.dashboard.utils import get_admin_site_name

USER_APPS = ['django.contrib.*']
if 'nodeshot.community.profiles' in settings.INSTALLED_APPS:
    USER_APPS.append('nodeshot.community.profiles.*')


class NodeshotDashboard(Dashboard):
    """
    Custom index dashboard for www.
    """
    
    def init_with_context(self, context):
        site_name = get_admin_site_name(context)
        
        self.children.append(modules.AppList(
            _('Nodeshot Core'),
            collapsible=True,
            column=1,
            models=('nodeshot.core.*',),
        ))
        
        self.children.append(modules.AppList(
            _('Nodeshot Networking'),
            collapsible=True,
            column=1,
            models=('nodeshot.networking.*',),
        ))
        
        self.children.append(modules.AppList(
            _('Nodeshot Community'),
            collapsible=True,
            column=1,
            models=('nodeshot.community.*',),
        ))
        
        self.children.append(modules.AppList(
            _('Administration'),
            collapsible=True,
            column=2,
            models=USER_APPS,
        ))
        
        # append a recent actions module
        self.children.append(modules.RecentActions(
            _('Recent Actions'),
            limit=5,
            collapsible=False,
            column=2,
        ))
        
        # append another link list module for "support".
        self.children.append(modules.LinkList(
            _('Media Management'),
            column=3,
            children=[
                {
                    'title': _('FileBrowser'),
                    'url': '/admin/filebrowser/browse/',
                    'external': False,
                },
            ]
        ))
        
        # append another link list module for "support".
        self.children.append(modules.LinkList(
            _('Support'),
            column=3,
            children=[
                {
                    'title': _('Django Documentation'),
                    'url': 'http://docs.djangoproject.com/',
                    'external': True,
                },
                {
                    'title': _('Grappelli Documentation'),
                    'url': 'http://packages.python.org/django-grappelli/',
                    'external': True,
                },
            ]
        ))

########NEW FILE########
__FILENAME__ = choices
from django.conf import settings
from django.utils.translation import ugettext_lazy as _


ROUTING_PROTOCOLS = (
    ('aodv','AODV'),
    ('batman','B.A.T.M.A.N.'),
    ('dsdv','DSDV'),
    ('dsr','DSR'),
    ('hsls','HSLS'),
    ('iwmp','IWMP'),
    ('olsr','OLSR'),
    ('oorp','OORP'),
    ('ospf','OSPF'),
    ('tora','TORA'),
)

DEFAULT_ROUTING_PROTOCOL = 'olsr'
ACTIVATION_DAYS = 7
DEFAULT_FROM_EMAIL = getattr(settings, 'DEFAULT_FROM_EMAIL', False)

SITE = {
    'name': 'Nodeshot',
    'domain': 'http://test.test.com'
}

NODE_STATUS = (
    ('p', _('potential')),
    ('a', _('active')),
    ('h', _('hotspot')),
    ('ah', _('active & hotspot')),
    ('u', _('unconfirmed')), # nodes that have not been confirmed via email yet
)

INTERFACE_TYPE = (
    ('wifi', _('wifi')),
    ('eth', _('ethernet')),
    ('vpn', _('vpn')),
    ('batman', _('batman')),
    ('bridge', _('bridge')),
    ('vwifi', _('virtual-wifi')),
    ('veth', _('virtual-ethernet'))
)

INTERFACE_STATUS = (
    ('r', _('reachable')),
    ('u', _('unreachable'))
)

WIRELESS_MODE = (
    ('sta', _('station')),
    ('ap', _('access point')),
    ('adhoc', _('adhoc')),
)

WIRELESS_POLARITY = (
    ('h', _('horizontal')),
    ('v', _('vertical')),
    ('c', _('circular')),
    ('a', _('auto')),
)

WIRELESS_CHANNEL = (
    ('2412', '2.4Ghz Ch  1 (2412 Mhz)'),
    ('2417', '2.4Ghz Ch  2 (2417 Mhz)'),
    ('2422', '2.4Ghz Ch  3 (2422 Mhz)'),
    ('2427', '2.4Ghz Ch  4 (2427 Mhz)'),
    ('2427', '2.4Ghz Ch  5 (2432 Mhz)'),
    ('2437', '2.4Ghz Ch  6 (2437 Mhz)'),
    ('2442', '2.4Ghz Ch  7 (2442 Mhz)'),
    ('2447', '2.4Ghz Ch  8 (2447 Mhz)'),
    ('2452', '2.4Ghz Ch  9 (2452 Mhz)'),
    ('2457', '2.4Ghz Ch  10 (2457 Mhz)'),
    ('2462', '2.4Ghz Ch  11 (2462 Mhz)'),
    ('2467', '2.4Ghz Ch  12 (2467 Mhz)'),
    ('2472', '2.4Ghz Ch  13 (2472 Mhz)'),
    ('2484', '2.4Ghz Ch  14 (2484 Mhz)'),
    ('4915', '5Ghz Ch 183 (4915 Mhz)'),
    ('4920', '5Ghz Ch 184 (4920 Mhz)'),
    ('4925', '5Ghz Ch 185 (4925 Mhz)'),
    ('4935', '5Ghz Ch 187 (4935 Mhz)'),
    ('4940', '5Ghz Ch 188 (4940 Mhz)'),
    ('4945', '5Ghz Ch 189 (4945 Mhz)'),
    ('4960', '5Ghz Ch 192 (4960 Mhz)'),
    ('4980', '5Ghz Ch 196 (4980 Mhz)'),
    ('5035', '5Ghz Ch 7 (5035 Mhz)'),
    ('5040', '5Ghz Ch 8 (5040 Mhz)'),
    ('5045', '5Ghz Ch 9 (5045 Mhz)'),
    ('5055', '5Ghz Ch 11 (5055 Mhz)'),
    ('5060', '5Ghz Ch 12 (5060 Mhz)'),
    ('5080', '5Ghz Ch 16 (5080 Mhz)'),
    ('5170', '5Ghz Ch 34 (5170 Mhz)'),
    ('5180', '5Ghz Ch 36 (5180 Mhz)'),
    ('5190', '5Ghz Ch 38 (5190 Mhz)'),
    ('5200', '5Ghz Ch 40 (5200 Mhz)'),
    ('5210', '5Ghz Ch 42 (5210 Mhz)'),
    ('5220', '5Ghz Ch 44 (5220 Mhz)'),
    ('5230', '5Ghz Ch 46 (5230 Mhz)'),
    ('5240', '5Ghz Ch 48 (5240 Mhz)'),
    ('5260', '5Ghz Ch 52 (5260 Mhz)'),
    ('5280', '5Ghz Ch 56 (5280 Mhz)'),
    ('5300', '5Ghz Ch 60 (5300 Mhz)'),
    ('5320', '5Ghz Ch 64 (5320 Mhz)'),
    ('5500', '5Ghz Ch 100 (5500 Mhz)'),
    ('5520', '5Ghz Ch 104 (5520 Mhz)'),
    ('5540', '5Ghz Ch 108 (5540 Mhz)'),
    ('5560', '5Ghz Ch 112 (5560 Mhz)'),
    ('5580', '5Ghz Ch 116 (5580 Mhz)'),
    ('5600', '5Ghz Ch 120 (5600 Mhz)'),
    ('5620', '5Ghz Ch 124 (5620 Mhz)'),
    ('5640', '5Ghz Ch 128 (5640 Mhz)'),
    ('5660', '5Ghz Ch 132 (5660 Mhz)'),
    ('5680', '5Ghz Ch 136 (5680 Mhz)'),
    ('5700', '5Ghz Ch 140 (5700 Mhz)'),
    ('5745', '5Ghz Ch 149 (5745 Mhz)'),
    ('5765', '5Ghz Ch 153 (5765 Mhz)'),
    ('5785', '5Ghz Ch 157 (5785 Mhz)'),
    ('5805', '5Ghz Ch 161 (5805 Mhz)'),
    ('5825', '5Ghz Ch 165 (5825 Mhz)')
)
########NEW FILE########
__FILENAME__ = db
"""
Django database routers are described here:
https://docs.djangoproject.com/en/dev/topics/db/multi-db/#using-routers
"""


class DefaultRouter(object):
    def db_for_read(self, model, **hints):
        """
        Reads from nodeshot2 db
        """
        if model._meta.app_label != 'oldimporter':
            return 'default'
        return None

    def db_for_write(self, model, **hints):
        """
        Writes to nodeshot2 db
        """
        if model._meta.app_label != 'oldimporter':
            return 'default'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """
        Relations between objects are allowed between nodeshot2 objects only
        """
        if obj1._meta.app_label != 'oldimporter' and \
           obj2._meta.app_label != 'oldimporter':
           return True
        return None

    def allow_syncdb(self, db, model):
        """
        Make sure the old_nodeshot app only appears in the 'old_nodeshot' database
        """
        if db != 'old_nodeshot' and model._meta.app_label != 'oldimporter':
            return True
        return None
    
    allow_migrate = allow_syncdb


class OldNodeshotRouter(object):
    def db_for_read(self, model, **hints):
        """
        Reads old nodeshot models from old_nodeshot db.
        """
        if model._meta.app_label == 'oldimporter':
            return 'old_nodeshot'
        return None

    def db_for_write(self, model, **hints):
        """
        Writes not allowed
        """
        if model._meta.app_label == 'oldimporter':
            return 'old_nodeshot'
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """
        Relations between objects are allowed between old_nodeshot objects only
        """
        if obj1._meta.app_label == 'oldimporter' and \
           obj2._meta.app_label == 'oldimporter':
           return True
        return None

    def allow_syncdb(self, db, model):
        """
        Make sure the old_nodeshot app only appears in the 'old_nodeshot' database
        """
        if db != 'old_nodeshot' or model._meta.app_label != 'oldimporter':
            return False
        return True
    
    allow_migrate = allow_syncdb

########NEW FILE########
__FILENAME__ = import_old_nodeshot
import sys
import string
import random
import traceback
from optparse import make_option

from netaddr import ip

from django.core.management.base import BaseCommand, CommandError
from django.db import transaction
from django.db.models import Q
from django.core.exceptions import ImproperlyConfigured
from django.contrib.gis.geos import Point
from django.utils.text import slugify
from django.conf import settings
from django.contrib.contenttypes.models import ContentType
from django.contrib.auth import get_user_model
User = get_user_model()

if 'emailconfirmation' in settings.INSTALLED_APPS:
    EMAIL_ADDRESS_APP_INSTALLED = True
    from emailconfirmation.models import EmailAddress
else:
    EMAIL_ADDRESS_APP_INSTALLED = False

# TODO: this check is useless because nodeshot.core.layer is required as a dependency!
if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
    from nodeshot.core.layers.models import Layer
    LAYER_APP_INSTALLED = True
else:
    LAYER_APP_INSTALLED = False

from nodeshot.core.base.utils import pause_disconnectable_signals, resume_disconnectable_signals
from nodeshot.core.nodes.models import Node, Status
from nodeshot.networking.net.models import *
from nodeshot.networking.net.models.choices import INTERFACE_TYPES
from nodeshot.networking.links.models import Link
from nodeshot.networking.links.models.choices import LINK_STATUS, LINK_TYPES, METRIC_TYPES
from nodeshot.community.mailing.models import Inward
from nodeshot.extra.oldimporter.models import *


class Command(BaseCommand):
    """
    Will try to import data from old nodeshot.

    Requirements for settings:
        * nodeshot.extra.oldimporter must be in INSTALLED_APPS
        * old_nodeshot database must be configured
        * database routers directives must be uncommented

    Steps:

    1.  Retrieve all nodes
        Retrieve all nodes from old db and convert queryset in a python list.

    2.  Extract user data from nodes

        (Since in old nodeshot there are no users but each node contains data
        such as name, email, and stuff like that)

            * loop over nodes and extract a list of unique emails
            * each unique email will be a new user in the new database
            * each new user will have a random password set
            * save users, email addresses

    3.  Import nodes

            * USER: assign owner (the link is the email)
            * LAYER: assign layer (layers must be created by hand first!):
                1. if node has coordinates comprised in a specified layer choose that
                2. if node has coordinates comprised in more than one layer prompt the user which one to choose
                3. if node does not have coordinates comprised in any layer:
                    1. use default layer if specified (configured in settings)
                    2. discard the node if no default layer specified
            * STATUS: assign status depending on configuration:
                settings.NODESHOT['OLD_IMPORTER']['STATUS_MAPPING'] must be a dictionary in which the
                key is the old status value while the value is the new status value
                if settings.NODESHOT['OLD_IMPORTER']['STATUS_MAPPING'] is False the default status will be used
            * HOSTPOT: if status is hotspot or active and hotspot add this info in HSTORE data field

    4.  Import devices
        Create any missing routing protocol

    5.  Import interfaces, ip addresses, vaps

    6.  Import links

    7.  Import Contacts

    TODO: Decide what to do with statistics and hna.
    """
    help = 'Import old nodeshot data. Layers and Status must be created first.'

    status_mapping = settings.NODESHOT['OLD_IMPORTER'].get('STATUS_MAPPING', False)
    # if no default layer some nodes might be discarded
    default_layer = settings.NODESHOT['OLD_IMPORTER'].get('DEFAULT_LAYER', False)

    old_nodes = []
    saved_users = []
    saved_nodes = []
    saved_devices = []
    routing_protocols_added = []
    saved_interfaces = []
    saved_vaps = []
    saved_ipv4 = []
    saved_ipv6 = []
    saved_links = []
    saved_contacts = []

    option_list = BaseCommand.option_list + (
        make_option(
            '--noinput',
            action='store_true',
            dest='noinput',
            default=False,
            help='Do not prompt for user intervention and use default settings'
        ),
        make_option(
            '--nodelete',
            action='store_false',
            dest='nodelete',
            default=False,
            help='Do not delete imported data if any uncaught exception occurs'
        ),
    )

    def message(self, message):
        self.stdout.write('%s\n\r' % message)

    def verbose(self, message):
        if self.verbosity == 2:
            self.message(message)

    def handle(self, *args, **options):
        """ execute synchronize command """
        self.options = options
        delete = False

        try:
            # blank line
            self.stdout.write('\r\n')
            # store verbosity level in instance attribute for later use
            self.verbosity = int(options.get('verbosity'))

            self.verbose('disabling signals (notififcations, websocket alerts)')
            pause_disconnectable_signals()

            self.check_status_mapping()
            self.retrieve_nodes()
            self.extract_users()
            self.import_users()
            self.import_nodes()
            self.import_devices()
            self.import_interfaces()
            self.import_links()
            self.import_contacts()

            self.confirm_operation_completed()

            resume_disconnectable_signals()
            self.verbose('re-enabling signals (notififcations, websocket alerts)')

        except KeyboardInterrupt:
            self.message('\n\nOperation cancelled...')
            delete = True
        except Exception as e:
            tb = traceback.format_exc()
            delete = True
            # rollback database transaction
            transaction.rollback()
            self.message('Got exception:\n\n%s' % tb)

        if delete:
            self.delete_imported_data()

    def confirm_operation_completed(self):
        # if noinput param do not ask for confirmatin
        if self.options.get('noinput') is True:
            return

        self.message("Are you satisfied with the results? If not all imported data will be deleted\n\n[Y/n]")

        while True:
            answer = raw_input().lower()
            if answer == '':
                answer = "y"

            if answer in ['y', 'n']:
                break
            else:
                self.message("Please respond with one of the valid answers\n")

        if answer == 'n':
            self.delete_imported_data()
        else:
            self.message('Operation completed!')

    def delete_imported_data(self):
        if options.get('nodelete') is True:
            self.message('--nodelete option specified, won\'t delete the imported data')
            return

        self.message('Going to delete all the imported data...')

        for interface in self.saved_interfaces:
            try:
                interface.delete()
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Got exception while deleting interface %s\n\n%s' % (interface.mac, tb))

        for device in self.saved_devices:
            try:
                device.delete()
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Got exception while deleting device %s\n\n%s' % (device.name, tb))

        for routing_protocol in self.routing_protocols_added:
            try:
                routing_protocol.delete()
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Got exception while deleting routing_protocol %s\n\n%s' % (routing_protocol.name, tb))

        for node in self.saved_nodes:
            try:
                node.delete()
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Got exception while deleting node %s\n\n%s' % (node.name, tb))

        for contact in self.saved_contacts:
            try:
                contact.delete()
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Got exception while deleting contact log entry %s\n\n%s' % (contact.id, tb))

        for user in self.saved_users:
            try:
                user.delete()
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Got exception while deleting user %s\n\n%s' % (user.username, tb))

    def prompt_layer_selection(self, node, layers):
        """Ask user what to do when an old node is contained in more than one layer.
        Possible answers are:
            * use default layer (default answer if pressing enter)
            * choose layer
            * discard node
        """
        valid = {
            "default": "default",
            "def":     "default",
            "discard": "discard",
            "dis":     "discard",
        }
        question = """Cannot automatically determine layer for node "%s" because there \
are %d layers available in that area, what do you want to do?\n\n""" % (node.name, len(layers))

        available_layers = ""
        for layer in layers:
            available_layers += "%d (%s)\n" % (layer.id, layer.name)
            valid[str(layer.id)] = layer.id

        prompt = """\
choose (enter the number of) one of the following layers:
%s
"default"    use default layer (if no default layer specified in settings node will be discarded)
"discard"    discard node

(default action is to use default layer)\n\n""" % available_layers

        sys.stdout.write(question + prompt)

        while True:
            if options.get('noinput') is True:
                answer = 'default'
                break

            answer = raw_input().lower()
            if answer == '':
                answer = "default"

            if answer in valid:
                answer = valid[answer]
                break
            else:
                sys.stdout.write("Please respond with one of the valid answers\n")

        sys.stdout.write("\n")
        return answer

    @classmethod
    def generate_random_password(cls, size=10, chars=string.ascii_uppercase+string.digits):
        return ''.join(random.choice(chars) for x in range(size))

    def check_status_mapping(self):
        """ ensure status map does not contain status values which are not present in DB """
        self.verbose('checking status mapping...')

        if not self.status_mapping:
            self.message('no status mapping found')
            return

        for old_val, new_val in self.status_mapping.iteritems():
            try:
                # look up by slug if new_val is string
                if isinstance(new_val, basestring):
                    lookup = { 'slug': new_val }
                # lookup by primary key otherwise
                else:
                    lookup = { 'pk': new_val }
                status = Status.objects.get(**lookup)
                self.status_mapping[old_val] = status.id
            except Status.DoesNotExist:
                raise ImproperlyConfigured('Error! Status with slug %s not found in the database' % new_val)

        self.verbose('status map correct')

    def get_status(self, value):
        return self.status_mapping.get(value, self.status_mapping['default'])

    def retrieve_nodes(self):
        """ retrieve nodes from old mysql DB """
        self.verbose('retrieving nodes from old mysql DB...')

        self.old_nodes = list(OldNode.objects.all())
        self.message('retrieved %d nodes' % len(self.old_nodes))

    def extract_users(self):
        """ extract user info """
        email_set = set()
        users_dict = {}

        self.verbose('going to extract user information from retrieved nodes...')

        for node in self.old_nodes:
            email_set.add(node.email)

            if not users_dict.has_key(node.email):
                users_dict[node.email] = {
                    'owner': node.owner
                }

        self.email_set = email_set
        self.users_dict = users_dict

        self.verbose('%d users extracted' % len(email_set))

    def import_users(self):
        """ save users to local DB """
        self.message('saving users into local DB')

        saved_users = []

        # loop over all extracted unique email addresses
        for email in self.email_set:
            owner = self.users_dict[email].get('owner')

            # if owner is not specified, build username from email
            if owner.strip() == '':
                owner, domain = email.split('@')
                # replace any points with a space
                owner = owner.replace('.', ' ')

            # if owner has a space, assume he specified first and last name
            if ' ' in owner:
                owner_parts = owner.split(' ')
                first_name = owner_parts[0]
                last_name = owner_parts[1]
            else:
                first_name = owner
                last_name = ''

            # username must be slugified otherwise won't get into the DB
            username = slugify(owner)

            # check if user exists first
            try:
                user = User.objects.get(username=username)
            # otherwise init new
            except User.DoesNotExist:
                user = User()
                # generate new password only for new users
                user.password = self.generate_random_password()

            # we'll create one user for each unique email address we've got
            user.username = username
            user.first_name = first_name.capitalize()
            user.last_name = last_name.capitalize()
            user.email = email
            user.is_active = True

            # extract date joined from old nodes
            # find the oldest node of this user
            oldest_node = OldNode.objects.filter(email=email).order_by('added')[0]
            user.date_joined = oldest_node.added

            # be sure username is unique
            counter = 1
            original_username = username
            while True:
                # do this check only if user is new
                if not user.pk and User.objects.filter(username=user.username).count() > 0:
                    counter += 1
                    user.username = '%s%d' % (original_username, counter)
                else:
                    break

            try:
                # validate data and save
                user.full_clean()
                user.save()
                # store id
                self.users_dict[email]['id'] = user.id
                # append to saved users
                saved_users.append(user)
                self.verbose('Saved user %s (%s) with email <%s>' % (user.username, user.get_full_name(), user.email))
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Could not save user %s, got exception:\n\n%s' % (user.username, tb))

            # mark email address as confirmed if feature is enabled
            if EMAIL_ADDRESS_APP_INSTALLED and EmailAddress.objects.filter(email=user.email).count() is 0:
                try:
                    email_address = EmailAddress(user=user, email=user.email, verified=True, primary=True)
                    email_address.full_clean()
                    email_address.save()
                except Exception as e:
                    tb = traceback.format_exc()
                    self.message('Could not save email address for user %s, got exception:\n\n%s' % (user.username, tb))

        self.message('saved %d users into local DB' % len(saved_users))
        self.saved_users = saved_users

    def import_nodes(self):
        """ import nodes into local DB """
        self.message('saving nodes into local DB...')

        saved_nodes = []

        # loop over all old node and create new nodes
        for old_node in self.old_nodes:
            # if this old node is unconfirmed skip to next cycle
            if old_node.status == 'u':
                continue

            try:
                node = Node.objects.get(pk=old_node.id)
            except Node.DoesNotExist:
                node = Node(id=old_node.id)
                node.data = {}

            node.user_id = self.users_dict[old_node.email]['id']
            node.name = old_node.name
            node.slug = old_node.slug
            node.geometry = Point(old_node.lng, old_node.lat)
            node.elev = old_node.alt
            node.description = old_node.description
            node.notes = old_node.notes
            node.added = old_node.added
            node.updated = old_node.updated

            if LAYER_APP_INSTALLED:
                intersecting_layers = node.intersecting_layers
                # if more than one intersecting layer
                if len(intersecting_layers) > 1:
                    # prompt user
                    answer = self.prompt_layer_selection(node, intersecting_layers)
                    if isinstance(answer, int):
                        node.layer_id = answer
                    elif answer == 'default' and self.default_layer is not False:
                        node.layer_id = self.default_layer
                    else:
                        self.message('Node %s discarded' % node.name)
                        continue
                # if one intersecting layer select that
                elif 2 > len(intersecting_layers) > 0:
                    node.layer = intersecting_layers[0]
                # if no intersecting layers
                else:
                    if self.default_layer is False:
                        # discard node if no default layer specified
                        self.message("""Node %s discarded because is not contained
                                     in any specified layer and no default layer specified""" % node.name)
                        continue
                    else:
                        node.layer_id = self.default_layer

            if old_node.postal_code:
                # additional info
                node.data['postal_code'] = old_node.postal_code

            # is it a hotspot?
            if old_node.status in ['h', 'ah']:
                node.data['is_hotspot'] = 'true'

            # determine status according to settings
            if self.status_mapping:
                node.status_id = self.get_status(old_node.status)

            try:
                node.full_clean()
                node.save(auto_update=False)
                saved_nodes.append(node)
                self.verbose('Saved node %s in layer %s with status %s' % (node.name, node.layer, node.status.name))
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Could not save node %s, got exception:\n\n%s' % (node.name, tb))

        self.message('saved %d nodes into local DB' % len(saved_nodes))
        self.saved_nodes = saved_nodes

    def import_devices(self):
        self.verbose('retrieving devices from old mysql DB...')
        self.old_devices = list(OldDevice.objects.all())
        self.message('retrieved %d devices' % len(self.old_devices))

        saved_devices = []
        routing_protocols_added = []

        for old_device in self.old_devices:
            try:
                device = Device.objects.get(pk=old_device.id,)
            except Device.DoesNotExist:
                device = Device(id=old_device.id)

            device.node_id = old_device.node_id
            device.type = "radio"
            device.name = old_device.name
            device.description = old_device.description
            device.added = old_device.added
            device.updated = old_device.updated
            device.data = {
                "model": old_device.type,
                "cname": old_device.cname
            }

            try:
                device.full_clean()
                device.save(auto_update=False)
                saved_devices.append(device)
                self.verbose('Saved device %s' % device.name)
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Could not save device %s, got exception:\n\n%s' % (device.name, tb))

            try:
                routing_protocol = RoutingProtocol.objects.filter(name__icontains=old_device.routing_protocol)[0]
            except IndexError:
                routing_protocol = RoutingProtocol.objects.create(name=old_device.routing_protocol)
                routing_protocols_added.append(routing_protocol)
            device.routing_protocols.add(routing_protocol)

        self.message('saved %d devices into local DB' % len(saved_devices))
        self.saved_devices = saved_devices
        self.routing_protocols_added = routing_protocols_added

    def import_interfaces(self):
        self.verbose('retrieving interfaces from old mysql DB...')
        self.old_interfaces = list(OldInterface.objects.all())
        self.message('retrieved %d interfaces' % len(self.old_interfaces))

        saved_interfaces = []
        saved_vaps = []
        saved_ipv4 = []
        saved_ipv6 = []

        for old_interface in self.old_interfaces:
            interface_dict = {
                "id": old_interface.id,
                "device_id": int(old_interface.device_id),
                "mac": old_interface.mac_address,
                "name": old_interface.cname[0:10],
                "added": old_interface.added,
                "updated": old_interface.updated,
                "data": {}
            }
            vap = None
            ipv4 = None
            ipv6 = None

            # determine interface type and specific fields
            if old_interface.type == 'eth':
                interface_dict['standard'] = 'fast'
                interface_dict['duplex'] = 'full'
                InterfaceModel = Ethernet
            elif old_interface.type == 'wifi':
                interface_dict['mode'] = old_interface.wireless_mode
                interface_dict['channel'] = old_interface.wireless_channel
                InterfaceModel = Wireless
                # determine ssid
                if old_interface.essid or old_interface.bssid:
                    vap = Vap(**{
                        "interface_id": old_interface.id,
                        "essid": old_interface.essid,
                        "bssid": old_interface.bssid
                    })
                    # if vap already exists flag it for UPDATE instead of INSERT
                    try:
                        v = Vap.objects.get(
                            Q(interface_id=old_interface.id) & (
                                Q(essid=old_interface.essid) |
                                Q(bssid=old_interface.bssid)
                            )
                        )
                        # trick to make django do an update query instead of an insert
                        # working on django 1.6
                        vap.id = v.id
                        vap._state.adding = False
                    except Vap.DoesNotExist:
                        pass
                if old_interface.essid:
                    interface_dict['data']['essid'] = old_interface.essid
                if old_interface.bssid:
                    interface_dict['data']['bssid'] = old_interface.bssid
            elif old_interface.type == 'bridge':
                InterfaceModel = Bridge
            elif old_interface.type == 'vpn':
                InterfaceModel = Tunnel
            else:
                interface_dict['type'] = INTERFACE_TYPES.get('virtual')
                interface_dict['data']['old_nodeshot_interface_type'] = old_interface.get_type_display()
                InterfaceModel = Interface

            interface = InterfaceModel(**interface_dict)
            # if interface already exists flag it for UPDATE instead of INSERT
            try:
                InterfaceModel.objects.get(pk=old_interface.id)
                interface._state.adding = False
            except InterfaceModel.DoesNotExist:
                pass

            if old_interface.ipv4_address:
                old_interface.ipv4_address = old_interface.ipv4_address.strip()  # stupid django bug
                ipv4 = Ip(**{
                    "interface_id": old_interface.id,
                    "address": old_interface.ipv4_address
                })
                # if ip already exists flag it for UPDATE instead of INSERT
                try:
                    ipv4.id = Ip.objects.get(address=old_interface.ipv4_address).id
                    ipv4._state.adding = False
                except Ip.DoesNotExist:
                    pass
                # ensure ipv4 is valid
                try:
                    ip.IPAddress(old_interface.ipv4_address)
                except (ip.AddrFormatError, ValueError):
                    self.message('Invalid IPv4 address %s' % (old_interface.ipv4_address))
                    ipv4 = None

            if old_interface.ipv6_address:
                old_interface.ipv6_address = old_interface.ipv6_address.strip()  # stupid django bug
                ipv6 = Ip(**{
                    "interface_id": old_interface.id,
                    "address": old_interface.ipv6_address
                })
                # if ip already exists flag it for UPDATE instead of INSERT
                try:
                    ipv6.id = Ip.objects.get(address=old_interface.ipv6_address).id
                    ipv6._state.adding = False
                except Ip.DoesNotExist:
                    pass
                # ensure ipv6 is valid
                try:
                    ip.IPAddress(old_interface.ipv6_address)
                except (ip.AddrFormatError, ValueError):
                    self.message('Invalid IPv6 address %s' % (old_interface.ipv6_address))
                    ipv6 = None

            try:
                interface.full_clean()
                interface.save(auto_update=False)
                saved_interfaces.append(interface)
                self.verbose('Saved interface %s' % interface.name)
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Could not save interface %s, got exception:\n\n%s' % (interface.mac, tb))
                continue

            if vap:
                try:
                    vap.full_clean()
                    vap.save()
                    saved_vaps.append(vap)
                    self.verbose('Saved vap %s' % vap.essid or vap.bssid)
                except Exception as e:
                    tb = traceback.format_exc()
                    self.message('Could not save vap %s, got exception:\n\n%s' % (vap.essid or vap.bssid, tb))

            if ipv4:
                try:
                    ipv4.full_clean()
                    ipv4.save()
                    saved_ipv4.append(ipv4)
                    self.verbose('Saved ipv4 %s' % ipv4.address)
                except Exception as e:
                    tb = traceback.format_exc()
                    self.message('Could not save ipv4 %s, got exception:\n\n%s' % (ipv4.address, tb))

            if ipv6:
                try:
                    ipv6.full_clean()
                    ipv6.save()
                    saved_ipv6.append(ipv6)
                    self.verbose('Saved ipv6 %s' % ipv6.address)
                except Exception as e:
                    tb = traceback.format_exc()
                    self.message('Could not save ipv6 %s, got exception:\n\n%s' % (ipv6.address, tb))

        self.message('saved %d interfaces into local DB' % len(saved_interfaces))
        self.message('saved %d vaps into local DB' % len(saved_vaps))
        self.message('saved %d ipv4 addresses into local DB' % len(saved_ipv4))
        self.message('saved %d ipv6 addresses into local DB' % len(saved_ipv6))
        self.saved_interfaces = saved_interfaces
        self.saved_vaps = saved_vaps
        self.saved_ipv4 = saved_ipv4
        self.saved_ipv6 = saved_ipv6

    def import_links(self):
        self.verbose('retrieving links from old mysql DB...')
        self.old_links = list(OldLink.objects.all())
        self.message('retrieved %d links' % len(self.old_links))

        saved_links = []

        for old_link in self.old_links:

            skip = False

            try:
                interface_a = Interface.objects.get(pk=old_link.from_interface_id)
                if interface_a.type != INTERFACE_TYPES.get('wireless'):
                    interface_a.type = INTERFACE_TYPES.get('wireless')
                    interface_a.save()
            except Interface.DoesNotExist:
                self.message('Interface #%s does not exist, probably link #%s is orphan!' % (old_link.from_interface_id, old_link.id))
                skip = True

            try:
                interface_b = Interface.objects.get(pk=old_link.to_interface_id)
                if interface_b.type != INTERFACE_TYPES.get('wireless'):
                    interface_b.type = INTERFACE_TYPES.get('wireless')
                    interface_b.save()
            except Interface.DoesNotExist:
                self.message('Interface #%s does not exist, probably link #%s is orphan!' % (old_link.to_interface_id, old_link.id))
                skip = True

            if skip:
                self.verbose('Skipping to next cycle')
                continue

            old_bandwidth = [old_link.sync_tx, old_link.sync_rx]

            link = Link(**{
                "id": old_link.id,
                "interface_a": interface_a,
                "interface_b": interface_b,
                "status": LINK_STATUS.get('active'),
                "type": LINK_TYPES.get('radio'),
                "metric_type": 'etx',
                "metric_value": old_link.etx,
                "dbm": old_link.dbm,
                "min_rate": min(old_bandwidth),
                "max_rate": max(old_bandwidth),
            })
            # if link already exists flag it for UPDATE instead of INSERT
            try:
                Link.objects.get(pk=old_link.id)
                link._state.adding = False
            except Link.DoesNotExist:
                pass

            if old_link.hide:
                link.access_level = 3

            try:
                link.full_clean()
                link.save()
                saved_links.append(link)
                self.verbose('Saved link %s' % link)
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Could not save link %s, got exception:\n\n%s' % (old_link.id, tb))

        self.message('saved %d links into local DB' % len(saved_links))
        self.saved_links = saved_links

    def import_contacts(self):
        self.verbose('retrieving contact log from old mysql DB...')
        self.old_contacts = list(OldContact.objects.all())
        self.message('retrieved %d entries from contact log' % len(self.old_contacts))

        saved_contacts = []

        content_type = ContentType.objects.only('id', 'model').get(app_label='nodes', model='node')

        for old_contact in self.old_contacts:

            contact = Inward(**{
                "id": old_contact.id,
                "content_type": content_type,
                "object_id": old_contact.node_id,
                "status": 1,  # sent
                "from_name": old_contact.from_name,
                "from_email": old_contact.from_email,
                "message": old_contact.message,
                "ip": old_contact.ip,
                "user_agent": old_contact.user_agent,
                "accept_language": old_contact.accept_language,
                "added": old_contact.date,
                "updated": old_contact.date,
            })

            # if contact already exists flag it for UPDATE instead of INSERT
            try:
                Inward.objects.get(pk=old_contact.id)
                contact._state.adding = False
            except Inward.DoesNotExist:
                pass

            try:
                contact.full_clean()
                contact.save(auto_update=False)
                saved_contacts.append(contact)
                self.verbose('Saved contact log entry #%s' % contact.id)
            except Exception as e:
                tb = traceback.format_exc()
                self.message('Could not save contact log entry %s, got exception:\n\n%s' % (old_contact.id, tb))

        self.message('saved %d entries of contact log into local DB' % len(saved_contacts))
        self.saved_contacts = saved_contacts

########NEW FILE########
__FILENAME__ = models
# -*- coding: utf-8 -*-
"""
this app can import data from older nodeshot versions (0.9)
developed to import data from map.ninux.org into the new version of nodeshot
"""

from nodeshot.core.base.utils import check_dependencies

check_dependencies(
    dependencies=[
        'nodeshot.core.nodes',
        'nodeshot.core.layers',
        'nodeshot.networking.net',
        'nodeshot.networking.links',
        'nodeshot.community.mailing',
        'nodeshot.community.profiles',
    ],
    module='nodeshot.extra.oldimporter'
)

from django.db import models
from django.utils.translation import ugettext_lazy as _

from .choices import *


__all__ = [
    'OldNode',
    'OldDevice',
    'OldHna',
    'OldInterface',
    'OldLink',
    'OldStatistic',
    'OldContact',
]


class OldNode(models.Model):
    name = models.CharField(_('name'), max_length=50, unique=True)
    slug = models.SlugField(max_length=50, db_index=True, unique=True)
    owner = models.CharField(_('owner'), max_length=50, blank=True, null=True)
    description = models.CharField(_('description'), max_length=200, blank=True, null=True)
    postal_code = models.CharField(_('postal code'), max_length=10, blank=True)
    email = models.EmailField()
    email2 = models.EmailField(blank=True, null=True)
    email3 = models.EmailField(blank=True, null=True)
    password =  models.CharField(max_length=255, help_text=_('Use "[algo]$[salt]$[hexdigest]" or use the  <a href="password/">change password form</a>.'))
    lat = models.FloatField(_('latitude'))
    lng = models.FloatField(_('longitude')) 
    alt = models.FloatField(_('altitude'), blank=True, null=True)
    status = models.CharField(_('status'), max_length=3, choices=NODE_STATUS, default='p')
    activation_key = models.CharField(_('activation key'), max_length=40, blank=True, null=True, help_text=_('Key needed for activation of the node. It\'s deleted once the node is activated.'))
    notes = models.TextField(_('notes'), blank=True, null=True)
    added = models.DateTimeField(_('added on'), auto_now_add=True)
    updated = models.DateTimeField(_('updated on'), auto_now=True)
    
    def get_lat(self):
        """ returns latitude as string (avoid django converting the dot . into a comma , in certain language sets) """
        return str(self.lat)
        
    def get_lng(self):
        """ returns longitude as string (avoid django converting the dot . into a comma , in certain language sets) """
        return str(self.lng)    
    
    def __unicode__(self):
        return u'%s' % (self.name)
    
    class Meta:
        verbose_name = _('Node')
        verbose_name_plural = _('Nodes')
        db_table = 'nodeshot_node'


class OldDevice(models.Model):
    name = models.CharField(_('name'), max_length=50, unique=True)
    cname = models.SlugField(_('CNAME'), help_text=_('Name used for DNS resolution. Example: grid1 becomes grid1.nodename.domain.org. If left empty device name is used as default.'), max_length=30, blank=True, null=True)
    description = models.CharField(_('description'), max_length=255, blank=True, null=True)
    type = models.CharField(_('type'), max_length=50, blank=True, null=True) 
    node = models.ForeignKey(OldNode, verbose_name=_('node'))
    routing_protocol = models.CharField(_('routing protocol'), max_length=20, choices=ROUTING_PROTOCOLS, default=DEFAULT_ROUTING_PROTOCOL)
    routing_protocol_version = models.CharField(_('routing protocol version'), max_length=10, blank=True, null=True)
    added = models.DateTimeField(_('added on'), auto_now_add=True)
    updated = models.DateTimeField(_('updated on'), auto_now=True)
    
    def __unicode__(self):
        return self.name
    
    class Meta:
        unique_together = (('node', 'cname'),)
        verbose_name = _('OldDevice')
        verbose_name_plural = _('OldDevices')
        db_table = 'nodeshot_device'


class OldHna(models.Model):
    device = models.ForeignKey(OldDevice)
    route = models.CharField(max_length=43)
    
    def __unicode__(self):
        return u'%s' % (self.route)
        
    class Meta:
        verbose_name = _('Hna')
        verbose_name_plural = _('Hna')
        db_table = 'nodeshot_hna'


class OldInterface(models.Model):
    ipv4_address = models.IPAddressField(verbose_name=_('ipv4 address'), blank=True, null=True, unique=True, default=None)
    ipv6_address = models.GenericIPAddressField(protocol='IPv6', verbose_name=_('ipv6 address'), blank=True, null=True, unique=True, default=None)
    mac_address = models.CharField(max_length=17, blank=True, null=True, unique=True, default=None)
    type = models.CharField(max_length=10, choices=INTERFACE_TYPE)
    cname = models.SlugField(_('cname'), help_text=_('Name used for DNS resolution. Example: eth0 becomes eth0.devicecname.nodename.domain.org. If left empty the interface type is used as default.'), max_length=30, blank=True, null=True)
    device = models.ForeignKey(OldDevice)
    draw_link = models.BooleanField(_('Draw links'), help_text=_('Draw links from/to this interface (not valid for VPN interfaces)'), default=True, blank=True)
    wireless_mode = models.CharField(max_length=5, choices=WIRELESS_MODE, blank=True, null=True)
    wireless_channel = models.CharField(max_length=4, choices=WIRELESS_CHANNEL, blank=True, null=True)
    wireless_polarity = models.CharField(max_length=1, choices=WIRELESS_POLARITY, blank=True, null=True)    
    essid = models.CharField(max_length=50, null=True, blank=True, default=None)
    bssid = models.CharField(max_length=50, null=True, blank=True, default=None)
    status = models.CharField(_('status'), max_length=1, choices=INTERFACE_STATUS, default='u')
    added = models.DateTimeField(auto_now_add=True,)
    updated = models.DateTimeField(auto_now=True)
    
    def __unicode__(self):
        if self.ipv4_address:
            value = self.ipv4_address
        elif self.ipv6_address:
            value = self.ipv6_address
        elif self.mac_address:
            value = 'MAC: %s' % self.mac_address
        else:
            value = self.device.name
        return value
    
    class Meta:
        unique_together = (('device', 'cname'),)
        verbose_name = _('Interface')
        verbose_name_plural = _('Interfaces')
        db_table = 'nodeshot_interface'


class OldLink(models.Model):
    from_interface = models.ForeignKey(OldInterface, related_name='from_interface')
    to_interface = models.ForeignKey(OldInterface, related_name='to_interface')
    etx = models.FloatField(default=0)
    dbm = models.IntegerField(default=0)
    sync_tx = models.IntegerField(default=0)
    sync_rx = models.IntegerField(default=0)
    hide = models.BooleanField(_('Hide from map'), default=False)
    
    def get_quality(self, type='etx'):
        """ used to determine color of links"""
        if type == 'etx':
            if 0 < self.etx < 1.5:
               quality = 1
            elif self.etx < 3:
               quality = 2
            else:
                quality = 3
        elif type == 'dbm':
            if -83 < self.dbm < 0:
                quality = 1
            elif self.dbm > -88:
                quality = 2
            else:
                quality = 3
        return quality
    
    def get_etx(self):
        """ return etx as a string to avoid dot to comma conversion (it happens only with certain LANGUAGE_CODEs like IT)"""
        return str(self.etx)
    
    def __unicode__(self):
        return u'%s  %s' % (self.from_interface.device, self.to_interface.device)
        
    class Meta:
        verbose_name = _('Link')
        verbose_name_plural = _('Links')
        db_table = 'nodeshot_link'


class OldStatistic(models.Model):
    active_nodes = models.IntegerField(_('active nodes'))
    potential_nodes = models.IntegerField(_('potential nodes'))
    hotspots = models.IntegerField(_('hotspots'))
    links = models.IntegerField(_('active links'))
    km = models.FloatField(_('Km'))
    date = models.DateTimeField(_('Added on'), auto_now_add=True)
    
    def __unicode__(self):
        return u'%s' % (self.date)
    
    class Meta:
        verbose_name = _('Statistic')
        verbose_name_plural = _('Statistics')
        db_table = 'nodeshot_statistic'


class OldContact(models.Model):
    node = models.ForeignKey(OldNode)
    from_name = models.CharField(_('name'), max_length=50)
    from_email = models.EmailField(_('email'), max_length=50)
    message = models.CharField(_('message'), max_length=2000)
    ip = models.GenericIPAddressField(verbose_name=_('ip address'))
    user_agent = models.CharField(max_length=200, blank=True)
    http_referer = models.CharField(max_length=200, blank=True)
    accept_language = models.CharField(max_length=60, blank=True)
    date = models.DateTimeField(auto_now_add=True)
    
    def __unicode__(self):
        return _(u'Message from %(from)s to %(to)s') % ({'from':self.from_name, 'to':self.node.name})
    
    class Meta:
        verbose_name = _('Contact Log')
        verbose_name_plural = _('Contact Logs')
        db_table = 'nodeshot_contact'

########NEW FILE########
__FILENAME__ = tasks
from celery import task
from django.core import management


@task()
def import_old_nodeshot(*args, **kwargs):
    """
    runs "python manage.py import_old_nodeshot"
    """
    management.call_command('import_old_nodeshot', *args, **kwargs)

########NEW FILE########
__FILENAME__ = tests
from django.test import TestCase
from django.core import mail, management
from django.conf import settings
from django.contrib.gis.geos import Point
from django.test.utils import override_settings

from nodeshot.core.nodes.models import Node
from nodeshot.core.layers.models import Layer
from nodeshot.networking.net.models import Device, Interface, Ip, Vap, Wireless
from nodeshot.networking.links.models import Link
from nodeshot.community.profiles.models import Profile as User
from nodeshot.community.mailing.models import Inward
from .models import *


class TestOldImporter(TestCase):
    fixtures = [
        'initial_data.json',
        'test_profiles.json',
        'test_layers.json',
        'test_status.json',
    ]

    mysql_fixtures = [
        'test_oldnodes.json',
        'test_olddevices.json',
        'test_oldlinks.json',
        'test_oldcontacts.json'
    ]

    def setUp(self):
        for fixture in self.mysql_fixtures:
            management.call_command('loaddata', fixture, database='old_nodeshot')

        # setup layer 1 and 2 area
        l1 = Layer.objects.get(pk=1)
        l1.area = 'POLYGON ((11.9727761230500001 42.0001370328649983, 12.3188454589879992 42.2669596835330026, 12.9148537597690005 42.1509994246999966, 13.2609230957069997 41.8079840923359995, 12.7500588378940005 41.3951648168940025, 12.5962502441440005 41.4445954826359966, 12.4067360839879992 41.6501514845399967, 12.1925026855510001 41.7444877274350006, 12.1128518066440005 41.9184405084070022, 12.0277077636760001 41.9368313579400009, 12.0277077636760001 41.9429604629400004, 11.9727761230500001 42.0001370328649983))'
        l1.save()

        l2 = l1 = Layer.objects.get(pk=2)
        l2.area = 'POLYGON ((10.1833779296829992 43.9387627493410022, 10.3454262695289998 43.9901623726480011, 10.6475502929680008 43.9822576330009980, 10.7491738281280007 43.9071101075910022, 10.8205849609349993 43.7188257293139984, 10.7574135742189991 43.5558293167039992, 10.6283242187470002 43.3484662663620028, 10.4470498046879996 43.3344836017819972, 10.3591591796899998 43.4602116419999973, 10.2712685546909999 43.5518482711390007, 10.2575356445299999 43.6830839058609968, 10.2383095703089992 43.8338488741229995, 10.1751381835920007 43.9328291618219993, 10.1833779296829992 43.9387627493410022))'
        l2.save()

        l = Layer()
        l.id = 5
        l.name = 'Default Layer'
        l.slug = 'default-layer'
        l.description = 'Default Layer'
        l.organization = 'Test'
        l.published = True
        l.geometry = Point(40.0, 10.0)
        l.full_clean()
        l.save()

    @override_settings()
    def test_command(self):
        for user in User.objects.all():
            user.delete()

        settings.NODESHOT['OLD_IMPORTER']['DEFAULT_LAYER'] = 5
        management.call_command('import_old_nodeshot', noinput=True)

        nodes = Node.objects.all().order_by('id')
        devices = Device.objects.all().order_by('id')
        interfaces = Interface.objects.all().order_by('id')
        ip_addresses = Ip.objects.all().order_by('id')
        links = Link.objects.all().order_by('id')
        users = User.objects.all()
        inwards = Inward.objects.all()

        self.assertEqual(len(nodes), 4)
        self.assertEqual(len(devices), 2)
        self.assertEqual(len(interfaces), 4)
        self.assertEqual(len(ip_addresses), 8)
        self.assertEqual(Vap.objects.count(), 2)
        self.assertEqual(len(links), 1)
        self.assertEqual(len(users), 4)
        self.assertEqual(len(inwards), 1)

        # node1
        self.assertEqual(nodes[0].id, 1)
        self.assertEqual(nodes[0].name, 'oldnode1 rome')
        self.assertEqual(nodes[0].slug, 'oldnode1-rome')
        self.assertEqual(nodes[0].user.get_full_name(), 'Oldnode1 Owner')
        self.assertEqual(nodes[0].user.username, 'oldnode1-owner')
        self.assertEqual(nodes[0].user.email, 'oldnode1@test.com')
        self.assertEqual(nodes[0].description, 'oldnode1-description')
        self.assertEqual(nodes[0].data['postal_code'], '00185')
        self.assertEqual(nodes[0].status.slug, 'active')
        self.assertEqual(nodes[0].updated.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-20T13:36:47')
        self.assertEqual(nodes[0].added.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-14T13:30:29')
        self.assertEqual(nodes[0].geometry[0], 12.5390629470348003)
        self.assertEqual(nodes[0].geometry[1], 41.9064152946931969)
        self.assertEqual(nodes[0].elev, 24.5)
        # ensure layer has been picked correctly
        self.assertEqual(nodes[0].layer.slug, 'rome')
        # ensure owner date_joined is correct
        self.assertEqual(nodes[0].user.date_joined.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-14T13:30:29')

        # node2
        self.assertEqual(nodes[1].id, 2)
        self.assertEqual(nodes[1].name, 'oldnode2 rome')
        self.assertEqual(nodes[1].slug, 'oldnode2-rome')
        self.assertEqual(nodes[1].user.get_full_name(), 'Oldnode2 Owner')
        self.assertEqual(nodes[1].user.username, 'oldnode2-owner')
        self.assertEqual(nodes[1].user.email, 'oldnode2@test.com')
        self.assertEqual(nodes[1].description, 'oldnode2-description')
        self.assertEqual(nodes[1].data['postal_code'], '00175')
        self.assertEqual(nodes[1].data['is_hotspot'], 'true')
        self.assertEqual(nodes[1].status.slug, 'active')
        self.assertEqual(nodes[1].updated.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-19T13:36:47')
        self.assertEqual(nodes[1].added.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-19T13:30:29')
        self.assertEqual(nodes[1].geometry[0], 12.534556835889)
        self.assertEqual(nodes[1].geometry[1], 41.90746129417)
        self.assertEqual(nodes[1].elev, 15.5)
        # ensure layer has been picked correctly
        self.assertEqual(nodes[1].layer.slug, 'rome')
        # ensure owner date_joined is correct
        self.assertEqual(nodes[1].user.date_joined.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-19T13:30:29')

        # node3
        self.assertEqual(nodes[2].id, 3)
        self.assertEqual(nodes[2].name, 'oldnode3 pisa')
        self.assertEqual(nodes[2].slug, 'oldnode3-pisa')
        self.assertEqual(nodes[2].user.get_full_name(), 'Oldnode3 Pisano')
        self.assertEqual(nodes[2].user.username, 'oldnode3-pisano')
        self.assertEqual(nodes[2].user.email, 'oldnode3@test.com')
        self.assertEqual(nodes[2].description, 'oldnode3 description')
        self.assertEqual(nodes[2].data['postal_code'], '00100')
        self.assertEqual(nodes[2].status.slug, 'potential')
        self.assertEqual(nodes[2].updated.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-18T13:36:47')
        self.assertEqual(nodes[2].added.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-18T13:30:29')
        self.assertEqual(nodes[2].geometry[0], 10.3973981737999992)
        self.assertEqual(nodes[2].geometry[1], 43.7175764660999988)
        self.assertEqual(nodes[2].elev, 10)
        # ensure layer has been picked correctly
        self.assertEqual(nodes[2].layer.slug, 'pisa')
        # ensure owner date_joined is correct
        self.assertEqual(nodes[2].user.date_joined.strftime('%Y-%m-%dT%H:%M:%S'), '2013-06-18T13:30:29')

        # ensure default layer
        self.assertEqual(nodes[3].layer.slug, 'default-layer')
        self.assertEqual(nodes[3].layer.id, 5)

        # device import check
        self.assertEqual(devices[0].id, 1)
        self.assertEqual(devices[0].name, 'device1')
        self.assertEqual(devices[0].node_id, 1)
        self.assertEqual(devices[0].description, 'device1-description')
        self.assertEqual(devices[0].type, 'radio')
        self.assertEqual(devices[0].data['cname'], 'oldnode1-device1')
        self.assertEqual(devices[0].data['model'], 'test model')
        self.assertEqual(devices[0].added.strftime('%Y-%m-%dT%H:%M:%S'), '2013-08-14T13:30:29')
        self.assertEqual(devices[0].routing_protocols.count(), 1)
        self.assertEqual(devices[0].routing_protocols.first().name, 'olsr')

        # interface import check
        self.assertEqual(interfaces[0].id, 1)
        self.assertEqual(interfaces[0].device_id, 1)
        self.assertEqual(interfaces[0].mac, '00:27:22:38:d1:38')
        self.assertEqual(interfaces[0].name, 'eth')
        self.assertEqual(interfaces[0].get_type_display(), 'ethernet')
        self.assertEqual(interfaces[0].added.strftime('%Y-%m-%dT%H:%M:%S'), '2013-08-15T13:30:29')
        self.assertEqual(interfaces[0].ip_set.count(), 2)
        ipv4 = interfaces[0].ip_set.filter(protocol='ipv4').first()
        self.assertEqual(str(ipv4.address), '10.40.0.1')
        ipv6 = interfaces[0].ip_set.filter(protocol='ipv6').first()
        self.assertEqual(str(ipv6.address), '2001:4c00:893b:fede:eddb:decd:e878:88b3')

        # wireless interface check
        wireless_interface = Wireless.objects.get(pk=interfaces[1].id)
        self.assertEqual(wireless_interface.id, 2)
        self.assertEqual(wireless_interface.device_id, 1)
        self.assertEqual(wireless_interface.mac, '00:27:22:38:d1:39')
        self.assertEqual(wireless_interface.name, 'wifi')
        self.assertEqual(wireless_interface.get_type_display(), 'wireless')
        self.assertEqual(wireless_interface.channel, '5620')
        self.assertEqual(wireless_interface.mode, 'ap')
        self.assertEqual(wireless_interface.added.strftime('%Y-%m-%dT%H:%M:%S'), '2013-08-16T13:30:29')
        ipv4 = wireless_interface.ip_set.filter(protocol='ipv4').first()
        self.assertEqual(str(ipv4.address), '172.16.40.27')
        ipv6 = wireless_interface.ip_set.filter(protocol='ipv6').first()
        self.assertEqual(str(ipv6.address), '2001:4c00:893b:fede:eddb:decd:e878:88b4')

        # vap check
        vap = wireless_interface.vap_set.first()
        self.assertEqual(vap.essid, 'essid test')
        self.assertEqual(vap.bssid, 'bssidtest')

        # link check
        self.assertEqual(links[0].id, 1)
        self.assertEqual(links[0].interface_a_id, 2)
        self.assertEqual(links[0].interface_b_id, 4)
        self.assertEqual(links[0].metric_type, 'etx')
        self.assertEqual(links[0].metric_value, 1)
        self.assertEqual(links[0].dbm, -76)
        self.assertEqual(links[0].min_rate, 50)
        self.assertEqual(links[0].max_rate, 50)

        # inward contact check
        self.assertEqual(inwards[0].id, 1)
        self.assertEqual(inwards[0].object_id, 1)
        self.assertEqual(inwards[0].status, 1)
        self.assertEqual(inwards[0].from_name, 'Tester')
        self.assertEqual(inwards[0].from_email, 'tester@test.com')
        self.assertEqual(inwards[0].message, 'This is a test old contact')
        self.assertEqual(inwards[0].ip, '10.40.0.56')
        self.assertEqual(inwards[0].user_agent, 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/33.0.1750.152 Chrome/33.0.1750.152 Safari/537.36')
        self.assertEqual(inwards[0].accept_language, 'it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4')
        self.assertEqual(inwards[0].added.strftime('%Y-%m-%dT%H:%M:%S'), '2013-09-14T13:30:29')

        # --- update --- #

        n = OldNode(**{
            "name": "addednode1",
            "slug": "addednode1",
            "owner": "addednode1 owner",
            "description": "addednode1-description",
            "postal_code": "00185",
            "email": "addednode@test.com",
            "password": "",
            "lat": 41.4064152946931969,
            "lng": 12.7390629470348003,
            "alt": 23.5,
            "status": "a"
        })
        n.save()

        d = OldDevice(**{
            "name": "addeddevice1",
            "node": n,
            "cname": "addeddevice1",
            "description": "addeddevice1-description",
            "type": "test model",
            "routing_protocol": "olsr"
        })
        d.save()

        i = OldInterface(**{
            "device": d,
            "mac_address": "00:27:22:38:D1:48",
            "ipv4_address": "10.40.0.6",
            "ipv6_address": "2001:4c00:893b:fede:eddb:decd:e878:88c3",
            "cname": "addedeth",
            "type": "eth",
            "status": "r"
        })
        i.save()

        l = OldLink(**{
            "from_interface": OldInterface.objects.first(),
            "to_interface": i,
            "etx": 1,
            "dbm": -75,
            "sync_tx": 60,
            "sync_rx": 40
        })
        l.save()

        c = OldContact(**{
            "node_id": 1,
            "from_name": "Added",
            "from_email": "added@test.com",
            "message": "This is an added test old contact",
            "ip": "10.40.0.57",
            "user_agent": "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Ubuntu Chromium/33.0.1750.152 Chrome/33.0.1750.152 Safari/537.36",
            "http_referer": "http://map.ninux.org/",
            "accept_language": "it-IT,it;q=0.8,en-US;q=0.6,en;q=0.4"
        })
        c.save()

        management.call_command('import_old_nodeshot', noinput=True)

        nodes = Node.objects.all().order_by('id')
        devices = Device.objects.all().order_by('id')
        interfaces = Interface.objects.all().order_by('id')
        ip_addresses = Ip.objects.all().order_by('id')
        links = Link.objects.all().order_by('id')
        users = User.objects.all().order_by('id')
        inwards = Inward.objects.all().order_by('id')

        self.assertEqual(len(nodes), 5)
        self.assertEqual(len(devices), 3)
        self.assertEqual(len(interfaces), 5)
        self.assertEqual(len(ip_addresses), 10)
        self.assertEqual(Vap.objects.count(), 2)
        self.assertEqual(len(links), 2)
        self.assertEqual(len(users), 5)
        self.assertEqual(len(inwards), 2)

        self.assertEqual(nodes[0].user.username, 'oldnode1-owner')
        self.assertEqual(nodes[1].user.username, 'oldnode2-owner')
        self.assertEqual(nodes[2].user.username, 'oldnode3-pisano')
        self.assertEqual(nodes[3].user.username, 'oldnode4-default')
        self.assertEqual(nodes[4].user.username, 'addednode1-owner')
        self.assertEqual(nodes[4].user.email, 'addednode@test.com')
        self.assertEqual(nodes[4].name, 'addednode1')
        self.assertEqual(nodes[4].description, 'addednode1-description')

        device = Device.objects.last()
        self.assertEqual(device.name, 'addeddevice1')

        interface = Interface.objects.last()
        self.assertEqual(interface.name, 'addedeth')
        self.assertEqual(interface.ip_set.count(), 2)

        link = Link.objects.last()
        self.assertEqual(link.interface_b_id, i.id)
        self.assertEqual(link.dbm, -75)

        self.assertEqual(inwards[1].from_name, 'Added')

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.conf import settings

from nodeshot.core.layers.admin import  LayerAdmin
from nodeshot.core.nodes.admin import NodeAdmin

from models import LayerExternal, NodeExternal


class LayerExternalInline(admin.StackedInline):
    model = LayerExternal
    fk_name = 'layer'

    if 'grappelli' in settings.INSTALLED_APPS:
        inline_classes = ('grp-collapse grp-open',)


# add inline to LayerAdmin
LayerAdmin.inlines.append(LayerExternalInline)
# custom admin template
LayerAdmin.change_form_template = 'admin/layer_change_form.html'


class NodeExternalInline(admin.StackedInline):
    model = NodeExternal
    fk_name = 'node'
    extra = 0

NodeAdmin.inlines.append(NodeExternalInline)

########NEW FILE########
__FILENAME__ = synchronize
from django.core.management.base import BaseCommand, CommandError
from django.core.exceptions import ImproperlyConfigured, ObjectDoesNotExist
from django.db.models import Q

from nodeshot.core.layers.models import Layer

from importlib import import_module
from optparse import make_option


class Command(BaseCommand):
    args = '<layer_slug layer_slug ...>'
    help = 'Synchronize external layers with the local database'
    
    option_list = BaseCommand.option_list + (
        make_option(
            '--exclude',
            action='store',
            dest='exclude',
            default=[],
            help='Exclude specific layers from synchronization\n\
                 Supply a comma separated string of layer slugs\n\
                 e.g. --exclude=layer1-slug,layer2-slug,layer3-slug\n\
                 (works only if no layer has been specified)'
        ),
    )

    def retrieve_layers(self, *args, **options):
        """
        Retrieve specified layers or all external layers if no layer specified.
        """
        
        # init empty Q object
        queryset = Q()
        
        # if no layer specified
        if len(args) < 1:
            # cache queryset
            all_layers = Layer.objects.published().external()
            
            # check if there is any layer to exclude
            if options['exclude']:
                # convert comma separated string in python list, ignore spaces
                exclude_list = options['exclude'].replace(' ', '').split(',')
                # retrieve all layers except the ones specified in exclude list
                return all_layers.exclude(slug__in=exclude_list)
            else:
                # nothing to exclude, retrieve all layers
                self.verbose('no layer specified, will retrieve all layers!')
                return all_layers
        
        # otherwise loop over args and retrieve each specified layer
        for layer_slug in args:
            queryset = queryset | Q(slug=layer_slug)
            
            # verify existence
            try:
                # retrieve layer
                layer = Layer.objects.get(slug=layer_slug)
                
                # raise exception if layer is not external
                if not layer.is_external:
                    raise CommandError('Layer "%s" is not an external layer\n\r' % layer_slug)
                
                # raise exception if layer is not published
                if not layer.is_published:
                    raise CommandError('Layer "%s" is not published. Why are you trying to work on an unpublished layer?\n\r' % layer_slug)
                
            # raise exception if one of the layer looked for doesn't exist
            except Layer.DoesNotExist:
                raise CommandError('Layer "%s" does not exist\n\r' % layer_slug)
        
        # return published external layers
        return Layer.objects.published().external().select_related().filter(queryset)
    
    def verbose(self, message):
        if self.verbosity == 2:
            self.stdout.write('%s\n\r' % message) 

    def handle(self, *args, **options):
        """ execute synchronize command """
        # store verbosity level in instance attribute for later use
        self.verbosity = int(options.get('verbosity'))
        
        # blank line
        self.stdout.write('\r\n')
        
        # retrieve layers
        layers = self.retrieve_layers(*args, **options)
        
        if len(layers) < 1:
            self.stdout.write('no layers to process\n\r')
            return
        else:
            self.verbose('going to process %d layers...' % len(layers))
        
        # loop over
        for layer in layers:
            # retrieve interop class if available
            try:
                interop = layer.external.interoperability
            except (ObjectDoesNotExist, AttributeError):
                self.stdout.write('External Layer %s does not have an interoperability class specified\n\r' % layer.name)
                continue
            
            # if no interop jump to next layer
            if interop == 'None':
                self.stdout.write('External Layer %s does not have an interoperability class specified\n\r' % layer.name)
                continue
            
            if layer.external.config is None:
                self.stdout.write('Layer %s does not have a config yet\n\r' % layer.name)
                continue
            
            # else go ahead and import module
            interop_module = import_module(interop)
            # retrieve class name (split and get last piece)
            class_name = interop.split('.')[-1]
            # retrieve class
            interop_class = getattr(interop_module, class_name)
            self.stdout.write('imported module %s\r\n' % interop_module.__file__)
            
            # try running
            try:
                instance = interop_class(layer, verbosity=self.verbosity)
                self.stdout.write('Processing layer "%s"\r\n' % layer.slug)
                messages = instance.process()
            except ImproperlyConfigured, e:
                self.stdout.write('Validation error: %s\r\n' % e)
                continue
        
            for message in messages:
                self.stdout.write('%s\n\r' % message)
        
        self.stdout.write('\r\n')

########NEW FILE########
__FILENAME__ = layer_external
from importlib import import_module

from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from django.core.exceptions import ValidationError, ImproperlyConfigured

import simplejson as json


# choices
INTEROPERABILITY = [
    ('None', _('Not interoperable'))
] + settings.NODESHOT['INTEROPERABILITY']


class LayerExternal(models.Model):
    """
    External Layers, extend 'Layers' with additional files
    These are the layers that are managed by local groups or other organizations
    """
    layer = models.OneToOneField('layers.Layer', verbose_name=_('layer'), parent_link=True, related_name='external')
    interoperability = models.CharField(_('interoperability'), max_length=128, choices=INTEROPERABILITY, default=False)
    config = models.TextField(_('configuration'), blank=True,
                              help_text=_('JSON format, will be parsed by the interoperability class to retrieve config keys'))
    map = models.URLField(_('map URL'), blank=True)
    
    # will hold an instance of the synchronizer class
    _synchronizer = None
    _synchronizer_class = None
    
    class Meta:
        app_label = 'interoperability'
        db_table = 'layers_external'
        verbose_name = _('external layer')
        verbose_name_plural = _('external layer info')

    def __unicode__(self):
        return '%s additional data' % self.layer.name

    def clean(self, *args, **kwargs):
        """
        Custom Validation:
        
            * must specify config if interoperability class is not none
            * indent json config nicely
            * validate any synchronizer.REQUIRED_CONFIG_KEYS
            * call synchronizer clean method for any third party validation
        """
        
        # if is interoperable some configuration needs to be specified
        if self.interoperability != 'None' and not self.config:
            raise ValidationError(_('Please specify the necessary configuration for the interoperation'))
        
        # configuration needs to be valid JSON
        if self.interoperability != 'None' and self.config:
            # convert ' to "
            self.config = self.config.replace("'", '"')
            
            # ensure valid JSON
            try:
                config = json.loads(self.config)
            except json.decoder.JSONDecodeError:
                raise ValidationError(_('The specified configuration is not valid JSON'))
            
            # ensure good indentation
            self.config = json.dumps(config, indent=4, sort_keys=True)
            
            # ensure REQUIRED_CONFIG_KEYS are filled
            for key in self.synchronizer_class.REQUIRED_CONFIG_KEYS:
                if key not in config:
                    raise ValidationError(_('Required config key "%s" missing from external layer configuration' % key))
            
            try:
                self.synchronizer.config = config
                self.synchronizer.clean()
            except ImproperlyConfigured as e:
                raise ValidationError(e.message)
    
    def save(self, *args, **kwargs):
        """
        call synchronizer "after_external_layer_saved" method
        for any additional operation that must be executed after save
        """
        after_save = kwargs.pop('after_save', True)
        
        super(LayerExternal, self).save(*args, **kwargs)
        
        if after_save and self.synchronizer:
            self.synchronizer.after_external_layer_saved(self.config)
    
    @property
    def synchronizer(self):
        """ access synchronizer """
        if not self.interoperability or self.interoperability == 'None' or not self.layer:
            return False
        
        # ensure data is up to date
        if (self._synchronizer is not None and self._synchronizer_class.__name__ not in self.interoperability):
            self._synchronizer = None
            self._synchronizer_class = None
        
        # init synchronizer if not already done
        if not self._synchronizer:
            synchronizer_class = self.synchronizer_class
            self._synchronizer = synchronizer_class(self.layer)
        
        return self._synchronizer
    
    @property
    def synchronizer_class(self):
        """ returns synchronizer class """
        if not self.interoperability or self.interoperability == 'None' or not self.layer:
            return False
        
        # ensure data is up to date
        if (self._synchronizer_class is not None and self._synchronizer_class.__name__ not in self.interoperability):
            self._synchronizer = None
            self._synchronizer_class = None
        
        if not self._synchronizer_class:
            synchronizer_module = import_module(self.interoperability)
            # retrieve class name (split and get last piece)
            class_name = self.interoperability.split('.')[-1]
            # retrieve class
            self._synchronizer_class = getattr(synchronizer_module, class_name)
        
        return self._synchronizer_class
    
    def __init__(self, *args, **kwargs):
        """ custom init method """
        super(LayerExternal, self).__init__(*args, **kwargs)
        
        # avoid blocking page loading in case of missing required config keys in configuration
        try:
            synchronizer = self.synchronizer
        except ImproperlyConfigured:
            return
        
        # if synchronizer has get_nodes method
        # add get_nodes method to current LayerExternal instance
        if synchronizer is not False and hasattr(synchronizer, 'get_nodes'):
            def get_nodes(class_name, params):
                return synchronizer.get_nodes(class_name, params)
            
            self.get_nodes = get_nodes

########NEW FILE########
__FILENAME__ = node_external
import simplejson as json

from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.core.exceptions import ValidationError

from nodeshot.core.nodes.models import Node


class NodeExternal(models.Model):
    """
    External Node info, extend 'Node' with additional data 
    """
    node = models.OneToOneField(Node, verbose_name=_('node'), parent_link=True, related_name='external')
    external_id = models.CharField(_('external id'), blank=True, max_length=255,
                                   help_text=_("""ID of this node on the external layer, might be a hash or an integer
                                               or whatever other format the external application uses to store IDs"""))
    extra_data = models.TextField(_('configuration'), blank=True, help_text=_('JSON format, might contain extra data regarding the external record'))
    
    class Meta:
        app_label = 'interoperability'
        db_table = 'nodes_external'
        verbose_name = _('external node')
        verbose_name_plural = _('external node info')

    def __unicode__(self):
        return '%s additional data' % self.node.name

    def clean(self, *args, **kwargs):
        """ Custom Validation """
        
        # extra_data needs to be valid JSON
        if self.extra_data != '' and self.extra_data is not None:
            # convert ' to "
            self.extra_data = self.extra_data.replace("'", '"')
            try:
                json.loads(self.extra_data)
            except json.decoder.JSONDecodeError:
                raise ValidationError(_('The specified configuration is not valid JSON'))


# ------ Signals ------ #


from django.dispatch import receiver
from django.db.models.signals import pre_delete, post_save

from ..tasks import push_changes_to_external_layers


@receiver(post_save, sender=Node)
def save_external_nodes(sender, **kwargs):
    """ sync by creating nodes in external layers when needed """
    
    node = kwargs['instance']
    operation = 'add' if kwargs['created'] is True else 'change'
    
    if node.layer.is_external is False or not hasattr(node.layer, 'external') or node.layer.external.interoperability is None:
        return False
    
    push_changes_to_external_layers.delay(node=node, external_layer=node.layer.external, operation=operation)


@receiver(pre_delete, sender=Node)
def delete_external_nodes(sender, **kwargs):
    """ sync by deleting nodes from external layers when needed """
    
    node = kwargs['instance']
    
    if node.layer.is_external is False or not hasattr(node.layer, 'external') or node.layer.external.interoperability is None:
        return False
    
    if hasattr(node, 'external') and node.external.external_id:
        # TODO: uniform here
        push_changes_to_external_layers.delay(node=node.external.external_id, external_layer=node.layer.external, operation='delete')

########NEW FILE########
__FILENAME__ = base
import requests
import simplejson as json
from xml.dom import minidom
from dateutil import parser as DateParser

from django.core.exceptions import ImproperlyConfigured
from django.template.defaultfilters import slugify
from django.contrib.auth import get_user_model
User = get_user_model()

from nodeshot.core.base.utils import pause_disconnectable_signals, resume_disconnectable_signals
from nodeshot.core.nodes.models import Node, Status


__all__ = [
    # classes
    'BaseSynchronizer',
    'XmlSynchronizer',
    'GenericGisSynchronizer',
    
    # mixins
    'HttpRetrieverMixin',
    'XMLParserMixin',
]


class BaseSynchronizer(object):
    """
    Base Synchronizer
    Provides methods for:
        * config validation
        * django validation
        * executing actions before or after specific events
        * retrieve data
        * extract data from imported source
        * save data into DB
        * log messages with different levels of verbosity
    """
    
    REQUIRED_CONFIG_KEYS = []
    
    def __init__(self, layer, *args, **kwargs):
        """
        :layer models.Model: instance of Layer we want to convert 
        """
        self.layer = layer
        self.verbosity = kwargs.get('verbosity', 1)
        self.config = json.loads(layer.external.config)
    
    def validate(self):
        """ External Layer config validation, must be called before saving the external layer instance """
        for field in self.REQUIRED_CONFIG_KEYS:
            if not self.config.get(field, False):
                raise ImproperlyConfigured('Required %s parameter missing from configuration' % field)
        
        self.clean()
    
    def clean(self):
        """ complex ad hoc validation here, will be executed before the external layer is saved """
        pass
    
    def after_external_layer_saved(self, *args, **kwargs):
        """ anything that should be executed after the external layer is saved goes here """
        pass
    
    def before_start(self, *args, **kwargs):
        """ anything that should be executed before the import starts goes here """
        pass
    
    def after_complete(self, *args, **kwargs):
        """ anything that should be executed after the import is complete goes here """
        pass
    
    def process(self):
        """
        This is the method that does everything automatically (at least attempts to).
        
        Steps:
            0. Call "before_start" method (which might be implemented by children classes)
            1. Retrieve data from external source
            2. Parse the data
            3. Save the data locally
            4. Call "after_complete" method (which might be implemented by children classes)
        """
        self.before_start()
        self.retrieve_data()
        self.parse()
        
        # TRICK: disable new_nodes_allowed_for_layer validation
        try:
            Node._additional_validation.remove('new_nodes_allowed_for_layer')
        except ValueError as e:
            print "WARNING! got exception: %s" % e
        # avoid sending zillions of notifications
        pause_disconnectable_signals()
        
        self.save()
        
        # Re-enable new_nodes_allowed_for_layer validation
        try:
            Node._additional_validation.insert(0, 'new_nodes_allowed_for_layer')
        except ValueError as e:
            print "WARNING! got exception: %s" % e
        # reconnect signals
        resume_disconnectable_signals()
        
        self.after_complete()
        
        # return message as a list because more than one messages might be returned
        return [self.message]
    
    def retrieve_data(self):
        """ retrieve data """
        raise NotImplementedError("BaseSynchronizer child class does not implement a retrieve_data method")
    
    def parse(self):
        """ parse data """
        raise NotImplementedError("BaseSynchronizer child class does not implement a parse method")
    
    def save(self):
        """ save data into DB """
        raise NotImplementedError("BaseSynchronizer child class does not implement a save method")
    
    def verbose(self, message):
        if self.verbosity >= 2:
            print(message)
    

class HttpRetrieverMixin(object):
    """ Retrieve external data through HTTP """
    
    def retrieve_data(self):
        """ retrieve data from an HTTP URL """
        # shortcuts for readability
        url = self.config.get('url')
        verify_SSL = self.config.get('verify_SSL', True)
        
        # do HTTP request and store content
        self.data = requests.get(url, verify=verify_SSL).content


class XMLParserMixin(object):
    """ XML Parsing utility methods """
    
    def parse(self):
        """ parse data """
        self.parsed_data = minidom.parseString(self.data)
    
    @staticmethod
    def get_text(item, tag, default=False):
        """ returns text content of an xml tag """
        try:
            xmlnode = item.getElementsByTagName(tag)[0].firstChild
        except IndexError as e:
            if default is not False:
                return default
            else:
                raise IndexError(e)
        
        if xmlnode is not None:
            return unicode(xmlnode.nodeValue)
        # empty tag
        else:
            return ''


class GenericGisSynchronizer(HttpRetrieverMixin, BaseSynchronizer):
    """
    Base Synchronizer for GIS formats like geojson, georss, kml, ecc
    
    It does not supports all the formats, rather it provides an easy way to add support for each format.
    
    You must implement a "parse_item" method to support different formats.
    """
    
    REQUIRED_CONFIG_KEYS = [
        'url',
        'map',
    ]
    
    def parse_item(self, item):
        """
        override this method according to the format you want to support.
        
        Should return a dictionary with the following structure:
        
        result = {
            "name": "string required",
            "status": "string or None",
            "address": "string or empty string",
            "is_published": "boolean",
            "user": "username or None",
            "geometry": "GEOSGeometry object",
            "elev": "float or none",
            "description": "string or empty string",
            "notes": "string or empty string",
            "added", "string date representation",
            "updated", "string date representation",
            "data": {}  # dictionary with additional key/values or empty dict
        }
        """
        raise NotImplementedError("Not Implemented")
    
    def _convert_item(self, item):
        """
        take a parsed item as input and returns a python dictionary
        the keys will be saved into the Node model
        either in their respective fields or in the hstore "data" field
        
        :param item: object representing parsed item
        """
        item = self.parse_item(item)
        
        # name is required
        if not item['name']:
            raise Exception('Expected property %s not found in item %s.' % (self.keys['name'], item))
        
        if not item['status']:
            item['status'] = self.default_status
        
        # get status or get default status or None
        try:
            item['status'] = Status.objects.get(slug__iexact=item['status'])
        except Status.DoesNotExist:
            try:
                item['status'] = Status.objects.filter(is_default=True)[0]
            except IndexError:
                item['status'] = None
        
        # slugify slug
        item['slug'] = slugify(item['name'])
        
        if not item['address']:
            item['address'] = ''
        
        if not item['is_published']:
            item['is_published'] = ''
        
        # get user or None
        try:
            item['user'] = User.objects.get(username=item['user'])
        except User.DoesNotExist:
            item['user'] = None
        
        if not item['elev']:
            item['elev'] = None
        
        if not item['description']:
            item['description'] = ''
        
        if not item['notes']:
            item['notes'] = ''
        
        # convert dates to python datetime
        try:
            item['added'] = DateParser.parse(item['added'])
        except Exception as e:
            print "Exception while parsing 'added' date: %s" % e
        try:
            item['updated'] = DateParser.parse(item['updated'])
        except Exception as e:
            print "Exception while parsing 'updated' date: %s" % e
        
        result = {
            "name": item['name'],
            "slug": item['slug'],
            "status": item['status'],
            "address": item['address'],
            "is_published": item['is_published'],
            "user": item['user'],
            "geometry": item['geometry'],
            "elev": item['elev'],
            "description": item['description'],
            "notes": item['notes'],
            "added": item['added'],
            "updated": item['updated'],
            "data": {}
        }
        
        # ensure all additional data items are strings
        for key, value in item['data'].items():
            result["data"][key] = unicode(value)
        
        return result
    
    def key_mapping(self, ):
        key_map = self.config.get('map', {})
        self.keys = {
            "name": key_map.get('name', 'name'),
            "status": key_map.get('status', 'status'),
            "description": key_map.get('description', 'description'),
            "address": key_map.get('address', 'address'),
            "is_published": key_map.get('is_published', 'is_published'),
            "user": key_map.get('user', 'user'),
            "elev": key_map.get('elevation', 'elev'),
            "notes": key_map.get('notes', 'notes'),
            "added": key_map.get('added', 'added'),
            "updated": key_map.get('updated', 'updated'),
        }
        self.default_status = self.config.get('default_status', '')
    
    def save(self):
        """
        save data into DB:
        
         1. save new (missing) data
         2. update only when needed
         3. delete old data
         4. generate report that will be printed
        
        constraints:
         * ensure new nodes do not take a name/slug which is already used
         * validate through django before saving
         * use good defaults
        """
        self.key_mapping()
        # retrieve all items
        items = self.parsed_data
        
        # init empty lists
        added_nodes = []
        changed_nodes = []
        unmodified_nodes = []
        
        # retrieve a list of all the slugs of this layer
        layer_nodes_slug_list = Node.objects.filter(layer=self.layer).values_list('slug', flat=True)
        # keep a list of all the nodes of other layers
        other_layers_slug_list = Node.objects.exclude(layer=self.layer).values_list('slug', flat=True)
        # init empty list of slug of external nodes that will be needed to perform delete operations
        processed_slug_list = []
        deleted_nodes_count = 0
        
        # loop over every item
        for item in items:
            
            item = self._convert_item(item)
            
            number = 1
            original_name = item['name']
            needed_different_name = False
            
            while True:
                # items might have the same name... so we add a number..
                if item['slug'] in processed_slug_list or item['slug'] in other_layers_slug_list:
                    needed_different_name = True
                    number = number + 1
                    item['name'] = "%s - %d" % (original_name, number)
                    item['slug'] = slugify(item['name'])
                else:
                    if needed_different_name:
                        self.verbose('needed a different name for %s, trying "%s"' % (original_name, item['name']))
                    break
            
            # default values
            added = False
            changed = False
            
            try:
                # edit existing node
                node = Node.objects.get(slug=item['slug'], layer=self.layer)
            except Node.DoesNotExist:
                # add a new node
                node = Node()
                node.layer = self.layer
                added = True
            
            # loop over fields and store data only if necessary
            for field in Node._meta.fields:
                # geometry is a special case, skip
                if field.name == 'geometry':
                    continue
                # skip if field is not present in values
                if field.name not in item.keys():
                    continue
                # shortcut for value
                value = item[field.name]
                # if value is different than what we have
                if getattr(node, field.name) != value and value is not None:
                    # set value
                    setattr(node, field.name, value)
                    # indicates that a DB query is necessary
                    changed = True
            
            if added is True or (node.geometry.equals(item['geometry']) is False\
                                 and node.geometry.equals_exact(item['geometry']) is False):
                node.geometry = item['geometry']
                changed = True
            
            node.data = node.data or {}
            
            # store any additional key/value in HStore data field
            for key, value in item['data'].items():
                if node.data[key] != value:
                    node.data[key] = value
                    changed = True
            
            # perform save or update only if necessary
            if added or changed:
                try:
                    node.full_clean()
                    if node.added is not None and node.updated is not None:
                        node.save(auto_update=False)
                    else:
                        node.save()
                except Exception as e:
                    # TODO: are we sure we want to interrupt the execution?
                    raise Exception('error while processing "%s": %s' % (node.name, e))
            
            if added:
                added_nodes.append(node)
                self.verbose('new node saved with name "%s"' % node.name)
            elif changed:
                changed_nodes.append(node)
                self.verbose('node "%s" updated' % node.name)
            else:
                unmodified_nodes.append(node)
                self.verbose('node "%s" unmodified' % node.name)
            
            # fill node list container
            processed_slug_list.append(node.slug)
        
        # delete old nodes
        for local_node in layer_nodes_slug_list:
            # if local node not found in external nodes
            if local_node not in processed_slug_list:
                # store node name to print it later
                node_name = node.name
                # retrieve from DB and delete
                node = Node.objects.get(slug=local_node)
                node.delete()
                # then increment count that will be included in message
                deleted_nodes_count = deleted_nodes_count + 1
                self.verbose('node "%s" deleted' % node_name)
        
        # message that will be returned
        self.message = """
            %s nodes added
            %s nodes changed
            %s nodes deleted
            %s nodes unmodified
            %s total external records processed
            %s total local nodes for this layer
        """ % (
            len(added_nodes),
            len(changed_nodes),
            deleted_nodes_count,
            len(unmodified_nodes),
            len(items),
            Node.objects.filter(layer=self.layer).count()
        )


class XmlSynchronizer(HttpRetrieverMixin, XMLParserMixin, BaseSynchronizer):
    """ XML HTTP syncrhonizer """
    
    REQUIRED_CONFIG_KEYS = ['url']

########NEW FILE########
__FILENAME__ = CitySDKMixin
import requests
import simplejson as json

from django.core.exceptions import ImproperlyConfigured, ObjectDoesNotExist

from ..models import NodeExternal

from celery.utils.log import get_logger
logger = get_logger(__name__)


class CitySDKMixin(object):
    """
    CitySDKMixin interoperability mixin
    Provides methods to perform following operations:
        * perform authentication into citysdk API
        * create or find a category
        * add new records
        * change existing records
        * delete existing records
    """
    
    REQUIRED_CONFIG_KEYS = [
        'url',
        'citysdk_url',
        'citysdk_category',
        'citysdk_type',
        'citysdk_username',
        'citysdk_password',
        'citysdk_lang',
        'citysdk_term',
    ]
    
    def __init__(self, *args, **kwargs):
        super(CitySDKMixin, self).__init__(*args, **kwargs)
        self._init_config()

    def _init_config(self):
        """ Init required attributes if necessary (for internal use only) """
        if getattr(self, 'citysdk_categories_url', None) is None:
            self.citysdk_resource_url = '%s%ss/' % (self.config['citysdk_url'], self.config['citysdk_type'])
            self.citysdk_categories_url = '%scategories?list=%s&limit=0&format=json' % (self.config['citysdk_url'], self.config['citysdk_type'])
            self.citysdk_category_id = self.config.get('citysdk_category_id')
 
    def clean(self):
        """
        Custom Validation, is executed by ExternalLayer.clean();
        These validation methods will be called before saving an object into the DB
            * verify authentication works
        """
        self.authenticate()
    
    def after_external_layer_saved(self, layer_config=None):
        """
        Method that will be called after the external layer has been saved
        """
        self.find_citysdk_category(layer_config)
    
    def before_start(self, *args, **kwargs):
        """ before the import starts do authentication (1 time only) """
        # first time 
        self.authenticate(force_http_request=True)
        # store cookies in a string
        self.config['cookies'] = self.cookies
        # save config
        self.layer.external.config = json.dumps(self.config, indent=4, sort_keys=True)
        self.layer.external.save(after_save=False)
    
    def authenticate(self, force_http_request=False):
        """ authenticate into the CitySDK API if necessary """
        # if session cookie is stored in DB no need to reauthenticate
        # if force_http_request is True do HTTP request anyway
        if force_http_request is False and self.config.get('cookies', False):
            self.cookies = self.config['cookies']
            return True
            
        self.verbose('Authenticating to CitySDK')
        logger.info('== Authenticating to CitySDK ==')

        citysdk_auth_url = '%sauth?format=json' % self.config['citysdk_url']
        
        response = requests.post(citysdk_auth_url, {
            'username': self.config['citysdk_username'],
            'password': self.config['citysdk_password'],
        })
        
        if response.status_code != 200:
            message = 'API Authentication Error: "%s"' % json.loads(response.content)['ResponseStatus']['Message']
            logger.error(message)
            raise ImproperlyConfigured(message)
        
        self.cookies = response.cookies.get_dict()
        
        return True
    
    def find_citysdk_category(self, layer_config=None):
        """
        Automatically finds the citysdk category ID
            * ensure the ID specified in config is correct otherwise auto-correct
            * create category if it does not exist
            * if category exist find the ID
            * store category ID in config
        """
        logger.info('== Going to find CitySDK category ID ==')

        self._init_config()
        
        if layer_config:
            self.config = json.loads(layer_config)

        citysdk_category_id = self.config.get('citysdk_category_id', False)
        response = requests.get(self.citysdk_categories_url, cookies=self.cookies)
        
        # do we already have the category id in the db config?
        # And is the category present in the API response?
        if citysdk_category_id is not False and citysdk_category_id in response.content:
            
            message = 'category with ID "%s" already present in config' % citysdk_category_id
            self.verbose(message)
            logger.info(message)
            
            # exit here
            return False
        # if not go and find it!
        else:
            # category does not exist, create it
            if self.config['citysdk_category'] not in response.content:
                
                category = {
                    "list": self.config['citysdk_type'],  # poi, event, route
                    "category": {
                        "label": [
                            {
                                "lang": self.config['citysdk_lang'],
                                "term": "primary",
                                "value": self.config['citysdk_category']
                            }
                        ],
                        "lang": self.config['citysdk_lang'],
                        "term": "category",
                        "value": self.config['citysdk_category']
                    }
                }
                
                self.verbose('Creating new category in CitySDK DB')
                logger.info('== Creating new category in CitySDK DB ==')
                # put to create
                response = requests.put(self.citysdk_categories_url, data=json.dumps(category),
                                        headers={'content-type': 'application/json'},
                                        cookies=self.cookies)
                
                # raise exception if something has gone wrong
                if response.status_code is not 200:
                    message = 'ERROR: %s' % response.content
                    self.verbose(message)
                    logger.error(message)
                    raise ImproperlyConfigured(response.content)
                
                # get ID
                citysdk_category_id = json.loads(response.content)
                
                message = 'category with ID "%s" has been created' % citysdk_category_id
                self.verbose(message)
                logger.info(message)
            # category already exists, find ID
            else:
                categories = json.loads(response.content)['categories']
                
                for category in categories:
                    if category['value'] == self.config['citysdk_category']:
                        citysdk_category_id = category['id']
                
                # raise exception if not found - should not happen but who knows
                if citysdk_category_id is None:
                    message = 'Category was thought to be there but could not be found!'
                    logger.info(message)
                    raise ImproperlyConfigured(message)
            
            # now store ID in the database both in case category has been created or not
            self.config['citysdk_category_id'] = citysdk_category_id
            self.layer.external.config = json.dumps(self.config, indent=4, sort_keys=True)
            self.layer.external.save()
            # verbose output
            message = 'category with ID "%s" has been stored in config' % citysdk_category_id
            self.verbose(message)
            logger.info(message)
    
    def convert_format(self, node):
        """ Prepares the JSON that will be sent to the CitySDK API """
        
        # determine description or fill some hopefully useful value
        if not node.description.strip():
            description = '%s in %s' % (node.name, node.address)
        else:
            description = node.description
        
        return {
            self.config['citysdk_type'] :{
                "location":{
                    "point":[
                        {
                            "Point":{
                                "posList":"%s %s" % (float(node.point.coords[1]), float(node.point.coords[0])),
                                "srsName":"http://www.opengis.net/def/crs/EPSG/0/4326"
                            },
                            "term": self.config['citysdk_term']
                        }
                    ],
                    "address": {
                        "value":"""BEGIN:VCARD
N:;%s;;;;
ADR;INTL;PARCEL;WORK:;;%s;%s;%s;;%s
END:VCARD""" % (
                            node.name,
                            node.data['address'],
                            node.data['city'],
                            node.data['province'],
                            node.data['country'],
                        ),
                        "type": "text/vcard"
                    },
                },
                "label":[
                    {
                        "term": "primary",
                        "value": node.name
                    },
                ],
                "description":[
                    {
                        "value": description,
                        "lang": self.config['citysdk_lang']
                    },
                ],
                "category":[
                    {
                        "id": self.citysdk_category_id
                    }
                ],
                "base": self.citysdk_resource_url,
                "lang": self.config['citysdk_lang'],
                "created": unicode(node.added),
                "author":{
                    "term": "primary",
                    "value": self.layer.organization
                },
                "license":{
                    "term": "primary",
                    "value": "open-data"
                }
            }
        }
    
    def add(self, node, authenticate=True):
        """ Add a new record into CitySDK db """
        if authenticate:
            self.authenticate()
        
        citysdk_record = self.convert_format(node)

        # citysdk sync
        response = requests.put(self.citysdk_resource_url, data=json.dumps(citysdk_record),
                     headers={ 'content-type': 'application/json' }, cookies=self.cookies)
        
        if response.status_code != 200:
            message = 'ERROR while creating "%s". Response: %s' % (node.name, response.content)
            logger.error(message)
            return False
        
        try:
            data = json.loads(response.content)
        except json.JSONDecodeError as e:
            logger.error('== ERROR: JSONDecodeError %s ==' % e)
            return False
        
        external = NodeExternal.objects.create(node=node, external_id=data['id'])
        message = 'New record "%s" saved in CitySDK through the HTTP API"' % node.name
        self.verbose(message)
        logger.info(message)
        
        return True
    
    def change(self, node, authenticate=True):
        """ Edit existing record in CitySDK db """
        if authenticate:
            self.authenticate()
        
        citysdk_record = self.convert_format(node)
        
        # citysdk sync
        try:
            citysdk_record['poi']['id'] = node.external.external_id
            response = requests.post(
                        self.citysdk_resource_url,
                        data=json.dumps(citysdk_record),
                        headers={ 'content-type': 'application/json' },
                        cookies=self.cookies)
            
            if response.status_code == 200:
                message = 'Updated record "%s" through the CitySDK HTTP API' % node.name
                self.verbose(message)
                logger.info(message)
            else:
                message = 'ERROR while updating record "%s" through CitySDK API\n%s' % (node.name, response.content)
                logger.error(message)
                raise ImproperlyConfigured(message)
            
            return True
        
        # in case external_id is not in the local DB we need to create instead
        except ObjectDoesNotExist:
            return self.add(node, authenticate=False)
    
    def delete(self, external_id, authenticate=True):
        """ Delete record from CitySDK db """
        if authenticate:
            self.authenticate()
        
        response = requests.delete(self.citysdk_resource_url, data='{"id":"%s"}' % external_id,
                            headers={ 'content-type': 'application/json' }, cookies=self.cookies)
        
        if response.status_code != 200:
            message = 'Failed to delete a record through the CitySDK HTTP API'
            self.verbose(message)
            logger.info(message)
            return False
        
        message = 'Deleted a record through the CitySDK HTTP API'
        self.verbose(message)
        logger.info(message)
        
        return True

########NEW FILE########
__FILENAME__ = CitySdkMobility
import requests
import simplejson as json

from django.core.exceptions import ImproperlyConfigured

from nodeshot.interoperability.synchronizers.base import BaseSynchronizer

from celery.utils.log import get_logger
logger = get_logger(__name__)


class CitySdkMobilityMixin(object):
    """
    CitySdkMobility interoperability mixin
    Provides methods to perform following operations:
        * perform authentication into citysdk mobility API
        * add new records
        * change existing records
        * delete existing records
    """
    
    REQUIRED_CONFIG_KEYS = [
        'citysdk_url',
        'citysdk_layer',
        'citysdk_username',
        'citysdk_password',
    ]
    
    def __init__(self, *args, **kwargs):
        super(CitySdkMobilityMixin, self).__init__(*args, **kwargs)
        self._init_config()

    def _init_config(self):
        """ Init required attributes if necessary (for internal use only) """
        # cache key for session (depends on layer_id)
        self.session_cache_key = 'citysdk-mobility-session'
        
        # add trailing slash if missing
        if self.config['citysdk_url'].endswith('/'):
            self.citysdk_url = self.config['citysdk_url']
        else:
            self.citysdk_url = '%s/' % self.config['citysdk_url']
 
    def clean(self):
        """
        Custom Validation, is executed by ExternalLayer.clean();
        These validation methods will be called before saving an object into the DB
            * verify authentication works
        """
        session = self.get_session()
        self.release_session(session)
    
    def get_session(self):
        """ authenticate into the CitySDK Mobility API and return session token """
        self.verbose('Authenticating to CitySDK')
        logger.info('== Authenticating to CitySDK ==')

        authentication_url = '%sget_session?e=%s&p=%s' % (
            self.citysdk_url,
            self.config['citysdk_username'],
            self.config['citysdk_password']
        )
        
        try:
            response = requests.get(
                authentication_url,
                verify=self.config.get('verify_SSL', True)
            )
        except Exception as e:
            message = 'API Authentication Error: "%s"' % e
            logger.error(message)
            raise ImproperlyConfigured(message)
        
        if response.status_code != 200:
            try:
                message = 'API Authentication Error: "%s"' % json.loads(response.content)['message']
            except Exception:
                message = 'API Authentication Error: "%s"' % response.content
            logger.error(message)
            raise ImproperlyConfigured(message)
        
        # store session token
        # will be valid for 1 minute after each request
        session = json.loads(response.content)['results'][0]
        
        return session
    
    def release_session(self, session):
        release_url = '%srelease_session' % self.citysdk_url
        response = requests.get(
            release_url,
            verify=self.config.get('verify_SSL', True),
            headers={ 'Content-type': 'application/json', 'X-Auth': session }
        )
        
        print response.content
        
        if response.status_code == 200:
            return True
        else:
            return False
    
    def convert_format(self, node, create_type="create"):
        """ Prepares the JSON that will be sent to the CitySDK API """
        
        data = node.data or {}
        
        if node.status: data['status'] = node.status.slug
        if node.description: data['description'] = node.description
        if node.address: data['address'] = node.address
        if node.elev: data['elevation'] = node.elev
        if node.user: data['owner'] = node.user.get_full_name()
        
        result = {
            "create": {
                "params": {
                    "create_type": create_type,
                    "srid": 4326
                }      
            },
            "nodes": [
                {
                    "name": node.name,
                    "geom" : json.loads(node.geometry.json),
                    "data" : data
                }
            ]
        }
        
        if create_type == "create":
            result['nodes'][0]['id'] = node.slug
        elif create_type == "update":
            result['nodes'][0]['cdk_id'] = node.external.external_id
        
        return result
    
    def add(self, node, authenticate=True):
        """ Add a new record into CitySDK db """
        session = self.get_session()
        
        citysdk_record = self.convert_format(node)
        citysdk_api_url = '%snodes/%s' % (self.citysdk_url, self.config['citysdk_layer'])

        # citysdk sync
        response = requests.put(
            citysdk_api_url,
            data=json.dumps(citysdk_record),
            verify=self.config.get('verify_SSL', True),
            headers={ 'Content-type': 'application/json', 'X-Auth': session }
        )
        
        print response.content
        
        self.release_session(session)
        
        if response.status_code != 200:
            message = 'ERROR while creating "%s". Response: %s' % (node.name, response.content)
            logger.error(message)
            return False
         
        try:
            data = json.loads(response.content)
        except json.JSONDecodeError as e:
            logger.error('== ERROR: JSONDecodeError %s ==' % e)
            return False
        
        message = 'New record "%s" saved in CitySDK through the HTTP API"' % node.name
        self.verbose(message)
        logger.info(message)
        
        return True
    
    def change(self, node, authenticate=True):
        """ Add a new record into CitySDK db """
        session = self.get_session()
        
        citysdk_record = self.convert_format(node, create_type='update')
        citysdk_api_url = '%snodes/%s' % (self.citysdk_url, self.config['citysdk_layer'])

        # citysdk sync
        response = requests.put(
            citysdk_api_url,
            data=json.dumps(citysdk_record),
            verify=self.config.get('verify_SSL', True),
            headers={ 'Content-type': 'application/json', 'X-Auth': session }
        )
        
        print response.content
        
        self.release_session(session)
        
        if response.status_code != 200:
            message = 'ERROR while updating record "%s" through CitySDK API\n%s' % (node.name, response.content)
            logger.error(message)
            return False
        
        try:
            json.loads(response.content)
        except json.JSONDecodeError as e:
            logger.error(e)
            return False
        
        message = 'Updated record "%s" through the CitySDK HTTP API' % node.name
        self.verbose(message)
        logger.info(message)
        
        return True
    
    def delete(self, external_id, authenticate=True):
        """ Delete record from CitySDK db """
        session = self.get_session()
        
        citysdk_api_url = '%s%s/%s?delete_node=true' % (
            self.citysdk_url,
            external_id,
            self.config['citysdk_layer']
        )
        
        response = requests.delete(
            citysdk_api_url,
            verify=self.config.get('verify_SSL', True),
            headers={ 'Content-type': 'application/json', 'X-Auth': session }
        )
        
        self.release_session(session)
        
        if response.status_code != 200:
            message = 'Failed to delete a record through the CitySDK HTTP API'
            self.verbose(message)
            logger.info(message)
            return False
        
        message = 'Deleted a record through the CitySDK HTTP API'
        self.verbose(message)
        logger.info(message)
        
        return True


class CitySdkMobility(CitySdkMobilityMixin, BaseSynchronizer):
    pass

########NEW FILE########
__FILENAME__ = GeoJson
import simplejson as json
from django.contrib.gis.geos import GEOSGeometry
from .base import GenericGisSynchronizer


class GeoJson(GenericGisSynchronizer):
    """ GeoJSON synchronizer """
    
    def parse(self):
        """ parse geojson and ensure is collection """
        try:
            self.parsed_data = json.loads(self.data)
        except Exception as e:
            raise Exception('Error while converting response from JSON to python. %s' % e)
        
        if self.parsed_data.get('type', '') != 'FeatureCollection':
            raise Exception('GeoJson synchronizer expects a FeatureCollection object at root level')
        
        self.parsed_data = self.parsed_data['features']
    
    def parse_item(self, item):
        result = {
            "name": item['properties'].pop(self.keys['name'], ''),
            "status": item['properties'].pop(self.keys['status'], None),
            "address": item['properties'].pop(self.keys['address'], ''),
            "is_published": item['properties'].pop(self.keys['is_published'], True),
            "user": item['properties'].pop(self.keys['user'], None),
            "geometry": GEOSGeometry(json.dumps(item['geometry'])),
            "elev": item['properties'].pop(self.keys['elev'], None),
            "description": item['properties'].pop(self.keys['description'], ''),
            "notes": item['properties'].pop(self.keys['notes'], ''),
            "added": item['properties'].pop(self.keys['added'], None),
            "updated": item['properties'].pop(self.keys['updated'], None),
            "data": {}
        }
        
        # loop over remainig items and put them into data dictionary
        for key, value in item['properties'].items():
            result["data"][key] = value
        
        return result
########NEW FILE########
__FILENAME__ = GeoJsonCitySdkMobility
from .GeoJson import GeoJson
from .CitySdkMobility import CitySdkMobilityMixin


class GeoJsonCitySdkMobility(CitySdkMobilityMixin, GeoJson):
    """ Import GeoJson and sync CitySDK """
    
    REQUIRED_CONFIG_KEYS = [
        'url',
        'map',
        'citysdk_url',
        'citysdk_layer',
        'citysdk_username',
        'citysdk_password'
    ]
########NEW FILE########
__FILENAME__ = GeoJsonCitySdkTourism
from .GeoJson import GeoJson
from .CitySDKMixin import CitySDKMixin


class GeoJsonCitySdkTourism(CitySDKMixin, GeoJson):
    """ Import GeoJson and sync CitySDK tourism API """
    
    REQUIRED_CONFIG_KEYS = [
        'url',
        'map',
        'citysdk_url',
        'citysdk_category',
        'citysdk_type',
        'citysdk_username',
        'citysdk_password',
        'citysdk_lang',
        'citysdk_term',
    ]
    
    def convert_format(self, node):
        # determine description or fill some hopefully useful value
        if node.description.strip() == '':
            description = node.name
        else:
            description = node.description
            
        return {
            self.config['citysdk_type'] :{
                "location":{
                   "point":[
                        {
                            "Point":{
                                "posList":"%s %s" % (float(node.point.coords[1]), float(node.point.coords[0])),
                                "srsName":"http://www.opengis.net/def/crs/EPSG/0/4326"
                            },
                            "term": self.config['citysdk_term']
                        }
                    ],
                    "address": {
                        "value":"""BEGIN:VCARD
N:;%s;;;;
ADR;INTL;PARCEL;WORK:;;%s;
END:VCARD""" % (
                            node.name,
                            description
                        ),
                        "type": "text/vcard"
                    },
                },
                "label":[
                    {
                        "term": "primary",
                        "value": node.name
                    },
                ],
                "description":[
                    {
                        "value": description,
                        "lang": self.config['citysdk_lang']
                    },
                ],
                "category":[
                    {
                        "id": self.citysdk_category_id
                    }
                ],
                "base": self.citysdk_resource_url,
                "lang": self.config['citysdk_lang'],
                "created": unicode(node.added),
                "author":{
                    "term": "primary",
                    "value": self.layer.organization
                },
                "license":{
                    "term": "primary",
                    "value": "open-data"
                }
            }
        }
########NEW FILE########
__FILENAME__ = GeoRss
from django.contrib.gis.geos import GEOSGeometry
from .base import XMLParserMixin, GenericGisSynchronizer


class GeoRss(XMLParserMixin, GenericGisSynchronizer):
    """ Generic GeoRSS (simple version only) synchronizer """
    
    def key_mapping(self, ):
        key_map = self.config.get('map', {})
        
        if 'summary' in self.data:
            description_default_key = 'summary'
        else:
            description_default_key = 'description'
        
        self.keys = {
            "name": key_map.get('name', 'title'),
            "status": key_map.get('status', 'status'),
            "description": key_map.get('description', description_default_key),
            "address": key_map.get('address', 'address'),
            "is_published": key_map.get('is_published', 'is_published'),
            "user": key_map.get('user', 'user'),
            "elev": key_map.get('elevation', 'elev'),
            "notes": key_map.get('notes', 'notes'),
            "added": key_map.get('added', 'pubDate'),
            "updated": key_map.get('updated', 'updated'),
        }
        self.default_status = self.config.get('default_status', '')
    
    def parse(self):
        """ parse data """
        super(GeoRss, self).parse()
        
        # support RSS and ATOM
        tag_name = 'item' if '<item>' in self.data else 'entry'
        
        self.parsed_data = self.parsed_data.getElementsByTagName(tag_name)
    
    def parse_item(self, item):
        try:
            lat, lng = self.get_text(item, 'georss:point').split(' ')
        except IndexError:
            try:
                # detail view
                lat = self.get_text(item, 'georss:lat')
                lng = self.get_text(item, 'georss:long')
            except IndexError:
                # W3C
                lat = self.get_text(item, 'geo:lat')
                lng = self.get_text(item, 'geo:long')
        
        result = {
            "name": self.get_text(item, self.keys['name']),
            "status": None,
            "address": '',
            "is_published": True,
            "user": None,
            "geometry": GEOSGeometry('POINT (%s %s)' % (lng, lat)),
            "elev": None,
            "description": self.get_text(item, self.keys['description'], ''),
            "notes": '',
            "added": self.get_text(item, self.keys['added'], None),
            "updated": self.get_text(item, self.keys['updated'], None),
            "data": {}
        }
        
        return result

########NEW FILE########
__FILENAME__ = Nodeshot
import requests
import simplejson as json

from django.core.exceptions import ImproperlyConfigured
from django.utils.translation import ugettext_lazy as _

from .base import BaseSynchronizer


class NodeshotMixin(object):
    """
    Nodeshot interoperability mixin
    """
    
    REQUIRED_CONFIG_KEYS = [
        'layer_url',
    ]
    
    def get_nodes(self, class_name, params):
        prefix = self.config['layer_url']
        suffix = 'nodes/' if 'geojson' not in class_name.lower() else 'nodes.geojson'
        # url from where to fetch nodes
        url = '%s%s' % (prefix, suffix)
        
        try:
            response = requests.get(url, params=params)
        except requests.exceptions.ConnectionError as e:
            return {
                'error': _('external layer not reachable'),
                'exception': list(e.message)
            }
        
        try:
            response.data = json.loads(response.content)
        except json.scanner.JSONDecodeError as e:
            return {
                'error': _('external layer is experiencing some issues because it returned invalid data'),
                'exception': list(e)
            }
        
        return response.data['nodes']


class Nodeshot(NodeshotMixin, BaseSynchronizer):
    """ Nodeshot interop test """
    pass

########NEW FILE########
__FILENAME__ = OpenLabor
import requests
import simplejson as json
from datetime import datetime

from django.utils.translation import ugettext_lazy as _
from django.contrib.gis.geos import Point
from django.core.cache import cache

from rest_framework import serializers
from rest_framework_gis import serializers as geoserializers

from nodeshot.core.base.utils import now_after
from nodeshot.core.nodes.models import Node, Status
from nodeshot.core.nodes.serializers import NodeListSerializer
from nodeshot.interoperability.models import NodeExternal

from .base import BaseSynchronizer

from celery.utils.log import get_logger
logger = get_logger(__name__)


class OpenLaborSerializer(NodeListSerializer):
    """ node list """
    
    layer_name = serializers.Field('layer_name')
    details = serializers.SerializerMethodField('get_details')
    
    def get_details(self, obj):
        """ return job detail """
        return obj.data.get('more_info', None)


class OpenLaborGeoSerializer(geoserializers.GeoFeatureModelSerializer, OpenLaborSerializer):
    pass


class OpenLabor(BaseSynchronizer):
    """
    OpenLabor RESTful translator
    """
    
    REQUIRED_CONFIG_KEYS = [
        'open311_url',
        'service_code_get',
        'service_code_post',
        'api_key',
        'default_status'
    ]
    
    def __init__(self, *args, **kwargs):
        super(OpenLabor, self).__init__(*args, **kwargs)
        self._init_config()

    def _init_config(self):
        """ init config attributes """
        # add trailing slash if missing
        if self.config['open311_url'].endswith('/'):
            self.open311_url = self.config['open311_url']
        else:
            self.open311_url = '%s/' % self.config['open311_url']
        
        # url from where to fetch nodes
        self.get_url = '%srequests.json?service_code=%s' % (
            self.open311_url,
            self.config['service_code_get']
        )
        
        # url for POST
        self.post_url = '%srequests.json' % self.open311_url
        # api_key
        self.api_key = self.config.get('api_key', '')
        
        # default status
        try:
            self.default_status = Status.objects.get(slug=self.config.get('default_status', ''))
        except Status.DoesNotExist:
            self.default_status = None
    
    def to_nodeshot(self, node):
        """
        takes an openlabor structure as input
        and returns a dictionary representing a nodeshot node model instance
        """
        latitude = node.get('latitude', False)
        longitude = node.get('longitude', False)
        
        address = node.get('address', None)
        city = node.get('city', None)
        cap = node.get('CAP', None)
        
        full_address = address
        # if city info available insert it in full_address
        if city:
            full_address = '%s, %s' % (full_address, city)
        # same for cap
        if cap:
            full_address = '%s - %s' % (full_address, cap)
        
        additional_data = {
            "professional_profile": node.get('professionalProfile', None),
            "qualification_required": node.get('qualificationRequired', None),
            "phone": node.get('phone', None),
            "fax": node.get('fax', None),
            "email": node.get('email', None),
            "address": address,
            "city": city,
            "cap": cap,
            "more_info": node.get('linkMoreInfo', None)
        }
        
        added = node.get('dateInsert', None)
        # convert timestamp to date
        if added:
            added = datetime.utcfromtimestamp(int(added))
        
        return {
            "name": node.get('position', ''), 
            "slug": node.get('idJobOriginal', None), 
            "layer_id": self.layer.id,
            "user": None, 
            "status": self.default_status,
            "geometry": Point(float(longitude), float(latitude)), 
            "elev": None, 
            "address": full_address, 
            "description": node.get('notes', ''), 
            "data": additional_data, 
            "updated": added, 
            "added": added,  # no updated info, set insertion date as last update
        }
    
    def to_external(self, node):
        """
        takes a nodeshot Node instance as input
        and returns a dictionary representing JSON structure of OpenLabor
        """
        # calculated automatically 1 month after now
        job_expiration = int(now_after(days=30).strftime('%s'))
        
        if node.user is not None:
            user_email = node.user.email
            user_first_name = node.user.first_name
            user_last_name = node.user.last_name
        else:
            user_email = None
            user_first_name = None
            user_last_name = None
        
        return {
            "service_code": self.config['service_code_post'],
            "latitude": node.point[1],
            "longitude": node.point[0],
            "j_latitude": node.point[1],
            "j_longitude": node.point[0],
            "address": node.address,
            "j_address": node.address,
            "address_string": node.address,
            "email": user_email,
            "first_name": user_first_name,
            "last_name": user_last_name,
            "description": node.description,
            "api_key": self.config.get('api_key', ''),
            "locale": "it_IT",
            "position": node.name,
            "professionalProfile": node.data.get('professional_profile'),
            "qualificationRequired": node.data.get('qualification_required'),
            "contractType": node.data.get('contract_type', ''),
            "workersRequired": node.data.get('workers_required', 1),
            "jobExpiration": job_expiration,
            "notes": node.description,
            "zipCode": node.data.get('zip_code', None),
            "cityCompany": node.data.get('city', None),
            "sourceJob": user_email,
            "sourceJobName": user_first_name,
            "sourceJobSurname": user_last_name
        }
    
    def get_nodes(self, class_name, params):
        """ get nodes """
        # determine if response is going to be JSON or GeoJSON
        if 'geojson' in class_name.lower():
            response_format = 'geojson'
            SerializerClass = OpenLaborGeoSerializer
        else:
            response_format = 'json'
            SerializerClass = OpenLaborSerializer
        
        layer_name = self.layer.name
        cache_key = 'layer_%s_nodes.%s' % (self.layer.id, response_format)
        serialized_nodes = cache.get(cache_key, False)
        
        if serialized_nodes is False:            
            try:
                response = requests.get(
                    self.get_url,
                    verify=self.config.get('verify_SSL', True)
                )
            except requests.exceptions.ConnectionError as e:
                return {
                    'error': _('external layer not reachable'),
                    'exception': list(e.message)
                }
            
            try:
                response.data = json.loads(response.content)
            except json.scanner.JSONDecodeError as e:
                return {
                    'error': _('external layer is experiencing some issues because it returned invalid data'),
                    'exception': list(e)
                }
            
            nodes = []
            
            # loop over all the entries and convert to nodeshot format
            for job in response.data:
                # skip records which do not have geographic information
                if not job.get('latitude', False) or not job.get('longitude', False):
                    continue
                # convert response in nodeshot format
                node_dictionary = self.to_nodeshot(job)
                # create Node model instance (needed for rest_framework serializer)
                node = Node(**node_dictionary)
                node.layer_name = layer_name  # hack to avoid too many queries to get layer name each time
                nodes.append(node)
            
            # serialize with rest framework to achieve consistency
            serialized_nodes = SerializerClass(nodes, many=True).data
            cache.set(cache_key, serialized_nodes, 86400)  # cache for 1 day
        
        return serialized_nodes
    
    def add(self, node):
        """ Add a new record into OpenLabor db """
        openlabor_record = self.to_external(node)

        # openlabor sync
        response=requests.post(self.post_url,openlabor_record)
        
        if response.status_code != 200:
            message = 'ERROR while creating "%s". Response: %s' % (node.name, response.content)
            logger.error('== %s ==' % message)
            return False
        
        try:
            data = response.json()
        except json.JSONDecodeError as e:
            logger.error('== ERROR: JSONDecodeError %s ==' % e)
            return False
        
        NodeExternal.objects.create(node=node, external_id=int(data['AddedJobId']))
        message = 'New record "%s" saved in CitySDK through the HTTP API"' % node.name
        self.verbose(message)
        logger.info('== %s ==' % message)
        
        # clear cache
        cache_key1 = 'layer_%s_nodes.json' % self.layer.id
        cache_key2 = 'layer_%s_nodes.geojson' % self.layer.id
        cache.delete_many([cache_key1, cache_key2])
        
        return True

########NEW FILE########
__FILENAME__ = OpenWISP
from django.contrib.gis.geos import Point
from .base import XMLParserMixin, GenericGisSynchronizer


class OpenWISP(XMLParserMixin, GenericGisSynchronizer):
    """ OpenWISP GeoRSS interoperability class """
    
    def parse(self):
        """ parse data """
        super(OpenWISP, self).parse()
        self.parsed_data = self.parsed_data.getElementsByTagName('item')
    
    def parse_item(self, item):
        guid = self.get_text(item, 'guid')
        name, created_at = guid.split('201', 1)  # ugly hack
        name = name.replace('_', ' ')
        created_at = "201%s" % created_at
        updated_at = self.get_text(item, 'updated')
        description = self.get_text(item, 'title')
        address = self.get_text(item, 'description')
        
        try:
            lat, lng = self.get_text(item, 'georss:point').split(' ')
        except IndexError:
            # detail view
            lat = self.get_text(item, 'georss:lat')
            lng = self.get_text(item, 'georss:long')
        
        # point object
        geometry = Point(float(lng), float(lat))
        
        result = {
            "name": name,
            "status": None,
            "address": address,
            "is_published": True,
            "user": None,
            "geometry": geometry,
            "elev": None,
            "description": description,
            "notes": guid,
            "data": {},
            "added": created_at,
            "updated": updated_at
        }
        
        return result
########NEW FILE########
__FILENAME__ = OpenWISPCitySDK
from .OpenWISP import OpenWISP
from .CitySDKMixin import CitySDKMixin


class OpenWISPCitySDK(CitySDKMixin, OpenWISP):
    """
    OpenWISPCitySDK interoperability class
    Imports data from OpenWISP GeoRSS and then exports the data to the CitySDK database
    """
    
    def convert_format(self, node):
        # determine description or fill some hopefully useful value
        if node.description.strip() == '':
            description = '%s in %s' % (node.name, node.address)
        else:
            description = node.description
            
        return {
            self.config['citysdk_type'] :{
                "location":{
                   "point":[
                        {
                            "Point":{
                                "posList":"%s %s" % (float(node.point.coords[1]), float(node.point.coords[0])),
                                "srsName":"http://www.opengis.net/def/crs/EPSG/0/4326"
                            },
                            "term": self.config['citysdk_term']
                        }
                    ],
                    "address": {
                        "value":"""BEGIN:VCARD
N:;%s;;;;
ADR;INTL;PARCEL;WORK:;;%s;
END:VCARD""" % (
                            node.name,
                            node.address
                        ),
                        "type": "text/vcard"
                    },
                },
                "label":[
                    {
                        "term": "primary",
                        "value": node.name
                    },
                ],
                "description":[
                    {
                        "value": description,
                        "lang": self.config['citysdk_lang']
                    },
                ],
                "category":[
                    {
                        "id": self.citysdk_category_id
                    }
                ],
                "base": self.citysdk_resource_url,
                "lang": self.config['citysdk_lang'],
                "created": unicode(node.added),
                "author":{
                    "term": "primary",
                    "value": self.layer.organization
                },
                "license":{
                    "term": "primary",
                    "value": "open-data"
                }
            }
        }
########NEW FILE########
__FILENAME__ = ProvinceRomeTraffic
import requests
import simplejson as json
from datetime import date, datetime, timedelta

from django.template.defaultfilters import slugify
from django.contrib.gis.geos import GEOSGeometry
from django.core.exceptions import ValidationError

from nodeshot.core.nodes.models import Node, Status

from .base import BaseSynchronizer


class ProvinceRomeTraffic(BaseSynchronizer):
    """ Province of Rome Traffic interoperability class """
    
    REQUIRED_CONFIG_KEYS = [
        'streets_url',
        'measurements_url',
        'check_streets_every_n_days'
    ]
    
    def retrieve_data(self):
        """ retrieve data """
        # shortcuts for readability
        streets_url = self.config.get('streets_url')
        check_streets_every_n_days = int(self.config.get('check_streets_every_n_days', 2))
        last_time_streets_checked = self.config.get('last_time_streets_checked', None)
        measurements_url = self.config.get('measurements_url')
        verify_SSL = self.config.get('verify_SSL', True)
        
        # do HTTP request and store content
        self.measurements = requests.get(measurements_url, verify=verify_SSL).content
        
        try:
            last_time_streets_checked = datetime.strptime(last_time_streets_checked,
                                                          '%Y-%m-%d').date()    
        except TypeError:
            pass
        
        # if last time checked more than days specified
        if last_time_streets_checked is None or last_time_streets_checked < date.today() - timedelta(days=check_streets_every_n_days):
            # get huge streets file
            self.streets = requests.get(streets_url, verify=verify_SSL).content
        else:
            self.streets = False
    
    def parse(self):
        """ parse data """
        self.measurements = json.loads(self.measurements)["features"]
        if self.streets:
            self.streets = json.loads(self.streets)["features"]
    
    def save(self):
        """ synchronize DB """
        self.process_streets()
        self.process_measurements()
    
    def process_measurements(self):
        items = self.measurements
        if len(items) < 1:
            self.message += """
            No measurements found.
            """
        else:
            saved_measurements = 0
            for item in items:
                try:
                    node = Node.objects.get(pk=int(item['id']))
                except Node.DoesNotExist:
                    print "Could not retrieve node #%s" % item['id']
                    continue
                try:
                    node.data['last_measurement'] = item['properties']['TIMESTAMP']
                    node.data['velocity'] = item['properties']['VELOCITY']
                    node.save()
                    self.verbose('Updated measurement for node %s' % node.id)
                    saved_measurements += 1
                except KeyError:
                    pass
            self.message += """
            Updated measurements of %d street segments out of %d
            """ % (saved_measurements, len(items))
        
    def process_streets(self):
        if not self.streets:
            self.message = """
            Street data not processed.
            """
            return False
        # retrieve all items
        items = self.streets
        
        # init empty lists
        added_nodes = []
        changed_nodes = []
        unmodified_nodes = []
        
        # retrieve a list of local nodes in DB
        local_nodes_slug = Node.objects.filter(layer=self.layer).values_list('slug', flat=True)
        # init empty list of slug of external nodes that will be needed to perform delete operations
        external_nodes_slug = []
        deleted_nodes_count = 0
        
        try:
            self.status = Status.objects.get(slug=self.config.get('status', None))
        except Status.DoesNotExist:
            self.status = None
        
        # loop over every parsed item
        for item in items:
            # retrieve info in auxiliary variables
            # readability counts!
            pk = item['id']
            name = item['properties'].get('LOCATION', '')[0:70]
            address = name
            slug = slugify(name)
            
            number = 1
            original_name = name
            needed_different_name = False
            
            while True:
                # items might have the same name... so we add a number..
                # check in DB too
                # TODO: this must be DRYED!!
                if slug in external_nodes_slug or Node.objects.filter(slug__exact=slug).exclude(pk=pk).count() > 0:
                    needed_different_name = True
                    number = number + 1
                    name = "%s - %d" % (original_name, number)
                    slug = slug = slugify(name)                    
                else:
                    if needed_different_name:
                        self.verbose('needed a different name for %s, trying "%s"' % (original_name, name))
                    break
            
            # geometry object
            geometry = GEOSGeometry(json.dumps(item["geometry"]))
            
            # default values
            added = False
            changed = False
            
            try:
                # edit existing node
                node = Node.objects.get(pk=pk)
            except Node.DoesNotExist:
                # add a new node
                node = Node()
                node.id = pk
                node.layer = self.layer
                node.status = self.status
                node.data = {}
                added = True
            
            if node.name != name:
                node.name = name
                changed = True
            
            if node.slug != slug:
                node.slug = slug
                changed = True
            
            if added is True or node.geometry.equals(geometry) is False:
                node.geometry = geometry
                changed = True
            
            if node.address != address:
                node.address = address
                changed = True
            
            # perform save or update only if necessary
            if added or changed:
                try:
                    node.full_clean()
                    node.save()
                except ValidationError as e:
                    # TODO: are we sure we want to interrupt the execution?
                    raise Exception("%s errors: %s" % (name, e.messages))
            
            if added:
                added_nodes.append(node)
                self.verbose('new node saved with name "%s"' % node.name)
            elif changed:
                changed_nodes.append(node)
                self.verbose('node "%s" updated' % node.name)
            else:
                unmodified_nodes.append(node)
                self.verbose('node "%s" unmodified' % node.name)
            
            # fill node list container
            external_nodes_slug.append(node.slug)
        
        # delete old nodes
        for local_node in local_nodes_slug:
            # if local node not found in external nodes
            if local_node not in external_nodes_slug:
                node_name = node.name
                # retrieve from DB and delete
                node = Node.objects.get(slug=local_node)
                node.delete()
                # then increment count that will be included in message
                deleted_nodes_count = deleted_nodes_count + 1
                self.verbose('node "%s" deleted' % node_name)
        
        self.config['last_time_streets_checked'] = str(date.today())
        self.layer.external.config = json.dumps(self.config, indent=4, sort_keys=True)
        self.layer.external.save()
        
        # message that will be returned
        self.message = """
            %s streets added
            %s streets changed
            %s streets deleted
            %s streets unmodified
            %s total external records processed
            %s total local records for this layer
        """ % (
            len(added_nodes),
            len(changed_nodes),
            deleted_nodes_count,
            len(unmodified_nodes),
            len(items),
            Node.objects.filter(layer=self.layer).count()
        )

########NEW FILE########
__FILENAME__ = ProvinciaWIFI
from django.template.defaultfilters import slugify
from django.contrib.gis.geos import Point
from django.core.exceptions import ValidationError, ImproperlyConfigured
from django.conf import settings

from nodeshot.core.nodes.models import Node, Status

from .base import XmlSynchronizer


class ProvinciaWIFI(XmlSynchronizer):
    """ ProvinciaWIFI interoperability class """
    
    def save(self):
        """ synchronize DB """
        # retrieve all items
        items = self.parsed_data.getElementsByTagName('AccessPoint')
        
        # init empty lists
        added_nodes = []
        changed_nodes = []
        unmodified_nodes = []
        
        # retrieve a list of local nodes in DB
        local_nodes_slug = Node.objects.filter(layer=self.layer).values_list('slug', flat=True)
        # init empty list of slug of external nodes that will be needed to perform delete operations
        external_nodes_slug = []
        deleted_nodes_count = 0
        
        try:
            self.status = Status.objects.get(slug=self.config.get('status', None))
        except Status.DoesNotExist:
            self.status = None
        
        # loop over every parsed item
        for item in items:
            # retrieve info in auxiliary variables
            # readability counts!
            name = self.get_text(item, 'Denominazione')[0:70]
            slug = slugify(name)
            
            number = 1
            original_name = name
            needed_different_name = False
            
            while True:
                # items might have the same name... so we add a number..
                if slug in external_nodes_slug:
                    needed_different_name = True
                    number = number + 1
                    name = "%s - %d" % (original_name, number)
                    slug = slug = slugify(name)                    
                else:
                    if needed_different_name:
                        self.verbose('needed a different name for %s, trying "%s"' % (original_name, name))
                    break
            
            lat = self.get_text(item, 'Latitudine')
            lng = self.get_text(item, 'longitudine')
            description = 'Indirizzo: %s, %s; Tipologia: %s' % (
                self.get_text(item, 'Indirizzo'),
                self.get_text(item, 'Comune'),
                self.get_text(item, 'Tipologia')
            )
            address = '%s, %s' % (
                self.get_text(item, 'Indirizzo'),
                self.get_text(item, 'Comune')
            )
            
            # point object
            point = Point(float(lng), float(lat))
            
            # default values
            added = False
            changed = False
            
            try:
                # edit existing node
                node = Node.objects.get(slug=slug)
            except Node.DoesNotExist:
                # add a new node
                node = Node()
                node.layer = self.layer
                node.status = self.status
                added = True
            
            if node.name != name:
                node.name = name
                changed = True
            
            if node.slug != slug:
                node.slug = slug
                changed = True
            
            if added is True or node.geometry.equals(point) is False:
                node.geometry = point
                changed = True
            
            if node.description != description:
                node.description = description
                changed = True
            
            if node.address != address:
                node.address = address  # complete address
                node.data = {
                    'address': self.get_text(item, 'Indirizzo'),
                    'city': self.get_text(item, 'Comune'),
                    'province': 'Roma',
                    'country': 'Italia'
                }
                changed = True
            
            # perform save or update only if necessary
            if added or changed:
                try:
                    node.full_clean()
                    node.save()
                except ValidationError as e:
                    # TODO: are we sure we want to interrupt the execution?
                    raise Exception("%s errors: %s" % (name, e.messages))
            
            if added:
                added_nodes.append(node)
                self.verbose('new node saved with name "%s"' % node.name)
            elif changed:
                changed_nodes.append(node)
                self.verbose('node "%s" updated' % node.name)
            else:
                unmodified_nodes.append(node)
                self.verbose('node "%s" unmodified' % node.name)
            
            # fill node list container
            external_nodes_slug.append(node.slug)
        
        # delete old nodes
        for local_node in local_nodes_slug:
            # if local node not found in external nodes
            if not local_node in external_nodes_slug:
                node_name = node.name
                # retrieve from DB and delete
                node = Node.objects.get(slug=local_node)
                node.delete()
                # then increment count that will be included in message
                deleted_nodes_count = deleted_nodes_count + 1
                self.verbose('node "%s" deleted' % node_name)
        
        # message that will be returned
        self.message = """
            %s nodes added
            %s nodes changed
            %s nodes deleted
            %s nodes unmodified
            %s total external records processed
            %s total local nodes for this layer
        """ % (
            len(added_nodes),
            len(changed_nodes),
            deleted_nodes_count,
            len(unmodified_nodes),
            len(items),
            Node.objects.filter(layer=self.layer).count()
        )
########NEW FILE########
__FILENAME__ = ProvinciaWIFICitySDK
from .ProvinciaWIFI import ProvinciaWIFI
from .CitySDKMixin import CitySDKMixin


class ProvinciaWIFICitySDK(CitySDKMixin, ProvinciaWIFI):
    """
    ProvinciaWIFICitySDK interoperability class
    Imports data from Provincia WIFI Open Data and then exports the data to the CitySDK database
    """
    pass
########NEW FILE########
__FILENAME__ = ProvinciaWifiCitySdkMobility
from .ProvinciaWIFI import ProvinciaWIFI
from .CitySdkMobility import CitySdkMobilityMixin


class ProvinciaWifiCitySdkMobility(CitySdkMobilityMixin, ProvinciaWIFI):
    """
    ProvinciaWIFICitySDK interoperability class
    Imports data from Provincia WIFI Open Data and then exports the data to the CitySDK Mobility API database
    """
    
    REQUIRED_CONFIG_KEYS = [
        'url',
        'citysdk_url',
        'citysdk_layer',
        'citysdk_username',
        'citysdk_password'
    ]
########NEW FILE########
__FILENAME__ = tasks
from celery import task
from importlib import import_module
from django.core import management


@task()
def synchronize_external_layers(*args, **kwargs):
    """
    runs "python manage.py synchronize"
    """
    management.call_command('synchronize', *args, **kwargs)


# ------ Asynchronous tasks ------ #


@task
def push_changes_to_external_layers(node, external_layer, operation):
    """
    Sync other applications through their APIs by performing updates, adds or deletes.
    This method is designed to be performed asynchronously, avoiding blocking the user
    when he changes data on the local DB.
    
    :param node: the node which should be updated on the external layer.
    :type node: Node model instance
    :param operation: the operation to perform (add, change, delete)
    :type operation: string
    """
    # putting the model inside prevents circular imports
    # subsequent imports go and look into sys.modules before reimporting the module again
    # so performance is not affected
    from nodeshot.core.nodes.models import Node
    
    # get node because for some reason the node instance object is not passed entirely,
    # pheraphs because objects are serialized by celery or transport/queuing mechanism
    if not isinstance(node, basestring):
        node = Node.objects.get(pk=node.pk)
        
    interop_module = import_module(external_layer.interoperability)
    # retrieve class name (split and get last piece)
    class_name = external_layer.interoperability.split('.')[-1]
    # retrieve class
    interop_class = getattr(interop_module, class_name)
    instance = interop_class(external_layer.layer)
    
    # call method only if supported
    if hasattr(instance, operation):
        getattr(instance, operation)(node)
########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.interoperability unit tests
"""

import sys
import simplejson as json
from cStringIO import StringIO
from datetime import date, timedelta

from django.test import TestCase
from django.core import management
from django.core.urlresolvers import reverse
from django.core.exceptions import ValidationError
from django.conf import settings
from django.contrib.gis.geos import Point, GEOSGeometry

from nodeshot.core.layers.models import Layer
from nodeshot.core.nodes.models import Node
from nodeshot.core.base.tests import user_fixtures

from .models import LayerExternal
from .tasks import synchronize_external_layers


class InteroperabilityTest(TestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json'
    ]
    
    def setUp(self):
        pass
    
    def test_external_layer_creation(self):
        layer = Layer()
        layer.name = 'test'
        layer.slug = 'test'
        layer.description = 'test'
        layer.is_external = True
        layer.organization = 'test'
        layer.center = Point(8.96166, 44.4185)
        layer.full_clean()
        layer.save()
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'None'
        external.config = ''
        external.full_clean()
        external.save()
    
    def test_not_interoperable(self):
        """ test not interoperable """
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna')
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('does not have an interoperability class specified', output.getvalue())
    
    def test_management_command_exclude(self):
        """ test --exclude """
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', exclude='vienna,test')
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('no layers to process', output.getvalue())
    
    def test_celery_task(self):
        """ ensure celery task works as expected """
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # call task
        synchronize_external_layers.apply()
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('does not have an interoperability class specified', output.getvalue())
    
    def test_celery_task_with_arg(self):
        # same output when calling with parameter
        output = StringIO()
        sys.stdout = output
        
        # call task
        synchronize_external_layers.apply(['vienna'])
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('does not have an interoperability class specified', output.getvalue())
    
    def test_celery_task_with_exclude(self):
        # same output when calling with parameter
        output = StringIO()
        sys.stdout = output
        
        # call task
        synchronize_external_layers.apply(kwargs={ 'exclude': 'vienna,test' })
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('no layers to process', output.getvalue())
    
    def test_celery_task_with_error(self):
        try:
            synchronize_external_layers.apply(['wrongvalue'])
            self.fail('should have got exception')
        except management.CommandError as e:
            self.assertIn('wrongvalue', str(e))
            self.assertIn('does not exist', str(e))
    
    def test_layer_admin(self):
        """ ensure layer admin does not return any error """
        layer = Layer.objects.external()[0]
        url = reverse('admin:layers_layer_change', args=[layer.id])
        
        self.client.login(username='admin', password='tester')
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.Nodeshot'
        external.config = '{ "layer_url": "http://test.com/" }'
        external.save()
        
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        
        layer = Layer.objects.filter(is_external=False)[0]
        url = reverse('admin:layers_layer_change', args=[layer.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
    
    def test_config_validation(self):
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.OpenWISP'
        external.config = '{ "WRONG_parameter_name": "foo" }'
        
        with self.assertRaises(ValidationError):
            external.clean()
    
    def test_openwisp(self):
        """ test OpenWISP synchronizer """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        xml_url = '%snodeshot/testing/openwisp-georss.xml' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.OpenWISP'
        external.config = '{ "url": "%s" }' % xml_url
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('42 nodes added', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('42 total external', output.getvalue())
        self.assertIn('42 total local', output.getvalue())
        
        # start checking DB too
        nodes = layer.node_set.all()
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 42)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='podesta1-ced')
        self.assertEqual(node.name, 'Podesta1 CED')
        self.assertEqual(node.address, 'Test WISP')
        point = Point(8.96166, 44.4185)
        self.assertTrue(node.geometry.equals(point))
        self.assertEqual(node.updated.strftime('%Y-%m-%d'), '2013-07-10')
        self.assertEqual(node.added.strftime('%Y-%m-%d'), '2011-08-24')
        
        ### --- with the following step we expect some nodes to be deleted --- ###
        
        xml_url = '%snodeshot/testing/openwisp-georss2.xml' % settings.STATIC_URL
        external.config = '{ "url": "%s" }' % xml_url
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('4 nodes unmodified', output.getvalue())
        self.assertIn('38 nodes deleted', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('4 total external', output.getvalue())
        self.assertIn('4 total local', output.getvalue())
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 4)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='lercari2-42')
        self.assertEqual(node.name, 'Lercari2 42')
        self.assertEqual(node.address, 'Test WISP')
        point = Point(8.96147, 44.4076)
        self.assertTrue(node.geometry.equals(point))
        self.assertEqual(node.updated.strftime('%Y-%m-%d'), '2013-07-10')
        self.assertEqual(node.added.strftime('%Y-%m-%d'), '2013-06-14')
    
    def test_provinciawifi(self):
        """ test ProvinciaWIFI converter """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        xml_url = '%snodeshot/testing/provincia-wifi.xml' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.ProvinciaWIFI'
        external.config = '{ "url": "%s" }' % xml_url
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('5 nodes added', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('5 total external', output.getvalue())
        self.assertIn('5 total local', output.getvalue())
        
        # start checking DB too
        nodes = layer.node_set.all()
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 5)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='viale-di-valle-aurelia-73')
        self.assertEqual(node.name, 'viale di valle aurelia, 73')
        self.assertEqual(node.address, 'viale di valle aurelia, 73, Roma')
        point = Point(12.4373, 41.9025)
        self.assertTrue(node.geometry.equals(point))
        
        # ensure itmes with the same name on the XML get a different name in the DB
        node = Node.objects.get(slug='largo-agostino-gemelli-8')
        node = Node.objects.get(slug='largo-agostino-gemelli-8-2')
        node = Node.objects.get(slug='largo-agostino-gemelli-8-3')
        node = Node.objects.get(slug='largo-agostino-gemelli-8-4')
        
        ### --- with the following step we expect some nodes to be deleted and some to be added --- ###
        
        xml_url = '%snodeshot/testing/provincia-wifi2.xml' % settings.STATIC_URL
        external.config = '{ "url": "%s" }' % xml_url
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('1 nodes added', output.getvalue())
        self.assertIn('2 nodes unmodified', output.getvalue())
        self.assertIn('3 nodes deleted', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('3 total external', output.getvalue())
        self.assertIn('3 total local', output.getvalue())
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 3)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='via-g-pullino-97')
        self.assertEqual(node.name, 'Via G. Pullino 97')
        self.assertEqual(node.address, 'Via G. Pullino 97, Roma')
        self.assertEqual(node.description, 'Indirizzo: Via G. Pullino 97, Roma; Tipologia: Privati federati')
        point = Point(12.484, 41.8641)
        self.assertTrue(node.geometry.equals(point))
    
    def test_province_rome_traffic(self):
        """ test ProvinceRomeTraffic converter """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        streets_url = '%snodeshot/testing/citysdk-wp4-streets.json' % settings.STATIC_URL
        measurements_url = '%snodeshot/testing/citysdk-wp4-measurements.json' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.ProvinceRomeTraffic'
        external.config = json.dumps({
            "streets_url": streets_url,
            "measurements_url": measurements_url,
            "check_streets_every_n_days": 2
        }, indent=4, sort_keys=True)
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('20 streets added', output.getvalue())
        self.assertIn('0 streets changed', output.getvalue())
        self.assertIn('20 total external', output.getvalue())
        self.assertIn('20 total local', output.getvalue())
        self.assertIn('Updated measurements of 4 street segments', output.getvalue())
        
        # start checking DB too
        nodes = layer.node_set.all()
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 20)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='via-di-santa-prisca')
        self.assertEqual(node.name, 'VIA DI SANTA PRISCA')
        self.assertEqual(node.address, 'VIA DI SANTA PRISCA')
        geometry = GEOSGeometry('SRID=4326;LINESTRING (12.4837894439700001 41.8823699951170028, 12.4839096069340005 41.8820686340329971, 12.4839801788330007 41.8818206787110014)')
        self.assertTrue(node.geometry.equals(geometry))
        
        # check measurements
        node = Node.objects.get(slug='via-casilina')
        self.assertEqual(node.name, 'VIA CASILINA')
        self.assertEqual(node.data['last_measurement'], '09-09-2013 22:31:00')
        self.assertEqual(node.data['velocity'], '44')
        
        # ensure last_time_streets_checked is today
        layer = Layer.objects.get(pk=layer.id)
        layer.external.config = json.loads(layer.external.config)
        self.assertEqual(layer.external.config['last_time_streets_checked'], str(date.today()))
        
        ### --- not much should happen --- ###
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('Street data not processed', output.getvalue())
        
        # set last_time_streets_checked to 6 days ago
        layer.external.config['last_time_streets_checked'] = str(date.today() - timedelta(days=6))
        layer.external.config = json.dumps(layer.external.config, indent=4, sort_keys=True)
        layer.external.save()
        
        ### --- with the following step we expect some nodes to be deleted and some to be added --- ###
        
        streets_url = '%snodeshot/testing/citysdk-wp4-streets2.json' % settings.STATIC_URL
        measurements_url = '%snodeshot/testing/citysdk-wp4-measurements2.json' % settings.STATIC_URL
        
        external.config = json.loads(external.config)
        external.config['streets_url'] = streets_url
        external.config['measurements_url'] = measurements_url
        external.config = json.dumps(external.config, indent=4, sort_keys=True)
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('5 streets added', output.getvalue())
        self.assertIn('16 streets unmodified', output.getvalue())
        self.assertIn('4 streets deleted', output.getvalue())
        self.assertIn('0 streets changed', output.getvalue())
        self.assertIn('21 total external', output.getvalue())
        self.assertIn('21 total local', output.getvalue())
        self.assertIn('No measurements found', output.getvalue())
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 21)
        
        # ensure last_time_streets_checked is today
        layer = Layer.objects.get(pk=layer.id)
        layer.external.config = json.loads(layer.external.config)
        self.assertEqual(layer.external.config['last_time_streets_checked'], str(date.today()))
    
    def test_geojson_sync(self):
        """ test GeoJSON sync """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        url = '%snodeshot/testing/geojson1.json' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.GeoJson'
        external.config = '{ "url": "%s", "map": {} }' % url
        external.full_clean()
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('2 nodes added', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('2 total external', output.getvalue())
        self.assertIn('2 total local', output.getvalue())
        
        # start checking DB too
        nodes = layer.node_set.all()
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 2)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='simplegeojson')
        self.assertEqual(node.name, 'simplegeojson')
        self.assertIn('simplegeojson', node.address)
        geometry = GEOSGeometry('{"type":"Polygon","coordinates":[[[12.501493164066,41.990441051094],[12.583890625003,41.957770034531],[12.618222900394,41.912820024702],[12.607923217778,41.877552973685],[12.582088180546,41.82423212474],[12.574148841861,41.813357913568],[12.551532455447,41.799730560554],[12.525053688052,41.795155470656],[12.510505386356,41.793715689492],[12.43308610535,41.803249638226],[12.388883300784,41.813613798573],[12.371030517581,41.870906276755],[12.382016845706,41.898511105474],[12.386136718753,41.912820024702],[12.38064355469,41.926104006681],[12.38064355469,41.955727539561],[12.413602539065,41.974107637675],[12.445188232426,41.983295698272],[12.45617456055,41.981254021593],[12.476773925785,41.985337309484],[12.490506835941,41.985337309484],[12.506986328129,41.990441051094],[12.501493164066,41.990441051094]]]}')
        self.assertTrue(node.geometry.equals_exact(geometry) or node.geometry.equals(geometry))
        self.assertEqual(node.elev, 10.0)
        
        ### --- repeat --- ###
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('2 nodes unmodified', output.getvalue())
        self.assertIn('0 nodes deleted', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('2 total external', output.getvalue())
        self.assertIn('2 total local', output.getvalue())
        
        ### --- repeat with slightly different input --- ###
        
        url = '%snodeshot/testing/geojson2.json' % settings.STATIC_URL
        external.config = '{ "url": "%s", "map": {} }' % url
        external.full_clean()
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('1 nodes unmodified', output.getvalue())
        self.assertIn('0 nodes deleted', output.getvalue())
        self.assertIn('1 nodes changed', output.getvalue())
        self.assertIn('2 total external', output.getvalue())
        self.assertIn('2 total local', output.getvalue())
    
    def test_preexisting_name(self):
        """ test preexisting names """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        node = Node.first()
        self.assertNotEqual(layer.id, node.layer.id)
        node.name = 'simplejson'
        node.save()
        
        url = '%snodeshot/testing/geojson1.json' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.GeoJson'
        external.config = '{ "url": "%s", "map": {} }' % url
        external.full_clean()
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('2 nodes added', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('2 total external', output.getvalue())
        self.assertIn('2 total local', output.getvalue())
    
    def test_key_mappings(self):
        """ importing a file with different keys """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        node = Node.first()
        self.assertNotEqual(layer.id, node.layer.id)
        node.name = 'simplejson'
        node.save()
        
        url = '%snodeshot/testing/geojson3.json' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.GeoJson'
        external.config = json.dumps({
            "url": url,
            "map": {
                "name": "nome",
                "description": "descrizione",
                "address": "indirizzo",
                "elevation": "altitudine"
            }
        })
        external.full_clean()
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('2 nodes added', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('2 total external', output.getvalue())
        self.assertIn('2 total local', output.getvalue())
        
        node = Node.objects.get(slug='verycool')
        self.assertEqual(node.name, 'veryCool')
        self.assertEqual(node.address, 'veryCool indirizzo')
        self.assertEqual(node.description, 'veryCool descrizione')
        self.assertEqual(node.elev, 10.0)
        
        node = Node.objects.get(slug='secondo')
        self.assertEqual(node.name, 'secondo')
        self.assertEqual(node.address, 'secondo indirizzo')
        self.assertEqual(node.description, 'secondo descrizione')
        self.assertEqual(node.elev, 20.0)
    
    def test_georss_simple(self):
        """ test GeoRSS simple """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        url = '%snodeshot/testing/georss-simple.xml' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.GeoRss'
        external.config = '{ "url": "%s", "map": {} }' % url
        external.full_clean()
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('3 nodes added', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('3 total external', output.getvalue())
        self.assertIn('3 total local', output.getvalue())
        
        # start checking DB too
        nodes = layer.node_set.all()
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 3)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='item-2')
        self.assertEqual(node.name, 'item 2')
        self.assertEqual(node.address, '')
        self.assertEqual(node.updated.strftime('%Y-%m-%d'), '2006-08-17')
        geometry = GEOSGeometry('POINT (-70.92 44.256)')
        self.assertTrue(node.geometry.equals_exact(geometry) or node.geometry.equals(geometry))
        
        ### --- repeat --- ###
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('3 nodes unmodified', output.getvalue())
        self.assertIn('0 nodes deleted', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('3 total external', output.getvalue())
        self.assertIn('3 total local', output.getvalue())
    
    def test_georss_w3c(self):
        """ test GeoRSS w3c """
        
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = False
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        url = '%snodeshot/testing/georss-w3c.xml' % settings.STATIC_URL
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.GeoRss'
        external.config = '{ "url": "%s", "map": {} }' % url
        external.full_clean()
        external.save()
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('2 nodes added', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('2 total external', output.getvalue())
        self.assertIn('2 total local', output.getvalue())
        
        # start checking DB too
        nodes = layer.node_set.all()
        
        # ensure all nodes have been imported
        self.assertEqual(nodes.count(), 2)
        
        # check one particular node has the data we expect it to have
        node = Node.objects.get(slug='test-2')
        self.assertEqual(node.name, 'test 2')
        self.assertEqual(node.address, '')
        #self.assertEqual(node.updated.strftime('%Y-%m-%d'), '2006-08-17')
        geometry = GEOSGeometry('POINT (95.8932 5.6319)')
        self.assertTrue(node.geometry.equals_exact(geometry) or node.geometry.equals(geometry))
        
        ### --- repeat --- ###
        
        # start capturing print statements
        output = StringIO()
        sys.stdout = output
        
        # execute command
        management.call_command('synchronize', 'vienna', verbosity=0)
        
        # stop capturing print statements
        sys.stdout = sys.__stdout__
        
        # ensure following text is in output
        self.assertIn('2 nodes unmodified', output.getvalue())
        self.assertIn('0 nodes deleted', output.getvalue())
        self.assertIn('0 nodes changed', output.getvalue())
        self.assertIn('2 total external', output.getvalue())
        self.assertIn('2 total local', output.getvalue())
    
    def test_openlabor_get_nodes(self):
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = True
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.OpenLabor'
        external.config = json.dumps({
            "open311_url": '%snodeshot/testing/' % settings.STATIC_URL,
            "service_code_get": "001",
            "service_code_post": "002",
            "default_status": "active",
            "api_key": "DEVO1395445966"
        })
        external.full_clean()
        external.save()
        
        url = reverse('api_layer_nodes_list', args=[layer.slug])
        response = self.client.get(url)
        nodes = response.data['nodes']
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(nodes), 2)
        self.assertEqual(nodes[0]['name'], 'SARTO CONFEZIONISTA')
        self.assertEqual(nodes[0]['address'], 'Via Lussemburgo snc, Anzio - 00042')
        
        # test geojson
        url = reverse('api_layer_nodes_geojson', args=[layer.slug])
        response = self.client.get(url)
        nodes = response.data['features']
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(nodes), 2)
        self.assertEqual(nodes[0]['properties']['name'], 'SARTO CONFEZIONISTA')
        self.assertEqual(nodes[0]['properties']['address'], 'Via Lussemburgo snc, Anzio - 00042')
    
    def test_openlabor_add_node(self):
        layer = Layer.objects.external()[0]
        layer.minimum_distance = 0
        layer.area = None
        layer.new_nodes_allowed = True
        layer.save()
        layer = Layer.objects.get(pk=layer.pk)
        
        url = 'http://devopenlabor.lynxlab.com/api/v1'
        
        external = LayerExternal(layer=layer)
        external.interoperability = 'nodeshot.interoperability.synchronizers.OpenLabor'
        external.config = json.dumps({
            "open311_url": url,
            "service_code_get": "001",
            "service_code_post": "002",
            "default_status": "active",
            "api_key": "DEVO1395445966"
        })
        external.full_clean()
        external.save()
        
        node = Node()
        node.name = 'offerta di lavoro di test'
        node.description = 'altra offerta di lavoro inserita automaticamente tramite unit test'
        node.geometry = 'POINT (12.5823391919000012 41.8721429276999820)'
        node.layer = layer
        node.user_id = 1
        node.address = 'via del test'
        node.data = {
            "professional_profile": "professional_profile test",
            "qualification_required": "qualification_required test",
            "contract_type": "contract_type test",
            "zip_code": "zip code test",
            "city": "city test"
        }
        
        node.save()
        self.assertIsNotNone(node.external.external_id)

########NEW FILE########
__FILENAME__ = utils
import sys
import re
import json

# ------- IFCONFIG TO JSON CONVERSION ------- #
# credits:
# https://gist.github.com/snbartell/1586034

def _extract(ifconfig_output):
    mo = re.search(r'^(?P<interface>\w+|\w+:\d+)\s+' +
                     r'Link encap:(?P<link_encap>\S+)\s+' +
                     r'(HWaddr\s+(?P<hardware_address>\S+))?' +
                     r'(\s+inet addr:(?P<ip_address>\S+))?' +
                     r'(\s+inet6 addr:(?P<ipv6_address>\S+)Scope:Global)?' +
                     r'(\s+Bcast:(?P<broadcast_address>\S+)\s+)?' +
                     r'(Mask:(?P<net_mask>\S+)\s+)?',
                     ifconfig_output, re.MULTILINE|re.IGNORECASE )
    if mo:
        info = mo.groupdict('')
        info['running'] = False
        info['up'] = False
        info['multicast'] = False
        info['broadcast'] = False
        if 'RUNNING' in ifconfig_output:
            info['running'] = True
        if 'UP' in ifconfig_output:
            info['up'] = True
        if 'BROADCAST' in ifconfig_output:
            info['broadcast'] = True
        if 'MULTICAST' in ifconfig_output:
            info['multicast'] = True
        return info
    return {}
 

def ifconfig_to_dict(ifconfig):
    interfaces = [ _extract(interface) for interface in ifconfig.split('\n\n') if interface.strip() ]
    return interfaces

def ifconfig_to_json(ifconfig, indent=4):
    interfaces = ifconfig_to_dict(ifconfig)
    return json.dumps(interfaces, indent=indent)
########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = admin
import os

from django.contrib import admin
from django.conf import settings

from nodeshot.core.base.admin import BaseAdmin, BaseStackedInline
from .models import DeviceConnector


class DeviceConnectorAdmin(BaseAdmin):
    list_display  = (
        'host', 'device', 'node',
        'port', 'backend', 'added', 'updated'
    )
    list_filter   = ('backend', 'added')
    date_hierarchy = 'added'
    ordering = ('-id',)
    search_fields = ('host', 'data')
    
    if 'grappelli' in settings.INSTALLED_APPS:
        raw_id_fields = ('node', 'device')
        autocomplete_lookup_fields = {
            'fk': ('node', 'device'),
        }
        
        change_form_template = '%s/templates/admin/device_connector_customization.html' % os.path.dirname(os.path.realpath(__file__))

admin.site.register(DeviceConnector, DeviceConnectorAdmin)


# ------ Extend Default Device Admin ------ #


from nodeshot.networking.net.models import Device
from nodeshot.networking.net.admin import DeviceAdmin as BaseDeviceAdmin


class DeviceConnectorInline(BaseStackedInline):
    model = DeviceConnector
    extra = 0
    sortable_field_name = 'order'
    exclude = ['node']


class DeviceAdmin(BaseDeviceAdmin):
    """
    add DeviceConnectorInline to inlines of DeviceAmin
    """
    inlines = BaseDeviceAdmin.inlines + [DeviceConnectorInline]


# unregister BaseDeviceAdmin
admin.site.unregister(Device)
admin.site.register(Device, DeviceAdmin)
########NEW FILE########
__FILENAME__ = device_connector
import inspect
from importlib import import_module
from netengine.exceptions import NetEngineError

from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.core.exceptions import ValidationError
from django.conf import settings
from django_hstore.fields import DictionaryField

from nodeshot.core.base.models import BaseDate, BaseOrdered
from nodeshot.core.base.managers import HStoreNodeshotManager
from nodeshot.networking.net.models import *
from nodeshot.networking.net.models.choices import DEVICE_STATUS
from nodeshot.core.base.utils import now

if 'nodeshot.networking.hardware' in settings.INSTALLED_APPS:
    HARDWARE_INSTALLED = True
    from nodeshot.networking.hardware.models import DeviceModel, Manufacturer, DeviceToModelRel
else:
    HARDWARE_INSTALLED = False


class DeviceConnector(BaseDate, BaseOrdered):
    """
    DeviceConnector Model
    """
    backend = models.CharField(_('backend'), max_length=128,
                              choices=settings.NODESHOT['NETENGINE_BACKENDS'],
                              help_text=_('select the operating system / protocol to use to retrieve info from device'))
    node = models.ForeignKey('nodes.Node', verbose_name=_('node'))
    host = models.CharField(_('host'), max_length=128)
    config = DictionaryField(_('config'), blank=True, null=True,
                            help_text=_('backend specific parameters, eg: username/password (SSH), community (SNMP)'))
    port = models.IntegerField(_('port'), blank=True, null=True,
                               help_text=_('leave blank to use the default port for the protocol in use'))
    store = models.BooleanField(_('store in DB?'),
                                default=True,
                                help_text=_('is adviced to store read-only credentials only'))
    device = models.ForeignKey(Device, verbose_name=_('device'),
                               blank=True, null=True,
                               help_text=_('leave blank, will be created automatically'))
    
    # django manager
    objects = HStoreNodeshotManager()
    
    __netengine = None
    __backend_class = None
    
    class Meta:
        ordering = ["order"]
        app_label = 'connectors'
        verbose_name = _('device connector')
        verbose_name_plural = _('device connectors')
    
    def __unicode__(self):
        if self.host:
            return self.host
        else:
            return _(u'Unsaved Device Connector')
    
    def save(self, *args, **kwargs):
        """
        Custom save does the following:
            * strip trailing whitespace from host attribute
            * create device and all other related objects
            * store connection config in DB if store attribute is True
        """
        self.host = self.host.strip()
        
        if not self.id:
            self.device = self.__create_device()
        
        if self.store is True:
            super(DeviceConnector, self).save(*args, **kwargs)
    
    def clean(self, *args, **kwargs):
        """ validation """
        self._validate_backend()
        self._validate_config()
        self._validate_netengine()
        self._validate_duplicates()
    
    @property
    def REQUIRED_CONFIG_KEYS(self):
        return self._get_netengine_arguments(required=True)
    
    @property
    def AVAILABLE_CONFIG_KEYS(self):
        return self._get_netengine_arguments()
    
    @property
    def backend_class(self):
        """
        returns python netengine backend class, importing it if needed
        """
        if not self.backend:
            return None
        
        if not self.__backend_class:
            self.__backend_class = self._get_netengine_backend()
        
        return self.__backend_class
    
    @property
    def netengine(self):
        """ access netengine instance """
        # return None if no backend chosen yet
        if not self.backend:
            return None
        
        # init instance of the netengine backend if not already done
        if not self.__netengine:
            NetengineBackend = self.backend_class
            arguments = self._build_netengine_arguments()
            
            self.__netengine = NetengineBackend(**arguments)
        
        # return netengine instance
        return self.__netengine
    
    def _validate_backend(self):
        """ ensure backend string representation is correct """
        try:
            self.backend_class
        # if we get an import error the specified path is wrong
        except (ImportError, AttributeError) as e:
            raise ValidationError(_('No valid backend found, got the following python exception: "%s"') % e)
    
    def _validate_config(self):
        """ ensure REQUIRED_CONFIG_KEYS are filled """
        # exit if no backend specified
        if not self.backend:
            return
        # exit if no required config keys
        if len(self.REQUIRED_CONFIG_KEYS) < 1:
            return
        
        self.config = self.config or {}  # default to empty dict of no config
        required_keys_set = set(self.REQUIRED_CONFIG_KEYS)
        config_keys_set = set(self.config.keys())
        missing_required_keys = required_keys_set - config_keys_set
        unrecognized_keys = config_keys_set - required_keys_set
        
        # if any missing required key raise ValidationError
        if len(missing_required_keys) > 0:
            # converts list in comma separated string
            missing_keys_string = ', '.join(missing_required_keys)
            # django error
            raise ValidationError(_('Missing required config keys: "%s"') % missing_keys_string)
        elif len(unrecognized_keys) > 0:
            # converts list in comma separated string
            unrecognized_keys_string = ', '.join(unrecognized_keys)
            # django error
            raise ValidationError(_('Unrecognized config keys: "%s"') % unrecognized_keys_string)
    
    def _validate_netengine(self):
        """
        call netengine validate() method
        verifies connection parameters are correct
        """
        if self.backend:
            try:
                self.netengine.validate()
            except NetEngineError as e:
                raise ValidationError(e)
    
    def _validate_duplicates(self):
        """
        Ensure we're not creating a device that already exists
        Runs only when the DeviceConnector object is created, not when is updated
        """
        # if connector is being created right now
        if not self.id:
            duplicates = []
            self.netengine_dict = self.netengine.to_dict()
            # loop over interfaces and check mac address
            for interface in self.netengine_dict['interfaces']:
                # avoid checking twice for the same interface (often ifconfig returns duplicates)
                if interface['mac_address'] in duplicates:
                    continue
                # check in DB
                if Interface.objects.filter(mac__iexact=interface['mac_address']).count() > 0:
                    duplicates.append(interface['mac_address'])
            
            # if we have duplicates raise validation error
            if len(duplicates) > 0:
                mac_address_string = ', '.join(duplicates)
                raise ValidationError(_('interfaces with the following mac addresses already exist: %s') % mac_address_string)
    
    def _get_netengine_arguments(self, required=False):
        """
        returns list of available config params
        returns list of required config params if required is True
        for internal use only
        """
        # inspect netengine class
        backend_class = self._get_netengine_backend()
        argspec = inspect.getargspec(backend_class.__init__)
        # store args
        args = argspec.args
        # remove known arguments
        for argument_name in ['self', 'host', 'port']:
            args.remove(argument_name)
        
        if required:
            # list of default values
            default_values = list(argspec.defaults)
            # always remove last default value, which is port number
            default_values = default_values[0:-1]
            
            # remove an amount of arguments equals to number of default values, starting from right
            args = args[0:len(args)-len(default_values)]
        
        return args
    
    def _get_netengine_backend(self):
        """
        returns the netengine backend specified in self.backend
        for internal use only
        """
        # extract backend class name, eg: AirOS or OpenWRT
        backend_class_name = self.backend.split('.')[-1]
        # convert to lowercase to get the path
        backend_path = self.backend.lower()
        # import module by its path
        module = import_module(backend_path)
        # get netengine backend class
        BackendClass = getattr(module, backend_class_name)
        
        return BackendClass
    
    def _build_netengine_arguments(self):
        """
        returns a python dictionary representing arguments
        that will be passed to a netengine backend
        for internal use only
        """
        arguments = {
            "host": self.host
        }
        
        if self.config is not None:
            for key, value in self.config.iteritems():
                arguments[key] = value
        
        if self.port:
            arguments["port"] = self.port
        
        return arguments
    
    def get_auto_order_queryset(self):
        """
        Overriding a method of BaseOrdered Abstract Model
        """
        return self.__class__.objects.filter(device=self.device)
    
    def __create_device(self):
        """
        creates device, internal use only
        """
        # retrieve netengine dictionary from memory or from network
        device_dict = getattr(self, 'netengine_dict', self.netengine.to_dict())
        device = Device()
        device.node_id = self.node_id
        device.name = device_dict['name']
        device.type = device_dict['type']
        device.status = DEVICE_STATUS.get('reachable')
        device.os = device_dict['os']
        device.os_version = device_dict['os_version']
        # this is the first time the device is seen by the system because we are just adding it
        device.first_seen = now()
        # and is also the latest
        device.last_seen = now()
        device.full_clean()
        device.save()
        
        # add routing protocols
        for routing_protocol in device_dict['routing_protocols']:
            # retrieve routing protocol from DB
            try:
                rp = RoutingProtocol.objects.filter(
                    name__iexact=routing_protocol['name'],
                    version__iexact=routing_protocol['version']
                )[0]
            # create if doesn't exist yet
            except IndexError:
                rp = RoutingProtocol(
                    name=routing_protocol['name'],
                    version=routing_protocol['version']
                )
                rp.full_clean()
                rp.save()
            # add to device
            device.routing_protocols.add(rp)
        
        for interface in device_dict['interfaces']:
            interface_object = False
            vap_object = False
            # create interface depending on type
            if interface['type'] == 'ethernet':
                interface_object = Ethernet(**{
                    'device': device,
                    'name': interface['name'],
                    'mac': interface['mac_address'],
                    'mtu': interface['mtu'],
                    'standard': interface['standard'],
                    'duplex': interface['duplex'],
                    'tx_rate': interface['tx_rate'],
                    'rx_rate': interface['rx_rate']
                })
            elif interface['type'] == 'wireless':
                interface_object = Wireless(**{
                    'device': device,
                    'name': interface['name'],
                    'mac': interface['mac_address'],
                    'mtu': interface['mtu'],
                    'mode': interface['mode'],
                    'standard': interface['standard'],
                    'channel': interface['channel'],
                    'channel_width': interface['channel_width'],
                    'output_power': interface['output_power'],
                    'dbm': interface['dbm'],
                    'noise': interface['noise'],
                    'tx_rate': interface['tx_rate'],
                    'rx_rate': interface['rx_rate']
                })
                
                for vap in interface['vap']:
                    vap_object = Vap(
                        essid=vap['essid'],
                        bssid=vap['bssid'],
                        encryption=vap['encryption']
                    )
            
            if interface_object:
                interface_object.full_clean()
                interface_object.save()
                
                if vap_object:
                    vap_object.interface = interface_object
                    vap_object.full_clean()
                    vap_object.save()
                
                for ip in interface['ip']:
                    ip_object = Ip(**{
                        'interface': interface_object,
                        'address': ip['address'],
                    })
                    ip_object.full_clean()
                    ip_object.save()
        
        if HARDWARE_INSTALLED:
            # try getting device model from db
            try:
                device_model = DeviceModel.objects.filter(name__iexact=device_dict['model'])[0]
            # if it does not exist create it
            except IndexError as e:
                # try getting manufacturer from DB
                try:
                    manufacturer = Manufacturer.objects.filter(name__iexact=device_dict['manufacturer'])[0]
                # or create
                except IndexError as e:
                    manufacturer = Manufacturer(name=device_dict['manufacturer'])
                    manufacturer.full_clean()
                    manufacturer.save()
                
                device_model = DeviceModel(
                    manufacturer=manufacturer,
                    name=device_dict['model']
                )
                device_model.ram = device_dict['RAM_total']
            
            device_model.full_clean()
            device_model.save()
            
            # create relation between device model and device
            rel = DeviceToModelRel(device=device, model=device_model)
            rel.full_clean()
            rel.save()
        
        return device
########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.networking.connectors unit tests
"""

import simplejson as json

from netengine.backends.ssh import OpenWRT
from netengine.exceptions import NetEngineError

from django.core.exceptions import ValidationError
from django.core.urlresolvers import reverse

from nodeshot.core.base.tests import BaseTestCase
from nodeshot.core.base.tests import user_fixtures
from nodeshot.networking.net.models import *

from .models import DeviceConnector


class ConnectorTest(BaseTestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_routing_protocols.json',
        'test_devices.json',
        'test_interfaces.json',
        'test_ip_addresses.json'
    ]
    
    def setUp(self):
        self.client.login(username='admin', password='tester')
        self.c1 = DeviceConnector.objects.create(backend='netengine.backends.Dummy',
                                                 node_id=1,
                                                 host='127.0.0.1')
    
    def test_unicode(self):
        unicode(self.c1)
    
    def test_admin_changelist(self):
        url = reverse('admin:connectors_deviceconnector_changelist')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
    
    def test_admin_change(self):
        url = reverse('admin:connectors_deviceconnector_change', args=[self.c1.id])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
    
    def test_saved_data(self):
        c1 = self.c1
        self.assertEquals(c1.device.name, 'dummy')
        self.assertEquals(c1.device.os, 'dummyOS')
        self.assertEquals(c1.device.interface_set.count(), 2)
        
        # ensure a new routing protocol has been created
        rp_count = RoutingProtocol.objects.filter(name='olsr', version='dummy version').count()
        self.assertEquals(rp_count, 1)
        
        # ensure vap interfaces have been created
        wireless = Wireless.objects.filter(device=c1.device)[0]
        self.assertEquals(wireless.vap_set.count(), 1)
    
    def test_get_netengine_backend(self):
        self.c1.backend = 'netengine.backends.ssh.OpenWRT'
        NetEngineBackend = self.c1._get_netengine_backend()
        self.assertTrue(NetEngineBackend is OpenWRT)
    
    def test_build_netengine_arguments(self):
        c1 = DeviceConnector(
            backend='netengine.backends.ssh.OpenWRT',
            host='127.0.0.1',
            config = {
                'username': 'root',
                'password':'test'
            }
        )
        arguments = c1._build_netengine_arguments()
        test_arguments = {
            'host': self.c1.host,
            'username': 'root',
            'password': 'test'
        }
        self.assertEqual(arguments, test_arguments)
        
        c1.port = 20200
        test_arguments['port'] = 20200
        arguments = c1._build_netengine_arguments()
        self.assertEqual(arguments, test_arguments)
        
        c1.config = {}
        c1.port = None
        arguments = c1._build_netengine_arguments()
        self.assertEqual(arguments, { 'host': self.c1.host })
    
    def test_get_netengine_arguments(self):
        c1 = DeviceConnector(
            backend='netengine.backends.ssh.OpenWRT',
            host='127.0.0.1',
            config = {
                'username': 'root',
                'password':'test'
            }
        )
        self.assertEqual(c1._get_netengine_arguments(), ['username', 'password'])
        self.assertEqual(c1.AVAILABLE_CONFIG_KEYS, ['username', 'password'])
        self.assertEqual(c1._get_netengine_arguments(required=True), ['username', 'password'])
        self.assertEqual(c1.REQUIRED_CONFIG_KEYS, ['username', 'password'])
        
        c2 = DeviceConnector()
        c2.backend = 'netengine.backends.snmp.AirOS'
        self.assertEqual(c2._get_netengine_arguments(), ['community', 'agent'])
        self.assertEqual(c2.AVAILABLE_CONFIG_KEYS, ['community', 'agent'])
        self.assertEqual(c2._get_netengine_arguments(required=True), [])
        self.assertEqual(c2.REQUIRED_CONFIG_KEYS, [])
    
    def test_validation_ok(self):
        self.c1.device.delete()
        self.c1.delete()
        c2 = DeviceConnector()
        c2.backend = 'netengine.backends.Dummy'
        c2.node_id = self.c1.node_id
        c2.host = '127.0.0.1'
        c2.full_clean()
        c2.save()
    
    def test_validate_backend(self):
        # wrong connector class
        c1 = DeviceConnector(backend='iam.very.wrong',
                             node_id=1,
                             host='127.0.0.1')
        try:
            c1._validate_backend()
            self.fail('ValidationError not raised')
        except ValidationError as e:
            self.assertIn('iam.very.wrong', e.messages[0])
            self.assertEquals(len(e.messages), 1)
    
    def test_validate_config_missing_keys(self):
        # missing username and password
        c2 = DeviceConnector()
        c2.backend = 'netengine.backends.ssh.AirOS'
        c2.node_id = self.c1.node_id
        c2.host = '127.0.0.1'
        try:
            c2._validate_config()
            self.fail('ValidationError not raised')
        except ValidationError as e:
            self.assertEquals(len(e.messages), 1)
            self.assertIn('username, password', e.messages[0])
        
        # missing password
        c2.config = { 'username': 'root' }
        try:
            c2._validate_config()
            self.fail('ValidationError not raised')
        except ValidationError as e:
            self.assertEquals(len(e.messages), 1)
            self.assertIn('password', e.messages[0])
        
        # missing username
        c2.config = { 'password': 'test' }
        try:
            c2._validate_config()
            self.fail('ValidationError not raised')
        except ValidationError as e:
            self.assertEquals(len(e.messages), 1)
            self.assertIn('username', e.messages[0])
        
        # nothing missing
        c2.config['username'] = 'test'
        c2._validate_config()
    
    def test_validate_config_unrecognized_keys(self):
        c2 = DeviceConnector()
        c2.backend = 'netengine.backends.ssh.AirOS'
        c2.node_id = self.c1.node_id
        c2.host = '127.0.0.1'
        
        # unrecoginzed parameter "wrong"
        c2.config = {
            'username': 'user',
            'password': 'test',
            'wrong': 'wrong'
        }
        try:
            c2._validate_config()
            self.fail('ValidationError not raised')
        except ValidationError as e:
            self.assertEquals(len(e.messages), 1)
            self.assertIn('wrong', e.messages[0])
        
        # no unrecognized keys
        c2.config.pop('wrong')
        c2._validate_config()
    
    def test_validate_netengine(self):
        c1 = DeviceConnector(
            backend='netengine.backends.ssh.AirOS',
            host='192.168.1.254',
            config = {
                'username': 'user',
                'password':'test'
            }
        )
        # expect connection error
        with self.assertRaises(ValidationError):
            c1._validate_netengine()
    
    def test_validate_duplicates(self):
        dup = DeviceConnector(backend='netengine.backends.Dummy',
                              node_id=1,
                              host='127.0.0.1')
        
        try:
            dup._validate_duplicates()
            self.fail('ValidationError not raised')
        except ValidationError as e:
            self.assertEquals(len(e.messages), 1)
            self.assertIn('de:9f:db:30:c9:c4', e.messages[0])
            self.assertIn('de:9f:db:30:c9:c5', e.messages[0])
########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.db import models

from nodeshot.core.base.admin import BaseAdmin, BaseStackedInline
from nodeshot.core.base.widgets import AdvancedFileInput
from nodeshot.networking.net.admin import DeviceAdmin

from models import *


class MacPrefixInline(admin.StackedInline):
    model = MacPrefix
    extra = 0
    inline_classes = ('grp-collapse grp-open',)


class ManufacturerAdmin(BaseAdmin):
    list_display  = ('name', 'image_img_tag', 'url_tag', 'added', 'updated')
    list_display_links = ('name', 'image_img_tag')
    search_fields = ('name',)
    inlines = [MacPrefixInline]
    
    formfield_overrides = {
        models.ImageField: {'widget': AdvancedFileInput(image_width=250)},
    }


class DeviceModelAdmin(BaseAdmin):
    list_display  = ('name', 'image_img_tag', 'added', 'updated')
    list_display_links = ('name', 'image_img_tag')
    search_fields = ('name',)
    
    formfield_overrides = {
        models.ImageField: {'widget': AdvancedFileInput(image_width=250)},
    }


class RadiationPatternInline(BaseStackedInline):
    model = RadiationPattern
    extra = 0
    inline_classes = ('grp-collapse grp-open',)


class AntennaModelAdmin(BaseAdmin):
    list_display  = ('name', 'image_img_tag', 'added', 'updated')
    list_display_links = ('name', 'image_img_tag')
    search_fields = ('name',)
    inlines = [RadiationPatternInline]
    
    formfield_overrides = {
        models.ImageField: {'widget': AdvancedFileInput(image_width=250)},
    }


admin.site.register(Manufacturer, ManufacturerAdmin)
admin.site.register(DeviceModel, DeviceModelAdmin)
admin.site.register(AntennaModel, AntennaModelAdmin)


# Extend Default Device Admin

class DeviceToModelRelInline(admin.StackedInline):
    model = DeviceToModelRel
    inline_classes = ('grp-collapse grp-open',)
    
    raw_id_fields = ('model',)
    autocomplete_lookup_fields = {
        'fk': ['model'],
    }


class AntennaInline(BaseStackedInline):
    model = Antenna
    extra = 0
    inline_classes = ('grp-collapse grp-open',)
    
    raw_id_fields = ('model',)
    autocomplete_lookup_fields = {
        'fk': ['model'],
    }


DeviceAdmin.inlines.insert(0, DeviceToModelRelInline)
DeviceAdmin.inlines.insert(1, AntennaInline)

########NEW FILE########
__FILENAME__ = antenna
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from nodeshot.networking.net.models import Device, Interface

from choices import POLARIZATION_CHOICES
from . import AntennaModel


class Antenna(BaseDate):
    """ Antenna of a device. A device may have more than one antenna """
    # device foreign key is redundant but it allows us to manage it easily in the django admin
    device = models.ForeignKey(Device)
    model = models.ForeignKey(AntennaModel)
    radio = models.ForeignKey(Interface, blank=True, null=True) #TODO: this should not be blank nor null
    polarization = models.SmallIntegerField(_('Polarization'), choices=POLARIZATION_CHOICES, blank=True, null=True)
    azimuth = models.FloatField(_('azimuth'), blank=True, null=True)
    inclination = models.FloatField(_('inclination'), blank=True, null=True)
    
    # TODO: this must become a postgis point
    # elevation = models.FloatField(_('elevation'), blank=True, null=True)
    # lat = models.FloatField(_('latitude'), blank=True, null=True, help_text=_('automatically inherits the value of the node, specify a different value if needed'))
    # lng = models.FloatField(_('longitude'), blank=True, null=True, help_text=_('automatically inherits the value of the node, specify a different value if needed'))
    
    class Meta:
        app_label = 'hardware'
    
    def __unicode__(self):
        return self.model.__unicode__()
    
    def save(self, *args, **kwargs):
        """
        1. set polarization according to AntennaModel (self.model.polarization) when creating a new antenna
        2. inherit latitude and longitude from node
        """
        if not self.pk and self.model.polarization:
            self.polarization = self.model.polarization
        super(Antenna, self).save(*args, **kwargs)

########NEW FILE########
__FILENAME__ = antenna_model
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from choices import POLARIZATION_CHOICES

from . import ImageMixin, DeviceModel, Manufacturer


class AntennaModel(BaseDate, ImageMixin):
    """
    Antenna Type Model
    Eg: Airmax Sector, Rocket Dish, ecc.
    """
    name = models.CharField(_('name'), max_length=50, unique=True)
    device_model = models.OneToOneField(DeviceModel, blank=True, null=True, help_text=_('specify only if it\'s an integrated antenna'))
    manufacturer = models.ForeignKey(Manufacturer)
    gain = models.DecimalField(_('gain'), max_digits=4, decimal_places=1, help_text=_('dBi'))
    polarization = models.SmallIntegerField(_('Polarization'), choices=POLARIZATION_CHOICES, blank=True, null=True)
    freq_range_lower = models.IntegerField(_('minimum Frequency'), help_text=_('MHz'))
    freq_range_higher = models.IntegerField(_('maximum Frequency'), help_text=_('MHz'))
    beamwidth_h = models.DecimalField(_('hpol Beamwidth'), max_digits=4, decimal_places=1, help_text=_('degrees'))
    beamwidth_v = models.DecimalField(_('vpol Beamwidth'), max_digits=4, decimal_places=1, help_text=_('degrees'))
    image = models.ImageField(_('image'), upload_to='antennas/images/', blank=True)
    datasheet = models.FileField(_('datasheet'), upload_to='antennas/datasheets/', blank=True)
    
    def __unicode__(self):
        return self.name
    
    class Meta:
        app_label= 'hardware'
        db_table = 'hardware_antenna_model'

########NEW FILE########
__FILENAME__ = base
from django.db import models
from django.conf import settings
from django.utils.translation import ugettext_lazy as _


class ImageMixin(models.Model):
    """
    Abstract model with few useful methods to display an image
    """
    
    image_width = 80
    
    class Meta:
        abstract = True
    
    def __unicode__(self, *args, **kwargs):
        return self.name
    
    def image_url(self):
        return '%s%s' % (settings.MEDIA_URL, self.image) 
    
    def image_img_tag(self):
        if self.image != '':
            return '<img src="%s" alt="" style="width:%spx" />' % (self.image_url(), self.image_width)
        else:
            return _('No image available')
    
    image_img_tag.allow_tags = True
########NEW FILE########
__FILENAME__ = choices
from nodeshot.core.base.utils import choicify


POLARIZATIONS = {
    'horizonal': 1,
    'vertical': 2,
    'circular': 3,
    'linear': 4,
    'dual_linear': 5
}

POLARIZATION_CHOICES = choicify(POLARIZATIONS)

########NEW FILE########
__FILENAME__ = device_model
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from . import ImageMixin, Manufacturer


class DeviceModel(BaseDate, ImageMixin):
    """
    Device Type Model
    Eg.: Nanostation M5, Rocket M2, ecc.
    """
    manufacturer = models.ForeignKey(Manufacturer)
    name = models.CharField(_('name'), max_length=50, unique=True)
    image = models.ImageField(_('image'), upload_to='devices/images/', blank=True)
    datasheet = models.FileField(_('datasheet'), upload_to='devices/datasheets/', blank=True)
    cpu = models.CharField(_('CPU'), max_length=255, blank=True)
    ram = models.IntegerField(_('RAM'), blank=True, help_text=_('bytes'))
    
    def __unicode__(self):
        return self.name
    
    class Meta:
        app_label= 'hardware'
        db_table = 'hardware_device_model'
        verbose_name = _('Device Model')
        verbose_name_plural = _('Device Models')

########NEW FILE########
__FILENAME__ = device_to_model_rel
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.networking.net.models import Device
from . import DeviceModel, Antenna, AntennaModel


class DeviceToModelRel(models.Model):
    """ OneToOne relationship between net.Device and hardware.DeviceModel """
    device = models.OneToOneField(Device, verbose_name=_('device'), related_name='hardware')
    model = models.ForeignKey(DeviceModel)
    cpu = models.CharField(_('CPU'), max_length=255, blank=True)
    ram = models.IntegerField(_('RAM'), blank=True, help_text=_('bytes'))
    
    class Meta:
        app_label= 'hardware'
        db_table = 'hardware_device_to_model'
        verbose_name = _('Device Model Information')
        verbose_name_plural = _('Device Model Information')
    
    def __unicode__(self):
        return '%s (%s)' % (self.device.name, self.model.name)
    
    def save(self, *args, **kwargs):
        """ when creating a new record fill CPU and RAM info if available """
        adding_new = False
        if not self.pk or (not self.cpu and not self.ram):
            # if self.model.cpu is not empty
            if self.model.cpu:
                self.cpu = self.model.cpu
            # if self.model.ram is not empty
            if self.model.ram:
                self.ram = self.model.ram
            # mark to add a new antenna
            adding_new = True
        # perform save
        super(DeviceToModelRel, self).save(*args, **kwargs)
        # after Device2Model object has been saved
        try:
            # does the device model have an integrated antenna?
            antenna_model = self.model.antennamodel
        except AntennaModel.DoesNotExist:
            # if not antenna_model is False
            antenna_model = False
        # if we are adding a new device2model and the device model has an integrated antenna
        if adding_new and antenna_model:
            # create new Antenna object
            antenna = Antenna(
                device=self.device,
                model=self.model.antennamodel
            )
            # retrieve wireless interfaces and assign it to the antenna object if possible
            wireless_interfaces = self.device.interface_set.filter(type=2)
            if len(wireless_interfaces) > 0:
                antenna.radio = wireless_interfaces[0]
            # save antenna
            antenna.save()

########NEW FILE########
__FILENAME__ = mac_prefix
from django.db import models
from django.utils.translation import ugettext_lazy as _

from . import Manufacturer


class MacPrefix(models.Model):
    """ Mac prefix of a Manufacturer """
    manufacturer = models.ForeignKey(Manufacturer, verbose_name=_('manufacturer'))
    prefix = models.CharField(_('mac address prefix'), max_length=8, unique=True)
    
    def __unicode__(self):
        return self.prefix
    
    class Meta:
        app_label= 'hardware'
        verbose_name = _('MAC Prefix')
        verbose_name_plural = _('MAC Prefixes')

########NEW FILE########
__FILENAME__ = manufacturer
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from . import ImageMixin


class Manufacturer(BaseDate, ImageMixin):
    """
    Manufacturer Model
    Eg: Ubiquiti, Mikrotic, Dlink, ecc.
    """
    name = models.CharField(_('name'), max_length=50, unique=True)
    url = models.URLField(_('url'), blank=True)
    image = models.ImageField(_('logo'), blank=True, upload_to='manufacturers/')
    image_width = 180
    
    class Meta:
        app_label= 'hardware'
        verbose_name = _('Manufacturer')
        verbose_name_plural = _('Manufacturers')
        ordering = ['name']
    
    def __unicode__(self):
        return self.name
    
    def url_tag(self):
        return '<a href="%s" target="_blank">%s</a>' % (self.url, self.url)
        
    url_tag.allow_tags = True

########NEW FILE########
__FILENAME__ = radiation_pattern
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from . import ImageMixin, AntennaModel


class RadiationPattern(BaseDate, ImageMixin):
    """ Radiation Pattern of an Antenna Model """
    antenna_model = models.ForeignKey(AntennaModel)
    type = models.CharField(_('type'), max_length=30)
    image = models.ImageField(upload_to='antennas/radiation_patterns/', verbose_name=_('image'))
    
    def __unicode__(self):
        return _('radiation pattern for antenna model: %s' % self.antenna_model)
    
    class Meta:
        app_label= 'hardware'
        db_table = 'hardware_radiation_pattern'

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin

from nodeshot.core.base.admin import BaseGeoAdmin
from .models import Link


class LinkAdmin(BaseGeoAdmin):
    list_display  = (
        '__unicode__',
        'type',
        'status',
        'interface_a_mac',
        'interface_b_mac',
        'added',
        'updated'
    )
    list_filter   = ('status', 'type')
    date_hierarchy = 'added'
    ordering = ('-id',)
    
    raw_id_fields = ('interface_a', 'interface_b', 'node_a', 'node_b')
    autocomplete_lookup_fields = {
        'fk': ['interface_a', 'interface_b', 'node_a', 'node_b'],
    }
    
    readonly_fields = [
        'first_seen', 'last_seen',
        'metric_value', 'min_rate', 'max_rate',
        'dbm', 'noise'
    ] + BaseGeoAdmin.readonly_fields[:]
    exclude = ('shortcuts',)


admin.site.register(Link, LinkAdmin)

########NEW FILE########
__FILENAME__ = choices

LINK_STATUS = {
    'archived': -3,
    'disconnected': -2,
    'down': -1,
    'planned': 0,
    'testing': 1,
    'active': 2
}

LINK_TYPES = {
    'radio': 1,
    'ethernet': 2,
    'fiber': 3,
    'other_wired': 4,
    'virtual': 5
}

# TODO: pheraphs this would be better to make it customizable from settings
METRIC_TYPES = {
    'ETX': 'etx',
    'ETC': 'etc',
    'HOP': 'hop'
}
########NEW FILE########
__FILENAME__ = link
from django.contrib.gis.db import models
from django.contrib.gis.geos import LineString
from django.utils.translation import ugettext_lazy as _
from django.core.exceptions import ValidationError

from django_hstore.fields import DictionaryField, ReferencesField

from nodeshot.core.base.managers import HStoreGeoAccessLevelManager as LinkManager
from nodeshot.core.base.models import BaseAccessLevel
from nodeshot.core.base.utils import choicify

from nodeshot.core.nodes.models import Node
from nodeshot.networking.net.models import Interface
from nodeshot.networking.net.models.choices import INTERFACE_TYPES

from .choices import METRIC_TYPES, LINK_STATUS, LINK_TYPES


class Link(BaseAccessLevel):
    """
    Link Model
    Designed for both wireless and wired links
    """
    type = models.SmallIntegerField(_('type'), max_length=10, null=True, blank=True,
                                    choices=choicify(LINK_TYPES), default=LINK_TYPES.get('radio'))
    
    # in most cases these two fields are mandatory, except for "planned" links
    interface_a = models.ForeignKey(Interface, verbose_name=_('from interface'),
                                    related_name='link_interface_from', blank=True, null=True,
                                    help_text=_('mandatory except for "planned" links (in planned links you might not have any device installed yet)'))
    interface_b = models.ForeignKey(Interface, verbose_name=_('to interface'),
                                    related_name='link_interface_to', blank=True, null=True,
                                    help_text=_('mandatory except for "planned" links (in planned links you might not have any device installed yet)'))
    
    # in "planned" links these two fields are necessary
    # while in all the other status they serve as a shortcut
    node_a = models.ForeignKey(Node, verbose_name=_('from node'),
                               related_name='link_node_from', blank=True, null=True,
                               help_text=_('leave blank (except for planned nodes) as it will be filled in automatically'))
    node_b = models.ForeignKey(Node, verbose_name=_('to node'),
                               related_name='link_node_to', blank=True, null=True,
                               help_text=_('leave blank (except for planned nodes) as it will be filled in automatically'))
    
    # geospatial info
    line = models.LineStringField(blank=True, null=True, help_text=_('leave blank and the line will be drawn automatically'))
    
    # monitoring info
    status = models.SmallIntegerField(_('status'), choices=choicify(LINK_STATUS), default=LINK_STATUS.get('planned'))
    first_seen = models.DateTimeField(_('first time seen on'), blank=True, null=True, default=None)
    last_seen = models.DateTimeField(_('last time seen on'), blank=True, null=True, default=None)
    
    # technical info
    metric_type = models.CharField(_('metric type'), max_length=6,
                                   choices=choicify(METRIC_TYPES), blank=True, null=True)
    metric_value = models.FloatField(_('metric value'), blank=True, null=True)
    max_rate = models.IntegerField(_('Maximum BPS'), null=True, default=None, blank=True)
    min_rate = models.IntegerField(_('Minimum BPS'), null=True, default=None, blank=True)
    
    # wireless specific info
    dbm = models.IntegerField(_('dBm average'), null=True, default=None, blank=True)
    noise = models.IntegerField(_('noise average'), null=True, default=None, blank=True)
    
    # additional data
    data = DictionaryField(_('extra data'), null=True, blank=True,
                           help_text=_('store extra attributes in JSON string'))
    shortcuts = ReferencesField(null=True, blank=True)
    
    # django manager
    objects = LinkManager()
    
    class Meta:
        app_label = 'links'
    
    def __unicode__(self):
        return _(u'%s <> %s') % (self.node_a_name, self.node_b_name)
    
    def clean(self, *args, **kwargs):
        """
        Custom validation
            1. interface_a and interface_b mandatory except for planned links
            2. planned links should have at least node_a and node_b filled in
            3. dbm and noise fields can be filled only for radio links
            4. interface_a and interface_b must differ
            5. interface a and b type must match
        """
        
        if self.status != LINK_STATUS.get('planned') and (self.interface_a is None or self.interface_b is None):
            raise ValidationError(_('fields "from interface" and "to interface" are mandatory in this case'))
        
        if self.status == LINK_STATUS.get('planned') and (self.node_a is None or self.node_b is None):
            raise ValidationError(_('fields "from node" and "to node" are mandatory for planned links'))
        
        if self.type != LINK_TYPES.get('radio') and (self.dbm is not None or self.noise is not None):
            raise ValidationError(_('Only links of type "radio" can contain "dbm" and "noise" information'))
        
        if (self.interface_a_id == self.interface_b_id) or (self.interface_a == self.interface_b):
            raise ValidationError(_('link cannot have same "from interface" and "to interface"'))
        
        if (self.interface_a and self.interface_b) and self.interface_a.type != self.interface_b.type:
            format_tuple = (self.interface_a.get_type_display(), self.interface_b.get_type_display())
            raise ValidationError(_('link cannot be between of interfaces of different types:\
                                    interface a is "%s" while b is "%s"') % format_tuple)
    
    def save(self, *args, **kwargs):
        """
        Custom save does the following:
            * determine link type if not specified
            * automatically fill 'node_a' and 'node_b' fields if necessary
            * draw line between two nodes
            * fill shortcut properties node_a_name and node_b_name
        """
        
        if not self.type:
            if self.interface_a.type == INTERFACE_TYPES.get('wireless'):
                self.type = LINK_TYPES.get('radio')
            elif self.interface_a.type == INTERFACE_TYPES.get('ethernet'):
                self.type = LINK_TYPES.get('ethernet')
            else:
                self.type = LINK_TYPES.get('virtual')
        
        if self.interface_a_id:
            self.interface_a = Interface.objects.get(pk=self.interface_a_id)
        if self.interface_b_id:
            self.interface_b = Interface.objects.get(pk=self.interface_b_id)
        
        # fill in node_a and node_b
        if self.node_a is None and self.interface_a is not None:
            self.node_a = self.interface_a.node
        if self.node_b is None and self.interface_b is not None:
            self.node_b = self.interface_b.node
        
        # draw linestring
        if not self.line:
            self.line = LineString(self.node_a.point, self.node_b.point)
        
        # fill properties
        if self.data is None or self.data.get('node_a_name', None) is None:
            self.data = self.data or {}  # in case is None init empty dict
            self.data['node_a_name'] = self.node_a.name
            self.data['node_b_name'] = self.node_b.name
        
        if self.data.get('node_a_slug', None) is None or self.data.get('node_b_slug', None) is None:
            self.data['node_a_slug'] = self.node_a.slug
            self.data['node_b_slug'] = self.node_b.slug
        
        if self.data.get('interface_a_mac', None) is None or self.data.get('interface_b_mac', None) is None:
            self.data['interface_a_mac'] = self.interface_a.mac
            self.data['interface_b_mac'] = self.interface_b.mac
        
        super(Link, self).save(*args, **kwargs)
    
    @property
    def node_a_name(self):
        self.data = self.data or {}
        return self.data.get('node_a_name', None)
    
    @property
    def node_b_name(self):
        self.data = self.data or {}
        return self.data.get('node_b_name', None)
    
    @property
    def node_a_slug(self):
        self.data = self.data or {}
        return self.data.get('node_a_slug', None)
    
    @property
    def node_b_slug(self):
        self.data = self.data or {}
        return self.data.get('node_b_slug', None)
    
    @property
    def interface_a_mac(self):
        self.data = self.data or {}
        return self.data.get('interface_a_mac', None)
    
    @property
    def interface_b_mac(self):
        self.data = self.data or {}
        return self.data.get('interface_b_mac', None)
    
    @property
    def quality(self):
        """
        Quality is a number between 1 and 6 that rates the quality of the link.
        The way quality is calculated might be overridden by settings.
        0 means unknown
        """
        if self.metric_value is None:
            return 0
        
        # PLACEHOLDER
        return 6

########NEW FILE########
__FILENAME__ = serializers
from rest_framework import pagination, serializers
from rest_framework_gis import serializers as gis_serializers

from nodeshot.core.base.serializers import DynamicRelationshipsMixin

from .models import *


__all__ = [
    'LinkListSerializer',
    'LinkDetailSerializer',
    'LinkListGeoJSONSerializer',
    'LinkDetailGeoJSONSerializer',
    'PaginatedLinkSerializer',
]

  
class LinkListSerializer(gis_serializers.GeoModelSerializer):
    """ location serializer  """
    
    quality = serializers.Field(source='quality')
    details = serializers.HyperlinkedIdentityField(view_name='api_link_details')
    
    class Meta:
        model = Link
        fields = ['id', 'line', 'quality', 'details']


class LinkListGeoJSONSerializer(LinkListSerializer, gis_serializers.GeoFeatureModelSerializer):
    class Meta:
        model = Link
        geo_field = 'line'
        fields = LinkListSerializer.Meta.fields[:]


class LinkDetailSerializer(DynamicRelationshipsMixin, LinkListSerializer):
    
    access_level = serializers.Field(source='get_access_level_display')
    status = serializers.Field(source='get_status_display')
    type = serializers.Field(source='get_type_display')
    node_a_name = serializers.Field(source='node_a_name')
    node_b_name = serializers.Field(source='node_b_name')
    interface_a_mac = serializers.Field(source='interface_a_mac')
    interface_b_mac = serializers.Field(source='interface_b_mac')
    relationships = serializers.SerializerMethodField('get_relationships')
    
    # this is needed to avoid adding stuff to DynamicRelationshipsMixin
    _relationships = {}

    class Meta:
        model = Link
        fields = [
            'id', 
            'node_a_name', 'node_b_name',
            'interface_a_mac', 'interface_b_mac',
            'access_level', 'status', 'type', 'line', 
            'quality', 'metric_type', 'metric_value',
            'max_rate', 'min_rate', 'dbm', 'noise',
            'first_seen', 'last_seen',
            'added', 'updated', 'relationships'
        ]

LinkDetailSerializer.add_relationship(
    'node_a',
    view_name='api_node_details',
    lookup_field='node_a_slug'
)

LinkDetailSerializer.add_relationship(
    'node_b',
    view_name='api_node_details',
    lookup_field='node_b_slug'
)


class LinkDetailGeoJSONSerializer(LinkDetailSerializer, gis_serializers.GeoFeatureModelSerializer):
    class Meta:
        model = Link
        geo_field = 'line'
        fields = LinkDetailSerializer.Meta.fields[:]


class PaginatedLinkSerializer(pagination.PaginationSerializer):
    class Meta:
        object_serializer_class = LinkListSerializer

########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.networking.links unit tests
"""

import simplejson as json

from django.core.exceptions import ValidationError
from django.core.urlresolvers import reverse

from nodeshot.core.base.tests import BaseTestCase
from nodeshot.core.base.tests import user_fixtures
from nodeshot.networking.net.models import Interface

from .models import Link
from .models.choices import LINK_STATUS, LINK_TYPES


class LinkTest(BaseTestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_routing_protocols.json',
        'test_devices.json',
        'test_interfaces.json',
        'test_ip_addresses.json'
    ]
    
    def setUp(self):
        l = Link()
        l.interface_a = Interface.objects.find(2)
        l.interface_b = Interface.objects.find(3)
        l.type = LINK_TYPES.get('radio')
        l.status = LINK_STATUS.get('active')
        self.link = l
    
    def test_non_radio_shouldnt_have_radio_info(self):
        """ *** A link of any type which is not "radio" should not have dBm or noise data *** """
        link = self.link
        link.type = LINK_TYPES.get('ethernet')
        link.dbm = -70
        link.noise = -90
        self.assertRaises(ValidationError, link.full_clean)
    
    def test_save_radio_link(self):
        """ *** It should be possible to save a new link *** """
        l = self.link
        l.type = LINK_TYPES.get('radio')
        l.dbm = -70
        l.noise = -90
        l.save()
        # delete variable l
        del l
        # retrieve link again from DB
        l = Link.objects.all()[0]
        # check everything worked
        self.assertTrue(l.type == 1 and l.dbm == -70 and l.noise == -90, "something went wrong while saving a new link")
    
    def test_null_interfaces(self):
        """ *** An active link with null 'from interface' and 'to interface' fields should not be saved  *** """
        l = Link(type=LINK_TYPES.get('radio'), status=LINK_TYPES.get('active'))
        self.assertRaises(ValidationError, l.full_clean)
    
    def test_auto_fill_node_fields(self):
        """ *** When a link with any type except for 'planned' is saved it should automatically fill the fields 'from node' and 'to node'  *** """
        l = self.link
        l.type = LINK_TYPES.get('radio')
        l.save()
        self.assertTrue(l.node_a != None and l.node_b != None, '"from node" and "to node" fields are null')
    
    def test_null_interface_and_node_fields(self):
        """ *** It should not be possible to save a link which has void node and interface info  *** """
        link = Link(type=LINK_TYPES.get('radio'), status=LINK_STATUS.get('planned'))
        self.assertRaises(ValidationError, link.full_clean)
    
    def test_same_to_and_from_interface(self):
        link = self.link
        link.interface_a = Interface.objects.find(1)
        link.interface_b = Interface.objects.find(1)
        with self.assertRaises(ValidationError):
            link.full_clean()
        
        link2 = self.link
        link2.interface_b_id = 1
        link2.interface_a_id = 1
        with self.assertRaises(ValidationError):
            link.full_clean()
    
    def test_auto_linestring(self):
        link = self.link
        self.assertIsNone(link.line)
        link.save()
        self.assertIsNotNone(link.line)
    
    def test_additional_properties(self):
        link = self.link
        link.interface_b = Interface.objects.find(3)  # different node
        self.assertIsNone(link.node_a_name)
        self.assertIsNone(link.node_b_name)
        self.assertIsNone(link.node_a_slug)
        self.assertIsNone(link.node_b_slug)
        self.assertIsNone(link.interface_a_mac)
        self.assertIsNone(link.interface_b_mac)
        link.save()
        link = Link.objects.find(link.id)
        self.assertEqual(link.node_a_name, link.node_a.name)
        self.assertEqual(link.node_b_name, link.node_b.name)
        self.assertEqual(link.node_a_slug, link.node_a.slug)
        self.assertEqual(link.node_b_slug, link.node_b.slug)
        self.assertEqual(link.interface_a_mac, link.interface_a.mac)
        self.assertEqual(link.interface_b_mac, link.interface_b.mac)
    
    def test_link_interface_type(self):
        link = self.link
        link.interface_a = Interface.objects.find(1)  # ethernet, while interface_b is wireless
        
        with self.assertRaises(ValidationError):
            link.full_clean()
    
    def test_auto_link_type(self):
        link = self.link
        link.type = None
        link.save()
        link = Link.objects.find(link.id)
        self.assertEqual(link.type, LINK_TYPES.get('radio'))
    
    def test_links_api(self):
        link = self.link
        link.save()
        link = Link.objects.find(link.id)
        
        # GET: 200 - link list
        url = reverse('api_link_list')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
        
        # GET: 200 - link list geojson
        url = reverse('api_links_geojson_list')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
        
        # GET: 200 - link details
        url = reverse('api_link_details', args=[link.id])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
        
        # GET: 200 - link details geojson
        url = reverse('api_links_geojson_details', args=[link.id])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
    
    def test_node_links_api(self):
        link = self.link
        link.save()
        link = Link.objects.find(link.id)
        
        # GET: 200 - node A
        url = reverse('api_node_links', args=[link.node_a.slug])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
        self.assertEquals(len(response.data), 1)
        
        # GET: 200 - node B
        url = reverse('api_node_links', args=[link.node_b.slug])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
        self.assertEquals(len(response.data), 1)
        
        # GET: 404
        url = reverse('api_node_links', args=['idontexist'])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 404)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.networking.links.views',
    url(r'^links/$', 'link_list', name='api_link_list'),
    url(r'^links/(?P<pk>[0-9]+)/$', 'link_details', name='api_link_details'),
    # geojson
    url(r'^links.geojson$', 'link_geojson_list', name='api_links_geojson_list'),
    url(r'^links/(?P<pk>[0-9]+).geojson$', 'link_geojson_details', name='api_links_geojson_details'),
    # node links
    url(r'^nodes/(?P<slug>[-\w]+)/links/$', 'node_link_list', name='api_node_links'),
)

########NEW FILE########
__FILENAME__ = views
from django.http import Http404
from django.utils.translation import ugettext_lazy as _
from django.db.models import Q

from rest_framework import authentication, generics

from nodeshot.core.base.mixins import ACLMixin
from nodeshot.core.nodes.models import Node

from .serializers import *
from .models import *


class LinkList(ACLMixin, generics.ListAPIView):
    """
    Retrieve link list according to user access level
    
    Parameters:
    
     * `limit=<n>`: specify number of items per page (defaults to 40)
     * `limit=0`: turns off pagination
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = Link.objects.all()
    serializer_class = LinkListSerializer
    pagination_serializer_class = PaginatedLinkSerializer
    paginate_by_param = 'limit'
    paginate_by = 40
    
link_list = LinkList.as_view()


class LinkGeoJSONList(ACLMixin, generics.ListAPIView):
    """
    Retrieve link list in GeoJSON format
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = Link.objects.all()
    serializer_class = LinkListGeoJSONSerializer
    
link_geojson_list = LinkGeoJSONList.as_view()


class LinkDetails(ACLMixin, generics.RetrieveAPIView):
    """
    Retrieve details of specified link
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = Link.objects.all()
    serializer_class = LinkDetailSerializer

link_details = LinkDetails.as_view()


class LinkGeoJSONDetails(LinkDetails):
    """
    Get link details in GeoJSON format
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = Link.objects.all()
    serializer_class = LinkDetailGeoJSONSerializer

link_geojson_details = LinkDetails.as_view()


class NodeLinkList(generics.ListAPIView):
    """
    Retrieve links of specified node according to user access level.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    serializer_class = LinkDetailSerializer
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure node exists and store it in an instance attribute
            * change queryset to return only links of current node
        """
        super(NodeLinkList, self).initial(request, *args, **kwargs)
        
        # ensure node exists
        try:
            self.node = Node.objects.published()\
                        .accessible_to(request.user)\
                        .get(slug=self.kwargs.get('slug', None))
        except Node.DoesNotExist:
            raise Http404(_('Node not found.'))
        
        # check permissions on node (for link creation)
        self.check_object_permissions(request, self.node)
        
        # return only links of current node
        self.queryset = Link.objects.select_related('node')\
                        .accessible_to(self.request.user)\
                        .filter(Q(node_a_id=self.node.id) | Q(node_b_id=self.node.id))
    
node_link_list = NodeLinkList.as_view()

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from nodeshot.networking.net.models import Device


class Server(BaseDate):
    layer = models.OneToOneField('layers.Layer', verbose_name=_('layer'))
    email = models.EmailField(_('email'), blank=True, null=True)
    url = models.URLField(_('url'))
    devices = models.ManyToManyField(Device, through='MonitoredDevices', verbose_name=_('devices'))
    
    class Meta:
        db_table = 'monitoring_server'


class MonitoredDevices(BaseDate):
    server = models.ForeignKey(Server, verbose_name=_('server'))
    device = models.ForeignKey(Device, verbose_name=_('device'))
    is_active = models.BooleanField(_('active'), default=True)
    
    class Meta:
        db_table = 'monitoring_monitored_devices'
########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.conf import settings

from nodeshot.core.base.admin import BaseAdmin, BaseGeoAdmin, BaseStackedInline

from .models.choices import INTERFACE_TYPES
from .models import *


class DeviceInline(BaseStackedInline):
    model = Device
    
    if not settings.DEBUG:
        readonly_fields =  [
            'status', 'first_seen', 'last_seen'
        ] + BaseStackedInline.readonly_fields
    
    if 'grappelli' in settings.INSTALLED_APPS:
        classes = ('grp-collapse grp-open', )
        
        raw_id_fields = ('routing_protocols',)
        autocomplete_lookup_fields = {
            'm2m': ['routing_protocols']
        }


class EthernetInline(BaseStackedInline):
    model = Ethernet


class WirelessInline(BaseStackedInline):
    model = Wireless


class BridgeInline(BaseStackedInline):
    model = Bridge


class TunnelInline(BaseStackedInline):
    model = Tunnel


class VlanInline(BaseStackedInline):
    model = Vlan


class IpInline(BaseStackedInline):
    model = Ip


class VapInline(BaseStackedInline):
    model = Vap


class DeviceAdmin(BaseGeoAdmin):
    list_filter   = ('added', 'updated',)
    list_display  = ('name', 'status', 'node', 'type', 'access_level', 'added', 'updated')
    search_fields = ('name', 'type')
    inlines = [EthernetInline, WirelessInline, BridgeInline, TunnelInline, VlanInline]
    
    raw_id_fields = ('node', 'routing_protocols')
    autocomplete_lookup_fields = {
        'fk': ['node'],
        'm2m': ['routing_protocols']
    }
    
    exclude = ('shortcuts',)
    
    if not settings.DEBUG:
        readonly_fields =  [
            'status', 'first_seen', 'last_seen'
        ] + BaseAdmin.readonly_fields


class InterfaceAdmin(BaseAdmin):
    list_display  = ('mac', 'name', 'type', 'device', 'added', 'updated')
    search_fields = ('mac',)
    exclude = ('shortcuts',)
    inlines = (IpInline,)
    
    raw_id_fields = ('device',)
    autocomplete_lookup_fields = {
        'fk': ['device'],
    }


class WirelessAdmin(InterfaceAdmin):
    inlines = (IpInline, VapInline)   


class RoutingProtocolAdmin(BaseAdmin):
    list_display   = ('name', 'version')


class IpAdmin(BaseAdmin):
    list_display = ('address', 'netmask', 'protocol', 'added', 'updated')
    list_filter = ('protocol', 'added', 'updated')
    search_fields = ('address',)
    
    raw_id_fields = ('interface',)
    autocomplete_lookup_fields = {
        'fk': ['interface'],
    }
    
    readonly_fields = ['protocol'] + BaseAdmin.readonly_fields


from django import forms
from .models.interfaces.bridge import validate_bridged_interfaces

class BridgeForm(forms.ModelForm):
    class Meta:
        model = Bridge
    
    def __init__(self, *args, **kwargs):
        """ only interfaces of the same device can be bridged """
        super(BridgeForm, self).__init__(*args, **kwargs)
        self.fields['interfaces'].queryset = Interface.objects.filter(device_id=self.instance.device_id) \
                                             .exclude(type=INTERFACE_TYPES.get('bridge'))
    
    def clean_interfaces(self):
        """ interface many2many validation """
        interfaces = self.cleaned_data.get('interfaces', [])
        if interfaces:
            # custom signal
            validate_bridged_interfaces(
                sender=self.instance.interfaces,
                instance=self.instance,
                action="pre_add",
                reverse=False,
                model=self.instance.interfaces.model,
                pk_set=interfaces
            )
        return self.cleaned_data['interfaces']


class BridgeAdmin(InterfaceAdmin):
    form = BridgeForm 


admin.site.register(Device, DeviceAdmin)
admin.site.register(Interface, InterfaceAdmin)

admin.site.register(Ethernet, InterfaceAdmin)
admin.site.register(Wireless, WirelessAdmin)
admin.site.register(Bridge, BridgeAdmin)
admin.site.register(Tunnel, InterfaceAdmin)
admin.site.register(Vlan, InterfaceAdmin)

admin.site.register(RoutingProtocol, RoutingProtocolAdmin)
admin.site.register(Ip, IpAdmin)


# ------ Add Device Inlines to NodeAdmin ------ #

from nodeshot.core.nodes.admin import NodeAdmin

NodeAdmin.inlines = [DeviceInline] + NodeAdmin.inlines

########NEW FILE########
__FILENAME__ = fields
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from rest_framework.fields import WritableField
from netaddr import eui, ip


class MacAddressField(WritableField):
        """
        A field to handle mac address and avoid 500 internal server errors
        """
        
        def validate(self, value):
            """ ensure valid mac """
            super(MacAddressField, self).validate(value)
            
            try:
                eui.EUI(value)
            except eui.AddrFormatError:
                raise ValidationError(_('Invalid mac address'))
        
        def from_native(self, value):
            return value
    
        def to_native(self, value):
            return unicode(value)


class IPAddressField(WritableField):
        """
        A field to handle ip address and avoid 500 internal server errors
        """
        
        def validate(self, value):
            """ ensure valid ip address """
            super(IPAddressField, self).validate(value)
            
            try:
                ip.IPAddress(value)
            except (ip.AddrFormatError, ValueError):
                raise ValidationError(_('Invalid ip address'))
        
        def from_native(self, value):
            return value
    
        def to_native(self, value):
            return unicode(value)


class IPNetworkField(WritableField):
        """
        A field to handle ip network and avoid 500 internal server errors
        """
        
        def validate(self, value):
            """ ensure valid ip network """
            super(IPNetworkField, self).validate(value)
            
            try:
                ip.IPNetwork(value)
            except (ip.AddrFormatError, ValueError):
                raise ValidationError(_('Invalid ip network'))
        
        def from_native(self, value):
            return value
    
        def to_native(self, value):
            if value:
                return unicode(value)
            return value
########NEW FILE########
__FILENAME__ = managers
from netfields.managers import NetQuery, NetWhere, NetManager
from nodeshot.core.base.managers import ExtendedManagerMixin, ACLMixin, AccessLevelQuerySet


class NetAccessLevelManager(NetManager, ExtendedManagerMixin, ACLMixin):
    """ NetManager + AccessLevelManager """

    def get_query_set(self):
        q = NetQuery(self.model, NetWhere)
        return AccessLevelQuerySet(self.model, using=self._db, query=q)
########NEW FILE########
__FILENAME__ = choices
from django.utils.translation import ugettext_lazy as _
from nodeshot.core.base.utils import choicify


ROUTING_PROTOCOLS = (
    ('olsr', 'OLSR'),
    ('batman', 'B.A.T.M.A.N.'),
    ('batman-adv', 'B.A.T.M.A.N. advanced'),
    ('bmx', 'BMX (Batman Experimental)'),
    ('babel', 'Babel'),
    ('802.11s', 'Open 802.11s'),
    ('bgp', 'BGP'),
    ('ospf', 'OSPF'),
    ('static', _('Static Routing')),
)

DEVICE_TYPES = {
    'radio device': 'radio',
    'server': 'server',
    'router': 'router',
    'switch managed': 'switch',
    'sensor': 'sensor',
    'other': 'other',
}
DEVICE_TYPES_CHOICES = choicify(DEVICE_TYPES)

DEVICE_STATUS = {
    'not_reachable': 0,     # device is not reachable
    'reachable': 1,         # device is reachable
    'unknown': 2,           # device has not been seen by the system yet
    'inactive': 3,          # manually deactivated by user or admin
}
DEVICE_STATUS_CHOICES = choicify(DEVICE_STATUS)

WIRELESS_MODE = (
    ('sta', _('station')),
    ('ap', _('access point')),
    ('adhoc', _('adhoc')),
    ('monitor', _('monitor')),
    ('mesh', _('mesh')),
)

WIRELESS_CHANNEL = (
    ('2412', '2.4Ghz Ch  1 (2412 Mhz)'),
    ('2417', '2.4Ghz Ch  2 (2417 Mhz)'),
    ('2422', '2.4Ghz Ch  3 (2422 Mhz)'),
    ('2427', '2.4Ghz Ch  4 (2427 Mhz)'),
    ('2427', '2.4Ghz Ch  5 (2432 Mhz)'),
    ('2437', '2.4Ghz Ch  6 (2437 Mhz)'),
    ('2442', '2.4Ghz Ch  7 (2442 Mhz)'),
    ('2447', '2.4Ghz Ch  8 (2447 Mhz)'),
    ('2452', '2.4Ghz Ch  9 (2452 Mhz)'),
    ('2457', '2.4Ghz Ch  10 (2457 Mhz)'),
    ('2462', '2.4Ghz Ch  11 (2462 Mhz)'),
    ('2467', '2.4Ghz Ch  12 (2467 Mhz)'),
    ('2472', '2.4Ghz Ch  13 (2472 Mhz)'),
    ('2484', '2.4Ghz Ch  14 (2484 Mhz)'),
    ('4915', '5Ghz Ch 183 (4915 Mhz)'),
    ('4920', '5Ghz Ch 184 (4920 Mhz)'),
    ('4925', '5Ghz Ch 185 (4925 Mhz)'),
    ('4935', '5Ghz Ch 187 (4935 Mhz)'),
    ('4940', '5Ghz Ch 188 (4940 Mhz)'),
    ('4945', '5Ghz Ch 189 (4945 Mhz)'),
    ('4960', '5Ghz Ch 192 (4960 Mhz)'),
    ('4980', '5Ghz Ch 196 (4980 Mhz)'),
    ('5035', '5Ghz Ch 7 (5035 Mhz)'),
    ('5040', '5Ghz Ch 8 (5040 Mhz)'),
    ('5045', '5Ghz Ch 9 (5045 Mhz)'),
    ('5055', '5Ghz Ch 11 (5055 Mhz)'),
    ('5060', '5Ghz Ch 12 (5060 Mhz)'),
    ('5080', '5Ghz Ch 16 (5080 Mhz)'),
    ('5170', '5Ghz Ch 34 (5170 Mhz)'),
    ('5180', '5Ghz Ch 36 (5180 Mhz)'),
    ('5190', '5Ghz Ch 38 (5190 Mhz)'),
    ('5200', '5Ghz Ch 40 (5200 Mhz)'),
    ('5210', '5Ghz Ch 42 (5210 Mhz)'),
    ('5220', '5Ghz Ch 44 (5220 Mhz)'),
    ('5230', '5Ghz Ch 46 (5230 Mhz)'),
    ('5240', '5Ghz Ch 48 (5240 Mhz)'),
    ('5260', '5Ghz Ch 52 (5260 Mhz)'),
    ('5280', '5Ghz Ch 56 (5280 Mhz)'),
    ('5300', '5Ghz Ch 60 (5300 Mhz)'),
    ('5320', '5Ghz Ch 64 (5320 Mhz)'),
    ('5500', '5Ghz Ch 100 (5500 Mhz)'),
    ('5520', '5Ghz Ch 104 (5520 Mhz)'),
    ('5540', '5Ghz Ch 108 (5540 Mhz)'),
    ('5560', '5Ghz Ch 112 (5560 Mhz)'),
    ('5580', '5Ghz Ch 116 (5580 Mhz)'),
    ('5600', '5Ghz Ch 120 (5600 Mhz)'),
    ('5620', '5Ghz Ch 124 (5620 Mhz)'),
    ('5640', '5Ghz Ch 128 (5640 Mhz)'),
    ('5660', '5Ghz Ch 132 (5660 Mhz)'),
    ('5680', '5Ghz Ch 136 (5680 Mhz)'),
    ('5700', '5Ghz Ch 140 (5700 Mhz)'),
    ('5745', '5Ghz Ch 149 (5745 Mhz)'),
    ('5765', '5Ghz Ch 153 (5765 Mhz)'),
    ('5785', '5Ghz Ch 157 (5785 Mhz)'),
    ('5805', '5Ghz Ch 161 (5805 Mhz)'),
    ('5825', '5Ghz Ch 165 (5825 Mhz)')
)

INTERFACE_TYPES = {
    'loopback': 0,
    'ethernet': 1,
    'wireless': 2,
    'bridge': 3,
    'virtual': 4,
    'tunnel': 5,
    'vlan': 6,
}
INTERFACE_TYPE_CHOICES = choicify(INTERFACE_TYPES)

WIRELESS_STANDARDS = (
    ('802.11a', '802.11a'),
    ('802.11b', '802.11b'),
    ('802.11g', '802.11g'),
    ('802.11n', '802.11n'),
    ('802.11s', '802.11s'),
    ('802.11ad', '802.11ac'),
    ('802.11ac', '802.11ad'),
)

ETHERNET_STANDARDS = (
    ('legacy', 'Legacy Ethernet'),
    ('fast', '10/100 Fast Ethernet'),
    ('gigabit', '10/100/1000 Gigabit Ethernet'),
    ('basefx', '100/1000 BaseFX (Fiber)'),
)

DUPLEX_CHOICES = (
    ('full', 'full-duplex'),
    ('half', 'half-duplex')
)

IP_PROTOCOLS = (
    ('ipv4', 'ipv4'),
    ('ipv6', 'ipv6')
)
########NEW FILE########
__FILENAME__ = device
from django.contrib.gis.db import models
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from nodeshot.core.base.models import BaseAccessLevel

from choices import DEVICE_STATUS, DEVICE_STATUS_CHOICES, DEVICE_TYPES_CHOICES

from django_hstore.fields import DictionaryField, ReferencesField
from nodeshot.core.base.managers import HStoreGeoAccessLevelManager as DeviceManager


class Device(BaseAccessLevel):
    """
    Device Model
    Represents a network device
    eg: an outdoor point-to-point wifi device, a BGP router, a server, and so on
    """
    name = models.CharField(_('name'), max_length=50)
    node = models.ForeignKey('nodes.Node', verbose_name=_('node'))
    type = models.CharField(_('type'), max_length=50, choices=DEVICE_TYPES_CHOICES)
    status = models.SmallIntegerField(_('status'), max_length=2, choices=DEVICE_STATUS_CHOICES, default=DEVICE_STATUS.get('unknown'))
    
    # geographic data
    location = models.PointField(_('location'), blank=True, null=True,
                                 help_text=_("""specify device coordinates (if different from node);
                                    defaults to node coordinates if node is a point,
                                    otherwise if node is a geometry it will default to che centroid of the geometry"""))
    elev = models.FloatField(_('elevation'), blank=True, null=True)
    
    # device specific
    routing_protocols = models.ManyToManyField('net.RoutingProtocol', blank=True)
    
    os = models.CharField(_('operating system'), max_length=128, blank=True, null=True)
    os_version = models.CharField(_('operating system version'), max_length=128, blank=True, null=True)
    
    first_seen = models.DateTimeField(_('first time seen on'), blank=True, null=True, default=None)
    last_seen = models.DateTimeField(_('last time seen on'), blank=True, null=True, default=None)
    
    # text
    description = models.CharField(_('description'), max_length=255, blank=True, null=True)
    notes = models.TextField(_('notes'), blank=True, null=True)
    
    # extra data
    data = DictionaryField(_('extra data'), null=True, blank=True,
                           help_text=_('store extra attributes in JSON string'))
    shortcuts = ReferencesField(null=True, blank=True)
    
    objects = DeviceManager()
    
    # list indicating if any other module has extended this model
    extended_by = []
    
    class Meta:
        app_label = 'net'
        
    def __unicode__(self):
        return '%s' % self.name
    
    def save(self, *args, **kwargs):
        """
        Custom save method does the following:
            * automatically inherit node coordinates and elevation
            * save shortcuts if HSTORE is enabled
        """
        custom_checks = kwargs.pop('custom_checks', True)
        
        super(Device, self).save(*args, **kwargs)
        
        if custom_checks is False:
            return
        
        changed = False
        
        if not self.location:
            self.location = self.node.point
            changed = True
        
        if not self.elev and self.node.elev:
            self.elev = self.node.elev
            changed = True
        
        original_user = self.shortcuts.get('user')
        
        self.shortcuts['user'] = self.node.user
        
        if original_user != self.shortcuts.get('user'):
            changed = True
        
        if 'nodeshot.core.layers' in settings.INSTALLED_APPS:
            original_layer = self.shortcuts.get('layer')
            self.shortcuts['layer'] = self.node.layer
            
            if original_layer != self.shortcuts.get('layer'):
                changed = True
        
        if changed:
            self.save(custom_checks=False)
    
    @property
    def owner(self):
        if 'user' not in self.shortcuts:
            if self.node or self.node_id:
                self.save()
            else:
                raise Exception('Instance does not have a node set yet')
        return self.shortcuts['user']
    
    @property
    def layer(self):
        if 'nodeshot.core.layers' not in settings.INSTALLED_APPS:
            return False
        if 'layer' not in self.shortcuts:
            if self.node or self.node_id:
                self.save()
            else:
                raise Exception('Instance does not have a node set yet')
        return self.shortcuts['layer']
    
    if 'grappelli' in settings.INSTALLED_APPS:
        @staticmethod
        def autocomplete_search_fields():
            return ('name__icontains',)

########NEW FILE########
__FILENAME__ = interface
from netfields import MACAddressField

from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from nodeshot.core.base.models import BaseAccessLevel
from choices import INTERFACE_TYPE_CHOICES

from django_hstore.fields import DictionaryField, ReferencesField
from nodeshot.core.base.managers import HStoreAccessLevelManager as InterfaceManager


class Interface(BaseAccessLevel):
    """ Interface model """
    device = models.ForeignKey('net.Device')
    type = models.IntegerField(_('type'), max_length=2, choices=INTERFACE_TYPE_CHOICES, blank=True)
    name = models.CharField(_('name'), max_length=10, blank=True, null=True)
    mac = MACAddressField(_('mac address'), max_length=17, unique=True, default=None, null=True, blank=True)
    mtu = models.IntegerField(_('MTU'), blank=True, null=True, default=1500,
                              help_text=_('Maximum Trasmission Unit'))
    tx_rate = models.IntegerField(_('TX Rate'), null=True, default=None, blank=True)
    rx_rate = models.IntegerField(_('RX Rate'), null=True, default=None, blank=True)
    
    # extra data
    data = DictionaryField(_('extra data'), null=True, blank=True,
                           help_text=_('store extra attributes in JSON string'))
    shortcuts = ReferencesField(null=True, blank=True)
    
    objects = InterfaceManager()
    
    class Meta:
        app_label = 'net'
    
    def __unicode__(self):
        return '%s %s' % (self.get_type_display(), self.mac)
    
    def save(self, *args, **kwargs):
        """
        Custom save method does the following:
            * save shortcuts if HSTORE is enabled
        """
        if 'node' not in self.shortcuts:
            self.shortcuts['node'] = self.device.node
        
        if 'user' not in self.shortcuts:
            self.shortcuts['user'] = self.device.node.user
        
        if 'layer' not in self.shortcuts and 'nodeshot.core.layers' in settings.INSTALLED_APPS:
            self.shortcuts['layer'] = self.device.node.layer
        
        super(Interface, self).save(*args, **kwargs)
    
    @property
    def owner(self):
        if 'user' not in self.shortcuts:
            if self.device or self.device_id:
                self.save()
            else:
                raise Exception('Instance does not have a device set yet')
        
        return self.shortcuts['user']
    
    @property
    def node(self):
        if 'node' not in self.shortcuts:
            if self.device or self.device_id:
                self.save()
            else:
                raise Exception('Instance does not have a device set yet')
        return self.shortcuts['node']
    
    @property
    def layer(self):
        if 'nodeshot.core.layers' not in settings.INSTALLED_APPS:
            return False
        if 'layer' not in self.shortcuts:
            if self.device or self.device_id:
                self.save()
            else:
                raise Exception('Instance does not have a device set yet')
        return self.shortcuts['layer']
    
    @property
    def ip_addresses(self):
        try:
            addresses = self.data.get('ip_addresses', '')
        # self.data might be none, hence self.data['ip_addresses'] will raise an exception
        except AttributeError:
            addresses = ''
        return addresses.replace(' ', '').split(',') if addresses else []
    
    @ip_addresses.setter
    def ip_addresses(self, value):
        """ :param value: a list of ip addresses """
        if not isinstance(value, list):
            raise ValueError('ip_addresses value must be a list')
        # in soem cases self.data might be none, so let's instantiate an empty dict
        if self.data is None:
            self.data = {}
        # update field
        self.data['ip_addresses'] = ', '.join(value)
    
    if 'grappelli' in settings.INSTALLED_APPS:
        @staticmethod
        def autocomplete_search_fields():
            return ('mac__icontains', 'data__icontains')

########NEW FILE########
__FILENAME__ = bridge
from django.db import models
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _

from nodeshot.networking.net.models import Interface
from nodeshot.networking.net.models.choices import INTERFACE_TYPES


class Bridge(Interface):
    """ Bridge interface """
    interfaces = models.ManyToManyField(Interface, verbose_name=_('interfaces'), related_name='bridge_interfaces')
    
    objects = Interface.objects.__class__()
    
    class Meta:
        app_label = 'net'
        db_table = 'net_interface_bridge'
        verbose_name = _('bridge interface')
        verbose_name_plural = _('bridge interfaces')
    
    def save(self, *args, **kwargs):
        """ automatically set Interface.type to bridge """
        self.type = INTERFACE_TYPES.get('bridge')
        super(Bridge, self).save(*args, **kwargs)


from django.dispatch import receiver
from django.db.models.signals import m2m_changed

@receiver(m2m_changed, sender=Bridge.interfaces.through)
def validate_bridged_interfaces(sender, instance, action, reverse, model, pk_set, **kwargs):
    """
    Bridge interface validation constraints:
        * can't bridge interfaces of different devices
        * can't bridge self
        * there must be at least two interfaces bridged
    """
    if action != 'pre_add':
        return
    
    interfaces = Interface.objects.filter(pk__in=pk_set)
    device = instance.device
    device_id = instance.device.id
    invalid_interfaces = []
    trying_to_bridge_self = False
    
    for interface in interfaces:
        # interfaces must belong to the same device
        if interface.device_id != device_id:
            invalid_interfaces.append(interface.mac)
        # you can't bridge same interface
        elif interface.id == instance.id:
            trying_to_bridge_self = True
    
    # ensure at least two interfaces are present
    if instance.interfaces.count() < 2 and len(pk_set) < 2:
        raise ValidationError(_(u'You must bridge at least 2 interfaces'))
    
    if invalid_interfaces:
        raise ValidationError(_(u'The interface%s %s %s not belong to device "%s"' % (
            "s" if len(invalid_interfaces) > 1 else "",
            ", ".join(invalid_interfaces),
            "do" if len(invalid_interfaces) > 1 else "does",
            device.name
        )))
    elif trying_to_bridge_self:
        raise ValidationError(_(u'Cannot bridge interface %s because that is the actual interface you are editing''' % instance.mac))
########NEW FILE########
__FILENAME__ = ethernet
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.networking.net.models import Interface
from nodeshot.networking.net.models.choices import ETHERNET_STANDARDS, DUPLEX_CHOICES, INTERFACE_TYPES


class Ethernet(Interface):
    """ Ethernet Interface """
    standard = models.CharField(_('standard'), max_length=15, choices=ETHERNET_STANDARDS)
    duplex = models.CharField(_('duplex?'), max_length=15, choices=DUPLEX_CHOICES)
    
    objects = Interface.objects.__class__()
    
    class Meta:
        app_label = 'net'
        db_table = 'net_interface_ethernet'
        verbose_name = _('ethernet interface')
        verbose_name_plural = _('ethernet interfaces')
    
    def save(self, *args, **kwargs):
        """ automatically set Interface.type to ethernet """
        self.type = INTERFACE_TYPES.get('ethernet')
        super(Ethernet, self).save(*args, **kwargs)
########NEW FILE########
__FILENAME__ = tunnel
from django.db import models
from django.utils.translation import ugettext_lazy as _

from netfields import InetAddressField

from nodeshot.networking.net.models import Interface
from nodeshot.networking.net.models.choices import INTERFACE_TYPES

from ...managers import NetAccessLevelManager


class Tunnel(Interface):
    """ Tunnel Interface """
    sap = models.CharField(max_length=10, null=True, blank=True)
    protocol = models.CharField(max_length=10, help_text=_('eg: GRE'), blank=True, null=True)
    endpoint = InetAddressField(verbose_name=_('end point'), blank=True, null=True)
    
    objects = NetAccessLevelManager()
    
    class Meta:
        app_label = 'net'
        db_table = 'net_interface_tunnel'
        verbose_name = _('tunnel interface')
        verbose_name_plural = _('tunnel interfaces')
    
    def save(self, *args, **kwargs):
        """ automatically set Interface.type to tunnel """
        self.type = INTERFACE_TYPES.get('tunnel')
        super(Tunnel, self).save(*args, **kwargs)
########NEW FILE########
__FILENAME__ = vap
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from nodeshot.networking.net.models import Interface


class Vap(BaseDate):
    """
    VAP interface
    represents a virtual wireless interface
    """
    interface = models.ForeignKey('net.Wireless',
                                  verbose_name='wireless interface')
    essid = models.CharField(max_length=50, null=True, blank=True)
    bssid = models.CharField(max_length=50, null=True, blank=True)
    encryption = models.CharField(max_length=50, null=True, blank=True)
    key = models.CharField(max_length=100, null=True, blank=True)
    auth_server = models.CharField(max_length=50, null=True, blank=True)
    auth_port = models.IntegerField(null=True, blank=True)
    accounting_server = models.CharField(max_length=50, null=True, blank=True)
    accounting_port = models.IntegerField(null=True, blank=True)
    
    def __unicode__(self):
        return self.essid
    
    class Meta:
        app_label = 'net'
        db_table = 'net_interface_vap'
        verbose_name = _('vap interface')
        verbose_name_plural = _('vap interfaces')
########NEW FILE########
__FILENAME__ = vlan
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.networking.net.models import Interface
from nodeshot.networking.net.models.choices import INTERFACE_TYPES


class Vlan(Interface):
    """ VLAN """
    tag = models.CharField(max_length=10)
    
    objects = Interface.objects.__class__()
    
    class Meta:
        app_label = 'net'
        db_table = 'net_interface_vlan'
        verbose_name = _('vlan interface')
        verbose_name_plural = _('vlan interfaces')
    
    def save(self, *args, **kwargs):
        """ automatically set Interface.type to virtual """
        self.type = INTERFACE_TYPES.get('vlan')
        super(Vlan, self).save(*args, **kwargs)
########NEW FILE########
__FILENAME__ = wireless
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.networking.net.models import Interface
from nodeshot.networking.net.models.choices import WIRELESS_MODE, WIRELESS_STANDARDS, WIRELESS_CHANNEL, INTERFACE_TYPES


class Wireless(Interface):
    """ Wireless Interface """
    mode = models.CharField(_('wireless mode'), max_length=5,
                            choices=WIRELESS_MODE,
                            blank=True, null=True, default=None)
    standard = models.CharField(_('wireless standard'), max_length=7,
                                choices=WIRELESS_STANDARDS,
                                blank=True, null=True, default=None)
    channel = models.CharField(_('channel'), max_length=4,
                               choices=WIRELESS_CHANNEL,
                               blank=True, null=True, default=None)
    channel_width = models.CharField(_('channel width'), max_length=6,
                                     blank=True, null=True)
    output_power = models.IntegerField(_('output power'), null=True, blank=True)
    dbm = models.IntegerField(_('dBm'), null=True, default=None, blank=True)
    noise = models.IntegerField(_('noise'), null=True, default=None, blank=True)
    
    objects = Interface.objects.__class__()
    
    class Meta:
        app_label = 'net'
        db_table = 'net_interface_wireless'
        verbose_name = _('wireless interface')
        verbose_name_plural = _('wireless interfaces')
    
    def save(self, *args, **kwargs):
        """ automatically set Interface.type to wireless """
        self.type = INTERFACE_TYPES.get('wireless')
        super(Wireless, self).save(*args, **kwargs)
########NEW FILE########
__FILENAME__ = ip
from netfields import InetAddressField, CidrAddressField

from django.db import models
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from django.conf import settings

from nodeshot.core.base.models import BaseAccessLevel
from ..managers import NetAccessLevelManager
from choices import IP_PROTOCOLS



class Ip(BaseAccessLevel):
    """ IP Address Model """
    interface = models.ForeignKey('net.Interface', verbose_name=_('interface'))
    address = InetAddressField(verbose_name=_('ip address'), unique=True, db_index=True)
    protocol = models.CharField(_('IP Protocol Version'), max_length=4, choices=IP_PROTOCOLS, default=IP_PROTOCOLS[0][0], blank=True)
    netmask = CidrAddressField(_('netmask (CIDR, eg: 10.40.0.0/24)'), blank=True, null=True)
    
    objects = NetAccessLevelManager()
    
    class Meta:
        app_label = 'net'
        permissions = (('can_view_ip', 'Can view ip'),)
        verbose_name = _('ip address')
        verbose_name_plural = _('ip addresses')
    
    def __unicode__(self):
        return '%s: %s' % (self.protocol, self.address)
    
    def clean(self, *args, **kwargs):
        """ TODO """
        # netaddr.IPAddress('10.40.2.1') in netaddr.IPNetwork('10.40.0.0/24')
        pass
    
    def save(self, *args, **kwargs):
        """
        Determines ip protocol version automatically.
        Stores address in interface shortcuts for convenience.
        """
        self.protocol = 'ipv%d' % self.address.version
        # save
        super(Ip, self).save(*args, **kwargs)
        
        # save shortcut on interfaces
        ip_cached_list = self.interface.ip_addresses
        # if not present in interface shorctus add it to the list
        if str(self.address) not in ip_cached_list:
            # recalculate cached_ip_list
            recalculated_ip_cached_list = []
            for ip in self.interface.ip_set.all():
                recalculated_ip_cached_list.append(str(ip.address))
            # rebuild string in format "<ip_1>, <ip_2>"
            self.interface.ip_addresses = recalculated_ip_cached_list
            self.interface.save()
    
    @property
    def owner(self):
        return self.interface.owner
    
    if 'grappelli' in settings.INSTALLED_APPS:
        @staticmethod
        def autocomplete_search_fields():
            return ('address__icontains',)

########NEW FILE########
__FILENAME__ = routing_protocol
from django.db import models
from django.utils.translation import ugettext_lazy as _
from nodeshot.core.base.models import BaseDate
from choices import ROUTING_PROTOCOLS


class RoutingProtocol(BaseDate):
    """ Routing Protocol Model """
    name = models.CharField(_('name'), max_length=50, choices=ROUTING_PROTOCOLS)
    version = models.CharField(_('version'), max_length=128, blank=True)
    
    class Meta:
        app_label = 'net'
        db_table = 'net_routing_protocol'
        unique_together = ('name', 'version')
    
    def __unicode__(self):
        return '%s %s' % (self.name, self.version)
########NEW FILE########
__FILENAME__ = permissions
from rest_framework import permissions


class IsOwnerOrReadOnly(permissions.BasePermission):
    """
    Object-level permission to only allow owners of an object to edit it.
    Assumes the model instance has an `owner` attribute.
    """

    def has_object_permission(self, request, view, obj):
        # Read permissions are allowed to any request,
        # so we'll always allow GET, HEAD or OPTIONS requests.
        if request.method in permissions.SAFE_METHODS:
            return True
        
        action = ''
        
        if request.method in ['PUT', 'PATCH']:
            action = 'change'
        elif request.method in ['DELETE']:
            action = 'delete'
        elif request.method == 'POST':
            action = 'add'
        
        class_name = obj.__class__.__name__
        
        # Instance must have an attribute named `owner`.
        return obj.owner == request.user or request.user.has_perm('net.%s_%s' % (action, class_name.lower()))
########NEW FILE########
__FILENAME__ = serializers
from django.utils.translation import ugettext_lazy as _
from django.core.exceptions import ValidationError

from rest_framework import pagination, serializers
from rest_framework.reverse import reverse
from rest_framework_gis import serializers as gis_serializers

from .models import *
from .models.choices import INTERFACE_TYPES
from .fields import MacAddressField, IPAddressField, IPNetworkField

from nodeshot.core.base.fields import HStoreDictionaryField


__all__ = [
    'DeviceListSerializer',
    'DeviceDetailSerializer',
    'DeviceAddSerializer',
    'NodeDeviceListSerializer',
    'PaginatedDeviceSerializer',
    'PaginatedNodeDeviceSerializer',
    
    'EthernetSerializer',
    'EthernetDetailSerializer',
    'EthernetAddSerializer',
    
    'WirelessSerializer',
    'WirelessDetailSerializer',
    'WirelessAddSerializer',
    
    'BridgeSerializer',
    'BridgeDetailSerializer',
    'BridgeAddSerializer',
    
    'TunnelSerializer',
    'TunnelDetailSerializer',
    'TunnelAddSerializer',
    
    'VlanSerializer',
    'VlanDetailSerializer',
    'VlanAddSerializer',
    
    'VapSerializer',
    
    'IpSerializer',
    'IpDetailSerializer',
    'IpAddSerializer'
]


# ------ DEVICES ------ #

  
class DeviceListSerializer(gis_serializers.GeoModelSerializer):
    """ location geo serializer  """
    
    node = serializers.Field(source='node.slug')
    type = serializers.WritableField(source='get_type_display', label=_('type'))
    status = serializers.Field(source='get_status_display')
    details = serializers.HyperlinkedIdentityField(view_name='api_device_details')
    
    class Meta:
        model = Device
        fields = [
            'id', 'node', 'name', 'type', 'status',
            'location', 'elev',
            'os', 'os_version', 'description',
            'first_seen', 'last_seen',
            'added', 'updated', 'details'
        ]
        read_only_fields = [
            'first_seen', 'last_seen',
            'added', 'updated'
        ]


class DeviceDetailSerializer(DeviceListSerializer):
    
    access_level = serializers.Field(source='get_access_level_display')
    
    routing_protocols_named = serializers.RelatedField(source='routing_protocols', many=True)
    
    ethernet = serializers.SerializerMethodField('get_ethernet_interfaces')
    ethernet_url = serializers.HyperlinkedIdentityField(view_name='api_device_ethernet')
    
    wireless = serializers.SerializerMethodField('get_wireless_interfaces')
    wireless_url = serializers.HyperlinkedIdentityField(view_name='api_device_wireless')
    
    bridge = serializers.SerializerMethodField('get_bridge_interfaces')
    bridge_url = serializers.HyperlinkedIdentityField(view_name='api_device_bridge')
    
    tunnel = serializers.SerializerMethodField('get_tunnel_interfaces')
    tunnel_url = serializers.HyperlinkedIdentityField(view_name='api_device_tunnel')
    
    vlan = serializers.SerializerMethodField('get_vlan_interfaces')
    vlan_url = serializers.HyperlinkedIdentityField(view_name='api_device_vlan')
    
    data = HStoreDictionaryField(
        required=False,
        label=_('extra data'),
        help_text=_('store extra attributes in JSON string')
    )
    
    def get_ethernet_interfaces(self, obj):
        user = self.context['request'].user
        interfaces = Ethernet.objects.filter(device=obj.id).accessible_to(user)
        return EthernetSerializer(interfaces, many=True, context=self.context).data
    
    def get_wireless_interfaces(self, obj):
        user = self.context['request'].user
        interfaces = Wireless.objects.filter(device=obj.id).accessible_to(user)
        return WirelessSerializer(interfaces, many=True, context=self.context).data
    
    def get_bridge_interfaces(self, obj):
        user = self.context['request'].user
        interfaces = Bridge.objects.filter(device=obj.id).accessible_to(user)
        return BridgeSerializer(interfaces, many=True, context=self.context).data
    
    def get_tunnel_interfaces(self, obj):
        user = self.context['request'].user
        interfaces = Tunnel.objects.filter(device=obj.id).accessible_to(user)
        return TunnelSerializer(interfaces, many=True, context=self.context).data
    
    def get_vlan_interfaces(self, obj):
        user = self.context['request'].user
        interfaces = Vlan.objects.filter(device=obj.id).accessible_to(user)
        return VlanSerializer(interfaces, many=True, context=self.context).data
    
    class Meta:
        model = Device
        primary_fields = [
            'id', 'access_level', 'node', 'name', 'type', 'status',
            'location', 'elev',
            'os', 'os_version', 'description',
            'routing_protocols', 'routing_protocols_named',
            'first_seen', 'last_seen', 'data',
            'added', 'updated'
        ]
        
        secondary_fields = [
            'ethernet', 'ethernet_url',
            'wireless', 'wireless_url',
            'bridge', 'bridge_url',
            'tunnel', 'tunnel_url',
            'vlan', 'vlan_url'
        ]
        
        fields = primary_fields + secondary_fields
        read_only_fields = [
            'added', 'updated',
            'first_seen', 'last_seen',
        ]


class NodeDeviceListSerializer(DeviceDetailSerializer):
    """ serializer to list devices of a node """
    class Meta:
        model = Device
        fields = DeviceDetailSerializer.Meta.primary_fields[:] + ['details']


class DeviceAddSerializer(NodeDeviceListSerializer):
    """ Serializer for Device Creation """
    node = serializers.WritableField(source='node_id')
    type = serializers.WritableField(source='type')
    details = serializers.HyperlinkedIdentityField(view_name='api_device_details') 


class PaginatedDeviceSerializer(pagination.PaginationSerializer):
    class Meta:
        object_serializer_class = DeviceListSerializer


class PaginatedNodeDeviceSerializer(pagination.PaginationSerializer):
    class Meta:
        object_serializer_class = NodeDeviceListSerializer


# ------ INTERFACES ------ #


class InterfaceSerializer(serializers.ModelSerializer):
    """ Base Interface Serializer Class """
    access_level = serializers.Field(source='get_access_level_display')
    mac = MacAddressField(label=_('mac address'))
    type = serializers.Field(source='get_type_display', label=_('type'))
    
    tx_rate = serializers.Field()
    rx_rate = serializers.Field()
    
    ip = serializers.SerializerMethodField('get_ip_addresses')
    ip_url = serializers.HyperlinkedIdentityField(view_name='api_interface_ip')
    
    data = HStoreDictionaryField(
        required=False,
        label=_('extra data'),
        help_text=_('store extra attributes in JSON string')
    )
    
    def get_ip_addresses(self, obj):
        user = self.context['request'].user
        interfaces = Ip.objects.filter(interface=obj.id).accessible_to(user)
        return IpSerializer(interfaces, many=True, context=self.context).data
    
    class Meta:
        model = Interface
        fields = [
            'id', 'access_level', 'type', 'name',
            'mac', 'mtu', 'tx_rate', 'rx_rate',
            'data', 'added', 'updated', 'ip_url', 'ip',
        ]
        read_only_fields = ['added', 'updated']


class EthernetSerializer(InterfaceSerializer):
    class Meta:
        model = Ethernet
        fields = InterfaceSerializer.Meta.fields[:] + [
            'standard', 'duplex'
        ]


class EthernetDetailSerializer(EthernetSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='api_ethernet_details')
    
    class Meta:
        model = Ethernet
        fields = EthernetSerializer.Meta.fields[:] + ['details']
        read_only_fields = ('added', 'updated')


class EthernetAddSerializer(EthernetSerializer):
    class Meta:
        model = Ethernet
        fields = EthernetSerializer.Meta.fields[:] + ['device']
        read_only_fields = ('added', 'updated')


class VapSerializer(serializers.ModelSerializer):
    class Meta:
        model = Vap
        fields = ['essid', 'bssid', 'encryption']


class WirelessSerializer(InterfaceSerializer):
    vap = VapSerializer(source='vap_set', many=True, read_only=True)
    
    class Meta:
        model = Wireless
        fields = InterfaceSerializer.Meta.fields[:] + [
            'mode', 'standard', 'channel',
            'channel_width', 'output_power', 'dbm', 'noise', 'vap'
        ]


class WirelessDetailSerializer(WirelessSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='api_wireless_details')
    
    class Meta:
        model = Wireless
        fields = WirelessSerializer.Meta.fields[:] + ['details']
        read_only_fields = ('added', 'updated')


class WirelessAddSerializer(WirelessSerializer):
    class Meta:
        model = Wireless
        fields = WirelessSerializer.Meta.fields[:] + ['device']
        read_only_fields = ('added', 'updated')


from .models.interfaces.bridge import validate_bridged_interfaces

class BridgeSerializer(InterfaceSerializer):
    
    interfaces = serializers.PrimaryKeyRelatedField(many=True, required=True)
    interfaces_links = serializers.SerializerMethodField('get_interfaces_links')
    
    def get_interfaces_links(self, obj):
        user = self.context['request'].user
        links = []
        
        for interface in obj.interfaces.accessible_to(user):
            view_names = {
                INTERFACE_TYPES['ethernet']: 'api_ethernet_details',
                INTERFACE_TYPES['wireless']: 'api_wireless_details',
                INTERFACE_TYPES['bridge']: 'api_bridge_details',
                INTERFACE_TYPES['virtual']: 'api_tunnel_details',
                INTERFACE_TYPES['vlan']: 'api_vlan_details'
            }
            link = reverse(view_names[interface.type],
                           args=[interface.id],
                           request=self.context['request'],
                           format=self.context['format'])
            links.append(link)
        
        return links
    
    def validate(self, attrs):
        """ perform many2many validation """
        interfaces = attrs.get('interfaces', [])
        created = False
        
        # redundant but necessary
        if(len(interfaces) < 2 and not self.partial) or \
          (self.partial and 'interfaces' in attrs and len(interfaces) < 2):  # this line adds support for partial udpates with PATCH method
            raise ValidationError(_(u'You must bridge at least 2 interfaces'))
        
        # when creating a new interface self.object is None
        if not self.object:
            created = True
            self.object = Bridge(
                device_id=attrs['device'].id,
                name=attrs['name'],
                mac=attrs['mac']
            )
            self.object.full_clean()
            self.object.save()
        
        # validate many2many
        try:
            validate_bridged_interfaces(
                sender=self.object.interfaces,
                instance=self.object,
                action="pre_add",
                reverse=False,
                model=self.object.interfaces.model,
                pk_set=[interface.id for interface in interfaces]
            )
        except ValidationError as e:
            # delete object first if validation error raised and then raise again
            if created:
                self.object.delete()
            raise ValidationError(e.messages[0])
        
        # delete any created object that was needed for validation only
        if created:
            self.object.delete()
        
        return attrs
    
    class Meta:
        model = Bridge
        fields = InterfaceSerializer.Meta.fields[:] + ['interfaces', 'interfaces_links']
        read_only_fields = ('added', 'updated')


class BridgeDetailSerializer(BridgeSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='api_bridge_details')
    
    class Meta:
        model = Bridge
        fields = BridgeSerializer.Meta.fields[:] + ['details']
        read_only_fields = ('added', 'updated')


class BridgeAddSerializer(BridgeSerializer):
    class Meta:
        model = Bridge
        fields = BridgeSerializer.Meta.fields[:] + ['device', 'interfaces']
        read_only_fields = ('added', 'updated')


class TunnelSerializer(InterfaceSerializer):
    class Meta:
        model = Tunnel
        fields = InterfaceSerializer.Meta.fields[:] + [
            'sap', 'protocol', 'endpoint',
        ]


class TunnelDetailSerializer(TunnelSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='api_tunnel_details')
    
    class Meta:
        model = Tunnel
        fields = TunnelSerializer.Meta.fields[:] + ['details']
        read_only_fields = ('added', 'updated')


class TunnelAddSerializer(TunnelSerializer):
    class Meta:
        model = Tunnel
        fields = TunnelSerializer.Meta.fields[:] + ['device']
        read_only_fields = ('added', 'updated')


class VlanSerializer(InterfaceSerializer):
    class Meta:
        model = Vlan
        fields = InterfaceSerializer.Meta.fields[:] + ['tag']


class VlanDetailSerializer(VlanSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='api_vlan_details')
    
    class Meta:
        model = Vlan
        fields = VlanSerializer.Meta.fields[:] + ['details']
        read_only_fields = ('added', 'updated')


class VlanAddSerializer(VlanSerializer):
    class Meta:
        model = Vlan
        fields = VlanSerializer.Meta.fields[:] + ['device']
        read_only_fields = ('added', 'updated')


# ------ IP ADDRESS ------ #


class IpSerializer(serializers.ModelSerializer):
    address = IPAddressField()
    netmask = IPNetworkField()
    
    class Meta:
        model = Ip
        fields = ['address', 'protocol', 'netmask']


class IpAddSerializer(IpSerializer):
    class Meta:
        model = Ip
        fields = IpSerializer.Meta.fields[:] + ['interface']
        read_only_fields = ('added', 'updated')


class IpDetailSerializer(IpSerializer):
    details = serializers.HyperlinkedIdentityField(view_name='api_ip_details')
    
    class Meta:
        model = Ip
        fields = ['id'] + IpSerializer.Meta.fields[:] + ['added', 'updated', 'details']
        read_only_fields = ('added', 'updated')

########NEW FILE########
__FILENAME__ = tests
import simplejson as json

from django.contrib.gis.geos import GEOSGeometry, Point
from django.core.urlresolvers import reverse
from django.core.exceptions import ValidationError
from django.conf import settings
from django.contrib.auth import get_user_model
User = get_user_model()

from nodeshot.core.base.tests import BaseTestCase
from nodeshot.core.base.tests import user_fixtures
from nodeshot.core.nodes.models import Node

from .models import *


class NetTest(BaseTestCase):
    """
    Network Model Tests
    """
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_routing_protocols.json',
        'test_devices.json',
        'test_interfaces.json',
        'test_ip_addresses.json'
    ]
    
    def test_ip_automatic_protocol_detection(self):
        """ automatic protocol detection """
        ip = Ip.objects.get(pk=1)
        ip.save()
        self.assertEquals('ipv4', ip.protocol)
        
        ip = Ip.objects.get(pk=2)
        ip.save()
        self.assertEquals('ipv6', ip.protocol)
    
    def test_interface_data_ip_addresses(self):
        ip = Ip.objects.get(pk=1)
        ip.save()
        
        ip_addresses = ip.interface.data['ip_addresses'].replace(' ', '').split(',')
        self.assertEqual(len(ip_addresses), ip.interface.ip_set.count())
        
        for ip in ip.interface.ip_set.all():
            self.assertIn(str(ip.address), ip_addresses)
    
    def test_device_manager(self):
        self.assertEqual(
            list(Device.objects.access_level_up_to('public').filter(location__distance_gte=(Point(41, 12), 8000))),
            list(Device.objects.filter(access_level__lte=0, location__distance_gte=(Point(41, 12), 8000)))
        )
    
    def test_netacl_manager(self):
        self.assertEqual(
            list(Ip.objects.access_level_up_to('public').filter(address__net_contained='172.16.40.0/24')),
            list(Ip.objects.filter(access_level__lte=0, address__net_contained='172.16.40.0/24'))
        )
    
    def test_device_inherits_node_location(self):
        """ ensure device location defaults to node location if empty """
        d = Device.objects.create(name='test_device_location', node_id=1, type='radio')
        self.assertEqual(d.location, d.node.geometry)
    
    def test_device_inherits_node_point(self):
        """ ensure device location defaults to node location if empty """
        node = Node.objects.get(pk=1)
        node.geometry = GEOSGeometry("POLYGON((12.501664825436 41.900427664574,12.524409957883 41.897552804356,12.53925866699 41.886499358789,12.495828338623 41.871289758828,12.478318878173 41.891611016451,12.502179809565 41.900810969491,12.501664825436 41.900427664574))")
        node.save()
        d = Device.objects.create(name='test_device_location', node_id=1, type='radio')
        self.assertEqual(d.location, d.node.point)
    
    def test_device_inherits_node_elevation(self):
        """ ensure device elevation is inherithed from node """
        d = Device.objects.create(name='test_device_location', node_id=1, type='radio')
        self.assertEqual(d.elev, d.node.elev)
    
    def test_shortcuts(self):
        d = Device.objects.create(name='test_device_location', node_id=1, type='radio')
        self.assertEqual(d.shortcuts['user'], d.node.user)
        self.assertEqual(d.owner, d.node.user)
        self.assertEqual(d.shortcuts['layer'], d.node.layer)
        self.assertEqual(d.layer, d.node.layer)
    
    def test_device_list_api(self):
        """ API device list """
        url = reverse('api_device_list')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), Device.objects.access_level_up_to('public').count())
    
    def test_device_list_search_api(self):
        """ API device list search """
        url = reverse('api_device_list')
        response = self.client.get(url, { 'search': 'RDP' })
        self.assertEqual(len(response.data['results']), 1)
    
    def test_device_list_api_ACL(self):
        """ API device list ACL """
        device = Device.objects.get(pk=1)
        device.access_level = 2
        device.save()
        
        url = reverse('api_device_list')
        response = self.client.get(url)
        self.assertEqual(len(response.data['results']), Device.objects.access_level_up_to('public').count())
        
        self.client.login(username='admin', password='tester')
        response = self.client.get(url)
        user_1 = User.objects.get(pk=1)
        self.assertEqual(len(response.data['results']), Device.objects.accessible_to(user_1).count())
    
    def test_device_details_api(self):
        url = reverse('api_device_details', args=[1])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
    
    def test_device_details_api_permissions(self):
        """ device detail permissions: only owner or admins can alter data """
        # non owner can only read
        url = reverse('api_device_details', args=[1])
        response = self.client.patch(url, { 'description': 'permission test' })
        self.assertEqual(response.status_code, 403)
        response = self.client.delete(url)
        self.assertEqual(response.status_code, 403)
        
        # login as non-owner
        self.client.login(username='pisano', password='tester')
        response = self.client.patch(url, { 'description': 'permission test' })
        self.assertEqual(response.status_code, 403)
        response = self.client.delete(url)
        self.assertEqual(response.status_code, 403)
        
        # login as owner
        device = Device.objects.get(pk=1)
        self.client.login(username=device.owner.username, password='tester')
        
        # owner can edit
        response = self.client.patch(url, { 'description': 'permission test' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['description'], 'permission test')
        # check DB
        device = Device.objects.get(pk=1)
        self.assertEqual(device.description, 'permission test')
        
        # admin can edit too
        self.client.logout()
        self.client.login(username='admin', password='tester')
        response = self.client.patch(url, { 'description': 'i am the admin' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['description'], 'i am the admin')
        # check DB
        device = Device.objects.get(pk=1)
        self.assertEqual(device.description, 'i am the admin')
    
    def test_node_device_list_api(self):
        """ API node device list """
        
        url = reverse('api_node_devices', args=[Node.objects.get(pk=7).slug])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data['results']), 2)
        
        url = reverse('api_node_devices', args=['idontexist'])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
    
    def test_node_device_list_api_ACL(self):
        """ API device list ACL """
        device = Device.objects.get(pk=1)
        device.access_level = 2
        device.save()
        
        node = Node.objects.get(pk=7)
        url = reverse('api_node_devices', args=[node.slug])
        response = self.client.get(url)
        self.assertEqual(len(response.data['results']), Device.objects.filter(node_id=node.id).access_level_up_to('public').count())
        
        self.client.login(username='admin', password='tester')
        response = self.client.get(url)
        user_1 = User.objects.get(pk=1)
        self.assertEqual(len(response.data['results']), Device.objects.filter(node_id=node.id).accessible_to(user_1).count())
    
    def test_device_creation_api_permissions(self):
        """ create device permissions: only node owner or admins can add devices """
        # non owner can only read
        node = Node.objects.get(pk=7)
        url = reverse('api_node_devices', args=[node.slug])
        
        device_data = {
            "name": "device creation test",
            "type": "radio",
            "description": "device creation test",
            "data": { "is_unittest": "true" }
        }
        
        # unauthenticated can't create
        response = self.client.post(url, device_data)
        self.assertEqual(response.status_code, 403)
        
        # login as non-owner
        self.client.login(username='pisano', password='tester')
        response = self.client.post(url, json.dumps(device_data), content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.client.logout()
        
        # login as node owner
        self.client.login(username=node.owner.username, password='tester')
        
        # node owner can create device
        response = self.client.post(url, json.dumps(device_data), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(response.data['description'], 'device creation test')
        self.assertEqual(response.data['data']['is_unittest'], 'true')
        # check DB
        device = Device.objects.order_by('-id').all()[0]
        self.assertEqual(device.description, 'device creation test')
        self.assertEqual(device.data['is_unittest'], 'true')
        device.delete()
        
        # admin can create device too
        self.client.logout()
        self.client.login(username='admin', password='tester')
        device_data["data"] = json.dumps(device_data["data"])
        response = self.client.post(url, device_data)
        self.assertEqual(response.status_code, 201)
        self.assertEqual(response.data['description'], 'device creation test')
        self.assertEqual(response.data['data']['is_unittest'], 'true')
        # check DB
        device = Device.objects.order_by('-id').all()[0]
        self.assertEqual(device.description, 'device creation test')
        self.assertEqual(device.data['is_unittest'], 'true')
    
    def test_interface_shortcuts(self):
        ethernet = Ethernet.objects.create(
            device_id=1,
            name='eth0',
            mac='00:27:22:38:13:f4',
            standard='fast',
            duplex='full'
        )
        self.assertEqual(ethernet.shortcuts['user'], ethernet.device.node.user)
        self.assertEqual(ethernet.owner, ethernet.device.node.user)
        self.assertEqual(ethernet.shortcuts['layer'], ethernet.device.node.layer)
        self.assertEqual(ethernet.layer, ethernet.device.node.layer)
        self.assertEqual(ethernet.shortcuts['node'], ethernet.device.node)
        self.assertEqual(ethernet.node, ethernet.device.node)
    
    def test_device_ethernet_api(self):
        """ API device ethernet interfaces """
        
        url = reverse('api_device_ethernet', args=[1])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 1)
        
        url = reverse('api_device_ethernet', args=[99])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
    
    def test_mac_address_rest_field(self):
        data = {
            "name": "eth0",
            "mac": "IAM WRONG",
            "tx_rate": 10000, 
            "rx_rate": 10000, 
            "data": {
                "status": "active"
            },
            "standard": "fast", 
            "duplex": "full"
        }
        self.client.login(username='romano', password='tester')
        url = reverse('api_device_ethernet', args=[2])
        
        response = self.client.post(url, json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.data['mac'][0], 'Invalid mac address')
        
        data['mac'] = '00:27:22:38:13:f4'
        response = self.client.post(url, json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 201)
    
    def test_device_ethernet_api_permissions(self):
        """ API device ethernet interfaces permissions to create """
        data = {
            "name": "eth0",
            "mac": "00:27:22:38:13:f4",
            "tx_rate": 10000, 
            "rx_rate": 10000, 
            "standard": "fast", 
            "duplex": "full",
            "data": { "status": "active" }
        }
        json_data = json.dumps(data)
        eth_count = Ethernet.objects.filter(device_id=2).count()
        url = reverse('api_device_ethernet', args=[2])
        
        # unlogged can't create
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.assertEqual(Ethernet.objects.filter(device_id=2).count(), eth_count)
        
        # non-owner can't create
        self.client.login(username='registered', password='tester')
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.assertEqual(Ethernet.objects.filter(device_id=2).count(), eth_count)
        self.client.logout()
        
        # owner can create
        self.client.login(username='romano', password='tester')
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Ethernet.objects.filter(device_id=2).count(), eth_count+1)
        self.client.logout()
        Ethernet.objects.get(mac='00:27:22:38:13:f4').delete()
        
        # admin can create too
        self.client.login(username='admin', password='tester')
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Ethernet.objects.filter(device_id=2).count(), eth_count+1)
    
    def test_device_ethernet_api_ACL(self):
        """ API device ethernet ACL """
        ethernet = Ethernet.objects.create(
            device_id=1,
            access_level=1,
            name='private',
            mac='00:27:22:38:13:a4',
            standard='fast',
            duplex='full'
        )
        
        url = reverse('api_device_ethernet', args=[1])
        device_url = reverse('api_device_details', args=[1])
        
        # unauthenticated can see only 1 record
        response = self.client.get(url)
        self.assertEqual(len(response.data), 1)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['ethernet']), 1)
        
        # registered can see two
        self.client.login(username='registered', password='tester')
        response = self.client.get(url)
        self.assertEqual(len(response.data), 2)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['ethernet']), 2)
        
        # set to higher access level
        ethernet.access_level = 2
        ethernet.save()
        
        # now registed can see only 1
        response = self.client.get(url)
        self.assertEqual(len(response.data), 1)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['ethernet']), 1)
        
        # community can see two
        self.client.logout()
        self.client.login(username='community', password='tester')
        response = self.client.get(url)
        self.assertEqual(len(response.data), 2)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['ethernet']), 2)
    
    def test_ethernet_details_api_permissions(self):
        """ ethernet details permissions: only owner or admins can alter data """
        # non owner can only read
        url = reverse('api_ethernet_details', args=[1])
        response = self.client.patch(url, { 'name': 'eth2' })
        self.assertEqual(response.status_code, 403)
        response = self.client.delete(url)
        self.assertEqual(response.status_code, 403)
        
        # login as non-owner
        self.client.login(username='pisano', password='tester')
        response = self.client.patch(url, { 'name': 'eth2' })
        self.assertEqual(response.status_code, 403)
        response = self.client.delete(url)
        self.assertEqual(response.status_code, 403)
        
        # login as owner
        ethernet = Ethernet.objects.get(pk=1)
        self.client.login(username=ethernet.owner.username, password='tester')
        
        # owner can edit
        response = self.client.patch(url, { 'name': 'eth2' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['name'], 'eth2')
        # check DB
        ethernet = Ethernet.objects.get(pk=1)
        self.assertEqual(ethernet.name, 'eth2')
        
        # admin can edit too
        self.client.logout()
        self.client.login(username='admin', password='tester')
        response = self.client.patch(url, { 'name': 'admineth2' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['name'], 'admineth2')
        # check DB
        ethernet = Ethernet.objects.get(pk=1)
        self.assertEqual(ethernet.name, 'admineth2')
    
    def test_ethernet_details_api_ACL(self):
        """ ethernet details ACL """
        # non owner can only read
        ethernet = Ethernet.objects.get(pk=1)
        ethernet.access_level = 1
        ethernet.save()
        url = reverse('api_ethernet_details', args=[1])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        
        self.client.login(username='registered', password='tester')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
    
    def test_device_wireless_api(self):
        """ API device wireless interfaces """
        
        url = reverse('api_device_wireless', args=[1])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 1)
        
        url = reverse('api_device_wireless', args=[99])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
    
    def test_device_wireless_api_ACL(self):
        """ API device wireless ACL """
        wireless = Wireless.objects.create(
            device_id=1,
            access_level=1,
            name='private',
            mac='00:27:22:38:13:a5',
            standard='802.11n'
        )
        
        url = reverse('api_device_wireless', args=[1])
        device_url = reverse('api_device_details', args=[1])
        
        # unauthenticated can see 1
        response = self.client.get(url)
        self.assertEqual(len(response.data), 1)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['wireless']), 1)
        
        # registered can see 2
        self.client.login(username='registered', password='tester')
        response = self.client.get(url)
        self.assertEqual(len(response.data), 2)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['wireless']), 2)
        
        # set to higher access level
        wireless.access_level = 2
        wireless.save()
        
        # now registed can see only 1
        response = self.client.get(url)
        self.assertEqual(len(response.data), 1)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['wireless']), 1)
        
        # community can see two
        self.client.logout()
        self.client.login(username='community', password='tester')
        response = self.client.get(url)
        self.assertEqual(len(response.data), 2)
        # check device detail url too
        response = self.client.get(device_url)
        self.assertEqual(len(response.data['wireless']), 2)
    
    def test_device_wireless_api_permissions(self):
        """ API device wireless interfaces permissions to create """
        data = {
            "name": "ath0",
            "mac": "00:27:22:38:13:c4",
            "tx_rate": 10000, 
            "rx_rate": 10000, 
            "standard": "802.11n",
            "data": { "status": "active" }
            
        }
        json_data = json.dumps(data)
        eth_count = Wireless.objects.filter(device_id=2).count()
        url = reverse('api_device_wireless', args=[2])
        
        # unlogged can't create
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.assertEqual(Wireless.objects.filter(device_id=2).count(), eth_count)
        
        # non-owner can't create
        self.client.login(username='registered', password='tester')
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.assertEqual(Wireless.objects.filter(device_id=2).count(), eth_count)
        self.client.logout()
        
        # owner can create
        self.client.login(username='romano', password='tester')
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Wireless.objects.filter(device_id=2).count(), eth_count+1)
        self.client.logout()
        Wireless.objects.get(mac='00:27:22:38:13:c4').delete()
        
        # admin can create too
        self.client.login(username='admin', password='tester')
        response = self.client.post(url, json_data, content_type='application/json')
        self.assertEqual(response.status_code, 201)
        self.assertEqual(Wireless.objects.filter(device_id=2).count(), eth_count+1)
    
    def test_wireless_details_api_permissions(self):
        """ wireless details permissions: only owner or admins can alter data """
        # non owner can only read
        url = reverse('api_wireless_details', args=[2])
        response = self.client.patch(url, { 'name': 'eth2' })
        self.assertEqual(response.status_code, 403)
        response = self.client.delete(url)
        self.assertEqual(response.status_code, 403)
        
        # login as non-owner
        self.client.login(username='pisano', password='tester')
        response = self.client.patch(url, { 'name': 'eth2' })
        self.assertEqual(response.status_code, 403)
        response = self.client.delete(url)
        self.assertEqual(response.status_code, 403)
        
        # login as owner
        wireless = Wireless.objects.get(pk=2)
        self.client.login(username=wireless.owner.username, password='tester')
        
        # owner can edit
        response = self.client.patch(url, { 'name': 'eth2' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['name'], 'eth2')
        # check DB
        wireless = Wireless.objects.get(pk=2)
        self.assertEqual(wireless.name, 'eth2')
        
        # admin can edit too
        self.client.logout()
        self.client.login(username='admin', password='tester')
        response = self.client.patch(url, { 'name': 'admineth2' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['name'], 'admineth2')
        # check DB
        wireless = Wireless.objects.get(pk=2)
        self.assertEqual(wireless.name, 'admineth2')
    
    def test_wireless_details_api_ACL(self):
        """ wireless details ACL """
        # non owner can only read
        wireless = Wireless.objects.get(pk=2)
        wireless.access_level = 1
        wireless.save()
        url = reverse('api_wireless_details', args=[2])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        
        self.client.login(username='registered', password='tester')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
    
    def test_interface_ip_address_get(self):
        # GET 404
        response = self.client.get(reverse('api_interface_ip', args=[99]))
        self.assertEqual(response.status_code, 404)
        
        # GET 200
        response = self.client.get(reverse('api_interface_ip', args=[1]))
        self.assertEqual(response.status_code, 200)
    
    def test_interface_ip_address_post_and_permissions(self):
        url = reverse('api_interface_ip', args=[1])
        data = {
            "address": "10.40.0.35",
            "netmask": "10.40.0.0/24"
        }
        
        # POST 403 unauthenticated
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 403)
        
        # POST 403 non owner can't add ip
        self.client.login(username='pisano', password='tester')
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 403)
        self.client.logout()
        
        # POST 200 owner can add ip
        self.client.login(username=Interface.objects.find(1).owner.username, password='tester')
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 201)
        # ensure address
        ip = Ip.objects.last()
        self.assertEqual(ip.address.__str__(), '10.40.0.35')
        ip.delete()
        self.client.logout()
        
        # POST 200 also admin can add ip
        self.client.login(username='admin', password='tester')
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 201)
        # ensure address
        ip = Ip.objects.last()
        self.assertEqual(ip.address.__str__(), '10.40.0.35')
    
    def test_interface_ip_address_fields_validation(self):
        url = reverse('api_interface_ip', args=[1])
        data = {
            "address": "WRONG",
            "netmask": "VERY WRONG"
        }
        
        self.client.login(username=Interface.objects.find(1).owner.username, password='tester')
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 400)
        self.assertEqual(response.data['address'][0], 'Invalid ip address')
        self.assertEqual(response.data['netmask'][0], 'Invalid ip network')
        
        data = {
            "address": "10.40.0.1",
            "netmask": "10.40."
        }
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 400)
        
        data = {
            "address": "10.40.0.",
            "netmask": "10.40.0.0/24"
        }
        response = self.client.post(url, data)
        self.assertEqual(response.status_code, 400)
    
    def test_interface_ip_api_ACL(self):
        url = reverse('api_interface_ip', args=[1])
        
        # non owner can only read
        interface = Interface.objects.get(pk=1)
        ip_count = interface.ip_set.count()
        ip = interface.ip_set.first()
        ip.access_level = 1
        ip.save()
        response = self.client.get(url)
        self.assertEqual(len(response.data), interface.ip_set.access_level_up_to('public').count())
        self.assertEqual(len(response.data), ip_count-1)
        
        self.client.login(username='registered', password='tester')
        response = self.client.get(url)
        self.assertEqual(len(response.data), interface.ip_set.access_level_up_to('registered').count())
        self.assertEqual(len(response.data), ip_count)
    
    def test_ip_address_details_permissions(self):
        url = reverse('api_ip_details', args=[1])
        data = json.dumps({
            "address": "10.40.0.35",
            "netmask": "10.40.0.0/24"
        })
        
        # PUT 403 unauthenticated
        response = self.client.put(url, data, content_type='application/json')
        self.assertEqual(response.status_code, 403)
        
        # PUT 403 non owner can't edit ip
        self.client.login(username='pisano', password='tester')
        response = self.client.put(url, data, content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.client.logout()
        
        # PUT 200 owner can edit ip
        self.client.login(username=Ip.objects.find(1).owner.username, password='tester')
        response = self.client.put(url, data, content_type='application/json')
        self.assertEqual(response.status_code, 200)
        # ensure address
        ip = Ip.objects.find(1)
        self.assertEqual(ip.address.__str__(), '10.40.0.35')
        self.client.logout()
        
        # PUT 200 also admin can edit ip
        self.client.login(username='admin', password='tester')
        data = json.dumps({
            "address": "10.40.0.36",
            "netmask": "10.40.0.0/24"
        })
        response = self.client.put(url, data, content_type='application/json')
        self.assertEqual(response.status_code, 200)
        # ensure address
        ip = Ip.objects.find(1)
        self.assertEqual(ip.address.__str__(), '10.40.0.36')
    
    def test_ip_details_api_ACL(self):
        # non owner can only read
        ip = Ip.objects.get(pk=1)
        ip.access_level = 1
        ip.save()
        url = reverse('api_ip_details', args=[1])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 404)
        
        self.client.login(username='registered', password='tester')
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
    
    def test_bridge_interfaces_validation(self):
        bridge = Bridge(device_id=1, mac='00:11:22:33:44:55', name='br0')
        bridge.save()
        
        # must bridge at least 2
        with self.assertRaises(ValidationError):
            bridge.interfaces.add(Interface.objects.find(1))
        
        bridge.interfaces.add(Interface.objects.find(1), Interface.objects.find(2))
        bridge.full_clean()
        
        # can't bridge different devices
        ethernet = Ethernet.objects.create(device_id=2, mac='00:00:22:33:44:55', name='br0')
        with self.assertRaises(ValidationError):
            bridge.interfaces.add(ethernet)
        
        # test add
        ethernet.device_id = 1
        ethernet.save()
        bridge.interfaces.add(ethernet)
        
        # can't bridge self
        with self.assertRaises(ValidationError):
            bridge.interfaces.add(bridge)
    
    def test_device_bridge_api(self):
        bridge = Bridge(device_id=1, mac='00:11:22:33:44:55', name='br0')
        bridge.save()
        bridge.interfaces.add(Interface.objects.find(1), Interface.objects.find(2))
        
        url = reverse('api_device_bridge', args=[1])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertIn('http://', response.data[0]['interfaces_links'][0])
        self.assertIn('http://', response.data[0]['interfaces_links'][1])
        bridge.delete()
        
        data = {
            "name": "br0test", 
            "mac": "00:11:22:33:44:55",
            "interfaces": []
        }
        
        # POST 403: unauthorized
        response = self.client.post(url, json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.client.login(username='pisano', password='tester')
        response = self.client.post(url, json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 403)
        self.client.logout()
        
        # POST 400: missing interfaces
        self.client.login(username=bridge.owner.username, password='tester')
        response = self.client.post(url, json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 400)
        
        data['interfaces'] = [1, 2]
        response = self.client.post(url, json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 201)
        
        # POST 201
        bridge = Bridge.objects.last()
        self.assertEquals(bridge.name, 'br0test')
        self.assertEquals(bridge.mac, '00:11:22:33:44:55')
        self.assertEquals(bridge.interfaces.count(), 2)
        
        # POST 400: duplicate mac address
        response = self.client.post(url, json.dumps(data), content_type='application/json')
        self.assertEqual(response.status_code, 400)
    
    def test_bridge_details_api(self):
        bridge = Bridge(device_id=1, mac='00:11:22:33:44:55', name='br0')
        bridge.save()
        bridge.interfaces.add(Interface.objects.find(1), Interface.objects.find(2))
        
        url = reverse('api_bridge_details', args=[bridge.id])
        response = self.client.get(url)
        self.assertEqual(response.status_code, 200)
        self.assertIn('http://', response.data['interfaces_links'][0])
        self.assertIn('http://', response.data['interfaces_links'][1])
        
        # PATCH 403 unauthenticated
        response = self.client.patch(url, {})
        self.assertEqual(response.status_code, 403)
        
        # PATCH 403 logged in as non owner
        self.client.login(username='pisano', password='tester')
        response = self.client.patch(url, {})
        self.assertEqual(response.status_code, 403)
        self.client.logout()
        
        # PATCH 200 logged in as owner
        self.client.login(username=bridge.owner.username, password='tester')
        response = self.client.patch(url, { 'name': 'brtest' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['name'], 'brtest')
        
        # PATCH 400 empty interfaces
        response = self.client.patch(url, json.dumps({ 'interfaces': [] }), content_type='application/json')
        self.assertEqual(response.status_code, 400)
        self.client.logout()
        
        # PATCH 200 by admin
        self.client.login(username='admin', password='tester')
        response = self.client.patch(url, { 'name': 'admin' })
        self.assertEqual(response.status_code, 200)
        self.assertEqual(response.data['name'], 'admin')
    
    # TODO: write tests for vlan, tunnel, vap
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.networking.net.views',
    url(r'^devices/$', 'device_list', name='api_device_list'),
    url(r'^devices/(?P<pk>[0-9]+)/$', 'device_details', name='api_device_details'),
    url(r'^nodes/(?P<slug>[-\w]+)/devices/$', 'node_device_list', name='api_node_devices'),
    
    # interfaces
    url(r'^devices/(?P<pk>[0-9]+)/ethernet/$', 'device_ethernet_list', name='api_device_ethernet'),
    url(r'^ethernet/(?P<pk>[0-9]+)/$', 'ethernet_details', name='api_ethernet_details'),
    url(r'^devices/(?P<pk>[0-9]+)/wireless/$', 'device_wireless_list', name='api_device_wireless'),
    url(r'^wireless/(?P<pk>[0-9]+)/$', 'wireless_details', name='api_wireless_details'),
    url(r'^devices/(?P<pk>[0-9]+)/bridge/$', 'device_bridge_list', name='api_device_bridge'),
    url(r'^bridge/(?P<pk>[0-9]+)/$', 'bridge_details', name='api_bridge_details'),
    url(r'^devices/(?P<pk>[0-9]+)/tunnel/$', 'device_tunnel_list', name='api_device_tunnel'),
    url(r'^tunnel/(?P<pk>[0-9]+)/$', 'tunnel_details', name='api_tunnel_details'),
    url(r'^devices/(?P<pk>[0-9]+)/vlan/$', 'device_vlan_list', name='api_device_vlan'),
    url(r'^vlan/(?P<pk>[0-9]+)/$', 'vlan_details', name='api_vlan_details'),
    
    # ip
    url(r'^interfaces/(?P<pk>[0-9]+)/ip/$', 'interface_ip_list', name='api_interface_ip'),
    url(r'^ip/(?P<pk>[0-9]+)/$', 'ip_details', name='api_ip_details'),
)
########NEW FILE########
__FILENAME__ = views
from django.http import Http404
from django.utils.translation import ugettext_lazy as _
from django.db.models import Q

from rest_framework import authentication, generics

from nodeshot.core.base.mixins import ACLMixin, CustomDataMixin
from nodeshot.core.nodes.models import Node

from .permissions import IsOwnerOrReadOnly
from .serializers import *
from .models import *


# ------ DEVICES ------ #


class DeviceList(ACLMixin, generics.ListAPIView):
    """
    Retrieve device list according to user access level
    
    Parameters:
    
     * `search=<word>`: search <word> in name, slug, description and address of nodes
     * `limit=<n>`: specify number of items per page (defaults to 40)
     * `limit=0`: turns off pagination
    """
    authentication_classes = (authentication.SessionAuthentication,)
    queryset = Device.objects.all().select_related('node')
    serializer_class = DeviceListSerializer
    pagination_serializer_class = PaginatedDeviceSerializer
    paginate_by_param = 'limit'
    paginate_by = 40
    
    def get_queryset(self):
        """
        Optionally restricts the returned devices
        by filtering against a `search` query parameter in the URL.
        """
        # retrieve all devices which are published and accessible to current user
        # and use joins to retrieve related fields
        queryset = super(DeviceList, self).get_queryset()#.select_related('layer', 'status', 'user')
        
        # retrieve value of querystring parameter "search"
        search = self.request.QUERY_PARAMS.get('search', None)
        
        if search is not None:
            search_query = (
                Q(name__icontains=search) |
                Q(description__icontains=search)
            )
            # add instructions for search to queryset
            queryset = queryset.filter(search_query)
        
        return queryset
    
device_list = DeviceList.as_view()


class DeviceDetails(ACLMixin, generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve details of specified device.
    
    ### DELETE
    
    Delete specified device. Must be authenticated as owner or admin.
    
    ### PUT & PATCH
    
    Edit device. Must be authenticated as owner or admin.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (IsOwnerOrReadOnly,)
    queryset = Device.objects.all().select_related('node')
    serializer_class = DeviceDetailSerializer

device_details = DeviceDetails.as_view()


class NodeDeviceList(CustomDataMixin, generics.ListCreateAPIView):
    """
    Retrieve devices of specified node according to user access level.
    
    Parameters:
    
     * `limit=<n>`: specify number of items per page (defaults to 40)
     * `limit=0`: turns off pagination
    
    ### POST
    
    Create a new device for this node. Must be authenticated as node owner or admin.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (IsOwnerOrReadOnly,)
    serializer_class = NodeDeviceListSerializer
    serializer_custom_class = DeviceAddSerializer
    pagination_serializer_class = PaginatedNodeDeviceSerializer
    paginate_by_param = 'limit'
    paginate_by = 40
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'node': self.node.id
        }
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure node exists and store it in an instance attribute
            * change queryset to return only devices of current node
        """
        super(NodeDeviceList, self).initial(request, *args, **kwargs)
        
        # ensure node exists
        try:
            self.node = Node.objects.published()\
                        .accessible_to(request.user)\
                        .get(slug=self.kwargs.get('slug', None))
        except Node.DoesNotExist:
            raise Http404(_('Node not found.'))
        
        # check permissions on node (for device creation)
        self.check_object_permissions(request, self.node)
        
        # return only devices of current node
        self.queryset = Device.objects.filter(node_id=self.node.id)\
                        .accessible_to(self.request.user)\
                        .select_related('node')
    
node_device_list = NodeDeviceList.as_view()


# ------ INTERFACES ------ #


class BaseInterfaceList(CustomDataMixin, generics.ListCreateAPIView):
    """
    Retrieve interface list for specified device.
    
    ### POST
    
    Create new interface for specified device.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (IsOwnerOrReadOnly,)
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'device': self.device.id
        }
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure device exists and store it in an instance attribute
            * change queryset to return only devices of current node
        """
        super(BaseInterfaceList, self).initial(request, *args, **kwargs)
        
        # ensure device exists
        try:
            self.device = Device.objects.accessible_to(request.user)\
                        .get(pk=self.kwargs.get('pk', None))
        except Device.DoesNotExist:
            raise Http404(_('Device not found.'))
        
        # check permissions on device (for interface creation)
        self.check_object_permissions(request, self.device)
        
        # return only interfaces of current device
        self.queryset = self.model.objects.filter(device_id=self.device.id)\
                        .accessible_to(self.request.user)


class BaseInterfaceDetails(ACLMixin, generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve details of specified interface.
    
    ### DELETE
    
    Delete specified interface. Must be authenticated as owner or admin.
    
    ### PUT & PATCH
    
    Edit interface. Must be authenticated as owner or admin.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (IsOwnerOrReadOnly,)


class DeviceEthernetList(BaseInterfaceList):
    model = Ethernet
    serializer_class = EthernetDetailSerializer
    serializer_custom_class = EthernetAddSerializer
    
device_ethernet_list = DeviceEthernetList.as_view()


class EthernetDetails(BaseInterfaceDetails):
    queryset = Ethernet.objects.all()
    serializer_class = EthernetSerializer

ethernet_details = EthernetDetails.as_view()


class DeviceWirelessList(BaseInterfaceList):
    model = Wireless
    serializer_class = WirelessDetailSerializer
    serializer_custom_class = WirelessAddSerializer
    
device_wireless_list = DeviceWirelessList.as_view()


class WirelessDetails(BaseInterfaceDetails):
    queryset = Wireless.objects.all()
    serializer_class = WirelessSerializer

wireless_details = WirelessDetails.as_view()


class DeviceBridgeList(BaseInterfaceList):
    model = Bridge
    serializer_class = BridgeDetailSerializer
    serializer_custom_class = BridgeAddSerializer
    
device_bridge_list = DeviceBridgeList.as_view()


class BridgeDetails(BaseInterfaceDetails):
    queryset = Bridge.objects.all()
    serializer_class = BridgeSerializer

bridge_details = BridgeDetails.as_view()


class DeviceTunnelList(BaseInterfaceList):
    model = Tunnel
    serializer_class = TunnelDetailSerializer
    serializer_custom_class = TunnelAddSerializer
    
device_tunnel_list = DeviceTunnelList.as_view()


class TunnelDetails(BaseInterfaceDetails):
    queryset = Tunnel.objects.all()
    serializer_class = TunnelSerializer

tunnel_details = TunnelDetails.as_view()


class DeviceVlanList(BaseInterfaceList):
    model = Vlan
    serializer_class = VlanDetailSerializer
    serializer_custom_class = VlanAddSerializer
    
device_vlan_list = DeviceVlanList.as_view()


class VlanDetails(BaseInterfaceDetails):
    queryset = Vlan.objects.all()
    serializer_class = VlanSerializer

vlan_details = VlanDetails.as_view()


# ------ IP ADDRESS ------ #


class InterfaceIpList(CustomDataMixin, generics.ListCreateAPIView):
    """
    Retrieve IP list of specified interface.
    
    ### POST
    
    Create new interface for specified device.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (IsOwnerOrReadOnly,)
    model = Ip
    serializer_class = IpDetailSerializer
    serializer_custom_class = IpAddSerializer
    
    def get_custom_data(self):
        """ additional request.DATA """
        return {
            'interface': self.interface.id
        }
    
    def initial(self, request, *args, **kwargs):
        """
        Custom initial method:
            * ensure interface exists and store it in an instance attribute
            * change queryset to return only devices of current node
        """
        super(InterfaceIpList, self).initial(request, *args, **kwargs)
        
        # ensure interface exists
        try:
            self.interface = Interface.objects.accessible_to(request.user)\
                        .get(pk=self.kwargs.get('pk', None))
        except Interface.DoesNotExist:
            raise Http404(_('Interface not found.'))
        
        # check permissions on interface (for interface creation)
        self.check_object_permissions(request, self.interface)
        
        # return only interfaces of current interface
        self.queryset = self.model.objects.filter(interface_id=self.interface.id)\
                        .accessible_to(self.request.user)

interface_ip_list = InterfaceIpList.as_view()


class IpDetails(ACLMixin, generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve details of specified ip address.
    
    ### DELETE
    
    Delete specified ip address. Must be authenticated as owner or admin.
    
    ### PUT & PATCH
    
    Edit ip address. Must be authenticated as owner or admin.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (IsOwnerOrReadOnly,)
    queryset = Ip.objects.all()
    serializer_class = IpDetailSerializer

ip_details = IpDetails.as_view()

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = models
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.nodes.models import Node
from nodeshot.core.base.choices import PLANNED_STATUS


class PlannedNode(Node):
    date = models.DateTimeField(_('planned for'))
    planning_status = models.SmallIntegerField(_('status'), max_length=1, choices=PLANNED_STATUS, default=0)
    
    class Meta:
        db_table = 'planned_node'
        permissions = (('can_view_planned_nodes', 'Can view planned nodes'),)

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = admin
from django.contrib import admin
from django.conf import settings

from nodeshot.core.base.admin import BaseAdmin, BaseStackedInline

from .models import Category, Service, ServiceLogin, Url


class CategoryAdmin(BaseAdmin):
    list_display  = ('name', 'description', 'added', 'updated')
    ordering = ('name',)
    search_fields = ('name', 'description')


class UrlInline(BaseStackedInline):
    model = Url
    
    if 'grappelli' in settings.INSTALLED_APPS:
        # define the raw_id_fields
        raw_id_fields = ('ip',)
        # define the autocomplete_lookup_fields
        autocomplete_lookup_fields = {
            'fk': ['ip'],
        }


class ServiceLoginInline(BaseStackedInline):
    model = ServiceLogin


class ServiceAdmin(BaseAdmin):
    list_display  = ('name', 'device', 'category', 'access_level', 'status', 'is_published', 'added', 'updated')
    list_filter   = ('category', 'status', 'is_published')
    search_fields = ('name', 'description', 'documentation_url')
    inlines = (UrlInline, ServiceLoginInline,)

    raw_id_fields = ('device',)
    autocomplete_lookup_fields = {
        'fk': ('device',),
    }
    
    # enable editor for "description" only
    html_editor_fields = ['description']

admin.site.register(Category, CategoryAdmin)
admin.site.register(Service, ServiceAdmin)

########NEW FILE########
__FILENAME__ = category
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate


class Category(BaseDate):
    """
    Categories of services
    """
    name = models.CharField(_('name'), max_length=30)
    description = models.TextField(_('description'), blank=True, null=True)
    
    class Meta:
        app_label = 'services'
        db_table = 'service_category'
        verbose_name = _('category')
        verbose_name_plural = _('categories')
    
    def __unicode__(self):
        return '%s' % self.name
########NEW FILE########
__FILENAME__ = choices
from django.conf import settings
from django.utils.translation import ugettext_lazy as _


LOGIN_TYPES = (
    (1, _('read-only')),
    (2, _('write')),
)

SERVICE_STATUS = (
    (1, _('up')),
    (2, _('down')),
    (3, _('not reachable'))
)

try:
    APPLICATION_PROTOCOLS = settings.NODESHOT['CHOICES']['APPLICATION_PROTOCOLS']
except KeyError:
    APPLICATION_PROTOCOLS = (
        ('http', 'http'),
        ('https', 'https'),
        ('ftp', 'FTP'),
        ('smb', 'Samba'),
        ('afp', 'AFP'),
        ('git', 'Git'),
    )

TRANSPORT_PROTOCOLS = (
    ('tcp', 'TCP'),
    ('udp', 'UDP'),
)
########NEW FILE########
__FILENAME__ = service
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseAccessLevel
from nodeshot.core.base.managers import AccessLevelManager

from . import Category
from .choices import SERVICE_STATUS


class Service(BaseAccessLevel):
    """
    Service Model
    Describes a service, eg: ftp, storage, proxy, ecc.
    """
    device = models.ForeignKey('net.Device', verbose_name=_('device'))
    name = models.CharField(_('name'), max_length=30)
    category = models.ForeignKey(Category, verbose_name=_('category') )
    description = models.TextField(_('description'), blank=True, null=True)
    documentation_url = models.URLField(_('documentation url'), blank=True, null=True)
    status = models.SmallIntegerField(_('status'), choices=SERVICE_STATUS)
    is_published = models.BooleanField(_('published'), default=True)
    
    objects = AccessLevelManager()
    
    class Meta:
        app_label = 'services'
        verbose_name = _('service')
        verbose_name_plural = _('services')
    
    def __unicode__(self):
        return '%s' % self.name
########NEW FILE########
__FILENAME__ = service_login
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseAccessLevel
from nodeshot.core.base.managers import AccessLevelManager

from .choices import LOGIN_TYPES


class ServiceLogin(BaseAccessLevel):
    service = models.ForeignKey('services.Service',
                                verbose_name=_('service'))
    type = models.SmallIntegerField(_('type'), max_length=2,
                                    choices=LOGIN_TYPES,
                                    default=LOGIN_TYPES[0][0])
    username = models.CharField(_('username'), max_length=30)  # space should not be allowed
    password = models.CharField(_('password'), max_length=128)
    description = models.CharField(_('description'), max_length=255, blank=True, null=True)
    
    objects = AccessLevelManager()
    
    class Meta:
        app_label= 'services'
        db_table = 'service_logins'
        permissions = (('can_view_service_login', 'Can view service logins'),)
        verbose_name = _('login')
        verbose_name_plural = _('logins')
        unique_together = ('username', 'service')
    
    def __unicode__(self):
        return '%s - %s' % (self.username, self.service) 
########NEW FILE########
__FILENAME__ = url
from django.db import models
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.base.models import BaseDate
from choices import APPLICATION_PROTOCOLS, TRANSPORT_PROTOCOLS


class Url(BaseDate):
    service = models.ForeignKey('services.Service',
                                verbose_name=_('service'))
    transport = models.CharField(_('transport protocol'), max_length=5,
                                 choices=TRANSPORT_PROTOCOLS,
                                 default=TRANSPORT_PROTOCOLS[1][0])
    application = models.CharField(_('application protocol'), max_length=20,
                                   choices=APPLICATION_PROTOCOLS)
    ip = models.ForeignKey('net.Ip', verbose_name=_('ip address'))
    port = models.IntegerField(_('port'), blank=True, null=True)
    path = models.CharField(_('path'), max_length=50, blank=True)
    domain = models.CharField(_('domain'), max_length=50, blank=True)
    
    class Meta:
        app_label= 'services'
        db_table = 'service_urls'
        verbose_name = _('url')
        verbose_name_plural = _('urls')
    
    def __unicode__(self):
        value = ''
        if self.application:
            value = '%s://' % self.application
        if self.domain:
            value += self.domain
        else:
            if self.ip.protocol == 'ipv4':
                encaps = '%s'
            else:
                encaps = '[%s]'
            value += encaps % self.ip.address
        if self.port:
            value += ':%s' % self.port
        return value

########NEW FILE########
__FILENAME__ = serializers
from rest_framework import pagination, serializers

from .models import *


__all__ = [
    'ServiceListSerializer',
    'ServiceDetailSerializer',
    'PaginatedServiceSerializer',
    'ServiceLoginSerializer',
    'CategorySerializer'
]


class ServiceLoginSerializer(serializers.ModelSerializer):
    class Meta:
        model = ServiceLogin


class ServiceListSerializer(serializers.ModelSerializer):
    """ Service List Serializer  """
    
    details = serializers.HyperlinkedIdentityField(view_name='api_service_details')
    
    class Meta:
        model = Service


class ServiceDetailSerializer(ServiceListSerializer):
    """ Service Detail Serializer  """
    
    logins = ServiceLoginSerializer(many=True, source='servicelogin_set')
    
    class Meta:
        model = Service


class PaginatedServiceSerializer(pagination.PaginationSerializer):
    class Meta:
        object_serializer_class = ServiceListSerializer


class CategorySerializer(serializers.ModelSerializer):
    
    details = serializers.HyperlinkedIdentityField(view_name='api_service_category_details')
    
    class Meta:
        model = Category
        fields = ['id', 'name', 'description', 'added', 'updated', 'details']

########NEW FILE########
__FILENAME__ = tests
import simplejson as json

from django.core.exceptions import ValidationError
from django.core.urlresolvers import reverse

from nodeshot.core.base.tests import BaseTestCase
from nodeshot.core.base.tests import user_fixtures


class ServiceTest(BaseTestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_routing_protocols.json',
        'test_devices.json',
        'test_interfaces.json',
        'test_ip_addresses.json',
        'test_services.json'
    ]
    
    def test_api_service_category_list(self):
        # GET: 200 - service category list
        url = reverse('api_service_category_list')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
        
    def test_api_service_category_details(self):
        # GET: 200 - service category detail
        url = reverse('api_service_category_details', args=[1])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
    
    def test_api_service_list(self):
        # GET: 200 - service list
        url = reverse('api_service_list')
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)
        
    def test_api_service_details(self):
        # GET: 200 - service detail
        url = reverse('api_service_details', args=[1])
        response = self.client.get(url)
        self.assertEquals(response.status_code, 200)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.networking.services.views',
    url(r'^services/categories/$', 'service_category_list', name='api_service_category_list'),
    url(r'^services/categories/(?P<pk>[0-9]+)/$', 'service_category_details', name='api_service_category_details'),
    url(r'^services/$', 'service_list', name='api_service_list'),
    url(r'^services/(?P<pk>[0-9]+)/$', 'service_details', name='api_service_details'),
)

########NEW FILE########
__FILENAME__ = views
from rest_framework import permissions, authentication, generics

from nodeshot.core.base.mixins import ACLMixin

from .serializers import *
from .models import *


class ServiceList(ACLMixin, generics.ListCreateAPIView):
    """
    Retrieve service list according to user access level
    
    Parameters:
    
     * `limit=<n>`: specify number of items per page (defaults to 40)
     * `limit=0`: turns off pagination
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.DjangoModelPermissionsOrAnonReadOnly,)
    model = Service
    queryset = Service.objects.all()
    serializer_class = ServiceListSerializer
    pagination_serializer_class = PaginatedServiceSerializer
    paginate_by_param = 'limit'
    paginate_by = 40
    
service_list = ServiceList.as_view()


class ServiceDetail(ACLMixin, generics.RetrieveUpdateDestroyAPIView):
    """
    Retrieve service detail according to user access level
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.DjangoModelPermissionsOrAnonReadOnly,)
    model = Service
    queryset = Service.objects.all()
    serializer_class = ServiceDetailSerializer
    
service_details = ServiceDetail.as_view()


class CategoryList(generics.ListCreateAPIView):
    """
    List of service categories
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.DjangoModelPermissionsOrAnonReadOnly,)
    model = Category
    serializer_class = CategorySerializer
    
service_category_list = CategoryList.as_view()


class CategoryDetail(generics.RetrieveUpdateAPIView):
    """
    Category detail view
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.DjangoModelPermissionsOrAnonReadOnly,)
    model = Category
    serializer_class = CategorySerializer
    
service_category_details = CategoryDetail.as_view()

########NEW FILE########
__FILENAME__ = base
import re

from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from nodeshot.core.nodes.models import Node
from nodeshot.community.participation.models import Vote, Comment, Rating

DISCOVERY = settings.NODESHOT['OPEN311']['DISCOVERY']

STATUS = settings.NODESHOT['OPEN311']['STATUS']

SERVICES = {
    'node': {
        'name': _('Node insertion'),
        'description': _('Insert new nodes'),
        'keywords': '',
        'group': ''
    },
    'vote': {
        'name': _('Vote'),
        'description': _('Like or Dislike something'),
        'keywords': '',
        'group': ''
    },
    'comment': {
        'name': _('Comment'),
        'description': _('Leave a comment'),
        'keywords': '',
        'group': ''
    },
    'rate': {
        'name': _('Rate'),
        'description': _('Leave your rating about something'),
        'keywords': '',
        'group': ''
    }
}

MODELS = {
    'node': Node,
    'vote': Vote,
    'comment': Comment,
    'rate': Rating,
}

iso8601_REGEXP = re.compile("^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[0-1]|0[1-9]|[1-2][0-9])?T(2[0-3]|[0-1][0-9]):([0-5][0-9]):([0-5][0-9])(\.[0-9]+)??(Z|[+-](?:2[0-3]|[0-1][0-9]):[0-5][0-9])?$")

########NEW FILE########
__FILENAME__ = models
from nodeshot.core.base.utils import check_dependencies

check_dependencies(
    dependencies=[
        'nodeshot.core.nodes',
        'nodeshot.core.layers',
        'nodeshot.community.participation'
    ],
    module='nodeshot.open311'
)
########NEW FILE########
__FILENAME__ = serializers
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from rest_framework import serializers
from rest_framework.reverse import reverse

from nodeshot.core.nodes.models import Node, Image
from nodeshot.community.participation.models import Vote, Comment, Rating
from nodeshot.core.base.serializers import ExtraFieldSerializer

from .base import SERVICES

__all__ = [
    'ServiceRatingSerializer',
    'ServiceCommentSerializer',
    'ServiceNodeSerializer',
    'ServiceVoteSerializer',
    'ServiceListSerializer',
    'NodeRequestSerializer',
    'VoteRequestSerializer',
    'CommentRequestSerializer',
    'RatingRequestSerializer',
    'NodeRequestDetailSerializer',
    'NodeRequestListSerializer',
    'VoteRequestListSerializer',
    'CommentRequestListSerializer',
    'RatingRequestListSerializer',
]

RATING_CHOICES = [ n for n in range(1, 11) ]
VOTING_CHOICES = [ -1, 1 ]
    

class ServiceListSerializer(serializers.Serializer):
    """
    Open 311 service list
    """
    definition = serializers.SerializerMethodField('get_definition')
    metadata = serializers.SerializerMethodField('get_metadata')
    keywords = serializers.SerializerMethodField('get_keywords')
    group = serializers.SerializerMethodField('get_group')
    type = serializers.SerializerMethodField('get_type')
    service_code = serializers.SerializerMethodField('get_service_code')
    service_name = serializers.SerializerMethodField('get_service_name')
    description = serializers.SerializerMethodField('get_service_description')
    
    def __init__(self, *args, **kwargs):
        self.service_type = kwargs.pop('service_type','node')
        super(ServiceListSerializer, self).__init__(*args, **kwargs)
    
    def get_definition(self, obj):
        request = self.context['request']
        format = self.context['format']
        return reverse('api_service_definition_detail',
                       args=[self.service_type],
                       request=request,
                       format=format) 
    
    def get_service_code(self, obj):        
        return self.service_type
    
    def get_service_name(self, obj):        
        return SERVICES[self.service_type]['name']
    
    def get_service_description(self, obj):        
        return SERVICES[self.service_type]['description']
    
    def get_keywords(self, obj):        
        return SERVICES[self.service_type]['keywords']
    
    def get_group(self,obj):
        return SERVICES[self.service_type]['group']
    
    def get_metadata(self,obj):
        """ Open311 metadata indicates whether there are custom attributes """
        return 'true'
    
    def get_type(self,obj):
        """ type setting - TODO explain """
        return settings.NODESHOT['OPEN311']['TYPE']
    
    class Meta:
        fields= (
            'service_code',
            'service_name',
            'description',
            'keywords',
            'group',
            'definition',
            'metadata',
            'type',
        )


class ServiceNodeSerializer(serializers.Serializer):
    """
    Service details
    """
    service_code = serializers.SerializerMethodField('get_service_code')    
    attributes = serializers.SerializerMethodField('get_attributes')
    
    def get_service_code(self, obj):        
        return 'node'
    
    def get_attributes(self, obj):        
        return [
            # layer
            {
                'code': 'layer',
                'description': _('layer_slug'),
                'datatype': 'string',
                'datatype_description': _('Specify the slug of the layer in which you want to insert the node'),
                'order': 1,
                'required': True,
                'variable' : True
            },
            
            # name
            {
                'code': 'name',
                'description': _('name'),
                'datatype': 'string',
                'datatype_description': _('Name of the node you want to insert'),
                'order': 2,
                'required': True,
                'variable' : True
            },
            
            # lat
            {
                'code': 'lat',
                'description': _('latitude'),
                'datatype': 'string',
                'datatype_description': _('Latitude of node'),
                'order': 3,
                'required': True,
                'variable' : True
            },
            
            # long
            {
                'code': 'long',
                'description': _('longitude'),
                'datatype': 'string',
                'datatype_description': _('Longitude of node'),
                'order': 4,
                'required': True,
                'variable' : True
            },
            
            # address
            {
                'code': 'address',
                'description': _('address'),
                'datatype': 'string',
                'datatype_description': _('Address of node'),
                'order': 5,
                'required': False,
                'variable' : True
            },
            
            # elev (elevation)
            {
                'code': 'elev',
                'description': _('elevation'),
                'datatype': 'string',
                'datatype_description': _('Elevation of node'),
                'order': 6,
                'required': False,
                'variable' : True
            },
            
            # description
            {
                'code': 'description',
                'description': _('description'),
                'datatype': 'string',
                'datatype_description': _('Description of node'),
                'order': 7,
                'required': False,
                'variable' : True
            },
            
            # images
            {
                'code': 'images',
                'description': _('images'),
                'datatype': 'string',
                'datatype_description': _('Images related to node. A client may POST multiple files as multipart/form-data.\
                                          Requests return the URL for this images via the image_url field'),
                'order': 8,
                'required': False,
                'variable' : True
            }
        ]
    
    class Meta:
        fields = ('service_code', 'attributes')


class ServiceVoteSerializer(serializers.Serializer):
    """
    Service details
    """
    service_code = serializers.SerializerMethodField('get_service_code')    
    attributes = serializers.SerializerMethodField('get_attributes')
    
    def get_service_code(self, obj):        
        return 'vote'
    
    def get_attributes(self, obj):        
        return [
            # node_id
            {
                'code': 'node_id',
                'description': _('Node id'),
                'datatype': 'string',
                'datatype_description': _('Specify for which node you want to insert the vote'),
                'order': 1,
                'required': True,
                'variable' : True

            },
            
            # vote
            {
                'code': 'vote',
                'description': _('vote on a node'),
                'datatype': 'string',
                'datatype_description': _('Vote 1 or -1 (Like/Dislike)'),
                'order': 2,
                'required': True,
                'variable' : True,
                'values' : [1,-1]
            },

        ]
    
    class Meta:
        fields = ('service_code', 'attributes')


class ServiceCommentSerializer(serializers.Serializer):
    """
    Service details
    """
    service_code = serializers.SerializerMethodField('get_service_code')    
    attributes = serializers.SerializerMethodField('get_attributes')
    
    def get_service_code(self, obj):        
        return 'comment'
    
    def get_attributes(self, obj):        
        return [
            # node_id
            {
                'code': 'node_id',
                'description': _('Node id'),
                'datatype': 'string',
                'datatype_description': _('Specify for which node you want to insert the comment'),
                'order': 1,
                'required': True,
                'variable' : True
            },
            
            # vote
            {
                'code': 'comment',
                'description': _('comment on a node'),
                'datatype': 'string',
                'datatype_description': _('text of the comment'),
                'order': 2,
                'required': True,
                'variable' : True

            },

        ]
    
    class Meta:
        fields = ('service_code', 'attributes')


class ServiceRatingSerializer(serializers.Serializer):
    """
    Service details
    """
    service_code = serializers.SerializerMethodField('get_service_code')    
    attributes = serializers.SerializerMethodField('get_attributes')
    
    def get_service_code(self, obj):        
        return 'rate'
    
    def get_attributes(self, obj):        
        return [
            # node_id
            {
                'code': 'node_id',
                'description': _('Node id'),
                'datatype': 'string',
                'datatype_description': _('Specify which node you want to rate'),
                'order': 1,
                'required': True,
                'variable' : True,
                'required': True

            },
            
            # rating
            {
                'code': 'rating',
                'description': _('rating of a node'),
                'datatype': 'string',
                'datatype_description': _('rate node from 1 to 10'),
                'order': 2,
                'required': True,
                'variable' : True,
                'values' : RATING_CHOICES
            },

        ]
    
    class Meta:
        fields = ('service_code', 'attributes')         


class NodeRequestListSerializer(ExtraFieldSerializer):
    """
    Open 311 node request 
    """
    service_request_id = serializers.SerializerMethodField('get_service_request_id')
    layer_slug= serializers.SerializerMethodField('get_layer_slug')   
    details = serializers.SerializerMethodField('get_details')
    image_urls = serializers.SerializerMethodField('get_image_urls')
    requested_datetime = serializers.Field(source='added')
    updated_datetime = serializers.Field(source='updated')
    lat = serializers.CharField()
    long = serializers.CharField()
    image = serializers.ImageField()
    service_code = serializers.CharField()
    layer = serializers.CharField()
    
    def get_image_urls(self,obj):
        image_url =[]
        
        try:
            image = Image.objects.all().filter(node=obj.id)
        except:
            image=None
        
        if image is not None:
            for i in image:
                    image_url.append( '%s%s' % (settings.MEDIA_URL, i))
            return image_url
        else:
            return ""

    def get_layer_name(self, obj):
        if obj is None:
            return ""
        layer_name =  obj.layer
        return layer_name
    
    def get_layer_slug(self, obj):
        if obj is None:
            return ""
        layer_slug =  obj.layer.slug
        return layer_slug
    
    def get_service_request_id(self, obj):
        if obj is None:
            return ""
        service_request_id = 'node-%d' % obj.id
        return service_request_id
    
    def get_details(self, obj):
        if obj is None:
            return ""
        request = self.context['request']
        format = self.context['format']
        
        return reverse('api_service_request_detail',
                       args=['node',obj.id],
                       request=request,
                       format=format)
   
    class Meta:
        model = Node
        fields= ('service_request_id', 'slug', 'name', 'service_code', 'layer', 'layer_slug', 'status', 'geometry', 'name',
                 'description', 'requested_datetime', 'updated_datetime', 'image_urls','image',
                 'details', 'address', 'lat', 'long', )
        read_only_fields = ('geometry', 'id', 'status', 'is_published', 'access_level',
                            'data','notes','user','added','updated', 'slug', )
        non_native_fields = ( 'service_code', 'lat', 'long',
                                'elev', 'image', 'layer_slug', )
        

class NodeRequestDetailSerializer(NodeRequestListSerializer):
    """
    Open 311 node request 
    """  
   
    class Meta:
        model = Node
        fields= ('layer','layer_slug','slug','name','status', 'geometry', 'description', 'address',
                 'requested_datetime', 'updated_datetime', 'image_urls',)


class NodeRequestSerializer(serializers.ModelSerializer):
    """
    Open 311 node request 
    """
    
    class Meta:
        model = Node
        

class VoteRequestListSerializer(ExtraFieldSerializer):
    """
    Open 311 vote request 
    """
    node_id = serializers.CharField()
    service_code = serializers.CharField()
    
    class Meta:
        model = Vote
        fields= ('service_code', 'node', 'vote',)        
        non_native_fields = ('node', 'service_code')


class VoteRequestSerializer(serializers.ModelSerializer):
    """
    Open 311 vote request 
    """
    
    class Meta:
        model = Vote


class CommentRequestListSerializer(ExtraFieldSerializer):
    """
    Open 311 comment request 
    """
    service_code = serializers.CharField()
    class Meta:
        model = Comment
        fields= ('service_code', 'node', 'text',)        
        non_native_fields = ('node', 'service_code')       

        
class CommentRequestSerializer(serializers.ModelSerializer):
    """
    Open 311 comment request 
    """
    
    class Meta:
        model = Comment


class RatingRequestListSerializer(ExtraFieldSerializer):
    """
    Open 311 rating request 
    """
    service_code = serializers.CharField()
    class Meta:
        model = Rating
        fields= ('service_code', 'node', 'value',)        
        non_native_fields = ('node', 'service_code')
        
        
class RatingRequestSerializer(serializers.ModelSerializer):
    """
    Open 311 rating request 
    """
    
    class Meta:
        model = Rating

########NEW FILE########
__FILENAME__ = tests
"""
nodeshot.open311.tests
"""
import os
import simplejson as json

from django.core.urlresolvers import reverse
from django.contrib.gis.geos import GEOSGeometry

from nodeshot.core.base.tests import BaseTestCase, user_fixtures
from nodeshot.open311.serializers import *
from nodeshot.open311.base import SERVICES


class Open311Request(BaseTestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_images.json'
    ]

    def test_service_discovery(self):
        response = self.client.get(reverse('api_service_discovery'))
        # ensure 4 keys in response
        self.assertEqual(len(response.data), 4)
        
        # ensure 5 keys for each endpoint
        for endpoint in response.data['endpoints']:
            self.assertEqual(len(endpoint), 5)
    
    def test_service_list(self):
        response = self.client.get(reverse('api_service_definition_list'))
        
        # ensure 4 services
        self.assertEqual(len(response.data), 4)
        
        # ensure these words are in response
        for word in SERVICES.keys():
            self.assertContains(response, word)
    
    def test_node_service_definition(self):
        response = self.client.get(reverse('api_service_definition_detail', args=['node']))
        
        # ensure correct service code
        self.assertEqual(response.data['service_code'], 'node')
        
        # ensure 7 attributes
        self.assertEqual(len(response.data['attributes']), 8)
        
    def test_vote_service_definition(self):
        response = self.client.get(reverse('api_service_definition_detail', args=['vote']))
        
        # ensure correct service code
        self.assertEqual(response.data['service_code'], 'vote')
        
        # ensure 7 attributes
        self.assertEqual(len(response.data['attributes']), 2)
    
    def test_comment_service_definition(self):
        response = self.client.get(reverse('api_service_definition_detail', args=['comment']))
        
        # ensure correct service code
        self.assertEqual(response.data['service_code'], 'comment')
        
        # ensure 7 attributes
        self.assertEqual(len(response.data['attributes']), 2)
    
    def test_rate_service_definition(self):
        response = self.client.get(reverse('api_service_definition_detail', args=['rate']))
        
        # ensure correct service code
        self.assertEqual(response.data['service_code'], 'rate')
        
        # ensure 7 attributes
        self.assertEqual(len(response.data['attributes']), 2)
        
    def test_service_request_wrong_service(self):
        # check wrong service in service_request
        login = self.client.login(username='admin', password='tester')
        service_request={'service_code':'not_exists'}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        self.assertEqual(response.status_code, 404)
        
    def test_service_request_node(self):
        # service_request for nodes
        service_request={
                        'service_code':"node",
                        "name": "montesacro4",
                        "slug": "montesacro4",
                        "layer": "rome",
                        "lat": "22.5253",
                        "long": "41.8890",
                        "description": "test",
                        }
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        # Not authenticated : 403
        self.assertEqual(response.status_code, 403)
        login = self.client.login(username='admin', password='tester')
        # Authenticated users can insert service requests: 201
        response = self.client.post(url,service_request)        
        self.assertEqual(response.status_code, 201)
        
    def test_service_request_node_incomplete_key(self):
        # POST requests
        
        # incorrect service_request for nodes
        login = self.client.login(username='admin', password='tester')
               
        service_request={
                        'service_code':"node",
                        "slug": "montesacro4",
                        "layer": "rome",
                        "lat": "22.5253",
                        "long": "41.8890",
                        "description": "test",
                        }
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        self.assertEqual(response.status_code, 400)
        
    def test_service_request_node_incomplete_value(self):
        # POST requests
        
        # incorrect service_request for nodes
        login = self.client.login(username='admin', password='tester')
               
        service_request={
                        'service_code':"node",
                        "name": "",
                        "slug": "montesacro4",
                        "layer": "rome",
                        "lat": "22.5253",
                        "long": "41.8890",
                        "description": "test",
                        }
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        self.assertEqual(response.status_code, 400)
    
    def test_service_request_vote(self):
        # service_request for votes
        login = self.client.login(username='admin', password='tester')   
        service_request={'service_code':"vote","node": 1,"vote":1}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        self.assertEqual(response.status_code, 201)
        
    def test_service_request_vote_incomplete(self):
        # incomplete service_request for votes
        login = self.client.login(username='admin', password='tester')   
        service_request={'service_code':"vote","vote":1}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        
        self.assertEqual(response.status_code, 400)
        
    def test_service_request_vote_incorrect(self):
        # incorrect service_request for votes
        login = self.client.login(username='admin', password='tester')   
        service_request={'service_code':"vote","node": 1,"vote":10}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        self.assertEqual(response.status_code, 400)
        
    def test_service_request_rating(self):
        # service_request for rating
        login = self.client.login(username='admin', password='tester')   
        service_request={'service_code':"rate","node": 1,"value":1}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        
        self.assertEqual(response.status_code, 201)
        
    def test_service_request_rating_incomplete(self):
        # incomplete service_request for rating
        login = self.client.login(username='admin', password='tester')   
        service_request={'service_code':"rate","value":1}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        
        self.assertEqual(response.status_code, 400)
        
    def test_service_request_rating_incorrect(self):
        # incorrect service_request for rating
        login = self.client.login(username='admin', password='tester')   
        service_request={'service_code':"rate","node": 1,"value":20}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        
        self.assertEqual(response.status_code, 400)
        
    def test_service_request_comment(self):
        # service_request for comments
        login = self.client.login(username='admin', password='tester')   
        service_request={'service_code':"comment","node": 1,"text":"OK"}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        
        self.assertEqual(response.status_code, 201)
        
    def test_service_request_comment_incomplete(self):
        # incomplete service_request for comments
        login = self.client.login(username='admin', password='tester')   
        # Vote
        service_request={'service_code':"comment","text":"OK"}
        url = "%s" % reverse('api_service_request_list')
        response = self.client.post(url,service_request)
        
        self.assertEqual(response.status_code, 400)
        
    def test_get_service_request(self):
        # GET request detail 
        response = self.client.get(reverse('api_service_request_detail', args=['node','1']))
        self.assertEqual(response.status_code, 200)
        # Wrong service code
        response = self.client.get(reverse('api_service_request_detail', args=['wrong','1']))
        self.assertEqual(response.status_code, 404)
        # Not existing request
        response = self.client.get(reverse('api_service_request_detail', args=['node','100']))
        self.assertEqual(response.status_code, 404)
        
    def test_get_service_requests(self):
        # GET requests list
        response = self.client.get(reverse('api_service_request_list'))
        self.assertEqual(response.status_code, 404)
        
        parameters = {'service_code': 'node'}
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 10)
        
        parameters['status'] = 'open'
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 3)
        
        parameters['status'] = 'closed'       
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 7)
        
        parameters['status'] = 'wrong'       
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 404)
        
        # check date parameters
        parameters = {'service_code':'node','start_date':'wrong'}
        
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 404)
        
        parameters['start_date'] = '2013-01-01T17:57:02Z'
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 10)
        
        parameters['end_date'] = '2013-04-01T17:57:02Z'
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 0)
        
        parameters['start_date'] = '2015-01-01T17:57:02Z'
        response = self.client.get(reverse('api_service_request_list'), parameters)
        self.assertEqual(response.status_code, 200)
        self.assertEqual(len(response.data), 0)
        
    def test_file_upload(self):
        login = self.client.login(username='admin', password='tester')
        service_request={
                        'service_code':"node",
                        "name": "montesacro4",
                        "slug": "montesacro4",
                        "layer": "rome",
                        "lat": "22.5253",
                        "long": "41.8890",
                        "description": "test",
                        "geometry": "POINT (22.5253334454477372 41.8890404543067518)"
                        }
        with open("%s/templates/image_unit_test.gif" % os.path.dirname(os.path.realpath(__file__)), 'rb') as image_file:
            service_request['file'] = image_file
            url = "%s" % reverse('api_service_request_list')
            response = self.client.post(url,service_request)        
            self.assertEqual(response.status_code, 201)

    def test_open311_serializers(self):
        """ ensure serializers can be created this way """
        ServiceRatingSerializer().data
        ServiceCommentSerializer().data
        ServiceNodeSerializer().data
        ServiceVoteSerializer().data
        ServiceListSerializer().data
        NodeRequestSerializer().data
        VoteRequestSerializer().data
        CommentRequestSerializer().data
        RatingRequestSerializer().data
        VoteRequestListSerializer().data
        CommentRequestListSerializer().data
        RatingRequestListSerializer().data
        NodeRequestListSerializer().data
        NodeRequestDetailSerializer().data
        
    def test_open311_UI(self):
        """ ensure open311 UI can be reached"""
        response = self.client.get(reverse('open311_demo:open311'))
        self.assertEqual(response.status_code, 200)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.open311.views',
    url(r'^open311/$', 'service_discovery', name='api_service_discovery'),
    url(r'^open311/services.json$', 'service_definition_list', name='api_service_definition_list'),
    url(r'^open311/services/(?P<service_type>[-\w]+).json$', 'service_definition_detail', name='api_service_definition_detail'),
    url(r'^open311/requests.json/$', 'service_request_list', name='api_service_request_list'),
    url(r'^open311/requests/(?P<service_code>[-\w]+)-(?P<request_id>[-\w]+).json$', 'service_request_detail', name='api_service_request_detail'),
)

########NEW FILE########
__FILENAME__ = views
import operator

from django.http import Http404
from django.utils.translation import ugettext_lazy as _
from django.utils.text import slugify
from django.db.models import Q
from django.shortcuts import get_object_or_404
from django.contrib.gis.geos import *
from django.core.exceptions import ImproperlyConfigured
from django.conf import settings

from rest_framework import generics, permissions, authentication, status
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.decorators import api_view

from nodeshot.core.nodes.models import Node, Status, Image
from nodeshot.core.layers.models import Layer
from nodeshot.community.participation.models import Comment, Rating

from .base import STATUS, SERVICES, DISCOVERY, MODELS, iso8601_REGEXP
from .serializers import *


@api_view(['GET'])
def service_discovery(request):
    """
    Open 311 services' discovery.
    """
    return Response(DISCOVERY)


class ServiceDefinitionList(generics.ListAPIView):
    """
    Retrieve list of Open 311 services.
    """
    authentication_classes = (authentication.SessionAuthentication,)
    serializer_class = ServiceListSerializer
    
    def get(self, request, *args, **kwargs):
        """ return list of open 311 services  """
        # init django rest framework specific stuff
        serializer_class = self.get_serializer_class()
        context = self.get_serializer_context()
        
        # init empty list
        services = []
        
        # loop over each service
        for service_type in SERVICES.keys():
            # initialize serializers for layer
            services.append(
                serializer_class(
                    object(),
                    context=context,
                    service_type=service_type
                ).data
            )
        
        return Response(services)

service_definition_list = ServiceDefinitionList.as_view()


class ServiceDefinitionDetail(APIView):
    """
    Retrieve details of specified service.
    """

    def get(self, request, *args, **kwargs):
        service_type = kwargs['service_type']
        
        if service_type not in SERVICES.keys():
            return Response({ 'detail': _('Not found') }, status=404)
        
        serializers = {
            'node': ServiceNodeSerializer,
            'vote': ServiceVoteSerializer,
            'comment': ServiceCommentSerializer,
            'rate': ServiceRatingSerializer,
        }
        
        # init right serializer
        data = serializers[service_type](object()).data
        
        return Response(data)
    
service_definition_detail = ServiceDefinitionDetail.as_view()


def create_output_data(data):
    # convert received geometry to Point
    geom = fromstr(data['geometry']).centroid
    del data['geometry']
    data['long'] = geom[0]
    data['lat'] = geom[1]
    
    # get status from model and converts it into the mapped status type (open/closed)
    status_id = data['status']
    status = get_object_or_404(Status, pk=status_id)
    data['detailed_status'] = status.name
    data['detailed_status_description'] = status.description
    try:
        data['status'] = STATUS[status.slug]
    except KeyError:
        if settings.DEBUG:
            raise ImproperlyConfigured("NODESHOT['OPEN311']['STATUS'] settings bad configuration: key %s not found"
                                       % status.slug)
        else:
            data['status'] = 'closed'
    
    return data


class ServiceRequestList(generics.ListCreateAPIView):
    """
    ### GET
    ###Retrieve list of service requests.
    
    Required parameters:
    
     * `service_code=<string>`: possible values are: 'node', 'vote', 'rate' , 'comment'
     
    ####Note:    List is displayed only for 'node' service requests
     
    Optional  parameters ( relevant only if service_code = node ):
    
     * `status=<string>`: possible values are: 'open' or 'closed'
     * `start_date=<date>`: date in w3 format, eg 2010-01-01T00:00:00Z
     * `end_date=<date>`: date in w3 format, eg 2010-01-01T00:00:00Z
     * `layer=<layer>`: layer to which node belongs
     
    ### POST
    ### Create a new service request. Requires authentication.
    See service definition for required parameters
    """
    authentication_classes = (authentication.SessionAuthentication,)
    permission_classes = (permissions.IsAuthenticatedOrReadOnly,)
    serializer_class= NodeRequestListSerializer
    model = Node
    
    def get_serializer(self, instance=None, data=None,
                       files=None, many=False, partial=False):
        """
        Return the serializer instance that should be used for validating and
        deserializing input, and for serializing output.
        """
        serializers = {
            'node': NodeRequestListSerializer,
            'vote': VoteRequestListSerializer,
            'comment': CommentRequestListSerializer,
            'rate': RatingRequestListSerializer,
        }
        context = self.get_serializer_context()
        service_code = context['request'].QUERY_PARAMS.get('service_code', 'node')
       
        if service_code not in serializers.keys():
            serializer_class = self.get_serializer_class()
        else:
            serializer_class = serializers[service_code]
        
        return serializer_class(instance, data=data, files=files,
                                many=many, partial=partial, context=context)
    
    def get_custom_data(self):
        """ additional request.DATA """
        
        return {
            'user': self.request.user.id
        }
    
    def get(self, request, *args, **kwargs):
        """ Retrieve list of service requests """
        if 'service_code' not in request.GET.keys():
            return Response({ 'detail': _('A service code must be inserted') }, status=404)
        
        service_code = request.GET['service_code']
        
        if service_code not in SERVICES.keys():
            return Response({ 'detail': _('Service not found') }, status=404)
        
        start_date = None
        end_date = None
        status = None
        layer = None
        
        STATUSES = {}
        for status_type in ('open','closed'):
            STATUSES[status_type] = [k for k, v in STATUS.items() if v == status_type]
        
        if 'start_date' in request.GET.keys():
            start_date = request.GET['start_date']
            if iso8601_REGEXP.match(start_date) is None:
                return Response({ 'detail': _('Invalid date inserted') }, status=404)
            
        if 'end_date' in request.GET.keys():
            end_date = request.GET['end_date']
            if iso8601_REGEXP.match(end_date) is None:
                return Response({ 'detail': _('Invalid date inserted') }, status=404)
            
        if 'status' in request.GET.keys():
            if request.GET['status'] not in ('open','closed'):
                return Response({ 'detail': _('Invalid status inserted') }, status=404)
            status = request.GET['status']
            
        if 'layer' in request.GET.keys():
            layer = request.GET['layer']
            node_layer = get_object_or_404(Layer, slug=layer)

        service_model = MODELS[service_code]
        if service_code in ('vote', 'comment', 'rate'):
            self.queryset = service_model.objects.none()
        else: 
            self.queryset = service_model.objects.all()
        
            # Filter by layer
            if layer is not None:
                self.queryset = self.queryset.filter(layer = node_layer)
                
            # Check of date parameters
            if start_date is not None and end_date is not None:
                self.queryset = self.queryset.filter(added__gte = start_date).filter(added__lte = end_date)
            
            if start_date is not None and end_date is None:
                self.queryset = self.queryset.filter(added__gte = start_date)
            
            if start_date is None and end_date is not None:
                self.queryset = self.queryset.filter(added__lte = end_date)
            
        # Check of status parameter
        if status is not None:
            q_list = [Q(status__slug__exact = s) for s in STATUSES[status]]
            self.queryset = self.queryset.filter(reduce(operator.or_, q_list))            
            
        # init right serializer
        kwargs['service_code'] = service_code
        
        return self.list(request, *args, **kwargs)
    
    def list(self, request, *args, **kwargs):
        self.object_list = self.filter_queryset(self.get_queryset())
        service_code = kwargs['service_code']
        
        # Default is to allow empty querysets.  This can be altered by setting
        # `.allow_empty = False`, to raise 404 errors on empty querysets.
        if not self.allow_empty and not self.object_list:
            warnings.warn(
                'The `allow_empty` parameter is due to be deprecated. '
                'To use `allow_empty=False` style behavior, You should override '
                '`get_queryset()` and explicitly raise a 404 on empty querysets.',
                PendingDeprecationWarning
            )
            class_name = self.__class__.__name__
            error_msg = self.empty_error % {'class_name': class_name}
            raise Http404(error_msg)

        # Switch between paginated or standard style responses
        page = self.paginate_queryset(self.object_list)
        
        if page is not None:
            serializer = self.get_pagination_serializer(page)
        else:
            serializer = self.get_serializer(self.object_list, many=True)
        
        data = serializer.data
            
        if service_code == 'node':
            for item in data:
                item = create_output_data(item)
        else:
            pass
        
        return Response(data)
    
    def post(self, request, *args, **kwargs):
        """ Post a service request ( requires authentication) """

        service_code = request.POST['service_code']
        
        if service_code not in SERVICES.keys():
            return Response({ 'detail': _('Service not found') }, status=404)
        
        serializers = {
            'node': NodeRequestSerializer,
            'vote': VoteRequestSerializer,
            'comment': CommentRequestSerializer,
            'rate': RatingRequestSerializer,
        }
        
        # init right serializer
        kwargs['service_code'] = service_code
        kwargs['serializer'] = serializers[service_code]
        
        user=self.get_custom_data()
        request.UPDATED = request.POST.copy()
        request.UPDATED['user'] = user['user']
        if service_code == 'node':
            for checkPOSTdata in ('layer','name','lat','long'):
                # Check if mandatory parameters key exists
                if checkPOSTdata not in request.POST.keys():
                    return Response({ 'detail': _('Mandatory parameter not found') }, status=400)
                else:
                    # Check if mandatory parameters values have been inserted
                    if not request.POST[checkPOSTdata] :
                        return Response({ 'detail': _('Mandatory parameter not found') }, status=400)
            # Get layer id
            layer = Layer.objects.get(slug=request.UPDATED['layer'])           
            request.UPDATED['layer'] = layer.id
            
            # Transform coords in wkt geometry
            lat = float(request.UPDATED['lat'])
            long = float(request.UPDATED['long'])
            point = Point((long,lat))
            request.UPDATED['geometry'] = point.wkt
            request.UPDATED['slug'] = slugify(request.UPDATED['name'])

        return self.create(request, *args, **kwargs)
   
    def create(self, request, *args, **kwargs):
        
        serializer = kwargs['serializer']( data=request.UPDATED, files=request.FILES)
        service_code= kwargs['service_code']
        if serializer.is_valid():
            self.pre_save(serializer.object)
            self.object = serializer.save(force_insert=True)
            self.post_save(self.object, created=True,
                           files=request.FILES,
                           service_code=service_code
                           )
            headers = self.get_success_headers(serializer.data)
            response_311 = service_code + '-' + str(self.object.id)
            return Response(response_311, status=status.HTTP_201_CREATED,
                            headers=headers)

        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    def post_save(self,obj, created, files, service_code):
        if service_code == 'node' and files:
            for file,image_file in files.iteritems():
                image=Image(node=obj, file=image_file)
                image.save()
        
service_request_list = ServiceRequestList.as_view()


class ServiceRequestDetail(generics.RetrieveAPIView):
    """ Retrieve the details of a service request """

    serializer_class= NodeRequestDetailSerializer
    
    def get(self, request, *args, **kwargs):
        context = self.get_serializer_context()
        service_code = kwargs['service_code']
        request_id = kwargs['request_id']
        
        if service_code not in SERVICES.keys():
            return Response({ 'detail': _('Service not found') }, status=404)
        
        serializers = {
            'node': NodeRequestDetailSerializer,
            'vote': VoteRequestSerializer,
            'comment': CommentRequestSerializer,
            'rate': RatingRequestSerializer,
        }
        
        service_model = MODELS[service_code]
        request_object = get_object_or_404(service_model, pk=request_id)
        data = serializers[service_code](request_object, context=context).data
        
        if service_code == 'node':
            data = create_output_data(data)
        else:
            data['status'] = 'Closed'                       
        
        data['service_code'] = service_code
        data['service_name'] = SERVICES[service_code]['name']
        
        return Response(data)

service_request_detail = ServiceRequestDetail.as_view()

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = tests
"""
This file demonstrates writing tests using the unittest module. These will pass
when you run "manage.py test".

Replace this with more appropriate tests for your application.
"""

from django.test import TestCase


class SimpleTest(TestCase):
    def test_basic_addition(self):
        """
        Tests that 1 + 1 always equals 2.
        """
        self.assertEqual(1 + 1, 2)

########NEW FILE########
__FILENAME__ = views
# Create your views here.

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
import simplejson as json
from django.core.urlresolvers import reverse
from nodeshot.core.base.tests import BaseTestCase, user_fixtures


class DefaultUiTest(BaseTestCase):
    
    fixtures = [
        'initial_data.json',
        user_fixtures,
        'test_layers.json',
        'test_status.json',
        'test_nodes.json',
        'test_images.json'
    ]

    def test_index(self):
        response = self.client.get(reverse('ui:index'))
        self.assertEqual(response.status_code, 200)
    
########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.ui.default.views',
    url(r'^$', 'index', name='index'),
)
########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.shortcuts import render

from nodeshot.core.nodes.models import Node, Status
from nodeshot.core.layers.models import Layer


if 'nodeshot.core.websockets' in settings.INSTALLED_APPS:
    from nodeshot.core.websockets import DOMAIN, PATH, PORT
    
    WEBSOCKETS = {
        'DOMAIN': DOMAIN,
        'PATH': PATH,
        'PORT': PORT
    }
else:
    WEBSOCKETS = False


# TODO
# improve spaghetti code
def index(request):
    layers = Layer.objects.published()
    
    context = {
        'layers': layers,
        'WEBSOCKETS': WEBSOCKETS,
        'TILESERVER_URL': settings.NODESHOT['SETTINGS'].get('TILESERVER_URL', '//a.tiles.mapbox.com/v3/nodeshot-cineca.i6kgg4hb/{z}/{x}/{y}.png')
    }
    return render(request, 'index.html', context)

########NEW FILE########
__FILENAME__ = models
from django.db import models

# Create your models here.

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, url


urlpatterns = patterns('nodeshot.ui.open311_demo.views',
    url(r'^$', 'open311', name='open311'),
)
########NEW FILE########
__FILENAME__ = views
from django.conf import settings
from django.shortcuts import render

def open311(request):
    context = {
        'TILESERVER_URL': settings.NODESHOT['SETTINGS'].get('TILESERVER_URL', '//a.tiles.mapbox.com/v3/nodeshot-cineca.i6kgg4hb/{z}/{x}/{y}.png')
    }
    return render(request,'open311/index.html', context)



########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.conf import settings
from django.contrib import admin

from filebrowser.sites import site

admin.autodiscover()


urlpatterns = patterns('',
   url(r'^admin/filebrowser/', include(site.urls)),
)


if 'social_auth' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'', include('social_auth.urls')),
    )


if 'grappelli' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^grappelli/', include('grappelli.urls')),
    )


if 'nodeshot.core.websockets' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'^websockets/', include('nodeshot.core.websockets.urls')),
    )


if 'nodeshot.community.profiles' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r"^account/password/reset/(?P<uidb36>[0-9A-Za-z]+)-(?P<key>.+)/$",
            "nodeshot.community.profiles.html_views.password_reset_from_key",
            name="account_password_reset_key"),
    )


if 'nodeshot.community.profiles' in settings.INSTALLED_APPS and settings.NODESHOT['SETTINGS'].get('PROFILE_EMAIL_CONFIRMATION', True):
    urlpatterns = urlpatterns + patterns('',
        url(r'^confirm_email/(\w+)/$', 'nodeshot.community.profiles.html_views.confirm_email', name='emailconfirmation_confirm_email'),
    )


# include 'nodeshot.core.api.urls'
if 'nodeshot.core.api' in settings.INSTALLED_APPS:
    
    urlpatterns = urlpatterns + patterns('',
        url(r'', include('nodeshot.core.api.urls')),
    )


if 'nodeshot.ui.open311_demo' in settings.INSTALLED_APPS:
    urlpatterns += patterns('',
        url(r'^open311/$', include('nodeshot.ui.open311_demo.urls', namespace='open311_demo', app_name='open311_demo')),
    )


if 'nodeshot.ui.default' in settings.INSTALLED_APPS:
    urlpatterns = urlpatterns + patterns('',
        url(r'', include('nodeshot.ui.default.urls', namespace='ui', app_name='ui')),
    )

    
if 'rosetta' in settings.INSTALLED_APPS:
    urlpatterns += patterns('',
        url(r'^rosetta/', include('rosetta.urls')),
    )
########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ninux.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = local_settings_example
# Django local settings for nodeshot project.

APP_PATH = '/home/stefano/django/nodeshot/'
DEBUG = True
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'nodeshot',                      # Or path to database file if using sqlite3.
        'USER': 'postgres',                      # Not used with sqlite3.
        'PASSWORD': 'postgres',                  # Not used with sqlite3.
        'HOST': '127.0.0.1',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}
DOMAIN = 'localhost'
ALLOWED_HOSTS = ['*'] 
SECRET_KEY = 'da)t*+$)ugeyip6-#tuyy$5wf2ervc0d2n#h)qb)y5@ly$t*@w'


########NEW FILE########
__FILENAME__ = production_settings.example
# Django settings for nodeshot project.

import os
import sys

from local_settings import *

sys.path.append(APP_PATH)

SERVE_STATIC = DEBUG
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS


# uncomment if you need to use nodeshot.extra.oldimporter
#if 'test' not in sys.argv:
#    DATABASES['old_nodeshot'] = {
#       'ENGINE': 'django.db.backends.mysql',  # might be also postgresql or sqlite
#       'NAME': 'nodeshot',
#       'USER': 'nodeshot-readonly',
#       'PASSWORD': '*********',
#       'HOST': 'remote-ip',
#       'PORT': 'remote-port',
#    }
#    DATABASE_ROUTERS = [
#        'nodeshot.extra.oldimporter.db.DefaultRouter',
#        'nodeshot.extra.oldimporter.db.OldNodeshotRouter'
#    ]


# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'Europe/Rome'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-gb'

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

SITE_ID = 1
PROTOCOL = 'http' if DEBUG else 'https'
PORT = '8000' if DEBUG else None
SITE_URL = '%s://%s' % (PROTOCOL, DOMAIN)

if PORT and PORT not in ['80', '443']:
    SITE_URL = '%s:%s' % (SITE_URL, PORT)

SITE_ROOT = os.path.dirname(os.path.realpath(__file__))

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = '%s/media/' % SITE_ROOT

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '%s/media/' % SITE_URL

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = '%s/static/' % SITE_ROOT

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '%s/static/' % SITE_URL

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

if PROTOCOL == 'https':
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    os.environ['HTTPS'] = 'on'

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'ninux.urls' # replace myproject with the name of your project. Default project is "ninux".

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'ninux.wsgi.application'


TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.request",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages"
)

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',

    # PostgreSQL HStore extension support
    'django_hstore',

    # admin site
    'grappelli.dashboard',
    'grappelli',
    'filebrowser',
    'django.contrib.admin',

    # --- background jobs --- #
    'djcelery_email',  # Celery Django Email Backend

    # nodeshot
    'nodeshot.core.api',
    'nodeshot.core.layers',
    'nodeshot.core.nodes',
    'nodeshot.core.cms',
    'nodeshot.core.websockets',
    'nodeshot.interoperability',
    'nodeshot.community.participation',
    'nodeshot.community.notifications',
    'nodeshot.community.profiles',
    'nodeshot.community.mailing',
    #'nodeshot.networking.net',
    #'nodeshot.networking.links',
    #'nodeshot.networking.services',
    #'nodeshot.networking.hardware',
    #'nodeshot.networking.connectors',
    'nodeshot.ui.default',
    'nodeshot.open311',
    'nodeshot.ui.open311_demo',

    # import data from old nodeshot version 0.9
    # needs python MySQL database driver
    # run "pip install MySQL-python"
    # you might need to run also a similar command according to your own OS distribution:
    # sudo apt-get install libmysqlclient-dev
    #'nodeshot.extra.oldimporter',

    # 3d parthy django apps
    'rest_framework',
    'rest_framework_swagger',
    'olwidget',  # geodjango better widgets
    'south',
    # 'debug_toolbar',
    'smuggler',
    'reversion',
    
    # django-cors-headers
    'corsheaders',

    # profiles and social networks
    'emailconfirmation',
    'social_auth',

    # other utilities
    # 'django_extensions',

    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
]

if 'nodeshot.community.profiles' in INSTALLED_APPS:
    AUTH_USER_MODEL = 'profiles.Profile'

# ------ DJANGO LOGGING ------ #

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'logfile': {
            'level': 'ERROR',
            'class':'logging.handlers.RotatingFileHandler',
            'formatter': 'verbose',
            'filename': SITE_ROOT + "/../log/ninux.error.log",
            'maxBytes': 10485760,  # 10 MB
            'backupCount': 3,
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'django': {
            'handlers':['logfile'],
            'level':'ERROR',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins', 'logfile'],
            'level': 'ERROR',
            'propagate': True,
        },
        '': {
            'handlers': ['logfile'],
            'level': 'ERROR',
        },
    },
    'formatters': {
        'verbose': {
            'format': '\n\n[%(levelname)s %(asctime)s] module: %(module)s, process: %(process)d, thread: %(thread)d\n%(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
        'custom': {
            'format': '%(levelname)s %(asctime)s\n%(message)s'
        },
    },
}

# ------ DJANGO CACHE ------ #

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'TIMEOUT': 172800 if not DEBUG else 300,
        'OPTIONS': {
            'MAX_ENTRIES': 1000
        }
    }
}

# ------ EMAIL SETTINGS ------ #

# if you want a dummy SMTP server that logs outgoing emails but doesn't actually send them
# you have 2 options:
#     * python -m -smtpd -n -c DebuggingServer localhost:1025
#     * python manage.py mail_debug  (django-extensions must be installed)

#EMAIL_USE_TLS = True
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = 'your@email.org'
#EMAIL_HOST_PASSWORD = '***********'
EMAIL_PORT = 1025 if DEBUG else 25  # 1025 if you are in development mode, while 25 is usually the production port
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
SERVER_EMAIL = DEFAULT_FROM_EMAIL  # used for error reporting

# ------ CELERY ------ #

if DEBUG:
    # this app makes it possible to use django as a queue system for celery
    # so you don't need to install RabbitQM or Redis
    # pretty cool for development, but might not suffice for production if your system is heavily used
    # our suggestion is to switch only if you start experiencing issues
    INSTALLED_APPS.append('kombu.transport.django')
    BROKER_URL = 'django://'
    # synchronous behaviour for development
    # more info here: http://docs.celeryproject.org/en/latest/configuration.html#celery-always-eager
    CELERY_ALWAYS_EAGER = True
    CELERY_EAGER_PROPAGATES_EXCEPTIONS = True
else:
    # in production the default background queue manager is Redis
    BROKER_URL = 'redis://localhost:6379/0'
    CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
    BROKER_TRANSPORT_OPTIONS = {
        "visibility_timeout": 3600,  # 1 hour
        "fanout_prefix": True
    }
    # in production emails are sent in the background
    EMAIL_BACKEND = 'djcelery_email.backends.CeleryEmailBackend'

#from datetime import timedelta
#
#CELERYBEAT_SCHEDULE = {
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#    },
#    # example of how to synchronize one of the layers with a different periodicity
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(minutes=30),
#        'args': ('layer_slug',)
#    },
#    # example of how to synchronize all layers except two layers
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#        'kwargs': { 'exclude': 'layer1-slug,layer2-slug' }
#    },
#    'purge_notifications': {
#        'task': 'nodeshot.community.notifications.tasks.purge_notifications',
#        'schedule': timedelta(days=1),
#    }
#}

# ------ NODESHOT ------ #

# https://docs.djangoproject.com/en/dev/topics/i18n/translation/
# look for (ctrl + f) 'lambda' and you'll find why the following is needed
_ = lambda s: s

NODESHOT = {
    'SETTINGS': {
        # api prefix examples:
        #   * api/
        #   * api/v1/
        # leave blank to include api urls at root level, such as /nodes/, /layers/ and so on
        'API_PREFIX': 'api/v1/',
        'ACL_GLOBAL_EDITABLE': True,

        # the following is an example of possible granular ACL setting that can be specified
        #'ACL_NODES_NODE_EDITABLE': False,

        'LAYER_TEXT_HTML': True,
        'NODE_DESCRIPTION_HTML': True,

        'CONTACT_INWARD_LOG': True,
        'CONTACT_INWARD_MAXLENGTH': 2000,
        'CONTACT_INWARD_MINLENGTH': 15,
        'CONTACT_INWARD_REQUIRE_AUTH': False,
        'CONTACT_OUTWARD_MAXLENGTH': 9999,
        'CONTACT_OUTWARD_MINLENGTH': 50,
        'CONTACT_OUTWARD_STEP': 20,
        'CONTACT_OUTWARD_DELAY': 10,
        'CONTACT_OUTWARD_HTML': True,  # grappelli must be in INSTALLED_APPS, otherwise it won't work

        'PROFILE_EMAIL_CONFIRMATION': True,
        'PROFILE_REQUIRED_FIELDS': ['email'],

        'ADMIN_MAP_COORDS': [41.8934, 12.4960],  # lat, lng
        'ADMIN_MAP_ZOOM': 1,  # default zoom in the admin

        'REVERSION_LAYERS': True,  # activate django reversion for layers.Layer model
        'REVERSION_NODES': True,  # activate django reversion for nodes.Node model
    },
    'CHOICES': {
        'AVAILABLE_CRONJOBS': (
            ('00', _('midnight')),
            ('04', _('04:00 AM')),
        ),
        'ACCESS_LEVELS': {
            'registered': 1,
            'community': 2,
            'trusted': 3
        },
        'APPLICATION_PROTOCOLS': (
            ('http', 'http'),
            ('https', 'https'),
            ('ftp', 'FTP'),
            ('smb', 'Samba'),
            ('afp', 'Apple File Protocol'),
            ('git', 'Git'),
        )
    },
    # default values for the application or new database objects
    'DEFAULTS': {
        'NODE_PUBLISHED': True,
        'LAYER_ZOOM': 12,
        'LAYER_MINIMUM_DISTANCE': 0,
        'MAILING_SCHEDULE_OUTWARD': False,
        'ACL_GLOBAL': 'public',
        # default access_level value for app: services, model: Login
        'ACL_SERVICES_LOGIN': 'community',
        'NOTIFICATION_BOOLEAN_FIELDS': True,
        'NOTIFICATION_DISTANCE_FIELDS': 30
    },
    'API': {
        'APPS_ENABLED': [
            'nodeshot.core.nodes',
            'nodeshot.core.layers',
            'nodeshot.core.cms',
            'nodeshot.community.profiles',
            'nodeshot.community.participation',
            'nodeshot.community.notifications',
            'nodeshot.community.mailing',
            'nodeshot.networking.net',
            'nodeshot.networking.links',
            'nodeshot.networking.services',
            'nodeshot.open311'
        ]
    },
    'INTEROPERABILITY': [
        ('nodeshot.interoperability.synchronizers.Nodeshot', 'Nodeshot'),
        ('nodeshot.interoperability.synchronizers.GeoJson', 'GeoJSON'),
        ('nodeshot.interoperability.synchronizers.GeoRss', 'GeoRSS'),
        ('nodeshot.interoperability.synchronizers.OpenWISP', 'OpenWISP'),
        ('nodeshot.interoperability.synchronizers.OpenWISPCitySDK', 'OpenWISPCitySDK'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFI', 'Provincia WiFi'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFICitySDK', 'ProvinciaWIFICitySDK'),
    ],
    'NOTIFICATIONS': {
        'TEXTS': {
            'custom': None,
            'node_created': _('A new node with name "%(name)s" has been created.'),
            'node_status_changed': _('Status of node "%(name)s" has changed from "%(old_status)s" to "%(new_status)s".'),
            'your_node_status_changed': _('Status of your node "%(name)s" changed from "%(old_status)s" to "%(new_status)s".'),
            'node_deleted': _('Node "%(name)s" with ID #%(id)s was deleted.'),
        },
        # boolean: users can only turn on or off
        # distance: users can turn off (-1), turn on for all (0) or set a range of km (n)
        'USER_SETTING': {
            'node_created':             { 'type': 'distance', 'geo_field': 'geometry' },
            'node_status_changed':      { 'type': 'distance', 'geo_field': 'geometry' },
            'node_deleted':             { 'type': 'distance', 'geo_field': 'geometry' },
            'your_node_status_changed': { 'type': 'boolean' },
        },
        'ACTIONS': {
            'node_created': "reverse('api_node_details', args=[self.related_object.slug])",
            'node_status_changed': "reverse('api_node_details', args=[self.related_object.slug])",
            'your_node_status_changed': "reverse('api_node_details', args=[self.related_object.slug])",
        },
        'DELETE_OLD': 40,  # delete notifications older than specified days
        'REGISTRARS': (
            'nodeshot.community.notifications.registrars.nodes',
        )
    },
    'WEBSOCKETS': {
        'PUBLIC_PIPE': '%s/nodeshot.websockets.public' % os.path.dirname(SITE_ROOT),
        'PRIVATE_PIPE': '%s/nodeshot.websockets.private' % os.path.dirname(SITE_ROOT),
        'DOMAIN': DOMAIN,
        'LISTENING_ADDRESS': '0.0.0.0',  # set to 127.0.0.1 to accept only local calls (used for proxying to port 80 with nginx or apache mod_proxy)
        'LISTENING_PORT': 9090,
        'REGISTRARS': (
            'nodeshot.core.websockets.registrars.nodes',
        )
    },
    # list that will contain functions to disable and re-enable some signals
    # for large import of data notifications, websockets, participation counts and similar operations
    # might be temporarily disabled to avoid unnecessary database load
    'DISCONNECTABLE_SIGNALS': [],
    # settings for old nodeshot importer
    'OLD_IMPORTER':{
        'DEFAULT_LAYER': 30,
        'STATUS_MAPPING': {
            'a': 'active',
            'h': 'active',
            'ah': 'active',
            'p': 'potential',
            'default': 'potential'
        }
    },
    'NETENGINE_BACKENDS': [
        ('netengine.backends.ssh.AirOS', 'AirOS (SSH)'),
        ('netengine.backends.ssh.OpenWRT', 'OpenWRT (SSH)'),
        ('netengine.backends.snmp.AirOS', 'AirOS (SNMP)'),
    ],
    'OPEN311': {
        # Metadata for service discovery
        'DISCOVERY': {
            'changeset':'2014-02-03 14:18',
            'contact':'email or phone number for assistance',
            'key_service':'URL for api_key requests',
            'endpoints':[
                {
                    'specification':'http://wiki.open311.org/GeoReport_v2',
                    'url':'Public URL of your endpoint',
                    'changeset':'2014-02-03 09:01',
                    'type':'production',
                    'formats':[
                        'application/json'
                    ]
                },

            ]
        },
        # Do not change this unless you want to redefine Open311 service definitions
        'METADATA': 'true',
        'TYPE': 'realtime',
        # Change the following, according to the statuses you have configured in your model
        'STATUS' : {
            'potential': 'open',
            'planned': 'open',
            'active': 'closed',
        }
    }
}

NODESHOT['DEFAULTS']['CRONJOB'] = NODESHOT['CHOICES']['AVAILABLE_CRONJOBS'][0][0]

if 'test' in sys.argv:
    NODESHOT['NETENGINE_BACKENDS'].append(
        ('netengine.backends.Dummy', 'Dummy')
    )

# ------ GRAPPELLI ------ #

if 'grappelli' in INSTALLED_APPS:
    GRAPPELLI_ADMIN_TITLE = 'Nodeshot Admin'
    GRAPPELLI_INDEX_DASHBOARD = 'nodeshot.dashboard.NodeshotDashboard'

# ------ DEBUG TOOLBAR ------ #

INTERNAL_IPS = ('127.0.0.1', '::1',)  # ip addresses where you want to show the debug toolbar here
DEBUG_TOOLBAR_CONFIG = {
    'INTERCEPT_REDIRECTS': False,
}

# ------ UNIT TESTING SPEED UP ------ #

SOUTH_DATABASE_ADAPTERS = {'default': 'south.db.postgresql_psycopg2'}
SOUTH_TESTS_MIGRATE = False

if 'test' in sys.argv:
    CELERY_ALWAYS_EAGER = True

    PASSWORD_HASHERS = (
        'django.contrib.auth.hashers.MD5PasswordHasher',
        'django.contrib.auth.hashers.SHA1PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
        'django.contrib.auth.hashers.BCryptPasswordHasher',
    )

# ------ SOCIAL AUTH SETTINGS ------ #

if 'social_auth' in INSTALLED_APPS:
    MIDDLEWARE_CLASSES += ('social_auth.middleware.SocialAuthExceptionMiddleware',)

    # In Django 1.6, the default session serliazer has been switched to one based on JSON,
    # rather than pickles, to improve security. Django-openid-auth does not support this
    # because it attemps to store content that is not JSON serializable in sessions.
    # See https://docs.djangoproject.com/en/dev/releases/1.6/#default-session-serialization-switched-to-json
    # for details on the Django 1.6 change.
    SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'

    AUTHENTICATION_BACKENDS = (
        'django.contrib.auth.backends.ModelBackend',
        'nodeshot.community.profiles.backends.EmailBackend',
        'social_auth.backends.facebook.FacebookBackend',
        'social_auth.backends.google.GoogleBackend',
        'social_auth.backends.contrib.github.GithubBackend',
    )

    SOCIAL_AUTH_PIPELINE = (
        'social_auth.backends.pipeline.social.social_auth_user',
        #'social_auth.backends.pipeline.associate.associate_by_email',
        'social_auth.backends.pipeline.user.get_username',
        'social_auth.backends.pipeline.user.create_user',
        'social_auth.backends.pipeline.social.associate_user',
        'nodeshot.community.profiles.social_auth_extra.pipeline.load_extra_data',
        'social_auth.backends.pipeline.user.update_user_details'
    )

    SOCIAL_AUTH_ENABLED_BACKENDS = ('facebook', 'google', 'github')

    # register a new app:
    FACEBOOK_APP_ID = ''  # put your app id
    FACEBOOK_API_SECRET = ''
    FACEBOOK_EXTENDED_PERMISSIONS = ['email', 'user_about_me', 'user_birthday', 'user_hometown']

    # register a new app:
    GITHUB_APP_ID = ''
    GITHUB_API_SECRET = ''
    GITHUB_EXTENDED_PERMISSIONS = ['user:email']

    SOCIAL_AUTH_DEFAULT_USERNAME = 'new_social_auth_user'
    SOCIAL_AUTH_UUID_LENGTH = 3
    SOCIAL_AUTH_SESSION_EXPIRATION = False
    SOCIAL_AUTH_ASSOCIATE_BY_MAIL = True

    LOGIN_URL = '/'
    LOGIN_REDIRECT_URL = '/'
    LOGIN_ERROR_URL    = '/'

# ------ CORS-HEADERS SETTINGS ------ #

CORS_ORIGIN_ALLOW_ALL = True

########NEW FILE########
__FILENAME__ = settings.example
# Django settings for nodeshot project.

import os
import sys

sys.path.append('/var/www/nodeshot/')

DEBUG = True
SERVE_STATIC = DEBUG
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis', # Add 'postgresql_psycopg2', 'mysql', 'sqlite3' or 'oracle'.
        'NAME': 'nodeshot',                      # Or path to database file if using sqlite3.
        'USER': 'nodeshot',                      # Not used with sqlite3.
        'PASSWORD': 'your_password',                  # Not used with sqlite3.
        'HOST': '127.0.0.1',                      # Set to empty string for localhost. Not used with sqlite3.
        'PORT': '',                      # Set to empty string for default. Not used with sqlite3.
    }
}

# uncomment if you need to use nodeshot.extra.oldimporter
#if 'test' not in sys.argv:
#    DATABASES['old_nodeshot'] = {
#       'ENGINE': 'django.db.backends.mysql',  # might be also postgresql or sqlite
#       'NAME': 'nodeshot',
#       'USER': 'nodeshot-readonly',
#       'PASSWORD': '*********',
#       'HOST': 'remote-ip',
#       'PORT': 'remote-port',
#    }
#    DATABASE_ROUTERS = [
#        'nodeshot.extra.oldimporter.db.DefaultRouter',
#        'nodeshot.extra.oldimporter.db.OldNodeshotRouter'
#    ]


# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'Europe/Rome'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-gb'

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

SITE_ID = 1
PROTOCOL = 'http' if DEBUG else 'https'
DOMAIN = 'localhost'
PORT = '8000' if DEBUG else None
SITE_URL = '%s://%s' % (PROTOCOL, DOMAIN)
ALLOWED_HOSTS = [DOMAIN]  # check https://docs.djangoproject.com/en/1.5/ref/settings/#allowed-hosts for more info

if PORT and PORT not in ['80', '443']:
    SITE_URL = '%s:%s' % (SITE_URL, PORT)

SITE_ROOT = os.path.dirname(os.path.realpath(__file__))

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = '%s/media/' % SITE_ROOT

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '%s/media/' % SITE_URL

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = '%s/static/' % SITE_ROOT

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '%s/static/' % SITE_URL

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

if PROTOCOL == 'https':
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    os.environ['HTTPS'] = 'on'

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# CHANGE THIS KEY AND UNCOMMENT
# Make this unique, and don't share it with anybody.
#SECRET_KEY = 'da)t*+$)ugeyip6-#tuyy$5wf2ervc0d2n#h)qb)y5@ly$t*@w'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'ninux.urls' # replace myproject with the name of your project. Default project is "ninux".

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'ninux.wsgi.application'


TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.request",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages"
)

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',

    # PostgreSQL HStore extension support
    'django_hstore',

    # admin site
    'grappelli.dashboard',
    'grappelli',
    'filebrowser',
    'django.contrib.admin',

    # --- background jobs --- #
    'djcelery_email',  # Celery Django Email Backend

    # nodeshot
    'nodeshot.core.api',
    'nodeshot.core.layers',
    'nodeshot.core.nodes',
    'nodeshot.core.cms',
    'nodeshot.core.websockets',
    'nodeshot.interoperability',
    'nodeshot.community.participation',
    'nodeshot.community.notifications',
    'nodeshot.community.profiles',
    'nodeshot.community.mailing',
    'nodeshot.networking.net',
    'nodeshot.networking.links',
    'nodeshot.networking.services',
    'nodeshot.networking.hardware',
    'nodeshot.networking.connectors',
    'nodeshot.ui.default',
    'nodeshot.open311',
    'nodeshot.ui.open311_demo',

    # import data from old nodeshot version 0.9
    # needs python MySQL database driver
    # run "pip install MySQL-python"
    # you might need to run also a similar command according to your own OS distribution:
    # sudo apt-get install libmysqlclient-dev
    #'nodeshot.extra.oldimporter',

    # 3d parthy django apps
    'rest_framework',
    'rest_framework_swagger',
    'olwidget',  # geodjango better widgets
    'south',
    'debug_toolbar',
    'smuggler',
    'reversion',

    # django-cors-headers
    'corsheaders',

    # profiles and social networks
    'emailconfirmation',
    'social_auth',

    # other utilities
    'django_extensions',

    # Uncomment the next line to enable admin documentation:
    # 'django.contrib.admindocs',
]

if 'nodeshot.community.profiles' in INSTALLED_APPS:
    AUTH_USER_MODEL = 'profiles.Profile'

# ------ DJANGO LOGGING ------ #

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'logfile': {
            'level': 'ERROR',
            'class':'logging.handlers.RotatingFileHandler',
            'formatter': 'verbose',
            'filename': SITE_ROOT + "/../log/ninux.error.log",
            'maxBytes': 10485760,  # 10 MB
            'backupCount': 3,
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'django': {
            'handlers':['logfile'],
            'level':'ERROR',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins', 'logfile'],
            'level': 'ERROR',
            'propagate': True,
        },
        '': {
            'handlers': ['logfile'],
            'level': 'ERROR',
        },
    },
    'formatters': {
        'verbose': {
            'format': '\n\n[%(levelname)s %(asctime)s] module: %(module)s, process: %(process)d, thread: %(thread)d\n%(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
        'custom': {
            'format': '%(levelname)s %(asctime)s\n%(message)s'
        },
    },
}

# ------ DJANGO CACHE ------ #

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'TIMEOUT': 172800 if not DEBUG else 300,
        'OPTIONS': {
            'MAX_ENTRIES': 1000
        }
    }
}

# ------ EMAIL SETTINGS ------ #

# if you want a dummy SMTP server that logs outgoing emails but doesn't actually send them
# you have 2 options:
#     * python -m -smtpd -n -c DebuggingServer localhost:1025
#     * python manage.py mail_debug  (django-extensions must be installed)

#EMAIL_USE_TLS = True
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = 'your@email.org'
#EMAIL_HOST_PASSWORD = '***********'
EMAIL_PORT = 1025 if DEBUG else 25  # 1025 if you are in development mode, while 25 is usually the production port
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
SERVER_EMAIL = DEFAULT_FROM_EMAIL  # used for error reporting

# ------ CELERY ------ #

if DEBUG:
    # this app makes it possible to use django as a queue system for celery
    # so you don't need to install RabbitQM or Redis
    # pretty cool for development, but might not suffice for production if your system is heavily used
    # our suggestion is to switch only if you start experiencing issues
    INSTALLED_APPS.append('kombu.transport.django')
    BROKER_URL = 'django://'
    # synchronous behaviour for development
    # more info here: http://docs.celeryproject.org/en/latest/configuration.html#celery-always-eager
    CELERY_ALWAYS_EAGER = True
    CELERY_EAGER_PROPAGATES_EXCEPTIONS = True
else:
    # in production the default background queue manager is Redis
    BROKER_URL = 'redis://localhost:6379/0'
    CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
    BROKER_TRANSPORT_OPTIONS = {
        "visibility_timeout": 3600,  # 1 hour
        "fanout_prefix": True
    }
    # in production emails are sent in the background
    EMAIL_BACKEND = 'djcelery_email.backends.CeleryEmailBackend'

#from datetime import timedelta
#
#CELERYBEAT_SCHEDULE = {
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#    },
#    # example of how to synchronize one of the layers with a different periodicity
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(minutes=30),
#        'args': ('layer_slug',)
#    },
#    # example of how to synchronize all layers except two layers
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#        'kwargs': { 'exclude': 'layer1-slug,layer2-slug' }
#    },
#    'purge_notifications': {
#        'task': 'nodeshot.community.notifications.tasks.purge_notifications',
#        'schedule': timedelta(days=1),
#    },
#    'import_old_nodeshot': {
#       'task': 'nodeshot.extra.oldimporter.tasks.import_old_nodeshot',
#       'schedule': timedelta(hours=12),
#       # pass --noinput and --nodelete options
#       'kwargs': { 'noinput': True, 'nodelete': True }
#    },
#}

# ------ NODESHOT ------ #

# https://docs.djangoproject.com/en/dev/topics/i18n/translation/
# look for (ctrl + f) 'lambda' and you'll find why the following is needed
_ = lambda s: s

NODESHOT = {
    'SETTINGS': {
        # api prefix examples:
        #   * api/
        #   * api/v1/
        # leave blank to include api urls at root level, such as /nodes/, /layers/ and so on
        'API_PREFIX': 'api/v1/',
        'ACL_GLOBAL_EDITABLE': True,

        # the following is an example of possible granular ACL setting that can be specified
        #'ACL_NODES_NODE_EDITABLE': False,

        'LAYER_TEXT_HTML': True,
        'NODE_DESCRIPTION_HTML': True,

        'CONTACT_INWARD_LOG': True,
        'CONTACT_INWARD_MAXLENGTH': 2000,
        'CONTACT_INWARD_MINLENGTH': 15,
        'CONTACT_INWARD_REQUIRE_AUTH': False,
        'CONTACT_OUTWARD_MAXLENGTH': 9999,
        'CONTACT_OUTWARD_MINLENGTH': 50,
        'CONTACT_OUTWARD_STEP': 20,
        'CONTACT_OUTWARD_DELAY': 10,
        'CONTACT_OUTWARD_HTML': True,  # grappelli must be in INSTALLED_APPS, otherwise it won't work

        'PROFILE_EMAIL_CONFIRMATION': True,
        'PROFILE_REQUIRED_FIELDS': ['email'],

        'ADMIN_MAP_COORDS': [41.8934, 12.4960],  # lat, lng
        'ADMIN_MAP_ZOOM': 1,  # default zoom in the admin

        'REVERSION_LAYERS': True,  # activate django reversion for layers.Layer model
        'REVERSION_NODES': True,  # activate django reversion for nodes.Node model
        
        # configure your tile server
        'TILESERVER_URL': '//a.tiles.mapbox.com/v3/nodeshot-cineca.i6kgg4hb/{z}/{x}/{y}.png'
    },
    'CHOICES': {
        'AVAILABLE_CRONJOBS': (
            ('00', _('midnight')),
            ('04', _('04:00 AM')),
        ),
        'ACCESS_LEVELS': {
            'registered': 1,
            'community': 2,
            'trusted': 3
        },
        'APPLICATION_PROTOCOLS': (
            ('http', 'http'),
            ('https', 'https'),
            ('ftp', 'FTP'),
            ('smb', 'Samba'),
            ('afp', 'Apple File Protocol'),
            ('git', 'Git'),
        )
    },
    # default values for the application or new database objects
    'DEFAULTS': {
        'NODE_PUBLISHED': True,
        'LAYER_ZOOM': 12,
        'LAYER_MINIMUM_DISTANCE': 0,
        'MAILING_SCHEDULE_OUTWARD': False,
        'ACL_GLOBAL': 'public',
        # default access_level value for app: services, model: Login
        'ACL_SERVICES_LOGIN': 'community',
        'NOTIFICATION_BOOLEAN_FIELDS': True,
        'NOTIFICATION_DISTANCE_FIELDS': 30
    },
    'API': {
        'APPS_ENABLED': [
            'nodeshot.core.nodes',
            'nodeshot.core.layers',
            'nodeshot.core.cms',
            'nodeshot.community.profiles',
            'nodeshot.community.participation',
            'nodeshot.community.notifications',
            'nodeshot.community.mailing',
            'nodeshot.networking.net',
            'nodeshot.networking.links',
            'nodeshot.networking.services',
            'nodeshot.open311'
        ]
    },
    'INTEROPERABILITY': [
        ('nodeshot.interoperability.synchronizers.Nodeshot', 'Nodeshot'),
        ('nodeshot.interoperability.synchronizers.GeoJson', 'GeoJSON'),
        ('nodeshot.interoperability.synchronizers.GeoRss', 'GeoRSS'),
        ('nodeshot.interoperability.synchronizers.OpenWISP', 'OpenWISP'),
        ('nodeshot.interoperability.synchronizers.OpenWISPCitySDK', 'OpenWISPCitySDK'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFI', 'Provincia WiFi'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFICitySDK', 'ProvinciaWIFICitySDK'),
    ],
    'NOTIFICATIONS': {
        'TEXTS': {
            'custom': None,
            'node_created': _('A new node with name "%(name)s" has been created.'),
            'node_status_changed': _('Status of node "%(name)s" has changed from "%(old_status)s" to "%(new_status)s".'),
            'node_own_status_changed': _('Status of your node "%(name)s" changed from "%(old_status)s" to "%(new_status)s".'),
            'node_deleted': _('Node "%(name)s" with ID #%(id)s was deleted.'),
        },
        # boolean: users can only turn on or off
        # distance: users can turn off (-1), turn on for all (0) or set a range of km (n)
        'USER_SETTING': {
            'node_created':             { 'type': 'distance', 'geo_field': 'geometry' },
            'node_status_changed':      { 'type': 'distance', 'geo_field': 'geometry' },
            'node_deleted':             { 'type': 'distance', 'geo_field': 'geometry' },
            'node_own_status_changed': { 'type': 'boolean' },
        },
        'DELETE_OLD': 40,  # delete notifications older than specified days
        'REGISTRARS': (
            'nodeshot.community.notifications.registrars.nodes',
        )
    },
    'WEBSOCKETS': {
        'PUBLIC_PIPE': '%s/nodeshot.websockets.public' % os.path.dirname(SITE_ROOT),
        'PRIVATE_PIPE': '%s/nodeshot.websockets.private' % os.path.dirname(SITE_ROOT),
        'DOMAIN': DOMAIN,
        'PATH': '',
        'LISTENING_ADDRESS': '0.0.0.0',  # set to 127.0.0.1 to accept only local calls (used for proxying to port 80 with nginx or apache mod_proxy)
        'LISTENING_PORT': 8080,
        'REGISTRARS': (
            'nodeshot.core.websockets.registrars.nodes',
            'nodeshot.core.websockets.registrars.notifications',
        )
    },
    # list that will contain functions to disable and re-enable some signals
    # for large import of data notifications, websockets, participation counts and similar operations
    # might be temporarily disabled to avoid unnecessary database load
    'DISCONNECTABLE_SIGNALS': [],
    # settings for old nodeshot importer
    'OLD_IMPORTER':{
        'DEFAULT_LAYER': 1,  # id of default layer
        'STATUS_MAPPING': {
            'a': 'active',
            'h': 'active',
            'ah': 'active',
            'p': 'potential',
            'default': 'potential'
        }
    },
    'NETENGINE_BACKENDS': [
        ('netengine.backends.ssh.AirOS', 'AirOS (SSH)'),
        ('netengine.backends.ssh.OpenWRT', 'OpenWRT (SSH)'),
        ('netengine.backends.snmp.AirOS', 'AirOS (SNMP)'),
    ],
    'OPEN311': {
        # Metadata for service discovery
        'DISCOVERY': {
            'changeset':'2014-02-03 14:18',
            'contact':'email or phone number for assistance',
            'key_service':'URL for api_key requests',
            'endpoints':[
                {
                    'specification':'http://wiki.open311.org/GeoReport_v2',
                    'url':'Public URL of your endpoint',
                    'changeset':'2014-02-03 09:01',
                    'type':'production',
                    'formats':[
                        'application/json'
                    ]
                },

            ]
        },
        # Do not change this unless you want to redefine Open311 service definitions
        'METADATA': 'true',
        'TYPE': 'realtime',
        # Change the following, according to the statuses you have configured in your model
        'STATUS' : {
            'potential': 'open',
            'planned': 'open',
            'active': 'closed',
        }
    }
}

NODESHOT['DEFAULTS']['CRONJOB'] = NODESHOT['CHOICES']['AVAILABLE_CRONJOBS'][0][0]

if 'test' in sys.argv:
    NODESHOT['NETENGINE_BACKENDS'].append(
        ('netengine.backends.Dummy', 'Dummy')
    )

# ------ GRAPPELLI ------ #

if 'grappelli' in INSTALLED_APPS:
    GRAPPELLI_ADMIN_TITLE = 'Nodeshot Admin'
    GRAPPELLI_INDEX_DASHBOARD = 'nodeshot.dashboard.NodeshotDashboard'

# ------ DEBUG TOOLBAR ------ #

INTERNAL_IPS = ('127.0.0.1', '::1',)  # ip addresses where you want to show the debug toolbar here
DEBUG_TOOLBAR_CONFIG = {
    'INTERCEPT_REDIRECTS': False,
}

# ------ UNIT TESTING SPEED UP ------ #

SOUTH_DATABASE_ADAPTERS = {'default': 'south.db.postgresql_psycopg2'}
SOUTH_TESTS_MIGRATE = False

if 'test' in sys.argv:
    CELERY_ALWAYS_EAGER = True

    PASSWORD_HASHERS = (
        'django.contrib.auth.hashers.MD5PasswordHasher',
        'django.contrib.auth.hashers.SHA1PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
        'django.contrib.auth.hashers.BCryptPasswordHasher',
    )

# ------ SOCIAL AUTH SETTINGS ------ #

if 'social_auth' in INSTALLED_APPS:
    MIDDLEWARE_CLASSES += ('social_auth.middleware.SocialAuthExceptionMiddleware',)

    # In Django 1.6, the default session serliazer has been switched to one based on JSON,
    # rather than pickles, to improve security. Django-openid-auth does not support this
    # because it attemps to store content that is not JSON serializable in sessions.
    # See https://docs.djangoproject.com/en/dev/releases/1.6/#default-session-serialization-switched-to-json
    # for details on the Django 1.6 change.
    SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'

    AUTHENTICATION_BACKENDS = (
        'django.contrib.auth.backends.ModelBackend',
        'nodeshot.community.profiles.backends.EmailBackend',
        'social_auth.backends.facebook.FacebookBackend',
        'social_auth.backends.google.GoogleBackend',
        'nodeshot.community.profiles.social_auth_extra.github.GithubBackend',
    )

    SOCIAL_AUTH_PIPELINE = (
        'social_auth.backends.pipeline.social.social_auth_user',
        'social_auth.backends.pipeline.associate.associate_by_email',
        'social_auth.backends.pipeline.user.get_username',
        'social_auth.backends.pipeline.user.create_user',
        'social_auth.backends.pipeline.social.associate_user',
        'nodeshot.community.profiles.social_auth_extra.pipeline.load_extra_data',
        'social_auth.backends.pipeline.user.update_user_details'
    )

    SOCIAL_AUTH_ENABLED_BACKENDS = ('facebook', 'google', 'github')

    # register a new app:
    FACEBOOK_APP_ID = ''  # put your app id
    FACEBOOK_API_SECRET = ''
    FACEBOOK_EXTENDED_PERMISSIONS = ['email', 'user_about_me', 'user_birthday', 'user_hometown']

    # register a new app:
    GITHUB_APP_ID = ''
    GITHUB_API_SECRET = ''
    GITHUB_EXTENDED_PERMISSIONS = ['user:email']

    SOCIAL_AUTH_DEFAULT_USERNAME = 'new_social_auth_user'
    SOCIAL_AUTH_UUID_LENGTH = 3
    SOCIAL_AUTH_SESSION_EXPIRATION = False
    SOCIAL_AUTH_ASSOCIATE_BY_MAIL = True

    LOGIN_URL = '/'
    LOGIN_REDIRECT_URL = '/'
    LOGIN_ERROR_URL    = '/'

# ------ CORS-HEADERS SETTINGS ------ #

CORS_ORIGIN_ALLOW_ALL = True

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.conf import settings
from django.contrib import admin

admin.autodiscover()


urlpatterns = patterns('',
    # smuggler for fixture management
    # must be before admin url patterns
    url(r'^admin/', include('smuggler.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    url(r'', include('nodeshot.urls'))
)


if settings.DEBUG and settings.SERVE_STATIC:
    urlpatterns += patterns('django.contrib.staticfiles.views',
        url(r'^static/(?P<path>.*)$', 'serve'),
        url(r'^media/(?P<path>.*)$', 'serve'),
    )

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for nodeshot project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ninux.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

########NEW FILE########
__FILENAME__ = celery
from __future__ import absolute_import

import os
from celery import Celery
from django.conf import settings

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'ci.settings')

app = Celery('ci')
app.config_from_object('django.conf:settings')
app.autodiscover_tasks(settings.INSTALLED_APPS, related_name='tasks')

########NEW FILE########
__FILENAME__ = local_settings.example
DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': 'nodeshot_ci',
        'USER': 'custom_user',
        'PASSWORD': 'custom_password',
        'HOST': '127.0.0.1',
        'PORT': '5432',
    }
}

DOMAIN = 'yourcustomhost.com'

########NEW FILE########
__FILENAME__ = settings
# Django settings for nodeshot project.

import os
import sys

DEBUG = True
SERVE_STATIC = DEBUG
TEMPLATE_DEBUG = DEBUG

ADMINS = (
    # ('Your Name', 'your_email@example.com'),
)

MANAGERS = ADMINS

DATABASES = {
    'default': {
        'ENGINE': 'django.contrib.gis.db.backends.postgis',
        'NAME': 'nodeshot_ci',
        'USER': 'postgres',
        'PASSWORD': '',
        'HOST': '',
        'PORT': '',
    }
}

POSTGIS_VERSION = (2, 1)

# uncomment if you need to use nodeshot.extra.oldimporter
#if 'test' not in sys.argv:
#    DATABASES['old_nodeshot'] = {
#       'ENGINE': 'django.db.backends.mysql',  # might be also postgresql or sqlite
#       'NAME': 'nodeshot',
#       'USER': 'nodeshot-readonly',
#       'PASSWORD': '*********',
#       'HOST': 'remote-ip',
#       'PORT': 'remote-port',
#    }
#    DATABASE_ROUTERS = [
#        'nodeshot.extra.oldimporter.db.DefaultRouter',
#        'nodeshot.extra.oldimporter.db.OldNodeshotRouter'
#    ]


# Local time zone for this installation. Choices can be found here:
# http://en.wikipedia.org/wiki/List_of_tz_zones_by_name
# although not all choices may be available on all operating systems.
# In a Windows environment this must be set to your system time zone.
TIME_ZONE = 'Europe/Rome'

# Language code for this installation. All choices can be found here:
# http://www.i18nguy.com/unicode/language-identifiers.html
LANGUAGE_CODE = 'en-gb'

# If you set this to False, Django will make some optimizations so as not
# to load the internationalization machinery.
USE_I18N = True

# If you set this to False, Django will not format dates, numbers and
# calendars according to the current locale.
USE_L10N = True

# If you set this to False, Django will not use timezone-aware datetimes.
USE_TZ = True

SITE_ID = 1
PROTOCOL = 'http' if DEBUG else 'https'
DOMAIN = 'localhost'
PORT = '8000' if DEBUG else None

try:
    from local_settings import *
except ImportError:
    pass

SITE_URL = '%s://%s' % (PROTOCOL, DOMAIN)
ALLOWED_HOSTS = [DOMAIN]  # check https://docs.djangoproject.com/en/1.5/ref/settings/#allowed-hosts for more info

if PORT and PORT not in ['80', '443']:
    SITE_URL = '%s:%s' % (SITE_URL, PORT)

SITE_ROOT = os.path.dirname(os.path.realpath(__file__))

# Absolute filesystem path to the directory that will hold user-uploaded files.
# Example: "/home/media/media.lawrence.com/media/"
MEDIA_ROOT = '%s/media/' % SITE_ROOT

# URL that handles the media served from MEDIA_ROOT. Make sure to use a
# trailing slash.
# Examples: "http://media.lawrence.com/media/", "http://example.com/media/"
MEDIA_URL = '%s/media/' % SITE_URL

# Absolute path to the directory static files should be collected to.
# Don't put anything in this directory yourself; store your static files
# in apps' "static/" subdirectories and in STATICFILES_DIRS.
# Example: "/home/media/media.lawrence.com/static/"
STATIC_ROOT = '%s/static/' % SITE_ROOT

# URL prefix for static files.
# Example: "http://media.lawrence.com/static/"
STATIC_URL = '%s/static/' % SITE_URL

# Additional locations of static files
STATICFILES_DIRS = (
    # Put strings here, like "/home/html/static" or "C:/www/django/static".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

if PROTOCOL == 'https':
    SESSION_COOKIE_SECURE = True
    CSRF_COOKIE_SECURE = True
    SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')
    os.environ['HTTPS'] = 'on'

# List of finder classes that know how to find static files in
# various locations.
STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
#    'django.contrib.staticfiles.finders.DefaultStorageFinder',
)

# CHANGE THIS KEY AND UNCOMMENT
# Make this unique, and don't share it with anybody.
SECRET_KEY = 'ba)t*+$)ugeyip6-#tuyy$5wf2ervc0d2n#h)qb)y5@ly$t*@w'

# List of callables that know how to import templates from various sources.
TEMPLATE_LOADERS = (
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
#     'django.template.loaders.eggs.Loader',
)

MIDDLEWARE_CLASSES = (
    'django.middleware.common.CommonMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    # Uncomment the next line for simple clickjacking protection:
    # 'django.middleware.clickjacking.XFrameOptionsMiddleware',
)

ROOT_URLCONF = 'ci.urls' # replace myproject with the name of your project. Default project is "ninux".

# Python dotted path to the WSGI application used by Django's runserver.
WSGI_APPLICATION = 'wsgi.application'


TEMPLATE_DIRS = (
    # Put strings here, like "/home/html/django_templates" or "C:/www/django/templates".
    # Always use forward slashes, even on Windows.
    # Don't forget to use absolute paths, not relative paths.
)

TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.request",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media",
    "django.core.context_processors.static",
    "django.core.context_processors.tz",
    "django.contrib.messages.context_processors.messages"
)

INSTALLED_APPS = [
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.gis',

    # PostgreSQL HStore extension support
    'django_hstore',

    # admin site
    'grappelli.dashboard',
    'grappelli',
    'filebrowser',
    'django.contrib.admin',

    # --- background jobs --- #
    'djcelery_email',  # Celery Django Email Backend

    # nodeshot
    'nodeshot.core.api',
    'nodeshot.core.layers',
    'nodeshot.core.nodes',
    'nodeshot.core.cms',
    #'nodeshot.core.websockets',
    'nodeshot.interoperability',
    'nodeshot.community.participation',
    'nodeshot.community.notifications',
    'nodeshot.community.profiles',
    'nodeshot.community.mailing',
    'nodeshot.networking.net',
    'nodeshot.networking.links',
    'nodeshot.networking.services',
    'nodeshot.networking.hardware',
    #'nodeshot.networking.connectors',
    'nodeshot.ui.default',
    'nodeshot.open311',
    'nodeshot.ui.open311_demo',

    # import data from old nodeshot version 0.9
    # needs python MySQL database driver
    # run "pip install MySQL-python"
    # you might need to run also a similar command according to your own OS distribution:
    # sudo apt-get install libmysqlclient-dev
    #'nodeshot.extra.oldimporter',

    # 3d parthy django apps
    'rest_framework',
    'rest_framework_swagger',
    'olwidget',  # geodjango better widgets
    'south',
    'smuggler',
    'reversion',

    # profiles and social networks
    'emailconfirmation',
    'social_auth',
]

if 'nodeshot.community.profiles' in INSTALLED_APPS:
    AUTH_USER_MODEL = 'profiles.Profile'

# ------ DJANGO LOGGING ------ #

# A sample logging configuration. The only tangible logging
# performed by this configuration is to send an email to
# the site admins on every HTTP 500 error when DEBUG=False.
# See http://docs.djangoproject.com/en/dev/topics/logging for
# more details on how to customize your logging configuration.
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse'
        }
    },
    'handlers': {
        'mail_admins': {
            'level': 'ERROR',
            'filters': ['require_debug_false'],
            'class': 'django.utils.log.AdminEmailHandler'
        },
        'logfile': {
            'level': 'ERROR',
            'class':'logging.handlers.RotatingFileHandler',
            'formatter': 'verbose',
            'filename': SITE_ROOT + "/error.log",
            'maxBytes': 10485760,  # 10 MB
            'backupCount': 3,
            'formatter': 'verbose'
        },
    },
    'loggers': {
        'django': {
            'handlers':['logfile'],
            'level':'ERROR',
            'propagate': True,
        },
        'django.request': {
            'handlers': ['mail_admins', 'logfile'],
            'level': 'ERROR',
            'propagate': True,
        },
        '': {
            'handlers': ['logfile'],
            'level': 'ERROR',
        },
    },
    'formatters': {
        'verbose': {
            'format': '\n\n[%(levelname)s %(asctime)s] module: %(module)s, process: %(process)d, thread: %(thread)d\n%(message)s'
        },
        'simple': {
            'format': '%(levelname)s %(message)s'
        },
        'custom': {
            'format': '%(levelname)s %(asctime)s\n%(message)s'
        },
    },
}

# ------ DJANGO CACHE ------ #

CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'TIMEOUT': 172800 if not DEBUG else 300,
        'OPTIONS': {
            'MAX_ENTRIES': 1000
        }
    }
}

# ------ EMAIL SETTINGS ------ #

# if you want a dummy SMTP server that logs outgoing emails but doesn't actually send them
# you have 2 options:
#     * python -m -smtpd -n -c DebuggingServer localhost:1025
#     * python manage.py mail_debug  (django-extensions must be installed)

#EMAIL_USE_TLS = True
EMAIL_HOST = 'localhost'
EMAIL_HOST_USER = 'your@email.org'
#EMAIL_HOST_PASSWORD = '***********'
EMAIL_PORT = 1025 if DEBUG else 25  # 1025 if you are in development mode, while 25 is usually the production port
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER
SERVER_EMAIL = DEFAULT_FROM_EMAIL  # used for error reporting

# ------ CELERY ------ #

if DEBUG:
    # this app makes it possible to use django as a queue system for celery
    # so you don't need to install RabbitQM or Redis
    # pretty cool for development, but might not suffice for production if your system is heavily used
    # our suggestion is to switch only if you start experiencing issues
    INSTALLED_APPS.append('kombu.transport.django')
    BROKER_URL = 'django://'
    # synchronous behaviour for development
    # more info here: http://docs.celeryproject.org/en/latest/configuration.html#celery-always-eager
    CELERY_ALWAYS_EAGER = True
    CELERY_EAGER_PROPAGATES_EXCEPTIONS = True
else:
    # in production the default background queue manager is Redis
    BROKER_URL = 'redis://localhost:6379/0'
    CELERY_RESULT_BACKEND = 'redis://localhost:6379/0'
    BROKER_TRANSPORT_OPTIONS = {
        "visibility_timeout": 3600,  # 1 hour
        "fanout_prefix": True
    }
    # in production emails are sent in the background
    EMAIL_BACKEND = 'djcelery_email.backends.CeleryEmailBackend'

#from datetime import timedelta
#
#CELERYBEAT_SCHEDULE = {
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#    },
#    # example of how to synchronize one of the layers with a different periodicity
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(minutes=30),
#        'args': ('layer_slug',)
#    },
#    # example of how to synchronize all layers except two layers
#    'synchronize': {
#        'task': 'nodeshot.interoperability.tasks.synchronize_external_layers',
#        'schedule': timedelta(hours=12),
#        'kwargs': { 'exclude': 'layer1-slug,layer2-slug' }
#    },
#    'purge_notifications': {
#        'task': 'nodeshot.community.notifications.tasks.purge_notifications',
#        'schedule': timedelta(days=1),
#    }
#}

# ------ NODESHOT ------ #

# https://docs.djangoproject.com/en/dev/topics/i18n/translation/
# look for (ctrl + f) 'lambda' and you'll find why the following is needed
_ = lambda s: s

NODESHOT = {
    'SETTINGS': {
        # api prefix examples:
        #   * api/
        #   * api/v1/
        # leave blank to include api urls at root level, such as /nodes/, /layers/ and so on
        'API_PREFIX': 'api/v1/',
        'ACL_GLOBAL_EDITABLE': True,

        # the following is an example of possible granular ACL setting that can be specified
        #'ACL_NODES_NODE_EDITABLE': False,

        'LAYER_TEXT_HTML': True,
        'NODE_DESCRIPTION_HTML': True,

        'CONTACT_INWARD_LOG': True,
        'CONTACT_INWARD_MAXLENGTH': 2000,
        'CONTACT_INWARD_MINLENGTH': 15,
        'CONTACT_INWARD_REQUIRE_AUTH': False,
        'CONTACT_OUTWARD_MAXLENGTH': 9999,
        'CONTACT_OUTWARD_MINLENGTH': 10,
        'CONTACT_OUTWARD_STEP': 20,
        'CONTACT_OUTWARD_DELAY': 10,
        'CONTACT_OUTWARD_HTML': True,  # grappelli must be in INSTALLED_APPS, otherwise it won't work

        'PROFILE_EMAIL_CONFIRMATION': True,
        'PROFILE_REQUIRED_FIELDS': ['email'],

        'ADMIN_MAP_COORDS': [41.8934, 12.4960],  # lat, lng
        'ADMIN_MAP_ZOOM': 1,  # default zoom in the admin

        'REVERSION_LAYERS': True,  # activate django reversion for layers.Layer model
        'REVERSION_NODES': True,  # activate django reversion for nodes.Node model
    },
    'CHOICES': {
        'AVAILABLE_CRONJOBS': (
            ('00', _('midnight')),
            ('04', _('04:00 AM')),
        ),
        'ACCESS_LEVELS': {
            'registered': 1,
            'community': 2,
            'trusted': 3
        },
        'APPLICATION_PROTOCOLS': (
            ('http', 'http'),
            ('https', 'https'),
            ('ftp', 'FTP'),
            ('smb', 'Samba'),
            ('afp', 'Apple File Protocol'),
            ('git', 'Git'),
        )
    },
    # default values for the application or new database objects
    'DEFAULTS': {
        'NODE_PUBLISHED': True,
        'LAYER_ZOOM': 12,
        'LAYER_MINIMUM_DISTANCE': 0,
        'MAILING_SCHEDULE_OUTWARD': False,
        'ACL_GLOBAL': 'public',
        # default access_level value for app: services, model: Login
        'ACL_SERVICES_LOGIN': 'community',
        'NOTIFICATION_BOOLEAN_FIELDS': True,
        'NOTIFICATION_DISTANCE_FIELDS': 30
    },
    'API': {
        'APPS_ENABLED': [
            'nodeshot.core.nodes',
            'nodeshot.core.layers',
            'nodeshot.core.cms',
            'nodeshot.community.profiles',
            'nodeshot.community.participation',
            'nodeshot.community.notifications',
            'nodeshot.community.mailing',
            'nodeshot.networking.net',
            'nodeshot.networking.links',
            'nodeshot.networking.services',
            'nodeshot.open311'
        ]
    },
    'INTEROPERABILITY': [
        ('nodeshot.interoperability.synchronizers.Nodeshot', 'Nodeshot'),
        ('nodeshot.interoperability.synchronizers.GeoJson', 'GeoJSON'),
        ('nodeshot.interoperability.synchronizers.GeoRss', 'GeoRSS'),
        ('nodeshot.interoperability.synchronizers.OpenWISP', 'OpenWISP'),
        ('nodeshot.interoperability.synchronizers.OpenWISPCitySDK', 'OpenWISPCitySDK'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFI', 'Provincia WiFi'),
        ('nodeshot.interoperability.synchronizers.ProvinciaWIFICitySDK', 'ProvinciaWIFICitySDK'),
        ('nodeshot.interoperability.synchronizers.OpenLabor', 'OpenLabor'),
    ],
    'NOTIFICATIONS': {
        'TEXTS': {
            'custom': None,
            'node_created': _('A new node with name "%(name)s" has been created.'),
            'node_status_changed': _('Status of node "%(name)s" has changed from "%(old_status)s" to "%(new_status)s".'),
            'node_own_status_changed': _('Status of your node "%(name)s" changed from "%(old_status)s" to "%(new_status)s".'),
            'node_deleted': _('Node "%(name)s" with ID #%(id)s was deleted.'),
        },
        # boolean: users can only turn on or off
        # distance: users can turn off (-1), turn on for all (0) or set a range of km (n)
        'USER_SETTING': {
            'node_created':             { 'type': 'distance', 'geo_field': 'geometry' },
            'node_status_changed':      { 'type': 'distance', 'geo_field': 'geometry' },
            'node_deleted':             { 'type': 'distance', 'geo_field': 'geometry' },
            'node_own_status_changed': { 'type': 'boolean' },
        },
        'ACTIONS': {
            'node_created': "reverse('api_node_details', args=[self.related_object.slug])",
            'node_status_changed': "reverse('api_node_details', args=[self.related_object.slug])",
            'node_own_status_changed': "reverse('api_node_details', args=[self.related_object.slug])",
        },
        'DELETE_OLD': 40,  # delete notifications older than specified days
        'REGISTRARS': (
            'nodeshot.community.notifications.registrars.nodes',
        )
    },
    'WEBSOCKETS': {
        'PUBLIC_PIPE': '%s/nodeshot.websockets.public' % os.path.dirname(SITE_ROOT),
        'PRIVATE_PIPE': '%s/nodeshot.websockets.private' % os.path.dirname(SITE_ROOT),
        'DOMAIN': DOMAIN,
        'LISTENING_ADDRESS': '0.0.0.0',  # set to 127.0.0.1 to accept only local calls (used for proxying to port 80 with nginx or apache mod_proxy)
        'LISTENING_PORT': 9090,
        'REGISTRARS': (
            'nodeshot.core.websockets.registrars.nodes',
        )
    },
    # list that will contain functions to disable and re-enable some signals
    # for large import of data notifications, websockets, participation counts and similar operations
    # might be temporarily disabled to avoid unnecessary database load
    'DISCONNECTABLE_SIGNALS': [],
    # settings for old nodeshot importer
    'OLD_IMPORTER':{
        'DEFAULT_LAYER': 5,   # id of default layer
        'STATUS_MAPPING': {
            'a': 'active',
            'h': 'active',
            'ah': 'active',
            'p': 'potential',
            'default': 'potential'
        }
    },
    'NETENGINE_BACKENDS': [
        ('netengine.backends.ssh.AirOS', 'AirOS (SSH)'),
        ('netengine.backends.ssh.OpenWRT', 'OpenWRT (SSH)'),
        ('netengine.backends.snmp.AirOS', 'AirOS (SNMP)'),
    ],
    'OPEN311': {
        # Metadata for service discovery
        'DISCOVERY': {
            'changeset':'2014-02-03 14:18',
            'contact':'email or phone number for assistance',
            'key_service':'URL for api_key requests',
            'endpoints':[
                {
                    'specification':'http://wiki.open311.org/GeoReport_v2',
                    'url':'Public URL of your endpoint',
                    'changeset':'2014-02-03 09:01',
                    'type':'production',
                    'formats':[
                        'application/json'
                    ]
                },

            ]
        },
        # Do not change this unless you want to redefine Open311 service definitions
        'METADATA': 'true',
        'TYPE': 'realtime',
        # Change the following, according to the statuses you have configured in your model
        'STATUS' : {
            'potential': 'open',
            'planned': 'open',
            'active': 'closed',
        }
    }
}

NODESHOT['DEFAULTS']['CRONJOB'] = NODESHOT['CHOICES']['AVAILABLE_CRONJOBS'][0][0]

if 'test' in sys.argv:
    NODESHOT['NETENGINE_BACKENDS'].append(
        ('netengine.backends.Dummy', 'Dummy')
    )

# ------ GRAPPELLI ------ #

if 'grappelli' in INSTALLED_APPS:
    GRAPPELLI_ADMIN_TITLE = 'Nodeshot Admin'
    GRAPPELLI_INDEX_DASHBOARD = 'nodeshot.dashboard.NodeshotDashboard'

# ------ UNIT TESTING SPEED UP ------ #

SOUTH_DATABASE_ADAPTERS = {'default': 'south.db.postgresql_psycopg2'}
SOUTH_TESTS_MIGRATE = False

if 'test' in sys.argv:
    CELERY_ALWAYS_EAGER = True

    PASSWORD_HASHERS = (
        'django.contrib.auth.hashers.MD5PasswordHasher',
        'django.contrib.auth.hashers.SHA1PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2PasswordHasher',
        'django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher',
        'django.contrib.auth.hashers.BCryptPasswordHasher',
    )

# ------ SOCIAL AUTH SETTINGS ------ #

if 'social_auth' in INSTALLED_APPS:
    MIDDLEWARE_CLASSES += ('social_auth.middleware.SocialAuthExceptionMiddleware',)

    # In Django 1.6, the default session serliazer has been switched to one based on JSON,
    # rather than pickles, to improve security. Django-openid-auth does not support this
    # because it attemps to store content that is not JSON serializable in sessions.
    # See https://docs.djangoproject.com/en/dev/releases/1.6/#default-session-serialization-switched-to-json
    # for details on the Django 1.6 change.
    SESSION_SERIALIZER = 'django.contrib.sessions.serializers.PickleSerializer'

    AUTHENTICATION_BACKENDS = (
        'django.contrib.auth.backends.ModelBackend',
        'nodeshot.community.profiles.backends.EmailBackend',
        'social_auth.backends.facebook.FacebookBackend',
        'social_auth.backends.google.GoogleBackend',
        'nodeshot.community.profiles.social_auth_extra.github.GithubBackend',
    )

    SOCIAL_AUTH_PIPELINE = (
        'social_auth.backends.pipeline.social.social_auth_user',
        'social_auth.backends.pipeline.associate.associate_by_email',
        'social_auth.backends.pipeline.user.get_username',
        'social_auth.backends.pipeline.user.create_user',
        'social_auth.backends.pipeline.social.associate_user',
        'nodeshot.community.profiles.social_auth_extra.pipeline.load_extra_data',
        'social_auth.backends.pipeline.user.update_user_details'
    )

    SOCIAL_AUTH_ENABLED_BACKENDS = ('facebook', 'google', 'github')

    # register a new app:
    FACEBOOK_APP_ID = ''  # put your app id
    FACEBOOK_API_SECRET = ''
    FACEBOOK_EXTENDED_PERMISSIONS = ['email', 'user_about_me', 'user_birthday', 'user_hometown']

    # register a new app:
    GITHUB_APP_ID = ''
    GITHUB_API_SECRET = ''
    GITHUB_EXTENDED_PERMISSIONS = ['user:email']

    SOCIAL_AUTH_DEFAULT_USERNAME = 'new_social_auth_user'
    SOCIAL_AUTH_UUID_LENGTH = 3
    SOCIAL_AUTH_SESSION_EXPIRATION = False
    SOCIAL_AUTH_ASSOCIATE_BY_MAIL = True

    LOGIN_URL = '/'
    LOGIN_REDIRECT_URL = '/'
    LOGIN_ERROR_URL    = '/'


import django

if django.VERSION[:2] >= (1, 6):
    TEST_RUNNER = 'django.test.runner.DiscoverRunner'
else:
    try:
        import discover_runner
        TEST_RUNNER = "discover_runner.DiscoverRunner"
    except ImportError:
        print("To run tests with django <= 1.5 you should install "
              "django-discover-runner.")
        sys.exit(-1)

########NEW FILE########
__FILENAME__ = urls
from django.conf.urls import patterns, include, url
from django.conf import settings
from django.contrib import admin

admin.autodiscover()


urlpatterns = patterns('',
    # smuggler for fixture management
    # must be before admin url patterns
    url(r'^admin/', include('smuggler.urls')),

    # Uncomment the next line to enable the admin:
    url(r'^admin/', include(admin.site.urls)),
    # Uncomment the admin/doc line below to enable admin documentation:
    # url(r'^admin/doc/', include('django.contrib.admindocs.urls')),

    url(r'', include('nodeshot.urls'))
)


if settings.DEBUG and settings.SERVE_STATIC:
    urlpatterns += patterns('django.contrib.staticfiles.views',
        url(r'^static/(?P<path>.*)$', 'serve'),
        url(r'^media/(?P<path>.*)$', 'serve'),
    )

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
import os
import sys

if __name__ == "__main__":
    os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ci.settings")

    from django.core.management import execute_from_command_line

    execute_from_command_line(sys.argv)

########NEW FILE########
__FILENAME__ = runtests
#!/usr/bin/env python
# -*- coding: utf-8 -*-


import os, sys
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ci.settings")


if __name__ == "__main__":

    args = sys.argv
    args.insert(1, "test")
    from ci.settings import INSTALLED_APPS
    from django.core.management import execute_from_command_line

    for app in INSTALLED_APPS:
        # include only nodeshot apps
        if app.startswith('nodeshot.'):
            args.append(app)

    execute_from_command_line(args)

########NEW FILE########
__FILENAME__ = wsgi
"""
WSGI config for nodeshot project.

This module contains the WSGI application used by Django's development server
and any production WSGI deployments. It should expose a module-level variable
named ``application``. Django's ``runserver`` and ``runfcgi`` commands discover
this application via the ``WSGI_APPLICATION`` setting.

Usually you will have the standard Django WSGI application here, but it also
might make sense to replace the whole Django WSGI application with a custom one
that later delegates to the Django one. For example, you could introduce WSGI
middleware here, or combine a Django application with an application of another
framework.

"""
import os
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.realpath(__file__))))

os.environ.setdefault("DJANGO_SETTINGS_MODULE", "ci.settings")

# This application object is used by any WSGI server configured to use this
# file. This includes Django's development server, if the WSGI_APPLICATION
# setting points here.
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()

########NEW FILE########
