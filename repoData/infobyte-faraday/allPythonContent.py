__FILENAME__ = manager
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import auth.users

RolesAdmited = set(["local_admin"])
    


class Roles(object):
    """Roles for a user are defined here"""
    def __init__(self, *args):
        self.roles = []
        if set(args).issubset(RolesAdmited): 
            self.roles.extend(args)

    def __iter__(self):
        return iter(self.roles)

class codes:
    """
    an enumeration with different result/status codes
    """
    successfulLogin = 0
    badUserOrPassword = 1

    __descriptions = {
        successfulLogin :"Successful Logon",
        badUserOrPassword : "Bad username or password",
    }

    @staticmethod
    def getDescription(code):
        """
        Returns the description for a given code
        """
        return codes.__descriptions.get(code,"code does not exist")


class SecurityManager(object):
    """
    Handles the security and authentication in the system.
    it exposes some methods used to authenticate users and check permissions
    over different objects on the model.
    """
                                                                                 
                                                                               
                                                                           
                                                                            
                                       
                                                                              
                           

    def __init__(self):
        self.current_user = None

    def authenticateUser(self, username, password):
        """
        Authenticates a user.
        It returns 2 values:
        First value:
            if username and password are correct it returns a User object.
            It returns None if authentication fails
        Second value:
            returns a result code
            This code can be used later to get a description of the situation.
            To get the description use
        """
                                                                                 
                        
                                                                                 
                                   

                                                                        
        user = auth.users.User(username,password)
        self.current_user = user

        return codes.successfulLogin

    def getCurrentUser(self):
        return self.current_user

    def getUserRoles(self):
        return Roles("local_admin")

    def checkPermissions(self, operation):
        providers = self.getProviders(operation) 
        if any( [ prov.isAllowed(securityManager = self, 
                                    aUser = self.getCurrentUser(), 
                                    anOperation = operation)
                        for  prov in providers ] ):
            return True
        raise SecurityFailException("No permission for anything")

    def getProviders(self, operation): 
        return  [prov() for prov in SecurityProvider.__subclasses__() if prov.handlesOp(operation) ]


class SecurityProvider(object):
    def isAllowed(self, securityManager, aUser, anOperation):
        raise NotImplementedError("Should not implement abstract")

class WorkspacePermisionProvider(SecurityProvider):
    handles = ["syncActiveWorkspace"]
    def __init__(self):
        self.ops_per_roles = {'syncActiveWorkspace' : Roles('pentester', 'admin').roles }

    @staticmethod
    def handlesOp(anOperation):
        return anOperation in WorkspacePermisionProvider.handles

    def isAllowed(self, securityManager, aUser, anOperation):
        """ Checks if the user has the role needed to run the operation """
        allowd = any(map(lambda x: x in self.ops_per_roles[anOperation], securityManager.getUserRoles()))

        return allowd


class SecurityFailException(Exception):
    pass

########NEW FILE########
__FILENAME__ = users
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import os
import sys
import uuid

                                                                                

class User(object):
    """
    This represents a user on the system.
    Users are assigned to work on different workspaces and
    some permissions are configured.
    A user can be part of groups.
    """
    def __init__(self, name, passwd = "", display_name = "", groups = [], level = 0):
                                                                                 
        self.name       = name
        self.__id       = uuid.uuid4()                       
                                                                        
        self.display_name = display_name or name
        self._groups    = []
        self._level     = level
                                                                          
                                                      
        self.__password = passwd
                                
                                     

        self.lastlogon = None

                                                                                

########NEW FILE########
__FILENAME__ = delAllHost
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
for host in api.__model_controller.getAllHosts():
    print "Del host: " + host.name
    api.delHost(host.id)

########NEW FILE########
__FILENAME__ = delAllServiceClosed
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

for host in api.__model_controller.getAllHosts():

    for i in host.getAllInterfaces():
        for s in i.getAllServices():
            if s.getStatus() != "open":
                print "delService" + s.name + "from int:" + i.name
                api.delServiceFromInterface(host.id,i.id,s.id)



########NEW FILE########
__FILENAME__ = getAllCreds
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

for host in api.__model_controller.getAllHosts():
    for c in host.getCreds():
        print host.name+"|0|"+c.username+ "|"+c.password

    for i in host.getAllInterfaces():
        for s in i.getAllServices():
            for c in s.getCreds():
                print host.name+"|"+str(s.getPorts()) + "|"+c.username+ "|"+c.password


########NEW FILE########
__FILENAME__ = getAllHosts
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

for host in api.__model_controller.getAllHosts():
    for i in host.getAllInterfaces():
        for h in i._hostnames:
            print h

########NEW FILE########
__FILENAME__ = getAllIps
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
for h in api.__model_controller.getAllHosts(): print h.name

########NEW FILE########
__FILENAME__ = getAllOs
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
for h in api.__model_controller.getAllHosts(): print h.name+"|"+h.getOS()

########NEW FILE########
__FILENAME__ = getAllVulnsCSV
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import re
vulns=""
for host in api.__model_controller.getAllHosts():
    hostnames=""
    for i in host.getAllInterfaces():
        for h in i._hostnames:
            hostnames+=","+h

    for v in host.getVulns():
        print host.name+"("+hostnames+")|0|"+v.name.encode("utf-8")+ "|"+re.sub("\n|\r",",",v.desc.encode("utf-8"))+"|"+str(v.severity)+"|"+str(v.id)

    for i in host.getAllInterfaces():
        for s in i.getAllServices():
            for v in s.getVulns():
                print host.name+"("+hostnames+")|"+str(s.getPorts()) + "|"+v.name.encode("utf-8")+ "|"+re.sub("\n|\r",",",v.desc.encode("utf-8"))+"|"+str(v.severity)+"|"+str(v.id)


########NEW FILE########
__FILENAME__ = getAllWebservers
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import re
webs={}
for host in api.__model_controller.getAllHosts():

    for i in host.getAllInterfaces():
        for s in i.getAllServices():
            web=False
            if re.search("www|web|http|https",s.name):
                web=True

            if ['80','443','8080'] in s.getPorts():
                web=true

            for v in s.getVulns():
                if v.class_signature=="VulnerabilityWeb":
                    web=True
                    break
            if web==True:
                for p in s.getPorts():
                    if str(p)=="443":
                        webs["https://" + host.name+":"+str(p)+"/"]=1
                    else:
                        webs["http://" + host.name+":"+str(p)+"/"]=1
                    
                for n in s.getNotes():
                    if n.name =="website":
                        for wn in n.getNotes():
                            webs["http://" + wn.name+":"+str(p)+"/"]=1


for k,v in webs.iteritems():
    print k




########NEW FILE########
__FILENAME__ = configuration
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import sys, os, string, ast, json

try:
    import xml.etree.cElementTree as ET
    from xml.etree.cElementTree import Element, ElementTree, dump
except ImportError:
    import xml.etree.ElementTree as ET
    from xml.etree.ElementTree import Element, ElementTree, dump
    
the_config = None
    
CONST_API_CON_INFO = "api_con_info"
CONST_API_CON_INFO_HOST = "api_con_info_host"
CONST_API_CON_INFO_PORT = "api_con_info_port"
CONST_APPNAME = "appname"
CONST_AUTH = "auth"
CONST_AUTO_SHARE_WORKSPACE = "auto_share_workspace"
CONST_CONFIG_PATH = "config_path"
CONST_DATA_PATH = "data_path"
CONST_DEBUG_STATUS = "debug_status"
CONST_DEFAULT_CATEGORY = "default_category"
CONST_DEFAULT_TEMP_PATH = "default_temp_path"
CONST_FONT = "font"
CONST_HOME_PATH = "home_path"
CONST_HOST_TREE_TOGGLE = "host_tree_toggle"
CONST_HSTACTIONS_PATH = "hstactions_path"
CONST_ICONS_PATH = "icons_path"
CONST_IMAGE_PATH = "image_path"
CONST_LOG_CONSOLE_TOGGLE = "log_console_toggle"
CONST_NETWORK_LOCATION = "network_location"
CONST_PERSISTENCE_PATH = "persistence_path"
CONST_PERSPECTIVE_VIEW = "perspective_view"
CONST_REPO_PASSWORD = "repo_password"
CONST_COUCH_URI = "couch_uri"
CONST_COUCH_REPLICS = "couch_replics"
CONST_COUCH_ISREPLICATED = "couch_is_replicated"
CONST_REPO_URL = "repo_url"
CONST_REPO_USER = "repo_user"
CONST_REPORT_PATH = "report_path"
CONST_SHELL_MAXIMIZED = "shell_maximized"
CONST_VERSION = "version"
CONST_TKTURI = "tickets_uri"
CONST_TKTAPIPARAMS = "tickets_api"
CONST_TKTTEMPLATE = "tickets_template"

CONST_LAST_WORKSPACE = "last_workspace"
CONST_PLUGIN_SETTINGS = "plugin_settings"

                                                                
DEFAULT_XML = os.path.dirname(__file__) +  "/default.xml"

 
class Configuration:

    def __init__(self, xml_file=DEFAULT_XML):
        """ Initializer that handles a configuration automagically. """

        self.filepath = xml_file

        if self._isConfig(): self._getConfig()

                                                               
    
    def _isConfig(self):
        """ Checks whether the given file exists and belongs 
        to faraday's configuration syntax"""

        root = f = None
        
        try:
            f = open(self.filepath, 'rb')
            try:
                for event, elem in ET.iterparse(f, ('start', )):
                    root = elem.tag
                    break
            except SyntaxError, err:
                print "Not an xml file.\n %s" % (err)
                return False

        except IOError, err:
            print "Error while opening file.\n%s. %s" % (err, self.filepath)
            return False
            
        finally:
            if f: f.close()

        return (root == "faraday")

    def _getTree(self):
        """ Returns an XML tree read from file. """

        f = open(self.filepath)
        try:
            tree = ET.fromstring(f.read())
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, self.filepath)
            return None
        return tree

    def _getValue(self, tree, var, default = None):
        """ Returns generic value from a variable on an XML tree. """

        elem = tree.findall(var)
        if not(elem):
            return default

        return elem[0].text
        
                                   
                                                                       
 
                                 
                            

    def _getConfig(self):
        """ Gathers all configuration data from self.filepath, and
            completes private attributes with such information. """

        tree = self._getTree()
        if tree:                                                          
                                                                   
                                                              
            self._api_con_info_host = self._getValue(tree, CONST_API_CON_INFO_HOST)
            self._api_con_info_port = self._getValue(tree, CONST_API_CON_INFO_PORT)
            self._api_con_info = self._getValue(tree, CONST_API_CON_INFO)
            self._appname = self._getValue(tree, CONST_APPNAME)
            self._auth = self._getValue(tree, CONST_AUTH)
            self._auto_share_workspace = self._getValue(tree, CONST_AUTO_SHARE_WORKSPACE)
            self._config_path = self._getValue(tree, CONST_CONFIG_PATH)
            self._data_path = self._getValue(tree, CONST_DATA_PATH)
            self._debug_status = self._getValue(tree, CONST_DEBUG_STATUS)
            self._default_category = self._getValue(tree, CONST_DEFAULT_CATEGORY)
            self._default_temp_path = self._getValue(tree, CONST_DEFAULT_TEMP_PATH)
            self._font = self._getValue(tree, CONST_FONT)
            self._home_path = self._getValue(tree, CONST_HOME_PATH)
            self._host_tree_toggle = self._getValue(tree, CONST_HOST_TREE_TOGGLE)
            self._hsactions_path = self._getValue(tree, CONST_HSTACTIONS_PATH)
            self._icons_path = self._getValue(tree, CONST_ICONS_PATH)
            self._image_path = self._getValue(tree, CONST_IMAGE_PATH)
            self._log_console_toggle = self._getValue(tree, CONST_LOG_CONSOLE_TOGGLE)
            self._network_location = self._getValue(tree, CONST_NETWORK_LOCATION)
            self._persistence_path = self._getValue(tree, CONST_PERSISTENCE_PATH)
            self._perspective_view = self._getValue(tree, CONST_PERSISTENCE_PATH)
            self._repo_password = self._getValue(tree, CONST_REPO_PASSWORD)
            self._couch_uri = self._getValue(tree, CONST_COUCH_URI, default = "")
            self._couch_replics = self._getValue(tree, CONST_COUCH_REPLICS, default = "")
            self._couch_is_replicated = bool(self._getValue(tree, CONST_COUCH_ISREPLICATED, default = False))
            self._repo_url = self._getValue(tree, CONST_REPO_URL)
            self._repo_user = self._getValue(tree, CONST_REPO_USER)
            self._report_path = self._getValue(tree, CONST_REPORT_PATH)
            self._shell_maximized = self._getValue(tree, CONST_SHELL_MAXIMIZED)
            self._version = self._getValue(tree, CONST_VERSION)
            self._last_workspace = self._getValue(tree, CONST_LAST_WORKSPACE, default = "untitled")
            self._plugin_settings = json.loads(self._getValue(tree, CONST_PLUGIN_SETTINGS, default = "{}"))

            self._tkts_uri = self._getValue(tree, CONST_TKTURI,default = "https://www.faradaysec.com/scripts/listener.php")
            self._tkt_api_params = self._getValue(tree, CONST_TKTAPIPARAMS,default ="{}")
            self._tkt_template = self._getValue(tree, CONST_TKTTEMPLATE,default ="{}")


                        
    def getApiConInfo(self):
        if str(self._api_con_info_host) == "None" or str(self._api_con_info_port) == "None":
            return None
        return self._api_con_info_host, int(self._api_con_info_port)
                                  
    
    def getApiConInfoHost(self):
        return self._api_con_info_host
    
    def getApiConInfoPort(self):
        return self._api_con_info_port
    
    def getAppname(self):
        return self._appname

    def getAuth(self):
        return self._auth

    def getAutoShareWorkspace(self):
        return self._auto_share_workspace

    def getConfigPath(self):
        return os.path.expanduser(self._config_path)

    def getDataPath(self):
        return os.path.expanduser(self._data_path)

    def getDebugStatus(self):
        return int(self._debug_status)

    def getDefaultCategory(self):
        return self._default_category

    def getDefaultTempPath(self):
        return os.path.expanduser(self._default_temp_path)
    
    def getFont(self):
        return self._font

    def getHomePath(self):
        return os.path.expanduser(self._home_path)

    def getHostTreeToggle(self):
        return self._host_tree_toggle

    def getHsactionsPath(self):
        return os.path.expanduser(self._hsactions_path)

    def getIconsPath(self):
        return os.path.expanduser(self._icons_path)

    def getImagePath(self):
        return os.path.expanduser(self._image_path)

    def getLogConsoleToggle(self):
        return self._log_console_toggle

    def getNetworkLocation(self):
        return self._network_location

    def getPersistencePath(self):
        return os.path.expanduser(self._persistence_path)

    def getPerspectiveView(self):
        return self._perspective_view

    def getCouchURI(self):
        return self._couch_uri

    def getCouchReplics(self):
        return self._couch_replics

    def getCouchIsReplicated(self):
        return self._couch_is_replicated

    def getRepoPassword(self):
        return self._repo_password

    def getRepoUrl(self):
        return self._repo_url

    def getRepoUser(self):
        return self._repo_user

    def getReportPath(self):
        return os.path.expanduser(self._report_path)

    def getShellMaximized(self):
        return self._shell_maximized

    def getVersion(self):
        return self._version

    def getLastWorkspace(self):
        return self._last_workspace

    def getPluginSettings(self):
        return self._plugin_settings

    def getTktPostUri(self):
        return self._tkts_uri

    def getApiParams(self):
        return self._tkt_api_params

    def getTktTemplate(self):
        return self._tkt_template

                        

    def setLastWorkspace(self, workspaceName):
        self._last_workspace = workspaceName

    def setApiConInfo(self, val1, val2):
        self._api_con_info = val1, val2
        self.setApiConInfoHost(val1)
        self.setApiConInfoPort(val2)
        
    def setApiConInfoHost(self, val):
        self._api_con_info_host = val
    
    def setApiConInfoPort(self, val):
        self._api_con_info_port = str(val)
    
    def setAppname(self, val):
        self._appname = val

    def setAuth(self, val):
        self._auth = val

    def setAutoShareWorkspace(self, val):
        self._auto_share_workspace = val

    def setConfigPath(self, val):
        self._config_path = val

    def setDataPath(self, val):
        self._data_path = val

    def setDebugStatus(self, val):
        self._debug_status = int(val)

    def setDefaultCategory(self, val):
        self._default_category = val

    def setDefaultTempPath(self, val):
        self._default_temp_path = val
    
    def setFont(self, val):
        self._font = val

    def setHomePath(self, val):
        self._home_path = val

    def setHostTreeToggle(self, val):
        self._host_tree_toggle = val

    def setHsactionsPath(self, val):
        self._hsactions_path = val

    def setIconsPath(self, val):
        self._icons_path = val

    def setImagePath(self, val):
        self._image_path = val

    def setLogConsoleToggle(self, val):
        self._log_console_toggle = val

    def setNetworkLocation(self, val):
        self._network_location = val

    def setPersistencePath(self, val):
        self._persistence_path = val

    def setPerspectiveView(self, val):
        self._perspective_view = val

    def setRepoPassword(self, val):
        self._repo_password = val

    def setRepoUrl(self, val):
        self._repo_url = val

    def setRepoUser(self, val):
        self._repo_user = val

    def setReportPath(self, val):
        self._report_path = val

    def setShellMaximized(self, val):
        self._shell_maximized = val

    def setVersion(self, val):
        self._version = val

    def setCouchUri(self, uri): 
        self._couch_uri = uri

    def setCouchIsReplicated(self, is_it):
        self._couch_is_replicated = is_it

    def setCouchReplics(self, urls):
        self._couch_replics = urls

    def setPluginSettings(self, settings):
        self._plugin_settings = settings
    
    def indent(self, elem, level=0):
        """ Indents the tree to make a pretty view of it. """

        i = "\n" + level*"  "
        if len(elem):
            if not elem.text or not elem.text.strip():
                elem.text = i + "  "
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
            for elem in elem:
                self.indent(elem, level+1)
            if not elem.tail or not elem.tail.strip():
                elem.tail = i
        else:
            if level and (not elem.tail or not elem.tail.strip()):
                elem.tail = i


    def saveConfig(self, xml_file="~/.faraday/config/user.xml"):
        """ Saves XML config on new file. """

        ROOT = Element("faraday")
        
        API_CON_INFO_HOST = Element(CONST_API_CON_INFO_HOST)
        API_CON_INFO_HOST.text = self.getApiConInfoHost()
        ROOT.append(API_CON_INFO_HOST)
        
        API_CON_INFO_PORT = Element(CONST_API_CON_INFO_PORT)
        API_CON_INFO_PORT.text = str(self.getApiConInfoPort())
        ROOT.append(API_CON_INFO_PORT)
        
        APPNAME = Element(CONST_APPNAME)
        APPNAME.text = self.getAppname()
        ROOT.append(APPNAME)

        AUTH = Element(CONST_AUTH, encrypted="no", algorithm="OTR")
        AUTH.text = self.getAuth()
        ROOT.append(AUTH)

        AUTO_SHARE_WORKSPACE = Element(CONST_AUTO_SHARE_WORKSPACE)
        AUTO_SHARE_WORKSPACE.text = self.getAutoShareWorkspace()
        ROOT.append(AUTO_SHARE_WORKSPACE)

        CONFIG_PATH = Element(CONST_CONFIG_PATH)
        CONFIG_PATH.text = self.getConfigPath()
        ROOT.append(CONFIG_PATH)

        DATA_PATH = Element(CONST_DATA_PATH)
        DATA_PATH.text = self.getDataPath()
        ROOT.append(DATA_PATH)

        DEBUG_STATUS = Element(CONST_DEBUG_STATUS)
        DEBUG_STATUS.text = str(self.getDebugStatus())
        ROOT.append(DEBUG_STATUS)

        DEFAULT_CATEGORY = Element(CONST_DEFAULT_CATEGORY)
        DEFAULT_CATEGORY.text = self.getDefaultCategory()
        ROOT.append(DEFAULT_CATEGORY)

        DEFAULT_TEMP_PATH = Element(CONST_DEFAULT_TEMP_PATH)
        DEFAULT_TEMP_PATH.text = self.getDefaultTempPath()
        ROOT.append(DEFAULT_TEMP_PATH)

        FONT = Element(CONST_FONT)
        FONT.text = self.getFont()
        ROOT.append(FONT)

        HOME_PATH = Element(CONST_HOME_PATH)
        HOME_PATH.text = self.getHomePath()
        ROOT.append(HOME_PATH)


        HOST_TREE_TOGGLE = Element(CONST_HOST_TREE_TOGGLE)
        HOST_TREE_TOGGLE.text = self.getHostTreeToggle()
        ROOT.append(HOST_TREE_TOGGLE)

        HSTACTIONS_PATH = Element(CONST_HSTACTIONS_PATH)
        HSTACTIONS_PATH.text = self.getHsactionsPath()
        ROOT.append(HSTACTIONS_PATH)

        ICONS_PATH = Element(CONST_ICONS_PATH)
        ICONS_PATH.text = self.getIconsPath()
        ROOT.append(ICONS_PATH)

        IMAGE_PATH = Element(CONST_IMAGE_PATH)
        IMAGE_PATH.text = self.getImagePath()
        ROOT.append(IMAGE_PATH)

        LOG_CONSOLE_TOGGLE = Element(CONST_LOG_CONSOLE_TOGGLE)
        LOG_CONSOLE_TOGGLE.text = self.getLogConsoleToggle()
        ROOT.append(LOG_CONSOLE_TOGGLE)

        NETWORK_LOCATION = Element(CONST_NETWORK_LOCATION)
        NETWORK_LOCATION.text = self.getNetworkLocation()
        ROOT.append(NETWORK_LOCATION)

        PERSISTENCE_PATH = Element(CONST_PERSISTENCE_PATH)
        PERSISTENCE_PATH.text = self.getPersistencePath()
        ROOT.append(PERSISTENCE_PATH)

        PERSPECTIVE_VIEW = Element(CONST_PERSPECTIVE_VIEW)
        PERSPECTIVE_VIEW.text = self.getPerspectiveView()
        ROOT.append(PERSPECTIVE_VIEW)

        REPO_PASSWORD = Element(CONST_REPO_PASSWORD)
        REPO_PASSWORD.text = self.getRepoPassword()
        ROOT.append(REPO_PASSWORD)

        REPO_URL = Element(CONST_REPO_URL, type="SVN")
        REPO_URL.text = self.getRepoUrl()
        ROOT.append(REPO_URL)

        REPO_USER = Element(CONST_REPO_USER)
        REPO_USER.text = self.getRepoUser()
        ROOT.append(REPO_USER)

        REPORT_PATH = Element(CONST_REPORT_PATH)
        REPORT_PATH.text = self.getReportPath()
        ROOT.append(REPORT_PATH)

        SHELL_MAXIMIZED = Element(CONST_SHELL_MAXIMIZED)
        SHELL_MAXIMIZED.text = self.getShellMaximized()
        ROOT.append(SHELL_MAXIMIZED)

        LAST_WORKSPACE = Element(CONST_LAST_WORKSPACE)
        LAST_WORKSPACE.text = self.getLastWorkspace()
        ROOT.append(LAST_WORKSPACE)

        COUCH_URI = Element(CONST_COUCH_URI)
        COUCH_URI.text = self.getCouchURI()
        ROOT.append(COUCH_URI)

        COUCH_IS_REPLICATED = Element(CONST_COUCH_ISREPLICATED)
        COUCH_IS_REPLICATED.text = str(self.getCouchIsReplicated())
        ROOT.append(COUCH_IS_REPLICATED)

        COUCH_REPLICS = Element(CONST_COUCH_REPLICS)
        COUCH_REPLICS.text = self.getCouchReplics()
        ROOT.append(COUCH_REPLICS)

        VERSION = Element(CONST_VERSION)
        VERSION.text = self.getVersion()
        ROOT.append(VERSION)

        PLUGIN_SETTINGS = Element(CONST_PLUGIN_SETTINGS)
        PLUGIN_SETTINGS.text = json.dumps(self.getPluginSettings())
        ROOT.append(PLUGIN_SETTINGS)

        TKT_URI = Element(CONST_TKTURI)
        TKT_URI.text = self.getTktPostUri()
        ROOT.append(TKT_URI)

        TKT_APIPARAMS = Element(CONST_TKTAPIPARAMS)
        TKT_APIPARAMS.text = self.getApiParams()
        ROOT.append(TKT_APIPARAMS)

        TKT_TEMPLATE = Element(CONST_TKTTEMPLATE)
        TKT_TEMPLATE.text = self.getTktTemplate()
        ROOT.append(TKT_TEMPLATE)

        self.indent(ROOT, 0)                         
        #dump(ROOT)                                        
        xml_file = os.path.expanduser(xml_file)
        ElementTree(ROOT).write(xml_file)                                      
        
def getInstanceConfiguration():
    global the_config
    if the_config is None:
                                                                          
                                              
                                                                                              
        if os.path.exists(os.path.expanduser("~/.faraday/config/user.xml")):
            the_config = Configuration(os.path.expanduser("~/.faraday/config/user.xml"))
        else:
            the_config = Configuration(os.path.expanduser("~/.faraday/config/config.xml"))
        
    return the_config


                           
                                     
 
                                     
                                 

                                          
                                         
                                                            
                                                                
                                                              

########NEW FILE########
__FILENAME__ = tofile
#!/usr/bin/python

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from datetime import date

class CSVVulnStatusReport(object):
    """Class to build CSV Vulnerability Status Report
    Expected output from this object is a file with model objects flatten
    """
    def __init__(self, path, modelobjects):
        self.path = path
        self.modelobjects = modelobjects 

    def getVulnCSVField(self, host, vuln, serv = None):
        vdate = str(date.fromtimestamp(vuln.getMetadata().create_time))
        status = 'vuln'
        level = vuln.severity
        name = vuln.name
        target = host.name + ( ':' + ','.join([ str(x) for x in serv.getPorts()]) if serv else '')
        if vuln.class_signature == "VulnerabilityWeb": 
            target = "%s/%s" % (target, vuln.path)
        
        desc = vuln.desc.replace('\n', '<br/>')

        csv_fields = [ vdate , status , str(level) , name , target , desc]
        try:
            encoded_csv_fields = map(lambda x: x.encode('utf-8'), csv_fields) 
        except Exception as e:
            print e

        field = "|".join(encoded_csv_fields)
        return field

    def createCSVVulnStatusReport(self):
        hosts = self.modelobjects
        filename = self.path

        if filename and filename is not None:
            with open(self.path + ".csv","w") as f: 
                # Date, status, Level, Name, Target, Description
                vulns_list = [] 
                for host in hosts:
                    # Get al HostVulns
                    for v in host.getVulns(): 
                        vulns_list.append(self.getVulnCSVField(host, v))

                    # Service Vulns, we don't have Interface vulns
                    for i in host.getAllInterfaces():
                        for s in i.getAllServices():
                            for v in s.getVulns(): 
                                vulns_list.append(self.getVulnCSVField(host, v, s))
                f.writelines('\n'.join(vulns_list))
                f.write('\n')

########NEW FILE########
__FILENAME__ = customevents
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
"""
This module contains the definition of all the CustomEvent's used
in the application.
These events are needed to communicate secondary threads with the GUI.

"""

import time

LOGEVENT_ID = 3131
SHOWDIALOG_ID = 3132
SHOWPOPUP_ID = 3133
EXCEPTION_ID = 3134
RENAMEHOSTSROOT_ID = 3135
CLEARHOSTS_ID = 3136
DIFFHOSTS_ID = 3137
SYNCFAILED_ID = 3138
CONFLICTS_ID = 3139
WORKSPACE_CHANGED = 3140
CONFLICT_UPDATE = 3141
RESOLVECONFLICTS_ID = 3142
ADDHOST = 4100
DELHOST = 4101
EDITHOST = 4102
UPDATEMODEL_ID = 54321


class CustomEvent(object):
    def __init__(self, type):
        self._type = type
        self._time = time.time()

    def type(self):
        return self._type

    def time(self):
        return self._time


class LogCustomEvent(CustomEvent):
    def __init__(self, text):
        CustomEvent.__init__(self, LOGEVENT_ID)
        self.text = text


class ShowDialogCustomEvent(CustomEvent):
    def __init__(self, text, type):
        CustomEvent.__init__(self, SHOWDIALOG_ID)
        self.text = text


class ShowPopupCustomEvent(CustomEvent):
    def __init__(self, text):
        CustomEvent.__init__(self, SHOWPOPUP_ID)
        self.text = text
        self.level = "INFORMATION"


class ShowExceptionCustomEvent(CustomEvent):
    def __init__(self, text, callback):
        CustomEvent.__init__(self, EXCEPTION_ID)
        self.text = text
        self.exception_objects = [None, text]
        self.callback = callback


class RenameHostsRootCustomEvent(CustomEvent):
    def __init__(self, name):
        CustomEvent.__init__(self, RENAMEHOSTSROOT_ID)
        self.name = name


class WorkspaceChangedCustomEvent(CustomEvent):
    def __init__(self, workspace):
        CustomEvent.__init__(self, WORKSPACE_CHANGED)
        self.workspace = workspace


class ConflictUpdatedCustomEvent(CustomEvent):
    def __init__(self, nconflicts):
        CustomEvent.__init__(self, CONFLICT_UPDATE)
        self.nconflicts = nconflicts


class DiffHostsCustomEvent(CustomEvent):
    def __init__(self, old_host, new_host):
        CustomEvent.__init__(self, DIFFHOSTS_ID)
        self.new_host = new_host
        self.old_host = old_host


class ResolveConflictsCustomEvent(CustomEvent):
    def __init__(self, conflicts):
        CustomEvent.__init__(self, RESOLVECONFLICTS_ID)
        self.conflicts = conflicts


class ClearHostsCustomEvent(CustomEvent):
    def __init__(self):
        CustomEvent.__init__(self, CLEARHOSTS_ID)


class ModelObjectUpdateEvent(CustomEvent):
    def __init__(self, hosts):
        CustomEvent.__init__(self, UPDATEMODEL_ID)
        self.hosts = hosts


class AddHostCustomEvent(CustomEvent):
    def __init__(self, host):
        CustomEvent.__init__(self, ADDHOST)
        self.host = host


class EditHostCustomEvent(CustomEvent):
    def __init__(self, host):
        CustomEvent.__init__(self, EDITHOST)
        self.host = host


class DeleteHostCustomEvent(CustomEvent):
    def __init__(self, host_id):
        CustomEvent.__init__(self, DELHOST)
        self.host_id = host_id

########NEW FILE########
__FILENAME__ = gui_app
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''


class UiFactory(object):
    @staticmethod
    def create(model_controller, plugin_manager, workspace_manager, gui="gtk"):
        if gui == "gtk":
            from gui.gtk.application import GuiApp
        elif gui == "qt3":
            from gui.qt3.application import GuiApp
        else:
            from gui.nogui.application import GuiApp

        return GuiApp(model_controller, plugin_manager, workspace_manager)


class FaradayUi(object):
    def __init__(self, model_controller=None, plugin_manager=None,
                 workspace_manager=None, gui="qt3"):
        #self.main_app = main_app
        self.model_controller = model_controller
        self.plugin_manager = plugin_manager
        self.workspace_manager = workspace_manager

    def getModelController(self):
        return self.model_controller

    def getPluginManager(self):
        return self.plugin_manager

    def getWorkspaceManager(self):
        return self.workspace_manager

    def setSplashImage(self, ipath):
        pass

    def startSplashScreen(self):
        pass

    def stopSplashScreen(self):
        pass

    def loadWorkspaces(self):
        pass

    def run(self, args):
        pass

    def quit(self):
        pass

    def postEvent(self, receiver, event):
        pass

    def createLoggerWidget(self):
        pass

########NEW FILE########
__FILENAME__ = application
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import time

from gui.gui_app import FaradayUi


class GuiApp(FaradayUi):
    def __init__(self, model_controller, plugin_manager, workspace_manager):
        FaradayUi.__init__(self,
                           model_controller,
                           plugin_manager,
                           workspace_manager)
        self._stop = False

    def run(self, args):

        while True:
            if self._stop:
                return
            time.sleep(0.01)

    def quit(self):
        self._stop = True

########NEW FILE########
__FILENAME__ = notifier
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import threading
from gui.gui_app import FaradayUi
import gui.customevents as events


class NotificationCenter():
    def __init__(self, uiapp=FaradayUi()):
        self.uiapp = uiapp
        self._consumers = []
        self._consumers_lock = threading.RLock()
        self.last_events = {}

    def setUiApp(self, uiapp):
        self.uiapp = uiapp

    def registerWidget(self, consumer):
        self._consumers_lock.acquire()
        if consumer not in self._consumers:
            self._consumers.append(consumer)
        self._consumers_lock.release()

    def deregisterWidget(self, consumer):
        self._consumers_lock.acquire()
        if consumer in self._consumers:
            self._consumers.remove(consumer)
        self._consumers_lock.release()

    def postCustomEvent(self, event, receiver=None):
        if self.last_events.get(event.type(), None):
            if self.last_events[event.type()] > event.time():
                return
        self.last_events[event.type()] = event.time()
        self.uiapp.postEvent(receiver, event)

    def _notifyWidgets(self, event):
        self._consumers_lock.acquire()
        for w in self._consumers:
            self.postCustomEvent(event, w)
        self._consumers_lock.release()

    def showPopup(self, msg):
        self._notifyWidgets(events.ShowPopupCustomEvent(msg))

    def workspaceLoad(self, hosts):
        self._notifyWidgets(events.ModelObjectUpdateEvent(hosts))

    def workspaceChanged(self, workspace):
        self._notifyWidgets(events.WorkspaceChangedCustomEvent(workspace))

    def addHost(self, host):
        self._notifyWidgets(events.AddHostCustomEvent(host))

    def delHost(self, host_id):
        self._notifyWidgets(events.DeleteHostCustomEvent(host_id))

    def editHost(self, host):
        self._notifyWidgets(events.EditHostCustomEvent(host))

    def conflictUpdate(self, vulns_changed):
        self._notifyWidgets(events.ConflictUpdatedCustomEvent(vulns_changed))

    def conflictResolution(self, conflicts):
        self._notifyWidgets(events.ResolveConflictsCustomEvent(conflicts))

########NEW FILE########
__FILENAME__ = application
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import os
import traceback

try:
    import qt
except ImportError:
    print "[-] Python QT3 was not found in the system, please install it and try again"
    print "Check the deps file"

from gui.gui_app import FaradayUi
from gui.qt3.mainwindow import MainWindow
from gui.qt3.customevents import QtCustomEvent
from shell.controller.env import ShellEnvironment
from model.workspace import WorkspaceOnFS, WorkspaceOnCouch

import model.guiapi
import model.api
import model.log

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()


class GuiApp(qt.QApplication, FaradayUi):
    def __init__(self, model_controller, plugin_manager, workspace_manager):
        FaradayUi.__init__(self,
                           model_controller,
                           plugin_manager,
                           workspace_manager)
        qt.QApplication.__init__(self, [])

        self._shell_envs = dict()

        model.guiapi.setMainApp(self)

        self._main_window = MainWindow(CONF.getAppname(),
                                       self,
                                       self.getModelController(),
                                       self.getPluginManager())
        self.setMainWidget(self.getMainWindow())

        notifier = model.log.getNotifier()
        notifier.widget = self._main_window

        self._splash_screen = qt.QSplashScreen(
            qt.QPixmap(os.path.join(CONF.getImagePath(), "splash2.png")),
            qt.Qt.WStyle_StaysOnTop)

    def getMainWindow(self):
        return self._main_window

    def run(self, args):
        self._main_window.createShellTab()
        self.createLoggerWidget()
        self._main_window.showAll()
        exit_code = self.exec_loop()
        return exit_code

    def createLoggerWidget(self):
        if not model.log.getLogger().isGUIOutputRegistered():
            model.log.getLogger().registerGUIOutput(self._main_window.getLogConsole())

    def loadWorkspaces(self):
        self.getMainWindow().getWorkspaceTreeView().loadAllWorkspaces()

    def setSplashImage(self, ipath):
        pass

    def startSplashScreen(self):
        splash_timer = qt.QTimer.singleShot(1700, lambda *args: None)
        self._splash_screen.show()

    def stopSplashScreen(self):
        self._splash_screen.finish(self._main_window)

    def quit(self):
        model.log.getLogger().clearWidgets()
        self.getMainWindow().hide()
        envs = [env for env in self._shell_envs.itervalues()]
        for env in envs:
            env.terminate()
        # exit status
        notifier = model.log.getNotifier()
        notifier.widget = None
        qt.QApplication.quit(self)

    def postEvent(self, receiver, event):
        if receiver is None:
            receiver = self.getMainWindow()
        qt.QApplication.postEvent(receiver, QtCustomEvent.create(event))

    def createShellEnvironment(self, name=None):

        model.api.devlog("createShellEnvironment called \
            - About to create new shell env with name %s" % name)

        shell_env = ShellEnvironment(name, self,
                                     self.getMainWindow().getTabManager(),
                                     self.model_controller,
                                     self.plugin_manager.createController,
                                     self.deleteShellEnvironment)

        self._shell_envs[name] = shell_env
        self.getMainWindow().addShell(shell_env.widget)
        shell_env.run()

    def deleteShellEnvironment(self, name, ref=None):
        def _closeShellEnv(name):
            try:
                env = self._shell_envs[name]
                env.terminate()
                tabmanager.removeView(env.widget)
                del self._shell_envs[name]
            except Exception:
                model.api.devlog("ShellEnvironment could not be deleted")
                model.api.devlog("%s" % traceback.format_exc())

        model.api.devlog("deleteShellEnvironment called \
            - name = %s - ref = %r" % (name, ref))
        tabmanager = self.getMainWindow().getTabManager()
        if len(self._shell_envs) > 1:
            _closeShellEnv(name)
        else:
            if ref is not None:
                result = self.getMainWindow().exitFaraday()
                if result == qt.QDialog.Accepted:
                    self.quit()
                else:
                    _closeShellEnv(name)
                    self.getMainWindow().createShellTab()

    def removeWorkspace(self, name):
        model.api.log("Removing Workspace: %s" % name)
        return self.getWorkspaceManager().removeWorkspace(name)

    def syncWorkspaces(self):
        try:
            self.getWorkspaceManager().saveWorkspaces()
        except Exception:
            model.api.log("An exception was captured while synchronizing \
                workspaces\n%s" % traceback.format_exc(), "ERROR")

    def saveWorkspaces(self):
        try:
            self.getWorkspaceManager().saveWorkspaces()
        except Exception:
            model.api.log("An exception was captured while saving \
                workspaces\n%s" % traceback.format_exc(), "ERROR")

    def createWorkspace(self, name, description="", w_type=""):

        if name in self.getWorkspaceManager().getWorkspacesNames():

            model.api.log("A workspace with name %s already exists"
                          % name, "ERROR")
        else:
            model.api.log("Creating workspace '%s'" % name)
            model.api.devlog("Looking for the delegation class")
            workingClass = globals()[w_type]

            w = self.getWorkspaceManager().\
                createWorkspace(name, description, workspaceClass=workingClass)
            self.getWorkspaceManager().setActiveWorkspace(w)
            self.getModelController().setWorkspace(w)

            self.getMainWindow().refreshWorkspaceTreeView()

            self.getMainWindow().getWorkspaceTreeView().loadAllWorkspaces()

    def openWorkspace(self, name):
        self.saveWorkspaces()
        try:
            workspace = self.getWorkspaceManager().openWorkspace(name)
            self.getModelController().setWorkspace(workspace)
        except Exception:
            model.api.log("An exception was captured while opening \
                workspace %s\n%s" % (name, traceback.format_exc()), "ERROR")

########NEW FILE########
__FILENAME__ = appstyle
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

"""
Custom GUI Styles for the application
"""
             
                                                
                                                
                                          
                                                     

import qt

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

class CustomWindowsStyle(qt.QWindowsStyle):
    def __init__(self):
        qt.QWindowsStyle.__init__(self)

                                    
                        
                                    

class CustomCommonStyle(qt.QCommonStyle):
    def __init__(self):
        qt.QCommonStyle.__init__(self)

########NEW FILE########
__FILENAME__ = configdialog
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import qt
import os
from gui.qt3.dialogs import BaseDialog

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()


class ConfigurationPage(qt.QVBox):
    def __init__(self, parent=None):
        super(ConfigurationPage, self).__init__(parent)
        configGroup = qt.QHGroupBox("Server configuration", self)
        serverLabel = qt.QLabel("Server:", configGroup)
        serverCombo = qt.QComboBox(configGroup)
        serverCombo.insertItem("Trolltech (Australia)")
        serverCombo.insertItem("Trolltech (Germany)")
        serverCombo.insertItem("Trolltech (Norway)")
        serverCombo.insertItem("Trolltech (People's Republic of China)")
        serverCombo.insertItem("Trolltech (USA)")
                           

class UpdatePage(qt.QVBox):
    def __init__(self, parent=None):
        super(UpdatePage, self).__init__(parent)

        updateGroup = qt.QVGroupBox("Package selection", self)
        systemCheckBox = qt.QCheckBox("Update system", updateGroup)
        appsCheckBox = qt.QCheckBox("Update applications", updateGroup)
        docsCheckBox = qt.QCheckBox("Update documentation", updateGroup)

        packageGroup = qt.QHGroupBox("Existing packages", self)
        packageList = qt.QListView(packageGroup)               
        packageList.addColumn("")
        packageList.setColumnWidthMode(0, qt.QListView.Maximum)
        packageList.setColumnWidth(0, packageList.width())

        qtItem = qt.QListViewItem(packageList)                              
        qtItem.setText(0, "Qt")
        qsaItem = qt.QListViewItem(packageList)
        qsaItem.setText(0, "QSA")
        teamBuilderItem = qt.QListViewItem(packageList)
        teamBuilderItem.setText(0, "Teambuilder")
        self.setSpacing(12)
        startUpdateButton = qt.QPushButton("Start update", self)
                                 


class ConfigDialog(BaseDialog):
    def __init__(self, parent=None, configuration=None):
        BaseDialog.__init__(self, parent, "Config Dialog",
                            layout_margin=10, layout_spacing=15, modal=True)

        self.configuration = configuration

        hbox = qt.QHBox(self)

        self.contentsWidget = qt.QIconView(hbox)               

                                                               
                                                          
                                                             
        self.contentsWidget.setMaximumWidth(128)
                                           

        self.pagesWidget = qt.QWidgetStack(hbox)                         
        self.pagesWidget.addWidget(ConfigurationPage(), 0)
        self.pagesWidget.addWidget(UpdatePage(), 1)
        self.pagesWidget.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
                                                

        self.createIcons()
        hbox.setStretchFactor(self.contentsWidget, 0)
        hbox.setStretchFactor(self.pagesWidget, 10)
        self.layout.addWidget(hbox)

                                                                           
        self.setupButtons({
            "ok": None,
            "cancel" : self.close,
            })


    def changePage(self, item):
        if item:
            current = self.contentsWidget.currentItem()
            self.pagesWidget.raiseWidget(self.contentsWidget.index(current))

    def createIcons(self):
        configButton = qt.QIconViewItem(self.contentsWidget)
        configButton.setPixmap(qt.QPixmap(os.path.join(CONF.getIconsPath(), 'config.png')))
        configButton.setText("Configuration")
                                                                             

                                                                                    

        updateButton = qt.QIconViewItem(self.contentsWidget)
        updateButton.setPixmap(qt.QPixmap(os.path.join(CONF.getIconsPath(), 'update.png')))
        updateButton.setText("Update")
                                                                             
                                                                                    

        self.connect(self.contentsWidget, qt.SIGNAL('clicked(QIconViewItem*)'), self.changePage)

    def sizeHint(self):
        return qt.QSize(600, 350)

########NEW FILE########
__FILENAME__ = customevents
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
"""
This module contains the definition of all the qt.QCustomEvent's used
in the application.
These events are needed to communicate secondary threads with the GUI.

"""
import qt
from gui.customevents import (LOGEVENT_ID, SHOWDIALOG_ID, SHOWPOPUP_ID,
                              EXCEPTION_ID, RENAMEHOSTSROOT_ID,
                              CLEARHOSTS_ID, DIFFHOSTS_ID, SYNCFAILED_ID,
                              CONFLICTS_ID, WORKSPACE_CHANGED, CONFLICT_UPDATE,
                              RESOLVECONFLICTS_ID, UPDATEMODEL_ID, ADDHOST,
                              EDITHOST, DELHOST)


class LogCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.text = e.text


class ShowDialogCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.text = e.text


class ShowPopupCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.text = e.text
        self.level = e.level


class ShowExceptionCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.text = e.text
        self.exception_objects = e.exception_objects
        self.callback = e.callback


class RenameHostsRootCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.name = e.name


class WorkspaceChangedCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.workspace = e.workspace


class ConflictUpdatedCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.nconflicts = e.nconflicts


class DiffHostsCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.new_host = e.new_host
        self.old_host = e.old_host


class ResolveConflictsCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.conflicts = e.conflicts


class ClearHostsCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())


class ModelObjectUpdateEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.hosts = e.hosts


class AddHostCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.host = e.host


class EditHostCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.host = e.host


class DeleteHostCustomEvent(qt.QCustomEvent):
    def __init__(self, e):
        qt.QCustomEvent.__init__(self, e.type())
        self.host_id = e.host_id


class QtCustomEvent(qt.QCustomEvent):
    events = {
        LOGEVENT_ID: LogCustomEvent,
        SHOWDIALOG_ID: ShowDialogCustomEvent,
        SHOWPOPUP_ID: ShowPopupCustomEvent,
        EXCEPTION_ID: ShowExceptionCustomEvent,
        RENAMEHOSTSROOT_ID: RenameHostsRootCustomEvent,
        CLEARHOSTS_ID: ClearHostsCustomEvent,
        DIFFHOSTS_ID: DiffHostsCustomEvent,
        SYNCFAILED_ID: None,
        CONFLICTS_ID: None,
        WORKSPACE_CHANGED: WorkspaceChangedCustomEvent,
        CONFLICT_UPDATE: ConflictUpdatedCustomEvent,
        RESOLVECONFLICTS_ID: ResolveConflictsCustomEvent,
        UPDATEMODEL_ID: ModelObjectUpdateEvent,
        ADDHOST: AddHostCustomEvent,
        DELHOST: DeleteHostCustomEvent,
        EDITHOST: EditHostCustomEvent
    }

    @staticmethod
    def create(custom_event):
        return QtCustomEvent.events[custom_event.type()](custom_event)

########NEW FILE########
__FILENAME__ = dialogs
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import os
import qt
import model.api as api
import model.guiapi as guiapi
import re
import model.hosts as hosts
from model.workspace import WorkspaceManager
from ui.plugin_settings import *
from ui.vulnerabilities import *
from ui.preferences import *
from ui.noteslist import NotesListUI
from ui.evidenceslist import *
from edition import EditionTable, HostEditor, ServiceEditor, InterfaceEditor, NoteEditor, NewNoteDialog, VulnEditor, NewVulnDialog, VulnWebEditor, NewCredDialog, CredEditor
from modelobjectitems import NoteRootItem, VulnRootItem, CredRootItem

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

                                                                       
                                               
class LogConsole(qt.QVBox):
    """
    widget component used to display a log or any other content in
    a small console window
    """
    tag_regex = re.compile(r"^(\[(.*)\]\s+-).*$", re.DOTALL)
    tag_replace_regex = re.compile(r"^(\[(.*)\]\s+-)")
    tag_colors = {
        "NOTIFICATION" : "#1400F2",
        "INFO" : "#000000",
        "WARNING" : "#F5760F",
        "ERROR" : "#FC0000",
        "CRITICAL": "#FC0000",
        "DEBUG" : "#0AC400",
    }

    def __init__(self, parent, caption=""):
        qt.QVBox.__init__(self, parent)
        self.setName(caption)
        self._text_edit = qt.QTextEdit(self, caption)
                                           
        self._text_edit.setTextFormat(qt.Qt.LogText)

    def customEvent(self, event):
        self.update(event)

    def update(self, event):
        if event.type() == 3131:
            self.appendText(event.text)

    def appendText(self, text):
        """
        appends new text to the console
        """
        m = self.tag_regex.match(text)
        if m is not None:
            tag = m.group(2).upper()
            colored_tag = "<font color=\"%s\"><b>[%s]</b></font> -" % (self.tag_colors.get(tag, "#000000"), tag)
            text = self.tag_replace_regex.sub(colored_tag, text)
        else:
            text = "<font color=\"#000000\"><b>[INFO]</b></font> - %s" % text

        self._text_edit.append(text)

    def clear(self):
        """
        Clear the console
        """
        self._text_edit.clear()

    def sizeHint(self):
        """Returns recommended size of dialog."""
        return qt.QSize(90, 30)

                                                                                

class BaseDialog(qt.QDialog):

    def __init__(self, parent, name, layout_margin=0, layout_spacing=-1, modal=True):
        qt.QDialog.__init__(self, parent, name, modal)
        if layout_spacing == -1:
            layout_spacing =  self.fontMetrics().height()

        self.layout = qt.QVBoxLayout(self, layout_margin, layout_spacing, "layout")
        self.button_box = None
        self.ok_button = None
        self.cancel_button = None
        self.quit_button = None

    def setupButtons(self, buttons=None):
        """
        Creates and setup buttons clicked singal connection using callbacks provided
        The buttons parameter must be a dict with keys (in lowercase)
        "ok", "cancel" or "quit" and a callback reference as value.
        If None is provided as callback value then default behaviour will
        be applied to the button (accept for Ok, reject for cancel and quit)
        Button order will be always Ok, Cancel and Quit
        This will add only the buttons provided in the buttons parameter, so not all
        keys must be used. You can add only the ones needed.
        If no parameter is provided, OK and Cancel buttons will be added with
        their default behaviour.
        IMPORTANT: if callbacks do not call accept or reject methods, then
        the dialog won't end and will be visible. Remember to call accept &
        reject internally on your provided callbacks
        """
        self.button_box = qt.QHBoxLayout(self.layout)
        spacer = qt.QSpacerItem(0,0,qt.QSizePolicy.Expanding,qt.QSizePolicy.Minimum)
        self.button_box.addItem(spacer)

        if buttons is None:
            self._addOkButton()
            self._addCancelButton()
        else:
            if "ok" in buttons:
                self._addOkButton(buttons["ok"])
            if "cancel" in buttons:
                self._addCancelButton(buttons["cancel"])
            if "quit" in buttons:
                self._addQuitButton(buttons["quit"])

    def _addOkButton(self, callback=None):
        self.ok_button = qt.QPushButton( "OK", self )
        self.button_box.addWidget( self.ok_button )
        if callback is None:
            callback = self.accept
        self.connect( self.ok_button, qt.SIGNAL('clicked()'), callback )

    def _addCancelButton(self, callback=None):
        self.cancel_button = qt.QPushButton("Cancel", self)
        self.button_box.addWidget( self.cancel_button )
        if callback is None:
            callback = self.reject
        self.connect( self.cancel_button, qt.SIGNAL('clicked()'), callback)

    def _addQuitButton(self, callback=None):
        self.quit_button = qt.QPushButton("Quit", self)
        self.button_box.addWidget( self.quit_button )
        if callback is None:
            callback = self.reject
        self.connect( self.quit_button, qt.SIGNAL('clicked()'), callback)

    def sizeHint(self):
                                                                  
        return qt.QSize(400, 150)

                                                                                

class LoginDialog(BaseDialog):
    def __init__(self, parent, callback):
        BaseDialog.__init__(self, parent, "Login",
                            layout_margin=10, layout_spacing=15, modal=True)

        self._auth_callback = callback
        self.setCaption("Login")

        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        self._username_label = qt.QLabel("Username", hbox1)
        self._username_edit = qt.QLineEdit(hbox1)
        self.layout.addWidget(hbox1)

        hbox2 = qt.QHBox(self)
        hbox2.setSpacing(10)
        self._password_label = qt.QLabel("Password", hbox2)
        self.__password_edit = qt.QLineEdit(hbox2)
        self.__password_edit.setEchoMode(qt.QLineEdit.Password)
        self.layout.addWidget(hbox2)

        self.__username_txt = self._username_edit.text()
        self.__passwd_txt = self.__password_edit.text()

        self.setupButtons({
            "ok" : self._login,
            "cancel" : self._clear,
            "quit" : None,
            })

    def getData(self):
        self.__username_txt = self._username_edit.text()
        self.__passwd_txt = self.__password_edit.text()
        return self.__username_txt.latin1(), self.__passwd_txt.latin1()

    def _login(self):
                                                                 
                               
        self.__username_txt = self._username_edit.text()
        self.__passwd_txt = self.__password_edit.text()
        api.devlog("Username: %s\nPassword: %s" %(self.__username_txt, self.__passwd_txt))
        self.accept()

    def _clear(self):
                                          
        self._username_edit.clear()
        self.__password_edit.clear()

    def sizeHint(self):
        return qt.QSize(250, 100)

                                                                                

class DebugPersistenceDialog(BaseDialog):

    def __init__(self, parent):
        BaseDialog.__init__(self, parent, "PersistenceDebugDialog",
                            layout_margin=15, layout_spacing=10, modal=True)
        self.setCaption( 'Persistence Debug Dialog' )

        self.layout.addWidget( self.logolabel )
        self.layout.addWidget( self.text )
        self.setupButtons({"ok" : None})

                                                                                

class ConflictResolutionDialog(BaseDialog):
    def __init__(self, conflicts, parent=None, name=None):

        BaseDialog.__init__(self, parent, "Conflicts",
                            layout_margin=10, layout_spacing=15, modal=True)

        self.conflict = None
        self.conflict_iterator = iter(conflicts)
        self.first_object = None
        self.second_object = None

        hbox = qt.QHBoxLayout()

        vbox = qt.QVBoxLayout()
        self.label_first_object = qt.QLabel("", self)
        vbox.addWidget(self.label_first_object)
        self.detailtable_first_object = EditionTable(self)
        self.editor_first_object = None
        vbox.addWidget(self.detailtable_first_object)
        self.choice_button_first_object = qt.QRadioButton(self, "")
        vbox.addWidget(self.choice_button_first_object)

        hbox.addLayout(vbox)

        vbox = qt.QVBoxLayout()
        self.label_second_object = qt.QLabel("", self)
        vbox.addWidget(self.label_second_object)
        self.detailtable_second_object = EditionTable(self)
        self.editor_second_object = None
        vbox.addWidget(self.detailtable_second_object)
        self.choice_button_second_object = qt.QRadioButton(self, "")
        vbox.addWidget(self.choice_button_second_object)

        self.object_group_button = qt.QButtonGroup()
        self.object_group_button.insert(self.choice_button_first_object)
        self.object_group_button.insert(self.choice_button_second_object)
        
        hbox.addLayout(vbox)

        self.layout.addLayout(hbox)

        self.setupButtons({"ok": self.resolve, "cancel": self.quit})

        self.del_callback = None
        self.add_callback = None

        self.setup()

    def setup(self):
        self.getNextConflict()
        if self.conflict:
            self.setupConflict()
        else:
            self.accept()

    def getNextConflict(self):
        try:
            self.conflict = self.conflict_iterator.next()
        except StopIteration:
            self.conflict = None

    def setupConflict(self):
        if not self.conflict:
            return

        self.first_object = self.conflict.getFirstObject()
        self.second_object = self.conflict.getSecondObject()
        type = self.conflict.getModelObjectType()
        
        self.setCaption(type)
        name_first_object = self.first_object.getName()
        name_second_object = self.second_object.getName()
        if self.first_object.getParent() is not None:
            name_first_object += " (Host: %s)" % self.first_object.getHost().getName()
            name_second_object += " (Host: %s)" % self.first_object.getHost().getName()
        self.label_first_object.setText(name_first_object)
        self.label_second_object.setText(name_second_object)

        if type == "Host":
            self.editor_first_object = HostEditor(self.first_object)
            self.editor_second_object = HostEditor(self.second_object)
        elif type == "Interface":
            self.editor_first_object = InterfaceEditor(self.first_object)
            self.editor_second_object = InterfaceEditor(self.second_object)
        elif type == "Service":
            self.editor_first_object = ServiceEditor(self.first_object)
            self.editor_second_object = ServiceEditor(self.second_object)

        self.editor_first_object.fillEditionTable(self.detailtable_first_object)
                                               
        self.editor_second_object.fillEditionTable(self.detailtable_second_object)
                                                

    def getSelectedEditor(self):
        if self.choice_button_first_object.isChecked():
            editor = self.editor_first_object
        elif self.choice_button_second_object.isChecked():
            editor = self.editor_second_object
        else:
            editor = None
        return editor

    def resolve(self):
        editor_selected = self.getSelectedEditor()
        if editor_selected:
            guiapi.resolveConflict(self.conflict, editor_selected.getArgs())
        self.setup()

    def quit(self):
        self.reject()

    def sizeHint(self):
        return qt.QSize(750, 500)

                                                                                

class ModelObjectListViewItem(qt.QListViewItem):
    def __init__(self, qtparent, model_object=None):
        qt.QListViewItem.__init__(self, qtparent)
        self.model_object = model_object
        if self.model_object:
            self.setText(0, model_object.name)
        else:
            self.setText(0, "")

    def getModelObject(self):
        return self.model_object

class ListableObjecttDialog(BaseDialog):
    def __init__(self, parent=None, title=None, model_object=None, objects_list = [], layout_margin=10, layout_spacing=15, modal=True):
        BaseDialog.__init__(self, parent, title,
                            layout_margin=10, layout_spacing=15, modal=True)

        hbox = qt.QHBoxLayout()
        vbox1 = qt.QVBoxLayout()
        vbox1.setMargin(5)
        vbox2 = qt.QVBoxLayout()
        vbox2.setMargin(5)
        self.model_object = model_object
        self.objects_list = objects_list
        self._selected_object = None
        self._current_item = None
        self._selected_items = []
        self.edition_layout = None
        self.title = title
        
        self.listview = qt.QListView(self)
        self.listview.setSorting(-1)
        self.listview.setSelectionMode(qt.QListView.Extended)
        self.connect(self.listview, qt.SIGNAL("selectionChanged()"), self._itemSelected)
        self.listview.addColumn(title, self.listview.size().width())
        self.listview.setColumnWidthMode(0, qt.QListView.Maximum)
        self.setListItems()

        vbox1.addWidget(self.listview)
        
        self.button_box1 = qt.QHBoxLayout()
        self.add_button = qt.QPushButton("Add", self)
        self.add_button.setMaximumSize(qt.QSize(100, 25))
        self.connect(self.add_button, qt.SIGNAL('clicked()'), self.addValue)
        self.remove_button = qt.QPushButton("Remove", self)
        self.remove_button.setMaximumSize(qt.QSize(100, 25))
        self.connect(self.remove_button, qt.SIGNAL('clicked()'), self.removeValue)
        self.button_box1.addWidget(self.add_button)
        self.button_box1.addWidget(self.remove_button)
        self.button_box1.addStretch(1)

        vbox1.addLayout(self.button_box1)

        self.setupEditor(vbox2)

        self.button_box2 = qt.QHBoxLayout()
        self.save_button = qt.QPushButton("Save", self)
        self.save_button.setMaximumSize(qt.QSize(100, 25))
        self.connect(self.save_button, qt.SIGNAL('clicked()'), self.saveValue)
        self.button_box2.addWidget(self.save_button)
        self.button_box2.addStretch(1)

        vbox2.addLayout(self.button_box2)
        
        hbox.setSpacing(6)
        hbox.addLayout(vbox1)
        hbox.addLayout(vbox2)
        self.layout.addLayout(hbox)

        self.setupButtons({"quit": None})

    def setupEditor(self, parent_layout):
        pass

    def saveValue(self):
        pass

    def addValue(self):
        pass

    def removeValue(self):
        pass

    def _itemSelected(self):
        self.edition_layout.clear()
        self._current_item = self.listview.currentItem()
        i = self.listview.firstChild()
        self._selected_items=[]
        while i is not None:
            if i.isSelected():
                self._selected_items.append(i)
            i = i.itemBelow()
        self.setEdition()

    def sizeHint(self):
        return qt.QSize(750, 500)

class NotesDialog(ListableObjecttDialog):
    def __init__(self, parent=None, model_object=None):
        ListableObjecttDialog.__init__(self, parent, "Notes", model_object, model_object.getNotes(),
                            layout_margin=10, layout_spacing=15, modal=True)

    def setupEditor(self, parent_layout):
        self.edition_layout = NoteEditor(self)
        parent_layout.addLayout(self.edition_layout)

    def setListItems(self):
        self.listview.clear()
        self.rootitem = NoteRootItem(self.listview, self.title, self.model_object)
        for obj in self.model_object.getNotes():
            self.rootitem.addNote(obj)

    def setEdition(self):
        if self._current_item is not None:
            if self._current_item.type == "Note":
                self.edition_layout.setNote(self._current_item.getModelObject())
        
    def saveValue(self):
        if self._current_item is not None:
            if self._current_item.type == "Note":
                note = self._current_item.getModelObject()
                kwargs = self.edition_layout.getArgs()
                if kwargs["name"] and kwargs["text"]:
                    guiapi.editNote(note, **kwargs)
                    self.setListItems()

    def addValue(self):
        dialog = NewNoteDialog(self, callback=self.__addValue)
        dialog.exec_loop()
    
    def __addValue(self, *args):
        obj = self.rootitem.getModelObject()
        if self._current_item:
            obj = self._current_item.getModelObject()
        guiapi.createAndAddNote(obj, *args)
        self.setListItems()

    def removeValue(self):
        for item in self._selected_items: 
            if item.type == "Note":
                note = item.getModelObject()
                guiapi.delNote(note.getParent(), note.getID())
        self.setListItems()
        self.edition_layout.clear()
                    

    def sizeHint(self):
        return qt.QSize(750, 500)


class VulnsDialog(ListableObjecttDialog):
    def __init__(self, parent=None, model_object=None):
        ListableObjecttDialog.__init__(self, parent, "Vulns", model_object, model_object.getVulns(),
                            layout_margin=10, layout_spacing=15, modal=True)

    def setupEditor(self, parent_layout):
        self._widget_stack = qt.QWidgetStack(self)

        self._vuln_edition_widget = qt.QFrame()
        self._vuln_edition_layout = VulnEditor(self._vuln_edition_widget)
        
        self._vuln_web_scrollbar_view = qt.QScrollView()
        self._vuln_web_scrollbar_view.setResizePolicy(qt.QScrollView.AutoOneFit)
        self._vuln_web_edition_widget = qt.QFrame(self._vuln_web_scrollbar_view.viewport())
        self._vuln_web_edition_layout = VulnWebEditor(self._vuln_web_edition_widget)
        self._vuln_web_edition_layout.setMargin(5)
        self._vuln_web_scrollbar_view.addChild(self._vuln_web_edition_widget)
        
        self._widget_stack.addWidget(self._vuln_edition_widget, 0)
        self._widget_stack.addWidget(self._vuln_web_scrollbar_view, 1)
        self._widget_stack.raiseWidget(self._vuln_edition_widget)
        
        self._vuln_edition_widget.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Ignored, qt.QSizePolicy.Ignored))
        self._vuln_web_edition_widget.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Ignored, qt.QSizePolicy.Ignored))
        
        self.edition_layout = self._vuln_edition_widget.layout()
        
        parent_layout.addWidget(self._widget_stack)

    def setListItems(self):
        self.listview.clear()
        self.rootitem = VulnRootItem(self.listview, self.title, self.model_object)
        for obj in self.model_object.getVulns():
            self.rootitem.addVuln(obj)

    def setEdition(self):
        if self._current_item is not None:
            if self._current_item.type == "Vuln" or self._current_item.type == "VulnWeb":
                widget = self._vuln_edition_widget
                self._widget_stack.raiseWidget(widget)
                if self._current_item.type == "VulnWeb":
                    widget = self._vuln_web_edition_widget
                    self._widget_stack.raiseWidget(self._vuln_web_scrollbar_view)
                self.edition_layout = widget.layout()
                self.edition_layout.setVuln(self._current_item.getModelObject())
        
    def saveValue(self):
        if self._current_item is not None:
            if self._current_item.type == "Vuln" or self._current_item.type == "VulnWeb":
                vuln = self._current_item.getModelObject()
                kwargs = self.edition_layout.getArgs()
                if kwargs["name"] and kwargs["desc"]:
                    if self._current_item.type == "Vuln":
                        guiapi.editVuln(vuln, **kwargs)
                    else:
                        guiapi.editVulnWeb(vuln, **kwargs)
                    self.setListItems()

    def addValue(self):
        vuln_web_enabled = False
        if self.model_object.class_signature == "Service":
            vuln_web_enabled = True
        dialog = NewVulnDialog(self, callback=self.__addValue, vuln_web_enabled=vuln_web_enabled)
        dialog.exec_loop()
    
    def __addValue(self, *args):
                               
                                                      
        obj = self.model_object
        if args[0]:
                     
            guiapi.createAndAddVulnWeb(obj, *args[1:])
        else:
            guiapi.createAndAddVuln(obj, *args[1:])
        self.setListItems()

    def removeValue(self):
        for item in self._selected_items: 
            if item.type == "Vuln" or item.type == "VulnWeb":
                vuln = item.getModelObject()
                guiapi.delVuln(vuln.getParent(), vuln.getID())
        self.setListItems()
        self.edition_layout.clear()

    def sizeHint(self):
        return qt.QSize(850, 500)


class CredsDialog(ListableObjecttDialog):
    def __init__(self, parent=None, model_object=None):
        ListableObjecttDialog.__init__(self, parent, "Credentials", model_object, model_object.getCreds(),
                            layout_margin=10, layout_spacing=15, modal=True)

    def setupEditor(self, parent_layout):
        self.edition_layout = CredEditor(self)
        parent_layout.addLayout(self.edition_layout)

    def setListItems(self):
        self.listview.clear()
        self.rootitem = CredRootItem(self.listview, self.title, self.model_object)
        for obj in self.model_object.getCreds():
            self.rootitem.addCred(obj)

    def setEdition(self):
        if self._current_item is not None:
            if self._current_item.type == "Cred":
                self.edition_layout.setCred(self._current_item.getModelObject())
        
    def saveValue(self):
        if self._current_item is not None:
            if self._current_item.type == "Cred":
                cred = self._current_item.getModelObject()
                kwargs = self.edition_layout.getArgs()
                if kwargs["username"] and kwargs["password"]:
                    guiapi.editCred(cred, **kwargs)
                    self.setListItems()

    def addValue(self):
        dialog = NewCredDialog(self, callback=self.__addValue)
        dialog.exec_loop()
    
    def __addValue(self, *args):
        obj = self.rootitem.getModelObject()
        guiapi.createAndAddCred(obj, *args)
        self.setListItems()

    def removeValue(self):
        for item in self._selected_items: 
            if item.type == "Cred":
                cred = item.getModelObject()
                guiapi.delCred(cred.getParent(), cred.getID())
        self.setListItems()
        self.edition_layout.clear()
                    

    def sizeHint(self):
        return qt.QSize(750, 500)


class AboutDialog(BaseDialog):

    def __init__(self, parent):
        BaseDialog.__init__(self, parent, "AboutDialog",
                            layout_margin=15, layout_spacing=10, modal=True)
        self.setCaption( 'About %s' % CONF.getAppname() )

        self.logo = qt.QPixmap( os.path.join(CONF.getImagePath(),"about.png") )
        self.logolabel = qt.QLabel( self )
        self.logolabel.setPixmap( self.logo )
        self.logolabel.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )
                                                                           
                                                              

        self._about_text = u"""%s v%s""" % (CONF.getAppname(),CONF.getVersion())

        self.text = qt.QLabel( self._about_text, self )
        self.text.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )

        self.layout.addWidget( self.logolabel )
        self.layout.addWidget( self.text )
        self.setupButtons({"ok" : None})


                                                                                
class RepositoryConfigDialog(BaseDialog):

    def __init__(self, parent, url="http://example:5984", replication = False, replics = "", callback=None):
        BaseDialog.__init__(self, parent, "RepositoryConfig",
                            layout_margin=25, layout_spacing=20, modal=True)

        self._callback = callback
        
        self.setCaption("Repository Configuration")

        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(10)
        self._repourl_label = qt.QLabel("CouchDB URL", hbox1)
        self._repourl_edit = qt.QLineEdit(hbox1)
        if url: self._repourl_edit.setText(url)
        self.layout.addWidget(hbox1)

        hbox2 = qt.QHBox(self)
        hbox2.setSpacing(5)
        self._replicate_label = qt.QLabel("Replication enabled", hbox2)
        self._replicate_edit = qt.QCheckBox(hbox2)
        self._replicate_edit.setChecked(replication)
                                                               
        self.layout.addWidget(hbox2)

        hbox3 = qt.QHBox(self)
        hbox3.setSpacing(10)
        self._replics_label = qt.QLabel("Replics", hbox3)
        self.__replics_edit = qt.QLineEdit(hbox3)
        if replics: self.__replics_edit.setText(replics)
        self.layout.addWidget(hbox3)

        self.__repourl_txt = self._repourl_edit.text()
        self.__is_replicated_bool = self._replicate_edit.isChecked()
        self.__replics_list_txt = self.__replics_edit.text()


        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
                          })

    def getData(self):
        self.__repourl_txt = self._repourl_edit.text()
        self.__is_replicated_bool = self._replicate_edit.isChecked()
        self.__replics_list_txt = self.__replics_edit.text()
        return (self.__repourl_txt.latin1(), 
            self.__is_replicated_bool,
            self.__replics_list_txt.latin1())

    def ok_pressed(self):
        if self._callback is not None:
            self._callback(*self.getData())
        self.accept()

                                                                                

class ExceptionDialog(BaseDialog):

    def __init__(self, parent, text="", callback=None, excection_objects=None):
        BaseDialog.__init__(self, parent, "ExceptionDialog",
                            layout_margin=10, layout_spacing=15, modal=True)
        self._callback = callback
        self._excection_objects = excection_objects
        self.setCaption('Error')

        label1 = qt.QLabel("An unhandled error ocurred...", self )
        label1.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )
        self.layout.addWidget(label1)

        exception_textedit = qt.QTextEdit(self)
        exception_textedit.setTextFormat(qt.Qt.LogText)
        exception_textedit.append(text)
        self.layout.addWidget(exception_textedit)

        label2 = qt.QLabel("""Do you want to collect information and send it to Faraday developers?\n\
If you press Cancel the application will just continue.""", self )
        label2.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )
        self.layout.addWidget(label2)

        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
                          })
    def ok_pressed(self):
        if self._callback is not None:
            self._callback(*self._excection_objects)
        self.accept()

    def sizeHint(self):
        return qt.QSize(680, 300)
                                                                                

class SimpleDialog(BaseDialog):

    def __init__(self, parent, text="", type="Information"):
        BaseDialog.__init__(self, parent, "SimpleDialog",
                            layout_margin=10, layout_spacing=10, modal=True)
        self.setCaption(type)

                                                   
        self.text = qt.QLabel(self)
        self.text.setTextFormat(qt.Qt.RichText)
        self.text.setText(text.replace("\n", "<br>"))                          
        self.text.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )
        self.layout.addWidget( self.text )
        self.setupButtons({"ok" : None})


class ExitDialog(BaseDialog):
    def __init__(self, parent, callback=None):
        BaseDialog.__init__(self, parent, "ExitDialog",
                            layout_margin=20, layout_spacing=15, modal=True)
        self.setCaption("Exit")
                                        
        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        self._message_label = qt.QLabel("Are you sure?", hbox1)
        self._message_label.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )
        self.layout.addWidget(hbox1)
        self.setupButtons({ "ok" : callback,
                            "cancel" : None
                          })

    def sizeHint(self):
        return qt.QSize(50, 50)

                                                                                

class MessageDialog(BaseDialog):
    def __init__(self, parent, callback=None , title="Are you sure?", msg="Are you sure?", item=None):
        BaseDialog.__init__(self, parent, "ExitDialog",
                            layout_margin=20, layout_spacing=15, modal=True)
        self.setCaption(title)
                                        
        self._callback = callback
        self._item=item
        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        self._message_label = qt.QLabel(msg, hbox1)
        self._message_label.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )
        self.layout.addWidget(hbox1)
        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
                          })
    def ok_pressed(self):
        if self._callback is not None:
            self._callback(self._item)
        self.accept()    

    def sizeHint(self):
        return qt.QSize(50, 50)

                                                                                

class VulnDialog(BaseDialog):

    def __init__(self, parent, name="",description="", ref="", callback=None, item=None):
        BaseDialog.__init__(self, parent, "VulnDialog",
                            layout_margin=10, layout_spacing=15, modal=True)
                                                                                     
        self._item = item
        self._callback = callback
        self.setCaption("New vulnerability" if name is "" else "Vuln %s" % item.name)

                      

        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        name_label = qt.QLabel("Name", hbox1)
        self._name_edit = qt.QLineEdit(hbox1)
        if name: self._name_edit.setText(name)
        self.layout.addWidget(hbox1)
        
        hbox2 = qt.QHBox(self)
        hbox2.setSpacing(5)
        ref_label = qt.QLabel("Ref", hbox2)
        self._ref_edit = qt.QLineEdit(hbox2)
        if ref: self._ref_edit.setText(ref)
        self.layout.addWidget(hbox2)

        vbox6 = qt.QVBox(self)
        vbox6.setSpacing(5)
        description_label = qt.QLabel("Description:", vbox6 )
                                                                                  
        self._description_edit = qt.QTextEdit(vbox6)
        self._description_edit.setTextFormat(qt.Qt.PlainText)
        if description: self._description_edit.append(description)
        self.layout.addWidget(vbox6)

        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
                          })
    def ok_pressed(self):
        if self._callback is not None:
            if self._name_edit.text() != "":
                self._callback("%s" % self._name_edit.text(),"%s" % self._description_edit.text(),
                "%s" % self._ref_edit.text(),self._item)
                self.accept()
            else:
                dialog = SimpleDialog(self, "Please select a name")
                dialog.exec_loop()

    def sizeHint(self):
        return qt.QSize(600, 400)


class CategoryDialog(BaseDialog):

    def __init__(self, parent, name="", callback=None, item=None):
        BaseDialog.__init__(self, parent, "CategoryDialog",
                            layout_margin=10, layout_spacing=15, modal=True)
                                                                                           
        self._item = item
        self._callback = callback
        self.setCaption("New category" if name is "" else "Category in %s" % item.name)

        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        name_label = qt.QLabel("Name", hbox1)
        self._name_edit = qt.QLineEdit(hbox1)
        if name: self._name_edit.setText(name)
        self.layout.addWidget(hbox1)

        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
                          })

    def ok_pressed(self):
        if self._callback is not None:
            if self._name_edit.text() != "":
                self._callback("%s" % self._name_edit.text(), self._item)
                self.accept()
            else:
                dialog = SimpleDialog(self, "Please select a name")
                dialog.exec_loop() 

    def sizeHint(self):
        return qt.QSize(600, 400)

                                                                                

class NoteDialog(BaseDialog):

    def __init__(self, parent, name="", text="", callback=None, item=None):
        BaseDialog.__init__(self, parent, "NoteDialog",
                            layout_margin=10, layout_spacing=15, modal=True)
                                                                                  
        self._item = item
        self._callback = callback
        self.setCaption("New note" if name is "" else "Note %d" % item.id)

        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        name_label = qt.QLabel("Name", hbox1)
        self._name_edit = qt.QLineEdit(hbox1)
        if name: self._name_edit.setText(name)
        self.layout.addWidget(hbox1)

        vbox2 = qt.QVBox(self)
        vbox2.setSpacing(3)
        content_label = qt.QLabel("Note content:", vbox2 )
                                                                              
        self._textedit = qt.QTextEdit(vbox2)
        self._textedit.setTextFormat(qt.Qt.PlainText)
        if text: self._textedit.append(text)
        self.layout.addWidget(vbox2)

        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
                          })
    def ok_pressed(self):
        if self._callback is not None:        
            if self._name_edit.text() != "":
                if self._item is not None:
                    self._callback(self._name_edit.text(), self._textedit.text(),self._item)
                else:
                    self._callback(self._name_edit.text(), self._textedit.text())
                self.accept()
            else:
                dialog = SimpleDialog(self, "Please select a name")
                dialog.exec_loop()   

    def sizeHint(self):
        return qt.QSize(600, 400)

                                                                                

            
class NotificationWidget(qt.QLabel):
    def __init__(self, parent, text=""):
        qt.QLabel.__init__(self, parent, "notification")
        pal = qt.QPalette()
        color = qt.QColor(232, 226, 179, qt.QColor.Rgb)
        pal.setColor(qt.QColorGroup.Background, color)
        self.setTextFormat(qt.Qt.RichText)
        self.setText(text.replace("\n", "<br>"))                          
        self.setFrameStyle(qt.QFrame.PopupPanel | qt.QFrame.Plain)
        self.setAlignment( qt.Qt.AlignHCenter | qt.Qt.AlignVCenter )
        self.setPalette(pal)
        
        _w,_h=self._getsize(text)
        self.resize(qt.QSize(_w,_h))
                                                                                          
        self._updatePos(parent)
        
    def _getsize(self, text):
        _tlist=text.split("\n")
        _width=0
        _w=10
        for i in _tlist:
            _size=len(i)
            if _size > _width:
                _width = _size
                if _size > 80 and len(i.split(" ")) <=2:
                    _w=12   
                                                                               
    
        return _width*_w,(28*len(text.split("\n")))
    

    def _updatePos(self, parent):
        pos = qt.QPoint()
        pos.setX(parent.width() - self.width() - 5)
        pos.setY(parent.height() - self.height() - 20)
        self.move(pos)

    def closeNotification(self):
        self.hide()
        parent = self.parent()
        parent.removeChild(self)
        self.destroy()

                                                                                

class WorkspacePropertiesDialog(BaseDialog):

    def __init__(self, parent, text="", callback=None, workspace=None):
        BaseDialog.__init__(self, parent, "WorkspacePropertiesDialog",
                            layout_margin=10, layout_spacing=15, modal=True)
        self._callback = callback
        self.setCaption('Workspace Properties')
                                                                          

        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        self._name_label = qt.QLabel("Name", hbox1)
        self._name_edit = qt.QLineEdit(hbox1)
        self.layout.addWidget(hbox1)

        hbox2 = qt.QHBox(self)
        self._sdate_edit = qt.QDateEdit(hbox2, "start_date")
        self.layout.addWidget(hbox2)

        hbox3 = qt.QHBox(self)
        self._fdate_edit = qt.QDateEdit(hbox3, "ftart_date")
        self.layout.addWidget(hbox3)

        hbox4 = qt.QHBox(self)
        self._shared_checkbox = qt.QCheckBox("Shared", hbox4, "shared")
        self.layout.addWidget(hbox4)

        hbox5 = qt.QHBox(self)
        hbox5.setSpacing(10)
        self._desc_label = qt.QLabel("Description", hbox5)
        self._desc_edit = qt.QTextEdit(hbox5)
        self.layout.addWidget(hbox5)



        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
        })

    def ok_pressed(self):
                                                                                 
                                                        
        if self._callback is not None:
            name = self._name_edit.text()
            description = self._desc_edit.text()
            sdate = self._sdate_edit.date.toString()
            fdate = self._fdate_edit.date.toString()
            shared = self._shared_checkbox.checked
            self._callback()
        self.accept()

    def sizeHint(self):
        return qt.QSize(600, 400)

                                                                                
                                                                         
                                                       
class WorkspaceCreationDialog(BaseDialog):

    def __init__(self, parent, text="", callback=None, workspace=None):
        BaseDialog.__init__(self, parent, "WorkspaceCreationDialog",
                            layout_margin=10, layout_spacing=15, modal=True)
        self._callback = callback
        self.setCaption('New Workspace')
        self._main_window = parent
        
        hbox1 = qt.QHBox(self)
        hbox1.setSpacing(5)
        self._name_label = qt.QLabel("Name", hbox1)
        self._name_edit = qt.QLineEdit(hbox1)
        self.layout.addWidget(hbox1)

        hbox2 = qt.QHBox(self)
        hbox2.setSpacing(10)
        self._desc_label = qt.QLabel("Description", hbox2)
        self._desc_edit = qt.QTextEdit(hbox2)
        self.layout.addWidget(hbox2)

        hbox3 = qt.QHBox(self)
        hbox3.setSpacing(10)
        self._type_label = qt.QLabel("Type", hbox3)
        self._type_combobox = qt.QComboBox(hbox3)
        self._type_combobox.setEditable(False)
        for w in WorkspaceManager.getAvailableWorkspaceTypes():
            self._type_combobox.insertItem(w)
        self.layout.addWidget(hbox3)

        if len(WorkspaceManager.getAvailableWorkspaceTypes()) <= 1:
            parent.showPopup("No Couch Configuration available. Config, more workpsaces flavors")

        self.__name_txt = self._name_edit.text()
        self.__desc_txt = self._desc_edit.text()
        self.__type_txt = str(self._type_combobox.currentText())

        self.setupButtons({ "ok" : self.ok_pressed,
                            "cancel" : None
                          })
    def ok_pressed(self):
        res = re.match(r"^[a-z][a-z0-9\_\$()\+\-\/]*$", str(self._name_edit.text()))
        if res:
            if self._callback is not None:
                self.__name_txt = str(self._name_edit.text())
                self.__desc_txt = str(self._desc_edit.text())
                self.__type_txt = str(self._type_combobox.currentText())
                self._callback(self.__name_txt, self.__desc_txt, self.__type_txt)
            self.accept()
        else:
            self._main_window.showPopup("A workspace must be named with all lowercase letters (a-z), digits (0-9) or any of the _$()+-/ characters. The name has to start with a lowercase letter (a-z)") 

                                                                                

class PluginSettingsDialog(BaseDialog, PluginSettingsUi):
    def __init__(self, parent=None, plugin_manager=None):
        BaseDialog.__init__(self, parent, "")
        PluginSettingsUi.__init__(self, parent)

        self._plugin_manager = plugin_manager
        if plugin_manager is not None:
            self._plugin_settings = plugin_manager.getSettings()
        else:
            self._plugin_settings = {}

        self._set_connections()

        self._items = {}
        self._params = {}

        self.t_parameters.horizontalHeader().setStretchEnabled(True, 0)

        self._selected_plugin = None
        self._load_plugin_list()

    def _set_connections(self):
        self.connect(self.lw_plugins, qt.SIGNAL("selectionChanged(QListViewItem*)"), self._show_plugin )
        self.connect(self.lw_plugins, qt.SIGNAL("clicked(QListViewItem*)"),
                     self._show_plugin)
        self.connect(self.t_parameters, qt.SIGNAL("valueChanged(int, int)"),
                     self._set_parameter)
        self.connect(self.bt_ok, qt.SIGNAL("clicked()"),
                     self._update_settings)

    def _load_plugin_list(self):
        if self._plugin_manager is None:
            return

        for plugin_id, params in self._plugin_settings.iteritems():
            new_item = qt.QListViewItem(self.lw_plugins, "%s" % params["name"])
            self._items[new_item] = plugin_id

    def _set_parameter(self, row, col):
        settings = self._plugin_settings[self._selected_plugin]["settings"]
        parameter = self.t_parameters.verticalHeader().label(row)
        value = self.t_parameters.text(row, col)
        settings[str(parameter).strip()] = str(value).strip()

    def _update_settings(self):
        if self._plugin_manager is not None:
            self._plugin_manager.updateSettings(self._plugin_settings)

    def _show_plugin(self, item):
        if item is None:
            return

        self.t_parameters.removeRows(range(self.t_parameters.numRows()))

        plugin_id = self._items[item]
        self._selected_plugin = plugin_id

        params = self._plugin_settings[plugin_id]

        self.le_name.setText(params["name"])
        self.le_version.setText(params["version"])
        self.le_pversion.setText(params["plugin_version"])

        for setting, value in params["settings"].iteritems():
            index = self.t_parameters.numRows()
            self.t_parameters.insertRows(index)

            self.t_parameters.verticalHeader().setLabel(index, setting)
            self.t_parameters.setText(index, 0, str(value))

                                                                                

class VulnsListDialog(BaseDialog, VulnerabilitiesUi):
    def __init__(self, parent=None,item=None):
        BaseDialog.__init__(self, parent, "")
        VulnerabilitiesUi.__init__(self, parent)
        self._vulns = []
        self._setup_signals()
        self._item=item

        self.t_vulns.setColumnReadOnly(0, True)
        self.t_vulns.setColumnReadOnly(1, True)
        self.t_vulns.setColumnReadOnly(2, True)

        self.t_vulns.horizontalHeader().setStretchEnabled(True, 3)

    def add_vuln(self, vuln):
        index = self.t_vulns.numRows()
        self._vulns.append(vuln)
        self.t_vulns.insertRows(index)

        self.t_vulns.setText(index, 0, str(vuln.name))
        self.t_vulns.setText(index, 1, str(vuln.refs))
        self.t_vulns.setText(index, 2, str(vuln.desc))

        self.t_vulns.adjustColumn(0)
        self.t_vulns.adjustColumn(1)
        self.t_vulns.adjustColumn(2)


    def del_vuln(self, vuln):
        
        index = self.t_vulns.currentRow()
        self._vulns.remove(vuln)
        self.t_vulns.removeRows([index])



    def _setup_signals(self):
                                                          
        self.connect(self.t_vulns, SIGNAL("doubleClicked(int,int,int,QPoint)"),self._edit)

        self.connect(self.add_button, SIGNAL("clicked()"), self._add)
        self.connect(self.edit_button, SIGNAL("clicked()"), self._edit)
        self.connect(self.delete_button, SIGNAL("clicked()"), self._delete)
        self.connect(self.list_note_button, SIGNAL("clicked()"), self._list_note)
        self.connect(self.manage_evidence_button, SIGNAL("clicked()"), self._evidence)
        
    
    def _edit(self):
                                       
        if self.t_vulns.currentSelection() != -1:
            _object=self._vulns[self.t_vulns.currentRow()]
            dialog = VulnDialog(self,str(_object.name),str(_object.desc),str(_object.refs),self._editcallback,_object)
            res = dialog.exec_loop()
            
    def _evidence(self):
                                       
        if self.t_vulns.currentSelection() != -1:
            _object=self._vulns[self.t_vulns.currentRow()]
            _object.object = _object
            dialog = EvidencesListDialog(self, _object)
                                             
                                            
            dialog.exec_loop()
            
    def _list_note(self):
                                       
        if self.t_vulns.currentSelection() != -1:
            _object=self._vulns[self.t_vulns.currentRow()]
            _object.object = _object
            dialog = NotesListDialog(self, _object)
                                             
                                            
            dialog.exec_loop()
            
    def _editcallback(self,name,desc,ref,item):

        item.name=name
        item.desc=desc
        item.ref=ref
        
        self.t_vulns.setText(self.t_vulns.currentRow(), 0, name)
        self.t_vulns.setText(self.t_vulns.currentRow(), 1, ref)
        self.t_vulns.setText(self.t_vulns.currentRow(), 2, desc)

    def _newcallback(self, name, desc, ref, item):
        _parent=self._item.object.getParent()
        
        api.devlog("newVuln (%s) (%s) (%s) (%s) " % (name, desc, ref, item.object.getName(),))
        
        _newvuln=api.newVuln(name,desc,ref)

        if item.type == "Application":
            api.addVulnToApplication(_newvuln,_parent.name,item.object.getName())
        elif item.type == "Interface":
            api.addVulnToInterface(_newvuln,_parent.name,item.object.getName())
        elif item.type == "Host":
            api.addVulnToHost(_newvuln,item.object.getName())
        elif item.type == "Service":
            api.addVulnToService(_newvuln,_parent.name,item.object.getName())
        
                                                          
        self.add_vuln(_newvuln)   
        
    def _add(self):
        if self._item is not None and self._item.object is not None:
            dialog = VulnDialog(self,callback=self._newcallback,item=self._item)
            res = dialog.exec_loop()
            
    
    def _delete(self):
        if self.t_vulns.currentSelection() != -1:
            _vuln=self._vulns[self.t_vulns.currentRow()]
            _parent=_vuln._parent
                                                                                                  
            
            if isinstance(_parent,hosts.HostApplication):
                api.delVulnFromApplication(_vuln.getID(),_parent.getParent().name,_parent.name)
            elif isinstance(_parent,hosts.Interface):
                api.delVulnFromInterface(_vuln.getID(),_parent.getParent().name,_parent.name)
            elif isinstance(_parent,hosts.Host):
                api.delVulnFromHost(_vuln.getID(),_parent.name)
            elif isinstance(_parent,hosts.Service):
                api.delVulnFromService(_vuln.getID(),_parent.getParent().name,_parent.name)
        
                                                                 
            self.del_vuln(_vuln)
        

                                                                                

class PreferencesDialog(BaseDialog, PreferencesUi):
    def __init__(self, parent=None):
        BaseDialog.__init__(self, parent, "")
        PreferencesUi.__init__(self, parent)
        self._main_window = parent

        self._fdb = qt.QFontDatabase()
        self._families = self._fdb.families()
        self.cb_font_family.insertStringList(self._families)

        self._styles = None
        self._sizes = None
        
        self._family = None
        self._style = None
        self._size = None


        self._set_connections()
        self._load_styles(0)
        self._load_sizes(0)
        
    def _set_connections(self):
        self.connect(self.cb_font_family, SIGNAL("activated(int)"),
                     self._load_styles)
        self.connect(self.cb_font_style, SIGNAL("activated(int)"),
                     self._load_sizes)
        self.connect(self.cb_font_size, SIGNAL("activated(int)"),
                     self._change_size)
        self.connect(self.bt_ok, SIGNAL("clicked()"),
                     self.accept)
        self.connect(self.bt_cancel, SIGNAL("clicked()"),
                     self.reject)

    def _load_styles(self, index):
        self._family = self._families[index]
        self.cb_font_style.clear()
        self._styles = self._fdb.styles(self._family)
        self.cb_font_style.insertStringList(self._styles)
        self._update_font()

    def _load_sizes(self, index):
        self._style = self._styles[index]
        self.cb_font_size.clear()
        self._sizes = self._fdb.smoothSizes(self._family, self._style)
        string_list = QStringList()
        [string_list.append(str(size)) for size in self._sizes]
        self.cb_font_size.insertStringList(string_list)
        self._update_font()

    def _change_size(self, index):
        self._size = self._sizes[index]
        self._update_font()

    def _update_font(self):
        font = self.le_example.font()
        if self._family is not None:
            font.setFamily(self._family)
        if self._size is not None:
            font.setPointSize(self._size)
        if self._style is not None:
            isItalic = self._fdb.italic(self._family, self._style)
            font.setItalic(isItalic)
            isBold = self._fdb.bold(self._family, self._style)
            font.setBold(isBold)
            weight = self._fdb.weight(self._family, self._style)
            font.setWeight(weight)
        self.le_example.setFont(font)
        self._main_window.shell_font = font

                                                                                

class NotesListDialog(BaseDialog, NotesListUI):

    def __init__(self, parent, item=None):
        BaseDialog.__init__(self, parent, "NotesListDialog", modal=True)
        NotesListUI.__init__(self, parent)
        self.notes_table.setColumnReadOnly(0, True)
        self.notes_table.setColumnReadOnly(1, True)
        self._notes = []
        self._setup_signals()
        self._item = item                                                           
        if item is not None and item.object is not None:
            for n in item.object.getNotes():
                self.add_note_to_table(n)
        
    def add_note_to_table(self, note):
        index = self.notes_table.numRows()
        self._notes.append(note)
        self.notes_table.insertRows(index)
        self.notes_table.setText(index, 0, note.name)
        self.notes_table.setText(index, 1, note.text)
        self.notes_table.adjustColumn(0)
        self.notes_table.adjustColumn(1)
        self.notes_table.adjustRow(index)
    
    def _setup_signals(self):
                                                          
                                                                                    
                              

        self.connect(self.add_button, SIGNAL("clicked()"), self._add_note)
        self.connect(self.edit_button, SIGNAL("clicked()"), self._edit_note)
        self.connect(self.delete_button, SIGNAL("clicked()"), self._delete_note)
        self.connect(self.list_note_button, SIGNAL("clicked()"), self._list_note)
    
    def _edit_note(self):
        if self.notes_table.currentSelection() != -1:
            _object=self._notes[self.notes_table.currentRow()]
            dialog = NoteDialog(self,_object.name,_object.text,self._editcallbackNote,_object)
            res = dialog.exec_loop()

    def _list_note(self):
                                       
        if self.notes_table.currentSelection() != -1:
            _object=self._notes[self.notes_table.currentRow()]
            _object.object = _object
            dialog = NotesListDialog(self, _object)
                                             
                                            
            dialog.exec_loop()

    def _editcallbackNote(self,name,text,item):
        item.name = name
        item.text = text
        self.notes_table.setText(self.notes_table.currentRow(), 0, name)
        self.notes_table.setText(self.notes_table.currentRow(), 1, text)

    def _newcallbackNote(self, name, text, item):
        _parent=self._item.object.getParent()
        
        api.devlog("newNote (%s) (%s) (%s)  " % (name, text, item.object.getName(),))
        
        _newnote=api.newNote(name,text)
        
        if item.object.class_signature == "HostApplication":
            api.addNoteToApplication(_newnote,_parent.name,item.object.getName())
        elif item.object.class_signature == "Interface":
            api.addNoteToInterface(_newnote,_parent.name,item.object.getName())
        elif item.object.class_signature == "Host":
            api.addNoteToHost(_newnote,item.object.getName())
        elif item.object.class_signature == "Service":
            api.addNoteToService(_newnote,_parent.name,item.object.getName())
        else:
                                                                                            
                                                                                    
            item.object.addNote(_newnote)
        
        self.add_note_to_table(_newnote)
        
    def _add_note(self):
        if self._item is not None and self._item.object is not None:
            dialog = NoteDialog(self,callback=self._newcallbackNote,item=self._item)
            res = dialog.exec_loop()
            
    
    def _delete_note(self):
        
        _object=self._notes[self.notes_table.currentRow()]
        if self.notes_table.currentSelection() != -1:
            _note=self._notes[self.notes_table.currentRow()]
            _parent=_note._parent
                
            if _parent.class_signature == "HostApplication":
                api.delNoteFromApplication(_note.getID(),_parent.getParent().name,_parent.name)
            elif _parent.class_signature == "Interface":
                api.delNoteFromInterface(_note.getID(),_parent.getParent().name,_parent.name)
            elif _parent.class_signature == "Host":
                api.delNoteFromHost(_note.getID(),_parent.name)
            elif _parent.class_signature == "Service":
                api.delNoteFromService(_note.getID(),_parent.getParent().name,_parent.name)
            else:
                _parent.delNote(_note.getID())
                
        
                                                                 
            self.del_note(_note)
        

    def del_note(self, note):
        
        index = self.notes_table.currentRow()
        self._notes.remove(note)
        self.notes_table.removeRows([index])

                                                                              

                                                                                

class EvidencesListDialog(BaseDialog, EvidencesListUI):

    def __init__(self, parent, item=None):
        BaseDialog.__init__(self, parent, "EvidencesListDialog", modal=True)
        EvidencesListUI.__init__(self, parent)
        self.evidences_table.setColumnReadOnly(0, True)
        self.evidences_table.setColumnReadOnly(1, True)
        self._setup_signals()
        self._item = item                                                               
        if item is not None and item.object is not None:
            for n in item.object.evidences:
                self.add_evidence_to_table(n)
        
    def add_evidence_to_table(self, evidence):
        index = self.evidences_table.numRows()
        self.evidences_table.insertRows(index)
        self.evidences_table.setText(index, 0, str(index))
        self.evidences_table.setText(index, 1, evidence)
        self.evidences_table.adjustColumn(0)
        self.evidences_table.adjustColumn(1)
        self.evidences_table.adjustRow(index)
    
    def _setup_signals(self):
                                                          
                                                                                        
                                  

        self.connect(self.add_button, SIGNAL("clicked()"), self._add_evidence)
        self.connect(self.delete_button, SIGNAL("clicked()"), self._delete_evidence)

    def _newcallbackEvidence(self, name, item):
        
        d_path = api.addEvidence("%s" % name)
        if d_path is not False:
            self._item.object.evidences.append(d_path)
            self.add_evidence_to_table(d_path)
        
    def _add_evidence(self):
        if self._item is not None and self._item.object is not None:
            filename =  QFileDialog.getOpenFileName(
                        CONF.getDefaultTempPath(),
                        "Images Files  (*.png)",
                        None,
                        "open file dialog",
                        "Choose a file to add in the evidence" );
            
            if (filename):
                self._newcallbackEvidence(filename,self._item)
                for n in self._item.object.evidences:
                    api.devlog("Los items screenshot son:" + n)
            
            
    def _delete_evidence(self):
        
        if self.evidences_table.currentSelection() != -1:

            index = self.evidences_table.currentRow()
            _evidence=self._item.object.evidences[index]
            self._item.object.evidences.remove(_evidence)
            api.delEvidence(_evidence)
            self.evidences_table.removeRows([index])
            self._updateIds()
            for n in self._item.object.evidences:
                api.devlog("Los items screenshot son:" + n)
                
    def _updateIds(self):
        for i in range(0,self.evidences_table.numRows()):
            self.evidences_table.setText(i , 0, str(i))
        


                                                                                     

########NEW FILE########
__FILENAME__ = edition
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import qt
import qttable
import model.guiapi as guiapi


class NewModelObjectDialog(qt.QDialog):

    def __init__(self, parent, name, callback, layout_margin=0, layout_spacing=-1, modal=True):
        qt.QDialog.__init__(self, parent, name, modal)
        self.widgets = {}
        self.result = None
        self.callback = callback

        if layout_spacing == -1:
            layout_spacing =  self.fontMetrics().height()

        self.main_layout = qt.QVBoxLayout(self, layout_margin, layout_spacing, "main_layout")
        
        self.setEdition()

        self.button_box = qt.QHBoxLayout()
        self.accept_button = qt.QPushButton("Accept", self)
        self.accept_button.setMaximumSize(qt.QSize(75, 25))
        self.connect(self.accept_button, qt.SIGNAL('clicked()'), self._accept)
        self.cancel_button = qt.QPushButton("Cancel", self)
        self.cancel_button.setMaximumSize(qt.QSize(75, 25))
        self.connect(self.cancel_button, qt.SIGNAL('clicked()'), self.cancel)
        self.button_box.addWidget(self.accept_button)
        self.button_box.addWidget(self.cancel_button)

        self.main_layout.addStretch(1)
        self.main_layout.setMargin(5)
        self.main_layout.setSpacing(6)
        self.main_layout.addLayout(self.button_box)

    def getMainLayout(self):
        return self.main_layout

    def setEdition(self):
                                                
        pass

    def _addWidget(self, label, widget):
        hbox = qt.QHBoxLayout()
        hbox.setMargin(5)
        hbox.addWidget(label)
        hbox.addWidget(widget)
        self.main_layout.addLayout(hbox)

    def getWidget(self, name):
        return self.widgets.get(name, None)

    def addTextEdit(self, name, description, label_size=100):
        label = qt.QLabel(None, description, self)
        label.setMinimumSize(qt.QSize(label_size, 1))
        self.widgets[name] = text_edit = TextEditWidget(self, "")
        text_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Minimum))
        self._addWidget(label, text_edit)

    def addIntEdit(self, name, description, minValue, maxValue, label_size=100):
        label = qt.QLabel(None, description, self)
        label.setMinimumSize(qt.QSize(label_size, 1))
        self.widgets[name] = int_edit = IntEditWidget(self, 1, minValue, maxValue)
        int_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Minimum))
        self._addWidget(label, int_edit)

    def addTextBlockEdit(self, name, description, label_size=100):
        label = qt.QLabel(None, description, self)
        label.setMinimumSize(qt.QSize(label_size, 1))
        label.setAlignment(qt.Qt.AlignTop)
        self.widgets[name] = text_block_edit = TextBlockEditWidget(self, "")
        text_block_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
        self._addWidget(label, text_block_edit)

    def addComboBox(self, name, description, values, label_size=100):
        label = qt.QLabel(None, description, self)
        label.setMinimumSize(qt.QSize(label_size, 1))
        label.setAlignment(qt.Qt.AlignTop)
        self.widgets[name] = combo_edit = ComboBoxEditWidget(self, values)
        combo_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
        self._addWidget(label, combo_edit)

    def addCheckBox(self, name, description, callback=None, label_size=100):
        label = qt.QLabel(None, description, self)
        label.setMinimumSize(qt.QSize(label_size, 1))
        label.setAlignment(qt.Qt.AlignTop)
        self.widgets[name] = checkbox_edit = BooleanEditWidget(self, False)
        checkbox_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
        if callback:
            self.connect(checkbox_edit, qt.SIGNAL("stateChanged(int)"), callback)
        self._addWidget(label, checkbox_edit)

    def getValues(self):
                                                
        pass

    def getValue(self, name):
        return self.widgets[name].getValue()

    def getResult(self):
        return self.result
    
    def cancel(self):
        self.reject()

    def _accept(self):
        if self.callback is not None:
            self.result = self.callback(*self.getValues())
        self.accept()

    def sizeHint(self):
                                                                  
        return qt.QSize(300, 100)


class NewHostDialog(NewModelObjectDialog):

    def __init__(self, parent, callback,  layout_margin=0, layout_spacing=-1, modal=True):
        NewModelObjectDialog.__init__(self, parent, "New Host", callback, layout_margin, layout_spacing, modal)

    def setEdition(self):
        self.addTextEdit("name", "Name")
        self.addTextEdit("os", "OS")

    def getValues(self):
        return [self.getValue("name"), self.getValue("os")]

class NewCredDialog(NewModelObjectDialog):

    def __init__(self, parent, callback,  layout_margin=0, layout_spacing=-1, modal=True):
        NewModelObjectDialog.__init__(self, parent, "New Cred", callback, layout_margin, layout_spacing, modal)

    def setEdition(self):
        self.addTextEdit("username", "Username")
        self.addTextEdit("password", "Password")

    def getValues(self):
        return [self.getValue("username"), self.getValue("password")]

class NewInterfaceDialog(NewModelObjectDialog):

    def __init__(self, parent, callback,  layout_margin=0, layout_spacing=-1, modal=True):
        NewModelObjectDialog.__init__(self, parent, "New Interface", callback, layout_margin, layout_spacing, modal)

    def setEdition(self):
        self.addTextEdit("name", "Name")
        self.addTextEdit("ipv4", "IPv4")
        self.addTextEdit("ipv6", "IPv6")

    def getValues(self):
        return [self.getValue("name"), self.getValue("ipv4"), self.getValue("ipv6")]


class NewServiceDialog(NewModelObjectDialog):

    def __init__(self, parent, callback,  layout_margin=0, layout_spacing=-1, modal=True):
        NewModelObjectDialog.__init__(self, parent, "New Service", callback, layout_margin, layout_spacing, modal)

    def setEdition(self):
        self.addTextEdit("name", "Name")
        self.addTextEdit("protocol", "Protocol")
        self.addIntEdit("port", "Port", 1, 65535)

    def getValues(self):
        return [self.getValue("name"), self.getValue("protocol"), self.getValue("port")]

class NewNoteDialog(NewModelObjectDialog):

    def __init__(self, parent, callback,  layout_margin=0, layout_spacing=-1, modal=True):
        NewModelObjectDialog.__init__(self, parent, "New Note", callback, layout_margin, layout_spacing, modal)

    def setEdition(self):
        self.addTextEdit("name", "Name", label_size=50)
        self.addTextBlockEdit("text", "Text", label_size=50)

    def getValues(self):
        return [self.getValue("name"), self.getValue("text")]

    def sizeHint(self):
                                                                  
        return qt.QSize(450, 200)

class NewVulnDialog(NewModelObjectDialog):

    def __init__(self, parent, callback, vuln_web_enabled=False, layout_margin=0, layout_spacing=-1, modal=True):
        self.vuln_web_enabled = vuln_web_enabled
        NewModelObjectDialog.__init__(self, parent, "New Vulnerabilty", callback, layout_margin, layout_spacing, modal)

    def setEdition(self):
        if not self.vuln_web_enabled:
            self.addCheckBox("vuln_web", "Web Vulnerabilty (only for services)", self._type_changed)
            self.getWidget("vuln_web").setEnabled(False)
        else:
            self.addCheckBox("vuln_web", "Web Vulnerabilty", self._type_changed)
        self.addTextEdit("name", "Name")
        self.addTextEdit("desc", "Description")
        self.addTextEdit("website", "Website")
        self.getWidget("website").setEnabled(False)
        self.addTextEdit("path", "Path")
        self.getWidget("path").setEnabled(False)
    
    def _type_changed(self, type):
        self.getWidget("path").setEnabled(bool(type))
        self.getWidget("website").setEnabled(bool(type))

    def getValues(self):
        values = [self.getValue("vuln_web"), self.getValue("name"), self.getValue("desc")]
        if self.getValue("vuln_web"):
            values.extend([self.getValue("website"), self.getValue("path")])
        return values

    def sizeHint(self):
                                                                  
        return qt.QSize(400, 250)

class NewVulnWebDialog(NewModelObjectDialog):

    def __init__(self, parent, callback,  layout_margin=0, layout_spacing=-1, modal=True):
        NewModelObjectDialog.__init__(self, parent, "New Web Vulnerabilty", callback, layout_margin, layout_spacing, modal)

    def setEdition(self):
        self.addTextEdit("name", "Name")
        self.addTextEdit("desc", "Description")
        self.addTextEdit("website", "Website")
        self.addTextEdit("path", "Path")

    def getValues(self):
        return [self.getValue("name"), self.getValue("desc"), self.getValues("website"), self.getValues("path")]


class DetailLabel(qt.QLabel):
    """
    A lable for ModelObject items details
    This implements mouse move and focus events
    This is to show a darker color when mouse is over detail
    and also to show context menues
    """

    def __init__(self, setting, text, parent):

        qt.QLabel.__init__(self, text, parent)
        self.bgcolor = self.paletteBackgroundColor()
        self.setFocusPolicy(qt.QWidget.StrongFocus)
        self.setMargin(1)

        self.setting    = setting
        self.inmenu     = False
        self.inmouse    = False
        self.infocus    = False

    def _setBg(self):
        """Set the background of the widget according to its state."""

                                                              
        num = 100
        if self.inmenu:
            num += 20
        else:
            if self.inmouse:
                num += 10
            if self.infocus:
                num += 10

        self.setPaletteBackgroundColor(self.bgcolor.dark(num))

    def keyPressEvent(self, event):
                                       

        key = event.key()
                                           
        if key == qt.Qt.Key_Up:
            self.focusNextPrevChild(False)
            self.focusNextPrevChild(False)
        elif key == qt.Qt.Key_Down:
            self.focusNextPrevChild(True)
            self.focusNextPrevChild(True)
        elif key == qt.Qt.Key_Left:
            self.focusNextPrevChild(False)
        elif key == qt.Qt.Key_Right:
            self.focusNextPrevChild(True)
        else:
            event.ignore()

    def enterEvent(self, event):
                            
        qt.QLabel.enterEvent(self, event)
        self.inmouse = True
        self._setBg()

    def leaveEvent(self, event):
                                
        qt.QLabel.leaveEvent(self, event)
        self.inmouse = False
        self._setBg()

    def focusInEvent(self, event):
                          
        qt.QLabel.focusInEvent(self, event)
        self.infocus = True
        self._setBg()

    def focusOutEvent(self, event):
                           
        qt.QLabel.focusOutEvent(self, event)
        self.infocus = False
        self._setBg()


class TextEditWidget(qt.QLineEdit):
    def __init__(self, parent, text):
        qt.QLineEdit.__init__(self, parent)
        self._setText(text)
    
    def getValue(self):
        text = self.text().ascii()
        if text:
            return self.text().ascii()
        return ""

    def _setText(self, text):
        text = text if text else ""
        self.setText(text)

class TextBlockEditWidget(qt.QTextEdit):
    def __init__(self, parent, text):
        qt.QTextEdit.__init__(self, parent)
        self._setText(text)
    
    def getValue(self):
        text = self.text().ascii()
        if text:
            return self.text().ascii()
        return ""

    def _setText(self, text):
        text = text if text else ""
        self.setText(text)

class BooleanEditWidget(qt.QCheckBox):
    def __init__(self, parent, value):
        qt.QCheckBox.__init__(self, parent)
        value = value if value else False
        self.setChecked(value)
    
    def getValue(self):
        return self.isChecked()


class IntEditWidget(qt.QSpinBox):
    def __init__(self, parent, value, minValue, maxValue, step=1):
        qt.QSpinBox.__init__(self, parent)
        value = value if value else minValue
        self.setMinValue(minValue)
        self.setMaxValue(maxValue)
        self.setLineStep(step)
        self.setValue(value)
        
    def getValue(self):
        return self.value()

class ComboBoxEditWidget(qt.QComboBox):
    def __init__(self, parent, values):
        qt.QComboBox.__init__(self, 0, parent)
                                      
        for value in values:
            self.insertItem(value)

    def getValue(self):
        return self.currentText()


class ListEditWidget(qt.QHBox):
    def __init__(self, parent, values, title="", preview_size=25):
        qt.QHBox.__init__(self, parent)
        self.title = title
        self.values = values
        self.preview_size = preview_size
        preview = self.getPreview()
        self.list_label = DetailLabel(None, preview, self)
        button = qt.QPushButton("...", self)
        button.setMaximumSize(qt.QSize(25, 25))
        self.connect(button, qt.SIGNAL('clicked()'), self.showListEditor)

    def getValue(self):
        return self.values

    def setValues(self, values):
        self.values = values
        self.updatePreview()

    def getPreview(self):
        return ", ".join(["%s" % hn for hn in self.values])[0:25]

    def updatePreview(self):
        self.list_label.setText(self.getPreview())

    def showListEditor(self):
        dialog = ListEditDialog(self, self.title, self.values)
        result = dialog.exec_loop()
        self.values = dialog.getValues()
        self.updatePreview()


class ListEditDialog(qt.QDialog):

    def __init__(self, parent, name, values, layout_margin=0, layout_spacing=-1, modal=True):
        qt.QDialog.__init__(self, parent, name, modal)
        if layout_spacing == -1:
            layout_spacing =  self.fontMetrics().height()

        self.list_layout = qt.QVBoxLayout()
        self.listview = qt.QListView(self)
        self.listview.setSelectionMode(qt.QListView.Extended)
        self.listview.addColumn(name)
        self.listview.setColumnWidthMode(0, qt.QListView.Maximum)
        for value in values:
            view_item = qt.QListViewItem(self.listview)
            view_item.setText(0, qt.QString(value))

        self.list_layout.addWidget(self.listview)

        self.button_box = qt.QVBoxLayout()
        self.add_button = qt.QPushButton("Add", self)
        self.add_button.setMaximumSize(qt.QSize(100, 100))
        self.connect(self.add_button, qt.SIGNAL('clicked()'), self.addValue)
        self.remove_button = qt.QPushButton("Remove", self)
        self.remove_button.setMaximumSize(qt.QSize(100, 100))
        self.connect(self.remove_button, qt.SIGNAL('clicked()'), self.removeValue)
        self.close_button = qt.QPushButton("Close", self)
        self.close_button.setMaximumSize(qt.QSize(100, 100))
        self.connect(self.close_button, qt.SIGNAL('clicked()'), self.close)
        self.button_box.addWidget(self.add_button)
        self.button_box.addWidget(self.remove_button)
        self.button_box.addStretch(2)
        self.button_box.addWidget(self.close_button)

        self.main_layout = qt.QHBoxLayout(self, layout_margin, layout_spacing, "main_layout")
        self.main_layout.addLayout(self.list_layout)
        self.main_layout.addLayout(self.button_box)

    def getValues(self):
        values = []
        iter = qt.QListViewItemIterator(self.listview)
        while True:
            item = iter.current()
            if item == None:
                break
            values.append(item.text(0).ascii())
            iter += 1
        return values

    def addValue(self):
        text, ok = qt.QInputDialog.getText('New value', 'New value:')
        if not ok or text == '':
            return
        view_item = qt.QListViewItem(self.listview)
        view_item.setText(0, qt.QString(text))

    def removeValue(self):
        items_selected = []
        iter = qt.QListViewItemIterator(self.listview)
        while True:
            item = iter.current()
            if item == None:
                break
            if item.isSelected():
                items_selected.append(item)
            iter += 1
        for item in items_selected:
            self.listview.takeItem(item)
            del item

    def close(self):
        self.accept()

    def sizeHint(self):
                                                                  
        return qt.QSize(400, 400)


class EditionTable(qttable.QTable):
    """The table which shows the details of item selected on the tree"""

    def __init__(self, parent, rows = 0, columns = 2):
        qttable.QTable.__init__(self, parent)
        self.setFocusPolicy(qt.QWidget.NoFocus)
                                                      
        self.setNumCols(columns)
        self.setNumRows(rows)
        self.setTopMargin(0)
        self.setLeftMargin(0)
        self.setShowGrid(False)
        self.setColumnStretchable(1, True)
        self.setSelectionMode(qttable.QTable.NoSelection)
        
        self._row_count = 0
                          

    def setEditable(self, editable):
        self._editable = editable
    
    def isEditable(self):
        return self._editable

    def _addWidget(self, label, widget):
        self.setCellWidget(self._row_count, 0, label)
        self.setCellWidget(self._row_count, 1, widget)
                                    
        self._row_count += 1

    def addTextEdit(self, description, value):
        view = self.viewport()
        label = DetailLabel(None, description, view)
        textEdit = TextEditWidget(view, value)
        self._addWidget(label, textEdit)
        return textEdit

    def addBooleanEdit(self, description, value):
        view = self.viewport()
        label = DetailLabel(None, description, view)
        booleanEdit = BooleanEditWidget(view, value)
        self._addWidget(label, booleanEdit)
        return booleanEdit    

    def addIntEdit(self, description, value, minValue, maxValue):
        view = self.viewport()
        label = DetailLabel(None, description, view)
        intEdit = IntEditWidget(view, value, minValue, maxValue)
        self._addWidget(label, intEdit)  
        return intEdit

    def addListEdit(self, description, values, title):
        view = self.viewport()
        label = DetailLabel(None, description, view)
        listEdit = ListEditWidget(view, values, title)
        self._addWidget(label, listEdit)  
        return listEdit

    def clear(self):
        self._row_count = 0
        self.setNumRows(0)
                             
    
    def keyPressEvent(self, event):
        """This method is necessary as the table steals keyboard input
        even if it cannot have focus."""
        fw = self.focusWidget()
        if fw != self:
            try:
                fw.keyPressEvent(event)
            except RuntimeError:
                                                                     
                event.ignore()
        else:
            event.ignore()

    def keyReleaseEvent(self, event):
        """This method is necessary as the table steals keyboard input
        even if it cannot have focus."""
        fw = self.focusWidget()
        if fw != self:
            try:
                fw.keyReleaseEvent(event)
            except RuntimeError:
                                                                     
                event.ignore()
        else:
            event.ignore()

class HostEditor():
    def __init__(self, host):
        self.host = host
        self.widgets = {}

    def getArgs(self):
        return {
            "name" : self.widgets["name"].getValue(),
            "description" : self.widgets["description"].getValue(),
            "os" : self.widgets["os"].getValue(),
            "owned" : self.widgets["owned"].getValue(),
        }

    def save(self):
        kargs = self.getArgs()
        if kargs["name"]:
            guiapi.editHost(self.host, **kargs)
            return True
        return False

    def fillEditionTable(self, qttable):
        qttable.clear()
        qttable.setNumRows(4)
        self.widgets["name"] = qttable.addTextEdit("Name", self.host.getName())
        self.widgets["description"] = qttable.addTextEdit("Description", self.host.getDescription())
        self.widgets["os"] = qttable.addTextEdit("OS", self.host.getOS())
        self.widgets["owned"] = qttable.addBooleanEdit("Owned", self.host.isOwned())

class InterfaceEditor():
    def __init__(self, interface):
        self.interface = interface
        self.widgets = {}

    def getArgs(self):
        return {
            "name" : self.widgets["name"].getValue(),
            "description" : self.widgets["description"].getValue(),
            "mac" : self.widgets["mac"].getValue(),
            "ipv4" : {
                'address' : self.widgets["ipv4_address"].getValue(),
                'mask' : self.widgets["ipv4_mask"].getValue(),
                'gateway' : self.widgets["ipv4_gateway"].getValue(),
                'DNS' : self.widgets["ipv4_dns"].getValue()
            },
            "ipv6" : {
                'address' : self.widgets["ipv6_address"].getValue(),
                'prefix' : self.widgets["ipv6_prefix"].getValue(),
                'gateway' : self.widgets["ipv6_gateway"].getValue(),
                'DNS' : self.widgets["ipv6_dns"].getValue(),    
            },
            "owned" : self.widgets["owned"].getValue(),
            "hostnames" : self.widgets["hostanmes"].getValue()
        }

    def save(self):
        kargs = self.getArgs()
        if kargs["name"]:
            guiapi.editInterface(self.interface, **kargs)
            return True
        return False

    def fillEditionTable(self, qttable):
        qttable.clear()
        qttable.setNumRows(11)
        self.widgets["name"] = qttable.addTextEdit("Name", self.interface.getName())
        self.widgets["description"] = qttable.addTextEdit("Description", self.interface.getDescription())
        self.widgets["mac"] = qttable.addTextEdit("MAC", self.interface.getMAC())
        self.widgets["hostanmes"] = qttable.addListEdit("Hostnames", self.interface.getHostnames(), "Hostnames")
        self.widgets["ipv4_address"] = qttable.addTextEdit("IPv4 Address", self.interface.getIPv4Address())
        self.widgets["ipv4_mask"] = qttable.addTextEdit("IPv4 Mask", self.interface.getIPv4Mask())
        self.widgets["ipv4_gateway"] = qttable.addTextEdit("IPv4 Gateway", self.interface.getIPv4Gateway())
        self.widgets["ipv4_dns"] = qttable.addListEdit("IPv4 DNS", self.interface.getIPv4DNS(), "IPv4 DNS")
        self.widgets["ipv6_address"] = qttable.addTextEdit("IPv6 Address", self.interface.getIPv6Address())
        self.widgets["ipv6_prefix"] = qttable.addTextEdit("IPv6 Prefix", self.interface.getIPv6Prefix())
        self.widgets["ipv6_gateway"] = qttable.addTextEdit("IPv6 Gateway", self.interface.getIPv6Gateway())
        self.widgets["ipv6_dns"] = qttable.addListEdit("IPv6 DNS", self.interface.getIPv6DNS(), "IPv6 DNS")
        self.widgets["owned"] = qttable.addBooleanEdit("Owned", self.interface.isOwned())

class ServiceEditor():
    def __init__(self, service):
        self.service = service
        self.widgets = {}

    def getArgs(self):
        return {
            "name" : self.widgets["name"].getValue(),
            "description" : self.widgets["description"].getValue(),
            "protocol" : self.widgets["protocol"].getValue(),
            "ports" : self.widgets["port"].getValue(),
            "status" : self.widgets["status"].getValue(),
            "version" : self.widgets["version"].getValue(),
            "owned" : self.widgets["owned"].getValue()
        }
    
    def save(self):
        kargs = self.getArgs()
        if kargs["name"] and kargs["protocol"] and kargs["ports"]:
            guiapi.editService(self.service, **kargs)
            return True
        return False

    def fillEditionTable(self, qttable):
        qttable.clear()
        qttable.setNumRows(7)
        self.widgets["name"] = qttable.addTextEdit("Name", self.service.getName())
        self.widgets["description"] = qttable.addTextEdit("Description", self.service.getDescription())
        self.widgets["protocol"] = qttable.addTextEdit("Protocol", self.service.getProtocol())
                                                                                                  
                                             
        self.widgets["port"] = qttable.addIntEdit("Port", self.service.getPorts()[0], 1, 65535)
        self.widgets["status"] = qttable.addTextEdit("Status", self.service.getStatus())
        self.widgets["version"] = qttable.addTextEdit("Version", self.service.getVersion())
        self.widgets["owned"] = qttable.addBooleanEdit("Owned", self.service.isOwned())


class GenericEditor():
    def __init__(self, object):
        pass

    def save(self):
        pass

    def fillEditionTable(self, qttable):
        pass

class NoteEditor(qt.QVBoxLayout):
    def __init__(self, parent):
        qt.QVBoxLayout.__init__(self)
        self.note = None

        self.setSpacing(10)

        label = qt.QLabel(None, "Name: ", parent)
        self._name_edit = TextEditWidget(parent, "")
        self._name_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._name_edit)
        label = qt.QLabel(None, "Text: ", parent)
        self._text_edit = TextBlockEditWidget(parent, "")
        self._text_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
        self.addWidget(label)
        self.addWidget(self._text_edit)

    def setNote(self, note):
        self.note = note
        self._name_edit._setText(note.name)
        self._text_edit._setText(note.text)

    def clear(self):
        self.note = None
        self._name_edit._setText("")
        self._text_edit._setText("")

    def getArgs(self):
        return {
            "name" : self._name_edit.getValue(),
            "text" : self._text_edit.getValue()
        }

class VulnEditor(qt.QVBoxLayout):
    def __init__(self, parent):
        qt.QVBoxLayout.__init__(self, parent)
        self.vuln = None

        self.setSpacing(10)

        label = qt.QLabel(None, "Name: ", parent)
        self._name_edit = TextEditWidget(parent, "")
        self._name_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._name_edit)
        label = qt.QLabel(None, "Description: ", parent)
        self._description_edit = TextBlockEditWidget(parent, "")
        self._description_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
        self.addWidget(label)
        self.addWidget(self._description_edit)
        label = qt.QLabel(None, "Severity: ", parent)
        self._severity_edit = TextEditWidget(parent, "")
        self._severity_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._severity_edit)
        label = qt.QLabel(None, "References: ", parent, "References")
        self._references_edit = ListEditWidget(parent, [], preview_size=100)
        self.addWidget(label)
        self.addWidget(self._references_edit)


    def setVuln(self, vuln):
        self.vuln = vuln
        self._name_edit._setText(vuln.name)
        self._description_edit._setText(vuln.desc)
        self._severity_edit._setText(vuln.severity)
        self._references_edit.setValues(vuln.refs)

    def clear(self):
        self.vuln = None
        self._name_edit._setText("")
        self._description_edit._setText("")
        self._severity_edit._setText("")
        self._references_edit.setValues([])

    def getArgs(self):
        return {
            "name" : self._name_edit.getValue(),
            "desc" : self._description_edit.getValue(),
            "severity" : self._severity_edit.getValue(),
            "refs" : self._references_edit.getValue()
        }

class VulnWebEditor(VulnEditor):
    def __init__(self, parent):
        VulnEditor.__init__(self, parent)
        self.vuln = None

        self.setSpacing(10)

        label = qt.QLabel(None, "Path: ", parent)
        self._path_edit = TextEditWidget(parent, "")
        self._path_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._path_edit)

        label = qt.QLabel(None, "Website: ", parent)
        self._website_edit = TextEditWidget(parent, "")
        self._website_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._website_edit)

        label = qt.QLabel(None, "Request: ", parent)
        self._request_edit = TextBlockEditWidget(parent, "")
        self._request_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
        self.addWidget(label)
        self.addWidget(self._request_edit)

        label = qt.QLabel(None, "Response: ", parent)
        self._response_edit = TextBlockEditWidget(parent, "")
        self._response_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
        self.addWidget(label)
        self.addWidget(self._response_edit)

        label = qt.QLabel(None, "Method: ", parent)
        self._method_edit = TextEditWidget(parent, "")
        self._method_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._method_edit)

        label = qt.QLabel(None, "Parameter Name: ", parent)
        self._pname_edit = TextEditWidget(parent, "")
        self._pname_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._pname_edit)

        label = qt.QLabel(None, "Parameters: ", parent)
        self._params_edit = TextEditWidget(parent, "")
        self._params_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._params_edit)

        label = qt.QLabel(None, "Query: ", parent)
        self._query_edit = TextEditWidget(parent, "")
        self._query_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._query_edit)

        label = qt.QLabel(None, "Category: ", parent)
        self._category_edit = TextEditWidget(parent, "")
        self._category_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Minimum, qt.QSizePolicy.Minimum))
        self.addWidget(label)
        self.addWidget(self._category_edit)

    def setVuln(self, vuln):
        super(VulnWebEditor, self).setVuln(vuln)
        self._path_edit._setText(vuln.path)
        self._website_edit._setText(vuln.website)
        self._request_edit._setText(vuln.request)
        self._response_edit._setText(vuln.response)
        self._method_edit._setText(vuln.method)
        self._pname_edit._setText(vuln.pname)
        self._params_edit._setText(vuln.params)
        self._query_edit._setText(vuln.query)
        self._category_edit._setText(vuln.category)

    def clear(self):
        super(VulnWebEditor, self).clear()
        self._name_edit._setText("")
        self._path_edit._setText("")
        self._website_edit._setText("")
        self._request_edit._setText("")
        self._response_edit._setText("")
        self._method_edit._setText("")
        self._pname_edit._setText("")
        self._params_edit._setText("")
        self._query_edit._setText("")
        self._category_edit._setText("")

    def getArgs(self):
        dic = super(VulnWebEditor, self).getArgs()
        dic.update(
            {
            "path" : self._path_edit.getValue(),
            "website" : self._website_edit.getValue(),
            "request" : self._request_edit.getValue(),
            "response" : self._response_edit.getValue(),
            "method" : self._method_edit.getValue(),
            "pname" : self._pname_edit.getValue(),
            "params" : self._params_edit.getValue(),
            "query" : self._query_edit.getValue(),
            "category" : self._category_edit.getValue()
        })
        return dic

class CredEditor(qt.QVBoxLayout):
    def __init__(self, parent):
        qt.QVBoxLayout.__init__(self)
        self.cred = None

        self.setSpacing(10)

        label = qt.QLabel(None, "Username: ", parent)
        label.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Maximum, qt.QSizePolicy.Maximum))
        self._username_edit = TextEditWidget(parent, "")
        self._username_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Maximum))
        self.addWidget(label)
        self.addWidget(self._username_edit)
        label = qt.QLabel(None, "Password: ", parent)
        label.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Maximum, qt.QSizePolicy.Maximum))
        self._password_edit = TextEditWidget(parent, "")
        self._password_edit.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Maximum))
        self.addWidget(label)
        self.addWidget(self._password_edit)
                                                                                               
        self.addStretch(15)

    def setCred(self, cred):
        self.cred = cred
        self._username_edit._setText(cred.username)
        self._password_edit._setText(cred.password)

    def clear(self):
        self.cred = None
        self._username_edit._setText("")
        self._password_edit._setText("")

    def getArgs(self):
        return {
            "username" : self._username_edit.getValue(),
            "password" : self._password_edit.getValue()
        }
        

########NEW FILE########
__FILENAME__ = forms
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import qt
import hostsbrowser as DetailsWidgets
import model.guiapi as guiapi

class BaseForm(qt.QVBox):
    def __init__(self, parent, rows, callback=None):
        qt.QVBox.__init__(self, parent)
        details_label = qt.QLabel("Details", self)
        details_label.setMargin(2)
        self._details_table = DetailsWidgets.DetailsTable(self, editable=True, rows=rows)
        self._widgets = {}
        
        self._callback = callback
        
        self._save_button = qt.QPushButton("Save", self)
        self._save_button.setMaximumWidth(50)
        self.connect(self._save_button, qt.SIGNAL('clicked()'), self._save_object)
    
    def createWidget(self, name, description, info):
        w = self._details_table.setInputWidget(name, description, info)
        self._appendWidget(name, w)
        
    def getWidgetValue(self, name):
        w = self._getWidget(name)
        return w.getValue()
    
    def _appendWidget(self, name, widget):
        self._widgets[name] = widget
    
    def _getWidget(self, name):
        return self._widgets[name]
        
    def _save_object(self):
                                              
        pass
    
    def execCallback(self, name):
        if self._callback is not None:
            self._callback(name)

class ServiceForm(BaseForm):
    def __init__(self, parent, service, callback):
        self.service = service
        BaseForm.__init__(self, parent, 7, callback)
                                                                           
        self.createWidget("description_edit", "Description", self.service.getDescription())
        self.createWidget("name_edit", "Name", self.service.getName())
        self.createWidget("protocol_edit", "Protocol", self.service.getProtocol())
        self.createWidget("ports_edit", "Ports", self.service.getPorts())
        self.createWidget("status_edit", "Status", self.service.getStatus())
        self.createWidget("version_edit", "Version", self.service.getVersion())
        self.createWidget("owned_edit", "Owned", self.service.isOwned())
    
    def _save_object(self):
                                                   
        guiapi.editService(self.service, self.getWidgetValue("name_edit"), self.getWidgetValue("description_edit"),
                        self.getWidgetValue("protocol_edit"), self.getWidgetValue("ports_edit"),
                        self.getWidgetValue("status_edit"), self.getWidgetValue("version_edit"),
                        self.getWidgetValue("owned_edit"))
        name = self.getWidgetValue("name_edit")
        self.execCallback(name)

class ApplicationForm(BaseForm):
    def __init__(self, parent, app, callback):
        self.app = app
        BaseForm.__init__(self, parent, 5, callback)
                                                                           
        self.createWidget("description_edit", "Description", self.app.getDescription())
        self.createWidget("name_edit", "Name", self.app.getName())
        self.createWidget("status_edit", "Status", self.app.getStatus())
        self.createWidget("version_edit", "Version", self.app.getVersion())
        self.createWidget("owned_edit", "Owned", self.app.isOwned())
    
    def _save_object(self):
                                                   
        guiapi.editApplication(self.app, self.getWidgetValue("name_edit"), self.getWidgetValue("description_edit"),
                        self.getWidgetValue("status_edit"), self.getWidgetValue("version_edit"),
                        self.getWidgetValue("owned_edit"))
        name = self.getWidgetValue("name_edit")
        self.execCallback(name)

class InterfaceForm(BaseForm):
    def __init__(self, parent, interface, callback):
        self.interface = interface
        BaseForm.__init__(self, parent, 9, callback)
                                                                           
        self.createWidget("description_edit", "Description", self.interface.getDescription())
        self.createWidget("name_edit", "Name", self.interface.getName())
        self.createWidget("hostnames_edit", "Hostnames", self.interface.getHostnames())
        self.createWidget("mac_edit", "MAC", self.interface.mac)
        self.createWidget("ipv4_edit", "IPv4", self.interface.ipv4)
        self.createWidget("network_segment_edit", "Network Segment", self.interface.network_segment)
        self.createWidget("amount_ports_opened_edit", "Ports opened", self.interface.amount_ports_opened)
        self.createWidget("amount_ports_closed_edit", "Ports closed", self.interface.amount_ports_closed)
        self.createWidget("amount_ports_filtered_edit", "Ports filtered", self.interface.amount_ports_filtered)
        self.createWidget("owned_edit", "Owned", self.interface.isOwned())
    
    def _save_object(self):
                                                   
        guiapi.editInterface(self.interface, self.getWidgetValue("name_edit"), self.getWidgetValue("description_edit"),
                        self.getWidgetValue("hostnames_edit"), self.getWidgetValue("mac_edit"),
                        self.getWidgetValue("ipv4_edit"), self.getWidgetValue("network_segment_edit"),
                        self.getWidgetValue("amount_ports_opened_edit"), self.getWidgetValue("amount_ports_closed_edit"),
                        self.getWidgetValue("amount_ports_filtered_edit"), self.getWidgetValue("owned_edit"))
        name = self.getWidgetValue("name_edit")
        self.execCallback(name)

class HostForm(BaseForm):
    def __init__(self, parent, host, callback):
        self.host = host
        BaseForm.__init__(self, parent, 4, callback)
                                                                           
        self.createWidget("description_edit", "Description", self.host.getDescription())
        self.createWidget("name_edit", "Name", self.host.getName())
        self.createWidget("os_edit", "OS", self.host.getOS())
        self.createWidget("owned_edit", "Owned", self.host.isOwned())
    
    def _save_object(self):
                                                   
        guiapi.editHost(self.host, self.getWidgetValue("name_edit"), self.getWidgetValue("description_edit"),
                        self.getWidgetValue("os_edit"), self.getWidgetValue("owned_edit"))
        name = self.getWidgetValue("name_edit")
        self.execCallback(name)

########NEW FILE########
__FILENAME__ = hostsbrowser
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import qt
from gui.qt3.modelobjectitems import *
import model.api as api
import model.guiapi as guiapi
import re as re
from gui.qt3.dialogs import NewVulnDialog, ConflictResolutionDialog, MessageDialog, NotesDialog, VulnsDialog, CredsDialog
from gui.qt3.customevents import *
from gui.qt3.dialogs import WorkspacePropertiesDialog
from gui.qt3.edition import EditionTable, NewServiceDialog, NewHostDialog, NewInterfaceDialog, NewCredDialog, NewNoteDialog

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

                      
from whoosh.index import create_in
from whoosh.fields import *


class PropertyItem(qt.QListViewItem):
                                                                
                         
    """Item for displaying a preferences-set in HostsBrowser."""
    def __init__(self, settings, number, parent):
        """_plugin_settings is the _plugin_settings class to work for
        parent is the parent ListViewItem (of type ModelObjectListViewItem)
        """
        qt.QListViewItem.__init__(self, parent)
        self.settings = settings
        self.parent = parent
        self.widget = None
        self.setText(0, settings.name)
        self.setText(1, 'setting')
        self.index = number

    def compare(self, i, col, ascending):
        """Always sort according to the index value."""

        a = [-1, 1][ascending]

        if self.index < i.index:
            return -1*a
        elif self.index > i.index:
            return 1*a
        else:
            return 0


class ModelObjectListView(qt.QListView):
    """
    List view for hosts
    It allows Drag and Drop (TODO)
    """
    def __init__(self, parent=None):
        qt.QListView.__init__(self, parent)
        self.setSelectionMode(qt.QListView.Extended)

                          
                                                                    
                                                                           
                                                
                     

    def selectWidget(self, widget):
        """Find the widget in the list and select it."""

                                                                   
                       
        iter = qt.QListViewItemIterator(self)

        found = None
        while True:
            item = iter.current()
            if item == None:
                break
            if item.widget == widget:
                found = item
                break
            iter += 1

        if found:
            self.ensureItemVisible(found)
            self.setSelected(found, True)

    def sizeHint(self):
        return qt.QSize(500, 800)


class SaveButton(qt.QPushButton):
    def __init__(self, parent, callback):
        qt.QPushButton.__init__(self, "Save", parent)
        parent.connect(self, qt.SIGNAL('clicked()'), callback)
        self.setMaximumSize(qt.QSize(75, 25))


class AbstractModelObjectBrowser(qt.QVBox):
    """Tree view to display Hosts"""

    def __init__(self, parent, caption=""):
        qt.QVBox.__init__(self, parent)
        self.setName(caption)
        self.setFrameStyle(qt.QFrame.Panel | qt.QFrame.Plain)
        self.setLineWidth(0)

        self.contextpopups = {}
        self._setupContextPopups()

        self.contextdispatchers = {}
        self._setupContextDispatchers()

        split = qt.QSplitter(self)
        split.setOrientation(qt.QSplitter.Vertical)

                                    
        vbox = qt.QVBox(split)
        lv = self.listview = ModelObjectListView(vbox)

        self.listenSelectionChanged(self._itemSelected)
        self.listenRightButtonPressed(self._showContextMenu())

        lv.setTreeStepSize(20)

        self.rootitem = None

                                                                           
        self.details_container = qt.QVBox(split)

        self._form = qt.QWidgetStack(self.details_container)
        self.f = None
        self.details_table = DetailsTable(self.details_container, editable=True)
                                                           
                                               
                                             
                                                              
                                                                                   

        self.prefchilds = []

    def sizeHint(self):
        """Returns recommended size of dialog."""
        return qt.QSize(70, 200)

    def resizeEvent(self, event):
                                                                  
                                                           
                                                                 
                              
        self.listview.setColumnWidth(0,self.size().width()-7)
                                                                              
                                                                       

    def getListview(self):
        return self.listview

    def setRootIsDecorated(self, decorated=False):
        self.listview.setRootIsDecorated(decorated)

    def selectRootItem(self, value=True):
        self.listview.setSelected(self.rootitem, value)

    def listenSelectionChanged(self, callback):
        self.connect(self.listview, qt.SIGNAL("selectionChanged()"), callback)

    def listenRightButtonPressed(self, callback):
        self.connect(self.listview, qt.SIGNAL("rightButtonPressed(QListViewItem *,const QPoint&,int)"), callback)

    def listenDoubleClicked(self, callback):
        self.connect(self.listview, qt.SIGNAL("doubleClicked(QListViewItem *, const QPoint &, int)"), callback)

    def setRootItem(self, rootItem):
        self.rootitem = rootItem

    def getRootItem(self):
        return self.rootitem

    def _itemSelected(self, item=False):
        """
        this is called when a list view item is selected
        """
        i = self.listview.firstChild()
        self.items_selected=[]
        self.items_type={'Host': 0, 'Workspace': 0, 'Service':0,
                         'Interface':0, 'Application':0,'Category_General':0
                         ,'Category_Applications':0,'Category_Interfaces':0}
        while i is not None:
            if i.isSelected():

                if i.type=="Category":
                    self.items_type[i.type+"_"+i.name] =self.items_type[i.type+"_"+i.name]+1
                else:
                    self.items_type[i.type] =self.items_type[i.type]+1

                self.items_selected.append(i)
            i = i.itemBelow()
            mtype={'Host': 0, 'Workspace': 0, 'Service':0, 'Interface':0, 'Application':0,'Category':0}

        self.itemselected = self.listview.currentItem()

                                                                                
                                                 
                                                                                     
                                                                                                     
        self.details_table.clear()
        editor = self.itemselected.getEditor()
        editor.fillEditionTable(self.details_table)
        self.setSaveCallback(editor.save)

    def _showContextMenu(self, item, pos, val):
        """Pop up a context menu when an item is clicked on the list view."""
        ret = None

        if item is not None:                           


                                  
                       
                                                                                                                                                            
            if self.items_type['Interface']:
                if (self.items_type['Category_General'] or self.items_type['Workspace']):
                    popname="CategoryWorkspace_Interface"
                elif (self.items_type['Host'] or self.items_type['Service']):
                    popname="ServiceHost_Interface"
                else:
                    popname=item.type

            elif (self.items_type['Host'] or self.items_type['Service']):
                if (self.items_type['Category_General'] or self.items_type['Workspace']):
                    popname="CategoryWorkspace_ServiceHost"
                elif (self.items_type['Host'] >1 or self.items_type['Service'] >1):
                    popname="Service_Host"
                elif (self.items_type['Host'] and self.items_type['Service']):
                    popname="Service_Host"
                else:
                    if item.type is "Category":
                        popname="Host"
                    else:
                        popname=item.type
            else:
                                   
                if item.type is "Category":
                    popname=item.type + "_" + item.name
                else:
                    popname=item.type


            ret = self.contextpopups[popname].exec_loop(pos)

            if ret in self.contextdispatchers:
                self.contextdispatchers[ret](item)
                  
                                                                         

            api.devlog("contextMenuEvent - item: %s - ret %s" % (self.name, ret))

class HostsBrowserConcrete(AbstractModelObjectBrowser):
    def __init__(self, parent, caption=""):
        AbstractModelObjectBrowser.__init__(parent, caption)
        self.setRootIsDecorated(True)

                                                        
        self.getListview().addColumn("Hosts")
        self.getListview().setColumnWidthMode(0, qt.QListView.Maximum)

        self.getListview().setSelected(self.rootitem, True)

        self.setRootItem(RootListViewItem(self.getListview(), name = "Untitled"))
        self.selectRootItem(True)

                                                                                                   
        self._category_items = {}

                                                                                                
                                                                        

    def update(self, hosts):
        self.clearTree()
        self.redrawTree(hosts)

    def clearTree(self):
        """
        clear the complete host tree
        """
        self.clear()
        self._category_items.clear()

    def redrawTree(self, hosts):
        for host in hosts:
            category = host.getCurrentCategory()
            self._addCategory(category)
            self._addHostToCategory(host, category)

    def _getCategoryListViewItem(self, category):
        return self._category_items.get(category, None)

    def _addCategory(self, category):
        if category not in self._category_items.keys():
            ref = CategoryListViewItem(self.rootitem, category)
            self._category_items[category] = ref
        else:
            ref = self._getCategoryListViewItem(category)
        return ref

    def _addHostToCategory(self, host, category):
        category_item = self._addCategory(category)
        category_item.addHost(host)

    def _delCategory(self, category, recursive=False):
        pass

    def selectWord(self, word):
        for category_item in self._category_items.values():
            category_item.selectByWord(word)

    def customEvent(self, event):
        pass

                                                   
                                                    
class HostsBrowser(qt.QVBox):
    """Tree view to display Hosts"""

    def __init__(self, parent, caption):
        qt.QVBox.__init__(self, parent)

        self.modelUpdateTimer = qt.QTimer(self)
       
        self.__pendingModelObjectRedraws = []

        self.connect( self.modelUpdateTimer, qt.SIGNAL("timeout()"), self._modelObjectViewUpdater)
                                        
        self.modelUpdateTimer.start( 1000  , False)
                                                                                 

        self.setName(caption) if caption else self.setName("")

        self.setFrameStyle(qt.QFrame.Panel | qt.QFrame.Plain)
        self.setLineWidth(0)

        self._host_items = {}

                                                                                                   
        self._category_items = {}

                                                                                                
                                                                        
        self._category_tree = {}

        self.contextpopups = {}
        self._setupContextPopups()

        self.contextdispatchers = {}

                       
        self._filter = ""
        self.ix = None

        self._setupContextDispatchers()

        split = qt.QSplitter(self)
        split.setOrientation(qt.QSplitter.Vertical)

        lv = self.listview = ModelObjectListView(split)
                                     
                                       
                                         
        lv.setRootIsDecorated(True)

                                               
        self.connect( lv, qt.SIGNAL("selectionChanged()"), self._itemSelected )
        self.connect( lv, qt.SIGNAL("rightButtonPressed(QListViewItem *,const QPoint&,int)"), self._showContextMenu )
                                                        
        lv.addColumn("Hosts")
        lv.setColumnWidthMode(0,qt.QListView.Maximum)
                                                                                    

                         
        lv.setTreeStepSize(20)

                                                                           
                                                                                                  
                                                                
                                                             
        self.rootitem = None

                                            
               

                                                                           
        self.details_table = EditionTable(split)
        hbox = qt.QHBox(self)
        self.object_label = qt.QLabel("", hbox)
        self.object_label.setMinimumSize(qt.QSize(50, 25))
        self.save_button = SaveButton(hbox, self._item_save)
        self._save_callback = None

        self.prefchilds = []

                              
                                                       

    def load(self, workspace):
        self.rootitem = WorkspaceListViewItem(self.listview, workspace)
        self.listview.setSelected(self.rootitem, True)

    def update(self, hosts):
        self.clearTree()
        self.redrawTree(hosts)
                                         
    def sizeHint(self):
        """Returns recommended size of dialog."""
        return qt.QSize(70, 200)

    def resizeEvent (self, event ):
                                                                  
                                                           
                                                                 
                              
        self.listview.setColumnWidth(0,self.size().width()-7)
                                                                              
                                                                       

    def clearTree(self):
        """
        clear the complete host tree
        """
        self._clearBranch(self.rootitem)
        self._host_items.clear()

    def _clearBranch(self, root):
        """
        clear a branch based on the root provided.
        """
        if root is not None:
            i = root.firstChild()
            items_to_remove = []
            while i is not None:
                items_to_remove.append(i)
                i = i.nextSibling()

            for i in items_to_remove:
                if i.type == "Category":
                    self._delCategory(i.name)
                elif i.type == "Host":
                    category_item = i.parent()
                    self._delHostFromCategory(i.object, category_item.name)

    def redrawTree(self, hosts):
        for host in hosts:
            category = host.getCurrentCategory()
            self._addCategory(category)
            self._addHostToCategory(host, category)

        for ci in self._category_items.values():
            ci.setOpen(True)
        self.createIndex(hosts)
        self.filterTree(self._filter)

    def filterTree(self, mfilter=""):
        hosts=[]
        viewall=False
        self._filter=mfilter

        for k in self._host_items.keys():
            hosts.append(self._host_items[k].object)

        if self._filter:
            hosts=self._filterHost(hosts)
        else:
            viewall=True
            hosts=[]

                                
                    

        for k in self._host_items.keys():
                                                  
            if (self._host_items[k].object.name in hosts) or viewall==True:
                self._host_items[k].setVisible(True)
            else:
                self._host_items[k].setVisible(False)


    def _filterHost(self,hosts):
                                  

        from whoosh.qparser import QueryParser
        with self.ix.searcher() as searcher:
            query = QueryParser("ip", self.ix.schema).parse(self._filter)
            results = searcher.search(query, limit=None)
                           
                        
                          
            hostv={}
            for r in results:
                hostv[r['ip']]=1

        return hostv

    def createIndex(self,hosts):
        schema = Schema(ip=TEXT(stored=True),
                        hostname=TEXT(stored=True),
                        mac=TEXT(stored=True),
                        os=TEXT(stored=True),
                        port=TEXT(stored=True),
                        srvname=TEXT(stored=True),
                        srvstatus=TEXT(stored=True),
                        vulnn=TEXT(stored=True),
                        namen=TEXT(stored=True),
                        owned=BOOLEAN,
                        cred=BOOLEAN,
                        vuln=BOOLEAN,
                        note=BOOLEAN)

        indexdir=CONF.getDataPath() + "/indexdir"
        if not os.path.exists(indexdir):
            os.mkdir(indexdir)

        self.ix = create_in(indexdir, schema)
        writer = self.ix.writer()
        revulns={}
        for host in hosts:

                          
            writer.add_document(ip=unicode(host.name), os=unicode(host.getOS()),owned=host.isOwned(),
                                vuln=True if host.vulnsCount() >0 else False,
                                note=True if len(host.getNotes()) >0 else False)

                               
                            
            for i in host.getAllInterfaces():
                for h in i._hostnames:
                    writer.add_document(ip=unicode(host.name), hostname=unicode(h),mac=unicode(i.getMAC()))


                             
            for v in host.getVulns():
                                          
                                      
                      
                                       
                                            
                writer.add_document(ip=unicode(host.name), vulnn=unicode(v.name))

                             
            for i in host.getAllInterfaces():
                for s in i.getAllServices():
                                        
                    for v in s.getVulns():
                        writer.add_document(ip=unicode(host.name), vulnn=unicode(v.name),srvname=unicode(s.getName()))
                    
                    for p in s.getPorts():
                        writer.add_document(ip=unicode(host.name), port=unicode(str(p)),owned=s.isOwned(),
                                        vuln=True if s.vulnsCount() >0 else False,
                                        note=True if len(s.getNotes()) >0 else False,
                                        cred=True if s.credsCount() > 0 else False,
                                        srvname=unicode(s.getName()),
                                        srvstatus=unicode(s.getStatus()))

        writer.commit()

    def selectWord(self, word):
        for k in self._host_items:
            host_item = self._host_items[k]
            if host_item.text(0).encode('utf8').strip() == word.strip():
                self.listview.setSelected(host_item, True)
                self.listview.ensureItemVisible(host_item)
                break
            else:
                for i in host_item.object.getAllInterfaces():
                    if i.ipv4['address'] == word.strip():
                        self.listview.setSelected(host_item, True)
                        self.listview.ensureItemVisible(host_item)
                        break
                    elif i.ipv6['address'] == word.strip():
                        self.listview.setSelected(host_item, True)
                        self.listview.ensureItemVisible(host_item)
                        break
                    else:
                        for h in i.getHostnames():
                            if h == word.strip():
                                self.listview.setSelected(host_item, True)
                                self.listview.ensureItemVisible(host_item)
                                break

    def workspaceChanged(self, workspace):
        if self.rootitem:
            root = self.rootitem
            self.listview.takeItem(root)
            del root
        self.clearTree()
        self.load(workspace)

    def updateWorkspaceName(self, nconflicts):
        self.rootitem.updateName(nconflicts)

    def _resolveConflicts(self, item):
        guiapi.resolveConflicts()

    def showResolveConflictDialog(self, conflicts):
        if len(conflicts):
            dialog = ConflictResolutionDialog(conflicts)
            dialog.exec_loop()

    def _item_save(self):
                                                                 
                         
        if self._save_callback is not None:
            self._save_callback()

    def setSaveCallback(self, callback):
        self._save_callback = callback

    def _itemSelected(self, item=False):
        """
        this is called when a list view item is selected
        """
                           
        i = self.listview.firstChild()
        self.items_selected=[]
        self.items_type={'Host': 0, 'Workspace': 0, 'Service':0,
                         'Interface':0, 'Application':0,'Category_General':0
                         ,'Category_Applications':0,'Category_Interfaces':0}
        while i is not None:
            if i.isSelected():

                if i.type=="Category":
                    self.items_type[i.type+"_"+i.name] =self.items_type[i.type+"_"+i.name]+1
                else:
                    self.items_type[i.type] =self.items_type[i.type]+1

                self.items_selected.append(i)
            i = i.itemBelow()
            mtype={'Host': 0, 'Workspace': 0, 'Service':0, 'Interface':0, 'Application':0,'Category':0}

        self.itemselected = self.listview.currentItem()

                                                                                
        self.details_table.clear()
        editor = self.itemselected.getEditor()
        editor.fillEditionTable(self.details_table)
        self.setSaveCallback(editor.save)

    def getItemSelected(self):
        return self.itemselected

    def _addCategory(self, category):
        if category not in self._category_tree:
            self._category_tree[category] = []
            ref = CategoryListViewItem(self.rootitem, category)
            self._category_items[category] = ref
        else:
            ref = self._getCategoryListViewItem(category)
        return ref

    def _addHost(self, host):
        category = host.getCurrentCategory()
        self._addCategory(category)
        self._addHostToCategory(host, category)

    def _removeHost(self, host_id):
        item = self._host_items.get(host_id, None)
        if host_id in self._host_items:
            del self._host_items[host_id]
        for category in self._category_tree.keys():
            if host_id in self._category_tree.get(category):
                self._category_tree[category].remove(host_id)
                category_item = self._getCategoryListViewItem(category)
                try:
                    category_item.takeItem(item)
                except Exception:
                    api.devlog("Exception taking item from category")

    def _editHost(self, host):
        self._removeHost(host.getID())
        self._addHost(host)

    def _addHostToCategory(self, host, category):
        category_item = self._addCategory(category)
        self._host_items[host.getID()] = HostListViewItem(category_item, host.name, host)
        self._category_tree[category].append(host.getID())

    def _delHostFromCategory(self, host, category):
        id = host.getID()
        item = self._host_items.get(id, None)
        if id in self._host_items:
            del self._host_items[id]
        if category in self._category_tree:
            if id in self._category_tree[category]:
                self._category_tree[category].remove(id)
                category_item = self._getCategoryListViewItem(category)
                api.devlog("_delHostFromCategory: about to call takeItem for category %s" % category)
                try:
                    category_item.takeItem(item)
                except Exception:
                    pass
                api.devlog("_delHostFromCategory: after takeItem")

    def _getCategoryListViewItem(self, category):
        return self._category_items.get(category, None)

    def _delCategory(self, category, recursive=False):
        if category in self._category_tree:
            if recursive:                                              
                for id in self._category_tree:
                    host_item = self._getHostListViewItem(id)
                    if host_item is not None:
                        self._delHostFromCategory(host_item.object, category)
            else:
                                                                                   
                                               
                for id in self._category_tree:
                    host_item = self._getHostListViewItem(id)
                    if host_item is not None:
                        self._moveHostToCategory(host_item.object, CONF.getDefaultCategory())

                del self._category_tree[category]
                item = self._category_items[category]
                del self._category_items[category]
                self.rootitem.takeItem(item)

    def _getHostListViewItem(self, id):
        return self._host_items.get(id, None)

    def _showContextMenu(self, item, pos, val):
        """Pop up a context menu when an item is clicked on the list view."""
        ret = None

        if item is not None:                           

                                  
                       
                                                                                                                                                            
            if self.items_type['Interface']:
                if (self.items_type['Category_General'] or self.items_type['Workspace']):
                    popname="CategoryWorkspace_Interface"
                elif (self.items_type['Host'] or self.items_type['Service']):
                    popname="ServiceHost_Interface"
                else:
                    popname=item.type

            elif (self.items_type['Host'] or self.items_type['Service']):
                if (self.items_type['Category_General'] or self.items_type['Workspace']):
                    popname="CategoryWorkspace_ServiceHost"
                elif (self.items_type['Host'] and self.items_type['Service']):
                    popname="Service_Host"
                else:
                    if item.type is "Category":
                        popname="Host"
                    else:
                        popname=item.type
            else:
                                   
                if item.type is "Category":
                    popname=item.type + "_" + item.name
                else:
                    popname=item.type

            ret = self.contextpopups[popname].exec_loop(pos)

            if ret in self.contextdispatchers:
                self.contextdispatchers[ret](item)
                  
                                                                         

            api.devlog("contextMenuEvent - item: %s - ret %s" % (self.name, ret))

              

    def _newHost(self, item):
        api.devlog("newHost")
        dialog = NewHostDialog(self, self._newHostCallback)
        dialog.exec_loop()

    def _newHostCallback(self, name, os):
        if name:
                                          
            guiapi.createAndAddHost(name, os=os)

    def _delHost(self,item):
        api.devlog("delHost")
        if item is not None and item.object is not None:                                                  
            dialog = MessageDialog(self,title="Host delete",callback=self._delSelectedCallback)
            dialog.exec_loop()

    def _delHostCallback(self, item):
        api.devlog("delcallbackHost %s " % (item.object.name))
        guiapi.delHost(item.object.getID())

    def _newInterface(self, item):
        api.devlog("newInterface")
        dialog = NewInterfaceDialog(self, self._newInterfaceCallback)
        dialog.exec_loop()

    def _newInterfaceCallback(self, name, ipv4_address, ipv6_address):
        if name and (ipv4_address or ipv6_address):
            for i in self.items_selected:
                host_id = i.object.getID()
                guiapi.createAndAddInterface(host_id, name, ipv4_address=ipv4_address, ipv6_address=ipv6_address)

    def _delInterface(self,item):
        api.devlog("delInterface")
        if item is not None and item.object is not None:                                                  
            dialog = MessageDialog(self,title="Interface delete",callback=self._delSelectedCallback)
            dialog.exec_loop()

    def _delInterfaceCallback(self, item):
        api.devlog("delcallbackInterface %s " % (item.object.name))
        _parent=item.object.getParent()
        guiapi.delInterface(_parent.getID(), item.object.getID())

    def _newService(self,item):
        api.devlog("newService")
        dialog = NewServiceDialog(self, self._newServiceSelectedCallback)
        dialog.exec_loop()

    def _newServiceSelectedCallback(self, name, protocol, ports):
        if name and protocol and ports:
            for i in self.items_selected:
                if i.type == "Interface":
                    interface_id = i.object.getID()
                    host_id = i.object.getParent().getID()
                    guiapi.createAndAddServiceToInterface(host_id, interface_id , name, protocol=protocol, ports=ports)

    def _delService(self,item):
        if item is not None and item.object is not None:                                                  
            dialog = MessageDialog(self,title="Delete Item(s)",callback=self._delSelectedCallback)
            dialog.exec_loop()

    def _delServiceCallback(self, item):
        api.devlog("delcallbackService %s " % (item.name))
        _object=item.object
        _host=_object.getParent()
        guiapi.delServiceFromHost(_host.getID(), _object.getID())

    def _delSelectedCallback(self,item):

        for i in self.items_selected:
            if i.type == "Host":
                api.devlog("delcallbackHost %s " % (i.object.name))
                guiapi.delHost(i.object.getID())
            elif i.type == "Application":
                api.devlog("delcallbackApplication %s " % (i.object.name))
                _parent=i.object.getParent()
                _object=i.object
                guiapi.delApplication(_parent.getID(),_object.getID())
            elif i.type == "Interface":
                api.devlog("delcallbackInterface %s " % (i.object.name))
                _parent=i.object.getParent()
                _object=i.object
                guiapi.delInterface(_parent.getID(), _object.getID())
            elif i.type == "Service":
                api.devlog("delcallbackService %s " % (i.name))
                _object=i.object
                parent_interface = self._getParentForType(i, "Interface").object
                parent_host = self._getParentForType(i, "Host").object
                guiapi.delServiceFromInterface(parent_host.getID(), parent_interface.getID(), _object.getID())
                                                       
        self.listview.setCurrentItem(self.rootitem)
        self._itemSelected()

    def _getParentForType(self, obj, obj_type):
        parent = obj.parent()
        if obj_type == parent.type:
            return parent
        else:
            return self._getParentForType(parent, obj_type)

    def _newCategory(self,item):
        api.devlog("newCategory")

    def _renCategory(self,item):
        api.devlog("renCategory")

    def _delCategorymenu(self,item):
        api.devlog("delCategorymenu")
        if item is not None:                                                  
            dialog = MessageDialog(self,title="Category delete",callback=self._delCategoryCallback,item=item)
            dialog.exec_loop()

    def _delCategoryCallback(self, item):
        api.devlog("delcallbackCategory %s " % (item.name))
                                        
                                        
                                                

    def _newVuln(self,item):
        api.devlog("newVuln")
        if item is not None and item.object is not None:
            dialog = NewVulnDialog(self, callback=self._newVulnSelectedCallback, vuln_web_enabled=False)
                                                                                        
            dialog.exec_loop()


    def _newVulnSelectedCallback(self, type, name, desc):

        api.devlog("newVulnMulti (%s) (%s) " % (name, desc))
        for i in self.items_selected:
            guiapi.createAndAddVuln(i.object, name, desc)

    def _listVulns(self,item):
        if item is not None and item.object is not None:
            dialog = VulnsDialog(parent=self, model_object=item.object)
            dialog.exec_loop()

    def _listVulnsCvs(self,item):
        vulns=""
        hosts=[]
        for k in self._host_items.keys():
            hosts.append(self._host_items[k].object)

        filename =  qt.QFileDialog.getSaveFileName(
                    "/tmp",
                    "Vulnerability CVS  (*.csv)",
                    None,
                    "save file dialog",
                    "Choose a file to save the vulns" )
        from exporters.tofile import CSVVulnStatusReport
        CSVVulnStatusReport(path = filename, 
                            modelobjects = hosts).createCSVVulnStatusReport() 

    def _importVulnsCvs(self,item):
        filename =  qt.QFileDialog.getOpenFileName(
                    CONF.getDefaultTempPath(),
                    "Csv vulnerability file  (*.*)",
                    None,
                    "open file dialog",
                    "Choose a vulnerability file" );
        
        if os.path.isfile(filename):
            with open(filename) as f:
                data = f.read()
            f.close()

            for l in data.split("\n"):
                api.devlog(l)
                if re.search("^#",l):
                    api.devlog("ERROR FILE")
                    continue
                
                d = l.split("|")
                
                if len(d) <=5:
                    api.devlog("Error vuln line: ("+l+")" )
                else:
                    self._newVulnImport(d[0],d[1],d[2],d[3],d[4],d[5],d[6])

    def _newVulnImport(self,ip,port,protocol,name,desc,severity,type):
        if port == "0": #vuln host
            h_id = guiapi.createAndAddHost(ip)
            v_id = guiapi.createAndAddVulnToHost(h_id, name, desc, [],severity)
        else: #vuln port
            h_id = guiapi.createAndAddHost(ip)
            if self._isIPV4(ip):
                i_id = guiapi.createAndAddInterface(h_id,ip,ipv4_address=ip)
            else:
                i_id = guiapi.createAndAddInterface(h_id,ip,ipv6_address=ip)
            s_id = guiapi.createAndAddServiceToInterface(h_id,i_id,port,protocol,ports=[port])
            if type == "2":
                v_id = guiapi.createAndAddVulnWebToService(h_id,s_id, name, desc, "/","/",[],severity)
            else:
                v_id = guiapi.createAndAddVulnToService(h_id,s_id, name, desc, [],severity)

        api.devlog("type:" + type)
                                   
    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

    def _listNotes(self, item):
        if item is not None and item.object is not None:                                                  
            dialog = NotesDialog(parent=self, model_object=item.object)
            dialog.exec_loop()

    def _newNote(self, item):
        if item is not None and item.object is not None:                                                  
            dialog = NewNoteDialog(self, callback=self._newNoteSelectedCallback)
            dialog.exec_loop()

    def _newNoteSelectedCallback(self, name, text):
        for i in self.items_selected:
            if i.type == "Host":
                api.devlog("newNotecallbackHost %s " % (i.object.name))
                guiapi.createAndAddNoteToHost(i.object.getID(), name, text)
            elif i.type == "Application":
                _parent=i.object.getParent()
                api.devlog("newNotecallbackApplication %s " % (i.object.name))
                guiapi.createAndAddNoteToApplication(_parent.getID(), i.object.getID(), name, text)
            elif i.type == "Interface":
                _parent=i.object.getParent()
                api.devlog("newNotecallbackInterface %s " % (i.object.name))
                guiapi.createAndAddNoteToInterface(_parent.getID(), i.object.getID(), name, text)
            elif i.type == "Service":
                _parent=i.object.getParent().getParent()
                api.devlog("newNotecallbackService %s " % (i.name))
                guiapi.createAndAddNoteToService(_parent.getID(), i.object.getID(), name, text)

    def _listCreds(self, item):
        if item is not None and item.object is not None:
            dialog = CredsDialog(parent=self, model_object=item.object)
            dialog.exec_loop()

    def _newCred(self, item):
        api.devlog("newCred")
        dialog = NewCredDialog(self, self._newCredSelectedCallback)
        dialog.exec_loop()

    def _importCreds(self, item):
        filename =  qt.QFileDialog.getOpenFileName(
                    CONF.getDefaultTempPath(),
                    "Csv user,pass or user:pass  (*.*)",
                    None,
                    "open file dialog",
                    "Choose a password file" );
        
        if os.path.isfile(filename):
            with open(filename) as f:
                data = f.read()
            f.close()

            for l in data.split():
                api.devlog(l)
                if re.search("^#",l):
                    api.devlog("ERROR FILE")
                    continue
                
                d = l.split(",")
                if len(d)<=1:
                    d = l.split(":")
                
                api.devlog(d)
                if len(d) <=1:
                    api.devlog("Error password line: ("+l+")" )
                else:
                    self._newCredSelectedCallback(d[0],d[1])

    def _newCredSelectedCallback(self,username,password):

        for i in self.items_selected:
            if i.type in ['Host','Service']:
                guiapi.createAndAddCred(i.object,username,password)

    def _saveWorkspace(self, item):
        self.parent().parent().getMainApp().saveWorkspaces()

    def _syncWorkspace(self, item):
        self.parent().parent().getMainApp().syncWorkspaces()

    def _showWorkspaceProperties(self, item):
        if item.object is not None:
            api.log("Llege a showWorkspace", "ERROR")
            d = WorkspacePropertiesDialog(self, "Workspace Properties", workspace=item.object)
            d.exec_loop()

    def _modelObjectViewUpdater(self): 
        if len(self.__pendingModelObjectRedraws):
            self.update(self.__pendingModelObjectRedraws.pop().hosts)
            self.__pendingModelObjectRedraws[:] = []

    def customEvent(self, event):
        if event.type() == UPDATEMODEL_ID:
            self.__pendingModelObjectRedraws.append(event)

        elif event.type() == RENAMEHOSTSROOT_ID:
            self.renameRootItem(event.name)

        elif event.type() == DIFFHOSTS_ID:
            self._diffHosts(event.old_host, event.new_host)

        elif event.type() == CLEARHOSTS_ID:
            self.clearTree()

        elif event.type() == WORKSPACE_CHANGED:
            self.workspaceChanged(event.workspace)

        elif event.type() == CONFLICT_UPDATE:
            self.updateWorkspaceName(event.nconflicts)

        elif event.type() == RESOLVECONFLICTS_ID:
            self.showResolveConflictDialog(event.conflicts)

        elif event.type() == ADDHOST:
            self._addHost(event.host)

        elif event.type() == DELHOST:
            self._removeHost(event.host_id)

        elif event.type() == EDITHOST:
            self._editHost(event.host)


    def _setupContextPopups(self):
        """
        Configures a context popup menu for each kind of item shown in the tree.
        This is done because different options may be needed for each item
        """
                         
        popup = qt.QPopupMenu(self)
                                      
                                             
                                            
        popup.insertSeparator()
        popup.insertItem('Resolve Conflicts', 303)
        popup.insertItem('Save Vulns CSV', 402)
        popup.insertItem('Import Vulns CSV', 403)
                                
                                              
        popup.insertSeparator()
        popup.insertItem('Add Host', 800)

        self.contextpopups["Workspace"] = popup

        self.contextpopups["Category_General"] = self.contextpopups["Workspace"]

                                
        popup = qt.QPopupMenu(self)
                                                  
                                
                                       

        self.contextpopups["Category_Applications"] = popup

                              
        popup = qt.QPopupMenu(self)
        popup.insertItem('Add Interfaces', 600)
                                
                                       

        self.contextpopups["Category_Interfaces"] = popup

                        
                                     
                                                     
                                 
                                              
                                 
                                                   
                                                      
                                 
                                           
                                             
                                 
                                        

                                                   

               
        popup = qt.QPopupMenu(self)
        popup.insertItem('Delete Host', 802)
        popup.insertSeparator()
        popup.insertItem('Add Interface', 600)
        popup.insertSeparator()
        popup.insertItem('New Vulnerability',400)
        popup.insertItem('List Vulnerabilities',401)
        popup.insertSeparator()
        popup.insertItem('New note', 500)
        popup.insertItem('Show notes', 501)
        popup.insertSeparator()
        popup.insertItem('New Credential', 550)
        popup.insertItem('Show Credentials', 551)
        popup.insertItem('Import Creds', 561)
                                
                                       

        self.contextpopups["Host"] = popup

                    
        popup = qt.QPopupMenu(self)
        popup.insertItem('Delete Interface', 602)
        popup.insertSeparator()
        popup.insertItem('Add Service', 200)
        popup.insertSeparator()
        popup.insertItem('New Vulnerability',400)
        popup.insertItem('List Vulnerabilities',401)
        popup.insertSeparator()
        popup.insertItem('New note', 500)
        popup.insertItem('Show notes', 501)
                                
                                       

        self.contextpopups["Interface"] = popup

                  
        popup = qt.QPopupMenu(self)
        popup.insertItem('Delete Service', 202)
        popup.insertSeparator()
        popup.insertItem('New Vulnerability',400)
        popup.insertItem('List Vulnerabilities',401)
        popup.insertSeparator()
        popup.insertItem('New note', 500)
        popup.insertItem('Show notes', 501)
        popup.insertSeparator()
        popup.insertItem('New Credential', 550)
        popup.insertItem('Show Credentials', 551)
        popup.insertItem('Import Creds', 561)
                                
                                       

        self.contextpopups["Service"] = popup

                       
                       
                       

                                


                     
        popup = qt.QPopupMenu(self)
        popup.insertItem('Delete Items', 202)
        popup.insertSeparator()
        popup.insertItem('New Vulnerability Items',400)
        popup.insertSeparator()
        popup.insertItem('New note Items', 500)
        popup.insertSeparator()
        popup.insertItem('New Credential', 550)
        popup.insertItem('Import Creds', 561)

        self.contextpopups["Service_Host"] = popup

                              
                        
        popup = qt.QPopupMenu(self)
        popup.insertItem('Add Service', 200)
        popup.insertSeparator()
        popup.insertItem('Delete Items', 202)
        popup.insertSeparator()
        popup.insertItem('New Vulnerability Items',400)
        popup.insertSeparator()
        popup.insertItem('New note Items', 500)
        popup.insertSeparator()
        popup.insertItem('New Credential', 550)
        popup.insertItem('Import Creds', 561)
                                
                                       

        self.contextpopups["ServiceHost_Interface"] = popup

                                    
        popup = qt.QPopupMenu(self)
                                      
                                             
        popup.insertItem('Properties', 302)
        popup.insertSeparator()
        popup.insertItem('Add Host', 800)
        popup.insertSeparator()
        popup.insertItem('Add Service', 200)
        popup.insertSeparator()
        popup.insertItem('Delete Items', 202)
        popup.insertSeparator()
        popup.insertItem('New Vulnerability Items',400)
        popup.insertSeparator()
        popup.insertItem('New note Items', 500)
        popup.insertSeparator()
        popup.insertItem('Add Service', 200)
        popup.insertSeparator()
        popup.insertItem('New Credential', 550)
        popup.insertItem('Import Creds', 561)
                                
                                       
        self.contextpopups["CategoryWorkspace_Interface"] = popup

                                      
        popup = qt.QPopupMenu(self)
                                      
                                             
        popup.insertItem('Properties', 302)
        popup.insertSeparator()
        popup.insertItem('Add Host', 800)
        popup.insertSeparator()
        popup.insertItem('Delete Items', 202)
        popup.insertSeparator()
        popup.insertItem('New Vulnerability Items',400)
        popup.insertSeparator()
        popup.insertItem('New note Items', 500)
        popup.insertSeparator()
        popup.insertItem('New Credential', 550)
        popup.insertItem('Import Creds', 561)
                                
                                       
        self.contextpopups["CategoryWorkspace_ServiceHost"] = popup


                                    
                              
                                                

                                                                                             
                                                             
                                                                                       
                                                                                       
    def _setupContextDispatchers(self):
        """
        Configures a context dispatcher for each kind of item shown in the tree.
        This is done because different options may be needed for each item
        """

        self.contextdispatchers[100] = self._newCategory
        self.contextdispatchers[102] = self._delCategorymenu

        self.contextdispatchers[200] = self._newService
        self.contextdispatchers[202] = self._delService

                                                           
                                                           
        self.contextdispatchers[302] = self._showWorkspaceProperties
        self.contextdispatchers[303] = self._resolveConflicts

        self.contextdispatchers[400] = self._newVuln
        self.contextdispatchers[401] = self._listVulns
        self.contextdispatchers[402] = self._listVulnsCvs
        self.contextdispatchers[403] = self._importVulnsCvs

        self.contextdispatchers[500] = self._newNote
        self.contextdispatchers[501] = self._listNotes

        self.contextdispatchers[550] = self._newCred
        self.contextdispatchers[551] = self._listCreds
        self.contextdispatchers[561] = self._importCreds

        self.contextdispatchers[600] = self._newInterface
        self.contextdispatchers[602] = self._delInterface

        self.contextdispatchers[800] = self._newHost
        self.contextdispatchers[802] = self._delHost


    def renameRootItem(self, new_name):
        self.rootitem.setText(0, new_name)

########NEW FILE########
__FILENAME__ = mainwindow
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import os
import sys
import qt
from gui.qt3.pyqonsole.widget import ShellWidget
from gui.qt3.tabmanager import TabManager
from gui.qt3.perspective import PerspectiveManager
from gui.qt3.hostsbrowser import HostsBrowser
from gui.qt3.workspacebrowser import WorkspaceTreeWindow
from gui.qt3.dialogs import *
from gui.qt3.configdialog import ConfigDialog
from gui.qt3.toolbars import *
from gui.qt3.customevents import *
from model.guiapi import notification_center as notifier
from managers.all import PersistenceManagerFactory, CouchdbManager


import model.api
import webbrowser
sys.path.append("./dependencies/jit")
import subprocess
import datetime
import threading
import time

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

                                    
test_count = 0

                                                                                

class MainWindow(qt.QMainWindow):

    def __init__(self, title, main_app, model_controller, plugin_manager):
        qt.QMainWindow.__init__(self, None, title, qt.Qt.WDestructiveClose)
        self.setWindowState(qt.Qt.WindowMaximized)
        self.setCaption(title)


                              
        self.setIcon(qt.QPixmap(os.path.join(CONF.getIconsPath(),"faraday_icon.png")))

                                                                                 
        self._main_app = main_app
        self._model_controller = model_controller

        self._mainArea = qt.QHBox(self)
        self.setCentralWidget(self._mainArea)
        self._vb_splitter = qt.QSplitter(self._mainArea)
        self._vb_splitter.setOrientation(qt.QSplitter.Vertical)
                                                         
        self._hb_splitter = qt.QSplitter(self._vb_splitter)
        self._hb_splitter.setOrientation(qt.QSplitter.Horizontal)
                                                          
                                                                            
                                          

        self.statusBar().setSizeGripEnabled(False)

        self._shell_widgets = []

                                  
                                                                               
                                         
        self._tab_manager = TabManager(self._hb_splitter)
        self._perspective_manager = PerspectiveManager(self._hb_splitter, self._main_app)

                        
        self._hosts_treeview = HostsBrowser(self._perspective_manager,"Hosts")
        notifier.registerWidget(self._hosts_treeview)

        self._perspective_manager.registerPerspective(self._hosts_treeview, default=True)
        
                                                                        
        wtw = WorkspaceTreeWindow(self._perspective_manager, "Workspaces",
                                  self._main_app.getWorkspaceManager())
        self._perspective_manager.registerPerspective(wtw)
        self._workspaces_treeview = wtw

        self._log_console = LogConsole(self._vb_splitter,"Console")

                                         
        self._actions = dict()
        self._setupActions()

                              
        self._menues = {}
        self._setupMenues()

                  
        self.main_toolbar = qt.QToolBar(self,'main toolbar')
        self._setupMainToolbar()

        self.location_toolbar = LocationToolbar(self,'location toolbar')
        self.location_toolbar.setOffset(1500)
                                     

                                    
        self._status_bar_widgets = dict()
        self._setupStatusBar()

        self._is_shell_maximized = False

                    
        self.shell_font=qt.QFont()
        self.shell_font.setRawName(CONF.getFont())
        self.setSizeFont()
        
    def setSizeFont(self):
        if re.search("fixed",str(self.shell_font.family()),re.IGNORECASE) is None:
            self.shell_font=qt.QFont()
            CONF.setFont("-Misc-Fixed-medium-r-normal-*-12-100-100-100-c-70-iso8859-1")
            CONF.saveConfig()
            self.shell_font.setRawName(CONF.getFont())

        self._sizes = [6,7,8,9,10,11,12,14,16,18,20,22,24,26,28,36]
        i=0
        self._size=6
        for f_i in self._sizes:
            if f_i == self.shell_font.pixelSize():
                self._size=i
            i+=1
        

    def setMainApp(self, mainapp):
       self._main_app = mainapp


    def _setupActions(self):
        """
        creates some actions needed on some menues and toolbars
        Actions are later added to different toolbars, for example in
        method _setupMainToolbar
        """
                 
                         
        a = self._actions["new_shell"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"newshell.png"))), "&New Shell", qt.Qt.CTRL + qt.Qt.SHIFT + qt.Qt.Key_T, self, "New Shell" )
        self.connect(a, qt.SIGNAL('activated()'), self.createShellTab)

                   
        a = self._actions["close_shell"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"exit.png"))), "&Close Shell", qt.Qt.CTRL + qt.Qt.SHIFT +qt.Qt.Key_W, self, "New Shell" )
        self.connect(a, qt.SIGNAL('activated()'), self.destroyShellTab)

                          
        a = self._actions["toggle-hosttree"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"HostTreeView.png"))), "Toggle Host Tree", 0, self, "Toggle Log Console" )
        a.setToggleAction(True)
        a.toggle()                                                               
        self.connect(a, qt.SIGNAL('activated()'), self.togglePerspectives)

                        
        a = self._actions["toggle-logconsole"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"LogConsole.png"))), "Toggle Log Console", 0, self, "Toggle Log Console" )
        a.setToggleAction(True)
        a.toggle()                                                             
        self.connect(a, qt.SIGNAL('activated()'), self.toggleLogConsole)

                               
        a = self._actions["maximize-shell"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"maximize.png"))), "Maximize Shell", 0, self, "Maximize Shell" )
        a.setToggleAction(True)
                                                                                
        self.connect(a, qt.SIGNAL('activated()'), self.maximizeShell)
        self._tab_manager.tabBar().addAction("maximize", self.maximizeShell)

                                  
                                                                                                                                                                                
                                
                                                                                
                                                                        
                                                                                        

                     
        #a = self._actions["test"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"donotpresstheredbutton.png"))), "Test", qt.Qt.CTRL + qt.Qt.Key_H, self, "Test" )
                                                                
        #self.connect(a, qt.SIGNAL('activated()'), self.test)

        a = self._actions["screenshot"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"Screenshot.png"))), "Take Screenshot", 0, self, "Take Screenshot" )
        self.connect(a, qt.SIGNAL('activated()'), self.takeScreenshot)

                         
        a = self._actions["clear-hosttree"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"clear.png"))), "Clear Host Tree", qt.Qt.CTRL + qt.Qt.Key_R, self, "Clear Host Tree" )
        self.connect(a, qt.SIGNAL('activated()'), self._hosts_treeview.clearTree)

        
                           
        a = self._actions["repo-config"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"connect.png"))), "Server Connection", 0, self, "Server Connection" )
        self.connect(a, qt.SIGNAL('activated()'), self._showRepositoryConfigDialog)

                                  
        a = self._actions["visualization"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"visualize.png"))), "Visualize", 0, self, "Visualize" )
        self.connect(a, qt.SIGNAL('activated()'), self.runVisualization)

        a = self._actions["plugin"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"config.png"))), "Plugin", 0, self, "Plugin" )
        self.connect(a, qt.SIGNAL('activated()'), self.showPluginSettingsDialog)

                       
        a = self._actions["documentation"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"Documentation.png"))), "Documentation", 0, self, "Documentation" )
        self.connect(a, qt.SIGNAL('activated()'), self.go2Website)

                      
        a = self._actions["exit-faraday"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"exit.png"))), "Exit Faraday", 0, self, "Exit Faraday" )
        self.connect(a, qt.SIGNAL('activated()'), self.exitFaraday)
        
                               
                                                                                                                                                                          
                                                                       
        
                          
        a = self._actions["create-workspace"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"sync.png"))), "Create", 0, self, "Create" )
        self.connect(a, qt.SIGNAL('activated()'), self.createWorkspace)
        
                        
                                                                                                                                                            
                                                                       
        
                        
        # a = self._actions["open-workspace"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"sync.png"))), "Open", 0, self, "Open" )
        # self.connect(a, qt.SIGNAL('activated()'), self.openWorkspace)

                        
        a = self._actions["reconnect"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"sync.png"))), "Reconnect", 0, self, "Reconnect" )

        self.connect(a, qt.SIGNAL('activated()'), self.reconnect)

        a = self._actions["bfont"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"fontb.png"))), "Big Font", 0, self, "Big Font" )
        self.connect(a, qt.SIGNAL('activated()'), self.setBfont)

        a = self._actions["sfont"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"fonts.png"))), "Small Font", 0, self, "Small Font" )
        self.connect(a, qt.SIGNAL('activated()'), self.setSfont)
                      
        if CONF.getDebugStatus():
            a = self._actions["debug"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"debug.png"))), "Debug", 0, self, "Debug" )
            self.connect(a, qt.SIGNAL('activated()'), self.doDebug)


    def _setupStatusBar(self):
        label_order = ["username", "userLevel", "space", "status"]
        for lname in label_order:
            l = qt.QLabel("", self)
            l.setFrameStyle(qt.QFrame.MenuBarPanel | qt.QFrame.Plain)
            self._status_bar_widgets[lname] = l
            self.statusBar().addWidget(l, 0, True)
                                                                                         
        w = qt.QWidget(self)
        self.statusBar().addWidget(w, 1, True)

    def _setupMenues(self):
        """
        Configures all the main windows menues
        """
                                                                                         
                          
        self._menues["file"] = qt.QPopupMenu(self)
        self.menuBar().insertItem('&File',self._menues["file"])
                                                                   
                                                                    
                                                                     
        
                                                               
                                                                          
                                                                          
        self._actions["exit-faraday"].addTo(self._menues["file"]);
        self.menuBar().insertSeparator()

                          
        self._menues["shell"] = qt.QPopupMenu(self)
        self.menuBar().insertItem('&Shell',self._menues["shell"])
        self._actions["new_shell"].addTo(self._menues["shell"]);
        self._actions["close_shell"].addTo(self._menues["shell"]);
        self._actions["maximize-shell"].addTo(self._menues["shell"]);
                                                                         
        self.menuBar().insertSeparator()
                          
        self._menues["edit"] = qt.QPopupMenu(self)
        self.menuBar().insertItem('&Edit',self._menues["edit"])
        self._menues["edit"].insertItem('&Copy', self._copy)
        self._menues["edit"].insertItem('&Paste', self._paste)
                                                                                
        self._actions["repo-config"].addTo(self._menues["edit"]);
                                          
        self.menuBar().insertSeparator()

                               
        self._menues["workspace"] = qt.QPopupMenu(self)
        self.menuBar().insertItem('&Workspace',self._menues["workspace"])
        # self._actions["open-workspace"].addTo(self._menues["workspace"])
        self._actions["create-workspace"].addTo(self._menues["workspace"])
                                                                          
                                                                          
                                               
        self.menuBar().insertSeparator()

                           
        self._menues["tools"] = qt.QPopupMenu(self)
        self.menuBar().insertItem('&Tools',self._menues["tools"])
        self._actions["visualization"].addTo(self._menues["tools"]);
                                                                                     
        self._actions["plugin"].addTo(self._menues["tools"]);
        self._actions["screenshot"].addTo(self._menues["tools"]);
                                                                                          
        self.menuBar().insertSeparator()

                          
        self._menues["view"] = qt.QPopupMenu(self)
        self.menuBar().insertItem('&View',self._menues["view"])
        self._actions["toggle-hosttree"].addTo(self._menues["view"]);
        self._actions["toggle-logconsole"].addTo(self._menues["view"]);
        self._actions["maximize-shell"].addTo(self._menues["view"]);
                                          
        self.menuBar().insertSeparator()

                          
        self._menues["help"] = qt.QPopupMenu(self)
        self.menuBar().insertItem('&Help',self._menues["help"])
        self._menues["help"].insertItem('&About', self._showAboutDialog)
        self._actions["documentation"].addTo(self._menues["help"]);
                                         

                                             
                                                                      
    def _setupMainToolbar(self):
        """
        Sets up the main toolbar
        """
        self._actions["new_shell"].addTo(self.main_toolbar)
        self._actions["toggle-hosttree"].addTo(self.main_toolbar)
        self._actions["toggle-logconsole"].addTo(self.main_toolbar)
        self._actions["maximize-shell"].addTo(self.main_toolbar)
                                                       
        self._actions["clear-hosttree"].addTo(self.main_toolbar)
        self._actions["repo-config"].addTo(self.main_toolbar)
        self._actions["visualization"].addTo(self.main_toolbar)
        self._actions["plugin"].addTo(self.main_toolbar)
        self._actions["screenshot"].addTo(self.main_toolbar)
        self._actions["reconnect"].addTo(self.main_toolbar)
        self._actions["sfont"].addTo(self.main_toolbar)
        self._actions["bfont"].addTo(self.main_toolbar)
        if CONF.getDebugStatus():
            self._actions["debug"].addTo(self.main_toolbar)

    def setFilter(self):
        value = self.location_toolbar.getSelectedValue()
        self._hosts_treeview.filterTree(value)
        self.location_toolbar.addFilter(value)

    def showAll(self):
                                       
        self.show()
                       
        self.main_toolbar.show()
        self.location_toolbar.show()
                                     
        self._tab_manager.show()

        self._perspective_manager.show()

                                    
        self._hosts_treeview.show()
                                
        self._log_console.show()
                                
        for shell_widget in self._shell_widgets:
            shell_widget.show()

    def addShell(self, shell_widget):
        self._shell_widgets.append(shell_widget)
                                                       
                                                
        self._tab_manager.addView(shell_widget)
        shell_widget.show()
        shell_widget.setFocus()

    def createShellTab(self):
                                                         
        tab_name = "Shell-%d" % self._tab_manager.getNextId()
        self._main_app.createShellEnvironment(tab_name)

    def destroyShellTab(self):
                                                              
                                  
        tabmanager = self.getTabManager()
        if tabmanager.count() == 1:
            self.exitFaraday()
        else:
            index = tabmanager.currentPageIndex()
            name = tabmanager.label(index)
            self._main_app.deleteShellEnvironment(str(name))
        

    def imIncomplete(self):
        model.api.log("This function is not implemented yet")

    
                                                                            
                                                                   
                                                                       
                                                                                
                                                                               
                           
    
                                                                                               
    def _copy(self):
        None

    def _paste(self):
                      
                                
        text = qt.QApplication.clipboard().text()
        if not text.isEmpty():
            text.replace(qt.QRegExp("\n"), "\r")
        ev = qt.QKeyEvent(qt.QEvent.KeyPress, 0, -1, 0, text)
        shell = self.getShellWithFocus()
        if shell:
            shell.myemit('keyPressedSignal', (ev,))                                     
            shell.myemit('clearSelectionSignal')
        qt.QApplication.clipboard().setSelectionMode(False)

    def _importWorkspace(self):
        model.api.showPopup("Be careful that importing could overwrite existing files", level="Warning")
        wm = self._main_app.getWorkspaceManager()
        mwin = self._main_app.getMainWindow()
            
        filename =  QFileDialog.getOpenFileName(
                    "$HOME/.faraday",
                    "Faraday export file  (*.faraday)",
                    None,
                    "import file dialog",
                    "Choose a file to import" );
        if filename and filename is not None:
            model.api.log("Import function %s/ %s" % (CONF.getPersistencePath(),filename))
            
                                                                                                               
                                                  
            api.importWorskpace("%s/" % CONF.getPersistencePath(), filename)
            
            wm.loadWorkspaces()
            w = wm.getActiveWorkspace()
            wm.setActiveWorkspace(w)                                      
            
                                                          
            mwin.getWorkspaceTreeView().loadAllWorkspaces()

    def _exportWorkspace(self):
        filename =  QFileDialog.getSaveFileName(
                    "/tmp",
                    "Faraday export file  (*.faraday)",
                    None,
                    "save file dialog",
                    "Choose a file to save the export" );
        if filename and filename is not None:
            model.api.log("Export function %s" % filename)
            api.exportWorskpace("%s/" % CONF.getPersistencePath(), "%s.faraday" % filename)
        
        
    def getTabManager(self):
        return self._tab_manager

    def getLogConsole(self):
        return self._log_console
    
    def getHostTreeView(self):
        return self._hosts_treeview 
    
    def getWorkspaceTreeView(self):
        return self._workspaces_treeview
    
    def refreshWorkspaceTreeView(self):
        self._workspaces_treeview.loadAllWorkspaces()
        
    def _showAboutDialog(self):
        about = AboutDialog(self)
        about.exec_loop()

    def _showConfigDialog(self):
        config_dialog = ConfigDialog(self)
        config_dialog.exec_loop()
    
                    
                                                                                                  
                                                                          
                             
    
    def showExceptionDialog(self, text="", callback=None , excection_objects=None):
        exc_dialog = ExceptionDialog(self, text, callback, excection_objects)
        return exc_dialog.exec_loop()

    def showSimpleDialog(self, text, type="Information"):
        dialog = SimpleDialog(self, text, type)
        return dialog.exec_loop()

    def showPluginSettingsDialog(self, type="Information"):
        dialog = PluginSettingsDialog(self, self._main_app.plugin_manager)
        return dialog.exec_loop()

    def showDebugPersistenceDialog(self, text, type="Information"):
        dialog = DebugPersistenceDialog(self)
        return dialog.exec_loop()

    def showPopup(self, text, type="Information"):
        message = "<b>%s:</b>\n%s" % (type, text)
        notification = NotificationWidget(self, message)
        notification.show()
        qt.QTimer.singleShot(4000, notification.closeNotification)

    def doLogin(self, callback=None):
                                                              
                                                                                     
        login_dialog = LoginDialog(self, callback)
        result_code = login_dialog.exec_loop()
                                                           
                                                                         
        if result_code == qt.QDialog.Rejected:
            return None,None
        else:
            return login_dialog.getData()

    def showLoggedUser(self, username):
        self._status_bar_widgets["username"].setText("Logged user: %s" % username)
  
    def _showRepositoryConfigDialog(self):
                                                                            
        repoconfig_dialog = RepositoryConfigDialog(self, CONF.getCouchURI(),
                                                   CONF.getCouchIsReplicated(),
                                                   CONF.getCouchReplics(),
                                                   callback=None) 
        result = repoconfig_dialog.exec_loop()        
        if result == qt.QDialog.Accepted:
            repourl, isReplicated, replics = repoconfig_dialog.getData()
            api.devlog("repourl = %s" % repourl)
            wm = self._main_app.getWorkspaceManager()
            if not CouchdbManager.testCouch(repourl):
                self.showPopup("""
                Repository URL Not valid, check if
                service is available and that connection string is from
                the form: http[s]://hostname:port""")
                repourl, isReplicated, replics = "", False, ""

            CONF.setCouchUri(repourl)
            CONF.setCouchIsReplicated(isReplicated)
            CONF.setCouchReplics(replics)
            CONF.saveConfig()
            

            couchdbmanager = PersistenceManagerFactory().getInstance()
            wm.setCouchManager(couchdbmanager)

            wm.loadWorkspaces()
            mwin = self._main_app.getMainWindow()
            mwin.getWorkspaceTreeView().loadAllWorkspaces()
            mwin.getWorkspaceTreeView().setDefaultWorkspace()

    def showConflictsDialog(self, local):
        dialog = ResolveConflictsDialog(self, local=local)
        result = dialog.exec_loop()
        return result

    def customEvent(self, event):
        """
        This method is to be able to handle custom events in order
        to show custom dialogs or pop ups
        """
        if event.type() ==  EXCEPTION_ID:
            self.showExceptionDialog(event.text, event.callback, event.exception_objects)
        elif event.type() ==  SHOWDIALOG_ID:
            self.showSimpleDialog(event.text, event.level)
        elif event.type() ==  SHOWPOPUP_ID:
            self.showPopup(event.text, event.level)
        elif event.type() == CONFLICTS_ID:
                                                                  
            self.showConflictsDialog(event.local)

    def update(self, event):
        if event.type() ==  EXCEPTION_ID:
            self.showExceptionDialog(event.text, event.callback, event.exception_objects)
        elif event.type() ==  SHOWDIALOG_ID:
            self.showSimpleDialog(event.text, event.level)
        elif event.type() ==  SHOWPOPUP_ID:
            self.showPopup(event.text, event.level)
        elif event.type() == CONFLICTS_ID:
            self.showConflictsDialog(event.local)

    def toggleLogConsole(self):
        if self._log_console.isVisible():
            self._log_console.hide()
        else:
            self._log_console.show()
            if self._is_shell_maximized:
                self._actions["maximize-shell"].toggle()
                self._is_shell_maximized = False

    def togglePerspectives(self):
        if self._perspective_manager.isVisible():
            self._perspective_manager.hide()
        else:
            self._perspective_manager.show()
            if self._is_shell_maximized:
                self._actions["maximize-shell"].toggle()
                self._is_shell_maximized = False

    def maximizeShell(self):
                                       
                                                      
                                                            
        if self._is_shell_maximized:
            self._is_shell_maximized = False
            if not self._log_console.isVisible():
                self.toggleLogConsole()
                self._actions["toggle-logconsole"].toggle()
            if not self._perspective_manager.isVisible():
                self.togglePerspectives()
                self._actions["toggle-hosttree"].toggle()
        else:
            self._is_shell_maximized = True
            if self._log_console.isVisible():
                self.toggleLogConsole()
                self._actions["toggle-logconsole"].toggle()

            if self._hosts_treeview.isVisible():
                self.togglePerspectives()
                self._actions["toggle-hosttree"].toggle()

    def changeShellFont(self):
        preferences_dialog = PreferencesDialog(self)
        if preferences_dialog.exec_loop():
            self.setShellFont()
            CONF.setFont(self.shell_font.rawName())
            CONF.saveConfig()
    
    def setBfont(self):
        if (self._size+1) < len(self._sizes):
            self._size=self._size+1
            self.setShellFont()

    def setSfont(self):
        if (self._size-1) > -1:
            self._size=self._size-1
            self.setShellFont()
            
    def getShellWithFocus(self):
        for shell in self._shell_widgets:
            if shell.hasFocus():
                return shell
        return None

    def setShellFont(self):
        self.shell_font=qt.QFont()
        CONF.setFont("-Misc-Fixed-medium-r-normal-*-"+str(self._sizes[self._size])+"-100-100-100-c-70-iso8859-1")
        CONF.saveConfig()
        self.shell_font.setRawName(CONF.getFont())

        for shell in self._shell_widgets:
            shell.setVTFont(self.shell_font)

    def runVisualization(self):
        """
        runs script that builds the html for visutalizacion and opens a browser
        """

        ret, url = self._main_app.getWorkspaceManager().createVisualizations()
        if ret:
            webbrowser.open_new(url)

                                                                                             
                                                                                   
                                                                                   
                                                                                 

    def go2Website(self):
                                                                                                   
                            
                                                                                                
                                                                               
        webbrowser.open_new("https://www.faradaysec.com")
        model.api.log("Opening faraday's website")

    def closeEvent(self, e):
        result = self.exitFaraday()
        if result == qt.QDialog.Accepted:
            e.accept()

    def exitFaraday(self):
        exit_dialog = ExitDialog(self, self._main_app.quit)
        return exit_dialog.exec_loop()

    def doDebug(self):
        exit_dialog = MessageDialog(self, self.__debug,"Debug", "Faraday use IPython for debuging, please switch to terminal\n where do you execute the framework, use Ctrl+D to exit debug.\nDo you want to continue?" )
        return exit_dialog.exec_loop()
    
    def __debug(self, item=False):
        from utils import ipython_shell
        ipython_shell.embedd(locals(), globals())

    def takeScreenshot(self):
        view = self._tab_manager.activeWindow()
        ts = datetime.datetime.now().strftime("%Y%m%d%H%M%s")
        pixmap = qt.QPixmap.grabWidget(view)
        pixmap.save(os.path.join(CONF.getDefaultTempPath(), "shell_capture_%s.png" % ts), "PNG")
        pixmap = qt.QPixmap.grabWidget(self)
        pixmap.save(os.path.join(CONF.getDefaultTempPath(), "fullscreen_capture_%s.png" % ts), "PNG")
        model.api.log("Screenshots taken")

    def syncWorkspaces(self):
                                                                   
                                             
                                                                                
                  
        self._model_controller.syncActiveWorkspace()

    def saveWorkspaces(self):
        """
        Saves workspaces and it is done syncronically so GUI won't respond
        until it finishes saving everything
        """
                                                   
        model.api.log("Saving workspaces...")
        self._main_app.saveWorkspaces()
        model.api.log("Workspaces saved!")
        
    def createWorkspace(self):
                                                                           
        wdialog = WorkspaceCreationDialog(self, callback=self._main_app.createWorkspace)
        wdialog.exec_loop()
        
        
    def openWorkspace(self):
                                                                         
                                           
        name = "Untitled"
        self._main_app.openWorkspace(name)


    def reconnect(self):
        wm = self._main_app.getWorkspaceManager()
        wm.reconnect() 
        
    """
    #XXX: test ALT+r on console to delete line
    def test2(self):
        for env in self._main_app._shell_envs.itervalues():
            env.session.em.sendString("\033r")
    """

########NEW FILE########
__FILENAME__ = modelobjectitems
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import os
import qt
import model.api as api
from edition import HostEditor, ServiceEditor, InterfaceEditor, GenericEditor, NoteEditor

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

class ModelObjectListViewItem(qt.QListViewItem):
    """Item for displaying in the HostsBrowser."""
              

    def __init__(self, qtparent,  name = "", model_object=None):
        qt.QListViewItem.__init__(self, qtparent)
                                   
        self.setRenameEnabled(0, False)
        self.index = 0
        self.object = model_object
        self.name = name if name else model_object.getName()
        self._childs = {}
        self.setDragEnabled(False)
        self.setDropEnabled(False)
        self._setIcon()
        self._populateChildItems()
        self._checkVulns()
        self.editor = GenericEditor(None)

    def getChilds(self):
        return self._childs

    def getChild(self, key):
        return self._childs[key]

    def addChild(self, key, val):
        self._childs[key] = val

    def addHost(self, host):
        self.addChild(host.getID(), HostListViewItem(self, host.getName(), host))

    def addInterface(self, interface):
        self.addChild(interface.getID(), InterfaceListViewItem(self, interface.getName(), interface))

    def addInterfaces(self):
        for interface in self.object.getAllInterfaces():
            self.addInterface(interface)

    def addApplication(self, application):
        self.addChild(application.getID(), ApplicationListViewItem(self, application.getName(), application))

    def addApplications(self):
        for application in self.object.getAllApplications():
            self.addApplication(application)

    def addService(self, service):
        self.addChild(service.getID(), ServiceListViewItem(self, service.getName(), service))

    def addServices(self):
        for service in self.object.getAllServices():
            self.addService(service)

    def addNote(self, note):
        self.addChild(note.getID(), NoteListViewItem(self, note.name, note))

    def addNotes(self):
        for note in self.object.getNotes():
            self.addNote(note)

    def addVuln(self, vuln):
        if vuln.class_signature == "VulnerabilityWeb":
            self.addChild(vuln.getID(), VulnWebListViewItem(self, vuln.name, vuln))
        else:
            self.addChild(vuln.getID(), VulnListViewItem(self, vuln.name, vuln))

    def addVulns(self):
        for vuln in self.object.getVulns():
            self.addVuln(vuln)

    def addCred(self, cred):
        self.addChild(cred.getID(), CredListViewItem(self, cred.name, cred))

    def addCreds(self):
        for cred in self.object.getCreds():
            self.addCred(cred)

    def clear(self):
        i = self.firstChild()
        items_to_remove = []
        while i is not None:
            items_to_remove.append(i)
            i = i.nextSibling()
        for i in items_to_remove:
            item = i
            i.clear()
            del i
            try:
                self.takeItem(item)
            except:
                pass
        self._childs.clear()

    def getContextMenu(self):
        pass

    def _setIcon(self):
                                                                            
                                 
                                                                
        owned = self.object.isOwned() if self.object is not None else False
        icon_name = "Tree%sOwned-20.png" % self.type if owned else "Tree%s-20.png" % self.type
        
                                      
        if self.type == "Service" and not owned:
            if self.object.getStatus() !="open":
                icon_name = "TreeOff%s-20.png" % self.type
        
        
        icon_path = os.path.join(CONF.getIconsPath(), icon_name)
        
        pm = qt.QPixmap(icon_path)
        self.setPixmap(0, pm)
        
    def _checkVulns(self):
        """
        Verifies if the item has vulnerabilities
        and shows it different with details
        """
        if self.object is not None:
            madd=[]
            vulns = self.object.getVulns()
            if vulns:
                madd.append("v:"+str(len(vulns)))
            notes = self.object.getNotes()
            if notes:
                madd.append("n:"+str(len(notes)))
            creds = self.object.getCreds()
            if creds:
                madd.append("c:"+str(len(creds)))
            if madd:
                newname=""
                if self.type == "Service":
                    newname = "(%s/%s) %s [%s]"  % (", ".join(["%s" % p for p in self.object.getPorts()]),
                                         self.object.getProtocol(), self.object.name, ",".join(madd))
                else:
                    newname = "%s [%s]" % (self.object.name, ",".join(madd))
                self.name = newname
                
    
    
    def _populateChildItems(self):
        """
        this creates new children items if needed
        to populate the tree
        depending on the item type this can create different items
        """
        pass

                                                            
                                                                 
                                                              
    def dragEntered(self):
        pass

    def dragLeft(self):
        pass

    def dropped(self, e):
                               
        pass

    def setText(self, col, text):
        """Update name of widget if rename is called."""
                               
        if col == 0:
            self.name = text

        qt.QListViewItem.setText(self, col, text)

    def rename(self):
        """Rename the listviewitem."""
        self.startRename(0)

                                                            
               
    def compare(self, i, col, ascending):
        """
        #Always sort according to the index value.

        a = [-1, 1][ascending]

        if self.index < i.index:
            return -1*a
        elif self.index > i.index:
            return 1*a
        else:
            return 0
        """
        a = [-1, 1][ascending]
                            
        if self.name < i.name:
            return -1*a
        elif self.name > i.name:
            return 1*a
        else:
            return 0

    def text(self, column):
        """Get the text in a particular column."""
        if column == 0:
            return self.name
        return ''
    
    def getModelObject(self):
        return self.object

    def setModelObject(self, model_object):
        self.object = model_object

                                         
                                                                        
                        

    def getEditor(self):
        return self.editor

                                                                                
class RootListViewItem(ModelObjectListViewItem):
    type = "Root"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)

class WorkspaceListViewItem(ModelObjectListViewItem):
    type = "Workspace"
    def __init__(self, qtparent, model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, model_object.name, model_object)
        self.nconflicts = 0
        self.setOpen(True)

    def _checkVulns(self):
        pass

    def _setIcon(self):
        
        if self.object.__class__.__name__ == "WorkspaceOnCouch":
            icon_name = "TreeRoot-20.png"
        else:
            icon_name = "TreeOffRoot-20.png"
        icon_path = os.path.join(CONF.getIconsPath(), icon_name)
        pm = qt.QPixmap(icon_path)
        self.setPixmap(0, pm)

    def updateName(self, nconflicts):
        self.nconflicts += nconflicts
        if self.nconflicts:
            self.name = "%s (%s)" % (self.getModelObject().name, self.nconflicts)
        else:
            self.name = "%s" % (self.getModelObject().name)

                                                                                
class CategoryListViewItem(ModelObjectListViewItem):
    type = "Category"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
        self.setDropEnabled(True)                                     

    def selectByWord(self, word):
        for host_item in self.getChilds().values():
            if host_item.text(0).encode('utf8').strip() == word.strip():
                self.setSelected(True)
                break

                                                                                
class HostListViewItem(ModelObjectListViewItem):
    type = "Host"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
                                                     
                                                    
        self.setDragEnabled(True)
        self.editor = HostEditor(self.object)

    def _populateChildItems(self):
                                                                              
                                                                                  
        
                                                                                          
                                                    
                                     
                                                               
        self.addInterfaces()
                           

                                                
                         
                                                              
    
    def _clearHost(self):
        self.clear()
                                               
                                             
                               
                              
                          

    def _clearServicesFromApplications(self):
        for item in self._childs:
            if item.name == "Applications":
                for app in item._childs:
                    app.clearServices()
    
    def _addServicesToApplications(self):
        for item in self._childs:
            if item.name == "Applications":
                for app in item._childs:
                    app._populateChildItems()
    
    def _clearServicesFromInterfaces(self):
        for item in self._childs:
            if item.name == "Interfaces":
                for interface in item._childs:
                    interface.clearServices()
    
    def _addServicesToInterfaces(self):
        for item in self._childs:
            if item.name == "Interfaces":
                for interface in item._childs:
                    interface._populateChildItems()
    
    def _setIcon(self):
        owned = self.object.isOwned() if self.object is not None else False
        if owned:
            icon_name = "User%sOwned.png" % self.type
        else:
            _oper = self.object.getOS()
            if "LINUX" in _oper.upper():
                icon_name = "tux.png"    
            elif "WINDOWS" in _oper.upper():
                icon_name = "windows.png"    
            elif "APPLE" in _oper.upper():
                icon_name = "Apple.png"
            elif "MAC" in _oper.upper():
                icon_name = "Apple.png"
            elif "CISCO" in _oper.upper():
                icon_name = "Cisco.png"
            elif "IOS" in _oper.upper():
                icon_name = "Cisco.png"                
            elif "LINKSYS" in _oper.upper():
                icon_name = "Router.png"
            elif "ROUTER" in _oper.upper():
                icon_name = "Router.png"
            else:
                icon_name = "Tree%s-20.png" % self.type
            
            
        icon_path = os.path.join(CONF.getIconsPath(), icon_name)
        pm = qt.QPixmap(icon_path)
        self.setPixmap(0, pm)


                                                                                
class InterfaceListViewItem(ModelObjectListViewItem):
    type = "Interface"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
        self.editor = InterfaceEditor(self.object)

    def _populateChildItems(self):
                                                 
        self.addServices()
    
    def clearServices(self):
        for s in self._childs:
            self.takeItem(s)
                  
        self._childs = []
        
                                                                                
class ApplicationListViewItem(ModelObjectListViewItem):
    type = "Application"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)

    def _populateChildItems(self):
                                                   
        self.addServices()
    
    def clearServices(self):
        for s in self._childs:
            self.takeItem(s)
                  
        self._childs = []

                                                                                
class ServiceListViewItem(ModelObjectListViewItem):
    type = "Service"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
        self.name = "(%s/%s) %s"  % (", ".join(["%s" % p for p in self.object.getPorts()]),
                                     self.object.getProtocol(), self.object.name )
        self.editor = ServiceEditor(self.object)
        self._checkVulns()

                                                                                

class NoteRootItem(RootListViewItem):
    type = "NoteRoot"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
        self.name = self.object.name
        self.setOpen(True)

    def _setIcon(self):
        pass

class NoteListViewItem(ModelObjectListViewItem):
    type = "Note"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)

    def _populateChildItems(self):
        self.addNotes()
    
    def clearNotes(self):
        for s in self._childs:
            self.takeItem(s)
                  
        self._childs = []

class VulnRootItem(RootListViewItem):
    type = "VulnRoot"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
        self.name = self.object.name
        self.setOpen(True)

    def _setIcon(self):
        pass

class VulnListViewItem(ModelObjectListViewItem):
    type = "Vuln"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)

    def _populateChildItems(self):
        self.addVulns()
    
    def clearVulns(self):
        for s in self._childs:
            self.takeItem(s)
                  
        self._childs = []

class VulnWebListViewItem(VulnListViewItem):
    type = "VulnWeb"
    def __init__(self, qtparent, name = "", model_object=None):
        VulnListViewItem.__init__(self, qtparent, name, model_object)

class CredRootItem(RootListViewItem):
    type = "CredRoot"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
        self.name = self.object.name
        self.setOpen(True)

    def _setIcon(self):
        pass

class CredListViewItem(ModelObjectListViewItem):
    type = "Cred"
    def __init__(self, qtparent, name = "", model_object=None):
        ModelObjectListViewItem.__init__(self, qtparent, name, model_object)
        self.name = "%s: %s" % (model_object.username, model_object.password)

    def _populateChildItems(self):
        self.addCreds()
    
    def clearVulns(self):
        for s in self._childs:
            self.takeItem(s)
                  
        self._childs = []


########NEW FILE########
__FILENAME__ = perspective
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import qt
from gui.qt3.toolbars import PerspectiveToolbar
import model.api

class PerspectiveManager(qt.QVBox):

    def __init__(self, parent, main_app):
        qt.QVBox.__init__(self, parent)
        self.setName("PerspectiveManager")
        self.setSpacing(5)
        self.setFrameStyle(qt.QFrame.PopupPanel | qt.QFrame.Plain)
        self._main_app = main_app
        self._active_perspective = None
        self._default = ""
        self._registered = {}
        self._toolbar = PerspectiveToolbar(self, "perspective_toolbar")
        self.setStretchFactor(self._toolbar, 0)
        self._stack_panel = qt.QWidgetStack(self)
        self._stack_panel.setFrameStyle(qt.QFrame.PopupPanel | qt.QFrame.Plain)
        self.setStretchFactor(self._stack_panel, 10)

    def _isValid(self, p):
                                                                     
        return p.parent() == self

    def registerPerspective(self, p, default=False):
        if self._isValid(p):
            self._stack_panel.addWidget(p)                            
            if p.name() not in self._registered:
                self._registered[p.name()] = p
                                                                       
                p.setSizePolicy(qt.QSizePolicy(qt.QSizePolicy.Expanding, qt.QSizePolicy.Expanding))
                self._toolbar.addPerspective(p.name())
                if default:
                    self._default = p.name()
                    self.setActivePerspective(p.name())

    def getActivePerspective(self):
        return self._active_perspective

    def setActivePerspective(self, name):
        if isinstance(name, int):                                              
            name = self._toolbar.getSelectedValue()

        model.api.devlog("setActivePerspective called - name = " + name)
                                               

        if name in self._registered:
            self._active_perspective = self._registered[name]
            if name == "Workspaces":
                self._active_perspective.loadAllWorkspaces()
            self._stack_panel.raiseWidget(self._active_perspective)

    def showDefaultPerspective(self):
        self.setActivePerspective(self._default)

    def getToolbar(self):
        return self._toolbar

    def sizeHint(self):
        return qt.QSize(70, 0)
        
    def getMainApp(self):
        return self._main_app

########NEW FILE########
__FILENAME__ = widget
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
""" Provide the Widget class.

Visible screen contents

   This class is responsible to map the `image' of a terminal emulation to the
   display. All the dependency of the emulation to a specific GUI or toolkit is
   localized here. Further, this widget has no knowledge about being part of an
   emulation, it simply work within the terminal emulation framework by exposing
   size and key events and by being ordered to show a new image.

   - The internal image has the size of the widget (evtl. rounded up)
   - The external image used in setImage can have any size.
   - (internally) the external image is simply copied to the internal
     when a setImage happens. During a resizeEvent no painting is done
     a paintEvent is expected to follow anyway.

FIXME:
   - 'image' may also be used uninitialized (it isn't in fact) in resizeEvent
   - 'font_a' not used in mouse events

TODO
   - evtl. be sensitive to `paletteChange' while using default colors.
   - set different 'rounding' styles? I.e. have a mode to show clipped chars?

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Benjamin Longuet
@author: Frederic Mantegazza
@author: Cyrille Boullier
@author: Sylvain Thenault
@copyright: 2003, 2005-2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CeCILL
"""

__revision__ = '$Id: widget.py,v 1.40 2006-02-15 10:24:01 alf Exp $'
#-------------------------------------------------------------------------------
import qt
import model.api as api
from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()
from shell.core import signalable
from shell.core.ca import DCA, RE_CURSOR, RE_BLINK, RE_UNDERLINE, \
                          TABLE_COLORS, DEFAULT_BACK_COLOR, ColorEntry

from model.common import TreeWordsTries
# FIXME: the rim should normally be 1, 0 only when running in full screen mode.
rimX = 0 # left/right rim width
rimY = 0 # top/bottom rim high

# width of the scrollbar
SCRWIDTH = 16

SCRNONE = 0
SCRLEFT = 1
SCRRIGHT = 2

# scroll increment used when dragging selection at top/bottom of window.
Y_MOUSE_SCROLL = 1

BELLNONE = 0
BELLSYSTEM = 1
BELLVISUAL = 2

#extern unsigned short vt100_graphics[32]

# Dnd
diNone = 0
diPending = 1
diDragging = 2


class dragInfo:
    """uninstantiable class used to handle drag and drop status"""
    state = None
    start = None
    dragObject = None

# Colors ######################################################################

#FIXME: the default color table is in session.C now.
#       We need a way to get rid of this one, here.
BASE_COLOR_TABLE = [
    # The following are almost IBM standard color codes, with some slight
    # gamma correction for the dim colors to compensate for bright X screens.
    # It contains the 8 ansiterm/xterm colors in 2 intensities.
    # Fixme: could add faint colors here, also.
    # normal
    ColorEntry(qt.QColor(0x00,0x00,0x00), 0, 0 ), ColorEntry( qt.QColor(0xB2,0xB2,0xB2), 1, 0 ), # Dfore, Dback
    ColorEntry(qt.QColor(0x00,0x00,0x00), 0, 0 ), ColorEntry( qt.QColor(0xB2,0x18,0x18), 0, 0 ), # Black, Red
    ColorEntry(qt.QColor(0x18,0xB2,0x18), 0, 0 ), ColorEntry( qt.QColor(0xB2,0x68,0x18), 0, 0 ), # Green, Yellow
    ColorEntry(qt.QColor(0x18,0x18,0xB2), 0, 0 ), ColorEntry( qt.QColor(0xB2,0x18,0xB2), 0, 0 ), # Blue,  Magenta
    ColorEntry(qt.QColor(0x18,0xB2,0xB2), 0, 0 ), ColorEntry( qt.QColor(0xB2,0xB2,0xB2), 0, 0 ), # Cyan,  White
    # intensiv
    ColorEntry(qt.QColor(0x00,0x00,0x00), 0, 1 ), ColorEntry( qt.QColor(0xFF,0xFF,0xFF), 1, 0 ),
    ColorEntry(qt.QColor(0x68,0x68,0x68), 0, 0 ), ColorEntry( qt.QColor(0xFF,0x54,0x54), 0, 0 ),
    ColorEntry(qt.QColor(0x54,0xFF,0x54), 0, 0 ), ColorEntry( qt.QColor(0xFF,0xFF,0x54), 0, 0 ),
    ColorEntry(qt.QColor(0x54,0x54,0xFF), 0, 0 ), ColorEntry( qt.QColor(0xFF,0x54,0xFF), 0, 0 ),
    ColorEntry(qt.QColor(0x54,0xFF,0xFF), 0, 0 ), ColorEntry( qt.QColor(0xFF,0xFF,0xFF), 0, 0 )
]

# Note that we use ANSI color order (bgr), while IBMPC color order is (rgb)
#
#   Code        0       1       2       3       4       5       6       7
#   ----------- ------- ------- ------- ------- ------- ------- ------- -------
#   ANSI  (bgr) Black   Red     Green   Yellow  Blue    Magenta Cyan    White
#   IBMPC (rgb) Black   Blue    Green   Cyan    Red     Magenta Yellow  White


# Font ########################################################################

#   The VT100 has 32 special graphical characters. The usual vt100 extended
#   xterm fonts have these at 0x00..0x1f.
#
#   QT's iso mapping leaves 0x00..0x7f without any changes. But the graphicals
#   come in here as proper unicode characters.
#
#   We treat non-iso10646 fonts as VT100 extended and do the requiered mapping
#   from unicode to 0x00..0x1f. The remaining translation is then left to the
#   QCodec.

# assert for i in [0..31] : vt100extended(vt100_graphics[i]) == i.

VT100_GRAPHICS = [
    # 0/8     1/9    2/10    3/11    4/12    5/13    6/14    7/15
    0x0020, 0x25C6, 0x2592, 0x2409, 0x240c, 0x240d, 0x240a, 0x00b0,
    0x00b1, 0x2424, 0x240b, 0x2518, 0x2510, 0x250c, 0x2514, 0x253c,
    0xF800, 0xF801, 0x2500, 0xF803, 0xF804, 0x251c, 0x2524, 0x2534,
    0x252c, 0x2502, 0x2264, 0x2265, 0x03C0, 0x2260, 0x00A3, 0x00b7,
]


FONTS = [
    "13",
    "7",   # tiny font, never used
    "10",  # small font
    "13",  # medium
    "15",  # large
    "20",  # huge
    "-misc-console-medium-r-normal--16-160-72-72-c-160-iso10646-1", # "Linux"
    "-misc-fixed-medium-r-normal--15-140-75-75-c-90-iso10646-1",    # "Unicode"
    ]

TOPFONT = 0

def shellSetFontAux(te, fontno):
    f = qt.QFont()
    if FONTS[fontno][0] == '-':
        f.setRawName(FONTS[fontno])
        if not f.exactMatch():
            return
    else:
        f.setFamily("fixed")
        f.setFixedPitch(True)
        f.setPixelSize(int(FONTS[fontno]))
    te.setVTFont(f)


class ShellWidget(signalable.Signalable, qt.QFrame):
    """a widget representing attributed text"""

    def __init__(self, qapp, parent=None, name=''):
        super(ShellWidget, self).__init__(parent, name)
        # application object
        self._qapp = qapp
        # current session in this widget
        self.current_session = None
        # has blinking cursor enabled
        self.has_blinking_cursor = False
        # hide text in paintEvent
        self.blinking = False
        # has characters to blink
        self.has_blinker = False
        # hide cursor in paintEvent
        self.cursor_blinking = False
        # active when self.has_blinker
        self.blink_t = qt.QTimer(self)
        # active when self.has_blinking_cursor
        self.blink_cursor_t = qt.QTimer(self)
        # require Ctrl key for drag
        self.ctrldrag = False
        # do we antialias or not
        self.antialias = False
        #self.fixed_font # has fixed pitch
        # height, width, ascend
        self.font_h = self.font_w = self.font_a = 1
        # The offsets are not yet calculated.
        # Do not calculate these too often to be more smoothly when resizing
        # pyqonsole in opaque mode.
        self.bX = self.bY = 0
        # widget size
        self.lines = 1
        self.columns = 1
        self._image = None  # [lines][columns]
        self._line_wrapped = [] # QBitArray

        self.color_table = [None] * TABLE_COLORS
        self.currentWord = ""
        self.resizing = False
        self.terminal_size_hint = False
        self.terminal_size_startup = True
        self.mouse_marks = False

        self.i_pnt_sel = None # initial selection point
        self.pnt_sel = None   # current selection point
        self._act_sel = 0      # selection state
        self._word_selection_mode = False
        self._line_selection_mode = False
        self.preserve_line_breaks = True
        self.scroll_loc = SCRNONE
        self.bell_mode = BELLSYSTEM
        # is set in mouseDoubleClickEvent and deleted
        # after QApplication::doubleClickInterval() delay
        self._possible_triple_click = False
        self._ctrl_pressed = self._shift_pressed = False

        self.m_resize_widget = None # QFrame
        self.m_resize_label = None # QLabel
        self.m_resize_timer = None # QTimer
        self.line_spacing = 0

        self.scrollbar = qt.QScrollBar(self)
        self.scrollbar.setCursor(self.arrowCursor)

        self.drop_text = ''
        self._cursor_rect = None #for quick changing of cursor

        cb = qt.QApplication.clipboard()
        self.connect(cb, qt.SIGNAL('selectionChanged()'), self.onClearSelection)
        self.connect(self.scrollbar, qt.SIGNAL('valueChanged(int)'),
                     self.scrollChanged)
        self.connect(self.blink_t, qt.SIGNAL('timeout()'), self.blinkEvent)
        self.connect(self.blink_cursor_t, qt.SIGNAL('timeout()'),
                     self.blinkCursorEvent)

        self.setMouseMarks(True)

        #self.setVTFont(qt.QFont("monaco"))
        self.setColorTable(BASE_COLOR_TABLE) # init color table
        #TODO: check if installing this event filter doesn't conflict other widgets
        self._qapp.installEventFilter(self) #FIXME: see below

        self._compose_length = 0
        # Init DnD ################################
        self.setAcceptDrops(True) # attempt
        dragInfo.state = diNone

        self.setFocusPolicy(self.WheelFocus)

        # We're just a big pixmap, no need to have a background
        # Speeds up redraws
        self.setBackgroundMode(self.NoBackground)


##     def __del__(self):
##         # FIXME: make proper destructor
##         self._qapp.removeEventFilter( self )

    def select_on_tree( self, word ):
        mw = self._qapp.mainWidget()
        host_tree_view = mw.getHostTreeView()
        host_tree_view.selectWord(word)
        
    def getDefaultBackColor(self):
        return self.color_table[DEFAULT_BACK_COLOR].color

    def getColorTable(self):
        return self.color_table
    def setColorTable(self, table):
        for i in xrange(TABLE_COLORS):
            self.color_table[i] = table[i]
        pm = self.paletteBackgroundPixmap()
        if not pm:
            self.setPaletteBackgroundColor(self.color_table[DEFAULT_BACK_COLOR].color)
        self.update()

    # FIXME: add backgroundPixmapChanged.

    def setScrollbarLocation(self, loc):
        if self.scroll_loc == loc:
            return # quickly
        self.bY = self.bX = 1
        self.scroll_loc = loc
        self.propagateSize()
        self.update()

    def setScroll(self, cursor, lines):
        self.disconnect(self.scrollbar, qt.SIGNAL('valueChanged(int)'),
                        self.scrollChanged)
        self.scrollbar.setRange(0, lines)
        self.scrollbar.setSteps(1, self.lines)
        self.scrollbar.setValue(cursor)
        self.connect(self.scrollbar, qt.SIGNAL('valueChanged(int)'),
                     self.scrollChanged)

    def doScroll(self, lines):
        self.scrollbar.setValue(self.scrollbar.value()+lines)

    def blinkingCursor(self):
        return self.has_blinking_cursor

    def setBlinkingCursor(self, blink):
        """Display operation"""
        self.has_blinking_cursor = blink
        if blink and not self.blink_cursor_t.isActive():
            self.blink_cursor_t.start(1000)
        if not blink and self.blink_cursor_t.isActive():
            self.blink_cursor_t.stop()
            if self.cursor_blinking:
                self.blinkCursorEvent()
            else:
                self.cursor_blinking = False

    def setLineSpacing(self, i):
        self.line_spacing = i
        self.setVTFont(self.font()) # Trigger an update.
   

    def emitSelection(self, useXselection, appendReturn):
        """Paste Clipboard by simulating keypress events"""
        qt.QApplication.clipboard().setSelectionMode(useXselection)
        text = qt.QApplication.clipboard().text()
        if appendReturn:
            text.append("\r")
        if not text.isEmpty():
            text.replace(qt.QRegExp("\n"), "\r")
        ev = qt.QKeyEvent(qt.QEvent.KeyPress, 0, -1, 0, text)
        self.myemit('keyPressedSignal', (ev,)) # expose as a big fat keypress event
        self.myemit('clearSelectionSignal')
        qt.QApplication.clipboard().setSelectionMode(False)

    def setImage(self, newimg, lines, columns):
        """Display Operation - The image can only be set completely.

        The size of the new image may or may not match the size of the widget.
        """
        pm = self.paletteBackgroundPixmap()
        self.setUpdatesEnabled(False)
        paint = qt.QPainter()
        paint.begin(self)
        tL  = self.contentsRect().topLeft()
        tLx = tL.x()
        tLy = tL.y()
        self.has_blinker = False
        cf = cb = cr  = -1 # undefined
        cols = min(self.columns, max(0, columns))
        oldimg = self._image
        #print 'setimage', lins, cols, self.lines, self.columns, len(oldimg), len(newimg)
        for y in xrange(min(self.lines,  max(0, lines))):
            if self.resizing: # while resizing, we're expecting a paintEvent
                break
            x = 0
            while x < cols:
                ca = newimg[y][x]
                self.has_blinker |= ca.r & RE_BLINK
                # "is" to be more effective than "==" when possible
                if ca is oldimg[y][x] or ca == oldimg[y][x]:
                    if ca.c != '' and ca.c != ' ':
                        pass

                    x += 1
                    continue
                else:
                    pass

                c = ca.c
                if not c:
                    x += 1
                    continue
                disstrU = [c]
                cr = ca.r
                cb = ca.b
                if ca.f != cf:
                    cf = ca.f
                lln = cols - x
                xlen = 1
                for xlen in xrange(1, lln):
                    cal = newimg[y][x + xlen]
                    c = cal.c
                    if not c:
                        continue # Skip trailing part of multi-col chars.
                    ocal = oldimg[y][x + xlen]
                    if (cal.f != cf or cal.b != cb or cal.r != cr or
                        (cal is ocal or cal == ocal)):
                        break
                    disstrU.append(c)

                unistr = qt.QString(u''.join(disstrU))
                self.drawAttrStr(paint,
                                 qt.QRect(self.bX+tLx+self.font_w*x,
                                          self.bY+tLy+self.font_h*y,
                                          self.font_w*xlen,
                                          self.font_h),
                                 unistr, ca, pm != None, True)
                x += xlen
        self._image = newimg
        self.drawFrame(paint)
        paint.end()
        self.setUpdatesEnabled(True)
        if self.has_blinker and not self.blink_t.isActive():
            self.blink_t.start(1000) # 1000 ms
        elif not self.has_blinker and self.blink_t.isActive():
            self.blink_t.stop()
            self.blinking = False

        if self.resizing and self.terminal_size_hint:
            if self.terminal_size_startup:
                self.terminal_size_startup = False
                return
            widget = self.m_resize_widget
            if not self.m_resize_widget:
                self.m_resize_widget = qt.QFrame(self)
                f = self.m_resize_widget.font()
                f.setPointSize(f.pointSize()*2)
                f.setBold(True)
                widget.setFont(f)
                widget.setFrameShape(self.Raised)
                widget.setMidLineWidth(4)
                l = qt.QVBoxLayout( widget, 10)
                self.m_resize_label = qt.QLabel("Size: XXX x XXX", widget)
                l.addWidget(self.m_resize_label, 1, self.AlignCenter)
                widget.setMinimumWidth(self.m_resize_label.fontMetrics().width("Size: XXX x XXX")+20)
                widget.setMinimumHeight(self.m_resize_label.sizeHint().height()+20)
                self.m_resize_timer = qt.QTimer(self)
                self.connect(self.m_resize_timer, qt.SIGNAL('timeout()'), widget.hide)
            sizeStr = qt.QString("Size: %1 x %2").arg(columns).arg(lines)
            self.m_resize_label.setText(sizeStr)
            widget.move((self.width()-widget.width())/2,
                                      (self.height()-widget.height())/2)
            widget.show()
            self.m_resize_timer.start(1000, True)

    def setLineWrapped(self, _line_wrapped):
        self._line_wrapped = _line_wrapped

    def setCursorPos(self, curx, cury):
        """Display Operation - Set XIM Position"""
        tL  = self.contentsRect().topLeft()
        tLx = tL.x()
        tLy = tL.y()
        ypos = self.bY + tLy + self.font_h*(cury-1) + self.font_a
        xpos = self.bX + tLx + self.font_w*curx
        self.setMicroFocusHint(xpos, ypos, 0, self.font_h)

    def propagateSize(self):
        oldimg = self._image
        oldlin = self.lines
        oldcol = self.columns
        self._makeImage()
        # we copy the old image to reduce flicker
        if oldimg:
            for y in xrange(min(oldlin, self.lines)):
                for x in xrange(min(oldcol, self.columns)):
                    self._image[y][x] = oldimg[y][x]
        else:
            self._clearImage()
        # NOTE: control flows from the back through the chest right into the eye.
        #      `emu' will call back via `setImage'.
        # expose resizeEvent
        self.resizing = True
        self.myemit('changedImageSizeSignal', (self.lines, self.columns))
        self.resizing = False

    def calcSize(self, cols, lins):
        """calculate the needed size for the widget to get a cols*lins
        characters terminal
        """
        frw = self.width() - self.contentsRect().width()
        frh = self.height() - self.contentsRect().height()
        if self.scroll_loc == SCRNONE:
            scw = 0
        else:
            scw = self.scrollbar.width()
        return qt.QSize(self.font_w*cols + 2*rimX + frw + scw + 2, self.font_h*lins + 2*rimY + frh + 2)


    def sizeHint(self):
        return self.size()

    def bell(self):
        if self.bell_mode == BELLSYSTEM:
            qt.QApplication.beep()
        if self.bell_mode == BELLVISUAL:
            self._swapColorTable()
            qt.QTimer.singleShot(200, self._swapColorTable)


    def setSelection(self, t):
        # Disconnect signal while WE set the clipboard
        cb = qt.QApplication.clipboard()
        self.disconnect(cb, qt.SIGNAL('selectionChanged()'), self.onClearSelection)
        cb.setSelectionMode(True)
        cb.setText(t)
        cb.setSelectionMode(False)
        cb.setText(t)
        self.connect(cb, qt.SIGNAL('selectionChanged()'), self.onClearSelection)


    def setFont(self, font):
        # ignore font change request if not coming from konsole itself
        pass

    def setVTFont(self, font):
        if not self.antialias:
            font.setStyleStrategy(qt.QFont.NoAntialias)
        qt.QFrame.setFont(self, font)
        self.fontChange(font)

    def setMouseMarks(self, on):
        self.mouse_marks = on
        self.setCursor(on and self.ibeamCursor or self.arrowCursor)

    def setTerminalSizeHint(self, on):
        self.terminal_size_hint = on

    def pasteClipboard(self):
        self.emitSelection(False, False)

    def onClearSelection(self):
        self.myemit('clearSelectionSignal')

    def setupLayout(self):
        self.setScrollbarLocation(2)
        #self.setMinimumSize(150, 70)
        self.setMinimumSize(200, 100)
        self.setBackgroundMode(qt.Qt.PaletteBackground)
        f=qt.QFont()
        f.setRawName(CONF.getFont())
        #f.setFixedPitch(True)
        #f.setPixelSize(13)

        self.shellSetFont(f)
        self.resize(self.calcSize(80, 25))

    # protected ###############################################################

    def styleChange(self, style):
        """overridden from QWidget"""
        self.propagateSize()

    def eventFilter(self, obj, e):
        """Keyboard

        FIXME: an `eventFilter' has been installed instead of a `keyPressEvent'
               due to a bug in `QT' or the ignorance of the author to prevent
               repaint events being self.emitted to the screen whenever one leaves
               or reenters the screen to/from another application.

         Troll says one needs to change focusInEvent() and focusOutEvent(),
         which would also let you have an in-focus cursor and an out-focus
         cursor like xterm does.

        for the auto-hide cursor feature, I added empty focusInEvent() and
        focusOutEvent() so that update() isn't called.
        For auto-hide, we need to get keypress-events, but we only get them when
        we have focus.
        """
        if (e.type() == qt.QEvent.Accel or
            e.type() == qt.QEvent.AccelAvailable) and self._qapp.focusWidget() == self:
            e.ignore()
            return True
        if obj != self and obj != self.parent(): # when embedded / when standalone
            return False # not us
        if e.type() == qt.QEvent.Wheel:
            qt.QApplication.sendEvent(self.scrollbar, e)

        if e.type() == qt.QEvent.KeyPress:
            if e.key() == qt.Qt.Key_Control:
                self._ctrl_pressed = True
            elif e.key() == qt.Qt.Key_Shift:
                self._shift_pressed = True
            elif (self._shift_pressed and self._ctrl_pressed):
                mw = self._qapp.mainWidget()
                if e.key() == qt.Qt.Key_T:
                    mw.createShellTab()
                    return True
                elif e.key() == qt.Qt.Key_W:
                    mw.destroyShellTab()
                    return True
                elif e.key() == qt.Qt.Key_C:
                    return True
                elif e.key() == qt.Qt.Key_V:
                    text = qt.QApplication.clipboard().text()
                    if not text.isEmpty():
                        text.replace(qt.QRegExp("\n"), "\r")
                    ev = qt.QKeyEvent(qt.QEvent.KeyPress, 0, -1, 0, text)
                    self.myemit('keyPressedSignal', (ev,)) # expose as a big fat keypress event
                    self.myemit('clearSelectionSignal')
                    qt.QApplication.clipboard().setSelectionMode(False)
                    return True
        elif e.type() == qt.QEvent.KeyRelease:
            if e.key() == qt.Qt.Key_Control:
                self._ctrl_pressed = False
            elif e.key() == qt.Qt.Key_Shift:
                self._shift_pressed = False

        if e.type() == qt.QEvent.KeyPress and not (self._ctrl_pressed and self._shift_pressed):
            self._act_sel = 0 # Key stroke implies a screen update, so TEWidget won't
                             # know where the current selection is.
            if self.has_blinking_cursor:
                self.blink_cursor_t.start(1000)
            if self.cursor_blinking:
                self.blinkCursorEvent()
            else:
                self.cursor_blinking = False
            self.myemit('keyPressedSignal', (e,)) # expose
            # in Qt2 when key events were propagated up the tree
            # (unhandled? . parent widget) they passed the event filter only once at
            # the beginning. in qt3 self has changed, that is, the event filter is
            # called each time the event is sent (see loop in qt.QApplication.notify,
            # when internalNotify() is called for KeyPress, whereas internalNotify
            # activates also the global event filter) . That's why we stop propagation
            # here.
            return True
        if e.type() == qt.QEvent.IMStart:
            self._compose_length = 0
            e.accept()
            return False
        if e.type() == qt.QEvent.IMCompose:
            text = qt.QString()
            if self._compose_length:
                text.setLength(self._compose_length)
                for i in xrange(self._compose_length):
                    text[i] = '\010'
            self._compose_length = e.text().length()
            text += e.text()
            if not text.isEmpty():
                ke = qt.QKeyEvent(qt.QEvent.KeyPress, 0,-1, 0, text)
                self.myemit('keyPressedSignal', (ke,))
            e.accept()
            return False
        if e.type() == qt.QEvent.IMEnd:
            text = qt.QString()
            if self._compose_length:
                text.setLength(self._compose_length)
                for i in xrange(self._compose_length):
                    text[i] = '\010'
            text += e.text()
            if not text.isEmpty():
                ke = qt.QKeyEvent(qt.QEvent.KeyPress, 0,-1, 0, text)
                self.myemit('keyPressedSignal', (ke,))
            e.accept()
            return False
        if e.type() == qt.QEvent.Enter:
            cb = qt.QApplication.clipboard()
            try:
                self.disconnect(cb, qt.SIGNAL('dataChanged()'), self.onClearSelection)
            except RuntimeError:
                # slot isn't connected
                pass
        elif e.type() == qt.QEvent.Leave:
            cb = qt.QApplication.clipboard()
            self.connect(cb, qt.SIGNAL('dataChanged()'), self.onClearSelection)
        return qt.QFrame.eventFilter(self, obj, e)

    def splitQstring(self, aQstr):

        list_qstr = []
        current_len = aQstr.length()

        i = -1

        state = 0
        c = 0
        while i<=current_len:
            i += 1
            current_char = aQstr.at(i)

            if current_char.isNull():
                state = 0
            elif current_char.isPrint() and not current_char.isSpace() :
            #if (current_char.isSymbol()  or current_char.isLetterOrNumber() or current_char.isPunct()) and not current_char.isSpace() :
                #if state == 2:
                if state == 2:

                    list_qstr.append(aQstr.left(i))


                    aQstr = aQstr.right(i)
                    i = -1
                    current_len = aQstr.length()
                state = 1

            else:
                if state == 1:

                    #import pdb
                    #pdb.set_trace()
                    #list_qstr.append()#qt.QString(u' '))#aQstr.left(i))
                    aQstr = aQstr.right(i)
                    i = -1
                    current_len = aQstr.length()

                state = 2

        
        list_qstr.append(aQstr.left(aQstr.length()))


        return list_qstr


                    
    def drawAttrStr(self, paint, rect, qstr, attr, pm, clear):
        """Display Operation - attributed string draw primitive"""
        #print attr.b, attr.f
        if (attr.r & RE_CURSOR) and self.hasFocus() and (not self.has_blinking_cursor or not self.cursor_blinking):
            fColor = self.color_table[attr.b].color
            bColor = self.color_table[attr.f].color
        else:
            fColor = self.color_table[attr.f].color
            bColor = self.color_table[attr.b].color
        if attr.r & RE_CURSOR:
            self._cursor_rect = rect
        if pm and self.color_table[attr.b].transparent and (not (attr.r & RE_CURSOR) or self.cursor_blinking):
            paint.setBackgroundMode(self.TransparentMode)
            if clear:
                self.erase(rect)
        else:
            if self.blinking:
                paint.fillRect(rect, bColor)
            else:
                paint.setBackgroundMode(self.OpaqueMode)
                paint.setBackgroundColor(bColor)


        w = qstr        
        if not (self.blinking and (attr.r & RE_BLINK)):
            if (attr.r and RE_CURSOR) and self.cursor_blinking:
                self.erase(rect)
            paint.setPen(fColor)

            paint.drawText(rect.x(), rect.y()+self.font_a, w)
            if (attr.r & RE_UNDERLINE) or self.color_table[attr.f].bold:
                paint.setClipRect(rect)
                if self.color_table[attr.f].bold:
                    paint.setBackgroundMode(self.TransparentMode)
                    paint.drawText(rect.x()+1, rect.y()+self.font_a, w) # second stroke
                if attr.r & RE_UNDERLINE:
                    paint.drawLine(rect.left(), rect.y()+self.font_a+1,
                                   rect.right(), rect.y()+self.font_a+1)
                paint.setClipping(False)

        if (attr.r & RE_CURSOR) and not self.hasFocus():

            if pm and self.color_table[attr.b].transparent:

                self.erase(rect)
                paint.setBackgroundMode(self.TransparentMode)
                paint.drawText(rect.x(), rect.y()+self.font_a, w)

            paint.setClipRect(rect)
            paint.drawRect(rect.x(), rect.y(), rect.width(), rect.height()-self.line_spacing)
            paint.setClipping(False)



    def paintEvent(self, pe):
        """
        The difference of this routine vs. the `setImage' is, that the drawing
        does not include a difference analysis between the old and the new
        image. Instead, the internal image is used and the painting bound by the
        PaintEvent box.
        """
        pm = self.paletteBackgroundPixmap()
        self.setUpdatesEnabled(False)
        paint = qt.QPainter()
        paint.begin(self)
        paint.setBackgroundMode(self.TransparentMode)
        # Note that the actual widget size can be slightly larger
        # that the image (the size is truncated towards the smaller
        # number of characters in `resizeEvent'. The paint rectangle
        # can thus be larger than the image, but less then the size
        # of one character.
        rect = pe.rect().intersect(self.contentsRect())
        tL  = self.contentsRect().topLeft()
        tLx = tL.x()
        tLy = tL.y()
        lux = min(self.columns-1, max(0, (rect.left()   - tLx - self.bX) / self.font_w))
        luy = min(self.lines-1,   max(0, (rect.top()    - tLy - self.bY) / self.font_h))
        rlx = min(self.columns-1, max(0, (rect.right()  - tLx - self.bX) / self.font_w))
        rly = min(self.lines-1,   max(0, (rect.bottom() - tLy - self.bY) / self.font_h))
        image = self._image
        for y in xrange(luy, rly+1):
            c = image[y][lux].c
            x = lux
            if not c and x:
                x -= 1 # Search for start of multi-col char
            while x <= rlx:
                disstrU = []
                ca = image[y][x]
                c = ca.c
                if c:
                    disstrU.append(c)
                cf = ca.f
                cb = ca.b
                cr = ca.r
                xlen = 1
                while (x+xlen <= rlx and
                       image[y][x+xlen].f == cf and
                       image[y][x+xlen].b == cb and
                       image[y][x+xlen].r == cr):
                    c = image[y][x+xlen].c
                    if c:
                        disstrU.append(c)
                    xlen += 1
                if (x+xlen < self.columns) and (not image[y][x+xlen].c):
                    xlen += 1 # Adjust for trailing part of multi-column char
                unistr = qt.QString(u''.join(disstrU))
                self.drawAttrStr(paint,
                                 qt.QRect(self.bX+tLx+self.font_w*x, self.bY+tLy+self.font_h*y, self.font_w*xlen, self.font_h),
                                 unistr, ca, pm != None, False)
                x += xlen
        self.drawFrame(paint)
        paint.end()
        self.setUpdatesEnabled(True)

    def resizeEvent(self, ev):
        # see comment in `paintEvent' concerning the rounding.
        # FIXME: could make a routine here; check width(),height()
        assert ev.size().width() == self.width()
        assert ev.size().height() == self.height()
        self.myemit('ignoreShellWidgetResize')
        self.propagateSize()



    def fontChange(self, font):
        fm = qt.QFontMetrics(font) # QFontMetrics fm(font())
        self.font_h = fm.height() + self.line_spacing
        # waba TEWidget 1.123:
        # "Base character width on widest ASCII character. Self prevents too wide
        #  characters in the presence of double wide (e.g. Japanese) characters."
        self.font_w = 1
        for i in xrange(128):
            i = chr(i)
            if not i.isalnum():
                continue
            fw = fm.width(i)
            if self.font_w < fw:
                self.font_w = fw
        if self.font_w > 200: # don't trust unrealistic value, fallback to QFontMetrics::maxWidth()
            self.font_w = fm.maxWidth()
        if self.font_w < 1:
            self.font_w = 1
            
        self.font_a = fm.ascent()
        self.propagateSize()
        self.update()

    def frameChanged(self):
        self.propagateSize()
        self.update()


    # Mouse ###################################################################

    #    Three different operations can be performed using the mouse, and the
    #    routines in self section serve all of them:
    #
    #    1) The press/release events are exposed to the application
    #    2) Marking (press and move left button) and Pasting (press middle button)
    #    3) The right mouse button is used from the configuration menu
    #
    #    NOTE: During the marking process we attempt to keep the cursor within
    #    the bounds of the text as being displayed by setting the mouse position
    #    whenever the mouse has left the text area.
    #
    #    Two reasons to do so:
    #    1) QT does not allow the `grabMouse' to confine-to the TEWidget.
    #       Thus a `XGrapPointer' would have to be used instead.
    #    2) Even if so, self would not help too much, since the text area
    #       of the TEWidget is normally not identical with it's bounds.
    #
    #    The disadvantage of the current handling is, that the mouse can visibly
    #    leave the bounds of the widget and is then moved back. Because of the
    #    current construction, and the reasons mentioned above, we cannot do better
    #    without changing the overall construction.

    def mouseDoubleClickEvent(self, ev):
        """select the word under the pointer on mouse double click, and
        eventually wait for a third click to select the entire line
        """
        if ev.button() != self.LeftButton:
            return
        x, y = self._evXY(ev)
        # pass on double click as two clicks.
        if not self.mouse_marks and not (ev.state() & self.ShiftButton):
            # Send just _ONE_ click event, since the first click of the double click
            # was already sent by the click handler!
            self.myemit('mouseSignal', (0, x+1, y+1)) # left button
            return

        self.myemit('clearSelectionSignal')
        self.i_pnt_sel = qt.QPoint(x, y + self.scrollbar.value())
        self._word_selection_mode = True
        self._act_sel = 2 # within selection
        self.myemit('beginSelectionSignal', self._wordStart(x, y))
        self.myemit('extendSelectionSignal', self._wordEnd(x, y))
        self.myemit('endSelectionSignal', (self.preserve_line_breaks,))
        self._possible_triple_click = True


        self.myemit('onDoubleClickSignal', (self._wordStart(x, y), self._wordEnd(x, y)) )
        qt.QTimer.singleShot(qt.QApplication.doubleClickInterval(), self._tripleClickTimeout)

    def mousePressEvent(self, ev):
        if self._possible_triple_click and ev.button() == self.LeftButton:
            self.mouseTripleClickEvent(ev)
            return
        if not self.contentsRect().contains(ev.pos()):
            return
        x, y = self._evXY(ev)
        self._line_selection_mode = False
        self._word_selection_mode = False
        if ev.button() == self.LeftButton:
            topleft  = self.contentsRect().topLeft()
            # XXX: this is the only place where we add self.font_w/2, why ?
            pos = qt.QPoint((ev.x()-topleft.x()-self.bX+(self.font_w/2)) / self.font_w, y)
            self.myemit('isBusySelecting', (True,)) # Keep it steady...
            # Drag only when the Control key is hold
            selected = [False]
            # The receiver of the testIsSelected() signal will adjust
            # 'selected' accordingly.
            self.myemit('testIsSelected', (pos.x(), y, selected))
            selected = selected[0]
            if (not self.ctrldrag or ev.state() & self.ControlButton) and selected:
                # The user clicked inside selected text
                dragInfo.state = diPending
                dragInfo.start = ev.pos()
            else:
                # No reason to ever start a drag event
                dragInfo.state = diNone
                self.preserve_line_breaks = not (ev.state() & self.ControlButton)
                if self.mouse_marks or (ev.state() & self.ShiftButton):
                    self.myemit('clearSelectionSignal')
                    pos.setY(y + self.scrollbar.value())
                    self.i_pnt_sel = self.pnt_sel = pos
                    self._act_sel = 1 # left mouse button pressed but nothing selected yet.
                    self.grabMouse() # handle with care!
                else:
                    self.myemit('mouseSignal', (0, x+1, y+1)) # Left button
        elif ev.button() == self.MidButton:
            if self.mouse_marks or (not self.mouse_marks and (ev.state() & self.ShiftButton)):
                self.emitSelection(True, ev.state() & self.ControlButton)
            else:
                self.myemit('mouseSignal', (1, x+1, y+1))
        elif ev.button() == self.RightButton:
            if self.mouse_marks or (ev.state() & self.ShiftButton):
                self.myemit('configureRequest', (self, ev.state() & (self.ShiftButton|self.ControlButton), ev.x(), ev.y()))
            else:
                self.myemit('mouseSignal', (2, x+1, y+1))

    def mouseReleaseEvent(self, ev):
        x, y = self._evXY(ev)
        if ev.button() == self.LeftButton:
            self.myemit('isBusySelecting', (False,)) # Ok.. we can breath again.
            if dragInfo.state == diPending:
                # We had a drag event pending but never confirmed.  Kill selection
                self.myemit('clearSelectionSignal', ())
            else:
                if self._act_sel > 1:
                    self.myemit('endSelectionSignal', (self.preserve_line_breaks,))
                self._act_sel = 0
                #FIXME: emits a release event even if the mouse is
                #       outside the range. The procedure used in `mouseMoveEvent'
                #       applies here, too.
                if not self.mouse_marks and not (ev.state() & self.ShiftButton):
                    self.myemit('mouseSignal', (3, x+1, y + 1)) # release
                self.releaseMouse()
            dragInfo.state = diNone
        if not self.mouse_marks and ((ev.button() == self.RightButton and not (ev.state() & self.ShiftButton))
                                     or ev.button() == self.MidButton):
            self.myemit('mouseSignal', (3, x+1, y+1))
            self.releaseMouse()

    def mouseMoveEvent(self, ev):
        # for auto-hiding the cursor, we need mouseTracking
        if ev.state() == self.NoButton:
            return
        if dragInfo.state == diPending:
            # we had a mouse down, but haven't confirmed a drag yet
            # if the mouse has moved sufficiently, we will confirm
            #   int distance = KGlobalSettings::dndEventDelay();
            #   int distance = 0; # FIXME
            #   if ( ev.x() > dragInfo.start.x() + distance or ev.x() < dragInfo.start.x() - distance or
            #        ev.y() > dragInfo.start.y() + distance or ev.y() < dragInfo.start.y() - distance) {
            # we've left the drag square, we can start a real drag operation now
            #      emit isBusySelecting(False); # Ok.. we can breath again.
            #      emit clearSelectionSignal();
            #      doDrag();
            return
        elif dragInfo.state == diDragging:
            # self isn't technically needed because mouseMoveEvent is suppressed during
            # Qt drag operations, replaced by dragMoveEvent
            return
        if self._act_sel == 0:
            return
        # don't extend selection while pasting
        if ev.state() & self.MidButton:
            return
        #if ( not self.contentsRect().contains(ev.pos()) ) return;
        topleft  = self.contentsRect().topLeft()
        topleftx = topleft.x()
        toplefty = topleft.y()
        scroll = self.scrollbar.value()
        # we're in the process of moving the mouse with the left button pressed
        # the mouse cursor will kept catched within the bounds of the text in
        # self widget.
        # Adjust position within text area bounds. See FIXME above.
        pos = qt.QPoint(ev.pos())
        if pos.x() < topleftx+self.bX:
            pos.setX(topleftx+self.bX)
        if pos.x() > topleftx+self.bX+self.columns*self.font_w-1:
            pos.setX(topleftx+self.bX+self.columns*self.font_w)
        if pos.y() < toplefty+self.bY:
            pos.setY(toplefty+self.bY)
        if pos.y() > toplefty+self.bY+self.lines*self.font_h-1:
            pos.setY(toplefty+self.bY+self.lines*self.font_h-1)
        # check if we produce a mouse move event by self
        if pos != ev.pos():
            self.cursor().setPos(self.mapToGlobal(pos))
        if pos.y() == toplefty+self.bY+self.lines*self.font_h-1: # scrollforward
            self.scrollbar.setValue(self.scrollbar.value() + Y_MOUSE_SCROLL)
        if pos.y() == toplefty+self.bY: # scrollbackward
            self.scrollbar.setValue(self.scrollbar.value() - Y_MOUSE_SCROLL)
        here = [(pos.x()-topleftx-self.bX+(self.font_w/2))/self.font_w,
                (pos.y()-toplefty-self.bY)/self.font_h]
        i_pnt_sel_corr = [self.i_pnt_sel.x(), self.i_pnt_sel.y() - self.scrollbar.value()]
        pnt_sel_corr = [self.pnt_sel.x(), self.pnt_sel.y() - self.scrollbar.value()]
        swapping = False
        offset = 0
        if self._word_selection_mode:
            # Extend to word boundaries
            left_not_right = (here[1] < i_pnt_sel_corr[1] or
                              here[1] == i_pnt_sel_corr[1] and here[0] < i_pnt_sel_corr[0])
            old_left_not_right = (pnt_sel_corr[1] < i_pnt_sel_corr[1] or
                                  pnt_sel_corr[1] == i_pnt_sel_corr[1] and pnt_sel_corr[0] < i_pnt_sel_corr[0])
            swapping = left_not_right != old_left_not_right
            # Find left (left_not_right ? from here : from start)
            x, y = left_not_right and here or i_pnt_sel_corr
            if (x, y) >= (0, 0) and (x, y) < (self.columns, self.lines):
                x, y = self._wordStart(x, y)
            left = [x, y]
            # Find right (left_not_right ? from start : from here)
            x, y = left_not_right and i_pnt_sel_corr or here
            if (x, y) >= (0, 0) and (x, y) < (self.columns, self.lines):
                x, y = self._wordEnd(x, y)
            right = [x, y]
            # Pick which is start (ohere) and which is extension (here)
            if left_not_right:
                here, ohere = left, right
            else:
                here, ohere = right, left
            ohere[0] += 1
        elif self._line_selection_mode:
            # Extend to complete line
            above_not_below = here[1] < i_pnt_sel_corr[1]
            swapping = True # triple click maybe selected a wrapped line
            y = (above_not_below and here or i_pnt_sel_corr)[1]
            while y > 0 and self._line_wrapped[y-1]:
                y -= 1
            above = [0, y]
            y = (above_not_below and i_pnt_sel_corr or here)[1]
            while y < self.lines-1 and self._line_wrapped[y]:
                y += 1
            below = [self.columns-1, y]
            # Pick which is start (ohere) and which is extension (here)
            if above_not_below:
                here, ohere = above, below
            else:
                here, ohere = below, above
            ohere[0] += 1
        else:
            left_not_right = (here[1] < i_pnt_sel_corr[1] or
                              here[1] == i_pnt_sel_corr[1] and here[0] < i_pnt_sel_corr[0])
            old_left_not_right = (pnt_sel_corr[1] < i_pnt_sel_corr[1] or
                                  pnt_sel_corr[1] == i_pnt_sel_corr[1] and pnt_sel_corr[0] < i_pnt_sel_corr[0])
            swapping = left_not_right != old_left_not_right
            # Find left (left_not_right ? from here : from start)
            left = left_not_right and here or i_pnt_sel_corr
            x, y = left_not_right and i_pnt_sel_corr or here
            if (x, y) >= (0, 0) and (x, y) < (self.columns, self.lines) and x < len(self._image[0]) and y < len(self._image):
                klass = self._image[y][x].charClass()
                if klass == ' ':
                    while (x < self.columns-1 and self._image[y][x].charClass() == klass and y < self.lines-1 and not self._line_wrapped[y]):
                        x += 1
                    if x < self.columns-1:
                        x, y = left_not_right and i_pnt_sel_corr or here
                    else:
                        # will be balanced later because of offset=-1
                        x += 1
            right = [x, y]
            # Pick which is start (ohere) and which is extension (here)
            if left_not_right:
                here, ohere = left, right
                offset = 0
            else:
                here, ohere = right, left
                offset = -1
        if here == pnt_sel_corr and scroll == self.scrollbar.value():
            return # not moved
        if here == ohere:
            return # It's not left, it's not right.
        if self._act_sel < 2 or swapping:
            self.myemit('beginSelectionSignal', (ohere[0]-1-offset, ohere[1]))
        self._act_sel = 2 # within selection
        self.pnt_sel = qt.QPoint(here[0], here[1] + self.scrollbar.value())
        self.myemit('extendSelectionSignal', (here[0] + offset, here[1]))

    def mouseTripleClickEvent(self, ev):
        x, y = self._evXY(ev)
        self.i_pnt_sel = qt.QPoint(x, y)
        self.myemit('clearSelectionSignal')
        self._line_selection_mode = True
        self._word_selection_mode = False
        self._act_sel = 2 # within selection
        while self.i_pnt_sel.y()>0 and self._line_wrapped[self.i_pnt_sel.y()-1]:
            self.i_pnt_sel.setY(self.i_pnt_sel.y() - 1)
        self.myemit('beginSelectionSignal', (0, self.i_pnt_sel.y()))
        while self.i_pnt_sel.y()<self.lines-1 and self._line_wrapped[self.i_pnt_sel.y()]:
            self.i_pnt_sel.setY(self.i_pnt_sel.y() + 1)
        self.myemit('extendSelectionSignal', (self.columns-1, self.i_pnt_sel.y()))
        self.myemit('endSelectionSignal', (self.preserve_line_breaks,))
        self.i_pnt_sel.setY(self.i_pnt_sel.y() + self.scrollbar.value())


    def focusInEvent(self, ev):
        """*do* erase area, to get rid of the hollow cursor rectangle"""
        self.repaint(self._cursor_rect, True)

    def focusOutEvent(self, ev):
        """don't erase area"""
        self.repaint(self._cursor_rect, False)

    def scrollChanged(self, value):
        self.myemit('changedHistoryCursor', (value,))

    def blinkEvent(self):
        """Display operation"""
        self.blinking = not self.blinking
        self.repaint(False)

    def blinkCursorEvent(self):
        self.cursor_blinking = not self.cursor_blinking
        self.repaint(self._cursor_rect, False)

    # private #################################################################

    def _clearImage(self):
        """initialize the image, for internal use only"""
        self._image = [[DCA for _ in xrange(self.columns)]
                       for _ in xrange(self.lines)]

    def _makeImage(self):
        # calculate geometry first
        # FIXME: set rimX == rimY == 0 when running in full screen mode.
        self.scrollbar.resize(qt.QApplication.style().pixelMetric(qt.QStyle.PM_ScrollBarExtent),
                              self.contentsRect().height())
        if self.scroll_loc == SCRNONE:
            self.bX = 1
            self.columns = (self.contentsRect().width() - 2 * rimX) / self.font_w
            self.scrollbar.hide()
        elif self.scroll_loc == SCRLEFT:
            self.bX = 1+self.scrollbar.width()
            self.columns = (self.contentsRect().width() - 2 * rimX - self.scrollbar.width()) / self.font_w
            self.scrollbar.move(self.contentsRect().topLeft())
            self.scrollbar.show()
        elif self.scroll_loc ==  SCRRIGHT:
            self.bX = 1
            self.columns = (self.contentsRect().width()  - 2 * rimX - self.scrollbar.width()) / self.font_w
            self.scrollbar.move(self.contentsRect().topRight() - qt.QPoint(self.scrollbar.width()-1, 0))
            self.scrollbar.show()
        if self.columns < 1:
            self.columns = 1
        # FIXME: support 'rounding' styles
        self.lines = (self.contentsRect().height() - 2 * rimY ) / self.font_h
        # then build an empty image
        self._clearImage()

    def _swapColorTable(self):
        color = self.color_table[1]
        self.color_table[1] = self.color_table[0]
        self.color_table[0] = color
        self.update()

    def _tripleClickTimeout(self):
        """resets self._possible_triple_click"""
        self._possible_triple_click = False

    def _evXY(self, ev):
        """return (x, y) coordonnate of the image's characters pointed by a
        mouse event
        """
        topleft  = self.contentsRect().topLeft()
        x = (ev.x() - topleft.x() - self.bX) // self.font_w
        y = (ev.y() - topleft.y() - self.bY) // self.font_h
        return x, y

    def _wordStart(self, x, y):
        klass = self._image[y][x].charClass()
        while (x > 0 or (y > 0 and self._line_wrapped[y-1])) \
                  and self._image[y][x].charClass() == klass:
            if x > 0:
                x -= 1
            else:
                x = self.columns - 1
                y -= 1
        # don't add 1 if x == 0
        return x and x+1, y

    def _wordEnd(self, x, y):
        klass = self._image[y][x].charClass()
        while (x < self.columns-1 or (y < self.lines-1 and self._line_wrapped[y])) \
                  and self._image[y][x].charClass() == klass:
            if x < self.columns-1:
                x += 1
            else:
                x = 0
                y += 1
        return x-1, y

    def contextMenuEvent(self, event):
        def copy(ev):
            #XXX: FIXME!!!
            # this is copying but also pasting like when the middle button is pressed
            # this should only copy!!
            if self.mouse_marks or (not self.mouse_marks and (ev.state() & self.ShiftButton)):
                qt.QApplication.clipboard().setSelectionMode(ev.state() & self.ControlButton)
                #self.emitSelection(True, ev.state() & self.ControlButton)
            else:
                self.myemit('mouseSignal', (1, x+1, y+1))
        def paste(ev):
            #XXX: FIXME!!!
            # I didn't if this is ok
            text = qt.QApplication.clipboard().text()
            if not text.isEmpty():
                text.replace(qt.QRegExp("\n"), "\r")
            ev = qt.QKeyEvent(qt.QEvent.KeyPress, 0, -1, 0, text)
            self.myemit('keyPressedSignal', (ev,)) # expose as a big fat keypress event
            self.myemit('clearSelectionSignal')
            qt.QApplication.clipboard().setSelectionMode(False)

        #TODO: esta variable popup menu en lugar de crearse aca todo el tiempo se puede
        # poner en el init y luego hacer un metodo de setup para agregarle todas las opciones
        # y asignar a cada item la funcion que corresponda (tal como se hace en el tab manager)
        popup_menu = qt.QPopupMenu(self)
        popup_menu.insertItem("Copy", lambda ev: copy(event))
        popup_menu.insertItem("Paste", lambda ev: paste(event))
        popup_menu.insertItem("Close Tab", lambda ev: ev)
        popup_menu.exec_loop(event.globalPos())

    def shellSetFont(self, font=None):
        if font is not None:
            self.setVTFont(font)
        else:
            f = qt.QFont()
            f.setFamily("fixed")
            f.setFixedPitch(True)
            f.setPixelSize(13)
            self.setVTFont(f)


########NEW FILE########
__FILENAME__ = tabmanager
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import qt
import os
import model.api as api
from model.guiapi import getMainWindow

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

#TODO: define some way to rename each tab

#TODO: check if we should reimplement our own QTabBar and replace the one on this
# QTabWidget

#TODO: check if the PYSIGNAL contextMenu needs to be changed because it is also
# used in the gui.hostbrowser

class ContextMenuTabBar(qt.QTabBar):
    def __init__(self, parent):
        qt.QTabBar.__init__(self,parent)
        self._actions = {}
        self._setupActions()
        self.connect(self, qt.PYSIGNAL('contextMenu'), self._showContextMenu )
        self.contextPopupMenu = qt.QPopupMenu(self)
        self._setupContextPopupMenu()
       
    def addAction(self, name, func):
        self._actions[name] = func

    def _setupContextPopupMenu(self):
        """
        setups all items in the context menu with all its actions
        """
        #insertItem ( const QString & text,
        #              const QObject * receiver,
        #              const char * member,
        #              const QKeySequence & accel = 0,
        #              int id = -1,
        #              int index = -1 )
        self.contextPopupMenu.insertItem("Allow plugins on this shell", self._allowPlugins)
        self._actions["new_shell"].addTo(self.contextPopupMenu);
        self._actions["close_shell"].addTo(self.contextPopupMenu);
        #self.contextPopupMenu.insertItem("Close tab", self._actions["close_shell"])

    def contextMenuEvent(self, event):
        #XXX: emits the signal to show the parent context menu
        # this will end up calling the TreeView _showContextMenu
        self.emit( qt.PYSIGNAL('contextMenu'), (event.globalPos(),) )

    def _showContextMenu(self, pos):
        """Pop up a context menu when the tab is clicked"""
        self.contextPopupMenu.exec_loop(pos)

    def _allowPlugins(self):
        api.devlog("<TabManager> plugins are allowed for current shell (%s)" % self.parent().activeWindow())

    def mouseDoubleClickEvent (self, ev):
        # e is a qt.QMouseEvent
        if "maximize" in self._actions:
            self._actions["maximize"]()
            
    def _setupActions(self):
        """
        creates some actions needed on some menues and toolbars
        """
        a = self._actions["close_shell"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"newshell.png"))), "&Close Shell", qt.Qt.CTRL + qt.Qt.Key_W, self, "New Shell" )
        self.connect(a, qt.SIGNAL('activated()'), self.destroyShellTab)
        
        a = self._actions["new_shell"] = qt.QAction( qt.QIconSet(qt.QPixmap(os.path.join(CONF.getIconsPath(),"newshell.png"))), "&New Shell", qt.Qt.CTRL + qt.Qt.Key_T, self, "New Shell" )
        self.connect(a, qt.SIGNAL('activated()'), self.createShellTab)

    def destroyShellTab(self):
        getMainWindow().destroyShellTab()
    
    def createShellTab(self):
        getMainWindow().createShellTab()

class TabManager(qt.QTabWidget):

    def __init__(self, parent):
        qt.QTabWidget.__init__(self, parent)
        self.views = []
        self.setMargin(10)
        self.connect(self, qt.SIGNAL('currentChanged(QWidget*)'), self._setFocus)
        
        # we replace the tab bar with our own wich handles contextMenu
        tabbar = ContextMenuTabBar(self)
        self.setTabBar(tabbar)
        self._next_id = 0
    
    def getNextId(self):
        self._next_id += 1
        return self._next_id
        
    def addView(self, view):
        if view not in self.views:
            self.views.append(view)
            self.addTab(view, view.name())
            self.showPage(view)

    def removeView(self, view):
        if view in self.views:
            self.views.remove(view)
            self.removePage(view)

    def activeWindow(self):
        return self.currentPage()

    def windowList(self):
        return self.views

    def cascade(self): pass

    def tile(self): pass

    def canCascade(self):
        return False

    def canTile(self):
        return False

    def count(self):
        return len(self.views)

    def _setFocus(self, widget):
        # just set focus is set on the widget that is contained in the new selected page.
        widget.setFocus()
########NEW FILE########
__FILENAME__ = toolbars
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
#!/usr/bin/env python
import qt

class LocationToolbar(qt.QToolBar):

    def __init__(self, parent, name, *args, **kwargs):
        qt.QToolBar.__init__(self, parent, name)
        self.setName(name)
        hb = qt.QHBox(self)
        self._lstr = qt.QLabel("Filter: ", hb, "Filter label")
                                                                              
                                                
                                                                      
                                                      
        self._lcombo = CustomQCombobox(True, hb, 'Filter ComboBox',parent.setFilter)
        self._values = [""]
        self._lcombo.insertStrList(self._values)
        self._lcombo.setFixedSize(300, 25)
        self._lbutton = qt.QPushButton("Set", hb, "Filter Toggle Button")
        self._lbutton.setFixedSize(50, 25)
        self.connect(self._lbutton, qt.SIGNAL('clicked()'), parent.setFilter)


    def getSelectedValue(self):
        return str(self._lcombo.currentText())

    def addFilter(self, new_filter):
        self._lcombo.insertItem(new_filter)

class CustomQCombobox(qt.QComboBox):
    def __init__(self, rw, parent, name,callback):
        qt.QComboBox.__init__(self, rw, parent, name)
        self.callback=callback

                                    
                          
                                     
                             
               
                            
              
                        
                       

    def keyReleaseEvent(self, event):
                                     
                             
               
                            
        self.callback()
        event.ignore()       

class PerspectiveToolbar(qt.QHBox):
    def __init__(self, parent, name, *args, **kwargs):
        qt.QHBox.__init__(self, parent, name)
        self.setName(name)
        self.setSpacing(0)
        hb = qt.QHBox(self)
        self._lstr = qt.QLabel("Perspective", hb, "perspective_label")
        self._lcombo = qt.QComboBox(hb,'Perspective_ComboBox')
        self.connect(self._lcombo, qt.SIGNAL('activated(int)'), parent.setActivePerspective)

    def addPerspective(self, new):
        self._lcombo.insertItem(new)

    def getSelectedValue(self):
        return str(self._lcombo.currentText())

    def sizeHint(self):
        return qt.QSize(70, 20)

########NEW FILE########
__FILENAME__ = evidenceslist
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
# -*- coding: utf-8 -*-

                                                                       
 
                                   
                                                          
 
                                                      


from qt import *
from qttable import QTable


class EvidencesListUI(QDialog):
    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)

        if not name:
            self.setName("EvidencesListUI")

        self.evidences_table = QTable(self,"evidences_table")
        self.evidences_table.setNumCols(self.evidences_table.numCols() + 1)
        self.evidences_table.horizontalHeader().setLabel(self.evidences_table.numCols() - 1,self.__tr("Id"))
        self.evidences_table.setNumCols(self.evidences_table.numCols() + 1)
        self.evidences_table.horizontalHeader().setLabel(self.evidences_table.numCols() - 1,self.__tr("Path"))
        self.evidences_table.setGeometry(QRect(20,20,510,360))
        self.evidences_table.setMinimumSize(QSize(300,0))
        self.evidences_table.setResizePolicy(QTable.AutoOne)
        self.evidences_table.setVScrollBarMode(QTable.AlwaysOn)
        self.evidences_table.setNumRows(0)
        self.evidences_table.setNumCols(2)

        LayoutWidget = QWidget(self,"layout7")
        LayoutWidget.setGeometry(QRect(90,400,377,29))
        
        layout7 = QHBoxLayout(LayoutWidget,5,5,"layout7")

        self.add_button = QPushButton(LayoutWidget,"add_button")
        layout7.addWidget(self.add_button)
        spacer = QSpacerItem(21,21,QSizePolicy.Expanding,QSizePolicy.Minimum)
        layout7.addItem(spacer)

        self.delete_button = QPushButton(LayoutWidget,"delete_button")
        layout7.addWidget(self.delete_button)

        self.languageChange()

        self.resize(QSize(555,447).expandedTo(self.minimumSizeHint()))
        self.clearWState(Qt.WState_Polished)


    def languageChange(self):
        self.setCaption(self.__tr("Evidences"))
        self.evidences_table.horizontalHeader().setLabel(0,self.__tr("Id"))
        self.evidences_table.horizontalHeader().setLabel(1,self.__tr("Path"))
        self.add_button.setText(self.__tr("Add"))
        self.delete_button.setText(self.__tr("Delete"))


    def __tr(self,s,c = None):
        return qApp.translate("EvidencesListUI",s,c)

########NEW FILE########
__FILENAME__ = noteslist
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
# -*- coding: utf-8 -*-

                                                                   
 
                                   
                                                          
 
                                                      


from qt import *
from qttable import QTable


class NotesListUI(QDialog):
    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)

        if not name:
            self.setName("NotesListUI")

        self.notes_table = QTable(self,"notes_table")
        self.notes_table.setNumCols(self.notes_table.numCols() + 1)
        self.notes_table.horizontalHeader().setLabel(self.notes_table.numCols() - 1,self.__tr("Name"))
        self.notes_table.setNumCols(self.notes_table.numCols() + 1)
        self.notes_table.horizontalHeader().setLabel(self.notes_table.numCols() - 1,self.__tr("Content"))
        self.notes_table.setGeometry(QRect(20,20,510,360))
        self.notes_table.setMinimumSize(QSize(300,0))
        self.notes_table.setResizePolicy(QTable.AutoOne)
        self.notes_table.setVScrollBarMode(QTable.AlwaysOn)
        self.notes_table.setNumRows(0)
        self.notes_table.setNumCols(2)

        LayoutWidget = QWidget(self,"layout7")
        LayoutWidget.setGeometry(QRect(90,400,377,29))
        
                                                                                                                 
        layout7 = QHBoxLayout(LayoutWidget,5,5,"layout7")

        self.add_button = QPushButton(LayoutWidget,"add_button")
        layout7.addWidget(self.add_button)
        spacer = QSpacerItem(21,21,QSizePolicy.Expanding,QSizePolicy.Minimum)
        layout7.addItem(spacer)

        self.edit_button = QPushButton(LayoutWidget,"edit_button")
        layout7.addWidget(self.edit_button)
        layout7.addItem(spacer)

        self.delete_button = QPushButton(LayoutWidget,"delete_button")
        layout7.addWidget(self.delete_button)
        layout7.addItem(spacer)
        
        self.list_note_button = QPushButton(LayoutWidget,"list_note_button")
        layout7.addWidget(self.list_note_button)

        self.languageChange()

        self.resize(QSize(555,447).expandedTo(self.minimumSizeHint()))
        self.clearWState(Qt.WState_Polished)


    def languageChange(self):
        self.setCaption(self.__tr("Notes"))
        self.notes_table.horizontalHeader().setLabel(0,self.__tr("Name"))
        self.notes_table.horizontalHeader().setLabel(1,self.__tr("Content"))
        self.add_button.setText(self.__tr("New"))
        self.edit_button.setText(self.__tr("Edit"))
        self.delete_button.setText(self.__tr("Delete"))
        self.list_note_button.setText(self.__tr("List Notes"))


    def __tr(self,s,c = None):
        return qApp.translate("NotesListUI",s,c)

########NEW FILE########
__FILENAME__ = plugin_settings
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
# -*- coding: utf-8 -*-

                                                                         
 
                                   
                                                          
 
                                                      


from qt import *
from qttable import QTable
from model.api import devlog


class PluginSettingsUi(QDialog):
    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)

        if not name:
            self.setName("PluginSettingsUi")

        self.setSizeGripEnabled(1)

        PluginSettingsUiLayout = QGridLayout(self,1,1,11,6,"PluginSettingsUiLayout")

        Layout1 = QHBoxLayout(None,0,6,"Layout1")
        Horizontal_Spacing2 = QSpacerItem(20,20,QSizePolicy.Expanding,QSizePolicy.Minimum)
        Layout1.addItem(Horizontal_Spacing2)

        self.bt_ok = QPushButton(self,"bt_ok")
        self.bt_ok.setAutoDefault(1)
        self.bt_ok.setDefault(1)
        Layout1.addWidget(self.bt_ok)

        self.bt_cancel = QPushButton(self,"bt_cancel")
        self.bt_cancel.setAutoDefault(1)
        Layout1.addWidget(self.bt_cancel)

        PluginSettingsUiLayout.addMultiCellLayout(Layout1,1,1,0,1)

        self.lw_plugins = QListView(self,"lw_plugins")
        self.lw_plugins.addColumn(self.__tr("Plugin"))
        self.lw_plugins.header().setClickEnabled(0,self.lw_plugins.header().count() - 1)
        self.lw_plugins.setMinimumSize(QSize(300,0))
        self.lw_plugins.setMaximumSize(QSize(300,32767))
        self.lw_plugins.setResizePolicy(QListView.AutoOneFit)
        self.lw_plugins.setResizeMode(QListView.LastColumn)

        PluginSettingsUiLayout.addWidget(self.lw_plugins,0,0)

        self.frame3 = QFrame(self,"frame3")
        self.frame3.setMinimumSize(QSize(330,0))
        self.frame3.setFrameShape(QFrame.StyledPanel)
        self.frame3.setFrameShadow(QFrame.Raised)
        frame3Layout = QGridLayout(self.frame3,1,1,11,6,"frame3Layout")

        self.line1 = QFrame(self.frame3,"line1")
        self.line1.setFrameShape(QFrame.HLine)
        self.line1.setFrameShadow(QFrame.Sunken)
        self.line1.setFrameShape(QFrame.HLine)

        frame3Layout.addWidget(self.line1,3,0)

        self.t_parameters = QTable(self.frame3,"t_parameters")
        self.t_parameters.setSelectionMode(QTable.NoSelection)
        self.t_parameters.setNumCols(self.t_parameters.numCols() + 1)
        self.t_parameters.horizontalHeader().setLabel(self.t_parameters.numCols() - 1,self.__tr("Value"))
        self.t_parameters.horizontalHeader().setClickEnabled(False)
        self.t_parameters.setNumRows(self.t_parameters.numRows() + 1)
        self.t_parameters.verticalHeader().setLabel(self.t_parameters.numRows() - 1,self.__tr("Default                "))
        self.t_parameters.setMinimumSize(QSize(300,0))
        self.t_parameters.setResizePolicy(QTable.Default)
        self.t_parameters.setVScrollBarMode(QTable.AlwaysOn)
        self.t_parameters.setNumRows(1)
        self.t_parameters.setNumCols(1)
        self.t_parameters.setSorting(1)

        frame3Layout.addWidget(self.t_parameters,3,0)

        layout5 = QHBoxLayout(None,0,6,"layout5")

        self.label_name = QLabel(self.frame3,"label_name")
        self.label_name.setMinimumSize(QSize(67,0))
        self.label_name.setMaximumSize(QSize(67,32767))
        label_name_font = QFont(self.label_name.font())
        label_name_font.setBold(1)
        self.label_name.setFont(label_name_font)
        layout5.addWidget(self.label_name)

        self.le_name = QLineEdit(self.frame3,"le_name")
        self.le_name.setMinimumSize(QSize(250,0))
        self.le_name.setReadOnly(1)
        layout5.addWidget(self.le_name)

        frame3Layout.addLayout(layout5,0,0)

        layout6 = QHBoxLayout(None,0,6,"layout6")

        self.label_version = QLabel(self.frame3,"label_version")
        self.label_version.setMinimumSize(QSize(67,0))
        self.label_version.setMaximumSize(QSize(67,32767))
        label_version_font = QFont(self.label_version.font())
        label_version_font.setBold(1)
        self.label_version.setFont(label_version_font)
        layout6.addWidget(self.label_version)
        
        self.le_version = QLineEdit(self.frame3,"le_version")
        self.le_version.setMinimumSize(QSize(250,0))
        self.le_version.setReadOnly(1)
        layout6.addWidget(self.le_version)

        frame3Layout.addLayout(layout6,1,0)
        
        layout7 = QHBoxLayout(None,0,6,"layout7")
        
        self.label_pversion = QLabel(self.frame3,"label_pversion")
        self.label_pversion.setMinimumSize(QSize(67,0))
        self.label_pversion.setMaximumSize(QSize(67,32767))
        label_pversion_font = QFont(self.label_pversion.font())
        label_pversion_font.setBold(1)
        self.label_pversion.setFont(label_pversion_font)
        layout7.addWidget(self.label_pversion)
        
        self.le_pversion = QLineEdit(self.frame3,"le_pversion")
        self.le_pversion.setMinimumSize(QSize(250,0))
        self.le_pversion.setReadOnly(1)
        layout7.addWidget(self.le_pversion)
        
        frame3Layout.addLayout(layout7,2,0)     

        PluginSettingsUiLayout.addWidget(self.frame3,0,1)

        self.languageChange()

        self.resize(QSize(782,593).expandedTo(self.minimumSizeHint()))
        self.clearWState(Qt.WState_Polished)

        self.connect(self.bt_ok,SIGNAL("clicked()"),self.accept)
        self.connect(self.bt_cancel,SIGNAL("clicked()"),self.reject)


    def languageChange(self):
        self.setCaption(self.__tr("Plugin Settings"))
        self.bt_ok.setText(self.__tr("&OK"))
        self.bt_ok.setAccel(QKeySequence(QString.null))
        self.bt_cancel.setText(self.__tr("&Cancel"))
        self.bt_cancel.setAccel(QKeySequence(QString.null))
        self.lw_plugins.header().setLabel(0,self.__tr("Plugin"))
        self.t_parameters.horizontalHeader().setLabel(0,self.__tr("Value"))
        self.t_parameters.verticalHeader().setLabel(0,self.__tr("Default                "))
        self.label_name.setText(self.__tr("Name:"))
        self.label_version.setText(self.__tr("Tool:"))
        self.label_pversion.setText(self.__tr("Plugin:"))

    def lv_parameters_currentChanged(self,a0):
        devlog("PluginSettingsUi.lv_parameters_currentChanged(QListViewItem*): Not implemented yet")

    def __tr(self,s,c = None):
        return qApp.translate("PluginSettingsUi",s,c)

########NEW FILE########
__FILENAME__ = preferences
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
# -*- coding: utf-8 -*-

                                                                     
 
                                   
                                                          
 
                                                      


from qt import *


class PreferencesUi(QDialog):
    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)

        if not name:
            self.setName("PreferencesUi")


        PreferencesUiLayout = QGridLayout(self,1,1,11,6,"PreferencesUiLayout")

        layout18 = QHBoxLayout(None,0,6,"layout18")

        self.textLabel1 = QLabel(self,"textLabel1")
        layout18.addWidget(self.textLabel1)

        self.cb_font_family = QComboBox(0,self,"cb_font_family")
        self.cb_font_family.setMinimumSize(QSize(300,0))
        layout18.addWidget(self.cb_font_family)

        PreferencesUiLayout.addLayout(layout18,0,0)

        layout19_2 = QHBoxLayout(None,0,6,"layout19_2")

        self.textLabel1_2_2 = QLabel(self,"textLabel1_2_2")
        layout19_2.addWidget(self.textLabel1_2_2)

        self.cb_font_size = QComboBox(0,self,"cb_font_size")
        self.cb_font_size.setMinimumSize(QSize(300,0))
        layout19_2.addWidget(self.cb_font_size)

        PreferencesUiLayout.addLayout(layout19_2,2,0)

        layout19 = QHBoxLayout(None,0,6,"layout19")

        self.textLabel1_2 = QLabel(self,"textLabel1_2")
        layout19.addWidget(self.textLabel1_2)

        self.cb_font_style = QComboBox(0,self,"cb_font_style")
        self.cb_font_style.setMinimumSize(QSize(300,0))
        layout19.addWidget(self.cb_font_style)

        PreferencesUiLayout.addLayout(layout19,1,0)

        layout21 = QHBoxLayout(None,0,6,"layout21")
        spacer6 = QSpacerItem(121,21,QSizePolicy.Expanding,QSizePolicy.Minimum)
        layout21.addItem(spacer6)

        layout20 = QHBoxLayout(None,0,6,"layout20")

        self.bt_ok = QPushButton(self,"bt_ok")
        layout20.addWidget(self.bt_ok)

        self.bt_cancel = QPushButton(self,"bt_cancel")
        layout20.addWidget(self.bt_cancel)
        layout21.addLayout(layout20)

        PreferencesUiLayout.addLayout(layout21,4,0)

        self.le_example = QLineEdit(self,"le_example")
        self.le_example.setFrameShadow(QLineEdit.Sunken)
        self.le_example.setAlignment(QLineEdit.AlignHCenter)
        self.le_example.setReadOnly(1)

        PreferencesUiLayout.addWidget(self.le_example,3,0)

        self.languageChange()

        self.resize(QSize(436,217).expandedTo(self.minimumSizeHint()))
        self.clearWState(Qt.WState_Polished)


    def languageChange(self):
        self.setCaption(self.__tr("Preferences"))
        self.textLabel1.setText(self.__tr("Font:"))
        self.textLabel1_2_2.setText(self.__tr("Size:"))
        self.textLabel1_2.setText(self.__tr("Style:"))
        self.bt_ok.setText(self.__tr("Ok"))
        self.bt_cancel.setText(self.__tr("Cancel"))
        self.le_example.setText(self.__tr("This is an example."))


    def __tr(self,s,c = None):
        return qApp.translate("PreferencesUi",s,c)

########NEW FILE########
__FILENAME__ = vulnerabilities
# -*- coding: utf-8 -*-
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

                                                                         
 
                                   
                                                          
 
                                                      


from qt import *
from qttable import QTable


class VulnerabilitiesUi(QDialog):
    def __init__(self,parent = None,name = None,modal = 0,fl = 0):
        QDialog.__init__(self,parent,name,modal,fl)

        if not name:
            self.setName("VulnerabilitiesUi")

                                        

                                                                                       

        self.t_vulns = QTable(self,"t_vulns")
        self.t_vulns.setNumCols(self.t_vulns.numCols() + 1)
        self.t_vulns.horizontalHeader().setLabel(self.t_vulns.numCols() - 1,self.__tr("Name"))
        self.t_vulns.setNumCols(self.t_vulns.numCols() + 1)
        self.t_vulns.horizontalHeader().setLabel(self.t_vulns.numCols() - 1,self.__tr("Refs"))
        self.t_vulns.setNumCols(self.t_vulns.numCols() + 1)
        self.t_vulns.horizontalHeader().setLabel(self.t_vulns.numCols() - 1,self.__tr("Description"))
        self.t_vulns.setMinimumSize(QSize(700,0))
        self.t_vulns.setResizePolicy(QTable.AutoOne)
        self.t_vulns.setVScrollBarMode(QTable.AlwaysOn)
        self.t_vulns.setNumRows(0)
        self.t_vulns.setNumCols(3)

                                                            
        LayoutWidget = QWidget(self,"layout7")
        LayoutWidget.setGeometry(QRect(90,500,450,29))
        
                                                                                                                 
        layout7 = QHBoxLayout(LayoutWidget,5,5,"layout7")

        self.add_button = QPushButton(LayoutWidget,"add_button")
        layout7.addWidget(self.add_button)
        spacer6_2 = QSpacerItem(21,21,QSizePolicy.Expanding,QSizePolicy.Minimum)
        layout7.addItem(spacer6_2)

        self.edit_button = QPushButton(LayoutWidget,"edit_button")
        layout7.addWidget(self.edit_button)
        spacer6 = QSpacerItem(21,21,QSizePolicy.Expanding,QSizePolicy.Minimum)
        layout7.addItem(spacer6)

        self.delete_button = QPushButton(LayoutWidget,"delete_button")
        layout7.addWidget(self.delete_button)
        
        spacer6_3 = QSpacerItem(21,21,QSizePolicy.Expanding,QSizePolicy.Minimum)
        layout7.addItem(spacer6_3)

        self.list_note_button = QPushButton(LayoutWidget,"list_note_button")
        layout7.addWidget(self.list_note_button)

        spacer7_3 = QSpacerItem(21,21,QSizePolicy.Expanding,QSizePolicy.Minimum)
        layout7.addItem(spacer7_3)

        self.manage_evidence_button = QPushButton(LayoutWidget,"manage_evidence_button")
        layout7.addWidget(self.manage_evidence_button)

        self.languageChange()
        
        
        self.resize(QSize(733,550).expandedTo(self.minimumSizeHint()))
        self.clearWState(Qt.WState_Polished)


    def languageChange(self):
        self.setCaption(self.__tr("Vulnerability List"))
        self.t_vulns.horizontalHeader().setLabel(0,self.__tr("Name"))
        self.t_vulns.horizontalHeader().setLabel(1,self.__tr("Refs"))
        self.t_vulns.horizontalHeader().setLabel(2,self.__tr("Description"))
        self.add_button.setText(self.__tr("New"))
        self.edit_button.setText(self.__tr("Edit"))
        self.delete_button.setText(self.__tr("Delete"))
        self.list_note_button.setText(self.__tr("List Notes"))
        self.manage_evidence_button.setText(self.__tr("Evidence"))


    def __tr(self,s,c = None):
        return qApp.translate("VulnerabilitiesUi",s,c)

########NEW FILE########
__FILENAME__ = workspacebrowser
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import sys
import os
import qt
import qttable
from model.controller import modelactions
import model.api as api
from gui.qt3.dialogs import WorkspacePropertiesDialog
from gui.qt3.dialogs import WorkspaceCreationDialog

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

class WorkspaceListViewItem(qt.QListViewItem):
    """Item for displaying in the WorkspaceTreeWindow."""

    def __init__(self, qtparent,  name = "", workspace_object=None):
        qt.QListViewItem.__init__(self, qtparent)
                                   
        self.setRenameEnabled(0, False)
        self.index = 0
        self.object = workspace_object
        self.name = self.object.name if self.object is not None else name
        self.setDragEnabled(False)
        self.setDropEnabled(False)
        self._setIcon()
        
        self.name = "%s (%s)" % (self.name , self.object.__class__.__name__.replace("WorkspaceOn",""))
        
    
    def _setIcon(self):
        active = self.object.isActive() if self.object is not None else False
        icon_name = "FolderBlue-20.png" if active else "FolderSteel-20.png"
        icon_path = os.path.join(CONF.getIconsPath(), icon_name)
        pm = qt.QPixmap(icon_path)
        self.setPixmap(0, pm)


    def setText(self, col, text):
        """Update name of widget if rename is called."""
                                                      

                               
        if col == 0:
            try:
                self.widget.rename( unicode(text) )
            except ValueError:
                                      
                text = self.widget.name

        qt.QListViewItem.setText(self, col, text)

    def rename(self):
        """Rename the listviewitem."""
        self.startRename(0)

                                                            
               
    def compare(self, i, col, ascending):
        """
        #Always sort according to the index value.
        """
        a = [-1, 1][ascending]
                            
        if self.name < i.name:
            return -1*a
        elif self.name > i.name:
            return 1*a
        else:
            return 0

    def text(self, column):
        """Get the text in a particular column."""
        if column == 0:
            return self.name
        return ''


                                                                                

class WorkspaceListView(qt.QListView):

    def __init__(self, parent):
        qt.QListView.__init__(self, parent)
        self.setSelectionMode(qt.QListView.Extended)
    
                                       
                                                               
                                                                 
                                                                                                                

    def dragObject(self):
                                                                   
                                                                          
                                               
        return False

    def selectWidget(self, widget):
        """Find the widget in the list and select it."""

                                                                   
                       
        iter = qt.QListViewItemIterator(self)

        found = None
        while True:
            item = iter.current()
            if item == None:
                break
            if item.widget == widget:
                found = item
                break
            iter += 1

        if found:
            self.ensureItemVisible(found)
            self.setSelected(found, True)

                                                                                
class WorkspaceTreeWindow(qt.QVBox):

    def __init__(self, parent, caption="", manager=None):
        qt.QVBox.__init__(self, parent)
        self.setName(caption)
        self.manager = manager
        
                                      
                                 
                                                                               
        self.setFrameStyle(qt.QFrame.Panel | qt.QFrame.Plain)
        self.setLineWidth(1)

        self.contextpopups = {}
                                   

                                    
                              
                                                   
                                     
        
                                                     
        lv = self.listview = WorkspaceListView(self)
        
                                     
                                       
                          
        
        lv.setRootIsDecorated(True)

                                               
                                                                                              
        self.connect( lv, qt.SIGNAL("rightButtonPressed(QListViewItem *,const QPoint&,int)"), self._showContextMenu )
        self.connect( lv, qt.SIGNAL("doubleClicked(QListViewItem *, const QPoint &, int)"), self._itemDoubleClick )

                                                        
        lv.addColumn("Workspaces")
        lv.setColumnWidthMode(0, qt.QListView.Maximum)
                                                                                    

                         
        lv.setTreeStepSize(20)

                                                         
                                                 
                                                                
        self._workspace_items = []
        
    
    def sizeHint(self):
        return qt.QSize(70, 200)

    def resizeEvent (self, event ):
                                                                  
                                                           
                                                                 
                              
        self.listview.setColumnWidth(0,self.size().width()-7)
                                                                              
                                                                       
    
    def clearTree(self):
        """
        clear all the items in the tree
        """
        api.devlog("clearTree called")
        i = self.listview.firstChild()
        items_to_remove = []
        while i is not None:
                                                               
                             
                                                       
            items_to_remove.append(i)
            i = i.nextSibling()

        for i in items_to_remove:
            self.listview.takeItem(i)
    
    def customEvent(self, event):
        if event.type() in ():
            pass

    def loadAllWorkspaces(self):
        """
        Clear the tree and loads all workspaces defined in the workspace manager
        """
        self.clearTree()
        for w in self.manager.getWorkspaces():
            witem = WorkspaceListViewItem(self.listview, w.name, w)
            self._workspace_items.append(witem)

    def setDefaultWorkspace(self): 
        first_child = self.listview.firstChild()
        if first_child: 
            self._openWorkspace(first_child)
            
    def _itemDoubleClick(self, item, pos, val):
                                  
                                               
                              
        if not item.object.isActive():
            self._openWorkspace(item)
        
    def _showContextMenu(self, item, pos, val):
        """Pop up a context menu when an item is right-clicked on the list view."""
                                                                                               
                                               
                                               
                                               
                              
        popup = qt.QPopupMenu(self)

        selected_items = self._getSelectedItems()

        if not selected_items:
                                                      
            popup.insertItem('Create Workspace', 100)
        else:
            if len(selected_items) == 1:
                if item.object.isActive():
                    popup.insertItem('Save', self._saveWorkspace)
                    popup.insertItem('Synchronize', self._syncWorkspace)
                    popup.insertItem('Close', 300)
                else:
                    popup.insertItem('Open', lambda: self._openWorkspace(item))
                    popup.insertItem('Delete', lambda: self._deleteWorkspace(item))
            
                popup.insertItem('Properties', lambda: self._showWorkspaceProperties(item))

            elif len(selected_items) > 1: 
                popup.insertItem('Delete', lambda: self._deleteWorkspaces(selected_items))
            else:
                api.devlog("ERROR: right click on an valid item (%r) which has a null object" % item)
            
        ret = popup.exec_loop(pos)
        
        api.devlog("contextMenuEvent WorkspaceItem - item: %s - ret %s" % (self.name, ret))
                                              

    def _getSelectedItems(self): 
        selected = []
        i = self.listview.firstChild()
        while i is not None:
            if i.isSelected(): selected.append(i)
            i = i.itemBelow()

        return selected


    def _deleteWorkspaces(self, items):
        for item in items:
            self._getMainApp().removeWorkspace(item.object.name)
        self.loadAllWorkspaces()

    def _deleteWorkspace(self, item):
        self._getMainApp().removeWorkspace(item.object.name)
        self.loadAllWorkspaces()
    
    def _openWorkspace(self, item):
                                               
                                                                     
        api.devlog("Opening workspace %s selected on the Workspace Perspective" % item.name)
        self._getMainApp().openWorkspace(item.object.name)
                         
        self.loadAllWorkspaces()

    def _saveWorkspace(self):
        self._getMainApp().saveWorkspaces()
        
    def _syncWorkspace(self):
        self._getMainApp().syncWorkspaces()

    def _getMainApp(self):
        return self.parent().parent().getMainApp()

    def _showWorkspaceProperties(self, item):
        if item.object is not None:
            d = WorkspacePropertiesDialog(self, "Workspace Properties", workspace=item.object)
            d.exec_loop()

########NEW FILE########
__FILENAME__ = main
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import sys
import os
# XXX: review this!!! it is not correct to hardcode the path this way!!
# python version might not be correct...
if (sys.platform == "darwin"):
    print "[+] Forcing path for %s" % sys.platform
    sys.path.append("/System/Library/Frameworks/Python.framework/Versions/2.6/lib/python2.6/site-packages/")
# XXX: optparse has been deprected
# import optparse
import argparse

from config.configuration import getInstanceConfiguration
from model.application import MainApplication

try:
    from utils.profilehooks import profile
except ImportError:
    # if profile module is not installed we use a dummy to avoid errors
    def profile(fn, *args, **kwargs):
        return fn
# XXX: force Python to search modules in the current directory first
sys.path.insert(0, os.path.dirname(__file__))


def checkDependencies():
    """
    before starting checks that all is needed is installed
    """
    # TODO: implement this!
    # if not os.path.exists("/bin/bash"):
    #     print "/bin/bash not present in the system!"
    #     return False
    return True


def setupOptions(parser):
    #TODO: we have to define all options supported
    parser.add_argument('-n', '--hostname', action="store", dest="host", default=False, help="Sets the hostname where api XMLRPCServe will listen. Default = localhost")
    parser.add_argument('-p', '--port', action="store", dest="port", default=9876, help="Sets the port where api XMLRPCServer will listen. Default = 9876")
    parser.add_argument('-d', '--debug', action="store_true", dest="debug", default=False, help="Enables debug mode. Default = disabled")
    parser.add_argument('--profile', action="store_true", dest="profile", default=False, help="Enables application profiling. When this option is used --profile-output and --profile-depth can also be used. Default = disabled")
    parser.add_argument('--profile-output', action="store", dest="profile_output", default=None, help="Sets the profile output filename. If no value is provided, standard output will be used")
    parser.add_argument('--profile-depth', action="store", dest="profile_depth", default=500, help="Sets the profile number of entries (depth). Default = 500")
    parser.add_argument('--disable-excepthook', action="store_true", dest="disableexcepthook", default=False, help="Disable the application Exception hook that allows to send error reports to developers.")
    parser.add_argument('--disable-login', action="store_true", dest="disablelogin", default=False, help="Disable the auth splash screen.")
    parser.add_argument('--gui', action="store", dest="gui", default="qt3", help="Disable the gui and use your own shell")


def main(args):

    parser = argparse.ArgumentParser()
    setupOptions(parser)
    args = parser.parse_args(args[1:])

    # TODO: make all the necessary things to handle each option entered...
    if checkDependencies():

        CONF = getInstanceConfiguration()

        CONF.setDebugStatus(False)
        if args.debug:
            CONF.setDebugStatus(True)

        if args.host and args.port:
            CONF.setApiConInfo(args.host, int(args.port))
            print "[+] setting api_conn_info = ", CONF.getApiConInfo()

        main_app = MainApplication(args)

        if args.disablelogin:
            CONF.setAuth(False)

        if not args.disableexcepthook:
            main_app.enableExceptHook()

        # something interesting to do when profiling is mixing
        # the cProfile output with kcachegrind like this:
        # http://stackoverflow.com/questions/1896032/using-cprofile-results-with-kcachegrind
        if args.profile:
            print "%s will be started with a profiler\
                attached. Performance may be affected." % CONF.getAppname()
            start = profile(main_app.start,
                            filename=args.profile_output,
                            entries=int(args.profile_depth))
        else:
            start = main_app.start

        exit_status = start()

        #os._exit(exit_status)
    else:
        print "%s cannot start!\nDependecies are not met." % CONF.getAppname()


if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
__FILENAME__ = all
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from utils.logs import getLogger
from utils.decorators import trap_timeout
from config.configuration import getInstanceConfiguration
import threading
import traceback
from urlparse import urlparse
from couchdbkit import Server, ChangesStream, Database, designer
from couchdbkit.resource import ResourceNotFound
import time
import os
import sys
import re
import imp
import plugins.core 
import mockito
import shutil
import json
from model.common import ModelObject

CONF = getInstanceConfiguration()


class CommandManager(object):
    """ A Command Persistence Manager """
    def __init__(self): 
        self._manager = PersistenceManagerFactory.getInstance()

    def saveCommand(self, command_info, workspace):
        self._manager = workspace._dmanager
        return self._manager.saveDocument(command_info.workspace,
                    command_info.toDict())

class PersistenceManagerFactory(object):
    """Creates PersistenceManager
    if CouchDB Available returns a couchdb manager
    otherwise FBManager"""
    instance = None
    def __init__(self):
        pass

    @staticmethod
    def getInstance():
        if PersistenceManagerFactory.instance: 
            return PersistenceManagerFactory.instance
        persistence_manager = CouchdbManager(uri = CONF.getCouchURI()) 
        PersistenceManagerFactory.instance = persistence_manager
        if persistence_manager.isAvailable():
            PersistenceManagerFactory.instance = persistence_manager
            return persistence_manager

    @staticmethod
    def setInstance(manager):
        PersistenceManagerFactory.instance = manager 

class PersistenceManager(object):
    def waitForDBChange(self, db_name, since = 0, timeout = 15000):
        time.sleep(timeout)
        return False

    def saveDocument(self, aWorkspaceName, aDocument):
        raise NotImplementedError('Implement in subclass')

class FSManager(PersistenceManager):
    """ This is a file system manager for the workspace, it will load from the provided FS"""
    def __init__(self, path):
        self._path = path
        if not os.path.exists(self._path):
            os.mkdir(self._path)

    def removeWorkspace(self, name):
        shutil.rmtree(os.path.join(self._path))

    def removeObject(self, obj_id):
        path = os.path.join(self._path, "%s.json" % obj_id)
        if os.path.isfile(path):
            os.remove(path)

    def saveDocument(self, aWorkspaceName, aDocumentDict):
        pass 


class NoCouchDBError(Exception): pass

class NoConectionServer(object):
    """ Default to this server if no conectivity"""
    def create_db(*args): pass
    def all_dbs(*args, **kwargs): return []
    def get_db(*args): 
        db_mock = mockito.mock(Database)
        mockito.when(db_mock).documents().thenReturn([])
        return db_mock
    def replicate(*args, **kwargs): pass
    def delete_db(*args): pass


class CouchdbManager(PersistenceManager):
    """ This is a couchdb manager for the workspace, it will load from the 
    couchdb databases"""
    def __init__(self, uri):
        self._last_seq_ack = 0
        getLogger(self).debug("Initializing CouchDBManager for url [%s]" % uri)
        self._lostConnection = False
        self.__uri = uri
        self.__dbs = {} 
        self.__seq_nums = {}
        self.__serv = NoConectionServer()
        self.mutex = threading.Lock()
        self._available = False

        #setting the doc types to load from couch
        def get_types(subclasses):
            if len(subclasses):
                head = subclasses[0]
                tail = []
                if len(subclasses[1:]):
                    tail = subclasses[1:]
                return get_types(head.__subclasses__()) + [head.class_signature] + get_types(tail)
            return []
        self._model_object_types = get_types([ModelObject])
        try:
            self.testCouchUrl(uri)
            url=urlparse(uri)
            getLogger(self).debug("Setting user,pass %s %s" % (url.username, url.password))
            self.__serv = Server(uri = uri)
            #print dir(self.__serv)
            self.__serv.resource_class.credentials = (url.username, url.password)
            self._available = True
        except:
            getLogger(self).warn("No route to couchdb server on: %s" % uri)
            getLogger(self).debug(traceback.format_exc())

    def isAvailable(self):
        return self._available

    def lostConnectionResolv(self): 
        self._lostConnection = True
        self.__dbs.clear()
        self.__serv = NoConectionServer()

    def reconnect(self):
        ret_val = False
        ur = self.__uri
        if CouchdbManager.testCouch(ur):
            self.__serv = Server(uri = ur)
            self.__dbs.clear()
            self._lostConnection = False
            ret_val = True

        return ret_val



    @staticmethod
    def testCouch(uri):
        host, port = None, None
        try:
            import socket
            url=urlparse(uri)
            proto = url.scheme
            host=url.hostname
            port=url.port

            port = port if port else socket.getservbyname(proto)
            s = socket.socket()
            s.settimeout(1)
            s.connect((host, int(port)))
        except:
            return False
        getLogger(CouchdbManager).info("Connecting Couch to: %s:%s" % (host, port))
        return True



    def testCouchUrl(self, uri):
        url=urlparse(uri)
        proto = url.scheme
        host=url.hostname
        port=url.port        
        self.test(host, int(port))

    def test(self, address, port):
        import socket
        s = socket.socket()
        s.settimeout(1)
        s.connect((address, port))


    @trap_timeout
    def getWorkspacesNames(self):
        return filter(lambda x: not x.startswith("_"), self.__serv.all_dbs())

    def workspaceExists(self, name):
        return name in self.getWorkspacesNames()


    @trap_timeout
    def addWorkspace(self, aWorkspace):
        self.__serv.create_db(aWorkspace.lower())
        return self._getDb(aWorkspace)

    @trap_timeout
    def addDocument(self, aWorkspaceName, documentId, aDocument):
        self._getDb(aWorkspaceName)
        self.incrementSeqNumber(aWorkspaceName)
        self._getDb(aWorkspaceName)[documentId] = aDocument

    @trap_timeout
    def saveDocument(self, aWorkspaceName, aDocument):
        self.incrementSeqNumber(aWorkspaceName)
        getLogger(self).debug("Saving document in remote workspace %s" % aWorkspaceName)
        return self._getDb(aWorkspaceName).save_doc(aDocument, use_uuids = True, force_update = True)

    def _getDb(self, aWorkspaceName):
        if not self.__dbs.has_key(aWorkspaceName):
            self.__getDb(aWorkspaceName)
        return self.__dbs.get(aWorkspaceName, None)

    @trap_timeout
    def __getDb(self, aWorkspaceName): 
        aWorkspaceName = aWorkspaceName.lower()
        getLogger(self).debug("Getting workspace [%s]" % aWorkspaceName)
        workspacedb = self.__dbs.get(aWorkspaceName, self.__serv.get_db(aWorkspaceName))
        if not self.__dbs.has_key(aWorkspaceName): 
            getLogger(self).debug("Asking couchdb for workspace [%s]" % aWorkspaceName)
            self.__dbs[aWorkspaceName] = workspacedb
            self.__seq_nums[aWorkspaceName] = workspacedb.info()['update_seq'] 


        return workspacedb

    @trap_timeout
    def getDocument(self, aWorkspaceName, documentId):
        getLogger(self).debug("Getting document for workspace [%s]" % aWorkspaceName)
        return self._getDb(aWorkspaceName).get(documentId)

    @trap_timeout
    def checkDocument(self, aWorkspaceName, documentName):
        return  self._getDb(aWorkspaceName).doc_exist(documentName)


    @trap_timeout
    def replicate(self, workspace, *targets_dbs, **kwargs):
        getLogger(self).debug("Targets to replicate %s" % str(targets_dbs))
        for target_db in targets_dbs:
            src_db_path = "/".join([self.__uri, workspace])
            dst_db_path = "/".join([target_db, workspace])
            try:
                getLogger(self).info("workspace: %s, src_db_path: %s, dst_db_path: %s, **kwargs: %s" % (workspace, src_db_path, dst_db_path, kwargs))
                self.__peerReplication(workspace, src_db_path, dst_db_path, **kwargs)
            except ResourceNotFound as e:
                raise e
            except Exception as e:
                getLogger(self).error(e)
                raise 

    def __peerReplication(self, workspace, src, dst, **kwargs):
        mutual = kwargs.get("mutual", True)
        continuous = kwargs.get("continuous", True)
        ct = kwargs.get("create_target", True)

        self.__serv.replicate(workspace, dst, mutual = mutual, continuous  = continuous, create_target = ct)
        if mutual:
            self.__serv.replicate(dst, src, continuous = continuous, **kwargs)


    def getLastChangeSeq(self, workspaceName):
        self.mutex.acquire()
        seq = self.__seq_nums[workspaceName]
        self.mutex.release()
        return seq

    def setLastChangeSeq(self, workspaceName, seq_num):
        self.mutex.acquire()
        self.__seq_nums[workspaceName] = seq_num
        self.mutex.release()


    @trap_timeout
    def waitForDBChange(self, db_name, since = 0, timeout = 15000):
        """ Be warned this will return after the database has a change, if
        there was one before call it will return immediatly with the changes
        done"""
        changes = []
        last_seq = max(self.getLastChangeSeq(db_name), since)
        db = self._getDb(db_name)
        with ChangesStream(db, feed="longpoll", since = last_seq, timeout = timeout) as stream:
            for change in stream:
                if change['seq'] > self.getLastChangeSeq(db_name):
                    self.setLastChangeSeq(db_name, change['seq'])
                    if not change['id'].startswith('_design'):
                        changes.append(change)
            #last_seq = reduce(lambda x,y:  max(y['seq'], x) , changes, self.getLastChangeSeq(db_name))
            #self.setLastChangeSeq(db_name, last_seq)
        if len(changes):
            getLogger(self).debug("Changes from another instance")
        return changes

    @trap_timeout
    def delete_all_dbs(self):
        for db in self.__serv.all_dbs():
            self.__serv.delete_db(db)

    @trap_timeout
    def existWorkspace(self, name):
        return name in self.__serv.all_dbs()

    @trap_timeout
    def workspaceDocumentsIterator(self, workspaceName): 
        return filter(self.filterConditions, self._getDb(workspaceName).documents(include_docs=True))

    def filterConditions(self, doc):
        ret = True
        ret = ret and not doc["id"].startswith("_")
        ret = ret and doc['doc']["type"] in self._model_object_types

        return ret

    @trap_timeout
    def removeWorkspace(self, workspace_name):
        return self.__serv.delete_db(workspace_name)

    @trap_timeout
    def remove(self, workspace, host_id):
        self.incrementSeqNumber(workspace)
        self.__dbs[workspace].delete_doc(host_id)

    @trap_timeout
    def compactDatabase(self, aWorkspaceName):
        self._getDb(aWorkspaceName).compact()

    def pushReports(self):
        vmanager = ViewsManager()
        reports = os.path.join(os.getcwd(), "views", "reports")
        workspace = self.__serv.get_or_create_db("reports") 
        vmanager.addView(reports, workspace)
        return self.__uri + "/reports/_design/reports/index.html"


    def addViews(self, workspaceName):
        vmanager = ViewsManager()
        workspace = self._getDb(workspaceName)
        for v in vmanager.getAvailableViews():
            vmanager.addView(v, workspace)

    def getViews(self, workspaceName):
        vmanager = ViewsManager()
        workspace = self._getDb(workspaceName)
        return vmanager.getViews(workspace)

    def syncWorkspaceViews(self, workspaceName):
        vmanager = ViewsManager()
        workspace = self._getDb(workspaceName) 
        installed_views = vmanager.getViews(workspace)
        for v in vmanager.getAvailableViews():
            if v not in installed_views: 
                vmanager.addView(v, workspace)

    def incrementSeqNumber(self, workspaceName):
        self.mutex.acquire()
        if not self.__seq_nums.has_key(workspaceName):
            self.__seq_nums[workspaceName] = 0
        self.__seq_nums[workspaceName] += 1 
        self.mutex.release()

class ViewsManager(object):
    """docstring for ViewsWrapper"""
                           
                                        
    def __init__(self):
        self.vw = ViewsListObject()

             
    def addView(self, design_doc, workspaceDB):
        designer.push(design_doc, workspaceDB, atomic = False)

    def addViewForFS(self, design_doc, workspaceDB):
        designer.fs.push(design_doc, workspaceDB, encode_attachments = False)


    def getAvailableViews(self):
        return self.vw.get_all_views()

    def getViews(self, workspaceDB):
        views = {}
        result = workspaceDB.all_docs(startkey='_design', endkey='_design0')
        if result:
            for doc in result.all():
                designdoc = workspaceDB.get(doc['id'])
                views.update(designdoc.get("views", []))
        return views

class ViewsListObject(object):
    """ Representation of the FS Views """
    def __init__(self):
        self.views_path = os.path.join(os.getcwd(), "views")
        self.designs_path = os.path.join(self.views_path, "_design") 

    def _listPath(self, path):
        flist = filter(lambda x: not x.startswith('.'), os.listdir(path))
        return map(lambda x: os.path.join(path, x), flist)

    def get_fs_designs(self):
        return self._listPath(self.designs_path)

    def get_all_views(self):
        return self.get_fs_designs()

class PluginManager(object):
    def __init__(self, plugin_repo_path):
        self._controllers = {}                                         
        self._plugin_modules = {}                                        
        self._loadPlugins(plugin_repo_path)

        self._plugin_settings = {}
        self._loadSettings()

    def createController(self, id):
        """
        Creates a new plugin controller and adds it into the controllers list.
        """
        plugs = self._instancePlugins()
        new_controller = plugins.core.PluginController(id, plugs, CommandManager())
        self._controllers[new_controller.id] = new_controller
        return new_controller

    def _loadSettings(self):
        _plugin_settings=CONF.getPluginSettings()
        if _plugin_settings:
                                          
            self._plugin_settings=_plugin_settings
        
        activep=self._instancePlugins()
        for plugin_id, plugin in activep.iteritems():
                                            
            if not plugin_id in _plugin_settings:
                self._plugin_settings[plugin_id] = {
                                        "name": plugin.name,
                                        "description": plugin.description,
                                        "version": plugin.version,
                                        "plugin_version": plugin.plugin_version,
                                        "settings": dict(plugin.getSettings())
                                                  }
                                           
        dplugins=[]
        for k,v in self._plugin_settings.iteritems():
            if not k in activep:
                dplugins.append(k)
        
        for d in dplugins:
            del self._plugin_settings[d]
        
                           
        CONF.setPluginSettings(self._plugin_settings)
        CONF.saveConfig()

    def getSettings(self):
        return self._plugin_settings

    def updateSettings(self, settings):
        self._plugin_settings = settings
        CONF.setPluginSettings(settings)
        CONF.saveConfig()
        for plugin_id, params in settings.iteritems():
            new_settings = params["settings"]
            for c_id, c_instance in self._controllers.iteritems():
                c_instance.updatePluginSettings(plugin_id, new_settings)

    def _instancePlugins(self):
        plugins = {}
        for module in self._plugin_modules.itervalues():
            new_plugin = module.createPlugin()
            self._verifyPlugin(new_plugin)
            plugins[new_plugin.id] = new_plugin
        return plugins

    def _loadPlugins(self, plugin_repo_path):
        """
        Finds and load all the plugins that are available in the plugin_repo_path.
        """
        try:
            os.stat(plugin_repo_path)
        except OSError:
                                 
            pass
        
        sys.path.append(plugin_repo_path)

        dir_name_regexp = re.compile(r"^[\d\w\-\_]+$")
        for name in os.listdir(plugin_repo_path):
            if dir_name_regexp.match(name):
                try:
                    module_path = os.path.join(plugin_repo_path, name)
                    sys.path.append(module_path)
                    module_filename = os.path.join(module_path, "plugin.py")
                    self._plugin_modules[name] = imp.load_source(name, module_filename)
                except Exception:
                    msg = "An error ocurred while loading plugin %s.\n%s" % (module_filename, traceback.format_exc())
                    getLogger(self).error(msg)
            else:
                pass

    def getPlugins(self):
        return self._instancePlugins()
                                                 

    def _updatePluginSettings(self, new_plugin_id):
        pass

    def _verifyPlugin(self, new_plugin):
        """ Generic method that decides is a plugin is valid
            based on a predefined set of checks. """
        try:
            assert(new_plugin.id is not None)
            assert(new_plugin.version is not None)
            assert(new_plugin.name is not None)
            assert(new_plugin.framework_version is not None)
        except (AssertionError,KeyError):
                                           
            return False
        return True

########NEW FILE########
__FILENAME__ = api
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import os
import zipfile

import model.common
from config.configuration import getInstanceConfiguration
#from workspace import Workspace
import model.log
from utils.common import *
import shutil
#from plugins.api import PluginControllerAPI

CONF = getInstanceConfiguration()

# global reference only for this module to work with the model controller
__model_controller = None


_xmlrpc_api_server = None
_plugin_controller_api = None

#XXX: temp way to replicate info
_remote_servers_proxy = []

_remote_sync_server_proxy = None

# name of the currently logged user
__current_logged_user = ""


def setUpAPIs(controller, hostname=None, port=None):
    global __model_controller
    __model_controller = controller
    _setUpAPIServer(hostname, port)


def startAPIServer():
    global _xmlrpc_api_server
    if _xmlrpc_api_server is not None:
        devlog("starting xmlrpc api server...")
        #_xmlrpc_api_server.serve_forever()
        _xmlrpc_api_server.start()


def stopAPIServer():
    global _xmlrpc_api_server
    if _xmlrpc_api_server is not None:
        _xmlrpc_api_server.stop_server()
        devlog("called stop on xmlrpc server")
        _xmlrpc_api_server.join()
        devlog("xmlrpc thread joined")


def _setUpAPIServer(hostname=None, port=None):
    global _xmlrpc_api_server
    global api_conn_info
    if _xmlrpc_api_server is None:
        #TODO: some way to get defaults.. from config?
        if str(hostname) == "None":
            hostname = "localhost"
        if str(port) == "None":
            port = 9876

        if CONF.getApiConInfo() is None:
            CONF.setApiConInfo(hostname, port)
        devlog("starting XMLRPCServer with api_conn_info = %s" % str(CONF.getApiConInfo()))
        try:
            _xmlrpc_api_server = model.common.XMLRPCServer(CONF.getApiConInfo())
            # Registers the XML-RPC introspection functions system.listMethods, system.methodHelp and system.methodSignature.
            _xmlrpc_api_server.register_introspection_functions()

            # register a function to nicely stop server
            _xmlrpc_api_server.register_function(_xmlrpc_api_server.stop_server)

            # register all the api functions to be exposed by the server
            _xmlrpc_api_server.register_function(createAndAddHost)
            _xmlrpc_api_server.register_function(createAndAddInterface)
            _xmlrpc_api_server.register_function(createAndAddServiceToApplication)
            _xmlrpc_api_server.register_function(createAndAddServiceToInterface)
            _xmlrpc_api_server.register_function(createAndAddApplication)
            _xmlrpc_api_server.register_function(createAndAddNoteToService)
            _xmlrpc_api_server.register_function(createAndAddNoteToHost)            
            _xmlrpc_api_server.register_function(createAndAddNoteToNote)
            _xmlrpc_api_server.register_function(createAndAddVulnWebToService)
            _xmlrpc_api_server.register_function(createAndAddVulnToHost)
            _xmlrpc_api_server.register_function(addHost)
            _xmlrpc_api_server.register_function(addInterface)
            _xmlrpc_api_server.register_function(addServiceToApplication)
            _xmlrpc_api_server.register_function(addServiceToInterface)
            _xmlrpc_api_server.register_function(addApplication)
            _xmlrpc_api_server.register_function(newHost)
            _xmlrpc_api_server.register_function(newInterface)
            _xmlrpc_api_server.register_function(newService)
            _xmlrpc_api_server.register_function(newApplication)
            _xmlrpc_api_server.register_function(devlog)

            #TODO: check if all necessary APIs are registered here!!

            devlog("XMLRPC API server configured...")
        except Exception, e:
            msg = "There was an error creating the XMLRPC API Server:\n%s" % str(e)
            log(msg)
            devlog("[ERROR] - %s" % msg)


#-------------------------------------------------------------------------------
# APIs to create and add elements to model
#-------------------------------------------------------------------------------

#TODO: create a decorator to find the caller of an api to try to determine which
# plugin created the object


def createAndAddHost(name, os = "Unknown", category=None, update = False, old_hostname = None ):
    host = newHost(name, os)
    if addHost(host, category, update, old_hostname):
        return host.getID()
    return None

def createAndAddInterface(host_id, name = "", mac = "00:00:00:00:00:00",
                 ipv4_address = "0.0.0.0", ipv4_mask = "0.0.0.0",
                 ipv4_gateway = "0.0.0.0", ipv4_dns = [],
                 ipv6_address = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_prefix = "00",
                 ipv6_gateway = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_dns = [],
                 network_segment = "", hostname_resolution = []):
    """
    Creates a new interface object with the parameters provided and adds it to
    the host selected.
    If interface is successfuly created and the host exists, it returns the inteface id
    It returns None otherwise
    """
    interface = newInterface(name, mac, ipv4_address, ipv4_mask, ipv4_gateway,
                             ipv4_dns,ipv6_address,ipv6_prefix,ipv6_gateway,ipv6_dns,
                             network_segment, hostname_resolution)
    if addInterface(host_id, interface):
        return interface.getID()
    return None

def createAndAddApplication(host_id, name, status = "running", version = "unknown"):
    application = newApplication(name, status, version)
    if addApplication(host_id, application):
        return application.getID()
    return None

def createAndAddServiceToApplication(host_id, application_id, name, protocol = "tcp?", 
                ports = [], status = "running", version = "unknown", description = ""):
    service = newService(name, protocol, ports, status, version, description)
    if addServiceToApplication(host_id, application_id, service):
        return service.getID()
    return None

def createAndAddServiceToInterface(host_id, interface_id, name, protocol = "tcp?", 
                ports = [], status = "running", version = "unknown", description = ""):
    service = newService(name, protocol, ports, status, version, description)
    if addServiceToInterface(host_id, interface_id, service):
        return service.getID()
    return None

# Vulnerability

def createAndAddVulnToHost(host_id, name, desc, ref, severity):
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToHost(host_id, vuln):
        return vuln.getID()
    return None

def createAndAddVulnToInterface(host_id, interface_id, name, desc, ref, severity):
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToInterface(host_id, interface_id, vuln):
        return vuln.getID()
    return None
    
def createAndAddVulnToApplication(host_id, application_id, name, desc, ref, severity):
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToApplication(host_id, application_id, vuln):
        return vuln.getID()
    return None

def createAndAddVulnToService(host_id, service_id, name, desc, ref, severity):
    #we should give the interface_id or de application_id too? I think we should...
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToService(host_id, service_id, vuln):
        return vuln.getID()
    return None

#WebVuln

def createAndAddVulnWebToService(host_id, service_id, name, desc, ref, severity, website, path, request, response,
                method,pname, params,query,category):
    #we should give the interface_id or de application_id too? I think we should...
    vuln = newVulnWeb(name, desc, ref, severity, website, path, request, response,
                method,pname, params,query,category)
    if addVulnWebToService(host_id, service_id, vuln):
        return vuln.getID()
    return None

# Note
 
def createAndAddNoteToHost(host_id, name, text):
    note = newNote(name, text)
    if addNoteToHost(host_id, note):
        return note.getID()
    return None

def createAndAddNoteToInterface(host_id, interface_id, name, text):
    note = newNote(name, text)
    if addNoteToInterface(host_id, interface_id, note):
        return note.getID()
    return None

def createAndAddNoteToApplication(host_id, application_id, name, text):
    note = newNote(text)
    if addNoteToApplication(host_id, application_id, note):
        return note.getID()
    return None

def createAndAddNoteToService(host_id, service_id, name, text):
    note = newNote(name, text)
    if addNoteToService(host_id, service_id, note):
        return note.getID()
    return None

def createAndAddNoteToNote(host_id, service_id, note_id, name, text):
    note = newNote(name, text)
    if addNoteToNote(host_id, service_id, note_id, note):
        return note.getID()
    return None

def createAndAddCredToService(host_id, service_id, username, password):
    cred = newCred(username, password)
    if addCredToService(host_id, service_id, cred):
        return cred.getID()
    return None

#-------------------------------------------------------------------------------
# APIs to add already created objets to the model
#-------------------------------------------------------------------------------

#TODO: add class check to object passed to be sure we are adding the right thing to the model

def addHost(host, category=None, update = False, old_hostname = None):
    if host is not None:
        __model_controller.addHostASYNC(host, category, update, old_hostname)
        return True
    return False

def addInterface(host_id, interface):
    if interface is not None:
        __model_controller.addInterfaceASYNC(host_id, interface)
        return True
    return False

def addApplication(host_id, application):
    if application is not None:
        __model_controller.addApplicationASYNC(host_id, application)
        return True
    return False

def addServiceToApplication(host_id, application_id, service):
    if service is not None:
        __model_controller.addServiceToApplicationASYNC(host_id, application_id, service)
        return True
    return False

def addServiceToInterface(host_id, interface_id, service):
    if service is not None:
        __model_controller.addServiceToInterfaceASYNC(host_id, interface_id, service)
        return True
    return False

# Vulnerability

def addVulnToHost(host_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToHostASYNC(host_id, vuln)
        return True
    return False

def addVulnToInterface(host_id, interface_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToInterfaceASYNC(host_id, interface_id, vuln)
        return True
    return False

def addVulnToApplication(host_id, application_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToApplicationASYNC(host_id, application_id, vuln)
        return True
    return False

def addVulnToService(host_id, service_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToServiceASYNC(host_id, service_id, vuln)
        return True
    return False

#VulnWeb
def addVulnWebToService(host_id, service_id, vuln):
    if vuln is not None:
        __model_controller.addVulnWebToServiceASYNC(host_id, service_id, vuln)
        return True
    return False



# Notes




def addNoteToHost(host_id, note):
    if note is not None:
        __model_controller.addNoteToHostASYNC(host_id, note)
        return True
    return False

def addNoteToInterface(host_id, interface_id, note):
    if note is not None:
        __model_controller.addNoteToInterfaceASYNC(host_id, interface_id, note)
        return True
    return False

def addNoteToApplication(host_id, application_id, note):
    if note is not None:
        __model_controller.addNoteToApplicationASYNC(host_id, application_id, note)
        return True
    return False

def addNoteToService(host_id, service_id, note):
    if note is not None:
        __model_controller.addNoteToServiceASYNC(host_id, service_id, note)
        return True
    return False

def addNoteToNote(host_id, service_id, note_id, note):
    if note is not None:
        __model_controller.addNoteToNoteASYNC(host_id, service_id, note_id, note)
        return True
    return False

def addCredToService(host_id, service_id, cred):
    if cred is not None:
        __model_controller.addCredToServiceASYNC(host_id, service_id, cred)
        return True
    return False

#-------------------------------------------------------------------------------
# APIs to delete elements to model
#-------------------------------------------------------------------------------
#TODO: delete funcitons are still missing
def delHost(hostname):
    __model_controller.delHostASYNC(hostname)
    return True

def delApplication(hostname,appname):
    __model_controller.delApplicationASYNC(hostname,appname)
    return True

def delInterface(hostname,intname):
    __model_controller.delInterfaceASYNC(hostname,intname)
    return True

def delServiceFromHost(hostname, service):
    __model_controller.delServiceFromHostASYNC(hostname, service)
    return True

def delServiceFromInterface(hostname, intname, service, remote = True):
    __model_controller.delServiceFromInterfaceASYNC(hostname,intname,service)
    return True

def delServiceFromApplication(hostname, appname, service):
    __model_controller.delServiceFromApplicationASYNC(hostname,appname,service)
    return True

# Vulnerability
#-------------------------------------------------------------------------------
def delVulnFromApplication(vuln, hostname, appname):
    __model_controller.delVulnFromApplicationASYNC(hostname, appname, vuln)
    return True
#-------------------------------------------------------------------------------
def delVulnFromInterface(vuln, hostname, intname):
    __model_controller.delVulnFromInterfaceASYNC(hostname,intname, vuln)
    return True
#-------------------------------------------------------------------------------
def delVulnFromHost(vuln, hostname):
    __model_controller.delVulnFromHostASYNC(hostname,vuln)
    return True

#-------------------------------------------------------------------------------
def delVulnFromService(vuln, hostname, srvname):
    __model_controller.delVulnFromServiceASYNC(hostname,srvname, vuln)
    return True

# Notes
#-------------------------------------------------------------------------------
def delNoteFromApplication(note, hostname, appname):
    __model_controller.delNoteFromApplicationASYNC(hostname, appname, note)
    return True
#-------------------------------------------------------------------------------
def delNoteFromInterface(note, hostname, intname):
    __model_controller.delNoteFromInterfaceASYNC(hostname,intname, note)
    return True
#-------------------------------------------------------------------------------
def delNoteFromHost(note, hostname):
    __model_controller.delNoteFromHostASYNC(hostname, note)
    return True

#-------------------------------------------------------------------------------
def delNoteFromService(note, hostname, srvname):
    __model_controller.delNoteFromServiceASYNC(hostname,srvname, note)
    return True

#-------------------------------------------------------------------------------
def delCredFromService(cred, hostname, srvname):
    __model_controller.delCredFromServiceASYNC(hostname,srvname, cred)
    return True

#-------------------------------------------------------------------------------
# CREATION APIS
#-------------------------------------------------------------------------------
def newHost(name, os = "Unknown"):
    """
    It creates and returns a Host object.
    The object created is not added to the model.
    """
    # 'Host' is a class signature if that is changed we have to update this
    return model.common.factory.createModelObject("Host", name, os=os)

#-------------------------------------------------------------------------------
def newInterface(name = "", mac = "00:00:00:00:00:00",
                 ipv4_address = "0.0.0.0", ipv4_mask = "0.0.0.0",
                 ipv4_gateway = "0.0.0.0", ipv4_dns = [],
                 ipv6_address = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_prefix = "00",
                 ipv6_gateway = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_dns = [],
                 network_segment = "", hostname_resolution = []):
    """
    It creates and returns an Interface object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Interface", name, mac = mac,
                 ipv4_address = ipv4_address , ipv4_mask = ipv4_mask,
                 ipv4_gateway = ipv4_gateway, ipv4_dns = ipv4_dns,
                 ipv6_address = ipv6_address , ipv6_prefix = ipv6_prefix,
                 ipv6_gateway = ipv6_gateway, ipv6_dns = ipv6_dns,
                 network_segment = network_segment,
                 hostname_resolution = hostname_resolution)
#-------------------------------------------------------------------------------
def newService(name, protocol = "tcp?", ports = [], status = "running",
               version = "unknown", description = ""):
    """
    It creates and returns a Service object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Service",name,
                    protocol = protocol, ports = ports, status = status,
                    version = version, description = description)
#-------------------------------------------------------------------------------

def newVuln(name, desc="", ref = None, severity=""):
    """
    It creates and returns a Vulnerability object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Vulnerability", name, desc=desc,
                                                  ref=ref, severity=severity)
 
#-------------------------------------------------------------------------------

def newVulnWeb(name, desc="", ref = None, severity="", website="", path="", request="", response="",
                method="",pname="", params="",query="",category=""):
    """
    It creates and returns a Vulnerability object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("VulnerabilityWeb", name, desc=desc, ref=ref,severity=severity, website=website, path=path, request=request,
                                                  response=response,method=method,pname=pname, params=params,query=query,category=category )
 
#-------------------------------------------------------------------------------
   
def newNote(name,text):
    
    """
    It creates and returns a Note object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Note", name, text=text)

def newCred(username,password):
    
    """
    It creates and returns a Cred object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Cred", username, password=password)


#-------------------------------------------------------------------------------
def newApplication(name, status = "running", version = "unknown"):
    """
    It creates and returns an Application object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("HostApplication",name,
                                                  status = status,
                                                  version = version)

#-------------------------------------------------------------------------------


#TODO: this api is used in the telnet plugin to get a host and change the
# name by adding a host with update flag in True.
# This may be risky because we are returning a reference to a host that
# could be deleted or changed while another plugin is using it
# A way to save this could be returning a copy of the object or
# implement dirty flag (or a lock) on the objects
def getHost(hostname):
    """
    THIS API WAS CREATED FOR DEMO WITH TELNET PLUGIN
    It is useful but risky using it like this
    """
    return __model_controller._getValueByID("_hosts", hostname)


#-------------------------------------------------------------------------------

#exportWorskpace

def exportWorskpace(workspace_path, export_path):
    """
    This api will create a zip file for the persistence directory
    """
    zip = zipfile.ZipFile(export_path, 'w', compression=zipfile.ZIP_DEFLATED)
    root_len = len(os.path.abspath(workspace_path))
    for root, dirs, files in os.walk(workspace_path):
        if ".svn" not in root:
            archive_root = os.path.abspath(root)[root_len:]
            if files is not ".svn":
                for f in files:
                    fullpath = os.path.join(root, f)
                    archive_name = os.path.join(archive_root, f)
#                        print f
                    zip.write(fullpath, archive_name, zipfile.ZIP_DEFLATED)
    zip.close()
    

def importWorskpace(workspace_path, file_path):
    """
    This api will import a zip file of the persistence directory.
    WARNING: this will overwrite any existing files!
    """
        
    archive = zipfile.ZipFile(str(file_path), "r", zipfile.ZIP_DEFLATED)
    names = archive.namelist()
    
    for name in names:
        filename = os.path.join(workspace_path, name)
        if not os.path.exists(os.path.dirname(filename)):
            os.mkdir(os.path.dirname(filename))
        # create the output file. This will overwrite any existing file with the same name
        temp = open(filename, "wb") 
        data = archive.read(name) # read data from zip archive
        temp.write(data)
        temp.close()
            
    archive.close()

#-------------------------------------------------------------------------------
# EVIDENCE
#-------------------------------------------------------------------------------
#TODO: refactor!! acomodar estos metodos para que no accedan a cosas directas del model_controller
def addEvidence(file_path):
    """
    Copy evidence file to the repository
    """
    filename=os.path.basename(file_path)
    ###: Ver de sacar ese nombre evidences del config
    
    dpath="%s/evidences/" % (__model_controller._persistence_dir)
    dpathfilename="%s%s" % (dpath,filename)
    
    #devlog("[addEvidence] File added ("+file_path+") destination path ("+dpathfilename+")")
    
    if os.path.isfile(dpathfilename):
        devlog("[addEvidence] - File evidence (" + dpathfilename +") exists abort adding")
    else:
        if not os.path.isdir(dpath):
            os.mkdir(dpath)
            
        shutil.copyfile(file_path,dpathfilename)
        if os.path.isfile(dpathfilename):
            #XXX: la idea es no acceder directamente a cosas privadas del model controller como esto de _check_evidences
            __model_controller._check_evidences.append(dpathfilename)
            return dpathfilename

    return False

def checkEvidence(file_path):
    """
    Copy evidence file to the repository
    """
    if not os.path.isfile(file_path):
        devlog("[addEvidence] - File evidence (" + dpathfilename +") doesnt exists abort adding")
    else:        
        __model_controller._check_evidences.append(file_path)
        return True

    return False

def cleanEvidence():
    """
    Copy evidence file to the repository
    """
    check_evidences=__model_controller._check_evidences
    #devlog("[cleanEvidence] check_evidence values=" + str(check_evidences))
    
    evidence_path="%s/evidences/" % (__model_controller._persistence_dir)
    for root, dirs, files in os.walk(evidence_path):
        for filename in files:
            if os.path.splitext(filename)[1].lower() == ".png":
                f=os.path.join(root, filename)
                if f in check_evidences:
                    devlog("[cleanEvidence] - The following file is in the evidence xml" + os.path.join(root, filename))
                else:
                    delEvidence(f)
            #__model_controller._check_evidences=[]
        return True

    return False

def delEvidence(file_path):
    """
    Add file_path to the queue to be delete from the svn and filesystem
    """
    if os.path.isfile(file_path):
        devlog("[addEvidence] - Adding file (" + file_path +") to the delete queue")
        __model_controller._deleted_evidences.append(file_path)
        return True
    else:
        devlog("[addEvidence] - File evidence (" + file_path +") doesnt exist abort deleting")

    return False

#-------------------------------------------------------------------------------
# MISC APIS
#-------------------------------------------------------------------------------
def log(msg ,level = "INFO"):
    """
    This api will log the text in the GUI console without the level
    it will also log to a file with the corresponding level
    if logger was configured that way
    """
    model.log.getLogger().log(msg,level)

def devlog(msg):
    """
    If DEBUG is set it will print information directly to stdout
    """
    if CONF.getDebugStatus():
        print "[DEBUG] - %s" % msg
        model.log.getLogger().log(msg,"DEBUG")

def showDialog(msg, level="Information"):
    return model.log.getNotifier().showDialog(msg, level)

def showPopup(msg, level="Information"):
    return model.log.getNotifier().showPopup(msg, level)

#-------------------------------------------------------------------------------
def getLoggedUser():
    """
    Returns the currently logged username
    """
    global __current_logged_user
    return __current_logged_user
#-------------------------------------------------------------------------------

#TODO: implement!!!!!
def getLocalDefaultGateway():    
    return gateway()

#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------

def getActiveWorkspace():
    return __model_controller.getWorkspace()

########NEW FILE########
__FILENAME__ = application
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import os
import sys
import signal

# TODO: no seria mejor activar todo ?
# XXX: something strange happens if we import
# this module at the bottom of the list....
from auth.manager import SecurityManager
from auth.manager import codes
from workspace import WorkspaceManager
#from shell.controller.env import ShellEnvironment
import model.controller
import model.api
import model.guiapi
import plugins.api
import model.log
from utils.logs import getLogger
import traceback
from managers.all import PluginManager

#from gui.qt3.mainwindow import MainWindow
from utils.error_report import exception_handler
from utils.error_report import installThreadExcepthook

#from gui.gui_app import FaradayUi
from gui.gui_app import UiFactory

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()


class MainApplication(object):
    """
    """

    def __init__(self, args):
        self._original_excepthook = sys.excepthook

        self._configuration = CONF

        self._security_manager = SecurityManager()

        self._model_controller = model.controller.ModelController(
            security_manager=self._security_manager)

        self._plugin_manager = PluginManager(os.path.join(CONF.getConfigPath(),
                                             "plugins"))

        self._workspace_manager = WorkspaceManager(self._model_controller,
                                                   self._plugin_manager.createController("ReportManager"))

        self.gui_app = UiFactory.create(self._model_controller,
                                        self._plugin_manager,
                                        self._workspace_manager,
                                        args.gui)

        self.gui_app.setSplashImage(os.path.join(
            CONF.getImagePath(), "splash2.png"))

        #self._splash_screen = qt.QSplashScreen(qt.QPixmap(os.path.join(CONF.getImagePath(),"splash2.png")),
        #                                       qt.Qt.WStyle_StaysOnTop)

    def enableExceptHook(self):
        sys.excepthook = exception_handler
        installThreadExcepthook()

    def disableLogin(self):
        CONF.setAuth(sys.disablelogin)

    def start(self):
        try:

            #splash_timer = qt.QTimer.singleShot(1700, lambda *args:None)
            #self._splash_screen.show()
            self.gui_app.startSplashScreen()

            signal.signal(signal.SIGINT, self.ctrlC)

            #self._writeSplashMessage("Setting up remote API's...")

            model.api.devlog("Starting application...")
            model.api.devlog("Setting up remote API's...")

            model.api.setUpAPIs(self._model_controller,
                                CONF.getApiConInfoHost(),
                                CONF.getApiConInfoPort())
            model.guiapi.setUpGUIAPIs(self._model_controller)

            #self._writeSplashMessage("Starting model controller daemon...")

            model.api.devlog("Starting model controller daemon...")
            self._model_controller.start()
            model.api.startAPIServer()
            plugins.api.startPluginControllerAPI(self._plugin_manager)

            #self._writeSplashMessage("Setting up main GUI...")

            #self._writeSplashMessage("Creating default shell...")

            #self._main_window.createShellTab()

            #self._writeSplashMessage("Ready...")
            #self.logger.log("Faraday ready...")
            model.api.devlog("Faraday ready...")

            self.gui_app.stopSplashScreen()
            #self._main_window.showAll()

            logged = True

            while True:

                username, password = "usuario", "password"

                if username is None and password is None:
                    break
                result = self._security_manager.authenticateUser(username, password)
                if result == codes.successfulLogin:
                    logged = True
                    break

            if logged:
                #self._main_window.showLoggedUser(self._security_manager.current_user.display_name)
                model.api.__current_logged_user = username

                self._workspace_manager.loadWorkspaces()

                last_workspace = CONF.getLastWorkspace()
                w = self._workspace_manager.createWorkspace(last_workspace)
                self._workspace_manager.setActiveWorkspace(w)

                self.gui_app.loadWorkspaces()

                self._workspace_manager.startReportManager()

        except Exception:

            print "There was an error while starting Faraday"
            print "-" * 50
            traceback.print_exc()
            print "-" * 50
            self.__exit(-1)

        if logged:
            exit_code = self.gui_app.run([])
            #exit_code = self.app.exec_loop()
        else:
            exit_code = -1

        return self.__exit(exit_code)

    def __exit(self, exit_code=0):
        """
        Exits the application with the provided code.
        It also waits until all app threads end.
        """
        self._workspace_manager.stopAutoLoader()
        self._workspace_manager.stopReportManager()
        #self._main_window.hide()
        model.api.devlog("Closing Faraday...")
        self._workspace_manager.saveWorkspaces()
        model.api.devlog("stopping model controller thread...")
        self._model_controller.stop()
        model.api.devlog("stopping model controller thread...")
        self.gui_app.quit()
        model.api.devlog("Waiting for controller threads to end...")
        self._model_controller.join()
        model.api.stopAPIServer()
        plugins.api.stopServer()

        return exit_code

    def quit(self):
        """
        Redefined quit handler to nicely end up things
        """

        self.gui_app.quit()

    def ctrlC(self, signal, frame):
        getLogger(self).info("Exiting...")
        self.__exit(exit_code=0)

    def getWorkspaceManager(self):
        return self._workspace_manager

    # def _writeSplashMessage(self, text):
    #     self._splash_screen.message(text, qt.Qt.AlignRight | qt.Qt.AlignTop, qt.Qt.red)

########NEW FILE########
__FILENAME__ = commands_history
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

class CommandRunInformation(object):
    """Command Run information object containing:
        command, parameters, time, workspace, etc."""

    def __init__(self, **kwargs):
        self.type = self.__class__.__name__
        for k, v in kwargs.items():
            setattr(self, k, v)

    def toDict(self):
        return self.__dict__

    def fromDict(self, dictt):
        for k, v in dictt.items():
            setattr(self, k, v)
        return self

########NEW FILE########
__FILENAME__ = common
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
"""
Contains base classes used to represent the application model
and some other common objects and functions used in the model
"""
import sys
import os
import traceback
import threading
import SimpleXMLRPCServer
import xmlrpclib
from utils.decorators import updateLocalMetadata, save, delete
import json
import model
from conflict import ConflictUpdate
from model.diff import ModelObjectDiff

try:
    import model.api as api
except AttributeError:
    import api
from utils.common import *

#----------- Metadata history for timeline support, prob. we should move this out model common

from time import time
import cPickle as pickle
from config.configuration import getInstanceConfiguration

class MetadataUpdateActions(object):
    """Constants for the actions made on the update"""
    UNDEFINED   = -1
    CREATE      = 0
    UPDATE      = 1

class Metadata(object):
    """To save information about the modification of ModelObjects.
       All members declared public as this is only a wrapper"""

    class_signature = "Metadata"

    def __init__(self, user):
        self.creator        = user
        self.owner          = user
        self.create_time    = time()
        self.update_time    = time()
        self.update_user    = user
        self.update_action  = MetadataUpdateActions.CREATE
        self.update_controller_action = self.__getUpdateAction()

    def toDict(self):
        return self.__dict__

    def fromDict(self, dictt):
        for k, v in dictt.items():
            setattr(self, k, v)
        return self


    def update(self, user, action = MetadataUpdateActions.UPDATE): 
        """Update the local metadata giving a user and an action.
        Update time gets modified to the current system time"""
        self.update_user = user
        self.update_time = time()
        self.update_action = action 

        self.update_controller_action = self.__getUpdateAction()

        # api.devlog("Updating object (%s) metadata for user: (%s), utime = (%.4f), action=(%d), controller action = (%s)"
        #                     % (self, self.update_user, self.update_time, self.update_action, self.update_controller_action))

    def __getUpdateAction(self):
        """This private method grabs the stackframes in look for the controller
        call that generated the update"""

        l_strace = traceback.extract_stack(limit = 10)
        controller_funcallnames = [ x[2] for x in l_strace if "controller" in x[0] ]
        
        if controller_funcallnames:
            return "ModelControler." +  " ModelControler.".join(controller_funcallnames)
        return "No model controller call"
        
class PickleBackedDict(dict): 
    def __init__(self, path, filename = None):
        self.path = os.path.join(path, filename) if not filename is None else path
        self.lock = threading.Lock()
        if os.path.exists(self.path):
            with open(self.path, 'rb') as f:
                self.dict = pickle.load(f)

        else:
            self.dict = {}

    def cleanUp(self):
        with self.lock:
            if os.path.isfile(self.path): 
                os.remove(self.path)
            self.dict = {}
            # with open(self.path, 'wb', 0) as writer:
            #     self.dict = {}
            #     pickle.dump(self.dict, writer)


    def __setitem__(self, key, value):
        # When we set an item, we update the old dict
        try:
            with self.lock:
                with open(self.path, 'wb', 0) as writer:
                    self.dict.__setitem__(key, value)
                    pickle.dump(self.dict, writer)
        except Exception, e:
            raise e

    def __getitem__(self, key):
        return self.dict.__getitem__(key)

    def get(self, key, default = None):
        return self.dict.get(key, default)

    def __repr__(self):
        return self.dict.__repr__()

    def __str__(self):
        return self.dict.__str__()



class MetadataHistory(object):
    """Wrap object for the history of metadata objects, just a wrap for an
    object dict that persists to disc"""
    class_signature = "MetadataHistory"

    _history_dict = PickleBackedDict(path = getInstanceConfiguration().getPersistencePath(), 
                                              filename = "metadata.pickle" )
    
    def __init__(self, *args):
        self._history_dict = MetadataHistory._history_dict

    def getHistory(self, objId):
        """docstring for getHistory"""
        return self._history_dict.get(objId, [])

    def setHistory(self, objId, obj):
        
        self._history_dict[objId] =  obj
        
    def pushMetadataForId(self, objId, obj):
        """Adds the metadata in obj for id into the internal rep. """ 
        pass
        # print "Object ID is: ", objId, " with type ", type(objId)
        # hist = self.getHistory(objId)
        # hist.append(obj)
        # self.setHistory(objId, hist)

    def cleanUp(self):
        self._history_dict.cleanUp()


    def toDict(self):
        return self._history_dict
    def fromDict(self, dictt):
        self._history_dict.update(dictt)



        
#-------------------------------------------------------------------------------
class ModelObjectDictAdapter(object):
    def __init__(self):
        self.excepts = ["_id"]
        self.modified = []

        # Here I register the classes I need on the factory to create the objects:
        factory.register(model.hosts.Host)
        factory.register(model.hosts.Interface)
        factory.register(model.hosts.Service)
        factory.register(model.hosts.HostApplication)
        factory.register(model.common.ModelObjectVuln)
        factory.register(model.common.ModelObjectNote)
        factory.register(model.common.ModelObjectCred)
        factory.register(model.common.Metadata)
        factory.register(model.common.MetadataHistory)



    def toDict(self, obj): 
        obj_dict = obj.toDict().copy()
        normalized_dict = {}

        normalized_dict.update(self._normalizeKeys(obj_dict))

        return normalized_dict

    def _normalizeKeys(self, obj_dict):
        normalized_dict = {}
        for k, v in obj_dict.items():
            if k is not None and k.startswith('_') and not k in self.excepts: 
                k = k.replace('_', '', 1)
                self.modified.append(k)
            if isinstance(v, dict): v = self._normalizeKeys(v)
            normalized_dict[k] = v

        return normalized_dict

    def _denormalizeKeys(self, dictt):
        denormalized_dict = {}
        for k, v in dictt.items():
            if k in self.modified:
                k = "_" + k
            if isinstance(v, dict): v = self._denormalizeKeys(v)
            denormalized_dict[k] = v

        return denormalized_dict

    def fromDict(self, obj, dictt):
        dictt = self._denormalizeKeys(dictt)
        return obj.fromDict(dictt)


class ModelObject(object):
    """
    This is the base class for every object we need to represent in the
    system (like hosts, services, etc)
    It defines some generic methods to handle internal attributes that are
    dictionaries. It also has generic methods to deal with notes & vulns
    since every object could have them.
    """
    # this static attribute used with a factory
    class_signature = "ModelObject"
    #_complex_attribs = ["_metadata", "_metadataHistory", "_notes", "_vulns", "_creds"]
    _complex_attribs = ["_notes", "_vulns", "_creds"]

    def __init__(self):
        self._name          = ""
        self._id            = None
        self._parent        = None
        
        self.owner          = api.getLoggedUser()
        self._metadata      = Metadata(self.owner)
        self._metadataHistory = MetadataHistory()

        
        # this flag is used to determine if the object is an instance that is
        # inside the ModelController or is just a copy of an existing ModelObject
        # that can be used without worrying about changes affecting the real object
        self.is_copy       = False
        
        # indicates if object was owned somehow
        # we could use this property to put a different color on the GUI
        self._is_owned      = False

        # a custom description given by the user
        # this can be used to explain the purpose of the object
        self.description    = ""

        #IMPORTANT: this must be used in each object that inherits from this class
        # DO NOT REDEFINE THIS, JUST ADD ENTRIES IN ORDER NOT TO LOOSE INHERITED ATTRS
        # this attribute lists all values that can be shown in the gui, or
        # can be accessed from outside. This is done to do things more generic and
        # dynamic. The object that needs to use this should check if the element
        # in the attribute list is callable or not
        # To use this attributes list something like this should be done
        # >>> for attrDesc, attrName in m_object.publicattrs.iteritems():
        # >>>     attr_ref = m_object.__getattribute__(attrName)
        # >>>     if callable(attr_ref):
        # >>>         info = attr_ref()
        # >>>     else:
        # >>>         info = attr_ref
        # the dictionary key is the description of the attribute that is like a
        # display name to be used if needed to show in a GUI for example
        # and the value is the attribute name, that can be the name of an attribute,
        # a method or a property, that is why it needs to be checked with callable()

        self.publicattrs = {'Description':'description',
                            'Name':'getName','Owned':'isOwned',
                            #'Vulnerabilities' : 'vulnsCount',
                            #'Notes' : 'notesCount',
                            #'Creds' : 'credsCount'}
                            }

        self.publicattrsrefs = {'Description': '_description',
                            'Name': '_name','Owned': '_is_owned',
                            #'Vulnerabilities' : '_vulns',
                            #'Notes' :'_notes',
                            #'Creds' :'_creds'} 
                            }

        self._updatePublicAttributes()

        #TODO: I think notes and vulns should be a dict
        self._notes = {}
        self._vulns = {}
        self._creds = {}
        self.evidences = []

        self.updates = []

    #def __getattr__( self, name):
    #    l_strace = traceback.extract_stack(limit = 5)
    #    print l_strace
    #    print ("BBBBBBBBBBBBBBBB ModelObject attribute to refactor: %s" % name)


    def defaultValues(self):
        return [-1, 0, '', 'unknown', None, [], {}]

    def __getAttribute(self, key):
        """ Looks for the attribute beneth the public attribute dict """
        return self.publicattrsrefs.get(key)

    def propertyTieBreaker(self, key, prop1, prop2):
        """ Breakes the conflict between two properties. If either of them
        is a default value returns the true and only.
        If neither returns the default value.
        If conflicting returns a tuple with the values """ 
        if prop1 in self.defaultValues(): return prop2
        elif prop2 in self.defaultValues(): return prop1
        elif self.tieBreakable(key): return self.tieBreak(key, prop1, prop2)
        else: return (prop2, prop1)

    def tieBreakable(self, key): 
        return False

    def tieBreak(self, key, prop1, prop2):
        return None

    def addUpdate(self, newModelObject):
        conflict = False
        diff = ModelObjectDiff(self, newModelObject) 
        for k, v in diff.getPropertiesDiff().items():
            attribute = self.__getAttribute(k)
            prop_update = self.propertyTieBreaker(attribute, *v)
            if isinstance(prop_update, tuple):
                conflict = True
            else:
                setattr(self, attribute, prop_update) 
        if conflict:
            self.updates.append(ConflictUpdate(self, newModelObject))
        return conflict

    def getUpdates(self):
        return self.updates

    def updateResolved(self, update):
        self.updates.remove(update)

    
    # IMPORTANT: all delete methods are considered FULL delete
    # this means it will delete the reference from host and all
    # other objects containing them
    def _getValueByID(self, attrName, ID):
        """
        attribute passed as a parameter MUST BE a dictionary indexed with a
        string ID
        if id is found as a part of a key it returns the object
        it returns None otherwise
        """
        if ID:
            hash_id = get_hash([ID])
            ref = self.__getattribute__(attrName)
            # we are assuming the value is unique inside the object ID's
            for key in ref:
                #XXX: this way of checking the ids doesn't allow us to use a real hash as key
                # because we are checking if "id" is part of the key... not a good way  of
                # dealing with this...
                if hash_id == key or ID == key:
                    return ref[key]
            # if id (hash) was not found then we try with element names
            for element in ref.itervalues():
                #if id in element.name:
                if ID == element.name:
                    return element
        return None


    def _addValue(self, attrName, newValue, setparent = False, update = False):
        # attribute passed as a parameter MUST BE  the name
        # of an internal attribute which is a dictionary indexed
        # with a string ID
        valID = newValue.getID()
        ref = self.__getattribute__(attrName)
        if valID not in ref or update:
            ref[valID] =  newValue
            if setparent:
                newValue.setParent(self)
            return True
            #return not update
        return False

    
    def _updatePublicAttributes(self):
        # can be overriden if needed
        pass


    def setID(self, ID=None):
        if ID is None:
            self.updateID()
        else:
            self._id = ID
        return self._id
            
    def updateID(self):
        # MUST be overriden
        # if not overriden then name is the id
        self._id = get_hash([self._name])

    def getID(self):
        if self._id is None:
            self.updateID()
        return self._id

    id = property(getID, setID)
    
    def getMetadata(self):
        """Returns the current metadata of the object"""
        return self._metadata
    
    def getMetadataHistory(self):
        """Returns the current metadata of the object"""
        return self._metadataHistory

    def updateMetadata(self):
        """ We are only saving the previous state so the newst is not available"""
        self.getMetadata().update(self.owner)
        # self.getMetadataHistory().pushMetadataForId(self.getID(), self.getMetadata())
    
    def getHost(self):
        #recursive method to recover the Host root
        if self.class_signature == "Host":
            return self
        return self.getParent().getHost()

    def setName(self, name):
        self._name = name

    def getName(self):
        return self._name

    name = property(getName, setName)
    
    def setDescription(self, description):
        self._description = description

    def getDescription(self):
        return self._description
    
    description = property(getDescription, setDescription)
    
    def isOwned(self):
        return self._is_owned

    def setOwned(self, owned=True):
        self._is_owned = owned

    @save
    def setParent(self, parent):
        self._parent = parent

    def getParent(self):
        return self._parent
    
    parent = property(getParent, setParent)
    
    #TODO: this should be removed and we could use some class
    # based on dict to implement this


    def _delValue(self, attrName, valID):
        # attribute passed as a parameter MUST BE  the name
        # of an internal attribute which is a dictionary indexed
        # with a string ID
        api.devlog("(%s)._delValue(%s, %s)" % (self, attrName, valID))
        ref = self.__getattribute__(attrName)
        api.devlog("ref.keys() = %s" % ref.keys())
        if valID in ref:
            val = ref[valID]
            del ref[valID]
            val.delete()
            return True
        
        hash_id = get_hash([valID])
        if hash_id in ref:
            val = ref[hash_id]
            del ref[hash_id]
            val.delete()
            return True
        
        for element in ref.itervalues():
            if valID == element.name:
                val = ref[element.getID()]
                del ref[element.getID()]
                val.delete()
                return True
            
        # none of the ids were found         
        return False

    def _delAllValues(self, attrName):
        ref = self.__getattribute__(attrName)
        try:
            ref.clear()
            return True
        except Exception:
            return False

    @delete
    def delete(self):
        del self

    def _getAllValues(self, attrName, mode = 0):
        """
        attribute passed as a parameter MUST BE a dictionary indexed with a
        string ID
        return all values in the dictionary
        mode = 0 returns a list of objects
        mode = 1 returns a dictionary of objects with their id as key
        """
        ref = self.__getattribute__(attrName)
        if mode:
            return ref
        else:
            return sorted(ref.values())

    def _getAllIDs(self, attrName):
        ref = self.__getattribute__(attrName)
        return ref.keys()

    def _getValueCount(self, attrName):
        ref = self.__getattribute__(attrName)
        return len(ref)

    def __repr__(self):
        return "<ModelObject %s at 0x%x>" % (self.__class__.__name__, id(self))

    def __str__(self):
        return "<ModelObject %s ID = %s at 0x%x>" % (self.__class__.__name__, self._id, id(self))

    #notes
    @updateLocalMetadata
    def addNote(self, newNote, update=False, setparent=True):
        return self._addValue("_notes", newNote, setparent=setparent, update=update)

    def newNote(self, name, text):
        note = ModelObjectNote(name, text, self)
        self.addNote(note)
        
    @updateLocalMetadata
    def delNote(self, noteID):
        return self._delValue("_notes", noteID)

    def getNotes(self):
        return self._notes.values()

    def getNote(self, noteID):
        return self._getValueByID("_notes", noteID)

    def notesToDict(self):
        d = []
        for note in self._notes.values():
            d.append(note.toDictFull())
        return d
    def notesCount(self):
        return len(self._notes.values())
        
    #Vulnerability
    @updateLocalMetadata
    def addVuln(self, newVuln, update=False, setparent=True):
        return self._addValue("_vulns", newVuln, setparent=setparent, update=update)

    @updateLocalMetadata
    def delVuln(self, vulnID):
        return self._delValue("_vulns", vulnID)

    def getVulns(self):
        return self._vulns.values()

    def getVuln(self, vulnID):
        return self._getValueByID("_vulns", vulnID)

    def vulnsCount(self):
        return len(self._vulns.values())

    def vulnsToDict(self):
        d = []
        for vuln in self._vulns.values():
            d.append(vuln.toDictFull())
        return d

    #creds
    @updateLocalMetadata
    def addCred(self, newCred, update=False, setparent=True):
        return self._addValue("_creds", newCred, setparent=setparent, update=update)

    def newCred(self, username, password):
        cred = ModelObjectCred(username, password, self)
        self.addCred(cred)
        
    @updateLocalMetadata
    def delCred(self, credID):
        return self._delValue("_creds", credID)

    def getCreds(self):
        return self._creds.values()

    def getCred(self, credID):
        return self._getValueByID("_creds", credID)

    def credsToDict(self):
        d = []
        for cred in self._creds.values():
            d.append(cred.toDictFull())
        return d


    def credsCount(self):
        return len(self._creds.values())
    
    def __getClassname(self, val):
        supported = factory.listModelObjectTypes()
        return filter(lambda x: val.lower().replace('_', '')[:-1] in x.lower(), supported)[0]

    def _asdict(self):
        return self.toDictFull()

    def ancestors_path(self):
            if self.getParent() is None:
                return str(self.getID())
            return ".".join([self.getParent().ancestors_path()] + [str(self.getID())])

    def _toDict(self, full=False):
        d = {   
                "_id" : self.ancestors_path(),
                "obj_id": self.getID(),
                "name" : self.name,
                "owned" : str(self.isOwned()),
                "parent" : self.getParent().getID() if self.getParent() is not None else "None",
                "owner" : self.owner,
                "description" : self.description,
                "metadata" : self.getMetadata().__dict__,
                "type" : self.class_signature
            }
        if full:
            d["note"] = {}
            d["vulnerability"] = {}
            d["cred"] = {}
            for note in self.getNotes():
                d["note"][note.getID()] = note._toDict(full)
            for vuln in self.getVulns():
                d["vulnerability"][vuln.getID()] = vuln._toDict(full)
            for cred in self.getCreds():
                d["cred"][cred.getID()] = cred._toDict(full)
        return d

    def _fromDict(self, dict):
        
        self.id = dict["obj_id"]
        self.name = dict["name"]
        self._is_owned  = True if dict.get("owned", "").upper() == "TRUE" else False
        #parent_id = dict["parent"]
        self.owner = dict["owner"]
        self.description = dict["description"]
        self._metadata = Metadata("").fromDict(dict["metadata"])

        if dict.get("note"):
            for note in dict["note"].values():
                n = ModelObjectNote("")
                n._parent = self
                n._fromDict(note)
                self.addNote(n, setparent=False)

        if dict.get("vulnerability"):
            for vuln in dict["vulnerability"].values():
                v = ModelObjectVuln("")
                v._parent = self
                v._fromDict(vuln)
                self.addVuln(v, setparent=False)

        if dict.get("vulnerabilityweb"):
            for vuln in dict["vulnerabilityweb"].values():
                v = ModelObjectVulnWeb("")
                v._parent = self
                v._fromDict(vuln)
                self.addVuln(v, setparent=False)

        if dict.get("cred"):
            for cred in dict["cred"].values():
                c = ModelObjectCred("")
                c._parent = self
                c._fromDict(cred)
                self.addCred(c, setparent=False)

#-------------------------------------------------------------------------------
#TODO: refactor this class to make it generic so this can be used also for plugins
# then create a subclass and inherit the generic factory
class ModelObjectFactory(object):
    """
    Factory to creat any ModelObject type
    """
    def __init__(self):
        self._registered_objects = dict()

    def register(self, model_object):
        """registers a class into the factory"""
        self._registered_objects[model_object.class_signature] = model_object

    def listModelObjectClasses(self):
        """returns a list of registered classes"""
        return self._registered_objects.values()

    def getModelObjectClass(self, name):
        """get the class for a particular object typename"""
        return self._registered_objects[name]

    def listModelObjectTypes(self):
        """returns an array with object typenames the factory is able to create"""
        names = self._registered_objects.keys()
        names.sort()
        return names

    def createModelObject(self, classname, object_name=None, **objargs):
        if classname in self._registered_objects:
            if object_name is not None:
                tmpObj = self._registered_objects[classname](object_name,**objargs)
                return tmpObj
            else:
                raise Exception("Object name parameter missing. Cannot create object class: %s" % classname)
        else:
            raise Exception("Object class %s not registered in factory. Cannot create object." % classname)

#-------------------------------------------------------------------------------
# global reference kind of a singleton
factory = ModelObjectFactory()

#-------------------------------------------------------------------------------

class CustomXMLRPCRequestHandler(SimpleXMLRPCServer.SimpleXMLRPCRequestHandler):

    def __init__(self, *args, **kwargs):
        SimpleXMLRPCServer.SimpleXMLRPCRequestHandler.__init__(self, *args, **kwargs)

    def handle(self):
        try:
            api.devlog("-" * 60)
            api.devlog("[XMLRPCHandler] - request = %s" % str(self.request))
            api.devlog("[XMLRPCHandler] - client_address = %s" % str(self.client_address))
            api.devlog("[XMLRPCHandler] - server = %s" % str(self.server))
            api.devlog("-" * 60)
            SimpleXMLRPCServer.SimpleXMLRPCRequestHandler.handle(self)
        except Exception:
            api.devlog("[XMLRPCHandler] - An error ocurred while handling a request\n%s" % traceback.format_exc())

    def do_POST(self):
        """
        Handles the HTTP POST request.
        Attempts to interpret all HTTP POST requests as XML-RPC calls,
        which are forwarded to the server's _dispatch method for handling.

        This is a copy of the original do_POST, but it sends information about
        the client calling the server to the marshaled dispatch. This info
        can be later passed to the server
        """

        # Check that the path is legal
        if not self.is_rpc_path_valid():
            self.report_404()
            return

        try:
            # Get arguments by reading body of request.
            # We read this in chunks to avoid straining
            # socket.read(); around the 10 or 15Mb mark, some platforms
            # begin to have problems (bug #792570).
            max_chunk_size = 10*1024*1024
            size_remaining = int(self.headers["content-length"])
            L = []
            while size_remaining:
                chunk_size = min(size_remaining, max_chunk_size)
                L.append(self.rfile.read(chunk_size))
                size_remaining -= len(L[-1])
            data = ''.join(L)

            # In previous versions of SimpleXMLRPCServer, _dispatch
            # could be overridden in this class, instead of in
            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
            # check to see if a subclass implements _dispatch and dispatch
            # using that method if present.
            response = self.server._marshaled_dispatch(
                    data, getattr(self, '_dispatch', None)
                )
        except Exception, e: # This should only happen if the module is buggy
            # internal error, report as HTTP server error
            self.send_response(500)

            # Send information about the exception if requested
            if hasattr(self.server, '_send_traceback_header') and \
                    self.server._send_traceback_header:
                self.send_header("X-exception", str(e))
                self.send_header("X-traceback", traceback.format_exc())

            self.end_headers()
        else:
            # got a valid XML RPC response
            self.send_response(200)
            self.send_header("Content-type", "text/xml")
            self.send_header("Content-length", str(len(response)))
            self.end_headers()
            self.wfile.write(response)

            # shut down the connection
            self.wfile.flush()
            self.connection.shutdown(1)
#-------------------------------------------------------------------------------
# custom XMLRPC server with stopping function
#TODO: check http://epydoc.sourceforge.net/stdlib/SimpleXMLRPCServer.SimpleXMLRPCServer-class.html
# see if there is a way to know the ip caller
# looks like the request handler can give us that info
# http://epydoc.sourceforge.net/stdlib/BaseHTTPServer.BaseHTTPRequestHandler-class.html#address_string
#

class XMLRPCServer(SimpleXMLRPCServer.SimpleXMLRPCServer, threading.Thread):
    """
    Stoppable XMLRPC Server with custom dispatch to send over complete traceback
    in case of exception.
    """
    def __init__(self, *args, **kwargs):
        threading.Thread.__init__(self)
        SimpleXMLRPCServer.SimpleXMLRPCServer.__init__(self, requestHandler = CustomXMLRPCRequestHandler, allow_none = True, *args,**kwargs)
        self._stop = False
        # set timeout for handle_request. If we don't the server will hang
        self.timeout = 2

    def run(self):
        self.serve_forever()
        api.devlog("serve_forever ended")
        return

    # overloaded method to be able to stop server
    def serve_forever(self):
        while not self._stop:
            self.handle_request()
        api.devlog("server forever stopped by flag")

    def stop_server(self):
        api.devlog("server stopping...")
        self._stop = True

    # The default dispatcher does not send across the whole stack trace.
    # Only type and value are passed back. The client has no way of knowing
    # the exact place where error occurred in the server (short of some
    # other means such as server logging). This dispatcher sends the whole
    # stack trace.
    def _dispatch(self, method, params):
        """Dispatches the XML-RPC method.

        XML-RPC calls are forwarded to a registered function that
        matches the called XML-RPC method name. If no such function
        exists then the call is forwarded to the registered instance,
        if available.

        If the registered instance has a _dispatch method then that
        method will be called with the name of the XML-RPC method and
        its parameters as a tuple
        e.g. instance._dispatch('add',(2,3))

        If the registered instance does not have a _dispatch method
        then the instance will be searched to find a matching method
        and, if found, will be called.

        Methods beginning with an '_' are considered private and will
        not be called.
        """

        func = None
        try:
            # check to see if a matching function has been registered
            func = self.funcs[method]
        except KeyError:
            if self.instance is not None:
                # check for a _dispatch method
                if hasattr(self.instance, '_dispatch'):
                    return self.instance._dispatch(method, params)
                else:
                    # call instance method directly
                    try:
                        func = SimpleXMLRPCServer.resolve_dotted_attribute(
                            self.instance,
                            method,
                            self.allow_dotted_names
                            )
                    except AttributeError:
                        pass

        if func is not None:
            try:
                # since we are using a keyword xmlrpc proxy this is sending
                # the info comes in form of args and kwargs
                # so params has 2 items, the first being a list or tuple
                # and the second a dictionary
                if len(params) == 2 and  isinstance(params[1],dict) and\
                ( isinstance(params[0],list) or isinstance(params[0],tuple) ) :
                    return func(*params[0], **params[1])
                else:
                    # this is the default way in case a normal xmlrpclib.ServerProxy is used
                    return func(*params)
            except Exception:
                # extended functionality to let the client have the full traceback
                msg = traceback.format_exc()
                raise xmlrpclib.Fault(1, msg)
        else:
            raise Exception('method "%s" is not supported' % method)


    def _marshaled_dispatch(self, data, dispatch_method = None):
        """Dispatches an XML-RPC method from marshalled (XML) data.

        XML-RPC methods are dispatched from the marshalled (XML) data
        using the _dispatch method and the result is returned as
        marshalled data. For backwards compatibility, a dispatch
        function can be provided as an argument (see comment in
        SimpleXMLRPCRequestHandler.do_POST) but overriding the
        existing method through subclassing is the prefered means
        of changing method dispatch behavior.
        """

        try:
            params, method = xmlrpclib.loads(data)

            # generate response
            if dispatch_method is not None:
                response = dispatch_method(method, params)
            else:
                response = self._dispatch(method, params)
            # wrap response in a singleton tuple
            response = (response,)
            response = xmlrpclib.dumps(response, methodresponse=1,
                                       allow_none=self.allow_none, encoding=self.encoding)
        except Fault, fault:
            response = xmlrpclib.dumps(fault, allow_none=self.allow_none,
                                       encoding=self.encoding)
        except Exception:
            # report exception back to server
            exc_type, exc_value, exc_tb = sys.exc_info()
            response = xmlrpclib.dumps(
                xmlrpclib.Fault(1, "%s:%s" % (exc_type, exc_value)),
                encoding=self.encoding, allow_none=self.allow_none,
                )

        return response

#-------------------------------------------------------------------------------

class XMLRPCKeywordProxy(object):
    """
    custom XMLRPC Server Proxy capable of receiving keyword arguments
    when calling remote methods
    """
    def __init__(self, *args, **kwargs):
        self._xmlrpc_server_proxy = xmlrpclib.ServerProxy(*args, **kwargs)
    def __getattr__(self, name):
        call_proxy = getattr(self._xmlrpc_server_proxy, name)
        def _call(*args, **kwargs):
            return call_proxy(args, kwargs)
        return _call



#-------------------------------------------------------------------------------
class ModelObjectNote(ModelObject):
    """
    Simple class to store notes about any object.
    id will be used to number notes (based on a counter on the object being commented)
    parent will be a reference to the object being commented.
    To assing new text this:
        >>> note.text = "foobar"
    to append text + or  += operators can be used (no need to use text property):
        >>> note += " hello world!"
    """
    class_signature = "Note"
    
    def __init__(self, name="", text="", parent=None):
        ModelObject.__init__(self)
        self.name = str(name)
        #self._parent = parent
        self._text = str(text)

    def updateID(self):
        self._id = get_hash([self.name, self._text])

    def _setText(self, text):
        # clear buffer then write new text
#        self._text.seek(0)
#        self._text.truncate()
#        self._text.write(text)
        self._text = str(text)

    def _getText(self):
#        return self._text.getvalue()
        return self._text

    text = property(_getText, _setText)

    @save
    @updateLocalMetadata
    def updateAttributes(self, name=None, text=None):
        if name is not None:
            self.setName(name)
        if text is not None:
            self.text = text

    def __add__(self, text):
        # to be able to concat/append using +
        # self._text.write(text)
        self._text = self._text + str(text)
        return self

    def __radd__(self, text):
        return self.__add__(str(text))

    def __iadd__(self, text):
        return self.__add__(str(text))

    def __str__(self):
        return self.text

    def __repr__(self):
        return self.text

    def _toDict(self, full=False):
        note = super(ModelObjectNote, self)._toDict(full)
        note["text"] = self._text
        return note

    def _fromDict(self, dict):
        super(ModelObjectNote, self)._fromDict(dict)
        self._text = dict["text"]

    def fromDict(self, dict):
        self._id = dict["_id"]
        self._text = dict["text"]
        self.name = dict["name"]
        
        for note in dict["notes"]:
            n = ModelObjectNote("")
            self.setParent(self)
            n.fromDict(note)
            self.addNote(n)
    
#-------------------------------------------------------------------------------
class ModelObjectVuln(ModelObject):
    """
    Simple class to store vulnerability about any object.
    id will be used to number vulnerability (based on a counter on the object being commented)
    parent will be a reference to the object being commented.   
    """
    class_signature = "Vulnerability"
    
    def __init__(self, name="",desc="", ref=None, severity="", parent=None):
        """
        The parameters refs can be a single value or a list with values
        """
        ModelObject.__init__(self)
        self.name = name
        #self._parent = parent

        self._desc = desc
        
        self.refs = []
        
        if isinstance(ref, list):
            self.refs.extend(ref)
        elif ref is not None:
            self.refs.append(ref)

        # Severity Standarization 
        self.severity = self.standarize(severity)

    def standarize(self, severity): 
        # Transform all severities into lower strings
        severity = str(severity).lower()
        # If it has info, med, high, critical in it, standarized to it: 
        

        def align_string_based_vulns(severity):
            severities = ['info','low', 'med', 'high', 'critical']
            for sev in severities:
                if severity[0:3] in sev:
                    return sev
            return severity

        severity = align_string_based_vulns(severity)

        # Transform numeric severity into desc severity
        numeric_severities = { '0' : 'info',
                                 '1' : 'low',
                                 '2' : 'med',
                                 '3' : 'high',
                                 "4" : 'critical' }


        if not severity in numeric_severities.values():
            severity = numeric_severities.get(severity, 'unclassified')

        return severity

    def updateID(self):
        self._id = get_hash([self.name, self._desc])
        
    def _setDesc(self, desc):
        self._desc = desc

    @save
    @updateLocalMetadata
    def updateAttributes(self, name=None, desc=None, severity=None, refs=None):
        if name is not None:
            self.setName(name)
        if desc is not None:
            self.desc = desc
        if severity is not None:
            self.severity = self.standarize(severity)
        if refs is not None:
            self.refs = refs

    def _getDesc(self):
        #return self._desc.getvalue()
        return self._desc

    desc = property(_getDesc, _setDesc)

    def __str__(self):
        return "vuln id:%s - %s" % (self.id, self.name)

    def __repr__(self):
        return self.__str__()

    def _toDict(self, full=False):
        vuln = super(ModelObjectVuln, self)._toDict(full)
        vuln["desc"] = self._desc
        vuln["severity"] = self.severity
        vuln["refs"] = self.refs
        return vuln

    def _fromDict(self, dict):
        super(ModelObjectVuln, self)._fromDict(dict)
        self._desc = dict["desc"]
        self.severity = dict["severity"]
        self.refs = dict["refs"]

    def fromDict(self, dict):
        self._id = dict["_id"]
        self._desc = dict["desc"]
        self.name = dict["name"]
        self.severity = dict["severity"]

        for ref in dict["refs"]:
            self.refs.append(ref)
        
        self.severity = dict["severity"]
        

#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
class ModelObjectVulnWeb(ModelObjectVuln):
    """
    Simple class to store vulnerability web about any object.
    This Vuln support path, hostname, request and response
    parent will be a reference to the ModelObjectVuln being commented.   
    """
    class_signature = "VulnerabilityWeb"
    
    def __init__(self, name="",desc="", website="", path="", ref=None, severity="", parent=None, request="", response="",
                method="",pname="", params="",query="",category=""):
        """
        The parameters ref can be a single value or a list with values
        """
        ModelObjectVuln.__init__(self, name,desc, ref, severity, parent)
        self.path = path
        self.website = website
        self.request = request
        self.response = response
        self.method = method
        self.pname = pname
        self.params = params
        self.query = query
        self.category = category
        
    def updateID(self):
        self._id = get_hash([self.name, self.website, self.path, self.desc ])

    @save
    @updateLocalMetadata
    def updateAttributes(self, name=None, desc=None, website=None, path=None, refs=None, severity=None, request=None,
                        response=None, method=None, pname=None, params=None, query=None, category=None):
        super(ModelObjectVulnWeb, self).updateAttributes(name, desc, severity, refs)
        if website is not None:
            self.website = website
        if path is not None:
            self.path = path
        if request is not None:
            self.request = request
        if response is not None:
            self.response = response
        if method is not None:
            self.method = method
        if pname is not None:
            self.pname = pname
        if params is not None:
            self.params = params
        if query is not None:
            self.query = query
        if category is not None:
            self.category = category
        
    def _toDict(self, full=False):
        vuln = super(ModelObjectVulnWeb, self)._toDict(full)
        vuln['website'] = self.website
        vuln['path'] = self.path
        vuln['request'] = self.request
        vuln['response'] = self.response
        vuln['method'] = self.method
        vuln['pname'] = self.pname
        vuln['params'] = self.params
        vuln['query'] = self.query
        vuln['category'] = self.category
        return vuln

    def _fromDict(self, dict):
        super(ModelObjectVulnWeb, self)._fromDict(dict)
        self.path = dict["path"]
        self.website = dict["website"]
        self.request = dict["request"]
        self.response = dict["response"]
        self.method = dict["method"]
        self.pname = dict["pname"]
        self.params = dict["params"]
        self.query = dict["query"]
        self.category = dict["category"]

    def fromDict(self, dict):
        
        ModelObjectVuln.fromDict(dict)
        
        self.path = dict["path"]
        self.website = dict["website"]
        self.request = dict["request"]
        self.response = dict["response"]
        self.method = dict["method"]
        self.pname = dict["pname"]
        self.params = dict["params"]
        self.query = dict["query"]
        self.category = dict["category"]
        
        return True


#-------------------------------------------------------------------------------
class ModelObjectCred(ModelObject):
    """
    Simple class to store credentials about any object.
    id will be used to number credentials (based on a counter on the object being commented)
    parent will be a reference to the object being commented.
    To assing new password this:
        >>> cred.password = "foobar"
    to append text + or  += operators can be used (no need to use password property):
        >>> cred += " hello world!"
    """
    class_signature = "Cred"
    
    def __init__(self, username="", password="", parent=None):
        ModelObject.__init__(self)
        #self._parent = parent
        self.username = str(username)
        self._parent = parent
        # using StringIO instead of common str because is more memory efficient
#        self._password = StringIO()
#        if password: self._password.write(password)
        self._password = str(password)
    
    def updateID(self):
        self._id = get_hash([self.username, self.password])

    def _setPassword(self, password):
        # clear buffer then write new password
#        self._password.seek(0)
#        self._password.truncate()
#        self._password.write(password)
        self._password = str(password)

    def _getPassword(self):
#        return self._password.getvalue()
        return self._password

    password = property(_getPassword, _setPassword)

    @save
    @updateLocalMetadata
    def updateAttributes(self, username=None, password=None):
        if username is not None:
            self.username = username
        if password is not None:
            self.password = password

    def __add__(self, password):
        # to be able to concat/append using +
        # self._password.write(password)
        self._password = self._password + str(password)
        return self

    def __radd__(self, password):
        return self.__add__(str(password))

    def __iadd__(self, password):
        return self.__add__(str(password))

    def __str__(self):
        return self.password

    def __repr__(self):
        return self.password

    def _toDict(self, full=False):
        cred = super(ModelObjectCred, self)._toDict(full)
        cred["username"] = self.username
        cred["password"] = self._password
        return cred

    def _fromDict(self, dict):
        super(ModelObjectCred, self)._fromDict(dict)
        self._password = dict["password"]
        self.username = dict["username"]

    def fromDict(self, dict):
        self._id = dict["_id"]
        self._password = dict["password"]
        self.username = dict["username"]
        
        #for cred in dict["creds"]:
        #    n = ModelObjectCred("")
        #    self.setParent(self)
        #    n.fromDict(cred)
        #    self.addCred(n)

class TreeWordsTries(object):
    instance = None       
    END = '_end_'
    root = dict()
    FOUND = True

    def __init__(self):
        self.partial_match = False
        self.partial_match_dict = {}
        self.cur_idx = 0

    def addWord(self, word):
        current_dict = self.root
        for letter in word:
            current_dict = current_dict.setdefault(letter, {})

        current_dict = current_dict.setdefault(self.END, self.END)

    def getWordsInText(self, text):
        current_dict = self.root
        list_of_word = list()
        w = ''
        for letter in text:
            if letter in current_dict:
                current_dict = current_dict[letter]
                w += letter
            elif self.END in current_dict:
                list_of_word.append(w)
                current_dict = self.root
                w = ''
            else:
                current_dict = self.root
                w = ''

        if self.END in current_dict:
            list_of_word.append(w)

        return list_of_word


    def isInTries(self, word):
        current_dict = self.root

        if word is None:
            return False

        for letter in word:
            if letter in current_dict:
                current_dict = current_dict[letter]
            else:
                return not self.FOUND
        else:
            if self.END in current_dict:
                return self.FOUND
            else:
                return False

    def __new__(cls, *args, **kargs): 
        if cls.instance is None:
            cls.instance = object.__new__(cls, *args, **kargs)
        return cls.instance

    def removeWord(self, word):
        previous_dict = None
        current_dict = self.root
        last_letter = ''

        if not self.isInTries(word):
            return

        for letter in word: 
            if letter in current_dict:
                if not previous_dict:
                    previous_dict = current_dict
                    last_letter = letter
                if len(current_dict.keys()) != 1:
                    previous_dict = current_dict
                    last_letter = letter
                current_dict = current_dict[letter]
        else:
            if self.END in current_dict:
                previous_dict.pop(last_letter)

    def clear(self):
        self.root = dict()
        self.FOUND = True



#-------------------------------------------------------------------------------
# taken from http://code.activestate.com/recipes/576477-yet-another-signalslot-implementation-in-python/
# under MIT License
#TODO: decide if we are going to use this...
class Signal(object):
    """
    used to handle signals between several objects
    """
    def __init__(self):
        self.__slots = WeakValueDictionary()

    def __call__(self, *args, **kargs):
        for key in self.__slots:
            func, _ = key
            func(self.__slots[key], *args, **kargs)

    def connect(self, slot):
        key = (slot.im_func, id(slot.im_self))
        self.__slots[key] = slot.im_self

    def disconnect(self, slot):
        key = (slot.im_func, id(slot.im_self))
        if key in self.__slots:
            self.__slots.pop(key)

    def clear(self):
        self.__slots.clear()

#-------------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = conflict
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
class Conflict():
	def __init__(self, first_object, second_object):
		self.type = None
		self.model_object_type = first_object.class_signature
		self.first_object = first_object
		self.second_object = second_object

	def getFirstObject(self):
		return self.first_object

	def getSecondObject(self):
		return self.second_object

	def getType(self):
		return self.type

	def getModelObjectType(self):
		return self.model_object_type

	def resolve(self, kwargs):
		return False


class ConflictUpdate(Conflict):
	def __init__(self, first_object, second_object):
		Conflict.__init__(self, first_object, second_object)
		self.type = "Update"

	def resolve(self, kwargs):
		self.first_object.updateAttributes(**kwargs)
		self.first_object.updateResolved(self)
		return True


		

########NEW FILE########
__FILENAME__ = container
#!/usr/bin/python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

                                                         
from model.common import  ModelObjectDictAdapter
from model.hosts import Host
import model
from mockito import mock
import traceback

class ModelObjectContainer(dict):
                                   
    """Used to provide a consistent interface while adding model objects to the currently running environment"""
    def __init__(self, *args):
        self.container = {}

    def __setitem__(self, k, v):
                                       
        self.container.__setitem__(k, v) 

    def __getitem__(self, k):
        return self.container.get(k)

    def __getattr__( self, name):
        return getattr(self.container, name)

    def itervalues(self):
        return self.container.itervalues()

    def values(self):
        return self.container.values()

    def keys(self):
        return self.container.keys()

    def __str__(self):
        return str(self.container)

    def clear(self):
        self.container.clear()

    def __contains__(self, elem):
        return self.container.__contains__(elem)

    def containsByAttr(self, attrName, attrValue):
        for k, elem in self.container:
            if elem.__getattribute__(attrName) == attrValue:
                return True
        return False
        
    def __len__(self):
        return len(self.container)

    def __delitem__(self, k):
        self.container.__delitem__(k)


class CouchedModelObjectContainer(ModelObjectContainer):
    def __init__(self, workspaceName, couchManager):
        ModelObjectContainer.__init__(self)
        self.cdm = couchManager
        self.workspaceName = workspaceName

    def __setitem__(self, k, v):
        ModelObjectContainer.__setitem__(self, k, v)



########NEW FILE########
__FILENAME__ = controller
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import time
import threading
import Queue
import traceback
import datetime
import model.common # this is to make sure the factory is created
import model.hosts

from config.configuration import getInstanceConfiguration
from model.common import TreeWordsTries
from model.container import ModelObjectContainer
from utils.logs import getLogger
import model.api as api
#import model.guiapi as guiapi
from model.guiapi import notification_center as notifier
from gui.customevents import *

from model.workspace import WorkspaceSyncronizer
from utils.decorators import lockModel
from utils.common import get_hash

from model.conflict import Conflict, ConflictUpdate


#XXX: consider re-writing this module! There's alot of repeated code
# and things are really messy

CONF = getInstanceConfiguration()


class modelactions:
    ADDHOST = 2000
    DELHOST = 2001
    ADDINTERFACE = 2002
    DELINTERFACE = 2003
    ADDSERVICEINT = 2004
    ADDSERVICEAPP = 2005
    DELSERVICEINT = 2006
    DELSERVICEAPP = 2007
    DELSERVICEHOST = 2008
    ADDAPPLICATION = 2009
    DELAPPLICATION = 2010
    ADDCATEGORY = 2011
    DELCATEGORY = 2012
    ADDVULNINT = 2013
    DELVULNINT = 2014
    ADDVULNAPP = 2015
    DELVULNAPP = 2016
    ADDVULNHOST = 2017
    DELVULNHOST = 2018
    ADDVULNSRV = 2019
    DELVULNSRV = 2020
    ADDNOTEINT = 2021
    DELNOTEINT = 2022
    ADDNOTEAPP = 2023
    DELNOTEAPP = 2024
    ADDNOTEHOST = 2025
    DELNOTEHOST = 2026
    ADDNOTESRV = 2027
    DELNOTESRV = 2028
    RENAMEROOT = 2029
    ADDNOTEVULN = 2030
    DELNOTEVULN = 2031
    EDITHOST = 2032
    EDITINTERFACE = 2033
    EDITAPPLICATION = 2034
    EDITSERVICE = 2035
    ADDCREDSRV = 2036
    DELCREDSRV = 2037
    ADDVULNWEBSRV = 2038
    DELVULNWEBSRV = 2039
    ADDNOTENOTE = 2040
    DELNOTENOTE = 2041
    EDITNOTE = 2042
    EDITVULN = 2043
    ADDNOTE = 2044
    DELNOTE = 2045
    ADDVULN = 2046
    DELVULN = 2047
    EDITCRED = 2048
    ADDCRED = 2049
    DELCRED = 2050

    __descriptions = {
        ADDHOST: "ADDHOST",
        DELHOST: "DELHOST",
        ADDINTERFACE: "ADDINTERFACE",
        DELINTERFACE: "DELINTERFACE",
        ADDSERVICEINT: "ADDSERVICEINT",
        ADDSERVICEAPP: "ADDSERVICEAPP",
        DELSERVICEINT: "DELSERVICEINT",
        DELSERVICEAPP: "DELSERVICEAPP",
        DELSERVICEHOST: "DELSERVICEHOST",
        ADDAPPLICATION: "ADDAPPLICATION",
        DELAPPLICATION: "DELAPPLICATION",
        ADDCATEGORY: "ADDCATEGORY",
        DELCATEGORY: "DELCATEGORY",
        ADDVULNINT: "ADDVULNINT",
        DELVULNINT: "DELVULNINT",
        ADDVULNAPP: "ADDVULNAPP",
        DELVULNAPP: "DELVULNAPP",
        ADDVULNHOST: "ADDVULNHOST",
        DELVULNHOST: "DELVULNHOST",
        ADDVULNSRV: "ADDVULNSRV",
        DELVULNSRV: "DELVULNSRV",
        ADDNOTEVULN: "ADDNOTEVULN",
        DELNOTEVULN: "DELNOTEVULN",
        ADDNOTENOTE: "ADDNOTENOTE",
        DELNOTENOTE: "DELNOTENOTE",
        EDITHOST: "EDITHOST",
        EDITINTERFACE: "EDITINTERFACE",
        EDITAPPLICATION: "EDITAPPLICATION",
        EDITSERVICE: "EDITAPPLICATION",
        ADDCREDSRV: "ADDCREDSRV",
        DELCREDSRV: "DELCREDSRV",
        ADDVULNWEBSRV: "ADDVULNSWEBRV",
        DELVULNWEBSRV: "DELVULNWEBSRV",
        EDITNOTE: "EDITNOTE",
        EDITVULN: "EDITVULN",
        EDITCRED: "EDITCRED",
        ADDNOTE: "ADDNOTE",
        DELNOTE: "DELNOTE",
        ADDVULN: "ADDVULN",
        DELVULN: "DELVULN",
        ADDCRED: "ADDCRED",
        DELCRED: "DELCRED"
    }

    @staticmethod
    def getDescription(action):
        return modelactions.__descriptions.get(action, "")


class ModelController(threading.Thread):

    def __init__(self, security_manager):
        threading.Thread.__init__(self)

        self.__sec = security_manager

        # set as daemon
        self.setDaemon(True)

        #TODO: think of a good way to handle cross reference between hosts and
        #categories
        self._categories = {}
        self._categories[CONF.getDefaultCategory()] = []

        # dictionary with host ids as key
        self._hosts = None

        # flag to stop daemon thread
        self._stop = False
        # locks needed to make model thread-safe
        self._hosts_lock = threading.RLock()

        #TODO: check if it is better using collections.deque
        # a performance analysis should be done
        # http://docs.python.org/library/collections.html#collections.deque

        # the actions queue
        self._pending_actions = Queue.Queue()

        # a reference to the ModelObjectFactory
        self._object_factory = model.common.factory
        self._registerObjectTypes()

        # sync api request flag. This flag is used to let the model know
        # there's some other object trying to use a sync api, and it should
        # give priority to that and stop processing the queue
        self._sync_api_request = False

        # This flag & lock are used when the complete model is being persisted
        self._saving_model_flag = False
        self._saving_model_lock = threading.RLock()

        self._actionDispatcher = None
        self._setupActionDispatcher()

        self._workspace = None

        self.objects_with_updates = []

        #used to highligthing
        self.treeWordsTries = TreeWordsTries()

    def __getattr__(self, name):
        getLogger(self).debug("ModelObject attribute to refactor: %s" % name)

    def _getValueByID(self, attrName, ID):
        """
        attribute passed as a parameter MUST BE a dictionary indexed with a
        string ID
        if id is found as a part of a key it returns the object
        it returns None otherwise
        """
        if ID:
            hash_id = get_hash([ID])
            ref = self.__getattribute__(attrName)
            # we are assuming the value is unique inside the object ID's
            #for key in ref:
            for key in ref.keys():
                #XXX: this way of checking the ids doesn't allow us to use a real hash as key
                # because we are checking if "id" is part of the key... not a good way  of
                # dealing with this...
                if hash_id == key or ID == key:
                    return ref[key]
            # if id (hash) was not found then we try with element names
            for element in ref.itervalues():
                #if id in element.name:
                if ID == element.name:
                    return element
        return None

    def _addValue(self, attrName, newValue, setparent=False, update=False):
        # attribute passed as a parameter MUST BE  the name
        # of an internal attribute which is a dictionary indexed
        # with a string ID
        valID = newValue.getID()
        ref = self.__getattribute__(attrName)
        #if valID not in ref or update:
        if valID not in ref or update:
            #TODO: Is this necesary?
            if setparent:
                newValue.setParent(self)
            ref[valID] = newValue
            return True
            #return not update
        return False

    def __acquire_host_lock(self):
        self._saving_model_lock.acquire()
        self._saving_model_lock.release()
        self._hosts_lock.acquire()

    def __release_host_lock(self):
        try:
            self._hosts_lock.release()
        except RuntimeError:
            pass

    def _registerObjectTypes(self):
        """
        Registers in the factory all object types that can be created
        """
        # This could be done in hosts module, but it seems easier to maintain
        # if we have all in one place inside the controller
        self._object_factory.register(model.hosts.Host)
        self._object_factory.register(model.hosts.Interface)
        self._object_factory.register(model.hosts.Service)
        self._object_factory.register(model.hosts.HostApplication)
        self._object_factory.register(model.common.ModelObjectVuln)
        self._object_factory.register(model.common.ModelObjectVulnWeb)
        self._object_factory.register(model.common.ModelObjectNote)
        self._object_factory.register(model.common.ModelObjectCred)

    def _setupActionDispatcher(self):
        self._actionDispatcher = {
            modelactions.ADDHOST: self.__addHost,
            modelactions.DELHOST: self.__delHost,
            modelactions.EDITHOST: self.__editHost,
            modelactions.ADDINTERFACE: self.__addInterfaceToHost,
            modelactions.DELINTERFACE: self.__delInterfaceFromHost,
            modelactions.EDITINTERFACE: self.__editInterface,
            modelactions.ADDSERVICEINT: self.__addServiceToInterface,
            modelactions.ADDSERVICEAPP: self.__addServiceToApplication,
            modelactions.DELSERVICEINT: self.__delServiceFromInterface,
            modelactions.DELSERVICEAPP: self.__delServiceFromApplication,
            modelactions.DELSERVICEHOST: self.__delService,
            modelactions.EDITSERVICE: self.__editService,
            modelactions.ADDAPPLICATION: self.__addApplication,
            modelactions.DELAPPLICATION:  self.__delApplication,
            modelactions.EDITAPPLICATION: self.__editApplication,
            modelactions.ADDCATEGORY: self.__addCategory,
            modelactions.DELCATEGORY:  self.__delCategory,
            #Vulnerability
            modelactions.ADDVULNINT: self.__addVulnerabilityToInterface,
            modelactions.DELVULNINT: self.__delVulnerabilityFromInterface,
            modelactions.ADDVULNAPP: self.__addVulnerabilityToApplication,
            modelactions.DELVULNAPP: self.__delVulnerabilityFromApplication,
            modelactions.ADDVULNHOST: self.__addVulnerabilityToHost,
            modelactions.DELVULNHOST: self.__delVulnerabilityFromHost,
            modelactions.ADDVULNSRV: self.__addVulnerabilityToService,
            modelactions.DELVULNSRV: self.__delVulnerabilityFromService,
            modelactions.ADDVULN: self.__addVulnToModelObject,
            modelactions.DELVULN: self.__delVulnFromModelObject,
            modelactions.ADDVULNWEBSRV: self.__addVulnerabilityToService,
            modelactions.DELVULNWEBSRV: self.__delVulnerabilityFromService,
            modelactions.EDITVULN: self.__editVulnerability,
            #Note
            modelactions.ADDNOTEINT: self.__addNoteToInterface,
            modelactions.DELNOTEINT: self.__delNoteFromInterface,
            modelactions.ADDNOTEAPP: self.__addNoteToApplication,
            modelactions.DELNOTEAPP: self.__delNoteFromApplication,
            modelactions.ADDNOTEHOST: self.__addNoteToHost,
            modelactions.DELNOTEHOST: self.__delNoteFromHost,
            modelactions.ADDNOTESRV: self.__addNoteToService,
            modelactions.DELNOTESRV: self.__delNoteFromService,
            modelactions.ADDNOTEVULN: self.__addNote,
            modelactions.DELNOTEVULN: self.__delNote,
            modelactions.ADDNOTE: self.__addNoteToModelObject,
            modelactions.DELNOTE: self.__delNoteFromModelObject,
            modelactions.ADDCREDSRV: self.__addCredToService,
            modelactions.DELCREDSRV: self.__delCredFromService,
            modelactions.ADDNOTENOTE: self.__addNoteToServiceNote,
            modelactions.DELNOTENOTE: self.__delNoteFromServiceNote,
            modelactions.EDITNOTE: self.__editNote,
            modelactions.EDITCRED: self.__editCred,
            modelactions.ADDCRED: self.__addCredToModelObject,
            modelactions.DELCRED: self.__delCredFromModelObject
        }

    def run(self):
        return self._main()

    def stop(self):
        """
        Sets the flag to stop daemon
        """
        self._stop = True

    def _dispatchActionWithLock(self, action_callback, *args):
        res = False
        self.__acquire_host_lock()
        try:
            res = action_callback(*args)
        except Exception:
            api.log("An exception occurred while dispatching an action (%r(%r)\n%s" %
                   (action_callback, args, traceback.format_exc()), "ERROR")
        finally:
            self.__release_host_lock()
        return res

    def _processAction(self, action, parameters, sync=False):
        """
        decodes and performs the action given
        It works kind of a dispatcher
        """
        if sync:
            self._sync_api_request = True

        api.devlog("_processAction - %s - parameters = %s" %
                  (action, str(parameters)))

        action_callback = self._actionDispatcher[action]
        res = self._dispatchActionWithLock(action_callback, *parameters)

        # finally we notify the widgets about this change
        #if res: # notify only if action was done successfuly
            #self._notifyModelUpdated(*parameters)
        #else:
        if not res:
            api.devlog("Action code %d failed. Parameters = %s" %
                      (action, str(parameters)))
        if sync:
            self._sync_api_request = False

    def getConflicts(self):
        conflicts = []
        for obj in self.objects_with_updates:
            conflicts += obj.getUpdates()
        return conflicts

    def resolveConflicts(self):
        notifier.conflictResolution(self.getConflicts())

    def resolveConflict(self, conflict, kwargs):
        if conflict.resolve(kwargs):
            if conflict.getModelObjectType() == "Interface":
                ipv4 = kwargs['ipv4']
                ipv6 = kwargs['ipv6']
                hostnames = kwargs['hostnames']

                if not ipv4['address'] in ["0.0.0.0", None]:
                    self.treeWordsTries.removeWord(ipv4['address'])
                    self.treeWordsTries.addWord(ipv4['address'])

                if not ipv6['address'] in ["0000:0000:0000:0000:0000:0000:0000:0000", None]:
                    self.treeWordsTries.removeWord(ipv6['address'])
                    self.treeWordsTries.addWord(ipv6['address'])

                for h in hostnames:
                    if h is not None:
                        self.treeWordsTries.removeWord(h)
                        self.treeWordsTries.addWord(h)

            notifier.conflictUpdate(-1)
            notifier.editHost(conflict.getFirstObject().getHost())
            #self._notifyModelUpdated()

    def removeConflictsByObject(self, obj):
        if obj in self.objects_with_updates:
            self.objects_with_updates.remove(obj)
        notifier.conflictUpdate(-len(obj.getUpdates()))

    def setSavingModel(self, value):
        api.devlog("setSavingModel: %s" % value)
        self._saving_model_flag = value
        if value:
            self._saving_model_lock.acquire()
        else:
            try:
                self._saving_model_lock.release()
            except RuntimeError:
                pass

    def _main(self):
        """
        The main method for the thread.
        The controller will be constantly checking a queue
        to see if new actions were added.
        This will make host addition and removal "thread-safe" and will
        avoid locking components that need to interact with the model
        """
        while True:
            # check if thread must finish
            if self._stop:
                return
            # first we check if there is a sync api request
            # or if the model is being saved/sync'ed
            # or if we have pending duplicated hosts that need to be
            # merged by the user
            if not self._sync_api_request and not self._saving_model_flag:

                self.processAction()
            else:
                # there is some object requesting for a sync api so we
                # sleep the thread execution for a moment to let others work
                # XXX: check if this time is not too much...
                time.sleep(0.01)

    def processAllPendingActions(self):
        [self.processAction() for i in range(self._pending_actions.qsize())]

    def processAction(self):
        # check the queue for new actions
        # if there is no new action it will block until timeout is reached
        try:
            # get new action or timeout (in secs)
            #TODO: timeout should be set through config
            current_action = self._pending_actions.get(timeout=2)
            action = current_action[0]
            parameters = current_action[1:]
            # dispatch the action
            self._processAction(action, parameters)
        except Queue.Empty:
            # if timeout was reached, just let the daemon run again
            # this is done just to be able to test the stop flag
            # because if we don't do it, the daemon will be blocked forever
            pass
        except Exception:
            getLogger(self).devlog("something strange happened... unhandled exception?")
            getLogger(self).devlog(traceback.format_exc())

    def sync_lock(self):
        self._sync_api_request = True
        self.__acquire_host_lock()

    def sync_unlock(self):
        self._sync_api_request = False
        self.__release_host_lock()

    def __addCategory(self, category):
        if category not in self._categories:
            self._categories[category] = []

    def getAllCategories(self):
        return self._categories

    def __delCategory(self, category, recursive=False):
        """
        Removes a given category from the model.
        If recursive is True it will also delete all hosts inside the category.
        If recursive is False it will first move the hosts in the category, to the
        default category "ALL" and then remove the desired category
        """
        #XXX: test this implementation...
        if category in self._categories:
            if recursive:
                for cat in self._categories[category]:
                    self.__delHost(cat)
            else:
                # we just move all hosts to category ALL and delete the category
                for host_id in self._categories[category]:
                    host = self._getValueByID("_hosts", host_id)
                    if host is not None:
                        host.categories.remove(category)
                        host.categories.append(CONF.getDefaultCategory())

     # adding, deleting and moving hosts in categories seem to be thread
     # safe operations, so we don't need to acquire any lock

    def __addHostToCategory(self, host, category):
        # we always try to create the category to make it safe.
        # If category exists it just won't do anything
        self.__addCategory(category)
        self._categories[category].append(host.getID())
        if category not in host.categories:
            host.registerCategory(category)

    def __delHostFromCategory(self, host, category):
        self._categories[category].remove(host.getID())
        host.removeCategory(category)

    def moveHostToCategory(self, hostname, category):
        host = self._getValueByID("_hosts", hostname)
        if host is not None:
            self.__delHostFromCategory(host, host.getCurrentCategory())
            self.__addHostToCategory(host, category)
            return True
        return False

    # TODO: CATEGORIES APIS are still missing...
    # also we need some "move" api to be used when drag & drop
    # exists in the host browser

    # TODO: >>> APIs <<< we have to know which plugin called the apis to store
    # in the history

    def __addPendingAction(self, *args):
        """
        Adds a new pending action to the queue
        Action is build with generic args tuple.
        The caller of this function has to build the action in the right
        way since no checks are preformed over args
        """
        new_action = args
        self._pending_actions.put(new_action)

    def addCategoryASYNC(self, category):
        self.__addPendingAction(modelactions.ADDCATEGORY, category)

    def addCategorySYNC(self, category):
        #self.sync_lock()
        #self.__addCategory(category)
        #self.sync_unlock()
        self._processAction(modelactions.ADDCATEGORY, category, sync=True)

    def delCategoryASYNC(self, category, recursive=False):
        self.__addPendingAction(modelactions.DELCATEGORY, category, recursive)

    def delCategorySYNC(self, category, recursive=False):
        self._processAction(modelactions.DELCATEGORY, [category, recursive], sync=True)

    def addUpdate(self, old_object, new_object):
        # Returns True if the update was resolved without user interaction
        res = True
        try:
            mergeAction = old_object.addUpdate(new_object)
            if mergeAction:
                if old_object not in self.objects_with_updates:
                    self.objects_with_updates.append(old_object)
                notifier.conflictUpdate(1)
                res = False
        except:
            res = False
            api.devlog("(%s).addUpdate(%s, %s) - failed" %
                      (self, old_object, new_object))
        return res

    def addHostASYNC(self, host, category=None, update=False, old_hostname=None):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        new host must be added to the model
        """
        self.__addPendingAction(modelactions.ADDHOST, host, category, update, old_hostname)

    def addHostSYNC(self, host, category=None, update=False, old_hostname=None):
        """
        SYNC API
        Adds a host directly to the model
        """
        self._processAction(modelactions.ADDHOST, [host, category, update, old_hostname], sync=True)

    def __addHost(self, host, category, update=False, old_hostname=None):
        res = False
        #self.__acquire_host_lock()
        old_host = self._getValueByID("_hosts", host.getID())
        if old_host:
            res = self.addUpdate(old_host, host)
        else:
            res = self._addValue("_hosts", host, update=update)
            if res:
                host.setParent(None)

                if category is None:
                    category = CONF.getDefaultCategory()
                elif category not in self._categories:
                    self.__addCategory(category)

                self.treeWordsTries.addWord(host.getName())
                self.treeWordsTries.addWord(category)

                self.__addHostToCategory(host, category)
                notifier.addHost(host)
            #self.__release_host_lock()
        return res

    def delHostASYNC(self, host):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        particular host must be removed from the model
        """
        self.__addPendingAction(modelactions.DELHOST, host)

    def delHostSYNC(self, host):
        """
        SYNC API
        Deletes a host from model
        """
        self._processAction(modelactions.DELHOST, [host], sync=True)

    def __clearHost(self, host):
        self.__clearModelObject(host)
        self.__delInterfaces(host)

    def __clearInterface(self, interface):
        self.__clearModelObject(interface)
        self.__delServices(interface)

    def __clearApplication(self, application):
        self.__clearModelObject(application)
        self.__delServices(application)

    def __clearService(self, service):
        self.__clearModelObject(service)

    def __clearNote(self, note):
        self.__clearModelObject(note)

    def __clearVuln(self, vuln):
        self.__clearModelObject(vuln)

    def __clearCred(self, cred):
        self.__clearModelObject(cred)

    def __clearModelObject(self, modelObj):
        self.removeConflictsByObject(modelObj)
        self.__delNotes(modelObj)
        self.__delVulns(modelObj)
        self.__delCreds(modelObj)

    def __delNotes(self, modelObj):
        for note in list(modelObj.getNotes()):
            self.__clearNote(note)
            modelObj.delNote(note.getID())

    def __delVulns(self, modelObj):
        for vuln in list(modelObj.getVulns()):
            self.__clearVuln(vuln)
            modelObj.delVuln(vuln.getID())

    def __delCreds(self, modelObj):
        for cred in list(modelObj.getCreds()):
            self.__clearCred(cred)
            modelObj.delCred(cred.getID())

    def __delInterfaces(self, modelObj):
        for interface in list(modelObj.getAllInterfaces()):
            self.__clearInterface(interface)
            modelObj.delInterface(interface.getID())

    def __delServices(self, modelObj):
        for service in list(modelObj.getAllServices()):
            self.__clearService(service)
            modelObj.delService(service.getID())

    def __delHost(self, host_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            #res = self._delValue("_hosts", host.getID())
            #if res:
            self.__clearHost(host)
            #this next method removes the host
            self._workspace.remove(host)
            self.treeWordsTries.removeWord(host.getName())
            for i in host.getAllInterfaces():
                for h in i.getHostnames():
                    self.treeWordsTries.removeWord(h)
            notifier.delHost(host.getID())
            res = True

        return res

    def _delValue(self, attrName, valID):
        # attribute passed as a parameter MUST BE  the name
        # of an internal attribute which is a dictionary indexed
        # with a string ID
        api.devlog("(%s)._delValue(%s, %s)" % (self, attrName, valID))
        ref = self.__getattribute__(attrName)
        api.devlog("ref.keys() = %s" % ref.keys())
        if valID in ref:
            del ref[valID]
            return True

        hash_id = get_hash([valID])
        if hash_id in ref:
            del ref[hash_id]
            return True

        for element in ref.itervalues():
            if valID == element.name:
                del ref[element.getID()]
                return True

        # none of the ids were found
        return False

    def editHostSYNC(self, host, name, description, os, owned):
        """
        SYNC API
        Modifies a host from model
        """
        self._processAction(modelactions.EDITHOST, [host, name, description, os, owned], sync=True)

    def __editHost(self, host, name=None, description=None, os=None, owned=None):
        res = False
        #host = self._getValueByID("_hosts", host)
        if host is not None:
            host.updateAttributes(name, description, os, owned)
            res = True
            notifier.editHost(host)
        return res

    def addInterfaceASYNC(self, host, interface, update=False):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        new interface must be added to a specific host
        """
        self.__addPendingAction(modelactions.ADDINTERFACE, host, interface)

    def addInterfaceSYNC(self, host, interface, update=False):
        """
        SYNC API
        Adds interface directly to the model
        """
        self._processAction(modelactions.ADDINTERFACE, [host, interface], sync=True)

    def __addInterfaceToHost(self, host_id, interface):
        res = False
        #self.__acquire_host_lock()
        # if host is not found nothing is done with the new interface
        try:
            host = self._getValueByID("_hosts", host_id)
            if host is not None:
                old_interface = host.getInterface(interface.getID())
                if old_interface:
                    res = self.addUpdate(old_interface, interface)
                else:
                    res = host.addInterface(interface)

                if res:
                    self.treeWordsTries.addWord(interface.name)
                    for h in interface.getHostnames():
                        self.treeWordsTries.addWord(h)
                    notifier.editHost(host)
        except Exception as e:
            raise e
        #self.__release_host_lock()
        return res

    def delInterfaceASYNC(self, host, interface_name):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        particular host must be removed from the model
        """
        self.__addPendingAction(modelactions.DELINTERFACE, host, interface_name)

    def delInterfaceSYNC(self, host, interface_name):
        """
        SYNC API
        Deletes an interface from model
        """
        self._processAction(modelactions.DELINTERFACE, [host, interface_name], sync=True)

    def __delInterfaceFromHost(self, host_id, interface_id):
        res = False
        #self.__acquire_host_lock()
        # DO NOT USE self.getHost because it will cause a deadlock
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            interface = host.getInterface(interface_id)
            if interface is not None:
                res = host.delInterface(interface.getID())
                self.__clearInterface(interface)
                self.treeWordsTries.removeWord(interface.name)
                for h in interface.getHostnames():
                    self.treeWordsTries.removeWord(h)
                notifier.editHost(host)

        return res

    def editInterfaceSYNC(self, interface, name, description, hostnames,
                          mac, ipv4, ipv6, network_segment,
                          amount_ports_opened, amount_ports_closed,
                          amount_ports_filtered, owned):
        """
        SYNC API
        Modifies an interface from model
        """
        self._processAction(modelactions.EDITINTERFACE,
                            [interface, name, description, hostnames,
                             mac, ipv4, ipv6, network_segment,
                             amount_ports_opened, amount_ports_closed,
                             amount_ports_filtered, owned], sync=True)

    def __editInterface(self, interface, name, description, hostnames,
                        mac, ipv4, ipv6, network_segment,
                        amount_ports_opened, amount_ports_closed,
                        amount_ports_filtered, owned):
        res = False
        if interface is not None:
            interface.updateAttributes(name, description, hostnames, mac,
                                       ipv4, ipv6, network_segment,
                                       amount_ports_opened,
                                       amount_ports_closed,
                                       amount_ports_filtered, owned)

            if not ipv4['address'] in ["0.0.0.0", None]:
                self.treeWordsTries.removeWord(ipv4['address'])
                self.treeWordsTries.addWord(ipv4['address'])

            if not ipv6['address'] in ["0000:0000:0000:0000:0000:0000:0000:0000", None]:
                self.treeWordsTries.removeWord(ipv6['address'])
                self.treeWordsTries.addWord(ipv6['address'])

            for h in hostnames:
                if h is not None:
                    self.treeWordsTries.removeWord(h)
                    self.treeWordsTries.addWord(h)
            notifier.editHost(interface.getHost())
            res = True
        return res

    def addApplicationASYNC(self, host, application):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        new application must be added to a specific host
        """
        self.__addPendingAction(modelactions.ADDAPPLICATION, host, application)

    def addApplicationSYNC(self, host, application):
        """
        SYNC API
        Adds an application to a specific host
        directly to the model
        """
        self._processAction(modelactions.ADDAPPLICATION, [host, application], sync=True)

    def __addApplication(self, host_id, application):
        res = False
        #self.__acquire_host_lock()
        # if host is not found nothing is done with the new interface
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            old_application = host.getApplication(application.getID())
            if old_application:
                res = self.addUpdate(old_application, application)
            else:
                res = host.addApplication(application)
                notifier.editHost(host)
        #self.__release_host_lock()
        return res

    def delApplicationASYNC(self, host, app_name):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        particular host must be removed from the model
        """
        self.__addPendingAction(modelactions.DELAPPLICATION, host, app_name)

    def delApplicationSYNC(self, host, app_name):
        """
        SYNC API
        Deletes an application from the model
        """
        self._processAction(modelactions.DELAPPLICATION, [host, app_name], sync=True)

    def __delApplication(self, host_id, app_id):
        res = False
        #self.__acquire_host_lock()
        # DO NOT USE self.getHost because it will cause a deadlock
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            application = host.getApplication(app_id)
            if application is not None:
                self.__clearApplication(application)
                res = host.delApplication(application.getID())
                notifier.editHost(host)

        #self.__release_host_lock()
        return res

    def editApplicationSYNC(self, application, name, description, status, version, owned):
        """
        SYNC API
        Modifies a host from model
        """
        self._processAction(modelactions.EDITAPPLICATION, [application, name, description, status, version, owned], sync=True)

    def __editApplication(self, application, name=None, description=None, status=None, version=None, owned=None):
        res = False
        #host = self._getValueByID("_hosts", host)
        if application is not None:
            application.updateAttributes(name, description, status, version, owned)
            notifier.editHost(application.getHost())
            res = True
        return res

    def addServiceToInterfaceASYNC(self, host, interface_name, newService):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        new services must be added to a specific host in a specific interface
        """
        self.__addPendingAction(modelactions.ADDSERVICEINT, host, interface_name, newService)

    def addServiceToInterfaceSYNC(self, host_id, interface_id, newService):
        """
        SYNC API
        Adds a service to a specific host in a specific interface
        directly to the model
        """
        self._processAction(modelactions.ADDSERVICEINT, [host_id, interface_id, newService], sync=True)

    def addServiceToApplicationASYNC(self, host, appname, newService):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        new services must be added to a specific host in a specific interface
        """
        self.__addPendingAction(modelactions.ADDSERVICEAPP, host, appname, newService)

    def addServiceToApplicationSYNC(self, host, appname, newService):
        """
        SYNC API
        Adds a service to a specific host in a specific application
        directly to the model
        """
        self._processAction(modelactions.ADDSERVICEAPP, [host, appname, newService], sync=True)

    def __addServiceToInterface(self, host_id, interface_id, service):
        res = False
        #self.__acquire_host_lock()
        # if host is not found nothing is done with the new interface
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            interface = host.getInterface(interface_id)
            if interface is not None:
                old_service = interface.getService(service.getID())
                if old_service:
                    res = self.addUpdate(old_service, service)
                else:
                    res = interface.addService(service)
                    if res:
                        notifier.editHost(host)
        else:
            api.devlog("__addService failed. Host ID: %s not found" % host_id)
        return res

    def __addServiceToApplication(self, host_id, application_id, service):
        res = False
        #self.__acquire_host_lock()
        # if host is not found nothing is done with the new interface
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            application = host.getApplication(application_id)
            if application is not None:
                old_service = application.getService(service.getID())
                if old_service:
                    res = self.addUpdate(old_service, service)
                else:
                    res = application.addService(service)
                    if res:
                        notifier.editHost(host)
        else:
            api.devlog("__addService failed. Host ID: %s not found" % host_id)
        return res

    def delServiceFromInterfaceASYNC(self, host, interface, service):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        particular service in a host and interface must be removed from the
        model Interface parameter can be "ALL"
        """
        self.__addPendingAction(modelactions.DELSERVICEINT, host, interface, service)

    def delServiceFromInterfaceSYNC(self, host, interface, service):
        """
        SYNC API
        Delete a service in a host and interface from the model
        """
        self._processAction(modelactions.DELSERVICEINT, [host, interface, service], sync=True)

    def delServiceFromApplicationASYNC(self, host, appname, service):
        """
        ASYNC API
        Adds an action to the ModelController actions queue indicating a
        particular service in a host and interface must be removed from the model
        appname parameter can be "ALL"
        """
        self.__addPendingAction(modelactions.DELSERVICEAPP, host, appname, service)

    def delServiceFromApplicationSYNC(self, host, appname, service):
        """
        SYNC API
        Delete a service in a host and application from the model
        """
        self._processAction(modelactions.DELSERVICEAPP, [host, appname, service], sync=True)

    def delServiceFromHostASYNC(self, host, service):
        self.__addPendingAction(modelactions.DELSERVICEHOST, host, service)

    def delServiceFromHostSYNC(self, host, service):
        """
        SYNC API
        Delete a service from the model
        """
        self._processAction(modelactions.DELSERVICEHOST, [host, service], sync=True)

    def __delServiceFromInterface(self, host_id, interface_id=None, service_id=None):
        res = False
        api.devlog("ModelController.__delServiceFromInterface(%s, %s, %s)" %
                  (host_id, interface_id, service_id))
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            if service_id is not None:
                interface = host.getInterface(interface_id)
                if interface is not None:
                    service = interface.getService(service_id)
                    self.__clearService(service)
                    res = interface.delService(service_id)
                    if res:
                        notifier.editHost(host)
        return res

    def __delServiceFromApplication(self, host_id, application_id=None, service_id=None):
        res = False
        api.devlog("ModelController.__delService(%s, %s, %s)" %
                  (host_id, application_id, service_id))
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            if service_id is not None and item_id is not None:
                application = host.getInterface(application_id)
                if application is not None:
                    service = interface.getService(service_id)
                    self.__clearService(service)
                    res = application.delService(service_id)
                    if res:
                        notifier.editHost(host)
        return res

    def __delService(self, host_id, service_id=None):
        res = False
        api.devlog("ModelController.__delService(%s, %s)" %
                  (host_id, service_id))
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            self.__clearService(service)
            res = host.delService(service_id)
            if res:
                notifier.editHost(host)

        return res

    def editServiceSYNC(self, service, name, description, protocol, ports, status, version, owned):
        """
        SYNC API
        Modifies a host from model
        """
        self._processAction(modelactions.EDITSERVICE, [service, name, description, protocol, ports, status, version, owned], sync=True)

    def editServiceASYNC(self, service, name, description, protocol, ports, status, version, owned):
        """
        ASYNC API
        Modifies a service from model
        """
        self.__addPendingAction(modelactions.EDITSERVICE, [service, name, description, protocol, ports, status, version, owned])

    def __editService(self, service, name=None, description=None,
                      protocol=None, ports=None, status=None,
                      version=None, owned=None):
        res = False
        if service is not None:
            service.updateAttributes(name, description, protocol, ports, status, version, owned)
            notifier.editHost(service.getHost())
            res = True
        return res

    def addVulnToInterfaceASYNC(self, host, intname, newVuln):
        self.__addPendingAction(modelactions.ADDVULNINT, host, intname, newVuln)

    def addVulnToInterfaceSYNC(self, host, intname, newVuln):
        self._processAction(modelactions.ADDVULNINT, [host, intname, newVuln], sync=True)

    def addVulnToApplicationASYNC(self, host, appname, newVuln):
        self.__addPendingAction(modelactions.ADDVULNAPP, host, appname, newVuln)

    def addVulnToApplicationSYNC(self, host, appname, newVuln):
        self._processAction(modelactions.ADDVULNAPP, [host, appname, newVuln], sync=True)

    def addVulnToHostASYNC(self, host, newVuln):
        self.__addPendingAction(modelactions.ADDVULNHOST, host, newVuln)

    def addVulnToHostSYNC(self, host, newVuln):
        self._processAction(modelactions.ADDVULNHOST, [host, newVuln], sync=True)

    def addVulnToServiceASYNC(self, host, srvname, newVuln):
        self.__addPendingAction(modelactions.ADDVULNSRV, host, srvname, newVuln)

    def addVulnToServiceSYNC(self, host, srvname, newVuln):
        self._processAction(modelactions.ADDVULNSRV, [host, srvname, newVuln], sync=True)

    def addVulnSYNC(self, model_object, newVuln):
        self._processAction(modelactions.ADDVULN, [model_object, newVuln], sync=True)

    def addVulnWebToServiceASYNC(self, host, srvname, newVuln):
        self.__addPendingAction(modelactions.ADDVULNWEBSRV, host, srvname, newVuln)

    def addVulnWebToServiceSYNC(self, host, srvname, newVuln):
        self._processAction(modelactions.ADDVULNWEBSRV, [host, srvname, newVuln], sync=True)

    def __addVulnToModelObject(self, model_object, vuln=None):
        res = False
        if model_object is not None:
            old_vuln = model_object.getVuln(vuln.getID())
            if old_vuln:
                res = self.addUpdate(old_vuln, vuln)
            else:
                res = model_object.addVuln(vuln)
                if res:
                    notifier.editHost(model_object.getHost())
        return res

    def __addVulnerabilityToHost(self, host_id, vuln=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None and vuln is not None:
            old_vuln = host.getVuln(vuln.getID())
            if old_vuln:
                res = self.addUpdate(old_vuln, vuln)
            else:
                res = host.addVuln(vuln)
                if res:
                    notifier.editHost(host)
        api.devlog("__addVulnerabilityToHost result = %s" % res)
        return res

    def __addVulnerabilityToApplication(self, host_id, application_id, vuln=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None and application_id is not None and vuln is not None:
            application = host.getApplication(application_id)
            if application is not None:
                old_vuln = application.getVuln(vuln.getID())
                if old_vuln:
                    res = self.addUpdate(old_vuln, vuln)
                else:
                    res = application.addVuln(vuln)
                    if res:
                        notifier.editHost(application.getHost())
        api.devlog("__addVulnerabilityToApplication result = %s" % res)
        return res

    def __addVulnerabilityToInterface(self, host_id, interface_id, vuln=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None and interface_id is not None and vuln is not None:
            interface = host.getInterface(interface_id)
            if interface is not None:
                old_vuln = interface.getVuln(vuln.getID())
                if old_vuln:
                    res = self.addUpdate(old_vuln, vuln)
                else:
                    res = interface.addVuln(vuln)
                    if res:
                        notifier.editHost(interface.getHost())
        api.devlog("__addVulnerabilityToInterface result = %s" % res)
        return res

    def __addVulnerabilityToService(self, host_id, service_id, vuln=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None and service_id is not None and vuln is not None:
            service = host.getService(service_id)
            if service is not None:
                old_vuln = service.getVuln(vuln.getID())
                if old_vuln:
                    res = self.addUpdate(old_vuln, vuln)
                else:
                    res = service.addVuln(vuln)
                    if res:
                        notifier.editHost(service.getHost())
        api.devlog("__addVulnerabilityToService result = %s" % res)
        return res

    def delVulnFromApplicationASYNC(self, hostname, appname, vuln):
        self.__addPendingAction(modelactions.DELVULNAPP, hostname, appname, vuln)

    def delVulnFromApplicationSYNC(self, hostname, appname, vuln):
        self._processAction(modelactions.DELVULNAPP, [hostname, appname, vuln], sync=True)

    def delVulnFromInterfaceASYNC(self, hostname, intname, vuln):
        self.__addPendingAction(modelactions.DELVULNINT, hostname, intname, vuln)

    def delVulnFromInterfaceSYNC(self, hostname, intname, vuln):
        self._processAction(modelactions.DELVULNINT, [hostname,intname, vuln], sync=True)

    def delVulnFromHostASYNC(self, hostname, vuln):
        self.__addPendingAction(modelactions.DELVULNHOST, hostname, vuln)

    def delVulnFromHostSYNC(self, hostname, vuln):
        self._processAction(modelactions.DELVULNHOST, [hostname, vuln], sync=True)

    def delVulnFromServiceASYNC(self, hostname, srvname, vuln):
        self.__addPendingAction(modelactions.DELVULNSRV, hostname, srvname, vuln)

    def delVulnFromServiceSYNC(self, hostname, srvname, vuln):
        self._processAction(modelactions.DELVULNSRV, [hostname, srvname, vuln], sync=True)

    def delVulnSYNC(self, model_object, vuln_id):
        self._processAction(modelactions.DELVULN, [model_object, vuln_id], sync=True)

    def __delVulnFromModelObject(self, model_object, vuln_id):
        res = False
        if model_object is not None:
            vuln = model_object.getVuln(vuln_id)
            self.__clearVuln(vuln)
            res = model_object.delVuln(vuln_id)
            if res:
                notifier.editHost(model_object.getHost())
        return res

    def __delVulnerabilityFromHost(self, host_id, vuln_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            vuln = host.getVuln(vuln_id)
            self.__clearVuln(vuln)
            res = host.delVuln(vuln_id)
            if res:
                notifier.editHost(host)
        return res

    def __delVulnerabilityFromInterface(self, host_id, interface_id, vuln_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            interface = host.getInterface(interface_id)
            if interface is not None:
                vuln = interface.getVuln(vuln_id)
                self.__clearVuln(vuln)
                res = interface.delVuln(vuln_id)
                if res:
                    notifier.editHost(host)
        return res

    def __delVulnerabilityFromApplication(self, host_id, application_id, vuln_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            application = host.getApplication(application_id)
            if application is not None:
                vuln = application.getVuln(vuln_id)
                self.__clearVuln(vuln)
                res = application.delVuln(vuln_id)
                if res:
                    notifier.editHost(host)
        return res

    def __delVulnerabilityFromService(self, host_id, service_id, vuln_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            if service is not None:
                vuln = service.getVuln(vuln_id)
                self.__clearVuln(vuln)
                res = service.delVuln(vuln_id)
                if res:
                    notifier.editHost(host)
        return res

    def editVulnSYNC(self, vuln, name, desc, severity, refs):
        self._processAction(modelactions.EDITVULN, [vuln, name, desc, severity, refs], sync=True)

    def editVulnASYNC(self, vuln, name, desc, severity, refs):
        self.__addPendingAction(modelactions.EDITVULN, [vuln, name, desc, severity, refs])

    def editVulnWebSYNC(self, vuln, name, desc, website, path, refs, severity,
                        request, response, method, pname, params, query,
                        category):
        self._processAction(modelactions.EDITVULN,
                            [vuln, name, desc, website, path, refs, severity,
                             request, response, method, pname, params, query,
                             category], sync=True)

    def editVulnWebASYNC(self, vuln, name, desc, website, path, refs,
                         severity, request, response, method, pname,
                         params, query, category):
        self.__addPendingAction(modelactions.EDITVULN,
                                [vuln, name, desc, website, path, refs,
                                 severity, request, response, method,
                                 pname, params, query, category])

    def __editVulnerability(self, vuln, *args):
        res = False
        if vuln is not None:
            vuln.updateAttributes(*args)
            res = True
            if res:
                notifier.editHost(vuln.getHost())
        return res

    # Note
    def addNoteToInterfaceASYNC(self, host, intname, newNote):
        self.__addPendingAction(modelactions.ADDNOTEINT, host, intname, newNote)

    def addNoteToInterfaceSYNC(self, host, intname, newNote):
        self._processAction(modelactions.ADDNOTEINT, [host, intname, newNote], sync=True)

    def addNoteToApplicationASYNC(self, host, appname, newNote):
        self.__addPendingAction(modelactions.ADDNOTEAPP, host, appname, newNote)

    def addNoteToApplicationSYNC(self, host, appname, newNote):
        self._processAction(modelactions.ADDNOTEAPP, [host, appname, newNote], sync=True)

    def addNoteToHostASYNC(self, host, newNote):
        self.__addPendingAction(modelactions.ADDNOTEHOST, host, newNote)

    def addNoteToHostSYNC(self, host, newNote):
        self._processAction(modelactions.ADDNOTEHOST, [host, newNote], sync=True)

    def addNoteToServiceASYNC(self, host, srvname, newNote):
        self.__addPendingAction(modelactions.ADDNOTESRV, host, srvname, newNote)

    def addNoteToNoteASYNC(self, host, srvname, note_id, newNote):
        self.__addPendingAction(modelactions.ADDNOTENOTE, host, srvname, note_id, newNote)

    def addNoteToServiceSYNC(self, host, srvname, newNote):
        self._processAction(modelactions.ADDNOTESRV, [host, srvname, newNote], sync=True)

    def addNoteSYNC(self, model_object, newNote):
        self._processAction(modelactions.ADDNOTE, [model_object, newNote], sync=True)

    def delNoteFromApplicationASYNC(self, hostname, appname, note):
        self.__addPendingAction(modelactions.DELNOTEAPP, hostname, appname, note)

    def delNoteFromApplicationSYNC(self, hostname, appname, note):
        self._processAction(modelactions.DELNOTEAPP, [hostname, appname, note], sync=True)

    def delNoteFromInterfaceASYNC(self, hostname, intname, note):
        self.__addPendingAction(modelactions.DELNOTEINT, hostname, intname, note)

    def delNoteFromInterfaceSYNC(self, hostname, intname, note):
        self._processAction(modelactions.DELNOTEINT, [hostname, intname, note], sync=True)

    def delNoteFromHostASYNC(self, hostname, note):
        self.__addPendingAction(modelactions.DELNOTEHOST, hostname, note)

    def delNoteFromHostSYNC(self, hostname, note):
        self._processAction(modelactions.DELNOTEHOST, [hostname, note], sync=True)

    def delNoteFromServiceASYNC(self, hostname, srvname, note):
        self.__addPendingAction(modelactions.DELNOTESRV, hostname, srvname, note)

    def delNoteFromServiceSYNC(self, hostname, srvname, note):
        self._processAction(modelactions.DELNOTESRV, [hostname, srvname, note], sync=True)

    def delNoteSYNC(self, model_object, note_id):
        self._processAction(modelactions.DELNOTE, [model_object, note_id], sync=True)

    def addCredToServiceASYNC(self, host, srvname, newCred):
        self.__addPendingAction(modelactions.ADDCREDSRV, host, srvname, newCred)

    def addCredToServiceSYNC(self, host, srvname, newCred):
        self._processAction(modelactions.ADDCREDSRV, [host, srvname, newCred], sync=True)

    def delCredFromServiceASYNC(self, hostname, srvname, cred):
        self.__addPendingAction(modelactions.DELCREDSRV, hostname, srvname, cred)

    def delCredFromServiceSYNC(self, hostname, srvname, note):
        self._processAction(modelactions.DELCREDSRV, [hostname, srvname, cred], sync=True)

    def __addNote(self, action, host_name, item_name=None, note=None, note_id=None):
        res = False
        #self.__acquire_host_lock()
        # if host is not found nothing is done with the new interface
        host = self._getValueByID("_hosts", host_name)
        if host is not None:
            if action == modelactions.ADDNOTEHOST:
                res = host.addNote(note)
            else:
                if action == modelactions.ADDNOTEAPP:
                    _getOne = host.getApplication
                elif action == modelactions.ADDNOTEINT:
                    _getOne = host.getInterface
                elif action == modelactions.ADDNOTESRV:
                    _getOne = host.getService
                elif action == modelactions.ADDNOTENOTE:
                    service = host.getService(item_name)
                    _getOne = service.getNote
                    item_name = note_id

                item = _getOne(item_name)
                if item is not None:
                    res = item.addNote(note)
                else:
                    api.devlog("__addNote: GetNote ID error" + str(item))
            notifier.editHost(host)

        else:
            api.devlog("__addNote failed. Hostname: %s not found" % host_name)
        return res

    def __addNoteToModelObject(self, model_object, note=None):
        res = False
        if model_object is not None:
            old_note = model_object.getNote(note.getID())
            if old_note:
                res = self.addUpdate(old_note, note)
            else:
                res = model_object.addNote(note)
                if res:
                    notifier.editHost(model_object.getHost())
        return res

    def __addNoteToHost(self, host_id, note=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            old_note = host.getNote(note.getID())
            if old_note:
                res = self.addUpdate(old_note, note)
            else:
                res = host.addNote(note)
                if res:
                    notifier.editHost(host)
        else:
            api.devlog("__addNoteToHost failed. Hostname: %s not found" %
                       host_id)
        return res

    def __addNoteToInterface(self, host_id, interface_id, note=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            interface = host.getInterface(interface_id)
            if interface is not None:
                old_note = interface.getNote(note.getID())
                if old_note:
                    res = self.addUpdate(old_note, note)
                else:
                    res = interface.addNote(note)
                    if res:
                        notifier.editHost(host)
        else:
            api.devlog("__addNote failed. Host ID: %s not found" % host_id)
        return res

    def __addNoteToApplication(self, host_id, application_id, note=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            application = host.getApplication(application_id)
            if application is not None:
                old_note = application.getNote(note.getID())
                if old_note:
                    res = self.addUpdate(old_note, note)
                else:
                    res = application.addNote(note)
                    if res:
                        notifier.editHost(host)
        else:
            api.devlog("__addNote failed. Host ID: %s not found" % host_id)
        return res

    def __addNoteToService(self, host_id, service_id, note=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            if service is not None:
                old_note = service.getNote(note.getID())
                if old_note:
                    res = self.addUpdate(old_note, note)
                else:
                    res = service.addNote(note)
                    if res:
                        notifier.editHost(host)
        else:
            api.devlog("__addNote failed. Host ID: %s not found" % host_id)
        return res

    def __addNoteToServiceNote(self, host_id, service_id, note_id, note=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            if service is not None:
                service_note = service.getNote(note_id)
                if note is not None:
                    old_note = service_note.getNote(note.getID())
                    if old_note:
                        res = self.addUpdate(old_note, note)
                    else:
                        res = service_note.addNote(note)
                        if res:
                            notifier.editHost(host)
        else:
            api.devlog("__addNote failed. Host ID: %s not found" % host_id)
        return res

    #DEPRECTED METHOD
    def __delNote(self, action, host_name, item_name, note_id):

        res = False
        # DO NOT USE self.getHost because it will cause a deadlock
        # if interface name is ALL then we delete the service from
        # the whole host
        host = self._getValueByID("_hosts", host_name)
        if host is not None:
            if action == modelactions.DELNOTEHOST:
                res = host.delNote(note_id)
            else:

                if action == modelactions.DELNOTEAPP:
                    _getOne = host.getApplication
                    _getAll = host.getAllApplications
                    _delItem = host.delApplication
                elif action == modelactions.DELNOTEINT:
                    _getOne = host.getInterface
                    _getAll = host.getAllInterfaces
                    _delItem = host.delInterface
                elif action == modelactions.DELNOTESRV:
                    _getOne = host.getService
                    _getAll = host.getAllServices
                    _delItem = host.delService

                if item_name != "ALL":
                    item = _getOne(item_name)
                    # if the service is really in that interface we delete it
                    # since there are cross references we have to delete the
                    # service from the interface and if there aren't any other references
                    # in any other interface then delete it from the host
                    if item is not None:
                        res = item.delNote(note_id)
                else:
                    # remove from all interfaces
                    for item in _getAll():
                        res = item.delNote(service.getID())
            notifier.editHost(host)

        self.__release_host_lock()
        return res

    def __delNoteFromModelObject(self, model_object, note_id):
        res = False
        if model_object is not None:
            note = model_object.getNote(note_id)
            self.__clearNote(note)
            res = model_object.delNote(note_id)
            if res:
                notifier.editHost(model_object.getHost())
        return res

    def __delNoteFromHost(self, host_id, note_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            note = host.getNote(note_id)
            self.__clearNote(note)
            res = host.delNote(note_id)
            if res:
                notifier.editHost(host)
        return res

    def __delNoteFromInterface(self, host_id, interface_id, note_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            interface = host.getInterface(interface_id)
            if interface is not None:
                note = interface.getNote(note_id)
                self.__clearNote(note)
                res = interface.delNote(note_id)
                if res:
                    notifier.editHost(host)
        return res

    def __delNoteFromApplication(self, host_id, application_id, note_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            application = host.getApplication(application_id)
            if application is not None:
                note = application.getNote(note_id)
                self.__clearNote(note)
                res = application.delNote(note_id)
                if res:
                    notifier.editHost(host)
        return res

    def __delNoteFromService(self, host_id, service_id, note_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            if service is not None:
                note = service.getNote(note_id)
                self.__clearNote(note)
                res = service.delNote(note_id)
                if res:
                    notifier.editHost(host)
        return res

    def __delNoteFromServiceNote(self, host_id, service_id, note_id, deep_note_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            if service is not None:
                note = service.getNote(note_id)
                if note is not None:
                    deep_note = note.getNote(note_id)
                    self.__clearNote(deep_note)
                    res = note.delNote(deep_note_id)
                    if res:
                        notifier.editHost(host)
        return res

    def editNoteSYNC(self, note, name, text):
        self._processAction(modelactions.EDITNOTE, [note, name, text], sync=True)

    def editNoteASYNC(self, note, name, text):
        self.__addPendingAction(modelactions.EDITNOTE, [note, name, text])

    def __editNote(self, note, name=None, text=None):
        res = False
        if note is not None:
            note.updateAttributes(name, text)
            res = True
            if res:
                notifier.editHost(note.getHost())
        return res

    def editCredSYNC(self, cred, username, password):
        self._processAction(modelactions.EDITCRED, [cred, username, password], sync=True)

    def editCredASYNC(self, cred, username, password):
        self.__addPendingAction(modelactions.EDITCRED, [cred, username, password])

    def __editCred(self, cred, username=None, password=None):
        res = False
        if cred is not None:
            cred.updateAttributes(username, password)
            res = True
            if res:
                notifier.editHost(cred.getHost())
        return res

    def addCredSYNC(self, model_object, newCred):
        self._processAction(modelactions.ADDCRED, [model_object, newCred], sync=True)

    def __addCredToModelObject(self, model_object, cred=None):
        res = False
        if model_object is not None:
            old_cred = model_object.getCred(cred.getID())
            if old_cred:
                res = self.addUpdate(old_cred, cred)
            else:
                res = model_object.addCred(cred)
                if res:
                    notifier.editHost(model_object.getHost())
        return res

    def delCredSYNC(self, model_object, cred_id):
        self._processAction(modelactions.DELCRED, [model_object, cred_id], sync=True)

    def __delCredFromModelObject(self, model_object, cred_id):
        res = False
        if model_object is not None:
            cred = model_object.getCred(cred_id)
            self.__clearCred(cred)
            res = model_object.delCred(cred_id)
            if res:
                notifier.editHost(model_object.getHost())
        return res

    def __addCredToService(self, host_id, service_id, cred=None):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            if service is not None:
                old_cred = service.getCred(cred.getID())
                if old_cred:
                    res = self.addUpdate(old_cred, cred)
                else:
                    res = service.addCred(cred)
                    if res:
                        notifier.editHost(host)
        else:
            api.devlog("__addCred failed. Host ID: %s not found" % host_id)
        return res

    def __delCredFromService(self, host_id, service_id, cred_id):
        res = False
        host = self._getValueByID("_hosts", host_id)
        if host is not None:
            service = host.getService(service_id)
            if service is not None:
                cred = service.getCred(cred_id)
                self.__clearCred(cred)
                res = service.delCred(cred_id)
                if res:
                    notifier.editHost(host)
        return res

    def getHost(self, name):
        self.__acquire_host_lock()
        h = self._getValueByID("_hosts", name)
        self.__release_host_lock()
        return h

    def getHostsCount(self):
        return len(self._hosts)

    def getAllHosts(self, mode=0):
        """
        return all interfaces in this host
        mode = 0 returns a list of hosts objects
        mode = 1 returns a dictionary of hosts objects with their id as key
        """
        #TODO: this can be a problem because if a host is deleted
        # while another is using this host list, then the information
        # provided here would be wrong
        self.__acquire_host_lock()
        #hosts = self.__getattribute__("_hosts").getContainer()
        hosts = self.__getattribute__("_hosts").values()
        self.__release_host_lock()
        return hosts

    def setWorkspace(self, workspace):
        self._workspace = workspace
        self._hosts = self._workspace.getContainee()
        self._workspace.load()
        self.createIndex(self._hosts)
        notifier.workspaceChanged(self._workspace)

    def createIndex(self, hosts):
        self.treeWordsTries = TreeWordsTries()
        self.treeWordsTries.clear()
        for k in hosts.keys():
            h = hosts[k]
            self.treeWordsTries.addWord(h.getName())
            for intr in h.getAllInterfaces():
                ipv4 = intr.ipv4
                ipv6 = intr.ipv6
                if not ipv4['address'] in ["0.0.0.0", None]:
                    self.treeWordsTries.addWord(ipv4['address'])

                if not ipv6['address'] in ["0000:0000:0000:0000:0000:0000:0000:0000", None]:
                    self.treeWordsTries.addWord(ipv6['address'])

                for hostname in intr.getHostnames():
                    self.treeWordsTries.addWord(hostname)

    def getWorkspace(self):
        return self._workspace

    def checkPermissions(self, op):
        ## In order to use the decorator passPermissionsOrRaise
        ## The client should implement checkPermissions method.
        self.__sec.checkPermissions(op)

    def getWorkspaceSyncronizer(self):
        return WorkspaceSyncronizer(self.getWorkspace())

    #@passPermissionsOrRaise
    @lockModel
    def syncActiveWorkspace(self):
        if len(self.getWorkspace().getConflicts()):
            #There are some conflicts
            notifier.showPopup("Sync Failed! \nYou should check if there are some conflicts to resolve")
            return False

        ws = self.getWorkspaceSyncronizer()
        if not ws.sync():
            notifier.showPopup("Sync Failed! \nYou should check if there are some conflicts to resolve")
            return False
        notifier.workspaceLoad(self.getAllHosts())
        return True

########NEW FILE########
__FILENAME__ = diff
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
class ModelObjectDiff(object):
    def __init__(self, objLeft, objRight):
        if not isinstance(objLeft, objRight.__class__):
            raise Exception("Cannot compare objects of different classes. objLeft (%s) vs objRight (%s)"
                            % (objLeft.__class__.__name__, objRight.__class__.__name__))
        self.obj1, self.obj2 = objLeft, objRight

        self.conflicting = []
        self.conflicting.extend(self.getPropertiesDiff()) 
        
        self.only_in_obj1 = {}
        self.only_in_obj2 = {}

    def existDiff(self):
        return bool(self.conflicting) or bool(self.only_in_obj1) or bool(self.only_in_obj2)


    def getPropertiesDiff(self): 
        prop_diff = {}
        for attrdesc, attrname in self.obj1.publicattrsrefs.items():
            info = lambda attr_ref: attr_ref() if callable(attr_ref) else attr_ref
            prop1 = info(self.obj1.__getattribute__(attrname))  
            prop2 = info(self.obj2.__getattribute__(attrname))
            if prop1 != prop2:
                prop_diff[attrdesc] = (prop1, prop2)

        return prop_diff

    def getDifferences(self, ObjDiff, getAllFunc, getById):
        """ Polymorphic method to get the differences between the list of objects on a ModelObject.
        Pass the ObjectDiff class, the unbound method to get all the objects and the one to get one by ID"""

                                                                
        only_in_obj1 = [ i for i in getAllFunc(self.obj1) if not i in getAllFunc(self.obj2) ]
        only_in_obj2 = [ i for i in getAllFunc(self.obj2) if not i in getAllFunc(self.obj1) ]

                                                                  
                                                                                                
                                                                                                
                                                       

        return (only_in_obj1, only_in_obj2)

    def getDifferencesIn(self, getAllFunc):
        """ Polymorphic method to get the differences between the list of objects on a ModelObject.
        Pass the ObjectDiff class, the unbound method to get all the objects and the one to get one by ID"""

                                                                
        only_in_obj1 = [ i for i in getAllFunc(self.obj1) if not i in getAllFunc(self.obj2) ]
        only_in_obj2 = [ i for i in getAllFunc(self.obj2) if not i in getAllFunc(self.obj1) ]

        return only_in_obj1, only_in_obj2

class HostDiff(ModelObjectDiff):
    """A container for all the differences between two hosts"""
    def __init__(self, h1, h2):
        super(HostDiff, self).__init__(h1, h2)

        obj1_only, obj2_only = self.getDifferencesIn(h1.__class__.getAllInterfaces) 
        if len(obj1_only):
            self.only_in_obj1.update({"Interfaces": obj1_only})
        if len(obj2_only):
            self.only_in_obj2.update({"Interfaces": obj2_only})

        obj1_only, obj2_only = self.getDifferencesIn(h1.__class__.getAllServices)
        if len(obj1_only): 
            self.only_in_obj1.update({"Services": obj1_only})
        if len(obj2_only):
            self.only_in_obj2.update({"Services": obj2_only})

        obj1_only, obj2_only = self.getDifferencesIn(h1.__class__.getVulns)
        if len(obj1_only): 
            self.only_in_obj1.update({"Vulns": obj1_only})
        if len(obj2_only):
            self.only_in_obj2.update({"Vulns": obj2_only})

        obj1_only, obj2_only = self.getDifferencesIn(h1.__class__.getAllApplications) 
        if len(obj1_only):
            self.only_in_obj1.update({"Apps": obj1_only})
        if len(obj2_only):
            self.only_in_obj2.update({"Apps": obj2_only})

class InterfaceDiff(ModelObjectDiff):
    pass


########NEW FILE########
__FILENAME__ = guiapi
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

#from model.common import factory
import model.common
from gui.notifier import NotificationCenter
from config.configuration import getInstanceConfiguration
#from model.api import showDialog, showPopup

CONF = getInstanceConfiguration()


notification_center = NotificationCenter()
__the_mainapp = None
__model_controller = None

def setMainApp(ref):
    global __the_mainapp
    __the_mainapp = ref
    notification_center.setUiApp(__the_mainapp)
    
def getMainApp():
    global __the_mainapp
    return __the_mainapp

def getMainWindow():
    global __the_mainapp
    return __the_mainapp.getMainWindow()
    
def postCustomEvent(event, receiver=None):
    if receiver is None:
        receiver = getMainWindow()
    __the_mainapp.postEvent(receiver, event)
    
def sendCustomEvent(event, receiver=None):
    if receiver is None:
        receiver = getMainWindow()
    __the_mainapp.sendEvent(receiver, event)

def setUpGUIAPIs(controller):
    global __model_controller
    __model_controller = controller


def registerWidget(widget):
    if widget is not None:
        notification_center.registerWidget(widget)


def deregisterWidget(widget):
    if widget is not None:
        notification_center.deregisterWidget(widget)


def createAndAddHost(name, os = "Unknown", category=None, update = False, old_hostname = None ):

    host = newHost(name, os)
    if addHost(host, category, update, old_hostname):
        return host.getID()
    return None

def createAndAddInterface(host_id, name = "", mac = "00:00:00:00:00:00",
                 ipv4_address = "0.0.0.0", ipv4_mask = "0.0.0.0",
                 ipv4_gateway = "0.0.0.0", ipv4_dns = [],
                 ipv6_address = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_prefix = "00",
                 ipv6_gateway = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_dns = [],
                 network_segment = "", hostname_resolution = []):
    """
    Creates a new interface object with the parameters provided and adds it to
    the host selected.
    If interface is successfuly created and the host exists, it returns the inteface id
    It returns None otherwise
    """
    interface = newInterface(name, mac, ipv4_address, ipv4_mask, ipv4_gateway,
                             ipv4_dns, network_segment, hostname_resolution)
    if addInterface(host_id, interface):
        return interface.getID()
    return None

def createAndAddApplication(host_id, name, status = "running", version = "unknown"):
    application = newApplication(name, status, version)
    if addApplication(host_id, application):
        return application.getID()
    return None

def createAndAddServiceToApplication(host_id, application_id, name, protocol = "tcp?", 
                ports = [], status = "running", version = "unknown", description = ""):
    service = newService(name, protocol, ports, status, version, description)
    if addServiceToApplication(host_id, application_id, service):
        return service.getID()
    return None

def createAndAddServiceToInterface(host_id, interface_id, name, protocol = "tcp?", 
                ports = [], status = "running", version = "unknown", description = ""):
    service = newService(name, protocol, ports, status, version, description)
    if addServiceToInterface(host_id, interface_id, service):
        return service.getID()
    return None

               

def createAndAddVulnToHost(host_id, name, desc, ref, severity="0"):
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToHost(host_id, vuln):
        return vuln.getID()
    return None

def createAndAddVulnToInterface(host_id, interface_id, name, desc, ref, severity="0"):
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToInterface(host_id, interface_id, vuln):
        return vuln.getID()
    return None
    
def createAndAddVulnToApplication(host_id, application_id, name, desc, ref, severity="0"):
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToApplication(host_id, application_id, vuln):
        return vuln.getID()
    return None

def createAndAddVulnToService(host_id, service_id, name, desc, ref, severity="0"):
                                                                                   
    vuln = newVuln(name, desc, ref, severity)
    if addVulnToService(host_id, service_id, vuln):
        return vuln.getID()
    return None

def createAndAddVulnWebToService(host_id, service_id, name, desc, website, path, ref=None, severity="0", request=None, response=None,
                method=None,pname=None, params=None,query=None,category=None):
                                                                                   
    vuln = newVulnWeb(name, desc, website, path, ref, severity, request, response,
                method,pname, params,query,category)
    
    if addVulnToService(host_id, service_id, vuln):
        return vuln.getID()
    return None

def createAndAddVuln(model_object, name, desc, ref=None, severity="0"):
    vuln = newVuln(name, desc, ref, severity)
    if addVuln(model_object, vuln):
        return vuln.getID()
    return None

def createAndAddVulnWeb(model_object, name, desc, website, path, ref=None, severity="0", request=None, response=None,
                method=None,pname=None, params=None,query=None,category=None):
    vuln = newVulnWeb(name, desc, website, path, ref, severity, request, response,
                method,pname, params,query,category)
    if addVuln(model_object, vuln):
        return vuln.getID()
    return None

      
 
def createAndAddNoteToHost(host_id, name, text):
    note = newNote(name, text)
    if addNoteToHost(host_id, note):
        return note.getID()
    return None

def createAndAddNoteToInterface(host_id, interface_id, name, text):
    note = newNote(name, text)
    if addNoteToInterface(host_id, interface_id, note):
        return note.getID()
    return None

def createAndAddNoteToApplication(host_id, application_id, name, text):
    note = newNote(text)
    if addNoteToApplication(host_id, application_id, note):
        return note.getID()
    return None

def createAndAddNoteToService(host_id, service_id, name, text):
    note = newNote(name, text)
    if addNoteToService(host_id, service_id, note):
        return note.getID()
    return None

def createAndAddNote(model_object, name, text):
    note = newNote(name, text)
    if addNote(model_object, note):
        return note.getID()
    return None

      
def createAndAddCred(model_object, username, password):
    cred = newCred(username, password)
    if addCred(model_object, cred):
        return cred.getID()
    return None

def createAndAddCredToHost(host_id, username, password):
    cred = newCred(username, password)
    if addCredToHost(host_id, cred):
        return cred.getID()
    return None

def createAndAddCredToService(host_id, service_id, username, password):
    cred = newCred(username, password)
    if addCredToService(host_id, service_id, cred):
        return cred.getID()
    return None
                                                                                
                                                 
                                                                                

                                                                                             

def addHost(host, category=None, update = False, old_hostname = None):
    if host is not None:
        __model_controller.addHostSYNC(host, category, update, old_hostname)
        return True
    return False

def addInterface(host_id, interface):
    if interface is not None:
        __model_controller.addInterfaceSYNC(host_id, interface)
        return True
    return False

def addApplication(host_id, application):
    if application is not None:
        __model_controller.addApplicationSYNC(host_id, application)
        return True
    return False

def addServiceToApplication(host_id, application_id, service):
    if service is not None:
        __model_controller.addServiceToApplicationSYNC(host_id, application_id, service)
        return True
    return False

def addServiceToInterface(host_id, interface_id, service):
    if service is not None:
        __model_controller.addServiceToInterfaceSYNC(host_id, interface_id, service)
        return True
    return False

               

def addVulnToHost(host_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToHostSYNC(host_id, vuln)
        return True
    return False

def addVulnToInterface(host_id, interface_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToInterfaceSYNC(host_id, interface_id, vuln)
        return True
    return False

def addVulnToApplication(host_id, application_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToApplicationSYNC(host_id, application_id, vuln)
        return True
    return False

def addVulnToService(host_id, service_id, vuln):
    if vuln is not None:
        __model_controller.addVulnToServiceSYNC(host_id, service_id, vuln)
        return True
    return False

def addVuln(model_object, vuln):
    if vuln is not None:
        __model_controller.addVulnSYNC(model_object, vuln)
        return True
    return False

       

def addNoteToHost(host_id, note):
    if note is not None:
        __model_controller.addNoteToHostSYNC(host_id, note)
        return True
    return False

def addNoteToInterface(host_id, interface_id, note):
    if note is not None:
        __model_controller.addNoteToInterfaceSYNC(host_id, interface_id, note)
        return True
    return False

def addNoteToApplication(host_id, application_id, note):
    if note is not None:
        __model_controller.addNoteToApplicationSYNC(host_id, application_id, note)
        return True
    return False

def addNoteToService(host_id, service_id, note):
    if note is not None:
        __model_controller.addNoteToServiceSYNC(host_id, service_id, note)
        return True
    return False

def addNote(model_object, note):
    if note is not None:
        __model_controller.addNoteSYNC(model_object, note)
        return True
    return False

      
def addCred(model_object, cred):
    if cred is not None:
        __model_controller.addCredSYNC(model_object, cred)
        return True
    return False

def addCredToService(host_id, service_id, cred):
    if cred is not None:
        __model_controller.addCredToServiceSYNC(host_id, service_id, cred)
        return True
    return False

def addCredToHost(host_id, cred):
    if cred is not None:
        __model_controller.addCredToHostSYNC(host_id, cred)
        return True
    return False

                                                                                
                                  
                                                                                
                                         
def delHost(host_id):
    __model_controller.delHostSYNC(host_id)
    return True

def delApplication(host_id, application_id):
    __model_controller.delApplicationSYNC(host_id, application_id)
    return True

def delInterface(host_id, interface_id):
    __model_controller.delInterfaceSYNC(host_id, interface_id)
    return True

def delServiceFromHost(host_id, service_id):
    __model_controller.delServiceFromHostSYNC(host_id, service_id)
    return True

def delServiceFromInterface(host_id, interface_id, service_id):
    __model_controller.delServiceFromInterfaceSYNC(host_id, interface_id, service_id)
    return True

def delServiceFromApplication(host_id, application_id, service_id):
    __model_controller.delServiceFromApplicationSYNC(host_id, application_id, service_id)
    return True

               
                                                                                
def delVulnFromApplication(vuln, hostname, appname):
    __model_controller.delVulnFromApplicationSYNC(hostname, appname, vuln)
    return True
                                                                                
def delVulnFromInterface(vuln, hostname, intname):
    __model_controller.delVulnFromInterfaceSYNC(hostname,intname, vuln)
    return True
                                                                                
def delVulnFromHost(vuln, hostname):
    __model_controller.delVulnFromHostSYNC(hostname,vuln)
    return True

                                                                                
def delVulnFromService(vuln, hostname, srvname):
    __model_controller.delVulnFromServiceSYNC(hostname,srvname, vuln)
    return True

def delVuln(model_object, vuln_id):
    __model_controller.delVulnSYNC(model_object, vuln_id)
    return True

       
                                                                                
def delNoteFromApplication(note, hostname, appname):
    __model_controller.delNoteFromApplicationSYNC(hostname, appname, note)
    return True
                                                                                
def delNoteFromInterface(note, hostname, intname):
    __model_controller.delNoteFromInterfaceSYNC(hostname,intname, note)
    return True
                                                                                
def delNoteFromHost(note, hostname):
    __model_controller.delNoteFromHostSYNC(hostname, note)
    return True

                                                                                
def delNoteFromService(note, hostname, srvname):
    __model_controller.delNoteFromServiceSYNC(hostname,srvname, note)
    return True

def delNote(model_object, note_id):
    __model_controller.delNoteSYNC(model_object, note_id)
    return True

     
def delCred(model_object, cred_id):
    __model_controller.delCredSYNC(model_object, cred_id)
    return True

def delCredFromHost(cred, hostname):
    __model_controller.delCredFromHostSYNC(hostname, cred)
    return True

                                                                                
def delCredFromService(cred, hostname, srvname):
    __model_controller.delCredFromServiceSYNC(hostname,srvname, cred)
    return True


                                                                                
              

def editHost(host, name=None, description=None, os=None, owned=None):
    __model_controller.editHostSYNC(host, name, description, os, owned)
    return True

def editService(service, name=None, description=None, protocol=None, ports=None, status=None, version=None, owned=None):
    __model_controller.editServiceSYNC(service, name, description, protocol, ports, status, version, owned)
    return True

def editApplication(application, name, description, status, version, owned):
    __model_controller.editApplicationSYNC(application, name, description, status, version, owned)
    return True

def editInterface(interface, name=None, description=None, hostnames=None, mac=None, ipv4=None, ipv6=None, network_segment=None, 
                  amount_ports_opened=None, amount_ports_closed=None, amount_ports_filtered=None, owned=None):
    __model_controller.editInterfaceSYNC(interface, name, description, hostnames, mac, ipv4, ipv6, network_segment, 
                  amount_ports_opened, amount_ports_closed, amount_ports_filtered, owned)
    return True

def editNote(note, name=None, text=None):
    __model_controller.editNoteSYNC(note, name, text)
    return True

def editVuln(vuln, name=None, desc=None, severity=None, refs=None):
    __model_controller.editVulnSYNC(vuln, name, desc, severity, refs)
    return True

def editVulnWeb(vuln, name=None, desc=None, website=None, path=None, refs=None, severity=None, request=None, response=None,
                method=None,pname=None, params=None,query=None,category=None):
    __model_controller.editVulnWebSYNC(vuln, name, desc, website, path, refs, severity, request, response,
                method,pname, params,query,category)
    return True

def editCred(cred, username=None, password=None):
    __model_controller.editCredSYNC(cred, username, password)
    return True

                                                                                

                                                                                
               
                                                                                
def newHost(name, os = "Unknown"):
    """
    It creates and returns a Host object.
    The object created is not added to the model.
    """
                                                                           
    return model.common.factory.createModelObject("Host", name, os=os)

                                                                                
def newInterface(name = "", mac = "00:00:00:00:00:00",
                 ipv4_address = "0.0.0.0", ipv4_mask = "0.0.0.0",
                 ipv4_gateway = "0.0.0.0", ipv4_dns = [],
                 ipv6_address = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_prefix = "00",
                 ipv6_gateway = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_dns = [],
                 network_segment = "", hostname_resolution = []):
    """
    It creates and returns an Interface object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Interface", name, mac = mac,
                 ipv4_address = ipv4_address , ipv4_mask = ipv4_mask,
                 ipv4_gateway = ipv4_gateway, ipv4_dns = ipv4_dns,
                 ipv6_address = ipv6_address , ipv6_prefix = ipv6_prefix,
                 ipv6_gateway = ipv6_gateway, ipv6_dns = ipv6_dns,
                 network_segment = network_segment,
                 hostname_resolution = hostname_resolution)
                                                                                
def newService(name, protocol = "tcp?", ports = [], status = "running",
               version = "unknown", description = ""):
    """
    It creates and returns a Service object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Service",name,
                             protocol = protocol, ports = ports,
                             status = status, version = version,
                             description = description)
                                                                                

def newVuln(name, desc="", ref = None, severity=""):
    """
    It creates and returns a Vulnerability object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Vulnerability", name, desc=desc,
                                                  ref=ref, severity=severity)
 
                                                                                

def newVulnWeb(name, desc="", website="", path="", ref=None, severity="", request="", response="",
                method="",pname="", params="",query="",category=""):
    """
    It creates and returns a Vulnerability object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("VulnerabilityWeb", name, desc=desc, ref=ref,severity=severity, website=website, path=path, request=request,
                                                  response=response,method=method,pname=pname, params=params,query=query,category=category )
 
                                                                                
   
def newNote(name,text):
    
    """
    It creates and returns a Note object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Note", name, text=text)


   
def newCred(username,password):
    
    """
    It creates and returns a Cred object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("Cred", username, password=password)


                                                                                
def newApplication(name, status = "running", version = "unknown"):
    """
    It creates and returns an Application object.
    The created object is not added to the model.
    """
    return model.common.factory.createModelObject("HostApplication",name,
                             status = status,
                             version = version)

                                                                                

                     
  
def resolveConflicts():
    __model_controller.resolveConflicts()

def resolveConflict(conflict, kwargs):
    __model_controller.resolveConflict(conflict, kwargs)

def merge(host1, host2):
    return __model_controller.merge(host1, host2)

########NEW FILE########
__FILENAME__ = hosts
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

from config.configuration import getInstanceConfiguration
from model.common import ModelObject, ModelObjectNote, ModelObjectVuln, ModelObjectVulnWeb, ModelObjectCred
from model.common import Metadata
from utils.common import *  
from utils.decorators import updateLocalMetadata, save, delete

import model.api as api
try:
    import IPy
except ImportError:
    print "[-] Python module IPy was not found in the system, please install it and try again"
    print "[-] ex: sudo pip install IPy"
CONF = getInstanceConfiguration()

                                                                                
                                                           
                                                                       
                                                                                 
                      

                                                                                
                                                                               
                                                                                    
                                                                               
                          

                                                                                
                                                                                      
                                                                                

                                                                                
                                                                      

class Host(ModelObject):
    """
    Represents a host found in the network.
    A hosts can have 1 or more interfaces and also 1 or more services (apps)
    Services can be reached through all host interfaces or only some of them
    The host has some attributes that are filled by the pen test tools run by
    the user
    """
                                               
    class_signature = "Host"
    _complex_attribs = ModelObject._complex_attribs + ["_interfaces", "_applications"]               

    def __init__(self, name, os = "Unknown", default_gateway=None, dic=None):
        ModelObject.__init__(self)
        self._interfaces            = {}
        self._applications          = {}
        self.categories             = []
        if dic is not None:
            self._fromDict(dic)
        else:
            self.__init(name, os, default_gateway)

    def __init(self, name, os = "Unknown", default_gateway=None):
        self._name = None
        if name is not None:
            self.setName(name)
        self._name                  = name
        self._operating_system      = os if os else "Unknown"
        self._default_gateway       = api.getLocalDefaultGateway() if default_gateway is None else default_gateway
        self.getMetadataHistory().pushMetadataForId(self.getID(), self.getMetadata())

    def _updatePublicAttributes(self):
                                                                           
        self.publicattrs['Operating System'] = 'getOS'
        self.publicattrsrefs['Operating System'] = '_operating_system'

    def getCategories(self):
        return self.categories

    def getCurrentCategory(self):
                          
        cat = CONF.getDefaultCategory()
        try:
            cat = self.getCategories()[0]
        except:
            pass
        return cat

    def registerCategory(self, category):
        self.categories.append(category)


    def removeCategory(self, category):
        self.getCategories().remove(category)

    def updateID(self):
                                                               
                                                                   
                                                                   
                                                                  
        self._id = get_hash([self._name])

    def setOS(self, newOS):
                                 
        self._operating_system = newOS

    def getOS(self):
        return self._operating_system
    
    operating_system = property(getOS, setOS)

    def setName(self, newName):
                                 
        self._name = newName

    def getName(self):
        return self._name
    
    name = property(getName, setName)

                                                                         

    @save
    @updateLocalMetadata
    def updateAttributes(self, name=None, description=None, os=None, owned=None):
        if name is not None:
            self.setName(name)
        if description is not None:
            self.setDescription(description)
        if os is not None:
            self.setOS(os)
        if name is not None:
            self.setOwned(owned)
    
                                                              
                                                               
                                   

    @updateLocalMetadata
    def addInterface(self, newInterface, update=False, setparent=True):
        return self._addValue("_interfaces", newInterface,
                              setparent=setparent, update=update)

    @updateLocalMetadata
    def delInterface(self, intID):
                                                                       
        interface = self.getInterface(intID)
        if interface is not None:
            for srv in interface.getAllServices():
                srv.delInterface(intID)
                                         
        return self._delValue("_interfaces", intID)

    def addInterfaceFull(self, interface):
        self.addInterface(interface)

    def getAllInterfaces(self, mode = 0):
        """
        return all interfaces in this host
        mode = 0 returns a list of interface objects
        mode = 1 returns a dictionary of interface objects with their id as key
        """
        return self._getAllValues("_interfaces", mode)

    def getInterface(self, value):
        """
        value can be mac or ip address
        if value is found it returns the interface objets
        it returns None otherwise
        """
        return self._getValueByID("_interfaces", value)


    def getService(self, name):
        """
        if name is found it returns the service object
        it returns None otherwise
        """
        service = None
        for interface in self.getAllInterfaces():
            if interface.getService(name):
                service = interface.getService(name)
                break
        return service

    @updateLocalMetadata
    def addApplication(self, newApp, update=False, setparent=True):
        return self._addValue("_applications", newApp,
                              setparent=setparent, update=update)

    @updateLocalMetadata
    def delApplication(self, appID):
                                         
        app = self.getApplication(appID)
        if app is not None:
            for srv in app.getAllServices():
                srv.delApplication(appID)
                                        
        return self._delValue("_applications", appID)

    def addApplicationFull(self, app):
        self.addApplication(app)

    def getAllApplications(self, mode = 0):
        """
        return all applications in this interface
        mode = 0 returns a list of service objects
        mode = 1 returns a dictionary of service objects with their id as key
        """
        return self._getAllValues("_applications", mode)

    def getApplication(self, name):
        """
        if name is found it returns the application object
        it returns None otherwise
        """
        return self._getValueByID("_applications", name)

                                                          
                                     
                                                                                               
    def __eq__(self, other_host):
        if isinstance(other_host, Host):
            if self._name == other_host.getName():
                return True
            else:
                                    
                ip_addr_this = self.getIPv4Addresses()
                ip_addr_other = other_host.getIPv4Addresses()
                                                                           
                                                  
                                
                      
                                                                                                          
                                                                                                 
                                                                                                              
                                              
                                                                                        
                                        
                for addr in ip_addr_this:
                    if addr in ip_addr_other and IPy.IP(addr).iptype() == "PUBLIC":
                        return True
                                                       
        return False

    def __ne__(self, other_host):
                                                                      
        return not self == other_host

    def getIPv4Addresses(self):
        """
        returns a list of all ipv4 addresses from all interfaces on this host
        """
        l = [interface.ipv4['address'] for name, interface in self._interfaces.items()]
        l.sort()
        return l

    def getIPv6Addresses(self):
        """
        returns a list of all ipv4 addresses from all interfaces on this host
        """
        l = [interface.ipv6['address'] for name, interface in self._interfaces.items()]
        l.sort()
        return l



    def _toDict(self, full=False):
        host = super(Host, self)._toDict(full)
        host["os"] = self.getOS()
        host["default_gateway"] = ",".join(self._default_gateway) if self._default_gateway is not None else "None"
        host["categories"] = [c for c in self.categories]
        if full:    
            host["interface"] = {}
            host["application"] = {}
            for interface in self.getAllInterfaces():
                host["interface"][interface.getID()] = interface._toDict(full)
            for application in self.getAllApplications():
                host["application"][application.getID()] = application._toDict(full)
        return host

                                         
                                                 
                                                 
    
    def _fromDict(self, dict):
        super(Host, self)._fromDict(dict)
        self.operating_system = dict["os"]
        self._default_gateway = dict["default_gateway"].split(",")

        for category in dict["categories"]:
            self.categories.append(category)

        if dict.get("interface"):
            for interface in dict["interface"].values():
                i = Interface()
                i._parent = self
                i._fromDict(interface)
                self.addInterface(i, setparent=False)
        
        if dict.get("application"):
            for application in dict["application"].values():
                app = HostApplication("")
                app._parent = self
                app._fromDict(application)
                self.addApplication(app, setparent=False)

    def fromDict(self, dict):
        dict.setdefault("")
        self.id = dict["_id"]
        self.name = dict["name"]
        owned = True if dict.get("owned", "").upper() == "TRUE" else False
        self.setOwned(owned)
        parent_id = dict["parent"]
        self.owner = dict["owner"]
        self.operating_system = dict["os"]
        self._default_gateway = dict["default_gateway"].split(",")

        self.description = dict["description"]
        
        self._metadata = Metadata("").fromDict(dict["metadata"] )
            
        self.categories = []
        for category in dict["categories"]:
            self.categories.append(category)
            
        interfaces = dict["interfaces"]
        for id, interface in interfaces.items():
            ints = Interface()
            ints.setParent(self)
            ints.fromDict(interface)
            self.addInterface(ints)
            
        applications = dict["applications"]
        for id, application in applications.items():
            app = HostApplication("")
            app.setParent(self)
            app.fromDict(application)
            self.addApplication(app)
            
        for note in dict["notes"]:
            n = ModelObjectNote("")
            self.setParent(self)
            n.fromDict(note)
            self.addNote(n)

        for vuln in dict["vulnerabilities"]:
            v = ModelObjectVuln("")
            self.setParent(self)
            v.fromDict(vuln)
            self.addVuln(v)

        return True


                                                                                

class Interface(ModelObject):
    """
    An interface in a host
    """
                                               
    class_signature = "Interface"
    _complex_attribs = ModelObject._complex_attribs + ["_services"]

    def __init__(self, name = "", mac = "00:00:00:00:00:00",
                 ipv4_address = "0.0.0.0", ipv4_mask = "0.0.0.0",
                 ipv4_gateway = "0.0.0.0", ipv4_dns = [],
                 ipv6_address = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_prefix = "00",
                 ipv6_gateway = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_dns = [],
                 network_segment = "", hostname_resolution = None):

        ModelObject.__init__(self)

                              
        self._name         = name
        self.mac           = mac
        self.ipv4          = {
                                "address" : ipv4_address,
                                "mask"    : ipv4_mask,
                                "gateway" : ipv4_gateway,
                                "DNS"     : ipv4_dns
                            }
             
        self.ipv6         = {
                                "address" : ipv6_address,
                                "prefix"    : ipv6_prefix,
                                "gateway" : ipv6_gateway,
                                "DNS"     : ipv6_dns
                            }

                                                    
        self._services      = {}

                                                                      
        self.network_segment       = network_segment

                                                     
        self._hostnames=[]
        if hostname_resolution is not None:
            if isinstance(hostname_resolution, (str,unicode)):
                self._hostnames.append(hostname_resolution)
            else:
                self._hostnames = hostname_resolution

                         
                                                                         
                                                                      
        self.amount_ports_opened   = 0
        self.amount_ports_closed   = 0
        self.amount_ports_filtered = 0

        self.getMetadataHistory().pushMetadataForId(self.getID(), self.getMetadata())

    def _updatePublicAttributes(self):
                                                                           
        self.publicattrs['MAC Address'] = 'mac'
        self.publicattrs['IPV4 Settings'] = 'ipv4'
        self.publicattrs['IPV6 Settings'] = 'ipv6'
        self.publicattrs['Network Segment'] = 'network_segment'
        self.publicattrs['Hostnames'] = 'getHostnames'
        self.publicattrs['Ports opened'] = 'amount_ports_opened'
        self.publicattrs['Ports closed'] = 'amount_ports_closed'
        self.publicattrs['Ports filtered'] = 'amount_ports_filtered'

        self.publicattrsrefs['MAC Address'] = 'mac'
        self.publicattrsrefs['IPV4 Settings'] = 'ipv4'
        self.publicattrsrefs['IPV6 Settings'] = 'ipv6'
        self.publicattrsrefs['Network Segment'] = 'network_segment'
        self.publicattrsrefs['Hostnames'] = '_hostnames'

    def defaultValues(self):
        defVals = ModelObject.defaultValues(self)
        defVals.extend([{
                                "address" :  "0.0.0.0",
                                "mask"    :  "0.0.0.0",
                                "gateway" :  "0.0.0.0",
                                "DNS"     :  []
                                }, {'prefix': '00', 'gateway': '0000:0000:0000:0000:0000:0000:0000:0000', 'DNS': [], 'address': '0000:0000:0000:0000:0000:0000:0000:0000'}])
        return defVals

    
    def tieBreakable(self, property_key):
        if property_key in ["_hostnames"]:
            return True
        return False

    def tieBreak(self, key, prop1, prop2):
        if key == "_hostnames":
            prop1.extend(prop2)
            return list(set(prop1))
        return None

    def updateID(self):
                                                                                                          
        self._id = get_hash([self.network_segment, self.ipv4["address"], self.ipv6["address"]])

    def setName(self, name):
        self._name = name
    
    def getName(self):
        return self._name
    
                                      

    def setMAC(self, mac):
        self.mac = mac
        
    def getMAC(self):
        return self.mac
    
                                   
    
    def setNetworkSegment(self, network_segment):
        self.network_segment = network_segment
    
    def getNetworkSegment(self):
        return self.network_segment
    
                                                                     
    
    def setIPv4(self, ipv4):
        self.ipv4["address"] = ipv4["address"]
        self.ipv4["mask"] = ipv4["mask"]
        self.ipv4["gateway"] = ipv4["gateway"]
        self.ipv4["DNS"] = ipv4["DNS"]
    
    def getIPv4(self):
        return self.ipv4

    def getIPv4Address(self):
        return self.ipv4["address"]

    def getIPv4Mask(self):
        return self.ipv4["mask"]

    def getIPv4Gateway(self):
        return self.ipv4["gateway"]

    def getIPv4DNS(self):
        return self.ipv4["DNS"]
    
    def setIPv6(self, ipv6):
        self.ipv6["address"] = ipv6["address"]
        self.ipv6["prefix"] = ipv6["prefix"]
        self.ipv6["gateway"] = ipv6["gateway"]
        self.ipv6["DNS"] = ipv6["DNS"]
    
    def getIPv6(self):
        return self.ipv6

    def getIPv6Address(self):
        return self.ipv6["address"]

    def getIPv6Prefix(self):
        return self.ipv6["prefix"]

    def getIPv6Gateway(self):
        return self.ipv6["gateway"]

    def getIPv6DNS(self):
        return self.ipv6["DNS"]
    
    def setPortsOpened(self, ports_opened):
        self.amount_ports_opened   = ports_opened
    
    def getPortsOpened(self):
        return self.amount_ports_opened
    
                                                                   
    
    def setPortsClosed(self, ports_closed):
        self.amount_ports_closed   = ports_closed
        
    def getPortsClosed(self):
        return self.amount_ports_closed
    
                                                                   
    
    def setPortsFiltered(self, ports_filtered):
        self.amount_ports_filtered = ports_filtered
        
    def getPortsFiltered(self):
        return self.amount_ports_filtered
    
                                                                         
    
    
                                                     
                                                                         
                                                                          
                                                                        


    @updateLocalMetadata
    def addService(self, newService, update=False, setparent=True):
        res = self._addValue("_services", newService, setparent=setparent, update=update)    
        if res: newService.addInterface(self)
        return res

    @updateLocalMetadata
    def delService(self, srvID, checkFullDelete=True):
                                                   
        res = True
        res = self._delValue("_services", srvID)
        return res

    def getAllServices(self, mode = 0):
        """
        return all services in this interface
        mode = 0 returns a list of service objects
        mode = 1 returns a dictionary of service objects with their id as key
        """
        return self._getAllValues("_services", mode)

    def getService(self, name):
        """
        if name is found it returnsnetwork_segment the service object
        it returns None otherwise
        """
        return self._getValueByID("_services", name)

    def addHostname(self, hostname):
        if hostname not in self._hostnames:
            self._hostnames.append(hostname)

    def removeHostname(self, hostname):
        if hostname in self._hostnames:
            self._hostnames.remove(hostname)

    def getHostnames(self):
        return self._hostnames
    
    def setHostnames(self, hostnames):
        self._hostnames = hostnames

    @save
    @updateLocalMetadata
    def updateAttributes(self, name=None, description=None, hostnames=None, mac=None, ipv4=None, ipv6=None,
                         network_segment=None, amount_ports_opened=None, amount_ports_closed=None,
                         amount_ports_filtered=None, owned=None):
        if name is not None:
            self.setName(name)
        if description is not None:
            self.setDescription(description)
        if hostnames is not None:
            self.setHostnames(hostnames)
        if mac is not None:
            self.setMAC(mac)
        if ipv4 is not None:
            self.setIPv4(ipv4)
        if ipv6 is not None:
            self.setIPv6(ipv6)
        if network_segment is not None:
            self.setNetworkSegment(network_segment)
        if amount_ports_opened is not None:
            self.setPortsOpened(amount_ports_opened)
        if amount_ports_closed is not None:
            self.setPortsClosed(amount_ports_closed)
        if amount_ports_filtered is not None:
            self.setPortsFiltered(amount_ports_filtered)

    def servicesToDict(self):
        d = []
        for service in self._services.values():
            d.append(service.toDict())
        return d

        
    def _toDict(self, full=False):
        interface = super(Interface, self)._toDict(full)
        interface["mac"] = self.mac
        interface["network_segment"] = self.network_segment
        interface["hostnames"] = [ hname for hname in self.getHostnames() ]
        interface["ipv4"] = self.ipv4
        interface["ipv6"] = self.ipv6
        interface["ports"] =  { 
                                "opened" : str(self.amount_ports_opened),
                                "closed" : str(self.amount_ports_closed),
                                "filtered" : str(self.amount_ports_filtered),
                            }
        if full:
            interface["service"] = {}
            for service in self.getAllServices():
                interface["service"][service.getID()] = service._toDict(full)
        return interface

    def _fromDict(self, dict):
        super(Interface, self)._fromDict(dict)
        self.mac = dict["mac"]
        self.network_segment = dict["network_segment"]

        self._hostnames = dict["hostnames"]
            
        self.ipv4 = dict["ipv4"]
        self.ipv6 = dict["ipv6"]
        
        self.amount_ports_opened = dict["ports"]["opened"]
        self.amount_ports_closed = dict["ports"]["closed"]
        self.amount_ports_filtered = dict["ports"]["filtered"]

        if dict.get("service"):
            for service in dict["service"].values():
                s = Service("")
                s._parent = self
                s._fromDict(service)
                self.addService(s, setparent=False)

    def fromDict(self, dict):
        self.id = dict["_id"]
        self.name = dict["name"]
        owned = True if dict["owned"].upper() == "TRUE" else False
        self.setOwned(owned)
        parent_id = dict["parent"]
        self.owner = dict["owner"]
        self.mac = dict["mac"]
        self.network_segment = dict["network_segment"]
        
         
        self.description = dict["description"]

        for hostname in dict["hostnames"]:
            self.addHostname(hostname)
            
        self.ipv4.update(dict["ipv4"])
        self.ipv6.update(dict["ipv6"])
        
        self.amount_ports_opened = dict["ports"]["opened"]
        self.amount_ports_closed = dict["ports"]["closed"]
        self.amount_ports_filtered = dict["ports"]["filtered"]

        for srv in dict["services"]:
            service = Service("")
            service.setParent(self)
            service.fromDict(srv)
            self.addService(service)

        for note in dict["notes"]:
            n = ModelObjectNote("")
            self.setParent(self)
            n.fromDict(note)
            self.addNote(n)

        for vuln in dict["vulnerabilities"]:
            v = ModelObjectVuln("")
            self.setParent(self)
            v.fromDict(vuln)
            self.addVuln(v)

        return True
            
                                                                                

class Service(ModelObject):
    """
    A service or application running in a host
    Commonly a service will have a name or description, a set of ports in which
    is listening and also a particular version
    """
                                               
    class_signature = "Service"
    _complex_attribs = ModelObject._complex_attribs

    def __init__(self, name, protocol="TCP", ports=None, status="running",
                 version="unknown", description = ""):
        ModelObject.__init__(self)

        self._name          = name
        self.description    = description
        self.setProtocol(protocol)
        self._ports=[]
        self.setPorts(ports)
        self._status        = status
        self._version       = version
        self._interfaces    = {}
        self._applications  = {}
        self._creds = {}

    def _updatePublicAttributes(self):
                                                                           
        self.publicattrsrefs['Ports'] = '_ports'
        self.publicattrsrefs['Protocol'] = '_protocol'
        self.publicattrsrefs['Status'] = '_status'
        self.publicattrsrefs['Version'] = '_version'

        self.publicattrs['Ports'] = 'getPorts'
        self.publicattrs['Protocol'] = 'getProtocol'
        self.publicattrs['Status'] = 'getStatus'
        self.publicattrs['Version'] = 'getVersion'
                                                           

                                     
                                     
                                     
                                  

    def setName(self, name):
        self._name = name
    
    def getName(self):
        return self._name
    
                                      

    def setProtocol(self, protocol):
        self._protocol = protocol.lower()

    def getProtocol(self):
        return self._protocol
    
                                                  

    def addPort(self, port):
        if port not in self._ports:
            self._ports.append(port)

    def removePort(self, port):
        if port in self._ports:
            self._ports.remove(port)

    def getPorts(self):
        return self._ports
    
    def setPorts(self, ports):
        if ports is not None:
            if isinstance(ports, (str,unicode)):
                self._ports = [int(ports)]
            elif isinstance(ports, int):
                self._ports = [ports]
            elif isinstance(ports, list):
                self._ports = [int(p) for p in ports]
            else:
                api.devlog("ports must be a string, an int o a list of any of those types")
        
                                         

    def setStatus(self, status):
        self._status = status

    def getStatus(self):
        return self._status
    
                                            

    def setVersion(self, version):
        self._version = version

    def getVersion(self):
        return self._version
    
                                               

    def updateID(self):
                                                                         
        self._id = get_hash([self._protocol, ":".join(str(self._ports))])

    @save
    @updateLocalMetadata
    def updateAttributes(self, name=None, description=None, protocol=None, ports=None, 
                          status=None, version=None, owned=None):
        if name is not None:
            self.setName(name)
        if description is not None:
            self.setDescription(description)
        if protocol is not None:
            self.setProtocol(protocol) 
        if ports is not None:
            self.setPorts(ports)
        if status is not None:
            self.setStatus(status)
        if version is not None:
            self.setVersion(version)
        if owned is not None:
            self.setOwned(owned) 

                                                                   

                                                      
                                                                          
                                                                          
                                                                         

    def addInterface(self, newInterface, update=False, setparent=False):
        res = self._addValue("_interfaces", newInterface, update=update, setparent=setparent)
                                                             
                                                                                 
        if res: newInterface.addService(self)
        return res

    def delInterface(self, intID, checkFullDelete=True):
        interface = self.getInterface(intID)
        res = self._delValue("_interfaces", intID)
        if res:
            if interface is not None:
                                                  
                                                                              
                                 
                interface.delService(self.getID(), checkFullDelete)

        if checkFullDelete: self._checkFullDelete()
        return res
                                                                                   
                                                                                 
                                          
                                                         
                                                   
                                                    
                   

    def _checkFullDelete(self):
                                                        
                                                                             
                                                                  
        api.devlog("Doing service checkFullDelete")
        if not self._interfaces and not self._applications:
            if self.getParent() is not None:
                self.getParent().delService(self.getID())

    def getAllInterfaces(self, mode = 0):
        """
        return all interfaces in this host
        mode = 0 returns a list of interface objects
        mode = 1 returns a dictionary of interface objects with their id as key
        """
        return self._getAllValues("_interfaces", mode)

    def getInterface(self, value):
        """
        value can be a mac or ipv4 address
        if value is found it returns the interface objets
        it returns None otherwise
        """
        return self._getValueByID("_interfaces", value)

    def addApplication(self, newApp, update=False):
        res = self._addValue("_applications", newApp, update=update)
        if res: newApp.addService(self)
        return res

    def delApplication(self, appID, checkFullDelete=True):
        app = self.getApplication(appID)
        res = self._delValue("_applications", appID)
        if res:
            if app is not None:
                app.delService(self.getID(), checkFullDelete)

        if checkFullDelete: self._checkFullDelete()
        return res

    def getAllApplications(self, mode = 0):
        """
        return all applications in this service
        mode = 0 returns a list of applications objects
        mode = 1 returns a dictionary of application objects with their id as key
        """
        return self._getAllValues("_applications", mode)

    def getApplication(self, name):
        """
        if name is found it returns the application object
        it returns None otherwise
        """
        return self._getValueByID("_applications", name)
    
                                          
                                 
                                          

    def _getServiceDict(self): 
        return {
                    "id" : self.getID(),
                    "name" : self.name,
                    "owned" : str(self.isOwned()),
                    "parent" : self.getParent().getID() if self.getParent() is not None else "None",
                    "owner" : self.owner,
                    "protocol" : self.getProtocol(),
                    "status" : self.getStatus(),
                    "version" : self.getVersion(),
                }
            

    def _toDict(self, full=False):
        service = super(Service, self)._toDict(full)
        service["protocol"] = self.getProtocol()
        service["status"] = self.getStatus()
        service["version"] = self.getVersion()
        service["ports"] = [ port for port in self.getPorts()]
        service["interfaces"] = [id for id in self._getAllIDs("_interfaces")]
        return service

    def _fromDict(self, dict):
        super(Service, self)._fromDict(dict)
        self._protocol = dict["protocol"]
        self._status = dict["status"]
        self._version = dict["version"]
        self._ports = dict["ports"]
                                              

    def fromDict(self, dict):
        self.id = dict["id"]
        self.name = dict["name"]
        owned = True if dict["owned"].upper() == "TRUE" else False
        self.setOwned(owned)
        parent_id = dict["parent"]
        self.owner = dict["owner"]
        self._protocol = dict["protocol"]
        self._status = dict["status"]
        self._version = dict["version"]

        self.description = dict["description"]

        for port in dict["ports"]:
            self.addPort(int(port))

                                              
                                                          
        for interface in dict["interfaces"]:
            inter = Interface()
            inter.id = interface
            self.addInterface(inter) 
         
        for application in dict["applications"]:
            app = HostApplication("")
            app.id = application
            self.addApplication(app)
            
        for cred in dict["creds"]:
            c = ModelObjectCred("")
            self.setParent(self)
            c.fromDict(cred)
            self.addCred(c)
            
        for note in dict["notes"]:
            n = ModelObjectNote("")
            self.setParent(self)
            n.fromDict(note)
            self.addNote(n)

        for vuln in dict["vulnerabilities"]:
            v = ModelObjectVuln("")
            self.setParent(self)
            v.fromDict(vuln)
            self.addVuln(v)

        return True
    
                                                                                

class HostApplication(ModelObject):
    """
    An application running in a host
    The application can be related to more than one service
    Commonly this will have a name, description, version and status
    """
                                               
    class_signature = "HostApplication"
    _complex_attribs = ModelObject._complex_attribs + ["_services"]
    def __init__(self, name, status = "running", version = "unknonw"):
        ModelObject.__init__(self)

        self._name          = name
        self._status        = status
        self._version       = version
                                                    
        self._services      = {}

    def _updatePublicAttributes(self):
                                                                           
        self.publicattrs['Status'] = 'getStatus'
        self.publicattrs['Version'] = 'getVersion'

                                     
                                     
                                     
                                  

    def setName(self, name):
        self._name = name
    
    def getName(self):
        return self._name
    
                                      
    
    def setStatus(self, status):
        self._status = status

    def getStatus(self):
        return self._status
    
                                            

    def setVersion(self, version):
        self._version = version

    def getVersion(self):
        return self._version
    
                                               

    def updateID(self):
        self._id = get_hash([self._name, self._version])
    
    @updateLocalMetadata
    def updateAttributes(self, name=None, description=None, status=None, version=None, owned=None):
        if name is not None:
            self.setName(name)
        if description is not None:
            self.setDescription(description)
        if status is not None:
            self.setStatus(status)
        if version is not None:
            self.setVersion(version)
        if owned is not None:
            self.setOwned(owned)

                                                                   

                                                     
                                                                         
                                                                          
                                                                        

    @updateLocalMetadata
    def addService(self, newService, update=False):
        res = self._addValue("_services", newService, update=update)
        if res: newService.addApplication(self)
        if self.getParent() is not None:
            self.getParent().addService(newService)
        return res

    @updateLocalMetadata
    def delService(self, srvID, checkFullDelete=True):
        srv = self.getService(srvID)
        res = self._delValue("_services", srvID)
        if res:
            if srv is not None:
                srv.delApplication(self.getID(), checkFullDelete)
        return res

    def getAllServices(self, mode = 0):
        """
        return all services in this interface
        mode = 0 returns a list of service objects
        mode = 1 returns a dictionary of service objects with their id as key
        """
        return self._getAllValues("_services", mode)

    def getService(self, name):
        """
        if name is found it returns the service object
        it returns None otherwise
        """
        return self._getValueByID("_services", name)


    def _toDict(self):
        s = {
            "_id" : self.getID(),
            "name" : self.name,
            "owned" : str(self.isOwned()),
            "parent" : self.getParent().getID() if self.getParent() is not None else "None",
            "owner" : self.owner,
            "status" : self.getStatus(),
            "version" : self.getVersion(),
            }
        s["description"] = self.description

        s["services"] = [id for id in self._getAllIDs("_services")]

        s["notes"] = self.notesToDict()
        s["vulnerabilities"] =  self.vulnsToDict()

    def fromDict(self, dict):
        self.id = dict["_id"]
        self.name = dict["name"]
        owned = True if dict["owned"].upper() == "TRUE" else False
        self.setOwned(owned)
        parent_id = dict["parent"]
        self.owner = dict["owner"]
        self._status = dict["status"]
        self._version = dict["version"]

        self.description = dict["description"]

        for u, p in dict["credentials"]:
            self.credentials.append((u, p))
            
                                                   
                                             
                                              
                                       
                              
                                   
                                        

        for note in dict["notes"]:
            n = ModelObjectNote("")
            self.setParent(self)
            n.fromDict(note)
            self.addNote(n)

        for vuln in dict["vulnerabilities"]:
            v = ModelObjectVuln("")
            self.setParent(self)
            v.fromDict(vuln)
            self.addVuln(v)

        return True
        

                                                                                
                                 

def __checkDiffObjectClasses(objLeft, objRight, checkClass):
                                                  
    if not isinstance(objLeft, checkClass) or not isinstance(objRight, checkClass) :
        raise Exception("Cannot diff objects. Class mismatch!. objLeft class (%s) - objRight class (%s)"
                        % (objLeft.__class__.__name__, objRight.__class__.__name__))

def HostDiff(objLeft, objRight):
    """
    
    """
    __checkDiffObjectClasses(objLeft, objRight, Host)
    


def InterfaceDiff(objLeft, objRight):
    __checkDiffObjectClasses(objLeft, objRight, Interface)
    pass

def ServiceDiff(objLeft, objRight):
    __checkDiffObjectClasses(objLeft, objRight, Service)
    pass

def HostApplicationDiff(objLeft, objRight):
    __checkDiffObjectClasses(objLeft, objRight, HostApplication)
    pass

__diff_dispatch_table = {
    Host: HostDiff,
    HostApplication: HostApplicationDiff,
    Interface: InterfaceDiff,
    Service: ServiceDiff    
}

                                                                   
                                                         
def ModelObjectDiff(objLeft, objRight):
    """
    This is like a dispatcher. Based on the object class it call the corresponding
    diff function. If a diff function for the class is not pressent it raises a
    NotImplemented Exception
    """
                                                         
    if not isinstance(objLeft, objRight.__class__):
        raise Exception("Cannot compare objects of different classes. objLeft (%s) vs objRight (%s)"
                        % (objLeft.__class__.__name__, objRight.__class__.__name__))
    
    global __diff_dispatch_table    
    diff_func = __diff_dispatch_table.get(objLeft.__class__, None)

    if diff_func is None:
        raise NotImplemented("Diff function for %s does not exist" % objLeft.__class__.__name__)
    
    return diff_func(objLeft, objRight)    

########NEW FILE########
__FILENAME__ = log
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import threading
import logging
import logging.handlers
from gui.customevents import (LogCustomEvent,
                              ShowPopupCustomEvent,
                              ShowDialogCustomEvent)
#import qt
import model.guiapi

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

__the_logger = None
__notifier = None


def getLogger():
    global __the_logger
    if __the_logger is None:
        # we create for the first time
        __the_logger = AppLogger()
    return __the_logger


def getNotifier(singleton=True):
    global __notifier
    if singleton:
        if __notifier is None:
            __notifier = Notifier()
        return __notifier
    else:
        return Notifier()


class AppLogger(object):
    """
    a logging facility to show application activity
    possible outputs are log file
    console in a gui
    This is thread safe. It uses an internal lock to make sure
    text is logged sequentially
    """

    levels = {
            "NOTIFICATION":logging.INFO,\
            "INFO":logging.INFO,\
            "WARNING":logging.WARNING,\
            "ERROR":logging.ERROR,\
            "CRITICAL":logging.CRITICAL,\
            "DEBUG":logging.DEBUG \
            }

    def __init__(self, name = CONF.getAppname()):
        # The logger instance.
        self.__logger = logging.getLogger(name)

        # We set the default level, this can be changed at any moment.
        self.__logger.setLevel(logging.DEBUG)

        # The name of the logger object.
        self.__name = name

        # The handler object.
        self.__handler = None

        # These flag will enable/disable the logger for different outputs
        self.__output_file = False
        self.__output_console = True

        # a list of widgets we need to update when new text comes
        self.__gui_output = []

        self.__lock = threading.RLock()


    def setLogFile(self, filename = None, maxsize=0,maxBackup=10, file_mode = 'a'):
        """
        Set a logfile as an output target. If no filename is given, then a
        file with the instance name with the ".log" extension will be created.
        The file rotates when the size is equal or higher than the
        specified maxsize (in bytes) value. If the maxsize value is 0, the file will increase
        indefinitely. The maxBackup value allows to create backups of rotated
        files with the *.log.1, .2, etc. You can define the maximun value of
        backup created files, if the value is zero, then no backup will be performed.
        """

        # Check if the filename is valid.

        if filename is None:
            # If not, then set a default name with the name of the instance.
            self.__handler = logging.handlers.RotatingFileHandler('%s.log' % self.__name, 'a', maxsize,maxBackup)
        else:
            # If the file_mode is not allowed, open with 'append' mode
            if not (file_mode == 'a' or file_mode == 'w'):
                 file_mode = 'a'

            # The user must set a correct path and filename.
            self.__handler = logging.handlers.RotatingFileHandler(filename, file_mode,maxsize,maxBackup)

        # Set the standard formater to the handler. The '-8' parameter in the level name argument
        # is a print format parameter, it means the converted value is left adjusted(-) and that
        # it spans at max 8 positions(8).
        self.__handler.setFormatter(logging.Formatter("%(asctime)s - %(levelname)-8s - %(message)s"))

        # Don't forget to add the handler to the logger.
        self.__logger.addHandler(self.__handler)

    def isGUIOutputRegistered(self):
        """
        determines if there is at least one GUI widget registered
        to show logger output
        """
        if self.__gui_output:
            return True
        else:
            return False

    def registerGUIOutput(self, widget):
        """
        adds a reference to a GUI widget we need to update
        """
        # IMPORTANT: the widget MUST implement a method called appendText
        self.__gui_output.append(widget)

    def clearWidgets(self):
        self.__lock.acquire()
        self.__gui_output = []
        self.__lock.release()

    def setLogLevel(self, level):
        self.__logger.setLevel(level)

    def enableLogOutput(self, enable=True):
        self.__output_file = enable

    def enableConsoleOutput(self, enable=True):
        self.__output_console = enable

    def getLogLevel(self):
        """ Get the current log level. """
        return self.__logger.getEffectiveLevel()

    def isFileEnabled(self):
        return self.__output_file

    def isGUIEnabled(self):
        return self.__output_console

    def __notifyGUIConsole(self, msg):
        """
        notifies all GUI widgets registered
        IMPORTANT: the widgets MUST be able to handle a custom event
        """
        for widget in self.__gui_output:
            event = LogCustomEvent(msg)
            #widget.update(event)
            #qt.QApplication.postEvent(widget, event)
            model.guiapi.postCustomEvent(event, widget)

    def log(self, msg ,level = "INFO"):
        """
        Send a message to the logger with the specified level and format.
        It will redirect the output to the current target.
        The method will automatically filter those messages with a lower
        "loglevel" than the specified.
        It also will attempt to write the arguments by checking the format
        list, if the arguments are incompatible with the format, it WON'T
        log anything else than the message.
        """
        #TODO: we need to format the message to contain a timestamp for the
        # gui output. The file handles this by itself, but for the gui, only a text
        # message arrives
        level = level.upper()
        if level not in self.levels:
            level = "INFO"

        # take lock
        self.__lock.acquire()
        try:
            if self.__handler and self.__output_file:
                self.__logger.log(self.levels.get(level,logging.INFO), msg)
            # Check if the log is being sent to the console
            if self.__output_console:
                self.__notifyGUIConsole("[%s] - %s" % (level, msg))
        finally: # for safety so we don't block anything
            # after doing all release
            self.__lock.release()


class Notifier(object):
    """
    This class is used to show information to the user using dialog boxes or
    little pop ups (like tooltips).
    Also all notifications get logged using the Application Logger
    """
    
    #TODO: change the implementation to send/post custom events to avoid
    # problems with threads like we had before
    def __init__(self):
        self.widget = None

    def _postCustomEvent(self, text, level, customEventClass):
        getLogger().log(text, "NOTIFICATION")
        if self.widget is not None:
            event = customEventClass(text, level)
            #widget.update(event)
            model.guiapi.postEvent(event, self.widget)

    def showDialog(self, text, level="Information"):
        self._postCustomEvent(text, level, ShowDialogCustomEvent)

    def showPopup(self, text, level="Information"):
        self._postCustomEvent(text, level, ShowPopupCustomEvent)



########NEW FILE########
__FILENAME__ = report
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import os
import model.api
import threading
import time
import traceback
import re
import requests
from persistence.utils import ET
from plugins.api import PluginControllerAPIClient

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

"""

"""
                                                                                
class ReportManager(threading.Thread):
    def __init__(self, timer, plugin_controller, path=None):
        threading.Thread.__init__(self)
        self.setDaemon(True)
        self.timer = timer
        self._stop = False
        self.path = path
        self.plugin_controller = plugin_controller

    def run(self):
        tmp_timer = 0
        while not self._stop:
                                   
            time.sleep(1)
            tmp_timer += 1
            if tmp_timer == self.timer:
                try:
                    self.syncReports()
                except Exception:
                    model.api.devlog("An exception was captured while saving reports\n%s" % traceback.format_exc())
                finally:
                    tmp_timer = 0

    def stop(self):
        self._stop = True
        
      
    def syncReports(self):
        """
        Synchronize report directory using the DataManager and Plugins online
        We first make sure that all shared reports were added to the repo
        """
        
        
        self._xml_output_path = self.path
        if self._xml_output_path is None:
            return
            
        if not os.path.exists(self._xml_output_path):
            return False
        
        for root, dirs, files in os.walk(self._xml_output_path,False):
                            
            if root == self._xml_output_path:
                for name in files:
                    filename = os.path.join(root, name)
                    
                                                                          
                    model.api.devlog( "Report file is %s" % filename)
                    
                                     
                    parser = ReportXmlParser(filename)
                    if (parser.report_type is not None):
                        #TODO: get host and port from config
                        client = PluginControllerAPIClient("127.0.0.1", 9977)

                        #self._xml_output_path = filename
                        model.api.devlog("The file is %s, %s" % (filename,parser.report_type))

                        command_string = "./%s report" % parser.report_type.lower()
                        model.api.devlog("Executing %s" % (command_string))
                        
                        # current_path =""
  
                        # new_cmd = self.plugin_controller.processCommandInput("", "",
                        #                                                          current_path,
                        #                                                          command_string,
                        #                                                          False)
                        new_cmd, output_file = client.send_cmd(command_string)
                        
                        #self.plugin_controller.storeCommandOutput(self._xml_output_path)
                        client.send_output(command_string, filename)
                        
                        #self.plugin_controller.onCommandFinished()
                        
                        
                                     
                    os.rename(filename, os.path.join(root,"process", name))
        
                               
        self.onlinePlugins()

                    
    def onlinePlugins(self):
        """
        Process online plugins
        """
        _pluginsOn={"MetasploitOn" : "./metasploiton online",}
        _pluginsOn={"Beef" : "./beef online",}
        _psettings=CONF.getPluginSettings()
        
        for k,v in _pluginsOn.iteritems():
            if k in _psettings:
                if _psettings[k]['settings']['Enable'] == "1":
                    new_cmd = self.plugin_controller.processCommandInput("", "",
                                                                             "",
                                                                             v,
                                                                             False)
                    
                    self.plugin_controller.storeCommandOutput("")
                    
                    self.plugin_controller.onCommandFinished()
                            

                                                                                
class ReportXmlParser(object):
    
    """Plugin that handles XML report files.
    
    :param xml_filepath: Xml file.
    
    :class:`.LoadReportXML`
    """

    def __init__(self, xml_report_path):
        self.report_type = ""
        root_tag,output = self.getRootTag(xml_report_path)

        if root_tag:
            self.report_type = self.rType(root_tag,output)
        model.api.devlog(self.report_type)
        
    def getRootTag(self, xml_file_path):
        result = f = None
        try:
            f = open(xml_file_path, 'rb')
            try:
                for event, elem in ET.iterparse(f, ('start', )):
                    result = elem.tag
                    break
            except SyntaxError, err:
                self.report_type = None
                model.api.devlog("Not an xml file.\n %s" % (err))

        except IOError, err:
            self.report_type = None
            model.api.devlog("Error while opening file.\n%s. %s" % (err, xml_file_path))
        finally:
            f.seek(0)
            output=f.read()
            if f: f.close()
            
        return result,output
                    
    def rType(self, tag, output):
        """Compares report root tag with known root tags.
        
        :param root_tag
        :rtype
        """
        if "arachni_report" == tag:
            return "arachni"
        elif "nmaprun" == tag:
            return "nmap"
        elif "w3afrun" == tag:
            return "w3af"
        elif "NessusClientData_v2" == tag:
            return "nessus"
        elif "report" == tag:
            if re.search("alertitem",output) is None:
                return "openvas"
            else:
                return "zap"
        elif "niktoscan" == tag:
            return "nikto"
        elif "MetasploitV4" == tag:
            return "metasploit"
        elif "issues" == tag:
            return "burp"
        elif "OWASPZAPReport" == tag:
            return "zap"
        elif "ScanGroup" == tag:
            return "acunetix"
        elif "session" == tag:
            return "x1"
        elif "entities" == tag:
            return "impact"
        elif "NeXposeSimpleXML" == tag:
            return "nexpose"
        elif "SCAN" == tag:
            return "qualysguard"
        elif "scanJob" == tag:
            return "retina"
        elif "netsparker" == tag:
            return "netsparker"
        else:
            return None


########NEW FILE########
__FILENAME__ = session
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import time
import datetime
import hashlib


class Session(object):
    """
    It will handle a Faraday session, that contains:
        - current user logged in
        - session start time
        - duration
        - workspace history (?...here?)
        - current workspace (?...here?)
    """

    def __init__(self, user):
        self.logged_user = user
        self.start_time = datetime.datetime.now()
                                                 
        self.workspace_history = []
        self.current_workspace = None
                                                          
        self.__token = hashlib.sha224("%s_%s" % (self.logged_user, self.start_time)).hexdigest()

    def get_token():
        return self.__token

########NEW FILE########
__FILENAME__ = timeline
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

class Branch(object):
    pass

class BranchItem(object):
    pass



########NEW FILE########
__FILENAME__ = views
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

class View(object):
    """A view for the data in a CouchDB"""
    def __init__(self):
        pass
        

class HostsServiceFrequencies(View):
    pass

########NEW FILE########
__FILENAME__ = workspace
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import os
import model.api
import model
import time
import datetime
from model.report import ReportManager
from model.diff import HostDiff
from model.container import ModelObjectContainer, CouchedModelObjectContainer
from model.conflict import Conflict
from model.hosts import Host
from model.guiapi import notification_center as notifier


import mockito

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

import json
import shutil

from persistence.orm import WorkspacePersister

from managers.all import PersistenceManagerFactory, CouchdbManager, FSManager

class Workspace(object):
    """
    Handles a complete workspace (or project)
    It contains a reference to the model and the command execution
    history for all users working on the same workspace.
    It has a list with all existing workspaces just in case user wants to
    open a new one.
    """
                                                                    
                                             
                                                          
                                                               
                                                                                 
    
    def __init__(self, name, manager, shared=CONF.getAutoShareWorkspace()):
        self.name                   = name
        self.description            = ""
        self.customer               = ""
        self.start_date             = datetime.date(1,1,1)
        self.finish_date            = datetime.date(1,1,1)
        self.id                     = name                                                              
        self._command_history       = None
        self._model_controller      = None
        self._workspace_manager     = manager
        self.shared                 = shared                                      

        self._path                  = os.path.join(CONF.getPersistencePath(), name)
        self._persistence_excluded_filenames = ["categories.xml", "workspace.xml"]


        self.container = ModelObjectContainer()
        self.__conflicts            = []

        self._object_factory = model.common.factory
        self._object_factory.register(model.hosts.Host)
        
        self._report_path = os.path.join(CONF.getReportPath(), name)
        self._report_ppath = os.path.join(self._report_path,"process")
        
        if not os.path.exists(self._report_path):
            os.mkdir(self._report_path)
         
        if not os.path.exists(self._report_ppath):
            os.mkdir(self._report_ppath)

    def _notifyWorkspaceNoConnection(self):
        notifier.showPopup("Couchdb Connection lost. Defaulting to memory. Fix network and try again in 5 minutes.")

    def getReportPath(self):
        return self._report_path

    def saveObj(obj):raise NotImplementedError("Abstract method")
    def delObj(obj):raise NotImplementedError("Abstract method")

    def remove(self, host):
        del self.container[host.getID()]
        self.delObj(host)

    def save(self): raise NotImplementedError("Abstract method")
    def load(self): raise NotImplementedError("Abstract method")

        
    def setModelController(self, model_controller):
        self._model_controller = model_controller

    def getContainee(self):
        return self.container


    def set_path(self, path):
        self._path = path
    
    def get_path(self):
        return self._path
    

    def set_report_path(self, path):
        self._report_path = path
        if not os.path.exists(self._report_path):
            os.mkdir(self._report_path)
        self._workspace_manager.report_manager.path = self.report_path

    def get_report_path(self):
        return self._report_path
    
    path = property(get_path, set_path) 
    report_path = property(get_report_path, set_report_path)
    
                              
            
                                                           
                                     
            
             
     
                                    
            
                                                           
            
             
    
    def isActive(self):
        return self.name == self._workspace_manager.getActiveWorkspace().name

    def getAllHosts(self):
        return self._model_controller.getAllHosts()

    def getDeletedHosts(self):
        return self._model_controller.getDeletedHosts()
    
    def cleanDeletedHosts(self):
        self._model_controller.cleanDeletedHosts()

    def verifyConsistency(self):
                                                        
        hosts = self.getAllHosts()
        hosts_counter = 0
        for h1 in hosts[:-1]:
            hosts_counter += 1
            for h2 in hosts[hosts_counter:]:
                if h1 == h2 :
                    diff = HostDiff(h1, h2)
                    if diff.existDiff():
                        self.addConflict(Conflict(h1, h2))
                                           
                                                                     
        return len(self.getConflicts())


    def getDataManager(self):
        return self._dmanager

    def addConflict(self, conflict):
        self.__conflicts.append(conflict)

    def getConflicts(self):
        return self.__conflicts

    def clearConflicts(self):
        self.__conflicts.clear()

    def resolveConflicts(self):
        pass

    def conflictResolved(self, conflict):
        self.__conflicts.remove(conflict)

class WorkspaceOnFS(Workspace):

    def __init__(self, name, manager, shared=CONF.getAutoShareWorkspace()):
        Workspace.__init__(self, name, manager, shared) 
        self._dmanager = FSManager(self._path)

    @staticmethod
    def isAvailable():
        return True

    def saveObj(self, obj):
        host = obj.getHost()
        try: 
            model.api.devlog("Saving host to FileSystem")
            model.api.devlog("Host, %s" % host.getID())
            host_as_dict = host._toDict(full=True)
            filepath = os.path.join(self._path, host.getID() + ".json")
            with open(filepath, "w") as outfile:
                json.dump(host_as_dict, outfile, indent = 2) 
        except Exception:
            model.api.devlog("Failed while persisting workspace to filesystem, enough perms and space?")

    def delObj(self, obj):
        if obj.class_signature == "Host":
            self._dmanager.removeObject(obj.getID())
            return
        host = obj.getHost()
        self.saveObj(host)

    def syncFiles(self):
        self.load()

    def load(self):
                                                       
        files = os.listdir(self._path)
        files = filter(lambda f: f.endswith(".json") and f not in
                self._persistence_excluded_filenames, files)
        modelobjectcontainer = self.getContainee()
        for filename in files:
            newHost = self.__loadHostFromFile(filename)
            modelobjectcontainer[newHost.getID()] = newHost

    def __loadHostFromFile(self, filename):
        if os.path.basename(filename) in self._persistence_excluded_filenames:
            model.api.devlog("skipping file %s" % filename)
            return
        else:
            model.api.devlog("loading file %s" % filename)
            
        infilepath = os.path.join(self._path, filename)
        host_dict = {}
        try:
            with open(infilepath) as infile: 
                host_dict = json.load(infile) 
        except Exception, e:
            model.api.log("An error ocurred while parsing file %s\n%s" %
                     (filename, str(e)), "ERROR")
            return mockito.mock()
        
                                                                       
                                                                     
        try:
            newHost = Host(name=None, dic=host_dict)
                                        
            return newHost
        except Exception, e:
            model.api.log("Could not load host from file %s" % filename, "ERROR")
            model.api.devlog(str(e))
            return None


class WorkspaceOnCouch(Workspace):
    """A Workspace that is syncronized in couchdb"""
    def __init__(self, name, manager, *args):
        super(WorkspaceOnCouch, self).__init__(name, manager)
        self._is_replicated = replicated = CONF.getCouchIsReplicated()
        self.cdm  = self._dmanager = manager.couchdbmanager
            
        if not self.cdm.workspaceExists(name):
            self.cdm.addWorkspace(name)
            if self.is_replicated():
                self.cdm.replicate(self.name, *self.validate_replic_urls(CONF.getCouchReplics()), create_target = True)

        self.cdm.syncWorkspaceViews(name)

        self.container = CouchedModelObjectContainer(name, self.cdm)
       

    def syncFiles(self):
        self.load()

    @staticmethod
    def isAvailable():
        return CouchdbManager.testCouch(CONF.getCouchURI())

    def is_replicated(self):
        return self._is_replicated

    def validate_replic_urls(self, urlsString):
                                      
        urls = urlsString.split(";") if urlsString is not None else ""
                                                            
        valid_replics = []
        for url in urls:
            try:
                self.cdm.testCouchUrl(url)
                valid_replics.append(url)
            except:
                pass

        return valid_replics

    def saveObj(self, obj):
        self.cdm.saveDocument(self.name, obj._toDict())
        self.cdm.compactDatabase(self.name)

    def delObj(self, obj):
        obj_id = obj.ancestors_path()
        if self._dmanager.checkDocument(self.name, obj_id):
            self._dmanager.remove(self.name, obj_id)
  
    def save(self): 
        model.api.devlog("Saving workspaces")
        for host in self.getContainee().itervalues():
            host_as_dict = host.toDict()
            for obj_dic in host_as_dict:
                self.cdm.saveDocument(self.name, obj_dic)
                                            

    def load(self):
        self._model_controller.setSavingModel(True)
        hosts = {}

        def find_leaf(path, sub_graph = hosts):
            for i in path:
                if len(path) > 1:
                    return find_leaf(path[1:], sub_graph['subs'][i])
                else:
                    return sub_graph
        try:
            t = time.time()
            model.api.devlog("load start: %s" % str(t))
            docs = [i["doc"] for i in self.cdm.workspaceDocumentsIterator(self.name)]
            model.api.devlog("time to get docs: %s" % str(time.time() - t))
            t = time.time()
            for d in docs:
                id_path = d['_id'].split('.')
                if d['type'] == "Host":
                    hosts[d['_id']] = d
                    subs = hosts.get('subs', {})
                    subs[d['_id']] = d
                    hosts['subs'] = subs
                    continue

                leaf = find_leaf(id_path)
                subs = leaf.get('subs', {})
                subs[d['obj_id']] = d
                leaf['subs'] = subs

                key = "%s" % d['type']
                key = key.lower()
                sub = leaf.get(key, {})
                sub[d['obj_id']] = d
                leaf[key] = sub
            model.api.devlog("time to reconstruct: %s" % str(time.time() - t))
            t = time.time()

            self.container.clear()
            for k, v in hosts.items():
                if k is not "subs":
                    h = Host(name=None, dic=v)
                    self.container[k] = h
            model.api.devlog("time to fill container: %s" % str(time.time() - t))
            t = time.time()
        except Exception, e:
            model.api.devlog("Exception during load: %s" % e)
        finally:
            self._model_controller.setSavingModel(False)
            notifier.workspaceLoad(self.getAllHosts())


class WorkspaceManager(object):
    """
    This handles all workspaces. It checks for existing workspaces inside
    the persistence directory.
    It is in charge of starting the WorkspacesAutoSaver to persist each workspace.
    This class stores information in $HOME/.faraday/config/workspacemanager.xml file
    to keep track of created workspaces to be able to load them
    """
    def __init__(self, model_controller, plugin_controller):
        self.active_workspace = None
                                                                  
        self._couchAvailable  = False 
        self.report_manager = ReportManager(10, plugin_controller)
        
        self.couchdbmanager = PersistenceManagerFactory().getInstance()
        
        self._workspaces = {}
        self._model_controller = model_controller
        self._excluded_directories = [".svn"]
        self.workspace_persister = WorkspacePersister()

    def couchAvailable(self, isit):
        self._couchAvailable = isit

    def reconnect(self):
        if not self.reconnectCouchManager():
            self._notifyWorkspaceNoConnection()

    def getCouchManager(self):
        return self.couchdbmanager

    def setCouchManager(self, cm):
        self.couchdbmanager = cm

    @staticmethod
    def getAvailableWorkspaceTypes(): 
        av = [w.__name__ for w in Workspace.__subclasses__() if w.isAvailable() ]
        model.api.devlog("Available wortkspaces: %s" ", ".join(av))
        return av
        
    def reconnectCouchManager(self):
        retval = True
        if not self.couchdbmanager.reconnect():
            retval = False
            return retval
        WorkspacePersister.reExecutePendingActions() 
        return retval
    
    def startAutoLoader(self): 
        pass

    def stopAutoLoader(self):
        pass
    

    def startReportManager(self):
        self.report_manager.start()
    
    def stopReportManager(self):
        self.report_manager.stop()
        self.report_manager.join()
        
    def getActiveWorkspace(self):
        return self.active_workspace
    
    def saveWorkspaces(self):
        pass
            
    def addWorkspace(self, workspace):
        self._workspaces[workspace.name] = workspace
 
    def createVisualizations(self):
        stat = False
        url = ""
        if self.couchdbmanager.isAvailable():
            stat = True
            url  = self.couchdbmanager.pushReports()
        else:
            self._notifyNoVisualizationAvailable()
        return stat, url

    def _notifyNoVisualizationAvailable(self):
        notifier.showPopup("No visualizations available, please install and configure CouchDB")

    def createWorkspace(self, name, description="", workspaceClass = WorkspaceOnFS, shared=CONF.getAutoShareWorkspace(),
                        customer="", sdate=None, fdate=None):
        if name not in self._workspaces:
            w = workspaceClass(name, self, shared)
            w.description = description
            w.customer = customer
            if sdate is not None:
                w.start_date = sdate
            if fdate is not None:
                w.finish_date = fdate
            self.addWorkspace(w)
        else:
            w = self._workspaces[name]
        return w

    def removeWorkspace(self, name):
        dm = self.getWorkspace(name).getDataManager()
        dm.removeWorkspace(name)
                       
        datapath = CONF.getDataPath()
        todelete = [i for i in os.listdir(datapath) if name in i ]
        for i in todelete:
            os.remove(os.path.join(datapath, i))

        shutil.rmtree(self.getWorkspace(name).getReportPath())
        del self._workspaces[name]
        if self.getWorkspace(name) == self.getActiveWorkspace() and self.getWorkspacesCount() > 0: 
            self.setActiveWorkspace(self.getWorkspace(self._workspaces.keys()[0]))

    def getWorkspace(self, name):
        return self._workspaces.get(name)
    
    def openWorkspace(self, name):
        if name in self._workspaces:
            w = self._workspaces[name]
            self.setActiveWorkspace(w)
            return w
        raise Exception("Error on OpenWorkspace for %s "  % name)
        
    def getWorkspaces(self):
        """
        Simply returns a list of all existing workspaces (including the active one)
        """
        self.loadWorkspaces()
        return [w for w in self._workspaces.itervalues()]
    
    def getWorkspacesCount(self):
        return len(self._workspaces)

    def getWorkspacesNames(self):
        return self._workspaces.keys()
        
    def loadWorkspaces(self): 
        self._workspaces.clear()
        for name in os.listdir(CONF.getPersistencePath()):
            if name not in self._workspaces:
                if os.path.isdir(os.path.join(CONF.getPersistencePath(),name)) and name not in self._excluded_directories:
                    w = self.createWorkspace(name, workspaceClass = WorkspaceOnFS)

        for name in self.couchdbmanager.getWorkspacesNames():
            if name not in self._workspaces and not name == "reports":
                self.createWorkspace(name, workspaceClass = WorkspaceOnCouch)
    
    def setActiveWorkspace(self, workspace):
        try:
            self.stopAutoLoader()
        except : pass

        if self.active_workspace is not None:
            self.active_workspace.setModelController(None)
        CONF.setLastWorkspace(workspace.name)
        CONF.saveConfig()
        self.active_workspace = workspace
        self.active_workspace.setModelController(self._model_controller)
        self._model_controller.setWorkspace(self.active_workspace)
        self.workspace_persister.setPersister(self.active_workspace, self.active_workspace._dmanager)

        self.report_manager.path = workspace.report_path

        if isinstance(self.active_workspace, WorkspaceOnCouch):
            self.startAutoLoader()
                
    def syncWorkspaces(self):
        """
        Synchronize persistence directory using the DataManager.
        We first make sure that all shared workspaces were added to the repo
        """
        pass

                                                                                
class NotSyncronizableWorkspaceException(Exception): pass
class ConflictsPendingToSolveException(Exception): pass

class WorkspaceSyncronizer(object):
    """Object whom purpose is to correctly syncronize a workspace
    Interacts with a DataManager and a Workspace Object as a mediator"""
    def __init__(self, workspace):
        self._workspace = workspace
        self._dmanager = workspace.getDataManager()

    def sync(self):
        if not self.localCheck():
            return False
                                  
        self._workspace.save()
        self._workspace.syncFiles()
        return True

    def localCheck(self):
        return True
                         
                                                                             
        if (self._workspace.verifyConsistency() > 0):
            if (len(self._workspace.resolveConflicts(local=True)) < 
                len(self._workspace.getConflicts())):
                                                                        
                return False
        return True


########NEW FILE########
__FILENAME__ = orm
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import model
import  threading 
import traceback

class WorkspacePersister(object):
    _instance = None
    _persister = None
    _workspace = None
    _workspace_autoloader = None
    _pending_actions = None


    def __new__(cls, *args, **kargs): 
        if cls._instance is None:
            cls._instance = object.__new__(cls, *args, **kargs)
        return cls._instance

                                   
                                    

    def setPersister(self, workspace, persister):
        WorkspacePersister._persister = persister
        WorkspacePersister._workspace = workspace
        WorkspacePersister._workspace_autoloader = WorkspaceAutoSync(self.reloadWorkspace, self.backendChangeListener)
        WorkspacePersister._workspace_autoloader.start()
        WorkspacePersister._pending_actions = PendingTransactionsQueue()

    @staticmethod
    def stopThreads():
        WorkspacePersister._workspace_autoloader.stop() 

    def reloadWorkspace(self):
        WorkspacePersister._workspace.load() 

    @staticmethod
    def addPendingAction(obj, func, args, kwargs):
        if "wait" not in func.__name__:
            WorkspacePersister._pending_actions.pushPendingTransaction(obj, func, args, kwargs)

    @staticmethod
    def reExecutePendingActions():
        for (obj, func, args, kwargs) in WorkspacePersister._pending_actions:
            func(obj, *args, **kwargs)
            
        model.api.devlog("Re executing")

    @staticmethod
    def notifyPersisterConnectionLost():
        WorkspacePersister._workspace.notifyWorkspaceNoConnection()

    def backendChangeListener(self): 
        changes = WorkspacePersister._persister.waitForDBChange(WorkspacePersister._workspace.name)
        return changes

    @staticmethod
    def save(obj):
        if WorkspacePersister._workspace is not None:
            WorkspacePersister._workspace.saveObj(obj)

    @staticmethod
    def delete(obj):
        if WorkspacePersister._workspace:
            WorkspacePersister._workspace.delObj(obj)

class WorkspaceAutoSync(threading.Thread):
    def __init__(self, action_callback, listener):
        threading.Thread.__init__(self)
        self.setDaemon(True)
        self._stop = False
        self._listener = listener
        self._action = action_callback

    def run(self):
                     
        while not self._stop:
            try:
                result = self._listener()
                if result:
                    model.api.devlog("Changes found: %s" % result)
                    self._action()
            except Exception, e:
                model.api.devlog("An exception was captured while saving workspaces\n%s" % traceback.format_exc())

    def stop(self):
        self._stop = True

    def start(self):
        self._stop = False
        threading.Thread.start(self)


class PendingTransactionsQueue(object):
    def __init__(self):
        self.pending = []

    def pushPendingTransaction(self, obj, func, args, kwargs):
        self.pending.insert(0, (obj, func, args, kwargs))

    def __iter__(self):
        return self

    def next(self):
        try:
            return self.pending.pop()
        except IndexError:
            raise StopIteration 


########NEW FILE########
__FILENAME__ = utils
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import sys
try:
    import xml.etree.cElementTree as ET
    
except ImportError:
    print "cElementTree could not be imported. Using ElementTree instead"
    import xml.etree.ElementTree as ET

import xml.etree.ElementTree as pyET
import model.api
    

def SafeXmlElement(tag, attrib={}, **extra):
    """
    ElementTree has some issues to persist certain types.
    This function goes through the items and makes sure types are converted
    before creating the real element.
    """
    attrib = attrib.copy()
    attrib.update(extra)
    to_update = {}
    for k,v in attrib.iteritems():
        if isinstance(v, list) or isinstance(v, tuple):
            to_update[k] = ",".join([str(i) for i in v])
        elif isinstance(v, dict):
            model.api.devlog("dict type found while creating ElementTree node %s (%s)" % (tag, str(v)))
            to_update[k] = str(v)
        elif isinstance(v, int):
            to_update[k] = str(v)
    
    for k, v in to_update.iteritems():
        attrib[k] = v
    
    return ET.Element(tag, attrib)

def custom_serialize_xml(write, elem, encoding, qnames, namespaces, indentation='\n'):
    """
    Custom function to serialize XML. Basically is a copy of ElementTree._serialize_xml
    that adds indentantion and newlines to each of the attributes in a tag.
    This results in each attribute and value in a different line that helps
    with svn synchronization to avoid file conflicts.
    This function should only be used with python 2.7
    """
    tag = elem.tag
    text = elem.text
    next_indentation = elem.tail
    if tag is ET.Comment:
        write("<!--%s-->" % pyET._encode(text, encoding))
    elif tag is ET.ProcessingInstruction:
        write("<?%s?>" % pyET._encode(text, encoding))
    else:
        tag = qnames[tag]
        if tag is None:
            if text:
                write(pyET._escape_cdata(text, encoding))
            for e in elem:
                custom_serialize_xml(write, e, encoding, qnames, None, next_indentation)
        else:
            write("<" + tag)
            items = elem.items()
            if items or namespaces:
                if namespaces:
                    for v, k in sorted(namespaces.items(),
                                       key=lambda x: x[1]):  
                        if k:
                            k = ":" + k
                        write("%s\t\txmlns%s=\"%s\"" % (
                                    indentation,
                                    k.encode(encoding),
                                    pyET._escape_attrib(v, encoding) )
                              )
                for k, v in sorted(items):
                    if isinstance(k, ET.QName):
                        k = k.text
                    if isinstance(v, ET.QName):
                        v = qnames[v.text]
                    else:
                        v = pyET._escape_attrib(v, encoding)
                    write("%s\t\t%s=\"%s\"" % (indentation, qnames[k], v))
            if text or len(elem):
                write(">")
                if text:
                    write(pyET._escape_cdata(text, encoding))
                for e in elem:
                    custom_serialize_xml(write, e, encoding, qnames, None, next_indentation)
                write("</" + tag + ">")
            else:
                write(" />")
    if elem.tail:
        write(pyET._escape_cdata(elem.tail, encoding))

def custom_xml_write(self, file, node, encoding, namespaces, indentation='\n'):
    """
    Custom write function based on ElementTree.ElementTree._write only for python 2.6
    Basically it does the same but writes each attribute in a different line
    The same was done with custom_serialize_xml for python 2.7
    """
    tag = node.tag
    next_indentation = node.tail
    if tag is pyET.Comment:
        file.write("<!-- %s -->" % pyET._escape_cdata(node.text, encoding))
    elif tag is pyET.ProcessingInstruction:
        file.write("<?%s?>" % pyET._escape_cdata(node.text, encoding))
    else:
        items = node.items()
        xmlns_items = []
        try:
            if isinstance(tag, pyET.QName) or tag[:1] == "{":
                tag, xmlns = pyET.fixtag(tag, namespaces)
                if xmlns: xmlns_items.append(xmlns)
        except TypeError:
            pyET._raise_serialization_error(tag)
        file.write("<" + pyET._encode(tag, encoding))
        if items or xmlns_items:
            items.sort()
            for k, v in items:
                try:
                    if isinstance(k, pyET.QName) or k[:1] == "{":
                        k, xmlns = pyET.fixtag(k, namespaces)
                        if xmlns: xmlns_items.append(xmlns)
                except TypeError:
                    pyET._raise_serialization_error(k)
                try:
                    if isinstance(v, pyET.QName):
                        v, xmlns = pyET.fixtag(v, namespaces)
                        if xmlns: xmlns_items.append(xmlns)
                except TypeError:
                    pyET._raise_serialization_error(v)
                file.write("%s\t\t%s=\"%s\"" % (indentation, pyET._encode(k, encoding),
                                                pyET._escape_attrib(v, encoding)))
            for k, v in xmlns_items:
                file.write("%s\t\t%s=\"%s\"" % (indentation, pyET._encode(k, encoding),
                                                pyET._escape_attrib(v, encoding)))
        if node.text or len(node):
            file.write(">")
            if node.text:
                file.write(pyET._escape_cdata(node.text, encoding))
            for n in node:
                self._write(file, n, encoding, namespaces, next_indentation)
            file.write("</" + pyET._encode(tag, encoding) + ">")
        else:
            file.write(" />")
        for k, v in xmlns_items:
            del namespaces[v]
    if node.tail:
        file.write(pyET._escape_cdata(node.tail, encoding))

major, minor = sys.version_info[0:2]
if minor == 7:
    pyET._serialize_xml = custom_serialize_xml
elif minor == 6:
    pyET.ElementTree._write = custom_xml_write
else:
    print "nothing to replace on ElementTree for python %d.%d" % (major, minor)


def indent_xml(elem, level=0):
    i = "\n" + level*"  "
    if len(elem):
        if not elem.text or not elem.text.strip():
            elem.text = i + "  "
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
        for elem in elem:
            indent_xml(elem, level+1)
        if not elem.tail or not elem.tail.strip():
            elem.tail = i
    else:
        if level and (not elem.tail or not elem.tail.strip()):
            elem.tail = i
  
def write_xml(xml_node, filepath, parent=None):
    """
    A little helper to write xml to a file or append to parent
    """   
    if parent is None:
        indent_xml(xml_node)
        tree = ET.ElementTree(xml_node)
        tree.write(filepath, encoding="UTF-8")
    else:
        parent.append(xml_node)
########NEW FILE########
__FILENAME__ = api
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import threading
import logging
import requests
import json
import base64

from flask import Flask, request, jsonify
from tornado.wsgi import WSGIContainer
from tornado.httpserver import HTTPServer
from tornado.ioloop import IOLoop

from plugins.core import PluginControllerForApi
from managers.all import CommandManager


_plugin_controller_api = None
_http_server = None


def startServer():
    global _http_server
    if _http_server is not None:
        IOLoop.instance().start()


def stopServer():
    global _http_server
    if _http_server is not None:
        IOLoop.instance().stop()


def startPluginControllerAPI(plugin_manager):
    global _plugin_controller_api
    global _http_server
    if _plugin_controller_api is None:
        #TODO: load API configuration from config file
        hostname = "localhost"
        port = 9977
        _plugin_controller_api = PluginControllerAPI(plugin_manager,
                                                     hostname,
                                                     port)
        if _http_server is None:
            _http_server = HTTPServer(WSGIContainer(_plugin_controller_api.getApp()))
            _http_server.listen(port)
            logging.getLogger("tornado.access").addHandler(logging.NullHandler())
            logging.getLogger("tornado.access").propagate = False
            threading.Thread(target=startServer).start()


def stopPluginControllerAPI():
    stopServer()


class PluginControllerAPI(object):
    def __init__(self, plugin_manager, hostname, port):
        self.plugin_controller = PluginControllerForApi("PluginController", plugin_manager.getPlugins(), CommandManager())
        self.app = Flask(__name__.split('.')[0])
        self.addRoutes()
        self.hostname = hostname
        self.port = port
        #self.api = Api(self.app)

    def getApp(self):
        return self.app

    #def run(self):
    #    self.app.run(host=self.hostname, port=self.port)

    def addRoutes(self):
        self.app.add_url_rule('/cmd/input',
                              view_func=self.postCmdInput,
                              methods=['POST'])
        self.app.add_url_rule('/cmd/output',
                              view_func=self.postCmdOutput,
                              methods=['POST'])
        self.app.add_url_rule('/cmd/active-plugins',
                              view_func=self.clearActivePlugins,
                              methods=['DELETE'])

    def startAPI(self):
        pass

    def stopAPI(self):
        pass

    def badRequest(self, message):
        error = 400
        return jsonify(error=error,
                       message=message), error

    def noContent(self, message):
        code = 204
        return jsonify(code=code,
                       message=message), code

    def pluginAvailable(self, new_cmd, output_file):
        code = 200
        return jsonify(code=code,
                       cmd=new_cmd,
                       custom_output_file=output_file)

    def ok(self, message):
        code = 200
        return jsonify(code=code,
                       message=message)

    def postCmdInput(self):
        json_data = request.get_json()
        if 'cmd' in json_data.keys():
            cmd = json_data.get('cmd')
            has_plugin, new_cmd, output_file = self.plugin_controller.\
                processCommandInput(cmd)
            if has_plugin:
                return self.pluginAvailable(new_cmd, output_file)
            return self.noContent("no plugin available for cmd")
        #cmd not sent, bad request
        return self.badRequest("cmd parameter not sent")

    def postCmdOutput(self):
        json_data = request.get_json()
        if 'cmd' in json_data.keys():
            if 'output' in json_data.keys():
                cmd = json_data.get('cmd')
                output = base64.b64decode(json_data.get('output'))
                if self.plugin_controller.onCommandFinished(cmd, output):
                    return self.ok("output successfully sent to plugin")
                return self.badRequest("output received but no active plugin")
            return self.badRequest("output parameter not sent")
        return self.badRequest("cmd parameter not sent")

    def clearActivePlugins(self):
        self.plugin_controller.clearActivePlugins()
        return self.ok("active plugins cleared")


class PluginControllerAPIClient(object):
    def __init__(self, hostname, port):
        self.hostname = hostname
        self.port = port
        self.url_input = "http://%s:%d/cmd/input" % (self.hostname, self.port)
        self.url_output = "http://%s:%d/cmd/output" % (self.hostname, self.port)
        self.url_active_plugins = "http://%s:%d/cmd/active-plugins" % (self.hostname, self.port)
        self.headers = {'Content-type': 'application/json', 'Accept': 'application/json'}

    def send_cmd(self, cmd):
        data = {"cmd": cmd}
        new_cmd = cmd
        try:
            response = requests.post(self.url_input,
                                     data=json.dumps(data),
                                     headers=self.headers)

            if response.status_code == 200:
                json_response = response.json()
                if "cmd" in json_response.keys():
                    if json_response.get("cmd") is not None:
                        new_cmd = json_response.get("cmd")
                if "custom_output_file" in json_response.keys():
                    output_file = json_response.get("custom_output_file")
        except:
            new_cmd = cmd
        finally:
            return new_cmd, output_file

    def send_output(self, cmd, output_file):
        output_file = open(output_file)
        output = base64.b64encode(output_file.read())
        data = {"cmd": cmd, "output": output}
        response = requests.post(self.url_output,
                                 data=json.dumps(data),
                                 headers=self.headers)
        if response.status_code != 200:
            return False
        return True
########NEW FILE########
__FILENAME__ = core
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import multiprocessing
import shlex
import copy_reg
import types
import model.api
from cStringIO import StringIO
import os
import re
import Queue
import traceback
import model.common
import errno

from model.commands_history import CommandRunInformation

from time import time

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()


def _pickle_method(method):
    func_name = method.im_func.__name__
    obj = method.im_self
    cls = method.im_class
    return _unpickle_method, (func_name, obj, cls)


def _unpickle_method(func_name, obj, cls):
    for cls in cls.mro():
        try:
            func = cls.__dict__[func_name]
        except KeyError:
            pass
        else:
            break
        return func.__get__(obj, cls)

copy_reg.pickle(types.MethodType, _pickle_method, _unpickle_method)


class modelactions:
    ADDHOST             = 2000
    CADDHOST            = 2001
    ADDINTERFACE        = 2002
    CADDINTERFACE       = 2003
    ADDSERVICEINT       = 2004
    ADDSERVICEAPP       = 2005
    CADDSERVICEINT      = 2006
    CADDSERVICEAPP      = 2007
    CADDSERVICEHOST     = 2008
    ADDAPPLICATION      = 2009
    CADDAPPLICATION     = 2010
    ADDVULNINT          = 2013
    CADDVULNINT         = 2014
    ADDVULNAPP          = 2015
    CADDVULNAPP         = 2016
    ADDVULNHOST         = 2017
    CADDVULNHOST        = 2018
    ADDVULNSRV          = 2019
    CADDVULNSRV         = 2020
    ADDNOTEINT          = 2021
    CADDNOTEINT         = 2022
    ADDNOTEAPP          = 2023
    CADDNOTEAPP         = 2024
    ADDNOTEHOST         = 2025
    CADDNOTEHOST        = 2026
    ADDNOTESRV          = 2027
    CADDNOTESRV         = 2028
    CADDNOTEVULN        = 2030
    CADDNOTEVULN        = 2031
    LOG                 = 2032
    DEVLOG              = 2033
    DELSERVICEINT       = 2034
    ADDCREDSRV       = 2035
    CADDCREDSRV      = 2036
    ADDVULNWEBSRV          = 2037
    CADDVULNWEBSRV         = 2038
    ADDNOTENOTE         = 2039
    CADDNOTENOTE        = 2039
    
    __descriptions = {
        ADDHOST             : "ADDHOST",
        CADDHOST            : "CADDHOST",
        ADDINTERFACE        : "ADDINTERFACE",
        CADDINTERFACE       : "CADDINTERFACE",
        ADDSERVICEINT       : "ADDSERVICEINT",
        ADDSERVICEAPP       : "ADDSERVICEAPP",
        CADDSERVICEINT      : "CADDSERVICEINT",
        CADDSERVICEAPP      : "CADDSERVICEAPP",
        CADDSERVICEHOST     : "CADDSERVICEHOST",
        ADDAPPLICATION      : "ADDAPPLICATION",
        CADDAPPLICATION     : "CADDAPPLICATION",
        ADDVULNINT          : "ADDVULNINT",
        CADDVULNINT         : "CADDVULNINT",
        ADDVULNAPP          : "ADDVULNAPP",
        CADDVULNAPP         : "CADDVULNAPP",
        ADDVULNHOST         : "ADDVULNHOST",
        CADDVULNHOST        : "CADDVULNHOST",
        ADDVULNSRV          : "ADDVULNSRV",
        CADDVULNSRV         : "CADDVULNSRV",
        LOG                 : "LOG",
        DEVLOG              : "DEVLOG",
        DELSERVICEINT       : "DELSERVICEINT",
        ADDCREDSRV       : "ADDCREDINT",
        ADDVULNWEBSRV          : "ADDVULNWEBSRV",
        CADDVULNWEBSRV         : "CADDVULNWEBSRV",
        ADDNOTENOTE          : "ADDNOTENOTE",
        CADDNOTENOTE         : "CADDNOTENOTE",
    }

    @staticmethod
    def getDescription(action):
        return modelactions.__descriptions.get(action, "")


class PluginControllerBase(object):
    """
    TODO: Doc string.
    """
    def __init__(self, id, available_plugins, command_manager):
        self._plugins               = available_plugins
        self.id                     = id
        self._actionDispatcher      = None
        self._setupActionDispatcher()

        self._command_manager = command_manager
        self.last_command_information  = None

    def _find_plugin(self, new_plugin_id):
        try:
            return self._plugins[new_plugin_id]
        except KeyError:
            return None

    def setLastCommandInformation(self, command_string):
        self.last_command_information = CommandRunInformation( **{'workspace': model.api.getActiveWorkspace().name,
                                                        'itime': time(),
                                                        'command': command_string.split()[0],
                                                        'params': ' '.join(command_string.split()[1:])})

    def _is_command_malformed(self, original_command, modified_command):
        """
        Checks if the command to be executed is safe and it's not in the block list
        defined by the user. Returns False if the modified command is ok, True if
        otherwise.

        TODO: Use global command block list.
        TODO: complete block idioms
        """
        block_chars = set(["|", "$", "#"])

        if original_command == modified_command:
            return False

        orig_cmd_args = shlex.split(original_command)

        if not isinstance(modified_command, basestring):
            modified_command = ""
        mod_cmd_args = shlex.split(modified_command)

        block_flag = False
        orig_args_len = len(orig_cmd_args)
        for index in xrange(0, len(mod_cmd_args)):
            if index < orig_args_len and orig_cmd_args[index] == mod_cmd_args[index]:
                continue

            for char in block_chars:
                if char in mod_cmd_args[index]:
                    block_flag = True
                    break

        return block_flag

    def _get_plugins_by_input(self, current_input):
        """
        Finds a plugin that can parse the current input and returns the plugin
        object. Otherwise returns None.
        """
        for plugin in self._plugins.itervalues():
            if plugin.canParseCommandString(current_input):
                return plugin
        return None

    def getAvailablePlugins(self):
        """
        Return a dictionary with the available plugins.
        Plugin ID's as keys and plugin instences as values
        """
        return self._plugins

    def processOutput(self, plugin, output):
        output_queue = multiprocessing.JoinableQueue()
        new_elem_queue = multiprocessing.Queue()

        plugin_process = PluginProcess(plugin, output_queue, new_elem_queue)
        model.api.devlog("PluginController (%d) - Created plugin_process (%d) for plugin instance (%d)" %
                         (id(self), id(plugin_process), id(plugin)))

        plugin_process.start()

        output_queue.put(output)
        output_queue.put(None)
        output_queue.join()

        #model.api.devlog("Core: queue size '%s'" % new_elem_queue.qsize())
        while True:
            try:
                current_action = new_elem_queue.get(block=False)
                if current_action is None:
                    break
                action = current_action[0]
                parameters = current_action[1:]
                model.api.devlog("Core: Processing a new '%s' , parameters (%s) \n" % (action,str(parameters)))
                self._processAction(action, parameters)

            except Queue.Empty:
                continue
            except IOError, e:
                if e.errno == errno.EINTR:
                    continue
                else:
                    model.api.devlog("PluginController.onCommandFinished - new_elem_queue Exception- something strange happened... unhandled exception?")
                    model.api.devlog(traceback.format_exc())
                    break
            except Exception:
                model.api.devlog("PluginController.onCommandFinished - new_elem_queue Exception- something strange happened... unhandled exception?")
                model.api.devlog(traceback.format_exc())
                break
        
        # Finally we register the recently executed command information
        self.last_command_information.duration = time() - self.last_command_information.itime
        workspace = model.api.getActiveWorkspace()
        self._command_manager.saveCommand(self.last_command_information, workspace)

    def _processAction(self, action, parameters):
        """
        decodes and performs the action given
        It works kind of a dispatcher
        """
        model.api.devlog("(PluginController) _processAction - %s - parameters = %s" % (action, str(parameters)))
        res = self._actionDispatcher[action](*parameters)

    def _setupActionDispatcher(self):
        self._actionDispatcher = {
                    modelactions.ADDHOST : model.api.addHost,
                    modelactions.CADDHOST : model.api.createAndAddHost,
                    modelactions.ADDINTERFACE : model.api.addInterface,
                    modelactions.CADDINTERFACE : model.api.createAndAddInterface,
                    modelactions.ADDSERVICEINT : model.api.addServiceToInterface,
                    modelactions.ADDSERVICEAPP : model.api.addServiceToApplication,
                    modelactions.CADDSERVICEINT : model.api.createAndAddServiceToInterface,
                    modelactions.CADDSERVICEAPP : model.api.createAndAddServiceToApplication,
                    modelactions.ADDAPPLICATION : model.api.addApplication,
                    modelactions.CADDAPPLICATION :  model.api.createAndAddApplication,
                    modelactions.DELSERVICEINT : model.api.delServiceFromInterface,
                    #Vulnerability
                    modelactions.ADDVULNINT : model.api.addVulnToInterface,
                    modelactions.CADDVULNINT : model.api.createAndAddVulnToInterface,
                    modelactions.ADDVULNAPP : model.api.addVulnToApplication,
                    modelactions.CADDVULNAPP : model.api.createAndAddVulnToApplication,
                    modelactions.ADDVULNHOST : model.api.addVulnToHost,
                    modelactions.CADDVULNHOST : model.api.createAndAddVulnToHost,
                    modelactions.ADDVULNSRV : model.api.addVulnToService,
                    modelactions.CADDVULNSRV : model.api.createAndAddVulnToService,
                    #VulnWeb
                    modelactions.ADDVULNWEBSRV : model.api.addVulnWebToService,
                    modelactions.CADDVULNWEBSRV : model.api.createAndAddVulnWebToService,
                    #Note
                    modelactions.ADDNOTEINT : model.api.addNoteToInterface,
                    modelactions.CADDNOTEINT : model.api.createAndAddNoteToInterface,
                    modelactions.ADDNOTEAPP : model.api.addNoteToApplication,
                    modelactions.CADDNOTEAPP : model.api.createAndAddNoteToApplication,
                    modelactions.ADDNOTEHOST : model.api.addNoteToHost,
                    modelactions.CADDNOTEHOST : model.api.createAndAddNoteToHost,
                    modelactions.ADDNOTESRV : model.api.addNoteToService,
                    modelactions.CADDNOTESRV : model.api.createAndAddNoteToService,
                    modelactions.ADDNOTENOTE : model.api.addNoteToNote,
                    modelactions.CADDNOTENOTE : model.api.createAndAddNoteToNote,                    
                    #Creds
                    modelactions.CADDCREDSRV : model.api.createAndAddCredToService,
                    modelactions.ADDCREDSRV  :  model.api.addCredToService,
                    #modelactions.ADDNOTEVULN : model.api.createAndAddNoteToApplication,
                    #modelactions.CADDNOTEVULN : model.api.createAndAddNoteToApplication,
                    #LOG
                    modelactions.LOG : model.api.log,
                    modelactions.DEVLOG : model.api.devlog,
        }

    def updatePluginSettings(self, plugin_id, new_settings):
        if plugin_id in self._plugins:
            self._plugins[plugin_id].updateSettings(new_settings)


class PluginController(PluginControllerBase):
    """
    TODO: Doc string.
    """
    def __init__(self, id, available_plugins, command_manager):
        PluginControllerBase.__init__(self, id, available_plugins, command_manager)
        self._active_plugin = None
        self._buffer = StringIO()

    def setActivePlugin(self, plugin):
        self._active_plugin = plugin

    def processCommandInput(self, prompt, username, current_path, command_string, interactive):
        """
        Receives the prompt that the current session has, the actual command_string that
        the user typed and if the command is interactive. If it is interactive the
        plugin controller does not choose a new active plugin but use the one the
        is already set (if none is set it raises an exeception).

        If always returns an string. It could be modified by the active plugin or, if
        there is none available, it will return the original command_string.
        """

        if interactive:
            return None
        else:
            self._disable_active_plugin()

        choosen_plugin = self._get_plugins_by_input(command_string)
        if choosen_plugin is None:
            model.api.devlog("There is no active plugin to handle current command/user input")
            return None
        self._active_plugin = choosen_plugin

        modified_cmd_string = self._active_plugin.processCommandString(
                                                                username,
                                                                current_path,
                                                                command_string)

        if self._is_command_malformed(command_string, modified_cmd_string):
            return None
        else:
            self.setLastCommandInformation(command_string)
            return modified_cmd_string if isinstance(modified_cmd_string, basestring) else None

    def storeCommandOutput(self, output):
        """
        Receives and output string and stores it in the buffer. Returns False
        if the output was not added to the plugin controllers buffer. Returns
        True otherwise.
        """
        if not self.getActivePluginStatus():
            return False
        else:
            self._buffer.write(output)
            return True

    def getPluginAutocompleteOptions(self, prompt, username, current_path, command_string, interactive):
        """
        This method should return a list of possible completitions based on the
        current output.
        TODO: We should think how to actually implement this...
        May be checking which plugin should handle the command in the current input
        and then passing it to the plugin to return a list of possible values.
        Each plugin implementation should return possible option according to
        what was received since it's the plugin the one it knows the command line
        parameters, etc.
        """
        if interactive:
            return None
        else:
            self._disable_active_plugin()

        choosen_plugin = self._get_plugins_by_input(command_string)
        if choosen_plugin is None:
            model.api.devlog("There is no active plugin to handle current command/user input")
            return None

        self._active_plugin = choosen_plugin

        new_options = self._active_plugin.getCompletitionSuggestionsList(command_string)
        return new_options

    def getActivePluginStatus(self):
        """
        Returns true if an active plugin is set, otherwise return False.
        """
        return (self._active_plugin is not None)

    def _disable_active_plugin(self):
        """
        This method is suppose to disable the active plugin.
        """
        model.api.devlog("Disabling active plugin")
        self._active_plugin = None

    def onCommandFinished(self):
        """
        This method is called when the last executed command has finished. It's
        in charge of giving the plugin the output to be parsed.
        """
        if self._active_plugin.has_custom_output():
            output_file = open(self._active_plugin.get_custom_file_path(), 'r')
            output = output_file.read()
            self._buffer.seek(0)
            self._buffer.truncate()
            self._buffer.write(output)

        self.processOutput(self._active_plugin, self._buffer.getvalue())

        self._buffer.seek(0)
        self._buffer.truncate()
        model.api.devlog("PluginController buffer cleared")

        self._disable_active_plugin()

        return True


class PluginControllerForApi(PluginControllerBase):
    def __init__(self, id, available_plugins, command_manager):
        PluginControllerBase.__init__(self, id, available_plugins, command_manager)
        self._active_plugins = {}

    def setActivePlugin(self, plugin):
        self._active_plugin = plugin

    def processCommandInput(self, command_string):

        plugin = self._get_plugins_by_input(command_string)

        if plugin:
            modified_cmd_string = plugin.processCommandString("", "", command_string)
            if not self._is_command_malformed(command_string, modified_cmd_string):
                self._active_plugins[command_string] = plugin
                output_file_path = None
                if plugin.has_custom_output():
                    output_file_path = plugin.get_custom_file_path()
                self.setLastCommandInformation(command_string)
                return True, modified_cmd_string, output_file_path

        return False, None, None

    def getPluginAutocompleteOptions(self, command_string):
        # if interactive:
        #     return None
        # else:
        #     self._disable_active_plugin()

        # choosen_plugin = self._get_plugins_by_input(command_string)
        # if choosen_plugin is None:
        #     model.api.devlog("There is no active plugin to handle current command/user input")
        #     return None

        # self._active_plugin = choosen_plugin

        # new_options = self._active_plugin.getCompletitionSuggestionsList(command_string)
        # return new_options
        pass

    def _disable_active_plugin(self):
        model.api.devlog("Disabling active plugin")
        self._active_plugin = None

    def onCommandFinished(self, cmd, output):
        if cmd not in self._active_plugins.keys():
            return False

        self.processOutput(self._active_plugins.get(cmd), output)

        del self._active_plugins[cmd]
        return True

    def clearActivePlugins(self):
        self._active_plugins = {}


class PluginBase(object):
    # TODO: Add class generic identifier
    class_signature = "PluginBase"

    def __init__(self):

        self.data_path = CONF.getDataPath()
        self.persistence_path = CONF.getPersistencePath()
        # Must be unique. Check that there is not
        # an existant plugin with the same id.
        # TODO: Make script that list current ids.
        self.id                = None
        self._rid              = id(self)
        self.version           = None
        self.name = None
        self.description = ""
        self._command_regex    = None
        self._output_file_path = None
        self.framework_version = None
        self._completition = {}
        self._new_elems = []
        self._pending_actions = Queue.Queue()
        self._settings = {}

    def has_custom_output(self):
        return bool(self._output_file_path)

    def get_custom_file_path(self):
        return self._output_file_path

    def getSettings(self):
        for param, (param_type, value) in self._settings.iteritems():
            yield param, value

    def getSetting(self, name):
        setting_type, value = self._settings[name]
        return value

    def addSetting(self, param, param_type, value):
        self._settings[param] = param_type, value

    def updateSettings(self, new_settings):
        for name, value in new_settings.iteritems():
            setting_type, curr_value = self._settings[name]
            self._settings[name] = setting_type, setting_type(value)

    def canParseCommandString(self, current_input):
        """
        This method can be overriden in the plugin implementation
        if a different kind of check is needed
        """
        return self._command_regex is not None and\
        self._command_regex.match(current_input.strip()) is not None
        
        
    def getCompletitionSuggestionsList(self, current_input):
        """
        This method can be overriden in the plugin implementation
        if a different kind of check is needed
        """
        
        words=current_input.split(" ")
        
        cword=words[len(words)-1] 
        
        
        
        options={}
        for k,v in self._completition.iteritems():
            if re.search(str("^"+cword),k,flags=re.IGNORECASE):
                
                options[k]=v
                
        return options

    def parseOutputString(self, output):
        """
        This method must be implemented.
        This method will be called when the command finished executing and
        the complete output will be received to work with it
        Using the output the plugin can create and add hosts, interfaces, services, etc.
        """
        pass

    def processCommandString(self, username, current_path, command_string):
        """
        With this method a plugin can add aditional arguments to the command that
        it's going to be executed.
        """
        return None 

    def getParsedElementsDict(self):
        """
        This method must be implemented and must return
        a dictionary with the following form.

        { 'FrameworkVersion': self.framework_version,
          'HostList': list_of_host_dictionaries,
          'PortList': list_of_port_dictionaries }

        list_of_host_dictionaries: must be 'None' or a list of
            dictionaries that have the following form

            { 'HostId': string,
              'HostAddress': string,
              ... }

        list_of_port_dictionaries: must be 'None' or a list of
            dictionaries that have the following form

            { 'PortNumber': integer,
              'Status': 'OPEN' or 'CLOSED',
              'Service': string,
              ... }
        """
        pass

    def _set_host(self):
        
        pass
        
    def __addPendingAction(self, *args):
        """
        Adds a new pending action to the queue
        Action is build with generic args tuple.
        The caller of this function has to build the action in the right
        way since no checks are preformed over args
        """
        self._pending_actions.put(args)

    
    def createAndAddHost(self, name, os = "unknown", category = None, update = False, old_hostname = None):
        host = model.api.newHost(name, os)
        self.__addPendingAction(modelactions.CADDHOST, name, os, category, update, old_hostname)
        return host.getID()

    def createAndAddInterface(self, host_id, name = "", mac = "00:00:00:00:00:00",
                 ipv4_address = "0.0.0.0", ipv4_mask = "0.0.0.0",
                 ipv4_gateway = "0.0.0.0", ipv4_dns = [],
                 ipv6_address = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_prefix = "00",
                 ipv6_gateway = "0000:0000:0000:0000:0000:0000:0000:0000", ipv6_dns = [],
                 network_segment = "", hostname_resolution = []):
        interface = model.api.newInterface(name, mac, ipv4_address, ipv4_mask, ipv4_gateway,
            ipv4_dns, ipv6_address, ipv6_prefix, ipv6_gateway, ipv6_dns,
            network_segment, hostname_resolution)
        self.__addPendingAction(modelactions.CADDINTERFACE, host_id, name, mac, ipv4_address, 
            ipv4_mask, ipv4_gateway, ipv4_dns, ipv6_address, ipv6_prefix, ipv6_gateway, ipv6_dns,
            network_segment, hostname_resolution)
        return interface.getID()

    def createAndAddApplication(self, host_id, name, status = "running", version = "unknown"):
        application = model.api.newApplication(name, status, version)
        self.__addPendingAction(modelactions.CADDAPPLICATION, host_id, name, status, version)
        return application.getID()

    def createAndAddServiceToApplication(self, host_id, application_id, name, protocol = "tcp?", 
                ports = [], status = "running", version = "unknown", description = ""):
        service = model.api.newService(name, protocol, ports, status, version, description)
        self.__addPendingAction(modelactions.CADDSERVICEAPP, host_id, application_id, name, protocol, 
                ports, status, version, description)
        return service.getID()

    def createAndAddServiceToInterface(self, host_id, interface_id, name, protocol = "tcp?", 
                ports = [], status = "running", version = "unknown", description = ""):
        service = model.api.newService(name, protocol, ports, status, version, description)
        self.__addPendingAction(modelactions.CADDSERVICEINT, host_id, interface_id, name, protocol, 
                ports, status, version, description)
        return service.getID()

    def createAndAddVulnToHost(self, host_id, name, desc="", ref=[], severity=""):
        vuln = model.api.newVuln(name, desc, ref, severity)
        self.__addPendingAction(modelactions.CADDVULNHOST, host_id, name, desc, ref, severity)
        return vuln.getID()

    def createAndAddVulnToInterface(self, host_id, interface_id, name, desc="", ref=[], severity=""):
        vuln = model.api.newVuln(name, desc, ref, severity)
        self.__addPendingAction(modelactions.CADDVULNINT, host_id, interface_id, name, desc, ref, severity)
        return vuln.getID()

    def createAndAddVulnToApplication(self, host_id, application_id, name, desc="", ref=[], severity=""):
        vuln = model.api.newVuln(name, desc, ref, severity)
        self.__addPendingAction(modelactions.CADDVULNAPP, host_id, application_id, name, desc, ref, severity)
        return vuln.getID()

    def createAndAddVulnToService(self, host_id, service_id, name, desc="", ref=[], severity=""):
        vuln = model.api.newVuln(name, desc, ref, severity)
        self.__addPendingAction(modelactions.CADDVULNSRV, host_id, service_id, name, desc, ref, severity)
        return vuln.getID()

    def createAndAddVulnWebToService(self, host_id, service_id, name, desc="", ref=[], severity="", website="", path="", request="",
                                  response="",method="",pname="", params="",query="",category=""):
        vuln = model.api.newVulnWeb(name, desc, ref, severity,website, path, request, response,
                method,pname, params,query,category)
        self.__addPendingAction(modelactions.CADDVULNWEBSRV, host_id, service_id, name, desc, ref, severity, website, path, request, response,
                method,pname, params,query,category)
        return vuln.getID()
    

    def createAndAddNoteToHost(self, host_id, name, text):
        note = model.api.newNote(name, text)
        self.__addPendingAction(modelactions.CADDNOTEHOST, host_id, name, text)
        return note.getID()

    def createAndAddNoteToInterface(self, host_id, interface_id, name, text):
        note = model.api.newNote(name, text)
        self.__addPendingAction(modelactions.CADDNOTEINT, host_id, interface_id, name, text)
        return note.getID()

    def createAndAddNoteToApplication(self, host_id, application_id, name, text):
        note = model.api.newNote(name, text)
        self.__addPendingAction(modelactions.CADDNOTEAPP, host_id, application_id, name, text)
        return note.getID()

    def createAndAddNoteToService(self, host_id, service_id, name, text):
        note = model.api.newNote(name, text) 
        self.__addPendingAction(modelactions.CADDNOTESRV, host_id, service_id, name, text)
        return note.getID()
    
    def createAndAddNoteToNote(self, host_id, service_id, note_id, name, text):
        note = model.api.newNote(name, text)
        self.__addPendingAction(modelactions.CADDNOTENOTE, host_id, service_id, note_id, name, text)
        return note.getID()
    
    def createAndAddCredToService(self, host_id, service_id, username, password):
        cred = model.api.newCred(username, password)
        self.__addPendingAction(modelactions.CADDCREDSRV, host_id, service_id, username, password)
        return cred.getID()

    def addHost(self, host, category=None,update=False, old_hostname=None):
        self.__addPendingAction(modelactions.ADDHOST, host, category, update, old_hostname)

    def addInterface(self, host_id, interface):
        self.__addPendingAction(modelactions.ADDINTERFACE, host_id, interface)

    def addApplication(self, host_id, application):
        self.__addPendingAction(modelactions.ADDAPPLICATION, host_id, application)

    def addServiceToApplication(self, host_id, application_id, service):
        self.__addPendingAction(modelactions.ADDSERVICEAPP, host_id, application_id, service)

    def addServiceToInterface(self, host_id, interface_id, service):
        self.__addPendingAction(modelactions.ADDSERVICEINT, host_id, interface_id, service)

    def addVulnToHost(self, host_id, vuln):
        self.__addPendingAction(modelactions.ADDVULNHOST, host_id, vuln)

    def addVulnToInterface(self, host_id, interface_id, vuln):
        self.__addPendingAction(modelactions.ADDVULNINT, host_id, interface_id, vuln)

    def addVulnToApplication(self, host_id, application_id, vuln):
        self.__addPendingAction(modelactions.ADDVULNAPP, host_id, application_id, vuln)

    def addVulnToService(self, host_id, service_id, vuln):
        self.__addPendingAction(modelactions.ADDVULNSRV, host_id, service_id, vuln)

    def addVulnWebToService(self, host_id, service_id, vuln):
        self.__addPendingAction(modelactions.ADDVULNWEBSRV, host_id, service_id, vuln)
        
    def addNoteToHost(self, host_id, note):
        self.__addPendingAction(modelactions.ADDNOTEHOST, host_id, note)

    def addNoteToInterface(self, host_id, interface_id, note):
        self.__addPendingAction(modelactions.ADDNOTEINT, host_id, interface_id, note)

    def addNoteToApplication(self, host_id, application_id, note):
        self.__addPendingAction(modelactions.ADDNOTEAPP, host_id, application_id, note)

    def addNoteToService(self, host_id, service_id, note):
        self.__addPendingAction(modelactions.ADDNOTESRV, host_id, service_id, note)

    def addNoteToNote(self, host_id, service_id,note_id, note):
        self.__addPendingAction(modelactions.ADDNOTENOTE, host_id, service_id, note_id, note)
        
    def addCredToService(self, host_id, service_id, cred):
        self.__addPendingAction(modelactions.ADDCREDSRV, host_id, service_id, cred)

    def delServiceFromInterface(self, service, hostname,
                 intname, remote = True):
        self.__addPendingAction(modelactions.DELSERVICEINT,hostname,intname,service,remote)
        
    def log(self, msg, level='INFO'):
        self.__addPendingAction(modelactions.LOG,msg,level)

    def devlog(self, msg):        
        self.__addPendingAction(modelactions.DEVLOG,msg)


class PluginProcess(multiprocessing.Process):
    def __init__(self, plugin_instance, output_queue, new_elem_queue):
        multiprocessing.Process.__init__(self)
        self.output_queue = output_queue
        self.new_elem_queue = new_elem_queue
        self.plugin = plugin_instance
        

    def run(self):
        proc_name = self.name
        model.api.devlog("-" * 40)
        model.api.devlog("proc_name = %s" % proc_name)
        model.api.devlog("Starting run method on PluginProcess")
        model.api.devlog('parent process: %s' % os.getppid())
        model.api.devlog('process id: %s' % os.getpid())
        model.api.devlog("-" * 40)
        done = False
        while not done:
            output = self.output_queue.get()
            if output is not None:
                model.api.devlog('%s: %s' % (proc_name, "New Output"))
                try:
                    self.plugin.parseOutputString(output)
                except Exception as e:
                    
                    model.api.devlog("Plugin raised an exception:")
                    model.api.devlog(traceback.format_exc())
                else:
                    while True:
                        try:
                            self.new_elem_queue.put(self.plugin._pending_actions.get(block=False))
                        except Queue.Empty:
                            model.api.devlog("PluginProcess run _pending_actions queue Empty. Breaking loop")
                            break
                        except Exception:
                            model.api.devlog("PluginProcess run getting from _pending_action queue - something strange happened... unhandled exception?")
                            model.api.devlog(traceback.format_exc())
                            break

            else:
                
                done = True
                model.api.devlog('%s: Exiting' % proc_name)
                
            self.output_queue.task_done()
        self.new_elem_queue.put(None)
        return


########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os, socket
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class AcunetixXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the acunetix tool.

    TODO: Handle errors.
    TODO: Test acunetix output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param acunetix_xml_filepath A proper xml generated by acunetix
    """
    def __init__(self, xml_output):
        #self.filepath = acunetix_xml_filepath

        tree = self.parse_xml(xml_output)
        
        if tree:
            self.sites = [data for data in self.get_items(tree)]
        else:
            self.sites = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
            
        for node in tree.findall('Scan'):
            yield Site(node)


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 

class Site(object):
    def __init__(self, item_node):
        self.node = item_node
        
        self.url = self.get_text_from_subnode('StartURL')
        mregex = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", self.url)
                              
        self.protocol = mregex.group(1)
        self.host = mregex.group(4)
        self.port=80
        if self.protocol == 'https':
            self.port=443        
        if mregex.group(11) is not None:
            self.port = mregex.group(11)
        
        
        self.ip = self.resolve(self.host)
        self.os = self.get_text_from_subnode('Os')
        self.banner = self.get_text_from_subnode('Banner')
        self.items = []
        for alert in self.node.findall('ReportItems/ReportItem'):
            self.items.append(Item(alert))

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an acunetix xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.name = self.get_text_from_subnode('Name')
        self.severity = self.get_text_from_subnode('Severity')
        self.request = self.get_text_from_subnode('TechnicalDetails/Request')
        self.response = self.get_text_from_subnode('TechnicalDetails/Response')
        self.parameter = self.get_text_from_subnode('Parameter')
        self.uri = self.get_text_from_subnode('Affects')
        self.desc = self.get_text_from_subnode('Description')
        self.desc += "\nSolution: " + self.get_text_from_subnode('Recommendation') if self.get_text_from_subnode('Recommendation')  else ""
        self.desc += "\nDetails: " + self.get_text_from_subnode('Details') if self.get_text_from_subnode('reference') else ""
        
        self.ref=[]
        for n in item_node.findall('References/Reference'):
            n2 = n.find('URL')
            self.ref.append(n2.text)
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class AcunetixPlugin(core.PluginBase):
    """
    Example plugin to parse acunetix output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Acunetix"
        self.name            = "Acunetix XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "9"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(acunetix|sudo acunetix|\.\/acunetix).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "acunetix_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = AcunetixXmlParser(output)

        for site in parser.sites:
            host = []
            if site.host != site.ip:
                host = [site.host]
            h_id = self.createAndAddHost(site.ip,site.os)
            i_id = self.createAndAddInterface(h_id, site.ip, ipv4_address=site.ip, hostname_resolution=host)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, "http", "tcp",
                                                       ports = [site.port],
                                                       version= site.banner,
                                                       status = 'open')
            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,site.host,"")

            for item in site.items:
                v_id = self.createAndAddVulnWebToService(h_id, s_id, item.name,
                                                         item.desc, website=site.host, severity=item.severity,
                                                         path=item.uri,params=item.parameter,
                                                         request=item.request,response=item.response,ref=item.ref)

        del parser
        
                      
                                             
                    


                                                                               
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return AcunetixPlugin()

if __name__ == '__main__':
    parser = AcunetixXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import argparse
import shlex
import socket
import random
current_path = os.path.abspath(os.getcwd())


                                                                        
                           
                                                                     
                      

class AmapPlugin(core.PluginBase):
    """
    Example plugin to parse amap output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Amap"
        self.name            = "Amap Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "5.4"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(amap|sudo amap).*?')
        self._hosts          = []
        self._completition = {
                                "":"amap [-A|-B|-P|-W] [-1buSRHUdqv] [[-m] -o &lt;file&gt;] [-D &lt;file&gt;] [-t/-T sec] [-c cons] [-C retries] [-p proto] [-i &lt;file&gt;] [target port [port] ...]",
                                "-A":"Map applications: send triggers and analyse responses (default)",
                                "-B":"Just grab banners, do not send triggers",
                                "-P":"No banner or application stuff - be a (full connect) port scanner",
                                "-1":"Only send triggers to a port until 1st identification. Speeeeed!",
                                "-6":"Use IPv6 instead of IPv4",
                                "-b":"Print ascii banner of responses",
                                "-i":"Nmap machine readable outputfile to read ports from",
                                "-u":"Ports specified on commandline are UDP (default is TCP)",
                                "-R":"Do NOT identify RPC / SSL services",
                                "-S":"Do NOT identify RPC / SSL services",
                                "-H":"Do NOT send application triggers marked as potentially harmful",
                                "-U":"Do NOT dump unrecognised responses (better for scripting)",
                                "-d":"Dump all responses",
                                "-v":"Verbose mode, use twice (or more!) for debug (not recommended :-)",
                                "-q":"Do not report closed ports, and do not print them as unidentified",
                                "-o":"FILE [-m] Write output to file FILE, -m creates machine readable output",
                                "-c":"CONS    Amount of parallel connections to make (default 32, max 256)",
                                "-C":"RETRIES Number of reconnects on connect timeouts (see -T) (default 3)",
                                "-T":"SEC     Connect timeout on connection attempts in seconds (default 5)",
                                "-t":"SEC     Response wait timeout in seconds (default 5)",
                                "-p":"PROTO   Only send triggers for this protocol (e.g. ftp)",
        }

        global current_path
        self._file_output_path=os.path.join(self.data_path,"amap_output-%s.txt" % random.uniform(1,10))


    def parseOutputString(self, output, debug = False):
                          
                                                                                             
        if not os.path.exists(self._file_output_path):
            return False

        if not debug:
            with open(self._file_output_path) as f:
                output = f.read()
        
        services = {}
        for line in output.split('\n'):
            if line.startswith('#'):
                         
                continue 
            
                                                                                                 
            fields = self.get_info(line)
                                                                                                 
            
            if len(fields) < 6:
                                                   
                continue

            address          = fields[0]
            h_id = self.createAndAddHost(address)

            port             = fields[1] 
            protocol         = fields[2]
            port_status      = fields[3]
                                         
            identification   = fields[5]
            printable_banner = fields[6]
                                         
            if port in services.keys():
                                      
                if identification != 'unidentified':
                                          
                    services[port][5] += ', ' + identification
            else:
                services[port] = [address, port, protocol, port_status, None, identification, printable_banner, None]
            
            
            args={}
            if self.args.__getattribute__("6"):
                self.ip = self.get_ip_6(self.args.m)
                args['ipv6_address']=address
            else:
                self.ip=self.getAddress(self.args.m)
                args['ipv4_address']=address
            
            if address != self.args.m:
                args['hostname_resolution']=self.args.m
            
            i_id = self.createAndAddInterface(h_id, name=address, **args)    

        for key in services:
            service = services.get(key)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, service[5], service[2], ports = [service[1]], status = service[3],description = service[6])
        
        if not debug:
            os.remove(self._file_output_path)
        return True

    file_arg_re = re.compile(r"^.*(-o \s*[^\s]+\s+(?:-m|)).*$")

    def get_info(self,data):
        if self.args.__getattribute__("6"):
            f = re.search(r"^\[(.*)\]:(.*):(.*):(.*):(.*):(.*):(.*):(.*)",data)
            return [f.group(1),f.group(2),f.group(3),
                    f.group(4),f.group(5),f.group(6),f.group(7),f.group(8)] if f else []
        
        else:
            return data.split(':')
        
        
    def get_ip_6(self,host, port=0):
                                                              
         alladdr = socket.getaddrinfo(host,port)
         ip6 = filter(
             lambda x: x[0] == socket.AF_INET6,                
             alladdr
         )
                                        
                                       
         return list(ip6)[0][4][0]
                                
                    
    
    def getAddress(self, hostname):
        """
        Returns remote IP address from hostname.
        """
        try:
            return socket.gethostbyname(hostname)
        except socket.error, msg:
                                                        
            return hostname

    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -m parameter to get machine readable output.
        """
        arg_match = self.file_arg_re.match(command_string)
        
        parser = argparse.ArgumentParser()
        
        parser.add_argument('-6',action='store_true')
        parser.add_argument('-o')
        parser.add_argument('-m')
        
        
               
        self._file_output_path=os.path.join(self.data_path,"amap_output-%s.txt" % random.uniform(1,10))        
        
        if arg_match is None:               
            final= re.sub(r"(^.*?amap)",
                          r"\1 -o %s -m " % self._file_output_path,
                          command_string) 
        else:
            final= re.sub(arg_match.group(1),
                          r"-o %s -m " % self._file_output_path,
                          command_string)
        
                                          
        cmd=shlex.split(re.sub(r'\-h|\-\-help', r'', final))
        if "-6" in cmd:
            cmd.remove("-6")
            cmd.insert(1,"-6")
        
                        
                     
        args=None
        if len(cmd) > 4:
            try:
                args, unknown = parser.parse_known_args(cmd)
            except SystemExit:
                pass
        
        self.args=args
        return final

    def setHost(self):
        pass

def createPlugin():
    return AmapPlugin()


########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information
'''

from __future__ import with_statement
from plugins import core
from model import api
import socket
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
except ImportError:
    import xml.etree.ElementTree as ET

"""Arachni plugin XML Parser.

Description.

"""

current_path = os.path.abspath(os.getcwd())

__author__     = "Matas Ariel R Medina"
__copyright__  = "Copyright 2011, Faraday Project"
__credits__    = ["Matas Ariel R Medina"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Matas Ariel R Medina"
__email__      = "mre@infobytesec.com"
__status__     = "Development"

class ArachniXmlParser(object):
    """Plugin that parses Arachni's XML report files.
    
    :param arachni_xml_filepath: Xml report generated by Arachni.
    
    :class:`.ArachniXmlParser`
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        
        if tree:
            self.issues = self.getIssues(tree)
            self.system = self.getSystem(tree)
        else:
            self.issues = []
            self.system = []

    def parse_xml(self, xml_output):
        """Opens and parses an arachni xml report file.
        
        :param filepath:

        :rtype xml_tree: An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def getIssues(self, tree):
        """
        :param tree:
        """
        for issues in tree.findall('issues'):
            for self.issue_node in issues.findall('issue'):
                yield Issue(self.issue_node)

    def getSystem(self, tree):
        """
        :param tree:
        """
        for self.system_node in tree.findall('system'):
            yield System(self.system_node)
    
    def getPlugins(self, tree):
        """
        :param tree:
        """
        for self.plugin_node in tree.findall('plugins'):
            yield Plugins(self.plugin_node)
        


               
      
               

class Issue(object):
    def __init__(self, issue_node):
        """
        :param issue_node:
        """
        self.node = issue_node
        self.name = self.getDesc(issue_node, 'name')
        self.var = self.getDesc(issue_node, 'var')
        self.severity = self.getDesc(issue_node, 'severity')
        self.url = self.getDesc(issue_node, 'url').lower()
        self.element = self.getDesc(issue_node, 'element')
        self.cwe = self.getDesc(issue_node, 'cwe')
        self.method = self.getDesc(issue_node, 'method')
        self.tags = self.getTags(issue_node, 'tags', 'tag')
        self.variable = self.getDesc(issue_node, 'variable')
        self.remedy_guidance = self.getDesc(issue_node, 'remedy_guidance')
        self.description = self.getDesc(issue_node, 'description')
        self.manual_verification = self.getDesc(issue_node, 'manual_verification')
        self.references = self.getReferences(issue_node)
        self.variations = self.getVariations(issue_node)

    def getDesc(self, issue_node, tag):
        """
        :param issue_node:
        :param tag:
        :rtype text: Returns current issue description
        """
        desc = issue_node.findall(tag)
        if desc:
            return desc[0].text
        else:
            return 'None'

    def getTags(self, issue_node, main_tag, child_tag):
        """
        :param issue_node:
        :param main_tag:
        :param child_tag:
        :rtype string: Returns current issue tag description
        """
        for tags in issue_node.findall(main_tag):
            for tag in tags.findall(child_tag):
                tagDesc = tag.attrib['name']
                if tagDesc:
                    return tagDesc
                else:
                    return 'None'

    def getReferences(self, issue_node):
        """Returns current issue references on this format {'url': 'http://www.site.com', 'name': 'WebSite'}.
        
        :param issue_node: Issue instance.
        :param main_tag: Container's tag.
        :param child_tag: Child's tag.

        :rtype dict: Reference
        """
        for tags in issue_node.findall('references'):
            for tag in tags.findall('reference'):
                reference = tag.attrib
                if reference:
                    return reference
                else:
                    return "None"

    def getVariations(self, issue_node):
        """Returns variations in dict format.

        :param issue_node: Issue instance.

        :rtype dict: Variations, keys : {'url', 'headers' , 'html'}

        """
        requests = []
        responses = []
        html = []
        url = []
        headers = [requests, responses]
        for variations in issue_node.findall('variations'):
            for variation in variations.findall('variation'):
                for urltmp in variation.findall('url'):
                    url.append(urltmp.text.lower())
                for heads in variation.findall('headers'):
                    for request in heads.findall('request'):
                        for field in request.findall('field'):
                            requests.append(field.attrib)
                    for response in heads.findall('response'):
                        for field in response.findall('field'):
                            responses.append(field.attrib)
                for htmltmp in variation.findall('html'):
                     html.append(htmltmp.text)
                     
        finalVariation = {'url' : url, 'headers' : headers, 'html' : html}
        return
    
    
               
       
               

class System(object):
    def __init__(self, system_node):
        self.system_node = system_node
        self.version = self.getDesc('version')
        self.revision = self.getDesc('revision')
        self.star_ttime = self.getDesc( 'start_datetime')
        self.finish_time = self.getDesc('finish_datetime')
        self.delta_time = self.getDesc('delta_time')
        self.url = self.getDesc('url')
        self.user_agent = self.getDesc('user_agent')
        self.audited_elements = self.getChildDesc('audited_elements', 'element')
        self.modules = self.getChildDesc('modules', 'module')
        self.filters = self.getFilters()
        self.cookies = self.getChildDesc('cookies', 'cookie')

    def getDesc(self, tag):
        """
        :param tag:
        :rtype text: Returns current issue description
        """
        desc = self.system_node.findall(tag)
        if desc:
            return desc[0].text
        else:
            return 'None'
            
    def getChildDesc(self, father_tag, child_tag):
        """Returns modules in dict format.

        :param father_tag: Container's tag.
        :param child_tag: Child's tag.
        :rtype child: (string/dict)

        """
        for tags in self.system_node.findall(father_tag):
            for child in tags.findall(child_tag):
                if child.tag == 'cookie':
                    return child.attrib
                elif child.tag == 'element':
                    return child.text
                else:
                    return child.attrib['name']
                    
    def getFilters(self):
        """Returns filters in list format.

        :rtype filters:
            filters[i], i:
                    0 for exclude,
                    1 for include,
                    2 for redundant.

        """
        exclude = []
        include = []
        redundant = []
        for tags in self.system_node.findall('filters'):
            for child in tags:
                if child.tag == 'exclude':
                    for regexp in child:
                        exclude.append(regexp.text)
                elif child.tag == 'include':
                    for regexp in child:
                        include.append(regexp.text)
                else:
                    for regexp in child:
                        redundant.append(regexp.text)
        filters = [('exclude', exclude), ('include', include), ('redundant', redundant)]
        return filters


               
        
               

class Plugins():
    def __init__(self, plugin_node):
        self.plugin_node = plugin_node
        self.healthmap = self.getHealthmap(self.plugin_node)
        self.content_types = self.getContentTypes(self.plugin_node)
    pass
    
class ArachniPlugin(core.PluginBase):
    """
    Plugin that parses Arachni's XML report files.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Arachni"
        self.name            = "Arachni XML Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "0.4.5.2"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.macaddress = None
        self.hostname = None
        self.address = None
        self.port = "80"

                                          
        self._command_regex  = re.compile(r'^(sudo arachni |arachni |\.\/arachni |ruby \.\/arachni |ruby arachni ).*?')
                                                   
        self._report_regex = re.compile(r"^.*(--report=xml\s*[^\s]+).*$")
        
        global current_path
        self._output_file_path = os.path.join(self.data_path, "arachni_report-%s.xml" % self._rid)
                                                                                                 
        self._completition = {
            "":"arachni [options] url",
            "-h":"Help",
            "--help":"Help",
            "-v":"Be verbose.",
            "--version":"Show version information and exit.",
            "--debug":"Show what is happening internally. (You should give it a shot sometime ;) )",
            "--only-positives":"Echo positive results *only*.",
            "--http-username":"&lt;string&gt;    Username for HTTP authentication.",
            "--http-password":"&lt;string&gt;    Password for HTTP authentication.",            
            "--http-req-limit":"--http-req-limit=&lt;integer&gt;  Concurrent HTTP requests limit. (Default: 20) (Be careful not to kill your server.) (*NOTE*: If your scan seems unresponsive try lowering the limit.)",
            "--http-timeout":"--http-timeout=&lt;integer&gt;    HTTP request timeout in milliseconds.",
            "--cookie-jar":"--cookie-jar=&lt;filepath&gt;     Netscape HTTP cookie file, use curl to create it.",
            "--cookie-string":"--cookie-string='&lt;name&gt;=&lt;value&gt;; &lt;name2&gt;=&lt;value2&gt;' Cookies, as a string, to be sent to the web application.",
            "--user-agent":"--user-agent=&lt;string&gt;       Specify user agent.",
            "--custom-header":"--custom-header='&lt;name&gt;=&lt;value&gt;' Specify custom headers to be included in the HTTP requests. (Can be used multiple times.)",
            "--authed-by":"--authed-by=&lt;string&gt;        Who authorized the scan, include name and e-mail address. (It'll make it easier on the sys-admins during log reviews.) (Will be appended to the user-agent string.)",
            "--login-check-url":"--login-check-url=&lt;url&gt;     A URL used to verify that the scanner is still logged in to the web application. (Requires 'login-check-pattern'.)",
            "--login-check-pattern":"--login-check-pattern=&lt;regexp&gt; A pattern used against the body of the 'login-check-url' to verify that the scanner is still logged in to the web application. (Requires 'login-check-url'.)",
            "--save-profile":"--save-profile=&lt;filepath&gt;   Save the current run profile/options to &lt;filepath&gt;.",
            "--load-profile":"--load-profile=&lt;filepath&gt;   Load a run profile from &lt;filepath&gt;. (Can be used multiple times.) (You can complement it with more options, except for:\n* --modules\n* --redundant)",
            "--show-profile":"Will output the running profile as CLI arguments.",
            "-e":"-e &lt;regexp&gt; Exclude urls matching &lt;regexp&gt;. (Can be used multiple times.)",
            "--exclude":"    --exclude=&lt;regexp&gt          Exclude urls matching &lt;regexp&gt;.",
            "--exclude-page":"    --exclude-page=&lt;regexp&gt     Exclude pages whose content matches &lt;regexp&gt;.",
            "-i":"-i &lt;regexp&gt; Include *only* urls matching &lt;regex&gt;. (Can be used multiple times.)",
            "--include":"&lt;regexp&gt;          Include *only* urls matching &lt;regex&gt;.",
            "--redundant":"--redundant=&lt;regexp&gt;:&lt;limit&gt; Limit crawl on redundant pages like galleries or catalogs. (URLs matching &lt;regexp&gt; will be crawled &lt;limit&gt; amount of times.) (Can be used multiple times.)",
            "--auto-redundant":"--auto-redundant=&lt;limit&gt;    Only follow &lt;limit&gt; amount of URLs with identical query parameter names. (Default: inf) (Will default to 10 if no value has been specified.)",
            "-f":"Follow links to subdomains. (Default: off)",
            "--depth":"--depth=&lt;integer&gt; Directory depth limit. (Default: inf) (How deep Arachni should go into the site structure.)",
            "--follow-subdomains":"Follow links to subdomains.",
            "--link-count":"--link-count=&lt;integer&gt;      How many links to follow. (Default: inf)",
            "--redirect-limit":"--redirect-limit=&lt;integer&gt;  How many redirects to follow. (Default: 20)",
            "--extend-paths":"--extend-paths=&lt;filepath&gt;   Add the paths in &lt;file&gt; to the ones discovered by the crawler. (Can be used multiple times.)",
            "--restrict-paths":"--restrict-paths=&lt;filepath&gt; Use the paths in &lt;file&gt; instead of crawling. (Can be used multiple times.)",
            "--https-only":"Forces the system to only follow HTTPS URLs.",
            "-g":"Audit links.",
            "-p":"Audit forms.",
            "-c":"Audit cookies.",
            "--audit-cookies":"Audit cookies.",
            "--exclude-cookie":"--exclude-cookie=&lt;name&gt; Cookie to exclude from the audit by name. (Can be used multiple times.)",
            "--exclude-vector":"--exclude-vector=&lt;name&gt; Input vector (parameter) not to audit by name. (Can be used multiple times.)",
            "--audit-headers":"Audit HTTP headers. (*NOTE*: Header audits use brute force. Almost all valid HTTP request headers will be audited even if there's no indication that the web app uses them.) (*WARNING*: Enabling this option will result in increased requests, maybe by an order of magnitude.)",
            "--audit-cookies-extensively":"Submit all links and forms of the page along with the cookie permutations. (*WARNING*: This will severely increase the scan-time.)",
            "--fuzz-methods":"Audit links, forms and cookies using both GET and POST requests. (*WARNING*: This will severely increase the scan-time.)",
            "--exclude-binaries":"Exclude non text-based pages from the audit. (Binary content can confuse recon modules that perform pattern matching.)",
            "--lsmod":"--lsmod=&lt;regexp&gt; List available modules based on the provided regular expression. (If no regexp is provided all modules will be listed.) (Can be used multiple times.)",
            "-m":"-m &lt;modname,modname..&gt; Comma separated list of modules to load. (Modules are referenced by their filename without the '.rb' extension, use '--lsmod' to list all.\nUse '*' as a module name to deploy all modules or as a wildcard, like so:\nxss*   to load all xss modules\nsqli*  to load all sql injection modules etc.\nYou can exclude modules by prefixing their name with a minus sign:\n--modules=*,-backup_files,-xss\nThe above will load all modules except for the 'backup_files' and 'xss' modules.\nOr mix and match:\n-xss*   to unload all xss modules.)",
            "--lsrep":"--lsrep=&lt;regexp&gt; List available reports based on the provided regular expression. (If no regexp is provided all reports will be listed.) (Can be used multiple times.)",
            "--repload":"--repload=&lt;filepath&gt; Load audit results from an '.afr' report file. (Allows you to create new reports from finished scans.)",
            "--report":"--report='&lt;report&gt;:&lt;optname&gt;=&lt;val&gt;,&lt;optname2&gt;=&lt;val2&gt;,...'\n&lt;report&gt;: the name of the report as displayed by '--lsrep'\n(Reports are referenced by their filename without the '.rb' extension, use '--lsrep' to list all.)\n(Default: stdout) (Can be used multiple times.)",
            "--lsplug":"--lsplug=&lt;regexp&gt; List available plugins based on the provided regular expression.",
            "--plugin":"--plugin='&lt;plugin&gt;:&lt;optname&gt;=&lt;val&gt;,&lt;optname2&gt;=&lt;val2&gt;,...",
            '--lsplat':"List available platforms.",
            "--no-fingerprinting":"Disable platform fingerprinting.",
            "--proxy":"--proxy=&lt;server:port&gt; Proxy address to use.",
            "--proxy-auth":"--proxy-auth=&lt;user:passwd&gt;  Proxy authentication credentials.",
            "--proxy-type":"--proxy-type=&lt;type&gt; Proxy type; can be http, http_1_0, socks4, socks5, socks4a (Default: http)",
            }

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        parser = ArachniXmlParser(output)
        for system in parser.system:
            self.hostname = self.getHostname(system.url)
            self.address = self.getAddress(self.hostname)
            
            h_id = self.createAndAddHost(self.address)

                               
            i_id = self.createAndAddInterface(h_id, self.address, ipv4_address=self.address,hostname_resolution=self.hostname )
                        
            s_id = self.createAndAddServiceToInterface(h_id, i_id,
                                                self.protocol, 
                                                "tcp",
                                                ports=[self.port],
                                                status="open",
                                                version="",
                                                description="")

            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,self.hostname,"")

            
            for issue in parser.issues:
                print dir(issue)
                
                desc=issue.description
                desc+="\nSolution: " + issue.remedy_guidance if issue.remedy_guidance !="None" else ""
                ref=[issue.references] if issue.references else []
                if issue.cwe != "None":
                    ref.append('CWE-'+issue.cwe)
                v_id = self.createAndAddVulnWebToService(h_id, s_id,
                                         website=self.hostname,    
                                         name=issue.name,
                                         desc=desc,    
                                         ref=ref,    
                                         pname=issue.var,
                                         severity=issue.severity,
                                         method=issue.method,
                                         path=issue.url)    
        
                    
                                         
        
        return True
    
    def processCommandString(self, username, current_path, command_string):
        """
        Adds the "--report=xml:outfile=" parameter to set an xml output for
        the command string that the user has set.
        If the user has already set a xml report his report will be replaced with faraday's one.
        """
    
        arg_match = self._report_regex.match(command_string)

        if arg_match is None:
            return re.sub(r"(^.*?arachni)", r"\1 --report=xml:outfile=%s" % self._output_file_path, command_string)
        else:
            return re.sub(arg_match.group(1),r"--report=xml:outfile=%s" % self._output_file_path, command_string)
            
    def getHostname(self, url):
        """
        Strips protocol and gets hostname from URL.
        """       
        reg = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", url)
        self.protocol = reg.group(1)
        self.hostname = reg.group(4)

        if self.protocol == 'https':
            self.port=443
        if reg.group(11) is not None:
            self.port = reg.group(11)
            
        return self.hostname

    
    def getAddress(self, hostname):
        """
        Returns remote IP address from hostname.
        """
        try:
            return socket.gethostbyname(hostname)
        except socket.error, msg:
                                                        
            return self.hostname


def createPlugin():
    return ArachniPlugin()

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from plugins import core
from model import api
import re
import os
import pprint


__author__     = "Federico Kirschbaum"
__copyright__  = "Copyright 2013, Faraday Project"
__credits__    = ["Federico Kirschbaum"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Federico Kirschbaum"
__email__      = "fedek@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class CmdArpScanPlugin(core.PluginBase):
    """
    This plugin handles arp-scan command.
    Basically inserts into the tree the ouput of this tool
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "arp-scan"
        self.name            = "arp-scan network scanner"
        self.plugin_version         = "0.0.1"
        self.version            ="1.8.1"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo arp-scan|\.\/arp-scan|arp-scan).*?')
        self._host_ip        = None
        self._port           = "23"

       

                                  

    def parseOutputString(self, output, debug = False):

        host_info = re.search(r"(\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b)", output)
        host_mac_addr = re.search(r"([\dA-F]{2}(?:[-:][\dA-F]{2}){5})", output)
        if host_info is None:
            api.devlog("No hosts detected")
        else:           
            for line in output.split('\n'):
                vals = line.split("\t")

                if len(vals[0].split(".")) == 4:
                    host = vals[0]
                    h_id = self.createAndAddHost(host)
                    i_id = self.createAndAddInterface(h_id, host, ipv4_address=host, mac=vals[1])
                    n_id = self.createAndAddNoteToHost(h_id,"NIC VENDOR:",vals[2])

        
            
        return True
     

    def processCommandString(self, username, current_path, command_string):
        """
        """
                                            
        
                                      
                                       

                    

def createPlugin():
    return CmdArpScanPlugin()

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys
import urllib2
import json


__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


                 

class BeefPlugin(core.PluginBase):
    """
    Example plugin to parse beef output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Beef"
        self.name            = "BeEF Online Service Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "0.4.4.9-alpha"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(beef|sudo beef|\.\/beef).*?')

        self.addSetting("Host", str, "http://127.0.0.1:3000/")
        self.addSetting("Authkey", str, "c818c7798ae1da38b45a6406c8dd0d6d4d007098")
        self.addSetting("Enable", str, "0")
        

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        try:
            f = urllib2.urlopen(self.getSetting("Host") + "/api/hooks?token=" + self.getSetting("Authkey"))
            data = json.loads(f.read())
        except:
            api.devlog ("[BeEF] - Connection with api")
            return
        
        if "hooked-browsers" in data:
            for t in ["online","offline"]:
                for h in data["hooked-browsers"][t]:
                    name=str(data["hooked-browsers"][t][h]['name'])
                    version=str(data["hooked-browsers"][t][h]['version'])
                    os=str(data["hooked-browsers"][t][h]['os'])
                    platform=str(data["hooked-browsers"][t][h]['platform'])
                    session=str(data["hooked-browsers"][t][h]['session'])
                    ip=str(data["hooked-browsers"][t][h]['ip'])
                    domain=str(data["hooked-browsers"][t][h]['domain'])
                    port=str(data["hooked-browsers"][t][h]['port'])
                    page_uri=str(data["hooked-browsers"][t][h]['page_uri'])
                    
                    desc="Client ip:" + ip +" has been injected with BeEF using the url:"+page_uri+"\n"
                    desc+="More information:"
                    desc+="\ntype:"+t
                    desc+="\nname:"+name
                    desc+="\nversion:"+version
                    desc+="\nos:"+os
                    desc+="\nplatform:"+platform
                    desc+="\nsession:"+session
                    desc+="\nip:"+ip
                    desc+="\ndomain:"+domain
                    desc+="\nport:"+port
                    desc+="\npage_uri:"+page_uri
                    
                    h_id = self.createAndAddHost(ip)
                    v_id = self.createAndAddVulnToHost(h_id,"BeEF injected "+t+" session:"+session,desc=desc,ref=["http://http://beefproject.com/"], severity=3)
    
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return BeefPlugin()

if __name__ == '__main__':
    parser = BeefXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class BurpXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the burp tool.

    TODO: Handle errors.
    TODO: Test burp output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param burp_xml_filepath A proper xml generated by burp
    """
    def __init__(self, xml_output):
        self.target = None
        self.port = "80"
        self.host = None
        
        tree = self.parse_xml(xml_output)
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
        bugtype=""
        
        for node in tree.findall('issue'):
            yield Item(node)


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an burp xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        name = item_node.findall('name')[0]
        host_node = item_node.findall('host')[0]
        path = item_node.findall('path')[0]
        location = item_node.findall('location')[0]
        severity = item_node.findall('severity')[0]
        requestresponse = item_node.findall('requestresponse')[0]
        request = item_node.findall('./requestresponse/request')[0]
        response = item_node.findall('./requestresponse/response')[0]
        detail = self.do_clean(item_node.findall('issueDetail'))
        remediation = self.do_clean(item_node.findall('remediationBackground'))
        
        self.url=host_node.text
        rhost = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", self.url)
        self.protocol = rhost.group(1)
        self.host = rhost.group(4)
        
        self.port=80
        if self.protocol == 'https':
            self.port=443
            
        if rhost.group(11) is not None:
            self.port = rhost.group(11)
       
        self.name = name.text
        self.location = location.text
        self.path = path.text

        self.ip = host_node.get('ip')
        self.url = self.node.get('url')
        self.severity = severity.text
        self.request = request.text
        self.response = response.text
        self.detail = detail
        self.remediation = remediation
    
    
    def do_clean(self,value):
        myreturn =""
        if value is not None:
            if len(value) > 0:
                myreturn = value[0].text
        return myreturn
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class BurpPlugin(core.PluginBase):
    """
    Example plugin to parse burp output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Burp"
        self.name            = "Burp XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "1.5.18 BurpPro"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(sudo burp|\.\/burp).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "burp_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        
        parser = BurpXmlParser(output)
        for item in parser.items:

            h_id = self.createAndAddHost(item.ip)
            i_id = self.createAndAddInterface(h_id, item.ip,ipv4_address=item.ip, hostname_resolution=item.host)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, item.protocol,
                                                "tcp",
                                                ports = [str(item.port)],
                                                status = "open")
            
                         
            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,item.host,"")
            
                               
            item.response=""
            desc=item.detail
            desc+="\nSolution: "+item.remediation if item.remediation else ""
            v_id = self.createAndAddVulnWebToService(h_id, s_id, item.name,
                                                     desc=desc,severity=item.severity,website=item.host,
                                                     path=item.path,request=item.request,response=item.response)

        del parser
        
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return BurpPlugin()

if __name__ == '__main__':
    parser = BurpXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class DnsenumXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the dnsenum tool.

    TODO: Handle errors.
    TODO: Test dnsenum output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param dnsenum_xml_filepath A proper xml generated by dnsenum
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
        bugtype=""
        
        node = tree.findall('testdata')[0]
        for hostnode in node.findall('host'):
            yield Item(hostnode)
            

                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item

    TODO: Consider evaluating the attributes lazily
    TODO: Write what's expected to be present in the nodes
    TODO: Refactor both Host and the Port clases?

    @param item_node A item_node taken from an dnsenum xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.hostname = self.get_text_from_subnode('hostname')
        self.ip = self.node.text
                                                               
    
    
    def do_clean(self,value):
        myreturn =""
        if value is not None:
            myreturn = re.sub("\n","",value)
        return myreturn
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class DnsenumPlugin(core.PluginBase):
    """
    Example plugin to parse dnsenum output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Dnsenum"
        self.name            = "Dnsenum XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "1.2.2"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo dnsenum|dnsenum|sudo dnsenum\.pl|dnsenum\.pl|perl dnsenum\.pl|\.\/dnsenum\.pl).*?')
        self._completition = {
                                "":"Usage: dnsenum.pl [Options] &lt;domain&gt;",
                                "--dnsserver":"&lt;server&gt;",
                                "--enum":"Shortcut option equivalent to --threads 5 -s 20 -w.",
                                "-h":"Print this help message.",
                                "--help":"Print this help message.",
                                "--noreverse":"Skip the reverse lookup operations.",
                                "--private":"Show and save private ips at the end of the file domain_ips.txt.",
                                "--subfile":"&lt;file&gt;	Write all valid subdomains to this file.",
                                "-t":"&lt;value&gt;	The tcp and udp timeout values in seconds (default: 10s).",
                                "--timeout":"&lt;value&gt;	The tcp and udp timeout values in seconds (default: 10s).",
                                "--threads":"&lt;value&gt;	The number of threads that will perform different queries.",
                                "-v":"Be verbose: show all the progress and all the error messages.",
                                "--verbose":"Be verbose: show all the progress and all the error messages.",
                                "-p":"&lt;value&gt;	The number of google search pages to process when scraping names, ",
                                "--pages":"&lt;value&gt;	The number of google search pages to process when scraping names the default is 20 pages, the -s switch must be specified.",
                                "-s":"  -s, --scrap &lt;value&gt;	The maximum number of subdomains that will be scraped from Google.",
                                "--scrap":"  -s, --scrap &lt;value&gt;	The maximum number of subdomains that will be scraped from Google.",
                                "-f":"&lt;file&gt;	Read subdomains from this file to perform brute force.",
                                "--file":"&lt;file&gt;	Read subdomains from this file to perform brute force.",
                                "-u":"&lt;a|g|r|z&gt; Update the file specified with the -f switch with valid subdomains.",
                                "--update":"&lt;a|g|r|z&gt; Update the file specified with the -f switch with valid subdomains.",
                                "-r":"Recursion on subdomains, brute force all discovred subdomains that have an NS record.",
                                "--recursion":"Recursion on subdomains, brute force all discovred subdomains that have an NS record.",
                                "-d":"The maximum value of seconds to wait between whois queries, the value is defined randomly, default: 3s.",
                                "--delay":"The maximum value of seconds to wait between whois queries, the value is defined randomly, default: 3s.",
                                "-w":"Perform the whois queries on c class network ranges.",
                                "--whois":"Perform the whois queries on c class network ranges.",
                                "-e":"&lt;regexp&gt;",
                                "--exclude":"&lt;regexp&gt;",
                                "-o":"&lt;file&gt;	Output in XML format. Can be imported in MagicTree (www.gremwell.com)",
                                "--output":"&lt;file&gt;	Output in XML format. Can be imported in MagicTree (www.gremwell.com)",            
        }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "dnsenum_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = DnsenumXmlParser(output)

        for item in parser.items:
            h_id = self.createAndAddHost(item.ip)
            i_id = self.createAndAddInterface(h_id, item.ip,ipv4_address=item.ip,hostname_resolution=item.hostname)

        del parser

    xml_arg_re = re.compile(r"^.*(-o\s*[^\s]+).*$")

    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -oX parameter to get xml output to the command string that the
        user has set.
        """

        arg_match = self.xml_arg_re.match(command_string)

        if arg_match is None:
            return re.sub(r"(^.*?dnsenum(\.pl)?)",r"\1 -o %s" % self._output_file_path,command_string)
        else:
            return re.sub(arg_match.group(1),
                          r"-o %s" % self._output_file_path,
                          command_string)
        
        

    def setHost(self):
        pass


def createPlugin():
    return DnsenumPlugin()

if __name__ == '__main__':
    parser = DnsenumXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
import re
import os
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class DnsmapParser(object):
    """
    The objective of this class is to parse an xml file generated by the dnsmap tool.

    TODO: Handle errors.
    TODO: Test dnsmap output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param dnsmap_filepath A proper simple report generated by dnsmap
    """
    def __init__(self, output):

        self.items = []
        lists = output.split("\n")

        for line in lists:
            mitem = line.split(',')
            if mitem.__len__() > 1:
                item = {'host': mitem[0], 'ip': mitem[1]}
                self.items.append(item)


class DnsmapPlugin(core.PluginBase):
    """
    Example plugin to parse dnsmap output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id = "Dnsmap"
        self.name = "Dnsmap XML Output Plugin"
        self.plugin_version = "0.0.1"
        self.version = "0.30"
        self._completition = {
            "":"dnsmap &lt;target-domain&gt; [options]",
            "-w":"-w &lt;wordlist-file&gt;",
            "-r":"-r &lt;regular-results-file&gt;",
            "-c":"-c &lt;csv-results-file&gt;",
            "-d":"-d &lt;delay-millisecs&gt;",
            "-i":"-i &lt;ips-to-ignore&gt; (useful if you're obtaining false positives)",
        }

        self.options = None
        self._current_output = None
        self.current_path = None
        self._command_regex = re.compile(r'^(sudo dnsmap|dnsmap|\.\/dnsmap).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path, "dnsmap_output-%s.txt" % self._rid)

    def canParseCommandString(self, current_input):
        if self._command_regex.match(current_input.strip()):
            return True
        else:
            return False

    def parseOutputString(self, output, debug=False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        if debug:
            parser = DnsmapParser(self._output_file_path)
        else:

            if not os.path.exists(self._output_file_path):
                return False

            parser = DnsmapParser(self._output_file_path)

            for item in parser.items:
                h_id = self.createAndAddHost(item['ip'])
                i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address=item['ip'],hostname_resolution=item['host'])


        del parser

        if not debug:
            os.remove(self._output_file_path)
        return True

    xml_arg_re = re.compile(r"^.*(-c\s*[^\s]+).*$")

    def processCommandString(self, username, current_path, command_string):
        """
        Adds the parameter to get output to the command string that the
        user has set.
        """

        arg_match = self.xml_arg_re.match(command_string)

        if arg_match is None:
            return "%s -c %s \n" % (command_string, self._output_file_path)
        else:
            return re.sub(arg_match.group(1),
                          r"-c %s" % self._output_file_path,
                          command_string)


def createPlugin():
    return DnsmapPlugin()

if __name__ == '__main__':
    parser = DnsmapParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class DnsreconXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the dnsrecon tool.

    TODO: Handle errors.
    TODO: Test dnsrecon output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param dnsrecon_xml_filepath A proper xml generated by dnsrecon
    """
    def __init__(self, xml_output):

        tree = self.parse_xml(xml_output)
        
        if tree:
            self.hosts = [host for host in self.get_hosts(tree)]
        else:
            self.hosts = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_hosts(self, tree):
        """
        @return items A list of Host instances
        """
        for item_node in tree.findall('record'):
            yield Item(item_node)
                


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item

    TODO: Consider evaluating the attributes lazily
    TODO: Write what's expected to be present in the nodes
    TODO: Refactor both Host and the Port clases?

    @param item_node A item_node taken from an dnsrecon xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.type = self.do_clean(self.node.get('type'))
        self.zonetransfer = self.do_clean(self.node.get('zone_transfer'))
        self.ns_server = self.do_clean(self.node.get('ns_server'))
        self.address = self.do_clean(self.node.get('address')) if not self.type=="info" else self.ns_server
        
        self.target = self.do_clean(self.node.get('target'))
        self.name = self.do_clean(self.node.get('name')) 
        self.exchange = self.do_clean(self.node.get('exchange'))
        
        print "GENERATION:" + self.type, self.address, self.zonetransfer
            
    def do_clean(self,value):
        myreturn =""
        if value is not None:
            myreturn = re.sub(" |\n","",value)
        return myreturn
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class DnsreconPlugin(core.PluginBase):
    """
    Example plugin to parse dnsrecon output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Dnsrecon"
        self.name            = "Dnsrecon XML Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "0.8.7"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo dnsrecon|dnsrecon|sudo dnsrecon\.py|dnsrecon\.py|python dnsrecon\.py|\.\/dnsrecon\.py).*?')
        self._completition = {
            "":"dnsrecon.py &lt;options&gt;",
            "-h":"Show this help message and exit",
            "-d":"-d &lt;domain&gt;  Domain to Target for enumeration.",
            "-r":"-r &lt;range&gt;   IP Range for reverse look-up brute force in formats (first-last) or in (range/bitmask).",
            "-n":"-n &lt;name&gt;    Domain server to use, if none is given the SOA of the target will be used",
            "-D":"-D  &lt;file&gt;    Dictionary file of sub-domain and hostnames to use for brute force.",
            "-f":"Filter out of Brute Force Domain lookup records that resolve to the wildcard defined IP Address when saving records.",
            "-t":"-t &lt;types&gt;   Specify the type of enumeration to perform:\nstd      To Enumerate general record types, enumerates.\nSOA, NS, A, AAAA, MX and SRV if AXRF on the NS Servers fail.\nrvl      To Reverse Look Up a given CIDR IP range.\nbrt      To Brute force Domains and Hosts using a given dictionary.\nsrv      To Enumerate common SRV Records for a given domain.\naxfr     Test all NS Servers in a domain for misconfigured zone transfers.\ngoo      Perform Google search for sub-domains and hosts.\nsnoop    To Perform a Cache Snooping against all NS servers for a given domain, testing all with file containing the domains, file given with -D option.\ntld      Will remove the TLD of given domain and test against all TLD's registered in IANA\nzonewalk Will perform a DNSSEC Zone Walk using NSEC Records.",
            "-a":"Perform AXFR with the standard enumeration.",
            "-s":"Perform Reverse Look-up of ipv4 ranges in the SPF Record of the targeted domain with the standard enumeration.",
            "-g":"Perform Google enumeration with the standard enumeration.",
            "-w":"Do deep whois record analysis and reverse look-up of IP ranges found thru whois when doing standard query.",
            "-z":"Performs a DNSSEC Zone Walk with the standard enumeration.",
            "--threads":"--threads &lt;number&gt; Number of threads to use in Range Reverse Look-up, Forward Look-up Brute force and SRV Record Enumeration",
            "--lifetime":"--lifetime &lt;number&gt; Time to wait for a server to response to a query.",
            "--db":"--db &lt;file&gt;   SQLite 3 file to save found records.",
            "--xml":"--xml &lt;file&gt;   XML File to save found records.",
            "--iw":"--iw Contibue bruteforcing a domain even if a wildcard record resolution is dicovered.",
            "-c":"-c &lt;file&gt;   Comma separated value file.",
            "-v":"Show attempts in the bruteforce modes.",
            }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "dnsrecon_output-%s.xml" % self._rid)

    def validHosts(self, hosts):
        valid_records = ["NS", "CNAME", "A", "MX", "info"]
        hosts = filter(lambda h: h.type in valid_records, hosts)
        return hosts

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = DnsreconXmlParser(output)

        for host in self.validHosts(parser.hosts):

            print host.type,host.name,host.zonetransfer
            hostname=host.target
            if host.type=="MX":
                hostname=host.exchange
            elif host.type=="A":
                hostname=host.name
                
            h_id = self.createAndAddHost(host.address)
                
            if self._isIPV4(str(host.address)):
                i_id = self.createAndAddInterface(h_id, name=host.address, ipv4_address=host.address,hostname_resolution=hostname)
            else:
                i_id = self.createAndAddInterface(h_id, name=host.address, ipv6_address=host.address,hostname_resolution=hostname)
            
            if host.type =="info":
                s_id = self.createAndAddServiceToInterface(h_id,i_id,"domain",protocol="tcp",ports=["53"],status="open")
                if host.zonetransfer=="success":
                    v_id = self.createAndAddVulnToService(h_id,s_id,name="Zone transfer",
                                                          desc="A Dns server allows unrestricted zone transfers",
                                                          ref=["CVE-1999-0532"])
            
        del parser

    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False


    xml_arg_re = re.compile(r"^.*(--xml\s*[^\s]+).*$")
        
    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -oX parameter to get xml output to the command string that the
        user has set.
        """
        arg_match = self.xml_arg_re.match(command_string)

        if arg_match is None:
            return re.sub(r"(^.*?dnsrecon(\.py)?)",
                          r"\1 --xml %s" % self._output_file_path,
                          command_string)
        else:
            return re.sub(arg_match.group(1),
                          r"--xml %s" % self._output_file_path,
                          command_string)

    def setHost(self):
        pass


def createPlugin():
    return DnsreconPlugin()

if __name__ == '__main__':
    parser = DnsreconXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys
import socket


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class DnswalkParser(object):
    """
    The objective of this class is to parse an xml file generated by the dnswalk tool.

    TODO: Handle errors.
    TODO: Test dnswalk output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param dnswalk_filepath A proper simple report generated by dnswalk
    """
    def __init__(self, output):
        
        lists = output.split("\n")
        self.items = []
        
        
        for line in lists:
            mregex = re.search("WARN: ([\w\.]+) ([\w]+) ([\w\.]+):",line)
            if mregex is not None:
                print "host %s, ip %s" % (mregex.group(1),mregex.group(3))
                item = {'host' : mregex.group(1), 'ip' : mregex.group(3), 'type' : mregex.group(2)}
                self.items.append(item)
            
                                                                               
            mregex = re.search("Getting zone transfer of ([\w\.]+) from ([\w\.]+)\.\.\.done\.",line)
            if mregex is not None:
                ip=self.getAddress(mregex.group(2))
                item = {'host' : mregex.group(1), 'ip' : ip, 'type' : 'info'}
                self.items.append(item)
            
    def getAddress(self, hostname):
        """
        Returns remote IP address from hostname.
        """
        try:
            return socket.gethostbyname(hostname)
        except socket.error, msg:
                                                        
            return hostname            
        
        


class DnswalkPlugin(core.PluginBase):
    """
    Example plugin to parse dnswalk output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Dnswalk"
        self.name            = "Dnswalk XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "2.0.2"
        
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo dnswalk|dnswalk|\.\/dnswalk).*?')
        self._completition = {
            "":"dnswalk domain",
            "-r":"Recursively descend subdomains of domain",
            "-i":"Suppress check for invalid characters in a domain name.",
            "-a":"turn on warning of duplicate A records.",
            "-d":"Debugging",
            "-m":"Check only if the domain has been modified.  (Useful only if dnswalk has been run previously.)",
            "-F":"Enable \"facist\" checking.  (See man page)",
            "-l":"Check lame delegations",
            }

        global current_path
        
                                  

    def canParseCommandString(self, current_input):
        if self._command_regex.match(current_input.strip()):
            return True
        else:
            return False


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        
            
        if debug:
            parser = DnswalkParser(output)
        else:
            
            parser = DnswalkParser(output)

        print parser.items.__len__()
        for item in parser.items:
            if item['type'] == "A":
                h_id = self.createAndAddHost(item['ip'])
                i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address=item['ip'],hostname_resolution=item['host'])
            elif item['type'] == "info":
                h_id = self.createAndAddHost(item['ip'])
                i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address=item['ip'],hostname_resolution=item['host'])
                s_id = self.createAndAddServiceToInterface(h_id, i_id, "domain", "tcp", ports=['53'])
                self.createAndAddVulnToService(h_id, s_id, "Zone transfer", desc="A Dns server allows unrestricted zone transfers",
                                                      ref=["CVE-1999-0532"])                

        del parser
        return True

    def processCommandString(self, username, current_path, command_string):
        """
        """
        return None

def createPlugin():
    return DnswalkPlugin()

if __name__ == '__main__':
    parser = DnswalkParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import shlex
import argparse
import sys
import random
from StringIO import StringIO
import traceback
#current_path = os.path.abspath(os.getcwd())


class FPlugin(core.PluginBase):
    """
    Example plugin to parse f output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "faraday"
        self.name            = "Faraday Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo fplugin|sudo \./fplugin|\./fplugin).*?')
        self._hosts          = []
        self.args=None
        self._completition = {
                                "":"f [i &lt;Python Code&gt;]",
                                "-e":"execute model directly",
                                "-o":"output command",
        }
        

    def parseOutputString(self, output, debug = False):
        pass
            
            
    file_arg_re = re.compile(r"^.*(-o\s*[^\s]+).*$")
    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -m parameter to get machine readable output.
        """
        arg_match = self.file_arg_re.match(command_string)
        self._file_output_path=os.path.join(self.data_path,"f_output-%s.txt" % random.uniform(1,10))

        parser = argparse.ArgumentParser()
        
        parser.add_argument('-e')
        parser.add_argument('-f')
        parser.add_argument('-o')
                
        if arg_match is None:               
            final= re.sub(r"(^.*?fplugin)",
                          r"\1 -o %s" % self._file_output_path,
                          command_string) 
        else:
            final= re.sub(arg_match.group(1),
                          r"-o %s" % self._file_output_path,
                          command_string)
        
                                          
        cmd=shlex.split(re.sub(r'\-h|\-\-help', r'', final))
        try:
            self.args, unknown = parser.parse_known_args(cmd)
        except SystemExit:
            pass
        
        codeEx=""
        if self.args.e:
            codeEx=self.args.e
        elif self.args.f:
            with open(current_path + "/" + self.args.f) as f:
                codeEx = f.read()
            f.close()

        if codeEx:
            buffer = StringIO()
            sys.stdout = buffer
            
            try:
                exec(codeEx)
            except Exception:
                api.devlog("[Error] - Faraday plugin")
                api.devlog(traceback.format_exc())
                                 
            sys.stdout = sys.__stdout__

            try:
                f=open(self._file_output_path,"w")
                f.write(buffer.getvalue())
                f.close()
            except:
                api.devlog ("[Faraday] Can't save faraday plugin output file")
                return            

            print buffer.getvalue()


        return final


    def setHost(self):
        pass

def createPlugin():
    return FPlugin()


########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import socket
import re
import os
import pprint
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

valid_records = ["NS", "CNAME", "A"]

class FierceParser(object):
    """
    The objective of this class is to parse an xml file generated by the fierce tool.

    TODO: Handle errors.
    TODO: Test fierce output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param fierce_filepath A proper simple report generated by fierce
    """
    def __init__(self, output):
        
                                   
        self.target = None
        self.items = []
        
                                            
                            
                    
                              
                      
                                               
        r = re.search("DNS Servers for ([\w\.-]+):\r\n([^$]+)Trying zone transfer first...",output)
        if r is not None:
            self.target = r.group(1)
            mstr = re.sub("\t","",r.group(2))
            self.dns = mstr.split()
                               
                                     
                                                                   
        
        r = re.search("Now performing [\d]+ test\(s\)...\r\n([^$]+)\x0D\nSubnets found ",output)
        if r is not None:
            list = r.group(1).split("\r\n")
            for i in list:
                if i != "":
                    mstr = i.split("\t")
                    item = {'host' : mstr[1], 'type' : "A", 'ip' : mstr[0]}
                    self.items.append(item)
                                                                  
                                              
            
        
        self.isZoneVuln = False
        r = re.search("Whoah, it worked - misconfigured DNS server found:\r\n([^$]+)There isn't much point continuing, you have everything.",output)
        if r is not None:
                                              
            self.isZoneVuln = True
            list = r.group(1).split("\n")
            for i in list:
                if i != "":
                    mstr = i.split()
                    if (mstr and mstr[0] != "" and len(mstr) > 3 and mstr[3] in valid_records):
                        item = {'host' : mstr[0], 'type' : mstr[3], 'ip' : mstr[4]}
                                             
                        self.items.append(item)

class FiercePlugin(core.PluginBase):
    """
    Example plugin to parse fierce output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Fierce"
        self.name            = "Fierce Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "0.9.9"
        
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo fierce|fierce|sudo fierce\.pl|fierce\.pl|perl fierce\.pl|\.\/fierce\.pl).*?')
        self._completition = {
                                "":"perl fierce.pl [-dns example.com] [OPTIONS]",
                                "-connect":"Attempt to make http connections to any non RFC1918 lot of free time on your hands (could take hours-days).  ",
                                "-delay":"The number of seconds to wait between lookups.",
                                "-dns":"The domain you would like scanned.",
                                "-dnsfile":"Use DNS servers provided by a file (one per line) for",
                                "-dnsserver":"Use a particular DNS server for reverse lookups ",
                                "-file":"A file you would like to output to be logged to.",
                                "-fulloutput":"When combined with -connect this will output everything",
                                "-help":"This screen.",
                                "-nopattern":"Don't use a search pattern when looking for nearby",
                                "-range":"Scan an internal IP range (must be combined with dnsserver).  Note, that this does not support a pattern. perl fierce.pl -range 111.222.333.0-255 -dnsserver ns1.example.co",
                                "-search":"	-search		Search list.  When fierce attempts to traverse up and. perl fierce.pl -dns examplecompany.com -search corpcompany,blahcompany",
                                "-suppress":"Suppress all TTY output (when combined with -file).",
                                "-tcptimeout":"Specify a different timeout (default 10 seconds).  You",
                                "-threads":"Specify how many threads to use while scanning (default",
                                "-traverse":"Specify a number of IPs above and below whatever IP you",
                                "-version":"Output the version number.",
                                "-wide":"Scan the entire class C after finding any matching",
                                "-wordlist":"Use a seperate wordlist (one word per line).  Usage:",            
        }

        global current_path
        
                                  

    def canParseCommandString(self, current_input):
        if self._command_regex.match(current_input.strip()):
            return True
        else:
            return False

    def resolveCNAME(self, item, items):
        for i in items:
            if (i['host'] == item['ip']):
                item['ip'] = i['ip']
                return item
        try:
            item['ip'] = socket.gethostbyname(item['ip'])
        except:
            pass
        return item

    def resolveNS(self, item, items):
        try:
            item['host'] = item['ip']
            item['ip'] = socket.gethostbyname(item['ip'])
        except:
            pass
        return item

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        
        parser = FierceParser(output)
        for item in parser.items:
            item['isResolver'] = False
            item['isZoneVuln'] = False
            if (item['type'] == "CNAME"):
                self.resolveCNAME(item, parser.items)
            if (item['type'] == "NS"):
                self.resolveNS(item, parser.items)
                item['isResolver'] = True
                item['isZoneVuln'] = parser.isZoneVuln
                for item2 in parser.items:
                    if item['ip'] == item2['ip'] and item != item2:
                        item2['isResolver'] = item['isResolver']
                        item2['isZoneVuln'] = item['isZoneVuln']
                                                           
                        item['ip'] = ''

                            
                                           
                                               
                                                                              
                                               

                                                                    
         
                                     
                                      
        for item in parser.items:
            if item['ip'] == "127.0.0.1" or item['ip'] == '':
                continue
            print "agregando (%s) (%s)" % (item['host'],item['ip'])
            h_id = self.createAndAddHost(item['ip'])
            i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address= item['ip'], hostname_resolution = [item['host']])
            if item['isResolver']:
                s_id = self.createAndAddServiceToInterface(h_id, i_id, "domain", "tcp", ports=['53'])
                if item['isZoneVuln']:
                    self.createAndAddVulnToService(h_id, s_id, "Zone transfer", desc="A Dns server allows unrestricted zone transfers",
                                                      ref=["CVE-1999-0532"])
        del parser

    def processCommandString(self, username, current_path, command_string):
        """
        """
        return None

def createPlugin():
    return FiercePlugin()

if __name__ == '__main__':
    parser = FierceParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from plugins import core
from model import api
import re
import os, socket
import pprint
current_path = os.path.abspath(os.getcwd())

__author__     = "Javier Victor Mariano Bruno"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Javier Victor Mariano Bruno"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Javier Victor Mariano Bruno"
__email__      = "mbruno@infobytesec.com"
__status__     = "Development"


class CmdFtpPlugin(core.PluginBase):
    """
    This plugin handles ftp command.
    Basically detects if user was able to connect to a device
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "ftp"
        self.name            = "Ftp"
        self.plugin_version         = "0.0.1"
        self.version        =  "0.17"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^ftp.*?')
        self._host_ip        = None
        self._port      = "21"
        self._info           = 0
        self._version        = None
        self._completition = {
            "":"ftp [-46pinegvd] [host [port]]",
            "-4":"Use only IPv4 to contact any host.",
            "-6":"Use IPv6 only.",
            "-p":"Use passive mode for data transfers. Allows use of ftp in environments where a firewall prevents connections from the outside world back to the client machine. Requires that the ftp server support the PASV command. This is the default if invoked as pftp.",
            "-i":"Turns off interactive prompting during multiple file transfers.",
            "-n":"Restrains ftp from attempting auto-login upon initial connection.  If auto-login is enabled, ftp will check the .netrc (see netrc(5)) file in the user's home directory for an entry describing an account on the remote machine.  If no entry exists, ftp will prompt for the remote machine login name (default is the user identity on the local machine), and, if necessary, prompt for a password and an account with which to login.",
            "-e":"Disables command editing and history support, if it was compiled into the ftp executable. Otherwise, does nothing.",
            "-g":"Disables file name globbing.",
            "-v":"Verbose option forces ftp to show all responses from the remote server, as well as report on data transfer statistics.",
            "-d":"Enables debugging.",
            }

        global current_path

                                  

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

    def parseOutputString(self, output, debug = False):
        
        host_info = re.search(r"Connected to (.+)\.", output)
        banner = re.search("220?([\w\W]+)$", output)
        if re.search("Connection timed out",output) is None and host_info is not None:
            hostname=host_info.group(1)
            ip_address = self.resolve(hostname)
            self._version = banner.groups(0) if banner else ""
            if debug:
                print ip_address

            h_id = self.createAndAddHost(ip_address)
            i_id = self.createAndAddInterface(h_id, ip_address, ipv4_address=ip_address,hostname_resolution=hostname)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, "ftp",
                                                   "tcp",
                                                   ports = [self._port],
                                                   status = "open")

                
            

            print ("Host detected: %s" % ip_address)

            api.log("New host detected: %s" % ip_address)
        if debug is True:
            api.devlog("Debug is active")


        return True

    def processCommandString(self, username, current_path, command_string):
        """
        """
        count_args = command_string.split()
        
        c=count_args.__len__()
        self._port="21"
        if re.search("[\d]+",count_args[c-1]):
            self._port = count_args[c-1]

        return None
def createPlugin():
    return CmdFtpPlugin()

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os, socket
import pprint
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class GoohostParser(object):
    """
    The objective of this class is to parse an xml file generated by the goohost tool.

    TODO: Handle errors.
    TODO: Test goohost output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param goohost_filepath A proper simple report generated by goohost
    @param goohost_scantype You could select scan type ip, mail or host
    """
    def __init__(self, goohost_filepath, goohost_scantype):
        self.filepath = goohost_filepath
        self.scantype = goohost_scantype
        
                                                              
                                          
        with open(self.filepath,"r") as f:
                              
            print "estoy por leer el archivo (%s)" % self.filepath 
            line = f.readline()
            self.items = []
            print "afuera del while %s" % line
            while line:
                print "estoy adentro del while %s" % line
                if self.scantype == 'ip':
                    minfo = line.split()
                    item = {'host' : minfo[0], 'ip' : minfo[1]}
                    print "El item ip (%s) (%s)" % (minfo[0],minfo[1])
                elif self.scantype == 'host':
                    line = line.strip()
                    item = {'host' : line, 'ip' : self.resolve(line)}
                    print "El item ip (%s) (%s)" % (item['host'],item['ip'])
                else:
                    item = {'data' : line}
                    print "el item host email %s" % line
                
                self.items.append(item)
                line = f.readline()

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host


class GoohostPlugin(core.PluginBase):
    """
    Example plugin to parse goohost output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Goohost"
        self.name            = "Goohost XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "v.0.0.1"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo goohost\.sh|goohost\.sh|sh goohost\.sh|\.\/goohost\.sh).*?')
        self.scantype = "host"
        self.host = None
        self._completition = {
                                "":"./goohost.sh -t domain.tld [-m <host|ip|mail> -p <1-20> -v] ",
                                "-t":"target domain. Ex: backtrack.linux.org ",
                                "-m":"method: <ip|host|mail>. Default value is set to host ",
                                "-p":"pages [1-20]. Max number of pages to download from Google. Default 5 ",
                                "-v":"verbosity. Default is set to off ",
        }

        global current_path
        self.output_path = None
        
                                  


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        
        print "este es el output (%s)" % output
                                                                               
        if self.output_path is None:
            mypath = re.search("Results saved in file (\S+)",output);
            print "este es el output %s" % output
            if mypath is not None:
                print "encontre el archivo '%s' '%s'" % (mypath.group(1), self.scantype)
                                                                                            
                self.output_path = self._current_path + "/" + mypath.group(1)
                
                
            else:
                return False
            
        if debug:
            parser = GoohostParser(output,self.scantype)
        else:
            if not os.path.exists(self.output_path):
                print "el archivo no existe '%s'" % self.output_path
                return False
            
            print "estoy a punto de entrar a goohost"
            parser = GoohostParser(self.output_path,self.scantype)


                                                                        
             

                                                                            
            if self.scantype == 'host' or self.scantype == 'ip' :
                                      
                                         
                for item in parser.items:
                    h_id = self.createAndAddHost(item['ip'])
                    i_id = self.createAndAddInterface(h_id, item['ip'],ipv4_address=item['ip'],hostname_resolution=item['host'])

        del parser
        
                      
                                             
                    

    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -oX parameter to get xml output to the command string that the
        user has set.
        """
         
                                                           
                                                         
                                              
                                          
                                          
                             
                                      
                                                          
                    

    def setHost(self):
        pass


def createPlugin():
    return GoohostPlugin()

if __name__ == '__main__':
    parser = GoohostParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import sys
import random


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class HydraParser(object):
    """
    The objective of this class is to parse an xml file generated by the hydra tool.

    @param hydra_filepath A proper simple report generated by hydra
    """
    def __init__(self, xml_output):
        lines = xml_output.splitlines()
        self.items = []
        for l in lines:
            reg = re.search("\[([^$]+)\]\[([^$]+)\] host: ([^$]+)   login: ([^$]+)   password: ([^$]+)\n",l)
            if reg:
                item = {'port' : reg.group(1), 'plugin' : reg.group(2), 'ip' : reg.group(3), 'login' : reg.group(4), 'password' : reg.group(5) }
                                         
                self.items.append(item)

                                    





class HydraPlugin(core.PluginBase):
    """
    Example plugin to parse hydra output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Hydra"
        self.name            = "Hydra XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "7.5"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo hydra|sudo \.\/hydra|hydra|\.\/hydra).*?')
        self.host = None
        self._completition = {
                                "":"[[[-l LOGIN|-L FILE] [-p PASS|-P FILE]] | [-C FILE]] [-e nsr] [-o FILE] [-t TASKS] [-M FILE [-T TASKS]] [-w TIME] [-W TIME] [-f] [-s PORT] [-x MIN:MAX:CHARSET] [-SuvV46] [service://server[:PORT][/OPT]]",
                                "-R":"restore a previous aborted/crashed session",
                                "-S":"connect via SSL",
                                "-s":"PORT   if the service is on a different default port, define it here",
                                "-l":"LOGIN or -L FILE login with LOGIN name, or load several logins from FILE",
                                "-p":"PASS  or -P FILE try password PASS, or load several passwords from FILE",
                                "-x":"MIN:MAX:CHARSET  password bruteforce generation, type \"-x -h\" to get help",
                                "-u":"loop around users, not passwords (effective! implied with -x)",
                                "-e":"ns     additional checks, \"n\" for null password, \"s\" try login as pass",
                                "-C":"FILE   colon separated \"login:pass\" format, instead of -L/-P options",
                                "-M":"FILE   server list for parallel attacks, one entry per line",
                                "-o":"FILE   write found login/password pairs to FILE instead of stdout",
                                "-f":"exit after the first found login/password pair (per host if -M)",
                                "-t":"TASKS  run TASKS number of connects in parallel (default: 16)",
                                "-w":"TIME   defines the max wait time in seconds for responses (default: 30)",
                                "-4":"prefer IPv4 (default)",
                                "-6":"prefer IPv6 addresses",
                                "-v":"verbose mode / show login+pass combination for each attempt",
                                "-V":"verbose mode / show login+pass combination for each attempt",
                                "-U":"service module usage details",            
        }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "hydra_output-%s.txt" % self._rid)
        
                                  


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = HydraParser(output)

        i=0;
        hosts={}
        service=""
        port=""
        for item in parser.items:
            service=item['plugin']
            port=item['port']
            
            if hosts.has_key(item['ip']) == False:
                hosts[item['ip']]=[]
                
            hosts[item['ip']].append([item['login'],item['password']])
                
        for k,v in hosts.iteritems():
            h_id = self.createAndAddHost(k)
            if self._isIPV4(k):
                i_id = self.createAndAddInterface(h_id, k, ipv4_address=k)
            else:
                i_id = self.createAndAddInterface(h_id, k, ipv6_address=k)
            s_id = self.createAndAddServiceToInterface(h_id,i_id,service,ports=[port],protocol="tcp",status="open")
            for cred in v:
                self.createAndAddCredToService(h_id,s_id, cred[0],cred[1])
            
        del parser

    xml_arg_re = re.compile(r"^.*(-o\s*[^\s]+).*$")
    def processCommandString(self, username, current_path, command_string):

        self._output_file_path=os.path.join(self.data_path,"hydra_output-%s.txt" % random.uniform(1,10))        
        arg_match = self.xml_arg_re.match(command_string)

        if arg_match is None:
            return re.sub(r"(^.*?hydra?)",r"\1 -o %s" % self._output_file_path,command_string)
        else:
            return re.sub(arg_match.group(1),
                          r"-o %s" % self._output_file_path,
                          command_string)
    
    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

    def setHost(self):
        pass


def createPlugin():
    return HydraPlugin()

if __name__ == '__main__':
    parser = HydraParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class ImpactXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the impact tool.

    TODO: Handle errors.
    TODO: Test impact output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param impact_xml_filepath A proper xml generated by impact
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """       
        for node in tree.findall("entity/[@class='host']"):
            yield Item(node,tree)

                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an impact xml tree
    """
    def __init__(self, item_node,parent=None):
        self.node = item_node
        
        self.arch = self.get_text_from_subnode("property/[@key='arch']")
        self.host = self.get_text_from_subnode("property/[@key='display_name']")
        self.ip = self.get_text_from_subnode("property/[@key='ip']")
        self.os = self.get_text_from_subnode("property/[@key='os']/property/[@key='entity name']")

        self.ports=[]
        for p in item_node.findall("property/[@key='tcp_ports']/property/[@type='port']"):
            self.ports.append({'port':p.get('key'),
                               'protocol':"tcp",
                               'status':"open" if p.text =="listen" else p.text})

        for p in item_node.findall("property/[@key='udp_ports']/property/[@type='port']"):
            self.ports.append({'port':p.get('key'),
                               'protocol':"udp",
                               'status':"open" if p.text =="listen" else p.text})
            

        self.agent=False
        for node in parent.findall("entity/[@class='agent']"):
                                                      
            self.node=node
            agentip=node.get('name').split("/")[1]
            if self.ip == agentip:
                self.agentip=agentip
                self.ipfrom=self.get_text_from_subnode("property/[@key='Connection Properties']/property/[@key='ip']")
                self.agentype=node.get("type")
                self.agentport= self.get_text_from_subnode("property/[@key='Connection Properties']//property/[@key='port']")
                self.agentsubtype= self.get_text_from_subnode("property/[@key='Connection Properties']//property/[@key='subtype']")
                self.agentcon=self.get_text_from_subnode("property/[@key='Connection Properties']//property/[@key='type']")
                self.agent=True
                break
            
        self.results=self.getResults(item_node)

    
    def getResults(self, tree):
        """
        :param tree:
        """
        for self.issues in tree.findall("property/[@key='Vulnerabilities']/property/[@type='container']"):
            yield Results(self.issues)
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class Results():
    def __init__(self, issue_node):
        self.node = issue_node
        self.ref=issue_node.get('key')
        vuln=issue_node.find("property/property")
        self.name=vuln.get("key")
        self.node=vuln
        self.desc= self.get_text_from_subnode("property/[@key='description']")
        self.port= self.get_text_from_subnode("property/[@key='port']")

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class ImpactPlugin(core.PluginBase):
    """
    Example plugin to parse impact output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Core Impact"
        self.name            = "Core Impact XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "Core Impact 2013R1"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo impact|\.\/impact).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "impact_output-%s.xml" % self._rid)

    def parseOutputString(self, output, debug = False):
        
                                                                          
        parser = ImpactXmlParser(output)
        for item in parser.items:
            h_id = self.createAndAddHost(item.ip,item.os+" "+item.arch)
            i_id = self.createAndAddInterface(h_id, item.ip,ipv4_address=item.ip, hostname_resolution=item.host)
            for p in item.ports:
                s_id = self.createAndAddServiceToInterface(h_id, i_id, p['port'],
                                                            p['protocol'],
                                                            ports = [p['port']],
                                                            status=p['status']) 
            
            if item.agent:
                desc="Agent Type: "+item.agentype
                desc+="\nConn from:" + item.ipfrom
                desc+="\nPort:" + item.agentport
                desc+="\nProtocol:" +item.agentsubtype
                desc+="\nConn:" +item.agentcon
                
                v_id=self.createAndAddVulnToHost(h_id,"Core Impact Agent",desc=desc,severity="HIGH")
                
            for v in item.results:
                if v.port == "Unknown":
                    v_id=self.createAndAddVulnToHost(h_id,v.name,desc=v.desc,
                                                        ref=v.ref)
                else:                    
                    s_id = self.createAndAddServiceToInterface(h_id, i_id, v.port,
                                                                       
                                                        ports = [str(v.port)],
                                                        status = "open")                        
                    v_id=self.createAndAddVulnToService(h_id, s_id,v.name,desc=v.desc,
                                                        ref=v.ref)
        del parser
        
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return ImpactPlugin()

if __name__ == '__main__':
    parser = ImpactXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class ListurlsParser(object):
    """
    The objective of this class is to parse an xml file generated by the listurls tool.

    TODO: Handle errors.
    TODO: Test listurls output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param listurls_filepath A proper simple report generated by listurls
    """
    def __init__(self, output):
        lists = output.split("\r\n")
        i=0;
        self.items = []
        if re.search("Could not reach",output) is not None:
            self.fail = True
            return
            
        for line in lists:
            if i > 8:
                print line
                item = {'link' : line}
                self.items.append(item)
            i=i+1



class ListurlsPlugin(core.PluginBase):
    """
    Example plugin to parse listurls output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Listurls"
        self.name            = "Listurls XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "6.3"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo list-urls\.py|list-urls\.py|perl list-urls\.py|\.\/list-urls\.py).*?')
        self.host = None
        self.port = None
        self.protocol = None
        self.fail = None
        self._completition ={
                                "":"./list-urls.py <web-page>"
        }

        global current_path
        self.output_path = os.path.join(self.data_path,
                                             "listurls_output-%s.txt" % self._rid)
        
                                  

    def canParseCommandString(self, current_input):
        if self._command_regex.match(current_input.strip()):
            return True
        else:
            return False


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
         
                                                
                                                 
             
                  
                                            
              
             
                                                       
                                            
         
         
                                                                         
              
                                  
                       
             
                                  
                               
                 
                                                                  
                                                                                               
             
                 
                                      
                                               
                 
                                                                              
                                                          
                                                                    
                                                                          
                                                                            
                                                                               
                      
         
                   
        
                      
                                             
                    

     
                                                                           
                                                                                     
    def processCommandString(self, username, current_path, command_string):
                                                                                                                                                                                                                                                                                                                                                                                                                                                             
        host = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", command_string)
                            
        self.protocol = host.group(1)
        self.host = host.group(4)
        if self.protocol == 'https':
            self.port=443
        if host.group(11) is not None:
            self.port = host.group(11)
        return None
    
    def setHost(self):
        pass


def createPlugin():
    return ListurlsPlugin()

if __name__ == '__main__':
    parser = ListurlsParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class MaltegoXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the maltego tool.

    TODO: Handle errors.
    TODO: Test maltego output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param maltego_xml_filepath A proper xml generated by maltego
    """
    def __init__(self, xml_output):
        self.target = None
        self.port = "80"
        self.host = None

        tree = self.parse_xml(xml_output)

        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
        
                                           
        node = tree.findall('graph')[0]
            
        for n in node.findall('node'):
            yield Item(n)
                                  


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an maltego xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.items =None

        self.id = self.get('id')
        node2 = self.node.findall('data')[0]
        node3 = node2.findall('mtg:MaltegoEntity')[0]
        self.node = node3
        self.type = self.get('type')
        node4 = node3.findall('mtg:Properties')[0]
        for n in node4.findall('mtg:Property'):
            self.node = n
            dname = self.get('displayName')
            value = self.get_text_from_subnode('mtg:Value')
            item = {'dname': dname, 'value' : value}
            self.items.append(item)
        
        
    def do_clean(self,value):
        myreturn =""
        if value is not None:
            myreturn = re.sub("\n","",value)
        return myreturn
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class MaltegoPlugin(core.PluginBase):
    """
    Example plugin to parse maltego output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Maltego"
        self.name            = "Maltego XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "3.0.4"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(sudo maltego|maltego|\.\/maltego).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "maltego_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        parser = MaltegoXmlParser(output)

        for item in parser.items:
            if item.id is not None:
                h_id = self.createAndAddHost(item.id, "unknown")
                i_id = self.createAndAddInterface(h_id, item.id,"00:00:00:00:00:00", item.id)
                for i in item.items:
                    s_id = self.createAndAddServiceToInterface(h_id, i_id, 
                                                        i['dname'],
                                                        "tcp",
                                                        ports = [0],
                                                        status = "status",
                                                        version = "version",
                                                        description = i['value'])

        del parser

    def processCommandString(self, username, current_path, command_string):
        return None

    def setHost(self):
        pass


def createPlugin():
    return MaltegoPlugin()

if __name__ == '__main__':
    parser = MaltegoXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys
import random
import socket


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright 2013, Faraday Project"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class MedusaParser(object):
    """
    The objective of this class is to parse an xml file generated by the medusa tool.

    @param medusa_filepath A proper simple report generated by medusa
    """
    def __init__(self, xml_output):
        self.srv = {'ftp':'21','http':'80','imap':'143','mssql':'1433','mysql':'3306','ncp':'524','nntp':'119',
                    'pcanywhere':'5631','pop3':'110','postgres':'5432','rexec':'512','rlogin':'513','rsh':'514',
                    'smbnt':'smbnt','smtp':'25','smtp-vrfy':'smtp-vrfy','snmp':'161','ssh':'22','svn':'3690',
                    'telnet':'23','vmauthd':'vmauthd','vnc':'5900','web-form':'web-form','wrapper':'wrapper'}

        lines = xml_output.splitlines()
        self.items = []
        for l in lines:
                                                                                      
            reg = re.search("ACCOUNT FOUND: \[([^$]+)\] Host: ([^$]+) User: ([^$]+) Password: ([^$]+) \[SUCCESS\]\n",l)
                                                                                                             
            if reg:
                item = {'service' : reg.group(1), 'host' : reg.group(2), 'user' : reg.group(3),
                        'pass' : reg.group(4)}
                
                print "ITEM" + str(item)
                item['ip'] = self.getAddress(item['host'])
                item['port']=self.srv[item['service']]
                print "ITEM" + str(item)
                self.items.append(item)

    def getAddress(self, hostname):
        """
        Returns remote IP address from hostname.
        """
        try:
            return socket.gethostbyname(hostname)
        except socket.error, msg:
            return hostname



class MedusaPlugin(core.PluginBase):
    """
    Example plugin to parse medusa output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Medusa"
        self.name            = "Medusa Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "2.1.1"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo medusa|sudo \.\/medusa|medusa|\.\/medusa).*?')
        self.host = None
        self.port =""

        self._completition = {
                                "":"Syntax: Medusa [-h host|-H file] [-u username|-U file] [-p password|-P file] [-C file] -M module [OPT]",
                                "-h":"[TEXT] Target hostname or IP address",
                                "-H":"[FILE] File containing target hostnames or IP addresses",
                                "-u":"[TEXT] Username to test",
                                "-U":"[FILE] File containing usernames to test",
                                "-p":"[TEXT] Password to test",
                                "-P":"[FILE] File containing passwords to test",
                                "-C":"[FILE] File containing combo entries. See README for more information.",
                                "-O":"[FILE] File to append log information to",
                                "-e":"[n/s/ns] Additional password checks ([n] No Password, [s] Password = Username)",
                                "-M":"[TEXT] Name of the module to execute (without the .mod extension)",
                                "-m":"[TEXT] Parameter to pass to the module. This can be passed multiple times with a",
                                "-m":"-m Param1 -m Param2, etc.)",
                                "-d":"Dump all known modules",
                                "-n":"[NUM] Use for non-default TCP port number",
                                "-s":": Enable SSL",
                                "-g":"[NUM] Give up after trying to connect for NUM seconds (default 3)",
                                "-r":"[NUM] Sleep NUM seconds between retry attempts (default 3)",
                                "-R":"[NUM] Attempt NUM retries before giving up. The total number of attempts will be NUM + 1.",
                                "-t":"[NUM] Total number of logins to be tested concurrently",
                                "-T":"[NUM] Total number of hosts to be tested concurrently",
                                "-L":"Parallelize logins using one username per thread. The default is to process ",
                                "-f":"Stop scanning host after first valid username/password found.",
                                "-F":"Stop audit after first valid username/password found on any host.",
                                "-b":"Suppress startup banner",
                                "-q":"Display module's usage information",
                                "-v":"[NUM] Verbose level [0 - 6 (more)]",
                                "-w":"[NUM] Error debug level [0 - 10 (more)]",
                                "-V":": Display version",
                                "-Z":": Resume scan based on map of previous scan",     
        }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "medusa_output-%s.txt" % self._rid)
        
                                  


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        parser = MedusaParser(output)
        for item in parser.items:
            h_id = self.createAndAddHost(item['ip'])
            if self._isIPV4(item['ip']):
                i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address=item['ip'],hostname_resolution=item['host'])
            else:
                i_id = self.createAndAddInterface(h_id, item['ip'], ipv6_address=item['ip'],hostname_resolution=item['host'])
            
            port = self.port if self.port else item['port']
            
            s_id = self.createAndAddServiceToInterface(h_id,i_id,item['service'],ports=[port],protocol="tcp",status="open")
            
            self.createAndAddCredToService(h_id,s_id, item['user'],item['pass'])

        del parser

    xml_arg_re = re.compile(r"^.*(-O\s*[^\s]+).*$")
    def processCommandString(self, username, current_path, command_string):

        self.port=""
        self._output_file_path=os.path.join(self.data_path,"medusa_output-%s.txt" % random.uniform(1,10))        
        arg_match = self.xml_arg_re.match(command_string)
        
        mreg=re.search(r"\-n( |)([\d]+)",command_string)
        if mreg:
            self.port=mreg.group(2)

        if arg_match is None:
            return re.sub(r"(^.*?medusa?)",r"\1 -O %s" % self._output_file_path,command_string)
        else:
            return re.sub(arg_match.group(1),
                          r"-O %s" % self._output_file_path,
                          command_string)
    
    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

    def setHost(self):
        pass


def createPlugin():
    return MedusaPlugin()

if __name__ == '__main__':
    parser = MedusaParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os, socket
import pprint
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class MetagoofilParser(object):
    """
    The objective of this class is to parse an xml file generated by the metagoofil tool.

    TODO: Handle errors.
    TODO: Test metagoofil output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param metagoofil_filepath A proper simple report generated by metagoofil
    """
    def __init__(self, output):
        
                                     
        self.items = []
        
        mfile = open("/root/dev/faraday/trunk/src/del", "r")
        output = mfile.read()
        mfile.close()
        print "adentro del init (%s)" % output
                                
 
                         
                     
 
                            
                        
 
                                     
                                 

                                                                                                                                                                                                                                                                                             
                                                                                                                                   
                
        mregex = re.search("\[\+\] List of paths and servers found:[-\s]+([^$]+)\[\+\] List of e-mails found:", output,re.M)
        if mregex is None:
            print "mregex no andubo"
            return
        
                                                                                         
        print "email (%s) " % (mregex.group(1))
        self.users = mregex.group(1).split("\n")
        self.software =mregex.group(2).split("\n")
        self.servers=mregex.group(1).strip().split("\n")
        
        for line in self.servers:
            line = line.strip()
            item = {'host' : line, 'ip' : self.resolve(line)}
            print item
            self.items.append(item)

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

class MetagoofilPlugin(core.PluginBase):
    """
    Example plugin to parse metagoofil output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Metagoofil"
        self.name            = "Metagoofil XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "2.2"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo metagoofil|metagoofil|sudo metagoofil\.py|metagoofil\.py|python metagoofil\.py|\.\/metagoofil\.py).*?')
        self._completition = {
                                "":"metagoofil.py -d microsoft.com -t doc,pdf -l 200 -n 50 -o microsoftfiles -f results.html",
                                "-d":"domain to search",
                                "-t":"filetype to download (pdf,doc,xls,ppt,odp,ods,docx,xlsx,pptx)",
                                "-l":"limit of results to search (default 200)",
                                "-h":"work with documents in directory (use \"yes\" for local analysis)",
                                "-n":"limit of files to download",
                                "-o":"working directory",
                                "-f":"output file",
        }

        global current_path
        
                                  

    def canParseCommandString(self, current_input):
        if self._command_regex.match(current_input.strip()):
            return True
        else:
            return False


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        
                                                
             
                  
                                              
              
             
                                                         
                                              
         
         
                                                                         
              
                                         
                                      
                                                                        
                                                         
                                                                                             
         
         
                   
        
    def processCommandString(self, username, current_path, command_string):
        """
        """
        return None



def createPlugin():
    return MetagoofilPlugin()

if __name__ == '__main__':
    parser = MetagoofilParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class MetasploitXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the metasploit tool.

    TODO: Handle errors.
    TODO: Test metasploit output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param metasploit_xml_filepath A proper xml generated by metasploit
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)

        if tree:
            servicesByWebsite = {}
            for site in tree.findall('web_sites/web_site'):
                servicesByWebsite[site.find('id').text] = site.find('service-id').text

            webVulnsByService = {}
            for v in [data for data in self.get_vulns(tree, servicesByWebsite)]:
                if v.service_id not in webVulnsByService:
                    webVulnsByService[v.service_id] = []
                webVulnsByService[v.service_id].append(v)

            self.hosts = [data for data in self.get_items(tree, webVulnsByService)]
        else:
            self.hosts = []

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree, webVulns):
        """
        @return items A list of Host instances
        """
        bugtype=""
        
                                           
                                         
            
        for node in tree.findall('hosts/host'):
            yield Host(node, webVulns)
                                  

    def get_vulns(self, tree, services):
        """
        @return items A list of WebVuln instances
        """
        bugtype=""           
        for node in tree.findall('web_vulns/web_vuln'):
            yield WebVuln(node, services)

                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 
class Host(object):
    def __init__(self, item_node, webVulnsByService):
        self.node = item_node
        self.id = self.get_text_from_subnode('id')
        self.host = self.get_text_from_subnode('name')
        self.ip = self.get_text_from_subnode('address')
        self.os = self.get_text_from_subnode('os-name')

        self.services = []
        self.vulnsByService = {}
        self.vulnsByHost = []
        self.notesByService = {}
        self.credsByService = {}
        for s in self.node.findall('services/service'):
            service = {'id':None, 'port':None, 'proto':None, 'state':None, 'name': None, 'info':None}
            for attr in service:
                service[attr] = s.find(attr).text
            if not service['name']:
                service['name']='unknown'
            if not service['state']:
                service['state']='unknown'
            if not service['info']:
                service['info']='unknown'
                
            self.services.append(service)
            self.vulnsByService[service['id']] = []
            self.notesByService[service['id']] = []
            if service['id'] in webVulnsByService:
                self.vulnsByService[service['id']] += webVulnsByService[service['id']]

        for v in self.node.findall('vulns/vuln'):
            vuln = HostVuln(v)
            if vuln.service_id:
                self.vulnsByService[vuln.service_id].append(vuln)
            else:
                self.vulnsByHost.append(vuln)

        for n in self.node.findall('notes/note'):
            note = HostNote(n)
            key=self.id+"_"+note.service_id
            if not key in self.notesByService:
                self.notesByService[key] = []
                
            self.notesByService[key].append(note)

        for c in self.node.findall('creds/cred'):
            cred = HostCred(c)
            key=cred.port
            if not key in self.credsByService:
                self.credsByService[key] = []
                
            self.credsByService[key].append(cred)
            
            

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            if sub_node.text is not None:
                return sub_node.text

        return None

class WebVuln(object):
    def __init__(self, item_node, services):
        self.node = item_node
        self.name = self.get_text_from_subnode('name')
        self.desc = self.get_text_from_subnode('description')
        self.host = self.get_text_from_subnode('vhost')
        self.port = self.get_text_from_subnode('port')
        self.ip = self.get_text_from_subnode('host')
        self.path = self.get_text_from_subnode('path')
        self.method = self.get_text_from_subnode('method')
        self.params = self.get_text_from_subnode('params')
        self.pname = self.get_text_from_subnode('pname')
        self.risk = self.get_text_from_subnode('risk')
        self.confidence = self.get_text_from_subnode('confidence')
        self.query = self.get_text_from_subnode('query')
        self.request = self.get_text_from_subnode('request')
        self.category = self.get_text_from_subnode('category-id')
        self.service_id = services[self.get_text_from_subnode('web-site-id')]
        self.isWeb = True

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            if sub_node.text is not None:
                return sub_node.text

        return ""

class HostNote(object):
    """
    An abstract representation of a HostNote


    @param item_node A item_node taken from an metasploit xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.service_id = self.get_text_from_subnode('service-id') if not None else ""
        self.host_id = self.get_text_from_subnode('host-id')
        self.ntype = self.get_text_from_subnode('ntype')
        self.data = self.get_text_from_subnode('data')

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            if sub_node.text is not None:
                return sub_node.text

        return ""
    
class HostCred(object):
    """
    An abstract representation of a HostNote


    @param item_node A item_node taken from an metasploit xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.port = self.get_text_from_subnode('port')
        self.user = self.get_text_from_subnode('user')
        self.passwd = self.get_text_from_subnode('pass')
        self.ptype = self.get_text_from_subnode('ptype')
        self.sname = self.get_text_from_subnode('sname')

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            if sub_node.text is not None:
                return sub_node.text

        return ""

class HostVuln(object):
    """
    An abstract representation of a HostVuln


    @param item_node A item_node taken from an metasploit xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.service_id = self.get_text_from_subnode('service-id')
        self.name = self.get_text_from_subnode('name')
        self.desc = self.get_text_from_subnode('info')
        self.refs = [r.text for r in self.node.findall('refs/ref')]
        self.exploited_date = self.get_text_from_subnode('exploited-at')
        self.exploited = (self.exploited_date != None)
        self.isWeb = False

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            if sub_node.text is not None:
                return sub_node.text

        return ""


class MetasploitPlugin(core.PluginBase):
    """
    Example plugin to parse metasploit output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Metasploit"
        self.name            = "Metasploit XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "4.7.2"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(metasploit|sudo metasploit|\.\/metasploit).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "metasploit_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = MetasploitXmlParser(output)

        for item in parser.hosts:
            h_id = self.createAndAddHost(item.ip, item.os)
            if self._isIPV4(item.ip):
                i_id = self.createAndAddInterface(h_id, item.ip, ipv4_address=item.ip,hostname_resolution=item.host)
            else:
                i_id = self.createAndAddInterface(h_id, item.ip, ipv6_address=item.ip,hostname_resolution=item.host)

            if item.id+"_" in item.notesByService:
                for n in item.notesByService[item.id+"_"]:
                    self.createAndAddNoteToHost(h_id,n.ntype,n.data)

            for v in item.vulnsByHost:
                print (h_id, v.name, v.desc, v.refs)
                v_id = self.createAndAddVulnToHost(h_id, v.name, v.desc, ref=v.refs)
                
            
            for s in item.services:
                print (h_id, i_id , s['name'],
                                                           s['proto'],
                                                           [s['port']],
                                                           s['state'],
                                                           s['info'])
                s_id = self.createAndAddServiceToInterface(h_id, i_id , s['name'],
                                                           s['proto'],
                                                           ports = [s['port']],
                                                           status = s['state'],
                                                           description = s['info'])                                          
                
                      
                if item.id+"_"+s['id'] in item.notesByService:
                    for n in item.notesByService[item.id+"_"+s['id']]:
                        self.createAndAddNoteToService(h_id,s_id,n.ntype,n.data)
                     
                if s['port'] in item.credsByService:
                    for c in item.credsByService[s['port']]:
                        print "CREDS"
                        print (h_id,s_id,s['port'],c.user,c.passwd)
                        self.createAndAddCredToService(h_id,s_id,c.user,c.passwd)

                n_id = None
                for v in item.vulnsByService[s['id']]:
                    if v.isWeb:
                        if n_id == None:
                            n_id = self.createAndAddNoteToService(h_id, s_id, "website", "")
                        n2_id = self.createAndAddNoteToNote(h_id, s_id, n_id, v.host, "")
                        v_id = self.createAndAddVulnWebToService(h_id, s_id, v.name, v.desc,
                                                                 severity=v.risk, website=v.host,
                                                                 path=v.path, request=v.request, method=v.method,
                                                                 pname=v.pname, params=v.params, query=v.query,
                                                                 category=v.category)
                    else:
                        print (h_id, s_id, v.name, v.desc, v.refs)
                        v_id = self.createAndAddVulnToService(h_id, s_id, v.name, v.desc, ref=v.refs)


        del parser
        
                      
                                             
                    
    
    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return MetasploitPlugin()

if __name__ == '__main__':
    parser = MetasploitXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import sys
import psycopg2
import time

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


                 

class MetasploitOnPlugin(core.PluginBase):
    """
    Example plugin to parse metasploiton output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "MetasploitOn"
        self.name            = "Metasploit Online Service Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "Metasploit 4.7.2"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(metasploiton|sudo metasploiton|\.\/metasploiton).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "metasploiton_output-%s.xml" % self._rid)
                                  
        self.addSetting("Database", str, "msf3")
        self.addSetting("User", str, "msf3")
        self.addSetting("Password", str, "ldoxy1qeJOkD7H515wKNgEbboCslTfyO")
        self.addSetting("Server", str, "localhost")
        self.addSetting("Wordspace", str, "%%")
        self.addSetting("Enable", str, "0")
        
        self._sdate=""                     
        self._lsdate=""                       
        self._mwhere=""       
    
        

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        try:
            conn = psycopg2.connect("dbname='"  + self.getSetting("Database")+ "' user='"+self.getSetting("User")+"' password='"+self.getSetting("Password")+"' host='"+self.getSetting("Server")+"'")
            cur = conn.cursor()
        except:
            api.devlog ("Error Connection database")
            return
        
        cur=self._doSql(cur,"select * from hosts inner join workspaces ON (hosts.workspace_id=workspaces.id) where workspaces.name like '"+ self.getSetting("Wordspace")+"';")
        if cur is None:
            return
        
                       
        self.path=self.data_path + "/"+api.getActiveWorkspace().name+ "_metasploit_last"
        
        
                              
                                                                                         
        
        if os.path.isfile(self.path):
            f=open(self.path,"r")
            self._sdate=f.readline()
            f.close

        
                        
                                                                                                                                                                                                                                                                                                              
        for h in cur.fetchall():
            h_id = self.createAndAddHost(str(h[2]), str(h[7]))
            
            
            if self._isIPV4(str(h[2])):
                i_id = self.createAndAddInterface(h_id, str(h[2]),
                                                  mac=str(h[3]),
                                                  ipv4_address=str(h[2]),
                                                  hostname_resolution=str(h[5])
                                                  )
            else:
                i_id = self.createAndAddInterface(h_id, str(h[2]),
                                                  mac=str(h[3]),
                                                  ipv6_address=str(h[2]),
                                                  hostname_resolution=str(h[5])
                                                  )                
            
            
                                       
            self._checkDate(str(h[13]))
            
                                   
                                                                                                
            cur=self._doSql(cur,"select * from vulns where host_id="+str(h[0])+" and service_id is null"+ self._mwhere +";")
            if cur is None:
                return

            for v in cur.fetchall():
                self._checkDate(str(v[5]))
                
                                                                      

                             
                                                                                                                        
                cur=self._doSql(cur,"select * from vulns_refs inner join refs ON (vulns_refs.id=refs.id) where vulns_refs.vuln_id="+ str(v[0])+";")
                if cur is None:
                    return
                
                refs=[]
                for r in cur.fetchall():
                    self._checkDate(str(r[5]))
                    refs.append(r[6])


                self.createAndAddVulnToHost(h_id,str(v[4]),str(v[6]),refs)

                                     
                                                                                                                        
            cur=self._doSql(cur,"select * from notes where host_id="+str(h[0])+" and service_id is null"+ self._mwhere +";")
            if cur is None:
                return

            for n in cur.fetchall():
                self._checkDate(str(n[6]))
                self.createAndAddNoteToHost(h_id,str(n[2]),str(n[9]))

                                           
                                                                                            
            cur=self._doSql(cur,"select * from services where host_id="+str(h[0]))
            if cur is None:
                return
        
            for s in cur.fetchall():
                self._checkDate(str(s[7]))
                s_id = self.createAndAddServiceToInterface(h_id,i_id,
                                                    name=str(s[6]),
                                                    ports=[str(s[3])],
                                                    protocol=str(s[4]),
                                                    status=str(s[5]),
                                                    description=str(s[8]),
                                                    version=str(s[8]),
                                                    )
                
                                                  
                                                                                                                           
                cur=self._doSql(cur,"select * from creds where service_id="+str(s[0])+ self._mwhere +";")
                creds=[]
                if cur is None:
                    return
                for c in cur.fetchall():
                    self._checkDate(str(c[3]))
                    self.createAndAddCredToService(h_id,s_id,c[4],c[5])
                                                                           
                  
                                                                    
                
                                                 
                                                                                   
                                                                                 
                cur=self._doSql(cur,"select * from vulns where host_id="+str(h[0])+" and service_id="+str(s[0])+ self._mwhere +";")
                if cur is None:
                    return

                for v in cur.fetchall():
                    self._checkDate(str(v[5]))

                                 
                                                                                                                            
                    cur=self._doSql(cur,"select * from vulns_refs inner join refs ON (vulns_refs.id=refs.id) where vulns_refs.vuln_id="+ str(v[0])+";")
                    if cur is None:
                        return
                    
                    refs=[]
                    for r in cur.fetchall():
                        self._checkDate(str(r[5]))
                        refs.append(r[6])
                        
                    self.createAndAddVulnToService(h_id,s_id,
                                                   name=str(v[4]),
                                                   desc=str(v[6]),ref=refs)
                         
                             
                                                                                                                                                                                                                                                                                                                                       
                                                                  
                mwhere=re.sub("updated_at","web_vulns.updated_at",self._mwhere)
                cur=self._doSql(cur,"select * from web_vulns INNER JOIN web_sites ON (web_vulns.web_site_id=web_sites.id) INNER JOIN web_vuln_category_metasploits as category ON (web_vulns.category_id=category.id) where web_sites.service_id="+str(s[0])+ mwhere +";")
                for v in cur.fetchall():
                    self._checkDate(str(v[3]))
                    self.createAndAddVulnWebToService(h_id,s_id, name=str(v[28]), desc=str(v[29]), website=str(v[24]),
                                                   path=str(v[4]),request=str(v[15]), method=str(v[5]),pname=str(v[7]),
                                                   params=str(v[6]),query=str(v[10])
                                                   )

                                                                                 
                                             
                                                                                                                            
                cur=self._doSql(cur,"select * from notes where host_id="+str(h[0])+" and service_id="+str(s[0])+ self._mwhere)
                if cur is None:
                    return
                
                for n in cur.fetchall():
                    self._checkDate(str(n[6]))
                    self.createAndAddNoteToService(h_id,s_id,str(n[2]),str(n[9]))
                    
                         
                cur=self._doSql(cur,"select * from web_sites where service_id="+str(s[0])+ self._mwhere)
                for w in cur.fetchall():
                    self._checkDate(str(w[3]))
                    n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                    n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,str(w[4]),"")
                
        cur.close()
        conn.close()
        
    def _doSql(self,db,sql):
        try:
            api.devlog("SQL:" + sql)
            db.execute(sql)
        except Exception, e:
            api.devlog ("Error SQL[" + e.pgcode+"] - " + e.pgerror)
            return None
        
        return db
        
    def _checkDate(self,rowdate):
        
        mret=True                              
        msave=True                
        
        if not self._lsdate:                
                                         
            if self._sdate:                     
                self._lsdate=self._sdate                                       
            else:
                self._lsdate=rowdate                                      

                                                           
        if self._cdate(self._lsdate,rowdate):
            msave=False
        
        if self._sdate:
            self._mwhere =" and updated_at > to_timestamp('"+self._sdate+"','YYYY-MM-DD HH24:MI:SS.US');"
                                                    
                                                      
                
        if msave:
            try:
                f=open(self.path,"w")
                f.write(rowdate)
                f.close()
                self._lsdate=rowdate
            except:
                api.devlog ("Can't save metasploit lastupdate file")
                return
        
        return mret
    
    def _cdate(self, date1,date2):
                                                  
        mdate=time.strptime(date1.split(".")[0],"%Y-%m-%d %H:%M:%S")
        mdate2=time.strptime(date2.split(".")[0],"%Y-%m-%d %H:%M:%S")
        if mdate>mdate2:
            return True
        else:
            return False

    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False
    
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return MetasploitOnPlugin()

if __name__ == '__main__':
    parser = MetasploitOnXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = dotnessus_v2
# dotnessus_v2.py
# Python module to deal with Nessus .nessus (v2) files
# http://code.google.com/p/pynessus/
#
# Copyright (C) 2010 Dustin Seibel
#
# GNU General Public Licence (GPL)
# 
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA
#
# 2011-03-12:	0.1.1: Initial version.
import sys
import re
import xml.etree.ElementTree as ET
from datetime import datetime
from StringIO import StringIO
from dateutil.parser import parse

# List all nodes in a ReportItem object that can have multiple values
MULTI_VALUED_ATTS = [
'cve',
'bid',
'xref',
]

# HOST_(START|END) date format
HOST_DATE_FORMAT = '%a %b %d %H:%M:%S %Y'

# Regex defs
re_ip = re.compile('\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}')
re_wmi_ip = re.compile('IPAddress/IPSubnet.*?(?P<value>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})', re.I)
re_wmi_man = re.compile('Computer Manufacturer : (?P<manufacturer>.*?)\n.*?Computer Model : (?P<model>.*?)\n.*?Computer Memory : (?P<memory>\d+)\s', re.I|re.M|re.S)
re_shares = re.compile('- (?P<value>.*?)\n', re.I|re.M|re.S)
re_local_admins = re.compile('- (?P<value>.*?)\s\(', re.I|re.M|re.S)
re_wsus = re.compile('WUServer: (?P<wsus_server>.*?)\n.*?AUOptions: (?P<wsus_auoption>.*?)\n.*?Detect LastSuccessTime: (?P<wsus_lastdetect>.*?)\n.*?Download LastSuccessTime: (?P<wsus_lastdownload>.*?)\n.*?Install LastSuccessTime: (?P<wsus_lastinstall>.*?)\n.*?RebootRequired: (?P<wsus_rebootneeded>.*?)\n.*?ServiceStatus: (?P<wsus_auenabled>.*?)(\n|$)', re.I|re.M|re.S)
re_unix_memory = re.compile('Total memory: (?P<memory>\d+)\s', re.I)
re_unix_model = re.compile('Serial Number\s+: (?P<serial>.*?)\s.*?\nProduct Name\s+: (?P<model>.*?)(\n|$)', re.I|re.M)
re_unix_cpu = re.compile('Current Speed\s+: (?P<cpu_speed>.*?)\s*\nManufacturer\s+: (?P<cpu_vendor>.*?)\s*\nFamily\s+: (?P<cpu_model>.*?)\s*\nExternal Clock\s+: (?P<cpu_externalclock>.*?)\s*\nVersion\s+: (?P<cpu_version>.*?)\s*\nType\s+: (?P<cpu_type>.*?)($|\s*\n)', re.I|re.M)

# Plugin to regex map
# Format is plugin_id: (attribute_name, regex_object, attribute_to_parse, multi_valued)
REGEX_MAP = {
'24272': ('ips', re_wmi_ip, 'plugin_output', True),
'25203': ('ips', re_ip, 'plugin_output', True),
'24270': ('', re_wmi_man, 'description', False),
'10395': ('shares', re_shares, 'plugin_output', True),
'10902': ('local_admins', re_local_admins, 'plugin_output', True),
'10860': ('local_users', re_local_admins, 'plugin_output', True),
'55555': ('', re_wsus, 'description', False),
'45433': ('', re_unix_memory, 'plugin_output', False),
'35351': ('', re_unix_model, 'plugin_output', False),
'45432': ('', re_unix_cpu, 'plugin_output', False),
}

# Local IP list
LOCAL_IP_LIST = [
	'0.0.0.0',
	'127.0.0.1',
]

class Report(object):
	def __init__(self):
		self.name = None
		self.targets = []
		self.scan_start = None
		self.scan_end = None

	def parse(self, xml_file, from_string=False):
		"""Import .nessus file"""
		# Parse XML file
		if from_string:
			xml_file = StringIO(xml_file)
				
		# Iterate through each host scanned and create objects for each
		for event, elem in ET.iterparse(xml_file):
			
			# Grab the report name from the Report element
			if event == 'end' and elem.tag == 'Report':
				self.name = elem.attrib.get('name')
				continue

			# Only process ReportHost elements
			elif event == 'end' and elem.tag != 'ReportHost':
				continue

			rh_obj = ReportHost(elem)
			if rh_obj:
				self.targets.append(rh_obj)

				# Update Report dates
				if not self.scan_start:
					self.scan_start = rh_obj.host_start
				if not self.scan_end:
					self.scan_end = rh_obj.host_end
				if rh_obj.get('host_start'):
					if rh_obj.host_start < self.scan_start:
						self.scan_start = rh_obj.host_start
				if rh_obj.host_end > self.scan_end:
					self.scan_end = rh_obj.host_end

	def __repr__(self):
		return "<Report: %s>" % self.name

	def get_target(self, name):
		"""Returns a target object given a name"""
		for t in self.targets:
			if name.lower() == t.name.lower():
				return t

class ReportHost(object):
	def __init__(self, xml_report_host):
		self.name = None
		self.dead = False
		self.vulns = []

		# Do a check to make sure it's well formed
		# ...

		# Get ReportHost name
		self.name = xml_report_host.attrib.get('name')

		# Get HostProperties tags
		for n in xml_report_host.findall('HostProperties/tag'):
			setattr(self, n.attrib.get('name'), n.text)

		# Convert scan dates and check for dead status
		if self.get('HOST_START'):
			self.host_start = parse(self.get('HOST_START'))
			#self.host_start = datetime.strptime(self.get('HOST_START'), HOST_DATE_FORMAT)
		else:
			self.dead = True
		self.host_end = self.get('HOST_END')
		#self.host_end = datetime.strptime(self.get('HOST_END'), HOST_DATE_FORMAT)

		# Get all ReportItems
		for ri in xml_report_host.findall('ReportItem'):
			ri_obj = ReportItem(ri)
			if ri_obj:
				self.vulns.append(ri_obj)
		xml_report_host.clear()

		# Do an additional check for deadness
		for v in self.find_vuln(plugin_id='10180'):
			if 'dead' in str(v.get('plugin_output')):
				self.dead = True

		# Parse additional fields into host attributes
		for plugin_id in REGEX_MAP:
			att, regex, dest_att, multi = REGEX_MAP[plugin_id]
			vulns = self.find_vuln(plugin_id=plugin_id)

			# If multi flag is set, store results in a dict
			if multi:
				results = []

			# Grab all plugins
			for v in vulns:
				if multi:
					setattr(self, att, regex.findall(v.get(dest_att)))
				else:
					plugin_output = v.get(dest_att)
					if not plugin_output:
						continue

					res = regex.search(v.get(dest_att))
					if not res:
						continue

					# Check to see if named fields were given
					if res.groupdict():
						# Store each named field as an attribute
						for k, v in res.groupdict().iteritems():
							setattr(self, k, v)

					# No named fields, just grab whatever matched
					else:
						setattr(self, att, res.group())
		
	def __repr__(self):
		return "<ReportHost: %s>" % self.name

	def get(self, attr):
		"""Returns attribute value if it exists"""
		try:
			return getattr(self, attr)
		except AttributeError:
			return None

	def find_vuln(self, **kwargs):
		"""Find a ReportItem given the search params"""
		results = []
		
		# Iterate through preferences
		for r in self.vulns:
			match = True
			# If one of the search criteria doesn't match, set the flag
			for k in kwargs:
				if kwargs.get(k) != r.get(k):
					match = False

			# If it's a match, add it to results
			if match:
				results.append(r)
		return results

	def get_ips(self, exclude_local=True):
		"""Return a list of IPs for host"""
		ip_list = set()
		if re_ip.search(self.name):
			ip_list.add(self.name)
		if self.get('host-ip'):
			ip_list.add(self.get('host-ip'))
		if self.get('ips'):
			ip_list.update(self.ips)

		# If exclude_local is set, remove local IPs from list
		if exclude_local:
			for i in LOCAL_IP_LIST:
				if i in ip_list:
					ip_list.remove(i)

		return list(ip_list)


	def get_open_ports(self):
		"""Returns a dict of open ports found"""
		results = {}

		# Fetch results
		vulns = self.find_vuln(plugin_id='0')

		# For each port, put it in a dict
		for v in vulns:
			proto = v.get('protocol')
			port = v.get('port')
			if proto not in results:
				results[proto] = []
			results[proto].append(port)
		return results

	def get_name(self):
		"""Returns a friendly name for host"""
		if re_ip.search(self.name):
			if self.get('netbios-name'):
				return self.get('netbios-name').lower()
			elif self.get('host-fqdn'):
				return self.get('host-fqdn').lower()
			else:
				return self.name
		else:
			return self.name

class ReportItem(object):
	def __init__(self, xml_report_item):
		# Make sure object is well formed
		# ...

		# Get ReportItem attributes
		self.port = xml_report_item.attrib.get('port')
		self.svc_name = xml_report_item.attrib.get('svc_name')
		self.protocol = xml_report_item.attrib.get('protocol')
		self.severity = xml_report_item.attrib.get('severity')
		self.plugin_id = xml_report_item.attrib.get('pluginID')
		self.plugin_name = xml_report_item.attrib.get('pluginName')
		self.plugin_family = xml_report_item.attrib.get('pluginFamily')

		# Create multi-valued atts
		for m in MULTI_VALUED_ATTS:
			setattr(self, m, list())

		# Get optional nodes
		for n in xml_report_item.getchildren():
			# If it's a multi-valued att, append to list
			if n.tag in MULTI_VALUED_ATTS:
				v = getattr(self, n.tag)
				v.append(n.text.strip())
				setattr(self, n.tag, v)
				continue

			# If it's not a multi-valued att, store it as a string
			setattr(self, n.tag, n.text.strip())

		xml_report_item.clear()

	def __repr__(self):
		return "<ReportItem: %s/%s %s %s>" % (self.port, self.protocol, self.plugin_id, self.plugin_name)

	def get(self, attr):
		"""Returns attribute value if it exists"""
		try:
			return getattr(self, attr)
		except AttributeError:
			return None



########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os, socket
import pprint
import sys
import dotnessus_v2


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class NessusParser(object):
    """
    The objective of this class is to parse an xml file generated by the nessus tool.

    TODO: Handle errors.
    TODO: Test nessus output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param nessus_filepath A proper simple report generated by nessus
    """
    def __init__(self, output):
        lists = output.split("\r\n")
        i=0;
        self.items = []
        if re.search("Could not reach",output) is not None:
            self.fail = True
            return
            
        for line in lists:
            if i > 8:
                item = {'link' : line}
                self.items.append(item)
            i=i+1


class NessusPlugin(core.PluginBase):
    """
    Example plugin to parse nessus output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Nessus"
        self.name            = "Nessus XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "5.2.4"
        self.framework_version  = "1.0.1"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(nessus|sudo nessus|\.\/nessus).*?')
        self.host = None
        self.port = None
        self.protocol = None
        self.fail = None

        global current_path
        self.output_path = os.path.join(self.data_path,
                                             "nessus_output-%s.txt" % self._rid)
        
                                  

    def canParseCommandString(self, current_input):
        if self._command_regex.match(current_input.strip()):
            return True
        else:
            return False


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        p = dotnessus_v2.Report()
              
        try:
            p.parse(output, from_string=True)
        except Exception as e:
            print "Exception - %s" % e
        
        for t in p.targets:
            mac=""
            host=""
            ip=""

            if t.get('mac-address'):
                mac=t.get('mac-address')
            if t.get('host-fqdn'):
                host=t.get('host-fqdn')
            if t.get('host-ip'):
                ip=t.get('host-ip')
                

            h_id = self.createAndAddHost(ip,t.get('operating-system'))
            
            if self._isIPV4(ip):
                i_id = self.createAndAddInterface(h_id, ip, mac, ipv4_address=ip, hostname_resolution=host)
            else:
                i_id = self.createAndAddInterface(h_id, ip, mac, ipv6_address=ip, hostname_resolution=host)
            
            srv={}
            web=False
            for v in t.vulns:
                                                                                                   
                desc=""
                desc+=v.get('description') if v.get('description') else ""
                desc+="\nSolution: "+ v.get('solution') if v.get('solution') else ""
                desc+="\nOutput: "+v.get('plugin_output') if v.get('plugin_output') else ""
                ref=[]
                if v.get('cve'):
                    ref.append(", ".join(v.get('cve')))
                if v.get('bid'):
                    ref.append(", ".join(v.get('bid')))
                if v.get('xref'):
                    ref.append(", ".join(v.get('xref')))
                if v.get('svc_name') == "general":
                    v_id = self.createAndAddVulnToHost(h_id, v.get('plugin_name'),
                                                   desc,ref,severity=v.get('severity'))
                else:

                    s_id = self.createAndAddServiceToInterface(h_id, i_id, v.get('svc_name'),
                                                   v.get('protocol'), 
                                                   ports = [str(v.get('port'))],
                                                   status = "open")
                    
                    web=True if re.search(r'^(www|http)',v.get('svc_name')) else False
                    if srv.has_key(v.get('svc_name')) == False:
                        srv[v.get('svc_name')]=1
                        if web:
                            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,host,"")
                    
                    if web:
                        v_id = self.createAndAddVulnWebToService(h_id, s_id, v.get('plugin_name'),
                                                desc,website=host, severity=v.get('severity'),ref=ref)
                    else:
                        v_id = self.createAndAddVulnToService(h_id, s_id, v.get('plugin_name'),
                                                       desc,
                                                       severity=v.get('severity'),ref = ref)
                        
    
    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

    def processCommandString(self, username, current_path, command_string):
        return None
    
    def setHost(self):
        pass

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

def createPlugin():
    return NessusPlugin()

if __name__ == '__main__':
    parser = NessusParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = pynessus
# pynessus.py
# Python module to interact with a Nessus 4.x scanner via XMLRPC.
# http://code.google.com/p/pynessus/
#
# Copyright (C) 2010 Dustin Seibel
#
# GNU General Public Licence (GPL)
# 
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA
#
# 2010-08-12:	0.1.0: Initial version.
# 2011-03-12:	0.2.1: Added a bunch of methods and robustified everything.
import sys
import urllib2
from urlparse import urljoin
from urllib import quote
import xml.etree.ElementTree as ET
import re
import datetime
import os
from random import randint

# Regex defs
re_unix_timestamp = re.compile('^\d{10}$')
re_unauthorized = re.compile('<title>200 Unauthorized</title>')

TOKEN_FILE = '.nessus_token'

# Plugin multi-value tags
PLUGIN_MULTI_VAL = [
	'bid',
	'xref',
	'cve',
]

class NessusServer(object):
	def __init__(self, server, port, username, password, verbose=False):
		self.server = server
		self.port = port
		self.username = username
		self.password = password
		self.base_url = 'https://%s:%s' % (self.server, self.port)
		self.verbose = verbose
		self.launched_scans = {}

		# Force urllib2 to not use a proxy
		hand = urllib2.ProxyHandler({})
		opener = urllib2.build_opener(hand)
		urllib2.install_opener(opener)

		self.login()

		# If token file exists, use it
		#self.token = get_token_file()
		#if not self.check_auth():
		#	self.login()
		#	success = create_token_file(self.token)
		#	# if not success...


	def login(self):
		"""Login to server"""
		# If token file exists, try to use it
		self.token = get_token_file()
		if self.check_auth():
			return True

		# Make call to server
		data = make_args(login=self.username, password=quote(self.password))
		resp = self._call('login', data)
		if self.verbose:
			print resp

		# Parse token
		seq, status, parsed = parse_reply(resp, ['token'])
		if 'token' in parsed:
			self.token = parsed['token']
		else:
			return False

		# Store it on the filesystem
		success = create_token_file(self.token)
		if success:
			return True
		else:
			return False

	def logout(self):
		"""Logout from server"""
		data = make_args(token=self.token)
		resp = self._call('logout', data)
		self.token = None

	def check_auth(self):
		"""Does a quick check to make sure token is still valid"""
		if not self.token:
			return False
		data = make_args(token=self.token)
		resp = self._call('scan/list', data)
		if not resp:
			return False
		elif re_unauthorized.search(resp):
			return False
		else:
			return True

	def download_plugins(self):
		"""Downloads all plugins"""
		data = make_args(token=self.token)
		resp = self._call('plugins/descriptions', data)

		# Get parsed data
		keys = []
		seq, status, parsed = parse_reply(resp, keys, uniq='pluginID', start_node='pluginsList')
		return parsed

	def download_report(self, uuid, v1=False):
		"""Retrieves a report"""
		if v1:
			data = make_args(token=self.token, report=uuid, v1='true')
		else:
			data = make_args(token=self.token, report=uuid)
		url = urljoin(self.base_url, 'file/report/download/?%s' % data)
		req = urllib2.urlopen(url) 
		resp = req.read()
		if not check_auth(resp):
			print >> sys.stderr, "Unauthorized"
			return None
		return resp

	def launch_scan(self, name, policy_id, target_list):
		"""Launches scan. Returns UUID of scan."""
		arg_targets = quote('\n'.join(target_list))
		data = make_args(token=self.token, scan_name=quote(name), policy_id=policy_id, target=arg_targets)
		resp = self._call('/scan/new', data)
		if self.verbose:
			print resp

		# Get parsed data
		keys = ['uuid', 'owner', 'start_time', 'scan_name']
		seq, status, parsed = parse_reply(resp, keys)
		self.launched_scans[parsed['uuid']] = parsed
		return parsed['uuid']

	def list_plugins(self):
		"""List plugins"""
		data = make_args(token=self.token)
		resp = _call('plugins/list', data)

	def list_policies(self):
		"""List policies"""
		data = make_args(token=self.token)
		resp = self._call('policy/list', data)

		# Get parsed data
		seq, status, parsed = parse_reply(resp, ['policyName', 'policyOwner', 'policyComments'], uniq='policyID')
		return parsed

	def get_policy_id(self, policy_name):
		"""Attempts to grab the policy ID for a name"""
		pols = self.list_policies()
		for k, v in pols.iteritems():
			if v.get('policyName').lower() == policy_name:
				return k

	def list_reports(self):
		"""List reports"""
		data = make_args(token=self.token)
		resp = self._call('report/list', data)

		# Get parsed data
		seq, status, parsed = parse_reply(resp, ['name', 'readableName', 'timestamp', 'status'], uniq='name')
		return parsed

	def list_scans(self):
		"""List scans"""
		data = make_args(token=self.token)
		resp = self._call('scan/list', data)

		# Get parsed data
		keys = ['owner', 'start_time', 'completion_current', 'completion_total']
		seq, status, parsed = parse_reply(resp, keys, uniq='uuid', start_node='scans/scanList')
		return parsed

	def list_hosts(self, report_uuid):
		"""List hosts for a given report"""
		data = make_args(token=self.token, report=report_uuid)
		resp = self._call('report/hosts', data)

		# Get parsed data
		keys = ['hostname', 'severity']
		seq, status, parsed = parse_reply(resp, keys, uniq='hostname', start_node='hostList')
		return parsed

	def list_ports(self, report_uuid, hostname):
		"""List hosts for a given report"""
		data = make_args(token=self.token, report=report_uuid, hostname=hostname)
		resp = self._call('report/ports', data)
		#return resp

		# Get parsed data
		seq, status, parsed = parse_ports(resp)
		return parsed

	def list_detail(self, report_uuid, hostname, protocol, port):
		"""List details for a given host/protocol/port"""
		data = make_args(token=self.token, report=report_uuid, hostname=hostname, protocol=protocol, port=port)
		resp = self._call('report/detail', data)
		#return resp

		# Get parsed data
		seq, status, parsed = parse_ports(resp)
		return parsed

	def list_tags(self, report_uuid, hostname):
		"""List hosts for a given report"""
		data = make_args(token=self.token, report=report_uuid, hostname=hostname)
		resp = self._call('report/tags', data)
		#return resp

		# Get parsed data
		seq, status, tags = parse_tags(resp)
		return tags

	## Template methods
	def create_template(self, name, policy_id, target_list):
		"""Creates a new scan template. Returns """
		arg_targets = quote('\n'.join(target_list))
		data = make_args(token=self.token, template_name=quote(name), policy_id=policy_id, target=arg_targets)
		resp = self._call('/scan/template/new', data)

	def edit_template(self, template_id, name, policy_id, target_list):
		"""Edits an existing scan template."""
		arg_targets = quote('\n'.join(target_list))
		data = make_args(token=self.token, template=template_id, template_name=quote(name), policy_id=policy_id, target=arg_targets)
		resp = self._call('/scan/template/edit', data)

	def list_templates(self):
		"""List templates"""
		data = make_args(token=self.token)
		resp = self._call('scan/list', data)

		# Get parsed data
		keys = ['policy_id', 'readableName', 'owner', 'startTime']
		seq, status, parsed = parse_reply(resp, keys, uniq='name', start_node='templates')
		return parsed

	def _call(self, func_url, args):
		url = urljoin(self.base_url, func_url)
		if self.verbose:
			print "URL: '%s'" % url
			print "POST: '%s'" % args
		req = urllib2.urlopen(url, args) 
		resp = req.read()
		if not check_auth(resp):
			print >> sys.stderr, "200 Unauthorized"
			return resp
		return resp

def check_auth(resp_str):
	"""Checks for an unauthorized message in HTTP response."""
	if re_unauthorized.search(resp_str):
		return False
	else:
		return True

def create_token_file(token, token_file=TOKEN_FILE):
	"""Creates token file"""
	if not token:
		return False
	# Write to file
	try:
		fout = open(token_file, 'w')
	except IOError:
		return False
	fout.write(token)
	fout.close()

	# Confirm the file was created and has the right token
	new_token = get_token_file(token_file)
	if new_token != token:
		return False
	else:
		return True

def get_token_file(token_file=TOKEN_FILE):
	"""Checks token from file"""
	if not os.path.isfile(token_file):
		return False
	fin = open(token_file, 'r')
	token = fin.read()
	fin.close()
	return token
		
def convert_date(unix_timestamp):
	"""Converts UNIX timestamp to a datetime object"""
	#try:
	#	return datetime.datetime.fromtimestamp(float(unix_timestamp))
	#except Exception:
	#	return unix_timestamp
	return datetime.datetime.fromtimestamp(float(unix_timestamp))

def parse_reply(xml_string, key_list, start_node=None, uniq=None):
	"""Gets all key/value pairs from XML"""
	ROOT_NODES = ['seq', 'status', 'contents']
	if not xml_string:
		return (0, 'Not a valid string', {})

	# Parse xml
	try:
		xml = ET.fromstring(xml_string)
	except ET.ExpatError:
		return (0, 'Cannot parse XML', {})

	# Make sure it looks like what we expect it to be
	if [t.tag for t in xml.getchildren()] != ROOT_NODES:
		return (0, 'XML not formatted correctly', {})

	# Get seq and status
	seq = xml.findtext('seq')
	status = xml.findtext('status')

	# If start node was given, append it to contents node
	if start_node:
		start_node = 'contents/%s' % start_node
	else:
		start_node = 'contents'
	if not xml.find(start_node):
		return (seq, 'start_node not found', {})

	# If a unique value was given, make sure it is a valid tag
	if uniq:
		found = False
		for x in xml.find(start_node).getiterator():
			if x.tag == uniq:
				found = True
				break
		if not found:
			return (seq, 'uniq not a valid tag', {})

	# Parse keys from contents
	d = {}
	for x in xml.find(start_node).getiterator():
		if uniq:
			# If tag is a unique field, start a new dict
			if x.tag == uniq:
				d[x.text] = {}
				k = x.text

			# Store key/value pair if tag is in key list or if no key list was given
			if not x.text:
				continue
			if ((x.tag in key_list) or (not key_list)) and x.text.strip():
				# If the tag has the word time and the value is a UNIX timestamp, convert it
				if 'time' in x.tag and re_unix_timestamp.search(x.text):
					d[k][x.tag] = convert_date(x.text)
				else:
					# Check to see if this is multi-valued
					if x.tag in PLUGIN_MULTI_VAL:
						if x.tag in d[k]:
							d[k][x.tag].append(x.text)
						else:
							d[k][x.tag] = [x.text]
					else:
						d[k][x.tag] = x.text

		else:
			# Store key/value pair if tag is in key list
			if not x.text:
				continue
			if ((x.tag in key_list) or (not key_list)) and x.text.strip():
				# If the tag has the word time and the value is a UNIX timestamp, convert it
				if 'time' in x.tag and re_unix_timestamp.search(x.text):
					d[x.tag] = convert_date(x.text)
				else:
					d[x.tag] = x.text
	return (seq, status, d)

def parse_reply_orig(xml_string, key_list, start_node=None, uniq=None):
	"""Gets all key/value pairs from XML"""
	ROOT_NODES = ['seq', 'status', 'contents']
	if not xml_string:
		return (0, 'Not a valid string', {})

	# Parse xml
	try:
		xml = ET.fromstring(xml_string)
	except ET.ExpatError:
		return (0, 'Cannot parse XML', {})

	# Make sure it looks like what we expect it to be
	if [t.tag for t in xml.getchildren()] != ROOT_NODES:
		return (0, 'XML not formatted correctly', {})

	# Get seq and status
	seq = xml.findtext('seq')
	status = xml.findtext('status')

	# If start node was given, append it to contents node
	if start_node:
		start_node = 'contents/%s' % start_node
	else:
		start_node = 'contents'
	if not xml.find(start_node):
		return (seq, 'start_node not found', {})

	# If a unique value was given, make sure it is a valid tag
	if uniq:
		found = False
		for x in xml.find(start_node).getiterator():
			if x.tag == uniq:
				found = True
				break
		if not found:
			return (seq, 'uniq not a valid tag', {})

	# Parse keys from contents
	d = {}
	for x in xml.find(start_node).getiterator():
		if uniq:
			# If tag is a unique field, start a new dict
			if x.tag == uniq:
				d[x.text] = {}
				k = x.text

			# Store key/value pair if tag is in key list
			if x.tag in key_list:
				# If the tag has the word time and the value is a UNIX timestamp, convert it
				if 'time' in x.tag and re_unix_timestamp.search(x.text):
					d[k][x.tag] = convert_date(x.text)
				else:
					d[k][x.tag] = x.text

		else:
			# Store key/value pair if tag is in key list
			if x.tag in key_list:
				# If the tag has the word time and the value is a UNIX timestamp, convert it
				if 'time' in x.tag and re_unix_timestamp.search(x.text):
					d[x.tag] = convert_date(x.text)
				else:
					d[x.tag] = x.text
	return (seq, status, d)

def parse_ports(xml_string):
	"""Parses ports from report/ports"""
	ROOT_NODES = ['seq', 'status', 'contents']
	if not xml_string:
		return (0, 'Not a valid string', {})

	# Parse xml
	try:
		xml = ET.fromstring(xml_string)
	except ET.ExpatError:
		return (0, 'Cannot parse XML', {})

	# Make sure it looks like what we expect it to be
	if [t.tag for t in xml.getchildren()] != ROOT_NODES:
		return (0, 'XML not formatted correctly', {})

	# Get seq and status
	seq = xml.findtext('seq')
	status = xml.findtext('status')

	# Parse ports
	d = {'tcp': {}, 'udp': {}, 'icmp': {}}
	for t in xml.findall('contents/portList/port'):
		port_d = {}
		prot = t.findtext('protocol')
		num = t.findtext('portNum')

		# Get additional attributes
		port_d['severity'] = t.findtext('severity')
		port_d['svcName'] = t.findtext('svcName')

		d[prot][num] = port_d
	return (seq, status, d)

def parse_tags(xml_string):
	"""Parses tags from report/tags"""
	ROOT_NODES = ['seq', 'status', 'contents']
	if not xml_string:
		return (0, 'Not a valid string', {})

	# Parse xml
	try:
		xml = ET.fromstring(xml_string)
	except ET.ExpatError:
		return (0, 'Cannot parse XML', {})

	# Make sure it looks like what we expect it to be
	if [t.tag for t in xml.getchildren()] != ROOT_NODES:
		return (0, 'XML not formatted correctly', {})

	# Get seq and status
	seq = xml.findtext('seq')
	status = xml.findtext('status')

	# Parse tags
	d = {}
	for t in xml.findall('contents/tags/tag'):
		k = t.findtext('name')
		v = t.findtext('value')
		d[k] = v
	return (seq, status, d)

def make_args(**kwargs):
	"""Returns arg list suitable for GET or POST requests"""
	args = []
	for k in kwargs:
		args.append('%s=%s' % (k, str(kwargs[k])))

	# Add a random number
	seq = randint(1, 1000)
	args.append('seq=%d' % seq)
	
	return '&'.join(args)

def zerome(string):
	# taken from http://www.codexon.com/posts/clearing-passwords-in-memory-with-python
	# to be used to secure the password in memory
	# find the header size with a dummy string
	temp = "finding offset"
	header = ctypes.string_at(id(temp), sys.getsizeof(temp)).find(temp)
 
	location = id(string) + header
	size = sys.getsizeof(string) - header
 
	# Check platform
	if 'windows' in sys.platform.lower():
		memset = ctypes.cdll.msvcrt.memset
	else:
		# For Linux, use the following. Change the 6 to whatever it is on your computer.
		memset = ctypes.CDLL("libc.so.6").memset
 
	print "Clearing 0x%08x size %i bytes" % (location, size)
 
	memset(location, 0, size)

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import sys
import socket,urllib

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION

ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"
    
class NetsparkerXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the netsparker tool.

    TODO: Handle errors.
    TODO: Test netsparker output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param netsparker_xml_filepath A proper xml generated by netsparker
    """
    def __init__(self, xml_output):
        self.filepath = xml_output
        
        tree = self.parse_xml(xml_output)
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            self.devlog("SyntaxError: %s. %s" % (err, xml_output))
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
        for node in tree.findall("vulnerability"):
            yield Item(node)

                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an netsparker xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.url = self.get_text_from_subnode("url")

        host = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", self.url)
                            
        self.protocol = host.group(1)
        self.hostname = host.group(4)
        self.port=80

        if self.protocol == 'https':
            self.port=443        
        if host.group(11) is not None:
            self.port = host.group(11)

        
        self.name = self.get_text_from_subnode("type")
        self.severity = self.get_text_from_subnode("severity")
        self.certainty = self.get_text_from_subnode("certainty")
        self.method = self.get_text_from_subnode("vulnerableparametertype")
        self.param = self.get_text_from_subnode("vulnerableparameter")
        self.paramval = self.get_text_from_subnode("vulnerableparametervalue")
        self.request = self.get_text_from_subnode("rawrequest")
        self.response = self.get_text_from_subnode("rawresponse")
        if self.response:
            self.response=self.response.encode("base64")[:-1]
        if self.request:
            self.request=self.request.encode("base64")[:-1]

        self.kvulns=[]
        for v in self.node.findall("knownvulnerabilities/knownvulnerability"):
            self.node = v
            self.kvulns.append(self.get_text_from_subnode("severity")+"-"+self.get_text_from_subnode("title"))
            

        self.extra=[]
        for v in item_node.findall("extrainformation/info"):
            self.extra.append(v.get('name')+ ":" +v.text)
        
        
        self.node = item_node
        self.node = item_node.find("classification")
        self.owasp=self.get_text_from_subnode("OWASP")
        self.wasc=self.get_text_from_subnode("WASC")
        self.cwe=self.get_text_from_subnode("CWE")
        self.capec=self.get_text_from_subnode("CAPEC")
        self.pci=self.get_text_from_subnode("PCI")
        self.pci2=self.get_text_from_subnode("PCI2")
        
        self.ref=[]
        if self.cwe:
            self.ref.append("CWE-"+self.cwe)
        if self.owasp:
            self.ref.append("OWASP-"+self.owasp)

        self.desc = ""
        self.desc += "\nKnowVulns: " + "\n".join(self.kvulns) if self.kvulns else ""
        self.desc += "\nWASC: " +self.wasc if self.wasc else ""
        self.desc += "\nPCI: " +self.pci if self.pci else ""
        self.desc += "\nPCI2: " +self.pci2 if self.pci2 else ""
        self.desc += "\nCAPEC: " +self.capec if self.capec else ""
        self.desc += "\nPARAM: " +self.param if self.param else ""
        self.desc += "\nPARAM VAL: " +repr(self.paramval) if self.paramval else ""
        self.desc += "\nExtra: " + "\n".join(self.extra) if self.extra else ""
        
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        if self.node:
            sub_node = self.node.find(subnode_xpath_expr)
            if sub_node is not None:
                return sub_node.text

        return None


class NetsparkerPlugin(core.PluginBase):
    """
    Example plugin to parse netsparker output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Netsparker"
        self.name            = "Netsparker XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "Netsparker 3.1.1.0"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo netsparker|\.\/netsparker).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "netsparker_output-%s.xml" % self._rid)

    def resolve(self,host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host
    
    def parseOutputString(self, output, debug = False):
        
                                                                                                  
        parser = NetsparkerXmlParser(output)
        first=True
        for i in parser.items:
            if first:
                ip = self.resolve(i.hostname)
                h_id = self.createAndAddHost(ip)
                i_id = self.createAndAddInterface(h_id, ip,ipv4_address=ip, hostname_resolution=i.hostname)
                
                s_id = self.createAndAddServiceToInterface(h_id, i_id, str(i.port),
                                                    str(i.protocol),
                                                    ports = [str(i.port)],
                                                    status = "open")
                
                n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,i.hostname,"")
                first=False
                
            v_id=self.createAndAddVulnWebToService(h_id, s_id,i.name,ref=i.ref,website=i.hostname,
                                                   severity=i.severity,desc=i.desc, path=i.url,method=i.method,
                                                   request=i.request, response=i.response,pname=i.param)
            
        del parser
        
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return NetsparkerPlugin()

if __name__ == '__main__':
    parser = NetsparkerXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class NexposeXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the nexpose tool.

    TODO: Handle errors.
    TODO: Test nexpose output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param nexpose_xml_filepath A proper xml generated by nexpose
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """       
        for node in tree.findall("devices/device"):
            yield Item(node)

                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an nexpose xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.ip = item_node.get('address')
        self.os = self.get_text_from_subnode("fingerprint/description")
            
        self.vulns=self.getResults(item_node)

        self.srv=[]
        
        for srv in item_node.findall("services/service"):
            item={}
            self.node=srv
            item['name']=srv.get('name')
            item['port']=srv.get('port')
            item['protocol']=srv.get('protocol')
            item['version']=self.get_text_from_subnode("fingerprint/description")
            item['vulns']=self.getResults(srv)
            self.srv.append(item)
            
    def getResults(self, tree):
        """
        :param tree:
        """
        for self.issues in tree.findall("vulnerabilities/vulnerability"):
            yield Results(self.issues)
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class Results():
    def __init__(self, issue_node):
        self.node = issue_node
        self.name=issue_node.get('id')
        self.ref=[]
        data=self.get_text_from_subnode("id/[@type='cve']")
        if data:
            self.ref.append(data)

        data=self.get_text_from_subnode("id/[@type='bid']")
        if data:
            self.ref.append("bid-"+data)

        data=self.get_text_from_subnode("id/[@type='osvdb']")
        if data:
            self.ref.append("osvdb-"+data)
        
        for v in issue_node.findall ("id/[@type='secunia']"):
            self.ref.append("secunia-"+v.text)

        for v in issue_node.findall ("id/[@type='url']"):
            self.ref.append("url-"+v.text)
            
        self.url=self.get_text_from_subnode("key")    
        

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class NexposePlugin(core.PluginBase):
    """
    Example plugin to parse nexpose output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Nexpose"
        self.name            = "Nexpose XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "Nexpose Enterprise 5.7.19"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo nexpose|\.\/nexpose).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "nexpose_output-%s.xml" % self._rid)

    def parseOutputString(self, output, debug = False):
        
                                                                                   
        parser = NexposeXmlParser(output)
        for item in parser.items:
            h_id = self.createAndAddHost(item.ip,item.os)
            i_id = self.createAndAddInterface(h_id, item.ip,ipv4_address=item.ip, hostname_resolution=item.ip)

            for v in item.vulns:
                v_id=self.createAndAddVulnToHost(h_id,v.name,ref=v.ref)
                
            for s in item.srv:
                web=False
                s_id = self.createAndAddServiceToInterface(h_id, i_id, s['name'],
                                                    s['protocol'],
                                                    ports = [str(s['port'])],
                                                    status = "open",
                                                    version=s['version'])
                for v in s['vulns']:
                    if v.url:
                        v_id=self.createAndAddVulnWebToService(h_id, s_id,v.name,ref=v.ref,website=item.ip,path=v.url)
                        if not web:
                            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,item.ip,"")
                            web=True
                    else:
                        v_id=self.createAndAddVulnToService(h_id, s_id,v.name,ref=v.ref)
        del parser
        
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return NexposePlugin()

if __name__ == '__main__':
    parser = NexposeXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Facundo de Guzmn", "Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class NiktoXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the nikto tool.

    TODO: Handle errors.
    TODO: Test nikto output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param nikto_xml_filepath A proper xml generated by nikto
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        
        if tree:
            self.hosts = [host for host in self.get_hosts(tree)]
        else:
            self.hosts = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_hosts(self, tree):
        """
        @return items A list of Host instances
        """
        for host_node in tree.findall('scandetails'):
            yield Host(host_node)
                


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item

    TODO: Consider evaluating the attributes lazily
    TODO: Write what's expected to be present in the nodes
    TODO: Refactor both Host and the Port clases?

    @param item_node A item_node taken from an nikto xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.id_nikto = self.node.get('id')
        
        self.osvdbid = ["BID-"+self.node.get('osvdbid')] if self.node.get('osvdbid') != "0" else []
        self.osvdblink = self.node.get('osvdbidlink')
        self.method = self.node.get('method')
        self.desc = self.get_text_from_subnode('description')
        self.uri = self.get_text_from_subnode('uri')
        self.namelink = self.get_text_from_subnode('namelink')
        self.iplink = self.get_text_from_subnode('iplink')

    
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

    def __str__(self):
        ports = []
        for port in self.ports:
            var = "    %s" % port
            ports.append(var)
        ports = "\n".join(ports)

        return "%s, %s, %s [%s], %s\n%s" % (self.hostnames, self.status,
                                           self.ipv4_address, self.mac_address, self.os, ports)

class Host(object):
    """
    An abstract representation of a Host

    @param host_node A host_node taken from an nmap xml tree
    """
    def __init__(self, host_node):
        self.node = host_node
        self.targetip = self.node.get('targetip')
        self.targethostname = self.node.get('targethostname')
        self.port = self.node.get('targetport')
        self.targetbanner = self.node.get('targetbanner')
        self.starttime = self.node.get('starttime')
        self.sitename = self.node.get('sitename')
        self.siteip = self.node.get('hostheader')
        self.items = [item for item in self.get_items()]
        
    def get_items(self):
        """
        @return items A list of Host instances
        """
        for item_node in self.node.findall('item'):
            yield Item(item_node)

    def __str__(self):
        ports = []
        for port in self.ports:
            var = "    %s" % port
            ports.append(var)
        ports = "\n".join(ports)

        return "%s, %s, %s [%s], %s\n%s" % (self.hostnames, self.status,
                                           self.ipv4_address, self.mac_address, self.os, ports)


class NiktoPlugin(core.PluginBase):
    """
    Example plugin to parse nikto output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Nikto"
        self.name            = "Nikto XML Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "2.1.5"
        self.options         = None
        self._current_output = None
        self.parent = None
        self._command_regex  = re.compile(r'^(sudo nikto|nikto|sudo nikto\.pl|nikto\.pl|perl nikto\.pl|\.\/nikto\.pl|\.\/nikto).*?')
        self._completition = {
                                "":"",
                                "-ask+":"Whether to ask about submitting updates",
                                "-Cgidirs+":'Scan these CGI dirs: "none", "all", or values like "/cgi/ /cgi-a/"',
                                "-config+":"Use this config file",
                                "-Display+":"Turn on/off display outputs:",
                                "-dbcheck":"Check database and other key files for syntax errors",
                                "-evasion+":"Encoding technique:",
                                "-Format+":"Save file (-o) format:",
                                "-Help":"Extended help information",
                                "-host+":"Target host",
                                "-IgnoreCode":"Ignore Codes--treat as negative responses",
                                "-id+":"Host authentication to use, format is id:pass or id:pass:realm",
                                "-key+":"Client certificate key file",
                                "-list-plugins":"List all available plugins, perform no testing",
                                "-maxtime+":"Maximum testing time per host",
                                "-mutate+":"Guess additional file names:",
                                "-mutate-options":"Provide information for mutates",
                                "-nointeractive":"Disables interactive features",
                                "-nolookup":"Disables DNS lookups",
                                "-nossl":"Disables the use of SSL",
                                "-no404":"Disables nikto attempting to guess a 404 page",
                                "-output+":"Write output to this file ('.' for auto-name)",
                                "-Pause+":"Pause between tests (seconds, integer or float)",
                                "-Plugins+":"List of plugins to run (default: ALL)",
                                "-port+":"Port to use (default 80)",
                                "-RSAcert+":"Client certificate file",
                                "-root+":"Prepend root value to all requests, format is /directory",
                                "-Save":"Save positive responses to this directory ('.' for auto-name)",
                                "-ssl":"Force ssl mode on port",
                                "-Tuning+":"Scan tuning:",
                                "-timeout+":"Timeout for requests (default 10 seconds)",
                                "-Userdbs":"Load only user databases, not the standard databases",
                                "-until":"Run until the specified time or duration",
                                "-update":"Update databases and plugins from CIRT.net",
                                "-useproxy":"Use the proxy defined in nikto.conf",
                                "-Version":"Print plugin and database versions",
                                "-vhost+":"Virtual host (for Host header)",
        }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "nikto_output-%s.xml" % self._rid)
                                  


    def parseOutputString(self, output, debug = False ):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = NiktoXmlParser(output)

        for host in parser.hosts:
    
                                                    
    
            h_id = self.createAndAddHost(host.targetip)
    
                                                                        
            i_id = self.createAndAddInterface(h_id, host.targetip, ipv4_address=host.targetip,hostname_resolution=host.targethostname)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, "http",
                                               "tcp",
                                               ports = [host.port],
                                               status = "open")
    
            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,host.targethostname,"")
    
            for item in host.items:
                v_id = self.createAndAddVulnWebToService(h_id, s_id,
                                                         name=item.desc, ref=item.osvdbid, website=host.targethostname,
                                                         method=item.method, path=item.namelink,query=item.uri)
        del parser

    xml_arg_re = re.compile(r"^.*(-output\s*[^\s]+).*$")

    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -oX parameter to get xml output to the command string that the
        user has set.
        """
        arg_match = self.xml_arg_re.match(command_string)


        if arg_match is None:
            return re.sub(r"(^.*?nikto(\.pl)?)",
                          r"\1 -output %s -Format XML" % self._output_file_path,
                          command_string)
        else:
            data=re.sub(" \-Format XML","",command_string)
            return re.sub(arg_match.group(1),
                          r"-output %s -Format XML" % self._output_file_path,
                          data)

    def setHost(self):
        pass


def createPlugin():
    return NiktoPlugin()

if __name__ == '__main__':
    parser = NiktoXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
                      
import re
import os
import sys
import random

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

class NmapXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the nmap tool.

    TODO: Handle errors.
    TODO: Test nmap output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param nmap_xml_filepath A proper xml generated by nmap
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)

        if tree:
            self.hosts = [host for host in self.get_hosts(tree)]
        else:
            self.hosts = []

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        # with open(filepath,"r") as f:
        #     try:
        #         tree = ET.fromstring(f.read())
        #     except SyntaxError, err:
        #         print "SyntaxError: %s. %s" % (err, filepath)
        #         return None

        #     return tree
        #import ipdb;ipdb.set_trace()
        return ET.fromstring(xml_output)

    def get_hosts(self, tree):
        """
        @return hosts A list of Host instances
        """
        for host_node in tree.findall('host'):
            yield Host(host_node)


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the host node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None

                 


class Host(object):
    """
    An abstract representation of a Host

    TODO: Consider evaluating the attributes lazily
    TODO: Write what's expected to be present in the nodes
    TODO: Refactor both Host and the Port clases?

    @param host_node A host_node taken from an nmap xml tree
    """
    def __init__(self, host_node):
        self.node = host_node

        self.hostnames = [hostname[0] for hostname in self.get_hostnames()]
        if len(self.hostnames) != 0:
            self.hostname = self.hostnames[0]
        else:
            self.hostname = 'unknown'
        
        self.hostnames=list(set(self.hostnames))
        self.status = self.get_status()
        self.ipv4_address = self.get_ipv4_address()
        self.ipv6_address = self.get_ipv6_address()
        self.mac_address = self.get_mac_address()
        self.os_guesses = [os_guess  for os_guess in self.get_os_guesses()]
        self.os = self.top_os_guess()
        self.ports = [port for port in self.get_ports()]
        self.vulns = [vuln for vuln in self.get_scripts()]
        if self.os != 'unknown':
            for p in self.ports:
                if p.service is not None:
                    if p.service.ostype:
                        self.os=p.service.ostype
                        break
            
                                 
    def get_hostnames(self):
        """
        Expects to find one or more '<hostname name="localhost.localdomain" type="PTR"/>'
        in the host node.

        @return A list of (hostname, hostname_type) or None
        """
        for hostname in self.node.findall('hostnames/hostname'):
            yield (hostname.attrib["name"],hostname.attrib["type"])

    def get_attrib_from_subnode(self, subnode_xpath_expr, attrib_name):
        """
        Finds a subnode in the host node and the retrieves a value from it

        @return An attribute value
        """
        return get_attrib_from_subnode(self.node, subnode_xpath_expr, attrib_name)

    def get_status(self):
        """
        Expects to find '<status state="up" reason="conn-refused"/>' in the node

        TODO: Use 'reason'

        @return An status or 'unknown'
        """
        status = self.get_attrib_from_subnode('status','state')
        return status if status else 'unknown'

    def get_ipv4_address(self):
        """
        Expects to find '<address addr="127.0.0.1" addrtype="ipv4"/>' in the node

        @return ip_address or 'unknown'
        """
        ip_address = self.get_attrib_from_subnode("address[@addrtype='ipv4']",'addr')
        return ip_address if ip_address else 'unknown'
    
    def get_ipv6_address(self):
        """
        Expects to find '<address addr="127.0.0.1" addrtype="ipv6"/>' in the node

        @return ip_address or 'unknown'
        """
        ip_address = self.get_attrib_from_subnode("address[@addrtype='ipv6']",'addr')
        return ip_address if ip_address else 'unknown'

    def get_mac_address(self):
        """
        Expects to find '<address addr="00:08:54:26:A9:E5" addrtype="mac" vendor="Netronix" />' in the node

        @return mac_address or 'unknown'
        """
        mac_address = self.get_attrib_from_subnode("address[@addrtype='mac']",'addr')
        return mac_address if mac_address else 'unknown'

    def get_os_guesses(self):
        """
        Expects to find '<os>..<osclass type="general purpose" vendor="Microsoft" osfamily="Windows" osgen="2003" accuracy="96" />..</os>' in the node

        @return A list of (os_vendor_family_gen, accuracy)
        """
        osclasses=self.node.findall('os/osclass')
        if osclasses == []:
            osclasses=self.node.findall('os/osmatch/osclass')
        
        for osclass in osclasses:
            os_vendor = osclass.get("vendor")
            os_family = osclass.get("osfamily")
            os_gen = osclass.get("osgen")
            accuracy = osclass.get("accuracy")

            yield ("%s %s %s" % (os_vendor, os_family, os_gen), accuracy)
    def get_scripts(self):
        """
        Expects to find a scripts in the node.
        """
        for s in self.node.findall('hostscript/script'):
            yield Script(s)
    def top_os_guess(self):
        """
        @return The most accurate os_guess_id or 'unknown'.
        """
        return self.os_guesses[0][0] if len(self.os_guesses) != 0 else 'unknown'

    def get_ports(self):
        """
        Expects to find one or more '<port protocol="tcp" portid="631">...</port>' in the node.

        @return A list of Port instances or None
        """
        for port in self.node.findall('ports/port'):
            yield Port(port)

    def is_up(self):
        """
        Returns True if the host is up else False.
        """
        if self.status == 'up':
            return True
        else:
            return False

    def __str__(self):
        ports = []
        for port in self.ports:
            var = "    %s" % port
            ports.append(var)
        ports = "\n".join(ports)

        return "%s, %s, %s [%s], %s\n%s" % (self.hostnames, self.status,
                                           self.ipv4_address, self.mac_address, self.os, ports)


class Port(object):
    """
    An abstract representation of a Port.

    @param port_node A port_node taken from an nmap xml tree
    """
    def __init__(self, port_node):
        self.node = port_node

        self.protocol = self.node.get("protocol")
        self.number = self.node.get("portid")
        self.state, self.reason, self.reason_ttl = self.get_state()
        self.service = self.get_service()
        self.vulns = [vuln for vuln in self.get_scripts()]

    def get_attrib_from_subnode(self, subnode_xpath_expr, attrib_name):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        return get_attrib_from_subnode(self.node, subnode_xpath_expr, attrib_name)

    def get_state(self):
        """
        Expects to find a '<state state="open" reason="syn-ack" reason_ttl="0"/>' in the node.

        @return (state, reason, reason_ttl) or ('unknown','unknown','unknown')
        """
        state = self.get_attrib_from_subnode('state','state')
        reason = self.get_attrib_from_subnode('state','reason')
        reason_ttl = self.get_attrib_from_subnode('state','reason_ttl')

        return (state if state else 'unknown',
                reason if reason else 'unknown',
                reason_ttl if reason_ttl else 'unknown')

    def get_service(self):
        """
        Expects to find a service in the node.
        """
        service_node = self.node.find('service')
        if service_node is not None:                                                                             
            return Service(service_node)

        return None

    def get_scripts(self):
        """
        Expects to find a scripts in the node.
        """
        for s in self.node.findall('script'):
            yield Script(s)
    

    def __str__(self):
        return "%s, %s, Service: %s" % (self.number, self.state, self.service)

class Script(object):
    """
    An abstract representation of a Script.

    '<script id="http-methods" output="No Allow or Public header in OPTIONS response (status code 400)"/><script id="http-title" output="Document Error: Unauthorized"><elem key="title">Document Error: Unauthorized</elem></script>'

    @param script_node A script_node taken from an nmap xml tree
    """
    def __init__(self, script_node):
        self.node = script_node

        self.name = script_node.get("id")
        self.desc = script_node.get("output")
        self.response=""
        for k in script_node.findall("elem"):
            self.response +="\n"+str(k.get('key')) + ": " +str(k.text)
        self.web = True if re.search("(http-|https-)",self.name) else False

    def __str__(self):
        return "%s, %s, %s" % (self.name, self.product, self.version)

class Service(object):
    """
    An abstract representation of a Service.

    '<service name="ipp" product="CUPS" version="1.4" method="probed" conf="10"/>'

    @param service_node A service_node taken from an nmap xml tree
    """
    def __init__(self, service_node):
        self.node = service_node

        name = service_node.get("name")
        self.name = name if name else 'unknown'

        product = service_node.get("product")
        self.product = product if product else 'unknown'

        version = service_node.get("version")
        self.version = version if version else 'unknown'

        self.method = service_node.get("method")
        self.conf = service_node.get("conf")
        self.ostype = self.node.get("ostype")

    def __str__(self):
        return "%s, %s, %s" % (self.name, self.product, self.version)


class NmapPlugin(core.PluginBase):
    """
    Example plugin to parse nmap output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Nmap"
        self.name            = "Nmap XML Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "6.40"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo nmap|nmap|\.\/nmap).*?')
        self._completition = {
                        '' : '',
                    "-iL":"&lt;inputfilename&gt;: Input from list of hosts/networks",
                    "-iR":"&lt;num hosts&gt;: Choose random targets",
                    "--exclude":"&lt;host1[,host2][,host3],...&gt;: Exclude hosts/networks",
                    "--excludefile":"&lt;exclude_file&gt;: Exclude list from file",
                    "-sL:":"List Scan - simply list targets to scan",
                    "-sn:":"Ping Scan - disable port scan",
                    "-Pn:":"Treat all hosts as online -- skip host discovery",
                    "-PS:":"[portlist] TCP SYN/ACK, UDP or SCTP discovery to given ports",
                    "-PA:":"[portlist] TCP SYN/ACK, UDP or SCTP discovery to given ports",
                    "-PU:":"[portlist] TCP SYN/ACK, UDP or SCTP discovery to given ports",
                    "-PY:":"[portlist] TCP SYN/ACK, UDP or SCTP discovery to given ports",
                    "-PE:":"ICMP echo, timestamp, and netmask request discovery probes",
                    "-PP:":"ICMP echo, timestamp, and netmask request discovery probes",
                    "-PM:":"ICMP echo, timestamp, and netmask request discovery probes",
                    "-PO":"[protocol list]: IP Protocol Ping",
                    "-n":"Never do DNS resolution/Always resolve [default: sometimes]",
                    "-R":"Never do DNS resolution/Always resolve [default: sometimes]",
                    "--dns-servers":"&lt;serv1[,serv2],...&gt;: Specify custom DNS servers",
                    "--system-dns:":"Use OS's DNS resolver",
                    "--traceroute:":"Trace hop path to each host",
                    "-sS:":"TCP SYN/Connect()/ACK/Window/Maimon scans",
                    "-sT:":"TCP SYN/Connect()/ACK/Window/Maimon scans",
                    "-sA:":"TCP SYN/Connect()/ACK/Window/Maimon scans",
                    "-sW:":"TCP SYN/Connect()/ACK/Window/Maimon scans",
                    "-sM:":"TCP SYN/Connect()/ACK/Window/Maimon scans",
                    "-sU:":"UDP Scan",
                    "-sN:":"TCP Null, FIN, and Xmas scans",
                    "-sF:":"TCP Null, FIN, and Xmas scans",
                    "-sX:":"TCP Null, FIN, and Xmas scans",
                    "--scanflags":"&lt;flags&gt;: Customize TCP scan flags",
                    "-sI":"&lt;zombie host[:probeport]&gt;: Idle scan",
                    "-sY:":"SCTP INIT/COOKIE-ECHO scans",
                    "-sZ:":"SCTP INIT/COOKIE-ECHO scans",
                    "-sO:":"IP protocol scan",
                    "-b":"&lt;FTP relay host&gt;: FTP bounce scan",
                    "-p":"&lt;port ranges&gt;: Only scan specified ports\nEx: -p22; -p1-65535; -p U:53,111,137,T:21-25,80,139,8080,S:9\naaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaAAAAAAAAAAA1",
                    "-F:":"Fast mode - Scan fewer ports than the default scan",
                    "-r:":"Scan ports consecutively - don't randomize",
                    "--top-ports":"&lt;number&gt;: Scan &lt;number&gt; most common ports",
                    "--port-ratio":"&lt;ratio&gt;: Scan ports more common than &lt;ratio&gt;",
                    "-sV:":"Probe open ports to determine service/version info",
                    "--version-intensity":"&lt;level&gt;: Set from 0 (light) to 9 (try all probes)",
                    "--version-light:":"Limit to most likely probes (intensity 2)",
                    "--version-all:":"Try every single probe (intensity 9)",
                    "--version-trace:":"Show detailed version scan activity (for debugging)",
                    "-sC:":"equivalent to --script=default",
                    "--script=":"&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of directories, script-files or script-categories",
                    "--script-args=":"&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts",
                    "--script-trace:":"Show all data sent and received",
                    "--script-updatedb:":"Update the script database.",
                    "-O:":"Enable OS detection",
                    "--osscan-limit:":"Limit OS detection to promising targets",
                    "--osscan-guess:":"Guess OS more aggressively",
                    "-T":"&lt;0-5&gt;: Set timing template (higher is faster)",
                    "--min-hostgroup/max-hostgroup":"&lt;size&gt;: Parallel host scan group sizes",
                    "--min-parallelism/max-parallelism":"&lt;numprobes&gt;: Probe parallelization",
                    "--min-rtt-timeout/max-rtt-timeout/initial-rtt-timeout":"&lt;time&gt;: Specifies",
                    "--max-retries":"&lt;tries&gt;: Caps number of port scan probe retransmissions.",
                    "--host-timeout":"&lt;time&gt;: Give up on target after this long",
                    "--scan-delay/--max-scan-delay":"&lt;time&gt;: Adjust delay between probes",
                    "--min-rate":"&lt;number&gt;: Send packets no slower than &lt;number&gt; per second",
                    "--max-rate":"&lt;number&gt;: Send packets no faster than &lt;number&gt; per second",
                    "-f":"&lt;val&gt;: fragment packets (optionally w/given MTU)",
                    "-D":"&lt;decoy1,decoy2[,ME],...&gt;: Cloak a scan with decoys",
                    "-S":"&lt;IP_Address&gt;: Spoof source address",
                    "-e":"&lt;iface&gt;: Use specified interface",
                    "-g":"&lt;portnum&gt;: Use given port number",
                    "--source-port":"&lt;portnum&gt;: Use given port number",
                    "--data-length":"&lt;num&gt;: Append random data to sent packets",
                    "--ip-options":"&lt;options&gt;: Send packets with specified ip options",
                    "--ttl":"&lt;val&gt;: Set IP time-to-live field",
                    "--spoof-mac":"&lt;mac address/prefix/vendor name&gt;: Spoof your MAC address",
                    "--badsum:":"Send packets with a bogus TCP/UDP/SCTP checksum",
                    "-oN":"&lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,",
                    "-oX":"&lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,",
                    "-oS":"&lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,",
                    "-oG":"&lt;file&gt;: Output scan in normal, XML, s|&lt;rIpt kIddi3,",
                    "-oA":"Output in the three major formats at once",
                    "-v:":"Increase verbosity level (use -vv or more for greater effect)",
                    "-d:":"Increase debugging level (use -dd or more for greater effect)",
                    "--reason:":"Display the reason a port is in a particular state",
                    "--open:":"Only show open (or possibly open) ports",
                    "--packet-trace:":"Show all packets sent and received",
                    "--iflist:":"Print host interfaces and routes (for debugging)",
                    "--log-errors:":"Log errors/warnings to the normal-format output file",
                    "--append-output:":"Append to rather than clobber specified output files",
                    "--resume":"&lt;filename&gt;: Resume an aborted scan",
                    "--stylesheet":"&lt;path/URL&gt;: XSL stylesheet to transform XML output to HTML",
                    "--webxml:":"Reference stylesheet from Nmap.Org for more portable XML",
                    "--no-stylesheet:":"Prevent associating of XSL stylesheet w/XML output",
                    "-6:":"Enable IPv6 scanning",
                    "-A:":"Enable OS detection, version detection, script scanning, and traceroute",
                    "--datadir":"&lt;dirname&gt;: Specify custom Nmap data file location",
                    "--send-eth/--send-ip:":"Send using raw ethernet frames or IP packets",
                    "--privileged:":"Assume that the user is fully privileged",
                    "--unprivileged:":"Assume the user lacks raw socket privileges",
                    "-V:":"Print version number",
                    "-h:":"Print this help summary page.",
                    }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "nmap_output-%s.xml" % self._rid)
                                  

        self.addSetting("Scan Technique", str, "-sS")

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = NmapXmlParser(output)

        for host in parser.hosts:
            if not host.is_up():
                continue

            if host.mac_address == 'unknown':
                host.mac_address="00:00:00:00:00:00"

            if host.ipv4_address != 'unknown':
                minterfase = host.ipv4_address
                h_id = self.createAndAddHost(minterfase, host.os)
                i_id = self.createAndAddInterface(h_id, minterfase, host.mac_address, ipv4_address=host.ipv4_address, hostname_resolution=host.hostnames)
            else:
                minterfase = host.ipv6_address
                h_id = self.createAndAddHost(minterfase, host.os)
                i_id = self.createAndAddInterface(h_id, minterfase, host.mac_address, ipv6_address=host.ipv6_address, hostname_resolution=host.hostnames)

            for v in host.vulns:
                desc=v.desc
                desc+="\nOutput: "+ v.response if v.response else ""
                v_id = self.createAndAddVulnToHost(h_id,v.name,desc=v.desc,
                                                         severity=0)

            for port in host.ports:
                
                srvname=str(port.number)
                srvversion="unknown"
                if port.service is not None:
                    srvname=port.service.name
                    srvversion=port.service.product if port.service.product != "unknown" else ""
                    srvversion+=" " +port.service.version if port.service.version != "unknown" else ""

                s_id = self.createAndAddServiceToInterface(h_id, i_id, srvname,
                                                   port.protocol,
                                                   ports = [port.number],
                                                   status = port.state,
                                                   version = srvversion,
                                                   description = srvname)
                note=True
                for v in port.vulns:
                    desc=v.desc
                    desc+="\nOutput: "+ v.response if v.response else ""
                    if v.web:
                        if note:
                            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,minterfase,"")
                            note=False
                        v_id = self.createAndAddVulnWebToService(h_id,s_id,v.name,desc=desc,
                                                                 severity=0,website=minterfase)
                    else:
                        v_id = self.createAndAddVulnToService(h_id,s_id,v.name,desc=v.desc,
                                                                 severity=0)
                        
                
        del parser
        
        return True


    xml_arg_re = re.compile(r"^.*(-oX\s*[^\s]+).*$")
    
                                                                           
                                                                                     
    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -oX parameter to get xml output to the command string that the
        user has set.
        """
        self._output_file_path = os.path.join(self.data_path,"nmap_output-%s.xml" % random.uniform(1,10))        

        arg_match = self.xml_arg_re.match(command_string)


        if arg_match is None:
            return re.sub(r"(^.*?nmap)",
                          r"\1 -oX %s" % self._output_file_path,
                          command_string)
        else:
            return re.sub(arg_match.group(1),
                          r"-oX %s" % self._output_file_path,
                          command_string)


    def setHost(self):
        pass


def createPlugin():
    return NmapPlugin()

if __name__ == '__main__':
    parser = NmapXmlParser(sys.argv[1])
    for host in parser.hosts:
        if host.status == 'up':
            print host

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class OpenvasXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the openvas tool.

    TODO: Handle errors.
    TODO: Test openvas output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param openvas_xml_filepath A proper xml generated by openvas
    """
    def __init__(self, xml_output):
        self.target = None
        self.port = "80"
        self.host = None

        tree = self.parse_xml(xml_output)
        
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
        bugtype=""
        
                                           
        node = tree.findall('report')[0]
        node2 = node.findall('results')[0]
            
        for node in node2.findall('result'):
            yield Item(node)
                                  


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an openvas xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.host = self.get_text_from_subnode('host')
        self.subnet = self.get_text_from_subnode('subnet')
        self.description = self.get_text_from_subnode('description')
        self.port ="None"
        self.severity = self.get_text_from_subnode('threat')
        self.service=""
        self.protocol=""
        port = self.get_text_from_subnode('port')
        
        if (re.search("^general",port) is None):
            mregex = re.search("([\w]+) \(([\d]+)\/([\w]+)\)",port)
            self.service = mregex.group(1)
            self.port = mregex.group(2)
            self.protocol = mregex.group(2)
        else:
            info = port.split("/")
            self.service = info[0]
            self.protocol = info[1]
            
            
        self.nvt = self.node.findall('nvt')[0]
        self.node = self.nvt 
        self.id=self.node.get('oid')
        self.name = self.get_text_from_subnode('name')
        self.cve = self.get_text_from_subnode('cve') if self.get_text_from_subnode('cve') != "NOCVE" else ""
        self.bid = self.get_text_from_subnode('bid') if self.get_text_from_subnode('bid') != "NOBID" else ""
        self.xref = self.get_text_from_subnode('xref') if self.get_text_from_subnode('xref') != "NOXREF" else ""
        
    def do_clean(self,value):
        myreturn =""
        if value is not None:
            myreturn = re.sub("\n","",value)
        return myreturn
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None and sub_node.text is not None:
            return sub_node.text

        return ''



class OpenvasPlugin(core.PluginBase):
    """
    Example plugin to parse openvas output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Openvas"
        self.name            = "Openvas XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "2.0"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(openvas|sudo openvas|\.\/openvas).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "openvas_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """                                                                               

        parser = OpenvasXmlParser(output)

        web=False
        ids={}
        for item in parser.items:
            if item.name is not None:
                ref=[]
                if item.cve:
                    ref.append(item.cve.encode("utf-8"))
                if item.bid:
                    ref.append(item.bid.encode("utf-8"))
                if item.xref:
                    ref.append(item.xref.encode("utf-8"))
                
                if ids.has_key(item.subnet):
                    h_id=ids[item.host]
                else:
                    h_id = self.createAndAddHost(item.subnet)
                    ids[item.subnet] = h_id
                    
                if item.port == "None":
                    v_id = self.createAndAddVulnToHost(h_id,item.name.encode("utf-8"),desc=item.description.encode("utf-8"),
                                                       ref=ref)
                else:
                    
                                   
                    web=True if re.search(r'^(www|http)',item.service) else False
                    
                    if ids.has_key(item.subnet+"_"+item.subnet):
                        i_id=ids[item.subnet+"_"+item.subnet]
                    else:
                                        
                        if self._isIPV4(item.subnet):
                            i_id = self.createAndAddInterface(h_id, item.subnet, ipv4_address=item.subnet,hostname_resolution=item.host)
                        else:
                            i_id = self.createAndAddInterface(h_id, item.subnet, ipv6_address=item.subnet,hostname_resolution=item.host)
                            
                        ids[item.subnet+"_"+item.subnet] = i_id
                        
                    
                    if ids.has_key(item.subnet+"_"+item.port):
                        s_id=ids[item.subnet+"_"+item.port]
                    else:
                        s_id = self.createAndAddServiceToInterface(h_id, i_id, item.service,
                                   item.protocol, 
                                   ports = [str(item.port)],
                                   status = "open")
                        ids[item.subnet+"_"+item.port] = s_id
                        if web:
                            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,item.host,"")

                    if item.name:                                        
                        if web:
                            v_id = self.createAndAddVulnWebToService(h_id, s_id, item.name.encode("utf-8"),
                                                    desc=item.description.encode("utf-8"),website=item.host,
                                                    severity=item.severity.encode("utf-8"),ref=ref)
                        else:
                            v_id = self.createAndAddVulnToService(h_id, s_id, item.name.encode("utf-8"),
                                                    desc=item.description.encode("utf-8"),severity=item.severity.encode("utf-8"),ref=ref)

        del parser
        
                      
                                             
                    

    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

                                                                              
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return OpenvasPlugin()

if __name__ == '__main__':
    parser = OpenvasXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from plugins import core
from model import api
import re
import os

__author__     = "Facundo de Guzmn, Esteban Guillardoy"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Facundo de Guzmn", "Esteban Guillardoy"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class CmdPingPlugin(core.PluginBase):
    """
    This plugin handles ping command.
    Basically detects if user was able to connect to a device
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "ping"
        self.name            = "Ping"
        self.plugin_version         = "0.0.1"
        self.version  = "1.0.0"
        self._command_regex  = re.compile(r'^(sudo ping|ping|sudo ping6|ping6).*?')
        self._completition = {
                                "":"[-LRUbdfnqrvVaAB]  [-c  count]  [-m  mark]  [-i interval] [-l preload] [-p pattern] [-s packetsize] [-t ttl] [-w deadline] [-F flowlabel] [-Iinterface] [-M hint] [-N nioption] [-Q tos] [-S sndbuf] [-T timestamp option] [-W timeout] [hop ...] destination",
                                "-a":"Audible ping.",
                                "-A":"Adaptive  ping.  Interpacket  interval adapts to round-trip time, so that effectively not more than one (or more, if preload is set) unanswered probes present in the network. Minimal interval is 200msec for not super-user.  On networks with low rtt this mode  is  essentially",
                                "-b":"Allow pinging a broadcast address.",
                                "-B":"Do not allow ping to change source address of probes.  The address is bound to one selected when ping starts.",
                                "-m":"mark",
                                "-c":"count",
                                "-d":"Set the SO_DEBUG option on the socket being used.  Essentially, this socket option is not used by Linux kernel.",
                                "-F":"flow label",
                                "-f":"Flood  ping.  For every ECHO_REQUEST sent a period ``.'' is printed, while for ever ECHO_REPLY received a backspace is printed.  This profast as they come back or one hundred times per second, whichever is more.  Only the super-user may use this option with zero interval.",
                                "-i":"interval",
                                "-I":"interface address.Set source address to specified interface address. Argument may be numeric IP address or name of  device.  When  pinging  IPv6 link-local",
                                "-l":"preload",
                                "-L":"Suppress loopback of multicast packets.  This flag only applies if the ping destination is a multicast address.",
                                "-N":"(nioption) Send ICMPv6 Node Information Queries (RFC4620), instead of Echo Request.",
                                "-n":"Numeric output only.  No attempt will be made to lookup symbolic names for host addresses.",
                                "-p":"pattern You  may  specify up to 16 ``pad'' bytes to fill out the packet you send.  This is useful for diagnosing data-dependent problems in a network.  For example, -p ff will cause the sent packet to be filled with all ones.",
                                "-D":"Print timestamp (unix time + microseconds as in gettimeofday) before each line.",
                                "-Q":"tos Set Quality of Service -related bits in ICMP datagrams.  tos can be either decimal or hex number.   Traditionally  (RFC1349),  these  have been  interpreted  as:  0  for reserved (currently being redefined as congestion control), 1-4 for Type of Service and 5-7 for Precedence enabled in the kernel.  In RFC2474, these fields has been redefined as 8-bit Differentiated Services (DS), consisting of: bits 0-1 of separate data (ECN will be used, here), and bits 2-7 of Differentiated Services Codepoint (DSCP).",
                                "-q":"Quiet output.  Nothing is displayed except the summary lines at startup time and when finished.",
                                "-R":"Record route.  Includes the RECORD_ROUTE option in the ECHO_REQUEST packet and displays the route buffer on returned packets.   Note  that",
                                "-r":"Bypass the normal routing tables and send directly to a host on an attached interface.  If the host is not on a directly-attached network,",
                                "-s":"packetsize",
                                "-S":"sndbuf",
                                "-t":"ttl Set the IP Time to Live.",
                                "-T":"Timestamp option",
                                "-M":"hint",
                                "-U":"Print full user-to-user latency (the old behaviour). Normally ping prints network round trip time, which can be different f.e. due to  DNS",
                                "-v":"Verbose output.",
                                "-V":"Show version and exit.",
                                "-w":"deadline",
                                "-W":"timeout",
                    }

    def parseOutputString(self, output, debug = False):

        reg=re.search(r"PING ([\w\.-:]+)( |)\(([\w\.:]+)\)", output)
        if re.search("0 received|unknown host",output) is None and reg is not None:
            
            ip_address = reg.group(3)
            hostname=reg.group(1)
                
            
            h_id = self.createAndAddHost(ip_address)
            if self._isIPV4(ip_address):                
                i_id = self.createAndAddInterface(h_id, ip_address, ipv4_address=ip_address, hostname_resolution=[hostname])
            else:
                i_id = self.createAndAddInterface(h_id, ip_address, ipv6_address=ip_address, hostname_resolution=[hostname])

        return True
    
    def _isIPV4(self, ip):
        if len(ip.split(".")) == 4:
            return True
        else:
            return False

    def processCommandString(self, username, current_path, command_string):
        """
        """
        return None

def createPlugin():
    return CmdPingPlugin()

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from plugins import core
from model import api
import re


__author__     = "Federico Kirschbaum"
__copyright__  = "Copyright 2011, Faraday Project"
__credits__    = ["Federico Kirschbaum"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Federico Kirschbaum"
__email__      = "fedek@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class CmdPropeciaPlugin(core.PluginBase):
    """
    This plugin handles propecia command.
    Basically inserts into the tree the ouput of this tool
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "propecia"
        self.name            = "propecia port scanner"
        self.plugin_version         = "0.0.1"
        self.version            ="1.0"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo propecia|\.\/propecia|propecia).*?')
        self._host_ip        = None
        self._port           = "23"

       

                                  

    def parseOutputString(self, output, debug = False):

        host_info = re.search(r"(\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b)", output)
        
        if host_info is None:
            api.log("No hosts detected")
        else:           
            for host in output.split('\r\n'):
                if host != "":
                    h_id = self.createAndAddHost(host)
                    i_id = self.createAndAddInterface(h_id, host, ipv4_address=host)
                    s_id = self.createAndAddServiceToInterface(h_id, i_id, str(self._port),
                                                       "tcp",
                                                       ports = [self._port],
                                                       status = "open",
                                                       version = "",
                                                       description = "")

        if debug is True:
            api.devlog("Debug is active")
        
            
        return True
     

    def processCommandString(self, username, current_path, command_string):
        """
        """
        count_args = command_string.split()
        
        if count_args.__len__() == 3:
            self._port = count_args[2]

        return None

def createPlugin():
    return CmdPropeciaPlugin()

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION

ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class QualysguardXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the qualysguard tool.

    TODO: Handle errors.
    TODO: Test qualysguard output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param qualysguard_xml_filepath A proper xml generated by qualysguard
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            self.devlog("SyntaxError: %s. %s" % (err, xml_output))
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """       
        for node in tree.findall("IP"):
            yield Item(node)

                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an qualysguard xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.ip = item_node.get('value')
        self.os = self.get_text_from_subnode("OS")
            
        self.vulns=self.getResults(item_node)
            
    def getResults(self, tree):
        """
        :param tree:
        """
        for self.issues in tree.findall("VULNS/CAT"):
            for v in self.issues.findall("VULN"):
                yield Results(v,self.issues)
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class Results():
    def __init__(self, issue_node,parent):
        self.node = issue_node
        self.port=parent.get('port')
        self.protocol=parent.get('protocol')
        self.name=self.node.get('number')
        self.severity=self.node.get('severity')
        self.title=self.get_text_from_subnode("TITLE")
        self.cvss=self.get_text_from_subnode("CVSS_BASE")
        self.pci=self.get_text_from_subnode("PCI_FLAG")
        self.diagnosis=self.get_text_from_subnode("DIAGNOSIS")
        self.solution=self.get_text_from_subnode("SOLUTION")
        self.result=self.get_text_from_subnode("RESULT")
        self.desc = self.diagnosis
        self.desc += "\nResult: " +self.result if self.result else ""
        self.desc += "\nSolution: " +self.solution if self.solution else ""
        
        self.ref=[]
        for r in issue_node.findall("CVE_ID_LIST/CVE_ID"):
            self.node=r
            self.ref.append(self.get_text_from_subnode("ID"))
        for r in issue_node.findall("BUGTRAQ_ID_LIST/BUGTRAQ_ID"):
            self.node=r
            self.ref.append("bid-"+self.get_text_from_subnode("ID"))
               
        

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class QualysguardPlugin(core.PluginBase):
    """
    Example plugin to parse qualysguard output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Qualysguard"
        self.name            = "Qualysguard XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "Qualysguard"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo qualysguard|\.\/qualysguard).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "qualysguard_output-%s.xml" % self._rid)

    def parseOutputString(self, output, debug = False):
        
                                                                                
        parser = QualysguardXmlParser(output)
        for item in parser.items:
            h_id = self.createAndAddHost(item.ip,item.os)
            i_id = self.createAndAddInterface(h_id, item.ip,ipv4_address=item.ip, hostname_resolution=item.ip)
            
            for v in item.vulns:
                if v.port is None:
                    v_id=self.createAndAddVulnToHost(h_id,v.title,ref=v.ref,severity=v.severity,desc=v.desc)
                else:
                    web=False
                    s_id = self.createAndAddServiceToInterface(h_id, i_id, v.port,
                                                        v.protocol,
                                                        ports = [str(v.port)],
                                                        status = "open")
                    
                    if v.port in ['80','443'] or re.search("ssl|http",v.name):
                        web=True
                    else:
                        web=False
                    
                    if web:
                        v_id=self.createAndAddVulnWebToService(h_id, s_id,v.title,ref=v.ref,website=item.ip,severity=v.severity,desc=v.desc)
                        n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                        n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,item.ip,"")
                    else:
                        v_id=self.createAndAddVulnToService(h_id, s_id,v.title,ref=v.ref,severity=v.severity,desc=v.desc)
                                  
                       
                          
             
                                 
                             
                             
        del parser
        
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return QualysguardPlugin()

if __name__ == '__main__':
    parser = QualysguardXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION

ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class RetinaXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the retina tool.

    TODO: Handle errors.
    TODO: Test retina output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param retina_xml_filepath A proper xml generated by retina
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """       
        for node in tree.findall("hosts/host"):
            yield Item(node)

                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an retina xml tree
    """
    def __init__(self, item_node):
        self.node = item_node
        self.ip = self.get_text_from_subnode("ip")
        self.hostname = "" if self.get_text_from_subnode("dnsName") == "unknown" else self.get_text_from_subnode("dnsName")
        self.netbiosname = self.get_text_from_subnode("netBIOSName")
        self.netbiosdomain = self.get_text_from_subnode("netBIOSDomain")
        self.os = self.get_text_from_subnode("os")
        self.mac = self.get_text_from_subnode("mac")
            
        self.vulns=self.getResults(item_node)
        self.ports={}
        for v in self.vulns:
            if not v.port in self.ports:
                self.ports[v.port] = []
            self.ports[v.port].append(v)
        
            
    def getResults(self, tree):
        """
        :param tree:
        """
        for self.issues in tree.findall("audit"):
            yield Results(self.issues)
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class Results():
    def __init__(self, issue_node):
        self.node = issue_node
        self.name=self.get_text_from_subnode('name')
                                 
        self.description=self.get_text_from_subnode('description')
        self.solution=self.get_text_from_subnode('fixInformation')
        self.severity=self.get_text_from_subnode('risk')
        self.cve="" if self.get_text_from_subnode('cve') == 'N/A' else self.get_text_from_subnode('cve')
        self.cce=self.get_text_from_subnode('cce')
        self.date=self.get_text_from_subnode('date')
        self.pciLevel=self.get_text_from_subnode('pciLevel')
        self.pciReason=self.get_text_from_subnode('pciReason')
        self.pciPassFail=self.get_text_from_subnode('pciPassFail')
        self.cvssScore=self.get_text_from_subnode('cvssScore')
        self.exploit=self.get_text_from_subnode('exploit')
        self.context=self.get_text_from_subnode('context')
        val=self.context.split(":")
        self.port=""
        self.protocol=""
        if len(val) == 2:
            if val[0] in ['TCP','UDP']:
                self.protocol = val[0]
                self.port = val[1]
            
        self.desc = self.get_text_from_subnode('description')
        self.desc += "\nSolution: " +self.solution if self.solution else ""
        self.desc += "\nExploit: " +self.exploit if self.exploit else ""
        self.desc += "\ncvssScore: " +self.cvssScore if self.cvssScore else ""
        self.desc += "\nContext: " +self.context if self.context else ""
        
        self.ref=[]
        if self.cve:
            self.ref=self.cve.split(",")
               
        

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class RetinaPlugin(core.PluginBase):
    """
    Example plugin to parse retina output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Retina"
        self.name            = "Retina XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "Retina Network 5.19.2.2718"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo retina|\.\/retina).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "retina_output-%s.xml" % self._rid)

    def parseOutputString(self, output, debug = False):
        
                                                                           
        parser = RetinaXmlParser(output)
        for item in parser.items:
            h_id = self.createAndAddHost(item.ip,item.os)
            hostname=item.hostname if item.hostname else item.ip
            i_id = self.createAndAddInterface(h_id, item.ip,ipv4_address=item.ip, hostname_resolution=hostname)
            
            if not item.netbiosname=='N/A':
                self.createAndAddNoteToHost(h_id,"netBIOSName",item.netbiosname)
            
            if not item.netbiosdomain=='N/A':
                self.createAndAddNoteToHost(h_id,"netBIOSDomain",item.netbiosdomain)
            
            a={}
            a.iteritems
            for k,vulns in item.ports.iteritems():
                if k:
                    for v in vulns:
                        web=False
                        s_id = self.createAndAddServiceToInterface(h_id, i_id, 'unknown',
                                                            v.protocol.lower(),
                                                            ports = [str(v.port)],
                                                            status = "open")
                        
                        if v.port in ['80','443'] or re.search("ssl|http",v.name.lower()):
                            web=True
                        else:
                            web=False
                        
                        if web:
                            v_id=self.createAndAddVulnWebToService(h_id, s_id,v.name.encode("utf-8"),ref=v.ref,website=hostname,severity=v.severity,desc=v.desc.encode("utf-8"))
                            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,hostname,"")
                        else:
                            v_id=self.createAndAddVulnToService(h_id, s_id,v.name.encode("utf-8"),ref=v.ref,severity=v.severity,desc=v.desc.encode("utf-8"))
                else:
                    for v in vulns:
                        v_id=self.createAndAddVulnToHost(h_id,v.name.encode("utf-8"),ref=v.ref,severity=v.severity,desc=v.desc.encode("utf-8"))
        del parser
        
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return RetinaPlugin()

if __name__ == '__main__':
    parser = RetinaXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class ReverseraiderParser(object):
    """
    The objective of this class is to parse an xml file generated by the reverseraider tool.

    @param reverseraider_filepath A proper simple report generated by reverseraider
    """
    def __init__(self, output):
        
        lists = output.split("\r\n")
        self.items = []
        
        if re.search("ReverseRaider domain scanner|Error opening",output) is not None:
            return
        
        for line in lists:
            if line <> "":
                print "(%s)" % line
                info = line.split("\t")
                if info.__len__() > 0:
                    item = {'host' : info[0], 'ip' : info[1]}
                    print "host = %s, ip = %s" % (info[0],info[1])
                    self.items.append(item)
    


class ReverseraiderPlugin(core.PluginBase):
    """
    Example plugin to parse reverseraider output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Reverseraider"
        self.name            = "Reverseraider XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "0.7.6"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(sudo \.\/reverseraider|\.\/reverseraider).*?')
        self._completition = {
                                "":"reverseraider -d domain | -r range [options]",
                                "-r":"range of ipv4 or ipv6 addresses, for reverse scanning",
                                "-d":"domain, for wordlist scanning (example google.com)",
                                "-w":"wordlist file (see wordlists directory...)",
                                "-t":"requests timeout in seconds",
                                "-P":"enable numeric permutation on wordlist (default off)",
                                "-D":"nameserver to use (default: resolv.conf)",
                                "-T":"use TCP queries instead of UDP queries",
                                "-R":"don't set the recursion bit on queries",
        }

        global current_path
        
                                  

    def canParseCommandString(self, current_input):
        if self._command_regex.match(current_input.strip()):
            return True
        else:
            return False


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
                    
        if debug:
            parser = ReverseraiderParser(output)
        else:
            
            parser = ReverseraiderParser(output)


            for item in parser.items:
                h_id = self.createAndAddHost(item['ip'])
                i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address=item['ip'])


        del parser

    def processCommandString(self, username, current_path, command_string):
        """
        """
        return None



def createPlugin():
    return ReverseraiderPlugin()

if __name__ == '__main__':
    parser = ReverseraiderParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys
import json
import socket
import random



current_path = os.path.abspath(os.getcwd())

__author__     = "Nicolas Rodriguez"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Nicolas Rodriguez"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class SkipfishParser(object):
    """
    The objective of this class is to parse an xml file generated by the skipfish tool.

    TODO: Handle errors.
    TODO: Test skipfish output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param skipfish_filepath A proper xml generated by skipfish
    """
    def __init__(self, skipfish_filepath):
        self.filepath = skipfish_filepath
        
        tmp = open(skipfish_filepath+"/samples.js", "r").read()
        issues = json.loads(self.extract_data(tmp, "var issue_samples =", "];",
                    lambda x: x.replace("'", '"'), False, False)[1] + "]")
        
        tmp = open(skipfish_filepath+"/index.html", "r").read()
        err_msg = json.loads(self.extract_data(tmp, "var issue_desc=", "};",
                    lambda x: self.convert_quotes(x, "'", '"'), False, False)[1] + "}")
        
        self.err_msg=err_msg
        self.issues=issues

    def convert_quotes(self,text, quote="'", inside='"'):
        start = 0
        while True:
            pos = text.find(quote, start)
    
            if pos == -1:
                break
    
            ss = text[:pos - 1]
            quotes = len(ss) - len(ss.replace(inside, ""))
    
            if quotes % 2 == 0:
                text = text[:pos - 1] + "\\" + quote + text[pos + 1:]
    
            start = pos + 1
        return text
    
    def extract_data(self, samples, start_tag, end_tag, fn=lambda x: x, include_start_tag=True, include_end_tag=True):
        start = samples.find(start_tag)
    
        if start == -1:
            return (-1, None)
    
        end = samples.find(end_tag, start + 1)
    
        if end == -1:
            return (-2, None)
    
        data = samples[start:end + len(end_tag)]
        data = fn(data)
    
        if not include_start_tag:
            data = data[len(start_tag) + 1:]
    
        if not include_end_tag:
            data = data[:-1 * len(end_tag)]
    
        return (0, data)


class SkipfishPlugin(core.PluginBase):
    """
    Example plugin to parse skipfish output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Skipfish"
        self.name            = "Skipfish XML Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "2.1.5"
        self.options         = None
        self._current_output = None
        self.parent = None
        self._command_regex  = re.compile(r'^(sudo skipfish|skipfish|sudo skipfish\.pl|skipfish\.pl|perl skipfish\.pl|\.\/skipfish\.pl|\.\/skipfish).*?')
        self._completition = {
                                "":"Usage: skipfish [ options ... ] -W wordlist -o output_dir start_url [ start_url2 ... ]",
                                "-A":"user:pass - use specified HTTP authentication credentials",
                                "-F":"host=IP - pretend that 'host' resolves to 'IP'",
                                "-C":"name=val - append a custom cookie to all requests",
                                "-H":"name=val - append a custom HTTP header to all requests",
                                "-b":"(i|f|p) - use headers consistent with MSIE / Firefox / iPhone",
                                "-N":"- do not accept any new cookies",
                                "--auth-form":"url - form authentication URL",
                                "--auth-user":"user - form authentication user",
                                "--auth-pass":"pass - form authentication password",
                                "--auth-verify-url":" --auth-verify-url -  URL for in-session detection",
                                "-d":"max_depth - maximum crawl tree depth (16)",
                                "-c":"max_child - maximum children to index per node (512)",
                                "-x":"max_desc - maximum descendants to index per branch (8192)",
                                "-r":"r_limit - max total number of requests to send (100000000)",
                                "-p":"crawl% - node and link crawl probability (100%)",
                                "-q":"hex - repeat probabilistic scan with given seed",
                                "-I":"string - only follow URLs matching 'string'",
                                "-X":"string - exclude URLs matching 'string'",
                                "-K":"string - do not fuzz parameters named 'string'",
                                "-D":"domain - crawl cross-site links to another domain",
                                "-B":"domain - trust, but do not crawl, another domain",
                                "-Z":"- do not descend into 5xx locations",
                                "-O":"- do not submit any forms",
                                "-P":"- do not parse HTML, etc, to find new links",
                                "-o":"dir - write output to specified directory (required)",
                                "-M":"- log warnings about mixed content / non-SSL passwords",
                                "-E":"- log all HTTP/1.0 / HTTP/1.1 caching intent mismatches",
                                "-U":"- log all external URLs and e-mails seen",
                                "-Q":"- completely suppress duplicate nodes in reports",
                                "-u":"- be quiet, disable realtime progress stats",
                                "-v":"- enable runtime logging (to stderr)",
                                "-W":"wordlist - use a specified read-write wordlist (required)",
                                "-S":"wordlist - load a supplemental read-only wordlist",
                                "-L":"- do not auto-learn new keywords for the site",
                                "-Y":"- do not fuzz extensions in directory brute-force",
                                "-R":"age - purge words hit more than 'age' scans ago",
                                "-T":"name=val - add new form auto-fill rule",
                                "-G":"max_guess - maximum number of keyword guesses to keep (256)",
                                "-z":"sigfile - load signatures from this file",
                                "-g":"max_conn - max simultaneous TCP connections, global (40)",
                                "-m":"host_conn - max simultaneous connections, per target IP (10)",
                                "-f":"max_fail - max number of consecutive HTTP errors (100)",
                                "-t":"req_tmout - total request response timeout (20 s)",
                                "-w":"rw_tmout - individual network I/O timeout (10 s)",
                                "-i":"idle_tmout - timeout on idle HTTP connections (10 s)",
                                "-s":"s_limit - response size limit (400000 B)",
                                "-e":"- do not keep binary responses for reporting",
                                "-l":"max_req - max requests per second (0.000000)",
                                "-k":"duration - stop scanning after the given duration h:m:s",
                                "--config":"- load the specified configuration file",

        }

        global current_path


    def parseOutputString(self, output, debug = False ):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
                                                              
        # if (re.search("\r\n",output) is None):
        #     self._output_path=output
            
        if not os.path.exists(self._output_path):
            return False
        
        p = SkipfishParser(self._output_path)

        hostc={}
        port=80
        for issue in p.issues:
            request=""
            response=""
            for sample in issue["samples"]:
                if not sample["url"] in hostc:
                    reg = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", sample["url"])
                                        
                    protocol = reg.group(1)
                    host = reg.group(4)
                    if reg.group(11) is not None:
                        port = reg.group(11)
                    else:
                        port = 443 if protocol == "https" else 80
                        
                    ip = self.resolve(host)
        
                    h_id = self.createAndAddHost(ip)
                    i_id = self.createAndAddInterface(h_id, ip, ipv4_address=ip,hostname_resolution=host)
                    s_id = self.createAndAddServiceToInterface(h_id, i_id, "http",
                                                       "tcp",
                                                       ports = [port],
                                                       status = "open")
    
                    n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
                    n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,host,"")
    

                    hostc[sample["url"]]={'h_id':h_id, 'ip':ip,'port':port,'host':host,'protocol':protocol,
                           'i_id':i_id,'s_id':s_id}
                        
            
                try:
                    request =open("%s/request.dat" % sample["dir"], "r").read()
                except:
                    pass
                
                try:
                    response =open("%s/request.dat" % sample["dir"], "r").read()
                except:
                    pass
        
                d=hostc[sample["url"]]
                v_id = self.createAndAddVulnWebToService(d['h_id'], d['s_id'],
                                                     name=p.err_msg[str(issue["type"])],desc="Extra: " + sample["extra"], website=d['host'],
                                                     path=sample["url"],severity=issue["severity"])


    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

    xml_arg_re = re.compile(r"^.*(-o\s*[^\s]+).*$")

    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -o parameter to get report of the command string that the
        user has set.
        """
        arg_match = self.xml_arg_re.match(command_string)

        self._output_path = os.path.join(self.data_path,
                                             "skipfish_output-%s" % random.uniform(1,10))

        if arg_match is None:
            return re.sub(r"(^.*?skipfish)",
                          r"\1 -o %s" % self._output_path,
                          command_string,1)
        else:
            return re.sub(arg_match.group(1),
                          r"-o %s" % self._output_path,
                          command_string,1)

    def setHost(self):
        pass


def createPlugin():
    return SkipfishPlugin()

if __name__ == '__main__':
    parser = SkipfishParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys
import json
import pickle
import sqlite3
import hashlib
import socket
import argparse
import shlex
from BaseHTTPServer import BaseHTTPRequestHandler
from StringIO import StringIO

                                                 
sys.path.append("/usr/share/sqlmap/")

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

class HASHDB_KEYS:
    DBMS = "DBMS"
    CONF_TMP_PATH = "CONF_TMP_PATH"
    KB_ABS_FILE_PATHS = "KB_ABS_FILE_PATHS"
    KB_BRUTE_COLUMNS = "KB_BRUTE_COLUMNS"
    KB_BRUTE_TABLES = "KB_BRUTE_TABLES"
    KB_CHARS = "KB_CHARS"
    KB_DYNAMIC_MARKINGS = "KB_DYNAMIC_MARKINGS"
    KB_INJECTIONS = "KB_INJECTIONS"
    KB_XP_CMDSHELL_AVAILABLE = "KB_XP_CMDSHELL_AVAILABLE"
    OS = "OS" 

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

UNICODE_ENCODING = "utf8"
HASHDB_MILESTONE_VALUE = "cAWxkLYCQT"


class Database(object):

    def __init__(self, database):
        self.database = database


    def connect(self, who="server"):
        print "Db" + self.database
        self.connection = sqlite3.connect(self.database, timeout=3, isolation_level=None)
        self.cursor = self.connection.cursor()

    def disconnect(self):
        self.cursor.close()
        self.connection.close()

    def commit(self):
        self.cursor.commit()

    def execute(self, statement, arguments=None):
        if arguments:
            self.cursor.execute(statement, arguments)
        else:
            self.cursor.execute(statement)

        if statement.lstrip().upper().startswith("SELECT"):
            return self.cursor.fetchall()

class SqlmapPlugin(core.PluginBase):
    """
    Example plugin to parse sqlmap output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Sqlmap"
        self.name            = "Sqlmap"
        self.plugin_version         = "0.0.1"
        self.version   = "sqlmap/1.0-dev"
        self.framework_version  = "1.0.0"
        self._current_output = None
        self.url = ""
        self.protocol=""
        self.hostname=""
        self.port="80"
        self.params=""
        self.fullpath=""
        self.path=""
        
        self.db_port = { "MySQL" : 3306, "PostgreSQL":"", "Microsoft SQL Server" : 1433,
                 "Oracle" : 1521, "Firebird" : 3050,"SAP MaxDB":7210, "Sybase" : 5000,
                 "IBM DB2" : 50000, "HSQLDB" :9001}
        self.ptype = {
                    1: "Unescaped numeric",
                    2: "Single quoted string",
                    3: "LIKE single quoted string",
                    4: "Double quoted string",
                    5: "LIKE double quoted string",
                }

        self._command_regex  = re.compile(r'^(sudo sqlmap|sqlmap|sudo python sqlmap|python sqlmap|\.\/sqlmap).*?')

        global current_path
        self._output_path = ""
        self._completition = {
                                "-h,":"Show basic help message and exit",
                                "-hh":"Show advanced help message and exit",
                                "--version":"Show program's version number and exit",
                                "-v":"VERBOSE            Verbosity level: 0-6 (default 1)",
                                "-d":"DIRECT           Direct connection to the database",
                                "-u":"URL, --url=URL   Target URL (e.g. \"www.target.com/vuln.php?id=1\")",
                                "-l":"LOGFILE          Parse targets from Burp or WebScarab proxy logs",
                                "-m":"BULKFILE         Scan multiple targets enlisted in a given textual file",
                                "-r":"REQUESTFILE      Load HTTP request from a file",
                                "-g":"GOOGLEDORK       Process Google dork results as target URLs",
                                "-c":"CONFIGFILE       Load options from a configuration INI file",
                                "--data":"DATA         Data string to be sent through POST",
                                "--param-del":"PDEL    Character used for splitting parameter values",
                                "--cookie":"COOKIE     HTTP Cookie header",
                                "--cookie-del":"CDEL   Character used for splitting cookie values",
                                "--load-cookies":"L..  File containing cookies in Netscape/wget format",
                                "--drop-set-cookie":"   Ignore Set-Cookie header from response",
                                "--user-agent":"AGENT  HTTP User-Agent header",
                                "--random-agent":"Use randomly selected HTTP User-Agent header",
                                "--host":"HOST         HTTP Host header",
                                "--referer":"REFERER   HTTP Referer header",
                                "--headers":"HEADERS   Extra headers (e.g. \"Accept-Language: fr\\nETag: 123\")",
                                "--auth-type":"AUTH..  HTTP authentication type (Basic, Digest, NTLM or Cert)",
                                "--auth-cred":"AUTH..  HTTP authentication credentials (name:password)",
                                "--auth-cert":"AUTH..  HTTP authentication certificate (key_file,cert_file)",
                                "--proxy":"PROXY       Use a proxy to connect to the target URL",
                                "--proxy-cred":"PRO..  Proxy authentication credentials (name:password)",
                                "--proxy-file":"PRO..  Load proxy list from a file",
                                "--ignore-proxy":"      Ignore system default proxy settings",
                                "--tor":"               Use Tor anonymity network",
                                "--tor-port":"TORPORT  Set Tor proxy port other than default",
                                "--tor-type":"TORTYPE  Set Tor proxy type (HTTP (default), SOCKS4 or SOCKS5)",
                                "--check-tor":"        Check to see if Tor is used properly",
                                "--delay":"DELAY       Delay in seconds between each HTTP request",
                                "--timeout":"TIMEOUT   Seconds to wait before timeout connection (default 30)",
                                "--retries":"RETRIES   Retries when the connection timeouts (default 3)",
                                "--randomize":"RPARAM  Randomly change value for given parameter(s)",
                                "--safe-url":"SAFURL   URL address to visit frequently during testing",
                                "--safe-freq":"SAFREQ  Test requests between two visits to a given safe URL",
                                "--skip-urlencode":"    Skip URL encoding of payload data",
                                "--force-ssl":"         Force usage of SSL/HTTPS",
                                "--hpp":"               Use HTTP parameter pollution",
                                "--eval":"EVALCODE     Evaluate provided Python code before the request (e.g.",
                                "-o":"-o                  Turn on all optimization switches",
                                "--predict-output":"    Predict common queries output",
                                "--keep-alive":"        Use persistent HTTP(s) connections",
                                "--null-connection":"   Retrieve page length without actual HTTP response body",
                                "--threads":"THREADS   Max number of concurrent HTTP(s) requests (default 1)",
                                "-p":"-p TESTPARAMETER    Testable parameter(s)",
                                "--skip":"SKIP         Skip testing for given parameter(s)",
                                "--dbms":"DBMS         Force back-end DBMS to this value",
                                "--dbms-cred":"DBMS..  DBMS authentication credentials (user:password)",
                                "--os":"OS             Force back-end DBMS operating system to this value",
                                "--invalid-bignum":"    Use big numbers for invalidating values",
                                "--invalid-logical":"   Use logical operations for invalidating values",
                                "--no-cast":"           Turn off payload casting mechanism",
                                "--no-escape":"         Turn off string escaping mechanism",
                                "--prefix":"PREFIX     Injection payload prefix string",
                                "--suffix":"SUFFIX     Injection payload suffix string",
                                "--tamper":"TAMPER     Use given script(s) for tampering injection data",
                                "--level":"LEVEL       Level of tests to perform (1-5, default 1)",
                                "--risk":"RISK         Risk of tests to perform (0-3, default 1)",
                                "--string":"STRING     String to match when query is evaluated to True",
                                "--not-string":"NOT..  String to match when query is evaluated to False",
                                "--regexp":"REGEXP     Regexp to match when query is evaluated to True",
                                "--code":"CODE         HTTP code to match when query is evaluated to True",
                                "--text-only":"        Compare pages based only on the textual content",
                                "--titles":"Compare pages based only on their titles",
                                "--technique":"TECH    SQL injection techniques to use (default \"BEUSTQ\")",
                                "--time-sec":"TIMESEC  Seconds to delay the DBMS response (default 5)",
                                "--union-cols":"UCOLS  Range of columns to test for UNION query SQL injection",
                                "--union-char":"UCHAR  Character to use for bruteforcing number of columns",
                                "--union-from":"UFROM  Table to use in FROM part of UNION query SQL injection",
                                "--dns-domain":"DNS..  Domain name used for DNS exfiltration attack",
                                "--second-order":"S..  Resulting page URL searched for second-order response",
                                "-f,":"-f, --fingerprint   Perform an extensive DBMS version fingerprint",
                                "-a,":"-a, --all           Retrieve everything",
                                "-b,":"-b, --banner        Retrieve DBMS banner",
                                "--current-user":"     Retrieve DBMS current user",
                                "--current-db":"        Retrieve DBMS current database",
                                "--hostname":"          Retrieve DBMS server hostname",
                                "--is-dba":"            Detect if the DBMS current user is DBA",
                                "--users":"             Enumerate DBMS users",
                                "--passwords":"         Enumerate DBMS users password hashes",
                                "--privileges":"Enumerate DBMS users privileges",
                                "--roles":"Enumerate DBMS users roles",
                                "--dbs":"Enumerate DBMS databases",
                                "--tables":"Enumerate DBMS database tables",
                                "--columns":"Enumerate DBMS database table columns",
                                "--schema":"Enumerate DBMS schema",
                                "--count":"Retrieve number of entries for table(s)",
                                "--dump":"Dump DBMS database table entries",
                                "--dump-all":"Dump all DBMS databases tables entries",
                                "--search":"Search column(s), table(s) and/or database name(s)",
                                "--comments":"Retrieve DBMS comments",
                                "-D":"DB               DBMS database to enumerate",
                                "-T":"TBL              DBMS database table to enumerate",
                                "-C":"COL              DBMS database table column to enumerate",
                                "-U":"USER             DBMS user to enumerate",
                                "--exclude-sysdbs":"Exclude DBMS system databases when enumerating tables",
                                "--start":"LIMITSTART  First query output entry to retrieve",
                                "--stop":"LIMITSTOP    Last query output entry to retrieve",
                                "--first":"FIRSTCHAR   First query output word character to retrieve",
                                "--last":"LASTCHAR     Last query output word character to retrieve",
                                "--sql-query":"QUERY   SQL statement to be executed",
                                "--sql-shell":"Prompt for an interactive SQL shell",
                                "--sql-file":"SQLFILE  Execute SQL statements from given file(s)",
                                "--common-tables":"Check existence of common tables",
                                "--common-columns":"Check existence of common columns",
                                "User-defined":"User-defined function injection:",
                                "--udf-inject":"Inject custom user-defined functions",
                                "--shared-lib":"SHLIB  Local path of the shared library",
                                "--file-read":"RFILE   Read a file from the back-end DBMS file system",
                                "--file-write":"WFILE  Write a local file on the back-end DBMS file system",
                                "--file-dest":"DFILE   Back-end DBMS absolute filepath to write to",
                                "--os-cmd":"OSCMD      Execute an operating system command",
                                "--os-shell":"Prompt for an interactive operating system shell",
                                "--os-pwn":"Prompt for an OOB shell, meterpreter or VNC",
                                "--os-smbrelay":"One click prompt for an OOB shell, meterpreter or VNC",
                                "--os-bof":"Stored procedure buffer overflow exploitation",
                                "--priv-esc":"Database process user privilege escalation",
                                "--msf-path":"MSFPATH  Local path where Metasploit Framework is installed",
                                "--tmp-path":"TMPPATH  Remote absolute path of temporary files directory",
                                "--reg-read":"Read a Windows registry key value",
                                "--reg-add":"Write a Windows registry key value data",
                                "--reg-del":"Delete a Windows registry key value",
                                "--reg-key":"REGKEY    Windows registry key",
                                "--reg-value":"REGVAL  Windows registry key value",
                                "--reg-data":"REGDATA  Windows registry key value data",
                                "--reg-type":"REGTYPE  Windows registry key value type",
                                "-s":"-s SESSIONFILE      Load session from a stored (.sqlite) file",
                                "-t":"-t TRAFFICFILE      Log all HTTP traffic into a textual file",
                                "--batch":"--batch             Never ask for user input, use the default behaviour",
                                "--charset":"CHARSET   Force character encoding used for data retrieval",
                                "--crawl":"CRAWLDEPTH  Crawl the website starting from the target URL",
                                "--csv-del":"CSVDEL    Delimiting character used in CSV output (default \",\")",
                                "--dump-format":"DU..  Format of dumped data (CSV (default), HTML or SQLITE)",
                                "--eta":"Display for each output the estimated time of arrival",
                                "--flush-session":"Flush session files for current target",
                                "--forms":"Parse and test forms on target URL",
                                "--fresh-queries":"Ignore query results stored in session file",
                                "--hex":"Use DBMS hex function(s) for data retrieval",
                                "--output-dir":"ODIR   Custom output directory path",
                                "--parse-errors":"Parse and display DBMS error messages from responses",
                                "--pivot-column":"P..  Pivot column name",
                                "--save":"Save options to a configuration INI file",
                                "--scope":"SCOPE       Regexp to filter targets from provided proxy log",
                                "--test-filter":"TE..  Select tests by payloads and/or titles (e.g. ROW)",
                                "--update":"Update sqlmap",
                                "-z":"MNEMONICS        Use short mnemonics (e.g. \"flu,bat,ban,tec=EU\")",
                                "--alert":"ALERT       Run shell command(s) when SQL injection is found",
                                "--answers":"ANSWERS   Set question answers (e.g. \"quit=N,follow\")",
                                "--beep":"Make a beep sound when SQL injection is found",
                                "--check-waf":"Heuristically check for WAF/IPS/IDS protection",
                                "--cleanup":"Clean up the DBMS from sqlmap specific UDF and tables",
                                "--dependencies":"Check for missing (non-core) sqlmap dependencies",
                                "--disable-coloring":"Disable console output coloring",
                                "--gpage":"GOOGLEPAGE  Use Google dork results from specified page number",
                                "--identify-waf":"Make a through testing for a WAF/IPS/IDS protection",
                                "--mobile":"Imitate smartphone through HTTP User-Agent header",
                                "--page-rank":"Display page rank (PR) for Google dork results",
                                "--purge-output":"Safely remove all content from output directory",
                                "--smart":"Conduct through tests only if positive heuristic(s)",
                                "--wizard":"Simple wizard interface for beginner users",
                            }        
    class HTTPRequest(BaseHTTPRequestHandler):
        def __init__(self, request_text):
            self.rfile = StringIO(request_text)
            self.raw_requestline = self.rfile.readline()
            self.error_code = self.error_message = None
            self.parse_request()
    
        def send_error(self, code, message):
            self.error_code = code
            self.error_message = message
        
    def hashKey(self,key):
        key = key.encode(UNICODE_ENCODING)                                             
        print "otra Key:" + str(key)
        retVal = int(hashlib.md5(key).hexdigest()[:8], 16)
        return retVal
    
    def hashDBRetrieve(self,key, unserialize=False, db=False):
        """
        Helper function for restoring session data from HashDB
        """
    
        key = "%s%s%s" % (self.url or "%s%s" % (self.hostname, self.port), key, HASHDB_MILESTONE_VALUE)
        retVal=""
        
        hash_ = self.hashKey(key)
        print "hash_" + str(hash_) + "key=" + key
        if not retVal:
            while True:
                try:
                    for row in db.execute("SELECT value FROM storage WHERE id=?", (hash_,)):
                        retVal = row[0]
                except sqlite3.OperationalError, ex:
                    if not 'locked' in ex.message:
                        raise
                else:
                    break
        return retVal if not unserialize else self.base64unpickle(retVal)    
    
    
    def base64decode(self,value):
        """
        Decodes string value from Base64 to plain format
    
        >>> base64decode('Zm9vYmFy')
        'foobar'
        """
    
        return value.decode("base64")
    
    def base64encode(self,value):
        """
        Encodes string value from plain to Base64 format
    
        >>> base64encode('foobar')
        'Zm9vYmFy'
        """
    
        return value.encode("base64")[:-1].replace("\n", "")
    
    def base64unpickle(self,value):
        """
        Decodes value from Base64 to plain format and deserializes (with pickle) its content
    
        >>> base64unpickle('gAJVBmZvb2JhcnEALg==')
        'foobar'
        """
        if value:
            return pickle.loads(self.base64decode(value))
    
    
    def xmlvalue(self,db,name,value="query"):
    
        filepath = "%s" % os.path.join(current_path, "plugins/repo/sqlmap/queries.xml")
        with open(filepath,"r") as f:
            try:
                tree = ET.fromstring(f.read())
            except SyntaxError, err:
                print "SyntaxError: %s. %s" % (err, filepath)
                return None
    
        for node in tree.findall("dbms[@value='"+db+"']/"+name+""):
            return node.attrib[value]

    def getuser(self,data):
        users = re.findall('database management system users \[[\d]+\]:\r\n(.*?)\r\n\r\n',data, re.S)
        if users:
            return map((lambda x: x.replace("[*] ","")), users[0].split("\r\n"))
    
    def getdbs(self,data):
        dbs = re.findall('available databases \[[\d]+\]:\r\n(.*?)\r\n\r\n',data, re.S)
        if dbs:
            return map((lambda x: x.replace("[*] ","")), dbs[0].split("\r\n"))
    def getpassword(self,data):
        users={}
        password = re.findall('database management system users password hashes:\r\n(.*?)\r\n\r\n',data, re.S)
        if password:
            for p in password[0].split("[*] ")[1::]:
                               
                user=re.findall("^(.*?) \[",p)[0]
                mpass=re.findall("password hash: (.*?)$",p, re.S)
                mpass=map((lambda x: re.sub(r"[ \r\n]", "", x)), mpass[0].split("password hash: "))
                users[user]=mpass
        return users
    
    def getAddress(self, hostname):
        """
        Returns remote IP address from hostname.
        """
        try:
            return socket.gethostbyname(hostname)
        except socket.error, msg:
                                                        
            return self.hostname
        
    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
            
                                                                          
        password = self.getpassword(output)
        webserver = re.search("web application technology: (.*?)\n",output)
        if webserver:
            webserver=webserver.group(1)
        users = self.getuser(output)
        print users
        dbs = self.getdbs(output)
        
                                         

        db = Database(self._output_path)
        db.connect()
        
                                                                    
                                                                                         
        absFilePaths = self.hashDBRetrieve(HASHDB_KEYS.KB_ABS_FILE_PATHS, True, db)
        tables = self.hashDBRetrieve(HASHDB_KEYS.KB_BRUTE_TABLES, True, db)
        columns = self.hashDBRetrieve(HASHDB_KEYS.KB_BRUTE_COLUMNS, True, db)
        xpCmdshellAvailable = self.hashDBRetrieve(HASHDB_KEYS.KB_XP_CMDSHELL_AVAILABLE, True, db)
        dbms_version = self.hashDBRetrieve(HASHDB_KEYS.DBMS, False, db)        
        
        os = self.hashDBRetrieve(HASHDB_KEYS.OS, False, db)           
        
        self.ip=self.getAddress(self.hostname)

        dbms=str(dbms_version.split(" ")[0])

        h_id = self.createAndAddHost(self.ip)
        i_id = self.createAndAddInterface(h_id, name=self.ip, ipv4_address=self.ip,hostname_resolution=self.hostname)
        s_id = self.createAndAddServiceToInterface(h_id, i_id, self.protocol,
                                            "tcp",
                                            [self.port],
                                            status="open",
                                            version=webserver)
        n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
        n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,self.hostname,"")
        
        db_port=self.db_port[dbms]
        
        s_id2 = self.createAndAddServiceToInterface(h_id, i_id,
                                                    name=dbms ,
                                                    protocol="tcp",
                                                    status="down",
                                                    version=str(dbms_version),
                                                    ports=[str(db_port)],
                                                    description="DB detect by SQLi")
        if users:
            for v in users:
                self.createAndAddCredToService(h_id,s_id2,v,"")
                
        if password:
            for k,v in password.iteritems():
                for p in v:
                    self.createAndAddCredToService(h_id,s_id2,k,p)
                    
        if absFilePaths:
            n_id2 = self.createAndAddNoteToService(h_id,s_id2,"sqlmap.absFilePaths",str(absFilePaths))
        if tables:
            n_id2 = self.createAndAddNoteToService(h_id,s_id2,"sqlmap.brutetables",str(tables))
        if columns:
            n_id2 = self.createAndAddNoteToService(h_id,s_id2,"sqlmap.brutecolumns",str(columns))
        if xpCmdshellAvailable:
            n_id2 = self.createAndAddNoteToService(h_id,s_id2,"sqlmap.xpCmdshellAvailable",str(xpCmdshellAvailable))
            
        for inj in self.hashDBRetrieve(HASHDB_KEYS.KB_INJECTIONS, True,db) or []:
            print inj
            print inj.dbms    
            print inj.dbms_version           
            print inj.place        
            print inj.os       
            print inj.parameter                
            
            dbversion = self.hashDBRetrieve(self.xmlvalue(dbms,"banner"), False, db)
            user = self.hashDBRetrieve(self.xmlvalue(dbms,"current_user"), False, db)
            dbname = self.hashDBRetrieve(self.xmlvalue(dbms,"current_db"), False, db)
            hostname = self.hashDBRetrieve(self.xmlvalue(dbms,"hostname"), False, db)
            
            if user:
                n_id2 = self.createAndAddNoteToService(h_id,s_id2,"db.user",user)
            if dbname:
                n_id2 = self.createAndAddNoteToService(h_id,s_id2,"db.name",dbname)
            if hostname:
                n_id2 = self.createAndAddNoteToService(h_id,s_id2,"db.hostname",hostname)
            if dbversion:
                n_id2 = self.createAndAddNoteToService(h_id,s_id2,"db.version",dbversion)
            if dbs:
                n_id2 = self.createAndAddNoteToService(h_id,s_id2,"db.databases",str(dbs))
            
            for k,v in inj.data.items():
                v_id = self.createAndAddVulnWebToService(h_id, s_id,
                                                         website=self.hostname,
                                                         name=inj.data[k]['title'],
                                                         desc="Payload:" + str(inj.data[k]['payload'])+
                                                        "\nVector:"+ str(inj.data[k]['vector'])+
                                                        "\nParam type:" + str(self.ptype[inj.ptype]),
                                                         ref=[],                
                                                         pname=inj.parameter,
                                                         method=inj.place,
                                                         params=self.params,
                                                         path=self.fullpath)
                                                         
                                             
                                                  
                                  
                          

    def processCommandString(self, username, current_path, command_string):
        
             
        
        parser = argparse.ArgumentParser(conflict_handler='resolve')
        
        parser.add_argument('-h')
        parser.add_argument('-u')
        parser.add_argument('-s')
        parser.add_argument('-r')
        
                                          
        try:
            args, unknown = parser.parse_known_args(shlex.split(re.sub(r'\-h|\-\-help', r'', command_string)))
        except SystemExit:
            pass        
        
        if args.r:         
            with open(args.r, 'r') as f:
                request = self.HTTPRequest(f.read())
                args.u="http://"+request.headers['host']+ request.path
                f.close()
        
        if args.u:      
            reg = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", args.u)
            self.protocol = reg.group(1)
            self.hostname = reg.group(4)
            self.path ="/"
            if self.protocol == 'https':
                self.port=443
            if reg.group(11) is not None:
                self.port = reg.group(11)
            
            if reg.group(12) is not None:
                tmp=re.search("/(.*)\?(.*?$)",reg.group(12))
                self.path = "/"+tmp.group(1)
                self.params=tmp.group(2)
            
            self.url=self.protocol+"://"+self.hostname+":"+self.port + self.path
            self.fullpath=self.url+"?"+self.params
            self._output_path="%s%s" % (os.path.join(self.data_path, "sqlmap_output-"),
                                        re.sub(r'[\n\/]', r'', args.u.encode("base64")[:-1]))
        
        if not args.s:
            return "%s -s %s\n" % (command_string,self._output_path)            
        

    def setHost(self):
        pass


def createPlugin():
    return SqlmapPlugin()


########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os, socket
import pprint
current_path = os.path.abspath(os.getcwd())

__author__     = "Facundo de Guzmn, Esteban Guillardoy"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Facundo de Guzmn", "Esteban Guillardoy"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Facundo de Guzmn"
__email__      = "fdeguzman@ribadeohacklab.com.ar"
__status__     = "Development"

                           
                                                                     
                      

class TelnetRouterPlugin(core.PluginBase):
    """
    This plugin handles telnet command.
    Basically detects if user was able to connect to a device
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Telnet"
        self.name            = "Telnet"
        self.plugin_version         = "0.0.1"
        self.version            ="0.17"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^telnet.*?')
        self._host_ip        = None
        self._host           = []
        self._port        = "23"
        self._completition = {
            "":"telnet [-468ELadr] [-S tos] [-b address] [-e escapechar] [-l user] [-n tracefile] [host [port]]",
            "-4":"Force IPv4 address resolution.",
            "-6":"Force IPv6 address resolution.",
            "-8":"Request 8-bit operation. This causes an attempt to negotiate the TELNET BINARY option for both input and output. By default telnet is not 8-bit clean.",
            "-E":"Disables the escape character functionality; that is, sets the escape character to ``no character''.",
            "-L":"Specifies an 8-bit data path on output.  This causes the TELNET BINARY option to be negotiated on just output.",
            "-a":"Attempt automatic login.  Currently, this sends the user name via the USER variable of the ENVIRON option if supported by the remote system. The username is retrieved via getlogin(3).",
            "-b":"-b &lt;address&gt; Use bind(2) on the local socket to bind it to a specific local address.",
            "-d":"Sets the initial value of the debug toggle to TRUE.",
            "-r":"Emulate rlogin(1).  In this mode, the default escape character is a tilde. Also, the interpretation of the escape character is changed: an escape character followed by a dot causes telnet to disconnect from the remote host. A ^Z instead of a dot suspends telnet, and a ^] (the default telnet escape character) generates a normal telnet prompt. These codes are accepted only at the beginning of a line.",
            "-S":"-S &lt;tos&gt;  Sets the IP type-of-service (TOS) option for the telnet connection to the value tos.",
            "-e":"-e &lt;escapechar&gt; Sets the escape character to escapechar. If no character is supplied, no escape character will be used.  Entering the escape character while connected causes telnet to drop to command mode.",
            "-l":"-l &lt;user&gt; Specify user as the user to log in as on the remote system. This is accomplished by sending the specified name as the USER environment variable, so it requires that the remote system support the TELNET ENVIRON option. This option implies the -a option, and may also be used with the open command.",
            "-n":"-n &lt;tracefile&gt; Opens tracefile for recording trace information.  See the set tracefile command below.",
            }

        global current_path

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

    def parseOutputString(self, output, debug = False):

        host_info = re.search(r"Connected to (.+)\.", output)
        
        hostname=host_info.group(1)
        ip_address = self.resolve(hostname)
        
        if host_info is not None:
            h_id = self.createAndAddHost(ip_address)
            i_id = self.createAndAddInterface(h_id, ip_address, ipv4_address=ip_address, hostname_resolution=hostname)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, self._port,
                                               "tcp",
                                               ports = [self._port],
                                               status = "open")
        return True


    def processCommandString(self, username, current_path, command_string):
        
        count_args = command_string.split()
        
        c=count_args.__len__()
        self._port="23"
        if re.search("[\d]+",count_args[c-1]):
            self._port = count_args[c-1]


def createPlugin():
    return TelnetRouterPlugin()

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from plugins import core
import re
import os
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class TheharvesterParser(object):
    """
    The objective of this class is to parse an xml file generated by the theharvester tool.

    TODO: Handle errors.
    TODO: Test theharvester output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param theharvester_filepath A proper simple report generated by theharvester
    """
    def __init__(self, output):
        
        self.items = []
        _hosts, _vhosts = [], []

                                                                                                                                                                                                                      
        mregex = re.search("\[\+\] Hosts found in search engines:[-=\s]+([\w\W]*)\[\+\]", output)
        if mregex is None:
            mregex = re.search("\[\+\] Hosts found in search engines:[-=\s]+([\w\W]*)\n", output)
        mregex2 = re.search("\[\+\] Virtual hosts:[-=\s]+([\w\W]*)\n", output)

        if mregex is None and mregex2 is None:
            return
        
                         
                                                                                         
                                                          
        if mregex:
            _hosts = mregex.group(1).strip().split("\n")
        if mregex2:
            _vhosts = mregex2.group(1).strip().split("\n")
        
        for line in _hosts:
                                                  
            info = line.split(":")
                                                 
            if len(info) > 1:
                item = {'host' : info[1].strip(), 'ip' : info[0].strip()}
                           
                self.items.append(item)
        
        for line in _vhosts:
                                                   
            info = line.split()
            if len(info) > 1:
                item = {'host' : info[1].strip(), 'ip' : info[0].strip()}
                           
                self.items.append(item)


class TheharvesterPlugin(core.PluginBase):
    """
    Example plugin to parse theharvester output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Theharvester"
        self.name            = "Theharvester XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "2.2a"
        self.options         = None
        self._current_output = None
        self._current_path = None
        self._command_regex  = re.compile(r'^(theharvester|sudo theharvester|sudo theHarvester\.py|theHarvester\.py|python theHarvester\.py|\.\/theHarvester\.py).*?')
        self._completition = {
                                "":"Examples:./theharvester.py -d microsoft.com -l 500 -b google",
                                "-d":"Domain to search or company name",
                                "-b":"Data source (google,bing,bingapi,pgp,linkedin,google-profiles,exalead,all)",
                                "-s":"Start in result number X (default 0)",
                                "-v":"Verify host name via dns resolution and search for vhosts(basic)",
                                "-l":"Limit the number of results to work with(bing goes from 50 to 50 results,",
                                "-f":"Save the results into an XML file",
                                "-n": "Perform a DNS reverse query on all ranges discovered",
                                "-c": "Perform a DNS brute force for the domain name",
                                "-t": "Perform a DNS TLD expansion discovery",
                                "-e": "Use this DNS server",
                                "-h": "use SHODAN database to query discovered hosts. google 100 to 100, and pgp doesn't use this option)",
        }

        global current_path
        
                                  


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """
        
        print "este es el output (%s)" % output
            
        if debug:
            parser = TheharvesterParser(output)
        else:
            
            parser = TheharvesterParser(output)


            print len(parser.items)
            for item in parser.items:
                host = []
                if item['host'] != item['ip']:
                    host = [item['host']]
                h_id = self.createAndAddHost(item['ip'])
                i_id = self.createAndAddInterface(h_id, item['ip'], ipv4_address= item['ip'], hostname_resolution=host)


        del parser


    def processCommandString(self, username, current_path, command_string):
        """
        """
        return None


def createPlugin():
    return TheharvesterPlugin()

if __name__ == '__main__':
    parser = TheharvesterParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os, socket
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class W3afXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the w3af tool.

    TODO: Handle errors.
    TODO: Test w3af output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param w3af_xml_filepath A proper xml generated by w3af
    """
    def __init__(self, xml_output):
        self.target = None
        self.port = "80"
        self.host = None

        tree = self.parse_xml(xml_output)
        
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
        bugtype=""
        
                                           
        scaninfo = tree.findall('scaninfo')[0]
        self.target = scaninfo.get('target')
        host = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", self.target)
                            
        self.protocol = host.group(1)
        self.host = host.group(4)
        if self.protocol == 'https':
            self.port=443
        if host.group(11) is not None:
            self.port = host.group(11)
            
        for node in tree.findall('vulnerability'):
            yield Item(node)
        for node in tree.findall('information'):
            yield Item(node)
                                  


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an w3af xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.id=self.node.get('id')
        self.name = self.node.get('name')
        self.url = self.node.get('url')
        self.plugin = self.node.get('plugin')
        self.detail = self.get_text_from_subnode('description')
        self.severity = self.node.get('severity')
        self.method = self.node.get('method')
        self.req = self.resp = ''
        for tx in self.node.findall('http-transactions/http-transaction'):
                                                       
            self.req = tx.find('httprequest/status').text
                                                        
            self.resp = tx.find('httpresponse/status').text
    
    def do_clean(self,value):
        myreturn =""
        if value is not None:
            myreturn = re.sub("\n","",value)
        return myreturn
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class W3afPlugin(core.PluginBase):
    """
    Example plugin to parse w3af output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "W3af"
        self.name            = "W3af XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "1.2"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(w3af|sudo w3af|\.\/w3af).*?')
        self._completition = {
            "":"",
            "-h":"Display this help message.",
            "-p":"-p &lt;profile&gt; Run with the selected &lt;profile&gt;",
            }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "w3af_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):

        parser = W3afXmlParser(output)

        ip = self.resolve(parser.host)
        h_id = self.createAndAddHost(ip)
        i_id = self.createAndAddInterface(h_id, ip, ipv4_address=ip, hostname_resolution=[parser.host])
        s_id = self.createAndAddServiceToInterface(h_id, i_id, "http",
                                            "tcp",
                                            ports = [parser.port],
                                            status = "open")

        n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
        n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,parser.host,"")

        for item in parser.items:
            v_id = self.createAndAddVulnWebToService(h_id, s_id, item.name,
                                                     item.detail, website=parser.host, severity=item.severity,
                                                     method=item.method, request=item.req, response=item.resp)
        del parser
        
                      
                                             
                    


    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return W3afPlugin()

if __name__ == '__main__':
    parser = W3afXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class WapitiXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the wapiti tool.

    TODO: Handle errors.
    TODO: Test wapiti output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param wapiti_xml_filepath A proper xml generated by wapiti
    """
    def __init__(self, xml_output):

        tree = self.parse_xml(xml_output)
        
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
        bugtype=""
        
                                           
        bug_typelist = tree.findall('bugTypeList')[0]
        for bug_type in bug_typelist.findall('bugType'):
                                           
            bugtype=bug_type.get('name')
            
            bug_list = bug_type.findall('bugList')[0]
            for item_bug in bug_list.findall('bug'):
                yield Item(item_bug,bugtype)
                                  
            
"""
<bugTypeList>
<bugType name="File Handling"><bugList><bug level="1"><url>
                        http://www.saludactiva.org.ar/index.php?id=http%3A%2F%2Fwww.google.fr%2F
                    </url><parameter>
                        id=http%3A%2F%2Fwww.google.fr%2F
                    </parameter><info>
                        Warning include() (id)
                    </info>
"""
                


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 


class Item(object):
    """
    An abstract representation of a Item

    TODO: Consider evaluating the attributes lazily
    TODO: Write what's expected to be present in the nodes
    TODO: Refactor both Host and the Port clases?

    @param item_node A item_node taken from an wapiti xml tree
    """
    def __init__(self, item_node,bugtype):
        self.node = item_node

        self.bugtype=bugtype
        self.buglevel=self.node.get('level')
        self.url = self.do_clean(self.get_text_from_subnode('url'))
        self.parameter = self.do_clean(self.get_text_from_subnode('parameter'))
        self.info = self.do_clean(self.get_text_from_subnode('info'))
    
    
    def do_clean(self,value):
        myreturn =""
        if value is not None:
            myreturn = re.sub("\n","",value)
        return myreturn
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class WapitiPlugin(core.PluginBase):
    """
    Example plugin to parse wapiti output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Wapiti"
        self.name            = "Wapiti XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "2.2.1"
        self.options         = None
        self._current_output = None
        self.protocol = None
        self.host = None
        self.port = "80"
        self._command_regex  = re.compile(r'^(python wapiti|wapiti|sudo wapiti|sudo wapiti\.py|wapiti\.py|python wapiti\.py|\.\/wapiti\.py|wapiti|\.\/wapiti|python wapiti|python \.\/wapiti).*?')
        self._completition = {
                                "":"python wapiti.py http://server.com/base/url/ [options]",
                                "-s":"&lt;url&gt; ",
                                "--start":"&lt;url&gt; ",
                                "-x":"&lt;url&gt; ",
                                "--exclude":"&lt;url&gt; ",
                                "-p":"&lt;url_proxy&gt; ",
                                "--proxy":"&lt;url_proxy&gt; ",
                                "-c":" -c &lt;cookie_file&gt; ",
                                "--cookie":"&lt;cookie_file&gt; ",
                                "-t":"&lt;timeout&gt; ",
                                "--timeout":"&lt;timeout&gt; ",
                                "-a":"&lt;login%password&gt; ",
                                "--auth":"&lt;login%password&gt; ",
                                "-r":"&lt;parameter_name&gt; ",
                                "--remove":"&lt;parameter_name&gt; ",
                                "-n":"&lt;limit&gt; ",
                                "--nice":"&lt;limit&gt; ",
                                "-m":"&lt;module_options&gt; Set the modules and HTTP methods to use for attacks. Example: -m \"-all,xss:get,exec:post\"",
                                "--module":"&lt;module_options&gt; Set the modules and HTTP methods to use for attacks. Example: -m \"-all,xss:get,exec:post\"",
                                "-u":"Use color to highlight vulnerables parameters in output",
                                "--underline":"Use color to highlight vulnerables parameters in output",
                                "-v":"&lt;level&gt; ",
                                "--verbose":"&lt;level&gt; ",
                                "-b":"&lt;scope&gt;",
                                "--scope":"&lt;scope&gt;",
                                "-f":"&lt;type_file&gt; ",
                                "--reportType":"&lt;type_file&gt; ",
                                "-o":"&lt;output_file&gt; ",
                                "--output":"&lt;output_file&gt; ",
                                "-i":"&lt;file&gt;",
                                "--continue":"&lt;file&gt;",
                                "-k":"&lt;file&gt;",
                                "--attack":"&lt;file&gt;",
                                "-h":"To print this usage message",
                                "--help":"To print this usage message",
        }

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "wapiti_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        self._output_file_path="/root/dev/faraday/trunk/src/report/wapiti2.3.0_abaco.xml"
        if debug:
            parser = WapitiXmlParser(output)
        else:
            if not os.path.exists(self._output_file_path):
                return False

            parser = WapitiXmlParser(self._output_file_path)

                                           
        """
                self.bugtype=bugtype
        self.buglevel=self.node.get('level')
        self.url = self.get_text_from_subnode('url')
        self.parameter = self.get_text_from_subnode('parameter')
        self.info = self.get_text_from_subnode('info')
        """
        
        h_id = self.createAndAddHost(self.host)
        i_id = self.createAndAddInterface(h_id, self.host, ipv4_address=self.host)
        i=1;
        for item in parser.items:
            mport = "%s%i" % (self.port,i)
            print "estoy recorriendo algo ? (%s) (%s) (%s) (%s) (%s) (%s)" % (item.url,item.info,item.parameter,self.port,self.protocol,self.host)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, mport,
                                                "tcp",
                                                [mport],
                                                status =  "(%s) (%s)" % (item.bugtype,item.url),
                                                version = item.parameter,
                                                description = item.info)        
            i=i+1

        del parser
        
                      
                                             
                    

    xml_arg_re = re.compile(r"^.*(-oX\s*[^\s]+).*$")

                                                                             
    def processCommandString(self, username, current_path, command_string):
        """
        Adds the -oX parameter to get xml output to the command string that the
        user has set.
        """
        host = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", command_string)
                            
        self.protocol = host.group(1)
        self.host = host.group(4)
        if host.group(11) is not None:
            self.port = host.group(11)
        if self.protocol == 'https':
            self.port=443
        
        print "host = %s, port = %s" % (self.host,self.port)

        arg_match = self.xml_arg_re.match(command_string)

                                                                         
                                                                            
        return "%s -o %s -f xml \n" % (command_string,self._output_file_path)
        

    def setHost(self):
        pass


def createPlugin():
    return WapitiPlugin()

if __name__ == '__main__':
    parser = WapitiXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys


current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class WebfuzzerParser(object):
    """
    The objective of this class is to parse an xml file generated by the webfuzzer tool.

    TODO: Handle errors.
    TODO: Test webfuzzer output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param webfuzzer_filepath A proper output generated by webfuzzer
    """
    def __init__(self, webfuzzer_filepath):
        self.filepath = webfuzzer_filepath

        with open(self.filepath,"r") as f:
            try:
                data = f.read()
                f.close()
                m = re.search("Scan of ([\w.]+):([\d]+) \[([/\w]+)\] \(([\w.]+)\)", data)
                self.hostname=m.group(1)
                self.port=m.group(2)
                self.uri=m.group(3)
                self.ipaddress=m.group(4)
                                                                                               
                m = re.search("Server header:\n\n([\w\W]+)\n\n\n", data)
                self.header = m.group(1)
                                                 
                
                self.items = []

                pattern = r'\((POST|GET)\): ([\w\W]*?) \]--'
                                           
                for m in re.finditer(pattern, data, re.DOTALL):
                                                                         
                                      
                    method = m.group(1)
                    info = re.search("^([\w\W]+)\(([\w\W]+)\)\n--\[ ([\w\W]+)$",m.group(2))
                                                                                                       
                    vuln = {'method' : m.group(1), 'desc' : info.group(1) , 'url':info.group(2), 'resp':info.group(3) }
                    self.items.append(vuln)
                    
                    
            except SyntaxError, err:
                print "SyntaxError: %s. %s" % (err, filepath)
                return None




class WebfuzzerPlugin(core.PluginBase):
    """
    Example plugin to parse webfuzzer output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Webfuzzer"
        self.name            = "Webfuzzer Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "0.2.0"
        self.options         = None
        self._current_output = None
        self.host = None
        self._command_regex  = re.compile(r'^(sudo webfuzzer|webfuzzer|\.\/webfuzzer).*?')
        self._completition = {  '':'__Usage: ./webfuzzer -G|-P URL [OPTIONS]',
                                '-G':'<url>	get this as starting url (with parameters)',
                                '-P':'<url>	post this as starting url (with parameters)',
                                '-x':'html output (txt default)',
                                '-c':'use cookies',
                                '-C':'<cookies>	set this cookie(s) **',
                                '-s':'check for sql, asp, vb, php errors (default)',
                                '-d':'check for directory traversal *',
                                '-p':'check for insecure perl open or xss *',
                                '-e':'check for execution through shell escapes or xss *',
                                '-a':'set all of the above switches on *',
        }

        self._output_path = None


    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

                                                              

        
                                                              
        if self._output_path is None:
            return False
        else:
            if not os.path.exists(self._output_path):
                return False

            parser = WebfuzzerParser(self._output_path)

            h_id = self.createAndAddHost(parser.ipaddress)

            i_id = self.createAndAddInterface(h_id, parser.ipaddress, ipv4_address=parser.ipaddress,hostname_resolution=parser.hostname)

            first=True
            for item in parser.items:
                if first:
                    s_id = self.createAndAddServiceToInterface(h_id, i_id, parser.port,
                                                       "tcp",
                                                       ports = [parser.port])
                    first=False
                
                v_id = self.createAndAddVulnWebToService(h_id,s_id,name=item['desc'],
                                                         path = item['url'],response = item['resp'],
                                                       method = item['method'], website=parser.hostname)
            
            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,parser.hostname,"")

        del parser
        
        if not debug:
            os.remove(self._output_path)
        return True


    def processCommandString(self, username, current_path, command_string):
        """
        """
        host = re.search("\-([G|P]) ([\w\.\-]+)", command_string)
        
        if host is not None:
            self.host = host.group(2)
            self._output_path = current_path + "/"+ self.host + ".txt"
        return None



def createPlugin():
    return WebfuzzerPlugin()

if __name__ == '__main__':
    parser = WebfuzzerParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from plugins import core
from model import api
import re
import os, socket
import pprint
current_path = os.path.abspath(os.getcwd())

__author__     = "Facundo de Guzmn, Esteban Guillardoy"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Facundo de Guzmn", "Esteban Guillardoy"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Federico Kirschbaum"
__email__      = "fedek@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class CmdWhoisPlugin(core.PluginBase):
    """
    This plugin handles whois command.
    Basically detects if user was able to connect to a device
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "whois"
        self.name            = "Whois"
        self.plugin_version         = "0.0.1"
        self.version            = "5.0.20"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^whois.*?')
        self._host_ip        = None
        self._info           = 0;
        self._completition = {
            "":"whois [OPTION]... OBJECT...",
            "-l":"one level less specific lookup [RPSL only]",
            "-L":"find all Less specific matches",
            "-m":"find first level more specific matches",
            "-M":"find all More specific matches",
            "-c":"find the smallest match containing a mnt-irt attribute",
            "-x":"exact match [RPSL only]",
            "-d":"return DNS reverse delegation objects too [RPSL only]",
            "-i":"-i ATTR[,ATTR]...      do an inverse lookup for specified ATTRibutes",
            "-T":"-T TYPE[,TYPE]...      only look for objects of TYPE",
            "-K":"only primary keys are returned [RPSL only]",
            "-r":"turn off recursive lookups for contact information",
            "-R":"force to show local copy of the domain object even if it contains referral",
            "-a":"search all databases",
            "-s":"-s SOURCE[,SOURCE]...  search the database from SOURCE",
            "-g":"-g SOURCE:FIRST-LAST   find updates from SOURCE from serial FIRST to LAST",
            "-t":"-t TYPE request template for object of TYPE",
            "-v":"-v TYPE request verbose template for object of TYPE",
            "-q":"-q [version|sources|types]  query specified server info [RPSL only]",
            "-F":"fast raw output (implies -r)",
            "-h":"-h HOST connect to server HOST",
            "-p":"-p PORT connect to PORT",
            "-H":"hide legal disclaimers",
            "--verbose":"explain what is being done",
            "--help":"display this help and exit",
            "--version":"output version information and exit",
            }

        global current_path

                                  

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

    def parseOutputString(self, output, debug = False):
        matches = re.findall("Name Server:\s*(.*)\s*",output)
        for m in matches:
            m = m.strip()
            ip = self.resolve(m)
            h_id = self.createAndAddHost(ip, "os unknown")
            i_id = self.createAndAddInterface(h_id, ip, "00:00:00:00:00:00", ip, hostname_resolution=[m])
        return True    

    def processCommandString(self, username, current_path, command_string):
        """
        """
        return None

def createPlugin():
    return CmdWhoisPlugin()

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"


class X1XmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the x1 tool.

    TODO: Handle errors.
    TODO: Test x1 output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param x1_xml_filepath A proper xml generated by x1
    """
    def __init__(self, xml_output):
        
        tree = self.parse_xml(xml_output)
        if tree:
            self.items = [data for data in self.get_items(tree)]
        else:
            self.items = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
                                                   
        for node in tree.findall('results/landscape/system/component'):
            yield Item(node)

                 


class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an x1 xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.name = self.get_text_from_subnode('name')
        self.host = self.get_text_from_subnode('host')
        self.vclass = self.get_text_from_subnode('class')
        
        self.connector = self.node.find('connector')
        self.cname = self.connector.get('name')
        data=self.cname.split("/")
        self.port,self.protocol=data[0].split()
        self.srvname=data[1]
        

        self.cresults=self.getResults(self.connector)
        self.results=self.getResults(self.node)
    
    def getResults(self, tree):
        """
        :param tree:
        """
        for self.issues in tree.findall('modResults/moduleResult'):
            yield Results(self.issues)
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class Results():
    def __init__(self, issue_node):
        self.node = issue_node
        self.id = self.get_text_from_subnode('id')
        self.name = self.get_text_from_subnode('name')
        
        self.category = self.get_text_from_subnode('category')
        self.trendingStatus = self.get_text_from_subnode('trendingStatus')
        self.description = self.get_text_from_subnode('description')
        self.risk = self.get_text_from_subnode('risk')
        self.resolution = self.get_text_from_subnode('solution')
        self.ref=[]
        for r in issue_node.findall('refs/reference'):
                                    
                                                       
            self.ref.append(r.get('type')+"-"+r.get('text'))

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

class X1Plugin(core.PluginBase):
    """
    Example plugin to parse x1 output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "X1"
        self.name            = "Onapsis X1 XML Output Plugin"
        self.plugin_version         = "0.0.1"
        self.version   = "Onapsis X1 2.56"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self._command_regex  = re.compile(r'^(sudo x1|\.\/x1).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "x1_output-%s.xml" % self._rid)

    def parseOutputString(self, output, debug = False):
        
                                                                   
        parser = X1XmlParser(output)
        for item in parser.items:
            h_id = self.createAndAddHost(item.host,item.name)
            i_id = self.createAndAddInterface(h_id, item.host,ipv4_address=item.host, hostname_resolution=item.vclass)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, item.srvname,
                                                item.protocol,
                                                ports = [str(item.port)],
                                                status = "open")                        
            for v in item.results:
                desc=v.description
                desc+="\nSolution: "+v.resolution if v.resolution else ""
                v_id=self.createAndAddVulnToService(h_id, s_id,v.name,desc=desc,
                                                    ref=v.ref,severity=v.risk)

            for v in item.cresults:
                desc=v.description
                desc+="\nSolution: "+v.resolution if v.resolution else ""
                v_id=self.createAndAddVulnToService(h_id, s_id,v.name,desc=desc,
                                                    ref=v.ref,severity=v.risk)
            
        del parser
        
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return X1Plugin()

if __name__ == '__main__':
    parser = X1XmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = plugin
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from __future__ import with_statement
from plugins import core
from model import api
import re
import os, socket
import pprint
import sys

try:
    import xml.etree.cElementTree as ET
    import xml.etree.ElementTree as ET_ORIG
    ETREE_VERSION = ET_ORIG.VERSION
except ImportError:
    import xml.etree.ElementTree as ET
    ETREE_VERSION = ET.VERSION
                      
ETREE_VERSION = [int(i) for i in ETREE_VERSION.split(".")]

current_path = os.path.abspath(os.getcwd())

__author__     = "Francisco Amato"
__copyright__  = "Copyright (c) 2013, Infobyte LLC"
__credits__    = ["Francisco Amato"]
__license__    = ""
__version__    = "1.0.0"
__maintainer__ = "Francisco Amato"
__email__      = "famato@infobytesec.com"
__status__     = "Development"

                           
                                                                     
                      

class ZapXmlParser(object):
    """
    The objective of this class is to parse an xml file generated by the zap tool.

    TODO: Handle errors.
    TODO: Test zap output version. Handle what happens if the parser doesn't support it.
    TODO: Test cases.

    @param zap_xml_filepath A proper xml generated by zap
    """
    def __init__(self, xml_output):
        tree = self.parse_xml(xml_output)
        
        if tree:
            self.sites = [data for data in self.get_items(tree)]
        else:
            self.sites = []
            

    def parse_xml(self, xml_output):
        """
        Open and parse an xml file.

        TODO: Write custom parser to just read the nodes that we need instead of
        reading the whole file.

        @return xml_tree An xml tree instance. None if error.
        """
        try:
            tree = ET.fromstring(xml_output)
        except SyntaxError, err:
            print "SyntaxError: %s. %s" % (err, xml_output)
            return None

        return tree

    def get_items(self, tree):
        """
        @return items A list of Host instances
        """
            
        for node in tree.findall('site'):
            yield Site(node)


                 
def get_attrib_from_subnode(xml_node, subnode_xpath_expr, attrib_name):
    """
    Finds a subnode in the item node and the retrieves a value from it

    @return An attribute value
    """
    global ETREE_VERSION
    node = None
    
    if ETREE_VERSION[0] <= 1 and ETREE_VERSION[1] < 3:
                                                           
        match_obj = re.search("([^\@]+?)\[\@([^=]*?)=\'([^\']*?)\'",subnode_xpath_expr)
        if match_obj is not None:
            node_to_find = match_obj.group(1)
            xpath_attrib = match_obj.group(2)
            xpath_value = match_obj.group(3)
            for node_found in xml_node.findall(node_to_find):
                if node_found.attrib[xpath_attrib] == xpath_value:
                    node = node_found
                    break
        else:
            node = xml_node.find(subnode_xpath_expr)

    else:
        node = xml_node.find(subnode_xpath_expr)

    if node is not None:
        return node.get(attrib_name)

    return None


                 

class Site(object):
    def __init__(self, item_node):
        self.node = item_node
        self.host = self.node.get('host')
        self.ip = self.resolve(self.host)
        self.port = self.node.get('port')
        self.items = []
        for alert in self.node.findall('alerts/alertitem'):
            self.items.append(Item(alert))

    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None

    def resolve(self, host):
        try:
            return socket.gethostbyname(host)
        except:
            pass
        return host

class Item(object):
    """
    An abstract representation of a Item


    @param item_node A item_node taken from an zap xml tree
    """
    def __init__(self, item_node):
        self.node = item_node

        self.id=self.get_text_from_subnode('pluginid')
        self.name = self.get_text_from_subnode('alert')
                                                           
                                                                     
        self.severity = self.get_text_from_subnode('riskcode')
        self.desc = self.get_text_from_subnode('desc')
        self.desc += "\nSolution: " + self.get_text_from_subnode('solution') if self.get_text_from_subnode('solution')  else ""
        self.desc += "\nReference: " + self.get_text_from_subnode('reference') if self.get_text_from_subnode('reference') else ""
        self.ref=[]
        if self.get_text_from_subnode('cweid'):
            self.ref.append("CWE-"+self.get_text_from_subnode('cweid')) 
                                                        
                                                          
        self.items =[]
        i=0
        for n in item_node.findall('uri'):
            n2 = item_node.findall('param')[i]
                                                          
            
            mregex = re.search("(http|https|ftp)\://([a-zA-Z0-9\.\-]+(\:[a-zA-Z0-9\.&amp;%\$\-]+)*@)*((25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9])\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[1-9]|0)\.(25[0-5]|2[0-4][0-9]|[0-1]{1}[0-9]{2}|[1-9]{1}[0-9]{1}|[0-9])|localhost|([a-zA-Z0-9\-]+\.)*[a-zA-Z0-9\-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))[\:]*([0-9]+)*([/]*($|[a-zA-Z0-9\.\,\?\'\\\+&amp;%\$#\=~_\-]+)).*?$", n.text)
                                  
            protocol = mregex.group(1)
            host = mregex.group(4)
            port =80
            if protocol == 'https':
                port=443
            if mregex.group(11) is not None:
                port = mregex.group(11)
                
            item = {'uri' : n.text, 'param' : n2.text, 'host' : host, 'protocol' : protocol, 'port' : port}
            self.items.append(item)
            i=i+1
        self.requests = "\n".join([i['uri'] for i in self.items])
        
    def get_text_from_subnode(self, subnode_xpath_expr):
        """
        Finds a subnode in the host node and the retrieves a value from it.

        @return An attribute value
        """
        sub_node = self.node.find(subnode_xpath_expr)
        if sub_node is not None:
            return sub_node.text

        return None



class ZapPlugin(core.PluginBase):
    """
    Example plugin to parse zap output.
    """
    def __init__(self):
        core.PluginBase.__init__(self)
        self.id              = "Zap"
        self.name            = "Zap XML Output Plugin"
        self.plugin_version         = "0.0.2"
        self.version   = "2.2.2"
        self.framework_version  = "1.0.0"
        self.options         = None
        self._current_output = None
        self.target = None
        self._command_regex  = re.compile(r'^(zap|sudo zap|\.\/zap).*?')

        global current_path
        self._output_file_path = os.path.join(self.data_path,
                                             "zap_output-%s.xml" % self._rid)
                                  

    def parseOutputString(self, output, debug = False):
        """
        This method will discard the output the shell sends, it will read it from
        the xml where it expects it to be present.

        NOTE: if 'debug' is true then it is being run from a test case and the
        output being sent is valid.
        """

        parser = ZapXmlParser(output)
        for site in parser.sites:
            host = []
            if site.host != site.ip:
                host = [site.host]
            h_id = self.createAndAddHost(site.ip)
            i_id = self.createAndAddInterface(h_id, site.ip, ipv4_address=site.ip, hostname_resolution=host)
            s_id = self.createAndAddServiceToInterface(h_id, i_id, "http", "tcp",
                                                       ports = [site.port],
                                                       status = 'open')
            n_id = self.createAndAddNoteToService(h_id,s_id,"website","")
            n2_id = self.createAndAddNoteToNote(h_id,s_id,n_id,site.host,"")

            for item in site.items:
                v_id = self.createAndAddVulnWebToService(h_id, s_id, item.name,
                                                         item.desc, website=site.host, severity=item.severity,
                                                         path=item.items[0]['uri'],params=item.items[0]['param'],
                                                         request=item.requests,ref=item.ref)

        del parser
        
                      
                                             
                    


                                                                          
    def processCommandString(self, username, current_path, command_string):
        return None
        

    def setHost(self):
        pass


def createPlugin():
    return ZapPlugin()

if __name__ == '__main__':
    parser = ZapXmlParser(sys.argv[1])
    for item in parser.items:
        if item.status == 'up':
            print item

########NEW FILE########
__FILENAME__ = shodan_faraday
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from shodan import WebAPI
import xmlrpclib
SHODAN_API_KEY = "insert your API key here"
api = WebAPI(SHODAN_API_KEY)
# Wrap the request in a try/ except block to catch errors
try:
# Search Shodan
	print "Search Shodan"
	results = api.search('apache')
	
	#Connect to faraday
	print "Connecting Farday"
	api = xmlrpclib.ServerProxy("http://127.0.0.1:9876/")
	
	# Show the results
	print 'Results found: %s' % results['total']
	for result in results['matches']:
		if "ip" in result:
			print 'IP: %s' % result['ip']
			print result['data']
			print ''
		
			h_id = api.createAndAddHost(result['ip'],result['os'] if result['os'] is not None else "")
			i_id = api.createAndAddInterface(h_id,result['ip'],"00:00:00:00:00:00", result['ip'], "0.0.0.0", "0.0.0.0",[],
				  "0000:0000:0000:0000:0000:0000:0000:0000","00","0000:0000:0000:0000:0000:0000:0000:0000",
				  [],"",result['hostnames'] if result['hostnames'] is not None else [])
			s_id = api.createAndAddServiceToInterface(h_id, i_id, "www",
								 "tcp",str(result['port']),"open","Apache",result['data'])
			
except Exception, e:
	print 'Error: %s' % e

########NEW FILE########
__FILENAME__ = ecma48
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import re
def c(x,y):
    return (x<<4)+y

ESC=chr(c(1,11))

C0  = "[00/00-01/15]"
C1  = "01/11,[04/00-05/15]"
CSI = "01/11,05/11,[03/00-03/15]*,[02/00-02/15]*,[04/00-07/14]"

##
## Compile single definition to regular expression
##

rx_char=re.compile(r"^(\d\d)/(\d\d)$")
rx_range=re.compile(r"^\[(\d\d)/(\d\d)-(\d\d)/(\d\d)\](\*?)$")

def compile_ecma_def(s):
    r=[]
    for token in s.split(","):
        match=rx_range.match(token)
        if match:
            c1=c(int(match.group(1)),int(match.group(2)))
            c2=c(int(match.group(3)),int(match.group(4)))
            if c1==c2:
                x=[r"\x%02x"%c1]
            elif c1<c2:
                rr=[r"\x%02x"%x for x in range(c1,c2+1)]
                x=["[%s]"%"".join(rr)]
            else:
                rr=[r"\x%02x"%x for x in range(c2,c1+1)]
                x=["[%s]"%"".join(rr)]
            if match.group(5):
                x+="*"
            r+=x
            continue
        match=rx_char.match(token)
        if match:
            r+=[r"\x%02x"%c(int(match.group(1)),int(match.group(2)))]
            continue
        raise Exception("Invalid token: <%s>"%token)
    return "".join(r)
##
## Compile ECMA-48 definitions to regular expression
##
def get_ecma_re():
    re_csi=compile_ecma_def(CSI)
    re_c1=compile_ecma_def(C1).replace("\\x5b","")
    re_c0=compile_ecma_def(C0)

    for xc in ["\\x08","\\x09","\\x0a","\\x0d","\\x1b"]:
        re_c0=re_c0.replace(xc,"")

    re_vt100="\\x1b[c()78]" # VT100
    re_other="\\x1b[^[]"       # Last resort. Skip all ESC+char
    return "|".join(["(%s)"%r for r in (re_csi,re_c1,re_c0,re_vt100,re_other)])
##
## Backspace pattern
##
rx_bs=re.compile("[^\x08]\x08")
##
## \r<spaces>\r should be cut
##
rx_lf_spaces=re.compile(r"\r\s+\r")
##
## ESC sequence to go to the bottom-left corner of the screen
##
rx_esc_pager=re.compile("(^.*?\x1b\\[24;1H)|((?<=\n).*?\x1b\\[24;1H)",re.MULTILINE)
##
## Remove ECMA-48 Control Sequences from a string
##
rx_ecma=re.compile(get_ecma_re())
def strip_control_sequences(s):
    def strip_while(s,rx):
        while True:
            ss=rx.sub("",s)
            if ss==s:
                return s
            s=ss
    
    # Remove pager trash
    s=strip_while(s,rx_esc_pager)
    # Process backspaces
    s=strip_while(s,rx_bs)
    # Process LFs
    s=rx_lf_spaces.sub("",s)
    # Remove escape sequences
    return rx_ecma.sub("",s)

########NEW FILE########
__FILENAME__ = env
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import os
import pwd
import re
from cStringIO import StringIO

from model.common import ModelObject
from shell.core.history import HistoryTypeBuffer
import model.api as api

from ecma48 import strip_control_sequences 
#TODO: check from config if it is qt3 or qt4 and import the right one
from gui.qt3.pyqonsole.widget import ShellWidget
from shell.controller.qt3.session import Session
#from shell.controller.qt3.procctrl import ProcessController
from model.common import TreeWordsTries
from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

next_id = 1
#-------------------------------------------------------------------------------

#TODO: decide if we really need to inherit from ModelObject
class ShellEnvironment(ModelObject):
    """
    Shell environment is really a group of components that need to work together
    The environment is composed by:
        * a ShellWidget used in the GUI
        * a Session (which is the real shell)
        * a PluginController needed to handle all shell input and output
    The shell environment interacts with the Model Controller to add new hosts
    """
    def __init__(self, name, qapp, gui_parent, model_controller,
                 plugin_controller, close_callback=None):

        ModelObject.__init__(self)
        self._id = self.get_id()
        self.name = name

        # a reference used to add new hosts
        self._model_controller = model_controller

        # create the widget
        self.widget = ShellWidget(qapp,gui_parent,name)
        self.widget.setupLayout()

        # For safesty we don't use the user shell, we force it to bash
        progname = "/bin/bash"
        # create the session
        #Session(gui, pgm, args, term, sessionid='session-1', cwd=None):
        #self.process_controller = ProcessController()
        self.session = Session(self.widget, progname, [], "xterm", name);

        self.session.setConnect(True)
        self.session.setHistory(HistoryTypeBuffer(1000))
        self._setUpSessionSinalHandlers()

        #self.__last_user_input = None
        #self.__user_input_signal = False

        # flag that determines if output has to be ignored
        self.__ignore_process_output = False
        self.__ignore_process_output_once = False
        self.__first_process_output = True
        self.__save_output_prompt_format = False

        # determines if input is for an interactive command or not
        self.__interactive = False

        #TODO: check if we need to connect to this signal
        self.session.myconnect('done', self.close)

        # instance a new plugin controller
        self.plugin_controller = plugin_controller(self.id)

        self._initial_prompt = ""
        #self._custom_prompt_format = re.compile("\\x1B\[1;32m\[.+@.+\s.+\]>(\$|#)\s+\\x1B\[m")
        #self._custom_prompt_format = re.compile("\[.+@.+\s.+\]>(\$|#)\s+")
        self._custom_prompt_format = re.compile("\[(?P<user>.+)@(?P<host>.+):(?P<path>.+)\]>(\$|#)")
        #TODO: somewhere in the config there should be a list of regexes used to match
        # prompts. Be careful with this because if regexes are too generic they will
        # match more that is needed.
        self._generic_prompt_formats = []
        #XXX: adding this format just as a test! This should be in the config somehow
        # Also this may be is too generic to use...
        self._generic_prompt_formats.append(re.compile("^.+@.+:.+(\$|#)$"))
        
        #This is a reference to MainApplication.deleteShellEnvironment
        self._close_callback = close_callback 
        
        # flag that determines if shell environment is running
        self.__running = False
        
        #Autocomplete
        self._options=[] #only keys
        self._tname="" # last tool executed
        self._lcount=0
        self._optionsh={} #keys + help
        self.__command = ''
    def __del__(self):
        """
        When deleteing the environment we have to delete all the components
        """
        #print "ShellEnvironment __del__ called"
        del self.session
        #TODO: delete tab holding current ShellWidget
        #tabmgr = self.widget.parentWidget()
        #tabmgr.removeView(self.widget)
        #FIXME: check the __del__ method in ShellWidget
        #del self.widget
        #TODO: make sure the plugin controller correctly finishes all processes
        del self.plugin_controller

    def close(self, session, status, *args):
        #TODO: por alguna razon queda colgado un QSocketNotifier
        # QSocketNotifier: invalid socket 17 and type 'Read', disabling...
        # y eso cuelga la aplicacion
        api.devlog("ShellEnvironment close was called - session = %r, status = %r , *args = %r" % (session, status, args))
        if self._close_callback is not None:
            self._close_callback(self.name, self)
        else:
            api.devlog("close was call but callback is not set")

    #def setCloseCallback(self, ref):
    #    self._close_callback = ref

    def get_id(self):
        global next_id
        # just to make sure each env has a differente id because names can be the same
        id = next_id
        next_id += 1
        return id

    def run(self):
        self.session.run()
        self.__running = True
        #self.plugin_controller.run()

    def _setUpSessionSinalHandlers(self):
        """
        Connects some signal handlers to different signals emmited inside shell
        emulation and pty.
        These signals are used to handle user input and child process output
        """
        #IMPORTANT ABOUT USER INPUT AND PROCESS OUPUT (Session class)
        #PtyProcess in method dataReceived gets the child output
        #in method sendBytes it has the user input
        #
        #Emulation in method sendString also has the user input
        #also check method onKeyPressed to identify when an ENTER key is pressed
        #
        #
        #OUTPUT
        # emulation onRcvBlock le llega la salida del proceso
        # self.myconnect('receivedStdout', self.dataReceived)
        # Este se llama desde childOutput en pty_
        #    self.myemit("receivedStdout", (fdno, lenlist))
        #
        # self.myemit('block_in', (buf,)) <--- se llama desde dataReceived
        # self.sh.myconnect('block_in', self.em.onRcvBlock)
        #
        #INPUT
        # self.myemit("sndBlock", (string,))
        # self.em.myconnect('sndBlock', self.sh.sendBytes)
        #
        # otra opcion es agregar una senal propia en los metodos sendString
        # o en onKeyPressed de emuVt102

        # connect signals to handle shell I/O
        self.session.sh.myconnect('processOutput', self.processOutputHandler)

        #XXX: nasty hack to be able to send a return value
        # Using myconnect and emitting singals won't allow us to return a value
        self.session.em.sendENTER = self.processUserInputBuffer
        self.widget.myconnect('ignoreShellWidgetResize', self.ignoreDueResize)
        
        #handle ctrl+space
        self.session.em.sendCTRLSPACE = self.processCtrlSpace
        self.session.em.sendRIGHT = self.processMove
        self.session.em.sendLEFT = self.processMove
        self.session.em.sendUP = self.processMove
        self.session.em.sendDOWN = self.processMove
        


    #---------------------------------------------------------------------------
    # methods to handle signals for shell I/O
    # these methods must be async to avoid blocking shell
    # XXX: signalable object is used.. and it is not really async
    #---------------------------------------------------------------------------


    def replaceWord(self, source, dest, output):
        #matchesWord = re.findall("(\x1b+\x1b?.*?%s\x1b?)"%source, output)
        matchesWord = re.findall("(\x1b\[01;34m127.0.0.1\x1b)", output)

        for w in matchesWord:
            output = output.replace(w, dest)

        return output

    def highligthword(self, w, output):
        highlighted_word = "\x1b[02;44m%s\x1b[0m" % w
        output = self.replaceWord(w, highlighted_word, output)
        return output

    def processOutputHandler(self, output):
        """
        This method is called when processOutput signal is emitted
        It sends the process output to the plugin controller so it can
        pass it to the corresponding plugin
        """
        # the output comes with escape chars for example to show things with colors
        # those escape chars are messing the text and plugins may not handle that
        # correctly.
        #TODO: implement some way of removing the escape sequences

        # if we get the output from the screen image we have some issues when the
        # output is longer than the actual size and scrolls the window
        #TODO: check how to handle the window scrolling

        #output = self.session.em.getLastOutputFromScreenImage(1)
        #api.devlog("-"*50)
        #api.devlog("processOutputHandler called - output =\n%r" % self.session.em.getLastOutputFromScreenImage(1))
        #api.devlog("processOutputHandler called - hist lines = %r" % self.session.em._scr.getHistLines())
        #api.devlog("-"*50)

        #TODO: is this really needed??? (to save first prompt output)
        if self.__first_process_output:
            # save the output as prompt
            #api.devlog("Saving prompt for the first time\n\tPROMPT: %r" % output)
            # then mark flag because it won't be the first anymore
            self._initial_prompt = output.strip()
            self.__first_process_output = False
            # after getting first output which is the default prompt
            # we change it and clear screen
            self.__setCurrentShellPromptFormat()
            self.session.updateLastUserInputLine()
            return

        if self.__save_output_prompt_format:
            # means the output is the PS1 format and we have to store it
            # The output is the result of running "echo $PS1" so 2 lines are
            # generated: one with the actual value of PS1 and one more
            # that is the prompt just because the echo finished
            # So we have to keep the first line only
            self._initial_prompt = ouput.splitlines()[0].strip()
            self.__save_output_prompt_format = False


        #strip_control_sequences(output)


        #print "AAAAAAAAAAAAAaaa: ", repr(output)
        #for word in wordsFound:
        #    output = self.highligthword(word, output)


        # check if output has to be ignored
        if not self.__ignore_process_output and not self.__ignore_process_output_once:
            api.devlog("processOutputHandler (PROCESSED):\n%r" % output)

            command_finished, output = self.check_command_end(output)

            #IMPORTANT: if no plugin was selected to process this output
            # we don't need to send to controller
            if self.plugin_controller.getActivePluginStatus():
                # always send all output to the plugin controller
                self.plugin_controller.storeCommandOutput(output)
                # if command ended we notify the plugin
                if command_finished:
                    api.devlog("calling plugin_controller.onCommandFinished()")
                    self.plugin_controller.onCommandFinished()
            else:
                api.devlog("<<< no active plugin...IGNORING OUTPUT >>>")

        else:
            #if re.search("export PS1",output) == None:
            #    self.__command += output

            #if re.search("export PS1",output) == None:
            #    self.__command += output
            #
            #if self.__command != "":
            #    api.devlog("processOutputHandler (Allcommand): (%s)" % self.__command)
            #    
            #    #TODO: hacer un regex inicial, y verificar si es el lugar exacto para poner esto.
            #    #TODO: No soporta el backspace o caracteres especiales
            #    #TODO: Recorrer todo no es performante, hay que revisar
            #    for h in self._model_controller._hosts.itervalues():
            #        if re.search(self.__command,h.name,flags=re.IGNORECASE):
            #            api.devlog("Host name found: " + h.name + " id ("+h.id+")");
            #        for o in h.getAllInterfaces():
            #            if re.search(self.__command,o.name,flags=re.IGNORECASE):
            #                api.devlog("Host name found: " + h.name + " id ("+h.id+") - Interface ("+o.name+") id ("+o.id+")");
            #        for o in h.getAllApplications():
            #            if re.search(self.__command,o.name,flags=re.IGNORECASE):
            #                api.devlog("Host name found: " + h.name + " id ("+h.id+") - Application ("+o.name+") id ("+o.id+")");
                    
                
            api.devlog("processOutputHandler (IGNORED by flags): \n%r" % output)
            #api.devlog("self.__ignore_process_output_once = %s" % self.__ignore_process_output_once)
            #api.devlog("self.__ignore_process_output = %s" % self.__ignore_process_output)
            self.__ignore_process_output_once = False


        



    def processMove(self):
        """
        this method is called when up/down/left/right
        """
        
        if not self.__interactive:
            self._options=[]
            self._optionsh={}
            self._tname = ""
            
    def processCtrlSpace(self):
        """
        this method is called when the Ctrl+Space is pressed
        """
        if not self.__interactive:
            # get the complete user input from screen image (this is done so we don't
            # have to worry about handling any key)
            user_input = self.session.em.getLastOutputFromScreenImage(get_spaces=True)
            # parse input to get the prompt and command in separated parts
            
            prompt, username, current_path, command_string, command_len = self.__parseUserInput(user_input,get_spaces=True)
            api.devlog("processCtrlSpace info("+user_input+")("+command_string+")")
            api.devlog("-"*60)
            api.devlog("CTRL + SPACE \nprompt = %r\ncommand = %r" % (prompt, command_string))
            api.devlog("self.__interactive = %s" % self.__interactive )
            api.devlog("-"*60)
            
            
            words=command_string.split(" ")
            #words2=command_string.split(" ")
            cword=words[len(words)-1] #obtengo la ultima palabra
            #words.remove(cword) #elimino la ultima palabra
            options=[]
            search=0
            mindex=0
            
            try: # si encuentra la palabra significa que se encuentra en una interaccion
                mindex = self._options.index(cword)
                #api.devlog("El tname es:" + self._tname)
                # Si no es la misma herramienta o cambio la cantidad de palabra significa que tengo que empezar de nuevo
                if (self._tname != words[1] and self._tname != "") or (self._lcount != len(words)): 
                    mindex = -1
            except ValueError:
                mindex = -1

            if mindex == -1: # si no la encuentra inicia de nuevo.
                self._options=[]
                self._optionsh={}
                search=1
            else:
                options=self._options                    
            
            #Guardo la cantidad palabras para comparar despues
            self._lcount = len(words)
            
            #save first command
            if len(words) >2:
                self._tname = words[1] #guardo el nombre de la tool
            else:
                self._tname = ""

            
            if search ==1 and cword !="":
                #Busqueda de Hosts (ignore si el comando que escribi es blanco)
                for h in self._model_controller._hosts.itervalues():
                    if re.search(str("^"+cword),h.name,flags=re.IGNORECASE):
                        if len(options) == 0:
                            options.append(cword)
                        api.devlog("Host name found: " + h.name + " id ("+h.id+")");
                        options.append(h.name)
                    #Busqueda de Hostname dentro de las interfaces
                    for i in h.getAllInterfaces():
                        for hostname in i.getHostnames():                            
                            if re.search(str("^"+cword),hostname,flags=re.IGNORECASE):
                                if len(options) == 0:
                                    options.append(cword)
                                api.devlog("Hostname found: " + hostname + " id ("+i.id+")");
                                options.append(hostname)

                self._options = options
            
            new_options={}
            api.devlog("Cantidad de _options" + str(len(self._options)))
            
            #Si no se encontro nada, busco opciones en el plugin
            if len(self._options) == 0:
                #try:
                if 1==1:
                    #Llamo al controller para ver si hay algun plugin que pueda dar opciones
                    #Devuelve un dict del estilo 'option' : 'help de la option'
                    new_options = self.plugin_controller.getPluginAutocompleteOptions(prompt, username,
                                                                         current_path,
                                                                         command_string,
                                                                         self.__interactive)
                    
                    
                    if new_options != None: 
                        if len(new_options) >= 1: #Si encontro plugin que maneje y  trae opciones hago iteracciones.
                            api.devlog("Options de plugin encontradas: ("+str(len(new_options))+") valores ("+str(new_options)+")")
                            options = [cword]+new_options.keys() #Guardo las opciones (agrego la word inicial)
                            self._options = options 
                            self._optionsh = new_options
                                
                            api.devlog("getPluginAutocompleteOptions: %r" % user_input)
                            api.devlog("new_options:" + str(options))
                if 1==2:
                #except Exception:
                    api.devlog("Exception: Plugin")
                    # if anything in the plugins fails and raises an exception we continue wihout doing anything
                    new_cmd = None                
            
            # Recorro las opciones disponibles
            #TODO: Reemplazar esto por una ventana desplegable o 
            i=0
            newword=""
            if len(options) > 1: # Reemplazar solo si hay opciones
                for w in options:
                    #api.devlog("Por la palabra ("+ w +") (" + str(i)+") la palabra(" + cword+")")
                    if cword==w:
                        if len(options) > i+1:
                            newword=options[i+1]
                            #api.devlog("La encontre next ("+ newword +") (" + str(i)+")"+ str(options) )
                        else:
                            newword=options[0]
                            #api.devlog("La encontre last ("+ newword +") (" + str(i)+")"+ str(options) )
                            #newword="-h"
                    i+=1
                    
                if self._optionsh.has_key(newword):
                    #TODO: reemplazar esto por un help distinto no usar el devlog
                    api.showPopup( newword + " :" + self._optionsh[newword])
                    #api.devlog("pluginhelp: " + newword + " :" + self._optionsh[newword])
                
                #Hago el cambio en la shell
                self.session.sh.sendBytes("\b" * len(cword) +  newword)

    def processUserInputBuffer(self):
        """
        this method is called when the ENTER is pressed
        It processes the user input buffer and then it clears it for future
        if a new command is returned by a plugin this is returned to the caller
        (which is onKeyPress in module emuVt102)
        """

        command_string=""
        command_len = 0
        if not self.__interactive:
            # get the complete user input from screen image (this is done so we don't
            # have to worry about handling any key)
            user_input = self.session.em.getLastOutputFromScreenImage(get_full_content=True)
            api.devlog("user_input parsed from screen(0) = %s" % user_input)
            # parse input to get the prompt and command in separated parts
            prompt, username, current_path, command_string, command_len = self.__parseUserInput(user_input)
            
            api.devlog("user_input parsed from screen(1) =%s" % self.session.em.getLastOutputFromScreenImage(index=1, get_full_content=True))

            # we send the buffer to the plugin controller to determine
            # if there is a plugin suitable to handle it
            api.devlog("-"*60)
            api.devlog("about to call plugin controller\nprompt = %r\ncommand = %r" % (prompt, command_string))
            api.devlog("self.__interactive = %s" % self.__interactive )
            api.devlog("-"*60)
            # when calling the plugin, the command string may be changed
            # if the configuration allows this we send it instead of the typed one
            #TODO: validate config to allow this

            try:
                new_cmd = self.plugin_controller.processCommandInput(prompt, username,
                                                                     current_path,
                                                                     command_string,
                                                                     self.__interactive)
                
                # we set it to interactive until we make sure the command has finished
                # this check is done in processOutputHandler
                self.__interactive = True
                api.devlog("processUserInputBuffer: %r" % user_input)
                api.devlog("new_cmd: %r" % new_cmd)
            except Exception, e:
                # if anything in the plugins fails and raises an exception we continue wihout doing anything
                api.devlog("ERROR: processCommandString")
                api.devlog(e)
                new_cmd = None

            if new_cmd is None:
                # the output MUST BE processed
                self.__ignore_process_output = False
                self.__ignore_process_output_once = False
            else:
                # means the plugin changed command and we are going to send
                # ALT + r to delete current line. That produces an empty output
                # which has to be ignored
                    
                self.__ignore_process_output_once = True
                self.__ignore_process_output = False
        else:
            api.devlog("IGNORING BECAUSE INTERACTIVE FLAG WAS SET")
            new_cmd = None
            

        return new_cmd,command_string,command_len

    def ignoreDueResize(self):
        self.__ignore_process_output = True


    def __parseUserInput(self, user_input="", get_spaces=False):
        """
        parses the user input buffer and returns the following values:
            * current user prompt
            * current username
            * current path
            * command or text after prompt
        """
        username = ""
        hostname = ""
        current_path = ""
        usr_prompt = ""
        usr_command = ""
        raw_command = ""

        match = self._custom_prompt_format.search(user_input)
        if match is not None:
            username = match.group("user")
            hostname = match.group("host")
            current_path = os.path.expanduser(match.group("path"))
            usr_prompt = user_input[:match.end()].strip()
            raw_command = user_input[match.end():]
            if get_spaces == False:
                usr_command = raw_command.strip()
            else:
                usr_command = raw_command
        else:
            # means there was no prompt and theres only user input
            usr_command = user_input 

        return usr_prompt, username, current_path, usr_command, len(raw_command)

    def __setCurrentShellPromptFormat(self):
        # this is done to be able to detect the prompt later
        # Since we defined the prompt format we know how to parse it
        # The prompt format must not contain color escape chars or it'll mess up the output
        self.session.set_shell_ps1("[\\u@\\h:\\w]>\\$ ")

    def __getCurrentShellPromptFormat(self):
        """
        this gets the current PS1 environment variable
        of the current shell created.
        This is async because a command is sent and
        the output is retrieved later.
        """
        self.__save_output_prompt_format = True
        self.session.get_shell_ps1()


    def __matchesCustomPrompt(self, txt):
        """
        checks if the current text matches our custom prompt format
        and returns true in that case, false otherwise
        """
        if not self._custom_prompt_format:
            api.devlog("prompt format (PS1) is not defined.\nThis may cause unexpected results...")
            return False

        txt = txt.strip()
        m = self._custom_prompt_format.search(txt)
        return (m is not None)
        
        #XXX: this code below checked that the match was the last part of the text
        #if m is not None:
        #    if len(txt) == m.end():
        #       return True
        #return False
    
    def __matchGenericPrompt(self, txt):
        """
        checks if the current text matches against a list of
        generic prompt formats defined in the configuration
        and returns true in that case, false otherwise.
        This is used because if a prompt is detected it may be because a connection
        was established with a remote host.
        """
        if not self._generic_prompt_formats:
            api.devlog("There isn't any generic prompt format defined")
            return False
        
        txt = txt.strip()
        # Should we use match instead of search?
        for r in self._generic_prompt_formats:
            m = r.search(txt)
            if m is not None:
                return True
        return False
        
        
    def check_command_end(self, output):
        """
        Checks if the command finished by checking if the last line of the ouput
        is just our shell custom prompt.
        It also checks if a generic prompt is detected as the last line, which
        could mean that the commmand may have resulted in a remote connection
        to another host or device.
        This method returns 2 values: first a boolean flag that determines if
        command ended and then the full command output.
        """
        # We check if the last line in the output is just our modified shell prompt...
        # This would mean the command ended and we notify the plugin then
        api.devlog("check_command_end called...\noutput received = %r" % output)
        output_lines = output.splitlines()
        last_line = output_lines[-1].strip()
        api.devlog("about to test match with line %r" % last_line)
        command_finished = self.__matchesCustomPrompt(last_line)
        #command_finished = self.__matchesCustomPrompt(last_line.split()[0])
        if command_finished:
            # if we found this prompt then it means the command ended
            # we remove that line from output to send it
            api.devlog("command finished. Removing last line from output because it is just the prompt")
            output_lines.pop(-1)
            output = "\n".join(output_lines)
            # if command finished we need to ignore further output. It will be user input
            self.__ignore_process_output = True
            self.__interactive = False
            self.session.updateLastUserInputLine()
        else:
            # if we are here means that last line of the output is not our custom
            # shell prompt, but we need to check if a generic prompt is there
            # which means a remote connection may have been established
            if self.__matchGenericPrompt(last_line):
                api.devlog("A generic prompt format matched the last line of the command ouput")
                #TODO: define what to do in this case
        
        return command_finished, output

    def terminate(self):
        if self.__running:
            self.__running = False
            self.session.terminate()
#-------------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = emulation
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""Provide the Emulation class.

This class acts as the controler between the Screen class (Model) and
Widget class (View). As Widget uses Qt, Emulation also depends on Qt.
But it is very easy to use another toolkit.

A note on refreshing

   Although the modifications to the current screen image could immediately
   be propagated via `Widget' to the graphical surface, we have chosen
   another way here.

   The reason for doing so is twofold.

   First, experiments show that directly displaying the operation results
   in slowing down the overall performance of emulations. Displaying
   individual characters using X11 creates a lot of overhead.

   Second, by using the following refreshing method, the screen operations
   can be completely separated from the displaying. This greatly simplifies
   the programmer's task of coding and maintaining the screen operations,
   since one need not worry about differential modifications on the
   display affecting the operation of concern.

   We use a refreshing algorithm here that has been adoped from rxvt/kvt.

   By this, refreshing is driven by a timer, which is (re)started whenever
   a new bunch of data to be interpreted by the emulation arives at `onRcvBlock'.
   As soon as no more data arrive for `BULK_TIMEOUT' milliseconds, we trigger
   refresh. This rule suits both bulk display operation as done by curses as
   well as individual characters typed.
   (BULK_TIMEOUT < 1000 / max characters received from keyboard per second).

   Additionally, we trigger refreshing by newlines comming in to make visual
   snapshots of lists as produced by `cat', `ls' and likely programs, thereby
   producing the illusion of a permanent and immediate display operation.

   As a sort of catch-all needed for cases where none of the above
   conditions catch, the screen refresh is also triggered by a count
   of incoming bulks (`bulk_incnt').

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Benjamin Longuet
@author: Frederic Mantegazza
@author: Cyrille Boullier
@author: Sylvain Thenault
@copyright: 2003, 2005, 2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CECILL
"""

__revision__ = '$Id: emulation.py,v 1.25 2006-02-15 10:24:01 alf Exp $'

import qt
import shell.core.signalable as signalable
import keytrans
import re
from shell.core.screen import Screen
from model.common import TreeWordsTries
import model.api

NOTIFYNORMAL = 0
NOTIFYBELL = 1
NOTIFYACTIVITY = 2
NOTIFYSILENCE = 3

BULK_TIMEOUT = 20


class Emulation(signalable.Signalable, qt.QObject):
    """This class acts as the controler between the Screen class (Model) and
    Widget class (View). It's actually a common abstract base class for
    different terminal implementations, and so should be subclassed.

    It is responsible to scan the escapes sequences of the terminal
    emulation and to map it to their corresponding semantic complements.
    Thus this module knows mainly about decoding escapes sequences and
    is a stateless device w.r.t. the semantics.

    It is also responsible to refresh the Widget by certain rules.
    """
    def __init__(self, gui):
        super(Emulation, self).__init__()
        self._gui = gui
        # 0 = primary, 1 = alternate
        self._screen = [Screen(self._gui.lines, self._gui.columns),
                        Screen(self._gui.lines, self._gui.columns)]
        self._scr = self._screen[0]
        # communicate with widget
        self._connected = False
        # codec
        self._codec = None
        self._decoder = None
        # key translator
        self._key_trans = None
        self.setKeymap(0)
        # bulk handling
        self._bulk_timer = qt.QTimer(self)
        self._bulk_nl_cnt = 0 # bulk new line counter
        self._bulk_in_cnt = 0 # bulk counter
        self._bulk_timer.connect(self._bulk_timer, qt.SIGNAL("timeout()"),
                                 self._showBulk)
        gui.myconnect("changedImageSizeSignal", self.onImageSizeChange)
        gui.myconnect("changedHistoryCursor", self.onHistoryCursorChange)
        gui.myconnect("keyPressedSignal", self.onKeyPress)
        gui.myconnect("beginSelectionSignal", self.onSelectionBegin)
        gui.myconnect("extendSelectionSignal", self.onSelectionExtend)
        gui.myconnect("endSelectionSignal", self.setSelection)
        gui.myconnect("clearSelectionSignal", self.clearSelection)
        gui.myconnect("isBusySelecting", self.isBusySelecting)
        gui.myconnect("testIsSelected", self.testIsSelected)
        gui.myconnect("onDoubleClickSignal", self.onDoubleClick)


        self._lasted_highlighted = []

        self.debug=0
        self.history_h = []
        self._save_last_cursor_pos = False
        # pos 0 will be used for user input grabbing
        # pos 1 will be used for process output grabbing
        self._last_cu_x = [0, 0]
        self._last_cu_y = [0, 0]

    def __del__(self):
        self._bulk_timer.stop()

    def _setScreen(self, n):
        """change between primary and alternate screen"""
        old = self._scr
        self._scr = self._screen[n]
        if not self._scr is old:
            self._scr.clearSelection()
            old.busy_selecting = False

    def setHistory(self, history_type):
        self._screen[0].setScroll(history_type)
        if self._connected:
            self._showBulk()

    def history(self):
        return self._screen[0].getScroll()

    def setKeymap(self, no):
        self._key_trans = keytrans.find(no)

    def keymap(self):
        return self._key_trans


    # Interpreting Codes
    # This section deals with decoding the incoming character stream.
    # Decoding means here, that the stream is first seperated into `tokens'
    # which are then mapped to a `meaning' provided as operations by the
    # `Screen' class.

    def onRcvChar(self, c):
        """process application unicode input to terminal"""
        raise NotImplementedError()

    def setMode(self):
        raise NotImplementedError()

    def resetMode(self):
        raise NotImplementedError()

    def sendString(self, string, clear_line = False, old_len=0):
        if clear_line:
            # we send backspace keys to delete the whole current output in the screen
            # this way we are deleteing the current command in the screen to send the new one
            backspace_amount = self.getCurrentOutputLen()
            if backspace_amount:
                #self.myemit("sndBlock", ("\010"*backspace_amount,))
                #Fix: Error consola modificacion usign left arrow
                self.myemit("sndBlock", ("\x1b\x5b\x43"*old_len,))
                self.myemit("sndBlock", ("\010"*old_len,))
                
            
            # now we send the new command
            self.myemit("sndBlock", (string,))
            # now we need to put an ENTER because the clear line happens when pressing that
            string = "\r"
        else:
            self.myemit("sndBlock", (string,))

    def sendENTER(self):
        #XXX: this method will be changed with a reference to another method
        # this is a nasty hack... we'd better change it...
        pass
    def sendCTRLSPACE(self):
        #XXX: this method will be changed with a reference to another method
        # this is a nasty hack... we'd better change it...
        pass
    def sendLEFT(self):
        #XXX: this method will be changed with a reference to another method
        # this is a nasty hack... we'd better change it...
        pass
    def sendRIGHT(self):
        #XXX: this method will be changed with a reference to another method
        # this is a nasty hack... we'd better change it...
        pass
    def sendUP(self):
        #XXX: this method will be changed with a reference to another method
        # this is a nasty hack... we'd better change it...
        pass
    def sendDOWN(self):
        #XXX: this method will be changed with a reference to another method
        # this is a nasty hack... we'd better change it...
        pass
    
    # Keyboard handling
    def onKeyPress(self, ev):
        """char received from the gui"""
        raise NotImplementedError()

    def onRcvBlock(self, block):
        self.myemit("notifySessionState", (NOTIFYACTIVITY,))
        self._bulkStart()
        self._bulk_in_cnt += 1
        for c in block:
            result = self._decoder.toUnicode(c , 1)
            for char in result:
                self.onRcvChar(char.at(0).unicode())
            if c == '\n':
                self._bulkNewLine()
        self._bulkEnd()



    def __getImageLine(self, line_number):
        image, wrapped = self._scr.getCookedImage() # Get the image
        return "".join([c.c for c in image[line_number]])

    def _getWordOnPosition(self, start_xy, end_xy):
        start_x, start_y = start_xy
        end_x, end_y = end_xy

        line = self.__getImageLine(start_y)
        if start_x > end_x:
            word = line[start_x:]
        else:
            word = line[start_x:end_x+1]

        return word
        

    def onDoubleClick(self, start_word_xy, end_word_xy):
        word = self._getWordOnPosition(start_word_xy, end_word_xy)
        treeWordsTries = TreeWordsTries()
        self._gui.select_on_tree( word )

    def onSelectionBegin(self, x, y):
        if self._connected:
            self._scr.setSelBeginXY(x, y)
            self._showBulk()

    def onSelectionExtend(self, x, y):
        if self._connected:
            self._scr.setSelExtendXY(x, y)
            self._showBulk()

    def setSelection(self, preserve_line_break):
        if self._connected:
            text = self._scr.getSelText(preserve_line_break)
            if text is not None:
                self._gui.setSelection(text)

    def isBusySelecting(self, busy):
        if self._connected:
            self._scr.busy_selecting = busy

    def testIsSelected(self, x, y, ref):
        if self._connected:
            ref[0] = self._scr.testIsSelected(x, y)

    def clearSelection(self):
        if self._connected:
            self._scr.clearSelection()
            self._showBulk()

    def setConnect(self, c):
        self._connected = c
        if self._connected:
            self.onImageSizeChange(self._gui.lines, self._gui.columns)
            self._showBulk()
        else:
            self._scr.clearSelection()

    def onImageSizeChange(self, lines, columns):
        """Triggered by image size change of the TEWidget `gui'.

        This event is simply propagated to the attached screens
        and to the related serial line.
        """
        if not self._connected:
            return
        #print 'emulation.onImageSizeChange', lines, columns
        self._screen[0].resizeImage(lines, columns)
        self._screen[1].resizeImage(lines, columns)
        self._showBulk()
        # Propagate event to serial line
        self.myemit("imageSizeChanged", (lines, columns))

    def onHistoryCursorChange(self, cursor):
        if self._connected:
            self._scr.hist_cursor = cursor
            self._showBulk()

    def _setCodec(self, c):
        """coded number, 0=locale, 1=utf8"""
        if c:
            self._codec = qt.QTextCodec.codecForName("utf8")
        else:
            self._codec = qt.QTextCodec.codecForLocale()
        self._decoder = self._codec.makeDecoder()

    def _setColumns(self, columns):
        # FIXME This goes strange ways
        # Can we put this straight or explain it at least?
        # XXX moreover no one is connected to this signal...
        self.myemit("changeColumns", (columns,))

    def _bulkNewLine(self):
        self._bulk_nl_cnt += 1
        self._bulk_in_cnt = 0  # Reset bulk counter since 'nl' rule applies

    def dump_all_screen(self):
        screen_lines = []    
        image, wrapped = self._scr.getCookedImage() # Get the image
        self._gui.setLineWrapped(wrapped)
        buf = self.getLastOutputFromScreenImage(1, get_full_content = True)
        for y in xrange(self._scr.lines):
            line = "".join([c.c for c in image[y]])                
            screen_lines.append(line)
        return screen_lines

    def _showBulk(self):
        self._bulk_nl_cnt = 0
        self._bulk_in_cnt = 0
        found = False

        GRAY_COLOR = 1
        RED_COLOR = 3
        treeWordsTries = TreeWordsTries()
        
        if self._connected:
            image, wrapped = self._scr.getCookedImage() # Get the image
            self._gui.setLineWrapped(wrapped)
 
            screen_lines = self.dump_all_screen()

            for c, f in self._lasted_highlighted:
                self._scr.setBackgroundColor(c, f, 0)


            image, wrapped = self._scr.getCookedImage() # Get the image
            self._gui.setLineWrapped(wrapped)

            self._lasted_highlighted = []
            for y_position in xrange(len(screen_lines)):
                l = screen_lines[y_position]
                c_letters = 0
                for w in l.split(' '):
                    if not w:
                        c_letters += 1
                        continue

                    n_w, deleted_begin, deleted_end = self.__clean_word(w)
                    wordsFound = treeWordsTries.isInTries(n_w)

                    if wordsFound:
                        comienzo = [c_letters + deleted_begin, y_position]
                        fin =  [c_letters + deleted_begin + len(n_w) -1, y_position]
                        self._lasted_highlighted.append((comienzo, fin))
                        self._scr.setBackgroundColor(comienzo, fin, RED_COLOR)

                        found = True
                    c_letters += len(w)+1
                    
            
            if found:
                image, wrapped = self._scr.getCookedImage() # Get the image
                self._gui.setLineWrapped(wrapped)

            self._gui.setImage(image, self._scr.lines, self._scr.columns) #  Actual refresh
            self._gui.setCursorPos(self._scr.getCursorX(), self._scr.getCursorY())
            # FIXME: Check that we do not trigger other draw event here
            
            self._gui.setScroll(self._scr.hist_cursor, self._scr.getHistLines())
            #print "about to emit processOutput signal inside _showBulk"
            #buf = self.getLastOutputFromScreenImage(1)
            #print "buf = ", buf
            #self.myemit('processOutput', (buf,)) # signal to pass it to plugins
            self.updateLastCursorPos()
            self.updateLastCursorPos(True, 1)

            #self._last_cu_x = [self._scr.getCursorX(), self._scr.getCursorX()]
            #self._last_cu_y = [self._scr.getCursorY(),self._scr.getCursorY()]


    def __remove_chars(self, w, chars):
        idx = 0
        for c in w:
            if c in chars:
                idx += 1
                continue

            break
        #print "REMOVE CHARS: ", w[idx:]
        return w[idx:], idx


    def __clean_word(self, w):
        """
            Clean some puntuation simbol staring or ending the word.
            return word, begin offset, end offset
        """
        import string
        VALID_PUNCTUATION = '_'
        to_remove = string.punctuation

        #remove the valid punctuation from the invalid punctuacion list
        for v in VALID_PUNCTUATION:
            to_remove = to_remove.replace(v, "")

        original_word = w

        w, deleted_from_begin = self.__remove_chars(w, to_remove)
        w, deleted_from_end = self.__remove_chars(w[::-1], to_remove)


        return w[::-1], deleted_from_begin, deleted_from_end

    def _bulkStart(self):
        if self._bulk_timer.isActive():
            self._bulk_timer.stop()

    def _bulkEnd(self):
        if self._bulk_nl_cnt > self._gui.lines or self._bulk_in_cnt > 20:
            self._showBulk()
        else:
            self._bulk_timer.start(BULK_TIMEOUT, True)
    
    def getCurrentOutputLen(self):
        """
        This method return the length of the current output in the screen.
        This can be used to determine how long a current command typed by
        the user is and then exactly delete it.
        """
        width = self._gui.columns
        cu_x = self._scr.getCursorX()
        cu_y = self._scr.getCursorY()
        return width * (cu_y-self._last_cu_y[0]) + cu_x

    def getLastOutputFromScreenImage(self, index=0, get_full_content=False, get_spaces=False):
        """
        Gets the text from the screen image that is located from
        last cursor x,y value to the actual cursor x,y value
        Last cursor coordinates are updated in _showBulk method that
        shows the process output
        The parameter "index" is used to determine if the output is retrieved
        as if it was user input (index=0) or process output (index=1).
        If get_full_content flag is True we don't get the last line only up to the
        current x position but the complete line.
        """
        # image is a matrix with Ca (characters) for each x,y coordinate in the screen
        image, wrapped = self._scr.getCookedImage() # Get the image
        cu_x = self._scr.getCursorX()
        cu_y = self._scr.getCursorY()
        
        
        #print "getLastOutputFromScreenImage - len(image) = %d - len(wrapped) = %d" % (len(image), len(wrapped))
        #print "getLastOutputFromScreenImage - index = %d - cu_x = %d - cu_y = %d - last_x = %d - last_y = %d" %\
        #(index, cu_x, cu_y, self._last_cu_x[index], self._last_cu_y[index])
        
        #self.__debug_dump_screen()
        #self.__debug_dump_screen(1)
        
        # TODO: check how to handle scrolling if the current cu_y is less than the saved cu_y
        # TODO: another problem could be that the current y position is not the real "last line"
        # of the user input. If ENTER is pressed and the current y is not the last line the shell
        # will be getting the complete user input but this method won't be getting the same
        lines = []
        # there is a special case where last_cu_y could be greater than cu_y and in such cases we must
        # swap values to get the text correctly
        if self._last_cu_y[index] > cu_y: # swap values
            self._last_cu_y[index], cu_y = cu_y, self._last_cu_y[index]
        elif self._last_cu_y[index] == cu_y:
            # if these values are the same we need to check if the previous line is wrapped
            # and take that line too. So we go backwards checking for wrapped lines and update
            # the value of the last_cu_y to the smallest wrapped line
            for y in xrange(cu_y-1, -1, -1):
                if wrapped[y]:  
                    self._last_cu_y[index] = y
                else:
                    break # if we find a line that is now wrapped we just stop searching
            
        for y in xrange(self._last_cu_y[index], cu_y+1):
            #XXX: this code here is commented because it was used to skip the prompt
            #if y == self._last_cu_y[index]:
            #    line = "".join([c.c for c in image[y][self._last_cu_x[index]:]])
            if y == cu_y and not get_full_content:
                # this means that the line que are processing is the current line so we
                # get everything until the current x position.
                line = "".join([c.c for c in image[y][:cu_x]])
            else:
                line = "".join([c.c for c in image[y]])

            if index: 
                line = line.rstrip()

            lines.append(line)

        join_char = "\n" if index else ""
        result = join_char.join(lines)
        if get_spaces:
            return result
        else:
            return result.strip()

    def updateLastCursorPos(self, flag=False, index=0):
        if self._save_last_cursor_pos or index:
#            print "updateLastCursorPos - saving last cursor pos with index ", index
#            print "updateLastCursorPos - (BEFORE) last x = %d - last y = %d" % (self._last_cu_x[index], self._last_cu_y[index])
            self._last_cu_x[index] = self._scr.getCursorX()
            self._last_cu_y[index] = self._scr.getCursorY()
            self._save_last_cursor_pos = False
#            print "updateLastCursorPos - (AFTER) last x = %d - last y = %d" % (self._last_cu_x[index], self._last_cu_y[index])
        if not index:
            self._save_last_cursor_pos = flag
            
    def __debug_dump_screen(self, index=0):
        image, wrapped = self._scr.getCookedImage() # Get the image
        
        model.api.devlog("-"*10, " image[%d] " % index, "-"*10)

        for y in xrange(len(image)):
            line = "".join([c.c for c in image[y]])
            model.api.devlog("%d | %s |" % (y, line))
        
        model.api.devlog("-"*30)
        model.api.devlog("")
        model.api.devlog("-"*10, " wrapped[%d] " % index, "-"*10)

        for y in xrange(len(image)):
            #line = "".join([c.c for c in wrapped[y]])
            model.api.devlog("%d | %s |" % (y, wrapped[y]))
        
        model.api.devlog("-"*30) 

########NEW FILE########
__FILENAME__ = emuVt102
# -*- coding: ISO-8859-1 -*-
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""Provide the EmuVt102 class, responsible for the VT102 Terminal Emulation.

Based on the konsole code from Lars Doelle.

OSC: Operating System Controls (introduced by 'ESC[')
CSI: Control Sequence Introducer (introduced by 'ESC]')

@author: Lars Doelle
@author: Benjamin Longuet
@author: Frederic Mantegazza
@author: Cyrille Boullier
@author: Sylvain Thenault
@copyright: 2003, 2005, 2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CECILL
"""

__revision__ = '$Id: emuVt102.py,v 1.23 2006-02-15 10:24:01 alf Exp $'

import os
import qt

import keytrans as kt
from emulation import Emulation, NOTIFYBELL, NOTIFYNORMAL
from shell.core.common import CTRL
import shell.core.screen as screen
import gui.qt3.pyqonsole.widget as widget
import shell.core.ca as ca
import model.api as api

# Qt chars shortcuts
ControlButton = qt.QEvent.ControlButton
ShiftButton = qt.QEvent.ShiftButton
AltButton = qt.QEvent.AltButton

# VT102 modes
MODE_AppScreen = screen.MODES_SCREEN+0
MODE_AppCuKeys = screen.MODES_SCREEN+1
MODE_AppKeyPad = screen.MODES_SCREEN+2
MODE_Mouse1000 = screen.MODES_SCREEN+3
MODE_Ansi      = screen.MODES_SCREEN+4

# Tokens
TY_CHR = 0
def TY_CTL(A):
    return ((ord(A) & 0xff) << 8) | 1
def TY_ESC(A):
    return ((ord(A) & 0xff) << 8) | 2
def TY_ESC_CS(A, B):
    return ((ord(B) & 0xffff) << 16) | ((ord(A) & 0xff) << 8) | 3
def TY_ESC_DE(A):
    return ((ord(A) & 0xff) << 8) | 4
def TY_CSI_PS(A, N):
    return ((N & 0xffff) << 16) | ((ord(A) & 0xff) << 8) | 5
def TY_CSI_PN(A):
    return ((ord(A) & 0xff) << 8) | 6
def TY_CSI_PR(A, N):
    return ((N & 0xffff) << 16) | ((ord(A) & 0xff) << 8) | 7
def TY_VT52(A):
    return ((ord(A) & 0xff) << 8) | 8
def TY_CSI_PG(A):
    return ((ord(A) & 0xff) << 8) | 9

# Character Classes used while decoding
CTL = 1
CHR = 2
CPN = 4
DIG = 8
SCS = 16
GRP = 32
ESC = 27


# init tokenizer table
TOK_TBL = []
def init_tokenizer():
    for i in xrange(32):
        TOK_TBL.append(CTL)
    for i in xrange(32, 256):
        TOK_TBL.append(CHR)
    for s in "@ABCDGHLMPXcdfry":
        TOK_TBL[ord(s)] |= CPN
    for s in "0123456789":
        TOK_TBL[ord(s)] |= DIG
    for s in "()+*%":
        TOK_TBL[ord(s)] |= SCS
    for s in "()+*#[]%":
        TOK_TBL[ord(s)] |= GRP
init_tokenizer()

# decoder helpers
def lec(p, s, P, L, C):
    """
    P: the length of the token scanned so far.
    L: (often P-1) the position on which contents we base a decision.
    C: a character or a group of characters (taken from 'tbl').

    s: input buffer
    p: length of the input buffer
    """
    return p == P and s[L]  == C

def lun(p, cc):
    return p == 1 and cc >= 32
def eec(p, cc, C):
    return p >= 3 and cc == C
def epp(p, s):
    return p >= 3 and s[2] == ord('?')
def egt(p, s):
    return p >= 3 and s[2] == ord('>')
def les(p, s, P, L, C):
    return p == P and s[L] < 256 and (TOK_TBL[s[L]] & C) == C
def eps(p, s, cc, C):
    return p >= 3 and s[2] != ord('?') and s[2] != ord('>') and cc < 256 and (TOK_TBL[cc] & C) == C
def ees(p, cc, C):
    return p >= 3 and cc < 256 and (TOK_TBL[cc] & C) == C


class CharCodes:
    """VT100 Charsets

    Character Set Conversion

       The processing contains a VT100 specific code translation layer.
       It's still in use and mainly responsible for the line drawing graphics.

       These and some other glyphs are assigned to codes (0x5f-0xfe)
       normally occupied by the latin letters. Since this codes also
       appear within control sequences, the extra code conversion
       does not permute with the tokenizer and is placed behind it
       in the pipeline. It only applies to tokens, which represent
       plain characters.

       This conversion it eventually continued in Widget, since
       it might involve VT100 enhanced fonts, which have these
       particular glyphs allocated in (0x00-0x1f) in their code page.
    """
    def __init__(self):
        self.charset = [0, 0, 0, 0]
        self.cu_cs = 0                        # actual charset.
        self.graphic = False                  # Some VT100 tricks
        self.pound = False                    # Some VT100 tricks
        self.trans = [0, 0, 0, 0, 0, 0, 0]    # pre-latin conversion
        self.sa_graphic = False               # saved graphic
        self.sa_pound = False                 # saved pound
        self.sa_trans = [0, 0, 0, 0, 0, 0, 0] # saved pre-latin conversion

    def reset(self):
        self.charset = [ord(c) for c in "BBBB"]
        self.cu_cs = 0
        self.graphic = False
        self.pound = False
        self.trans_from_string("[\\]{|}~")
        self.sa_graphic = False
        self.sa_pound = False

    def trans_from_string(self, string):
        #assert len(string) == 6, string
        self.trans = [ord(c) for c in string]

    def applyCharset(self, c):
        if self.graphic and 0x5f <= c and c <= 0x7e:
            return widget.VT100_GRAPHICS[c-0x5f]
        if self.pound and c == ord('#'):
            return 0xa3 # Obsolete mode
        if ord('[') <= c and c <= ord(']'):
            return self.trans[c-ord('[')+0] & 0xff
        if ord('{') <= c and c <= ord('~'):
            return self.trans[c-ord('{')+3] & 0xff
        return c

    def setCharset(self, n, cs):
        self.charset[n & 3] = cs
        self.useCharset(self.cu_cs)

    def save(self):
        self.sa_graphic = self.graphic
        self.sa_pound = self.pound
        self.sa_trans = self.trans[:]

    def restore(self):
        self.graphic = self.sa_graphic
        self.pound = self.sa_pound
        self.trans = self.sa_trans[:]

    def useCharset(self, n):
        self.cu_cs = n & 3
        self.graphic = (self.charset[n & 3] == '0')
        self.pound = (self.charset[n & 3] == 'A') # This mode is obsolete
        self.trans_from_string("[\\]{|}~") # ancient mode, identical
        # FIXME: we might better use octal strings below to prevent filter problems
        if self.charset[n & 3] == 'K':
            self.trans_from_string("") # ancient mode, german
        elif self.charset[n & 3] == 'R':
            self.trans_from_string("") # ancient mode, french


class EmuVt102(Emulation):
    """VT102 Terminal Emulation

    This class puts together the screens, the pty and the widget to a
    complete terminal emulation. Beside combining it's componentes, it
    handles the emulations's protocol.

    It consists of the following sections:
    - Incoming Bytes Event pipeline
    - Outgoing Bytes
      - Mouse Events
      - Keyboard Events
    - Modes and Charset State
    """

    def __init__(self, gui):
        super(EmuVt102, self).__init__(gui)
        self._pbuf = []
        self._argv = [0]
        # file used while in print mode
        self._print_fd = None
        # mapping with mode as key and a boolean indicating wether it's
        # activated as value
        self._curr_mode = {}
        self._save_mode = {}
        self._charset = [CharCodes(), CharCodes()]
        self._hold_screen = False
        self.reset()
        gui.myconnect("mouseSignal", self.onMouse)

    def reset(self):
        self._resetToken()
        self._resetModes()
        self._resetCharset(0)
        self._resetCharset(1)
        self._screen[0].reset()
        self._screen[1].reset()
        self._setCodec(0)

    # Processing the incoming byte stream #####################################
    """Incoming Bytes Event pipeline

    This section deals with decoding the incoming character stream.
    Decoding means here, that the stream is first seperated into `tokens'
    which are then mapped to a `meaning' provided as operations by the
    `TEScreen' class or by the emulation class itself.

    The pipeline proceeds as follows:

    - Tokenizing the ESC codes (onRcvChar)
    - VT100 code page translation of plain characters (applyCharset)
    - Interpretation of ESC codes (tau)

    The escape codes and their meaning are described in the
    technical reference of this program.


    Tokens ------------------------------------------------------------------


       Since the tokens are the central notion if this section, we've put them
       in front. They provide the syntactical elements used to represent the
       terminals operations as byte sequences.

       They are encodes here into a single machine word, so that we can later
       switch over them easily. Depending on the token itself, additional
       argument variables are filled with parameter values.

       The tokens are defined below:

       - CHR        - Printable characters     (32..255 but DEL (=127))
       - CTL        - Control characters       (0..31 but ESC (= 27), DEL)
       - ESC        - Escape codes of the form <ESC><CHR but `[]()+*#'>
       - ESC_DE     - Escape codes of the form <ESC><any of `()+*#%'> C
       - CSI_PN     - Escape codes of the form <ESC>'['     {Pn} ';' {Pn} C
       - CSI_PS     - Escape codes of the form <ESC>'['     {Pn} ';' ...  C
       - CSI_PR     - Escape codes of the form <ESC>'[' '?' {Pn} ';' ...  C
       - VT52       - VT52 escape codes
                      - <ESC><Chr>
                      - <ESC>'Y'{Pc}{Pc}
       - XTE_HA     - Xterm hacks              <ESC>`]' {Pn} `;' {Text} <BEL>
                      note that this is handled differently

       The last two forms allow list of arguments. Since the elements of
       the lists are treated individually the same way, they are passed
       as individual tokens to the interpretation. Further, because the
       meaning of the parameters are names (althought represented as numbers),
       they are includes within the token ('N').


    Tokenizer ---------------------------------------------------------------

    The tokenizers state

       The state is represented by the buffer (pbuf, ppos),
       and accompanied by decoded arguments kept in (argv,argc).
       Note that they are kept internal in the tokenizer.


    Instead of keeping an explicit state, we deduce it from the
    token scanned so far. It is then immediately combined with
    the current character to form a scanning decision.

    This is done by the following defines.

    - P is the length of the token scanned so far.
    - L (often P-1) is the position on which contents we base a decision.
    - C is a character or a group of characters (taken from 'tbl').

    Note that they need to applied in proper order.
    """

    def Xpe(self):
        return len(self._pbuf) >= 2 and self._pbuf[1] == ord(']')
    def Xte(self, cc):
        return self.Xpe() and cc == 7
    def ces(self, cc, C):
        return cc < 256 and (TOK_TBL[cc] & C) == C and not self.Xte(cc)

    def onRcvChar(self, cc):
        """char received from the subprocess"""
        if self._print_fd:
            self.printScan(cc)
            return
        if cc == 127: # VT100: ignore.
            return
        if self.ces(cc, CTL):
            # DEC HACK ALERT! Control Characters are allowed *within* esc sequences in VT100
            # This means, they do neither a resetToken nor a pushToToken. Some of them, do
            # of course. Guess this originates from a weakly layered handling of the X-on
            # X-off protocol, which comes really below this level.
            if cc == CTRL('X') or cc == CTRL('Z') or cc == ESC: # VT100: CAN or SUB
                self._resetToken()
            if cc != ESC:
                self.tau(TY_CTL(chr(cc+ord('@'))), 0, 0)
                return
        # Advance the state
        self._pbuf.append(cc)
        s = self._pbuf
        p = len(self._pbuf)

        if self.getMode(MODE_Ansi): # Decide on proper action
            if lec(p, s, 1, 0, ESC):
                pass
            elif les(p, s, 2, 1, GRP):
                pass
            elif self.Xte(cc):
                self._XtermHack()
                self._resetToken()
            elif self.Xpe():
                pass
            elif lec(p,s, 3, 2, ord('?')):
                pass
            elif lec(p, s, 3, 2, ord('>')):
                pass
            elif lun(p, cc):
                self.tau(TY_CHR, self._applyCharset(cc), 0)
                self._resetToken()
            elif lec(p, s, 2, 0, ESC):
                self.tau(TY_ESC(chr(s[1])), 0, 0)
                self._resetToken()
            elif les(p, s, 3, 1, SCS):
                self.tau(TY_ESC_CS(chr(s[1]), chr(s[2])), 0, 0)
                self._resetToken()
            elif lec(p, s, 3, 1, ord('#')):
                self.tau(TY_ESC_DE(chr(s[2])), 0, 0)
                self._resetToken()
            elif eps(p, s, cc, CPN):
                if len(self._argv)> 1:
                    q = self._argv[-1]
                else:
                    q = None
                self.tau(TY_CSI_PN(chr(cc)), self._argv[0], q)
                self._resetToken()
            elif ees(p, cc, DIG):
                self._addDigit(cc - ord('0'))
            elif eec(p, cc, ord(';')):
                self._argv.append(0)
            else:
                for arg in self._argv:
                    if epp(p, s):
                        self.tau(TY_CSI_PR(chr(cc), arg), 0, 0)
                    elif egt(p, s):
                        self.tau(TY_CSI_PG(chr(cc)), 0, 0) # spec. elif token == for ESC]>0c or ESC]>c
                    else:
                        self.tau(TY_CSI_PS(chr(cc), arg), 0, 0)
                self._resetToken()

        else: # mode VT52
            if lec(p, s, 1, 0, ESC):
                pass
            elif les(p, s, 1, 0, CHR):
                self.tau(TY_CHR, s[0], 0)
                self._resetToken()
            elif lec(p, s, 2, 1, ord('Y')):
                pass
            elif lec(p, s, 3, 1, ord('Y')):
                pass
            elif p < 4:
                self.tau(TY_VT52(chr(s[1])), 0, 0)
                self._resetToken()
            else:
                self.tau(TY_VT52(chr(s[1])), s[2], s[3])
                self._resetToken()


    def tau(self, token, p, q):
        """
        Interpretation of ESC codes
        ---------------------------

        Now that the incoming character stream is properly tokenized,
        meaning is assigned to them. These are either operations of
        the current screen, or of the emulation class itself.

        The token to be interpreteted comes in as a machine word
        possibly accompanied by two parameters.

        Likewise, the operations assigned to, come with up to two
        arguments. One could consider to make up a proper table
        from the function below.

        The technical reference manual provides more informations
        about this mapping.
        """
        if token == TY_CHR: self._scr.showCharacter(p) # UTF16

        # 127 DEL: ignored on input

        elif token == TY_CTL('@') : pass # NUL: ignored
        elif token == TY_CTL('A') : pass # SOH: ignored
        elif token == TY_CTL('B') : pass # STX: ignored
        elif token == TY_CTL('C') : pass # ETX: ignored
        elif token == TY_CTL('D') : pass # EOT: ignored
        elif token == TY_CTL('E') : self.reportAnswerBack() # VT100
        elif token == TY_CTL('F') : pass # ACK: ignored
        elif token == TY_CTL('G'):
            if self._connected: # VT100
                self._gui.bell()
                self.myemit("notifySessionState", (NOTIFYBELL,))
        elif token == TY_CTL('H') : self._scr.backSpace() # VT100
        elif token == TY_CTL('I') : self._scr.tabulate()  # VT100
        elif token == TY_CTL('J') : self._scr.newLine()   # VT100
        elif token == TY_CTL('K') : self._scr.newLine()   # VT100
        elif token == TY_CTL('L') : self._scr.newLine()   # VT100
        elif token == TY_CTL('M') : self._scr.return_()   # VT100
        elif token == TY_CTL('N') : self._useCharset(1)   # VT100
        elif token == TY_CTL('O') : self._useCharset(0)   # VT100

        elif token == TY_CTL('P')  : pass # DLE: ignored
        elif token == TY_CTL('Q')  : pass # DC1: XON continue # VT100
        elif token == TY_CTL('R')  : pass # DC2: ignored
        elif token == TY_CTL('S')  : pass # DC3: XOFF halt # VT100
        elif token == TY_CTL('T')  : pass # DC4: ignored
        elif token == TY_CTL('U')  : pass # NAK: ignored
        elif token == TY_CTL('V')  : pass # SYN: ignored
        elif token == TY_CTL('W')  : pass # ETB: ignored
        elif token == TY_CTL('X')  : self._scr.showCharacter(0x2592) # VT100 XXX Not in spec
        elif token == TY_CTL('Y')  : pass # EM : ignored
        elif token == TY_CTL('Z')  : self._scr.showCharacter(0x2592) # VT100 XXX Not in spec
        elif token == TY_CTL('[')  : pass # ESC: cannot be seen here.
        elif token == TY_CTL('\\') : pass # FS : ignored
        elif token == TY_CTL(']')  : pass # GS : ignored
        elif token == TY_CTL('^')  : pass # RS : ignored
        elif token == TY_CTL('_')  : pass # US : ignored

        elif token == TY_ESC('D') : self._scr.index() # VT100
        elif token == TY_ESC('E') : self._scr.NextLine() # VT100
        elif token == TY_ESC('H') : self._scr.changeTabStop(True) # VT100
        elif token == TY_ESC('M') : self._scr.reverseIndex() # VT100
        elif token == TY_ESC('Z') : self.reportTerminalType()
        elif token == TY_ESC('c') : self.reset()

        elif token == TY_ESC('n') : self._useCharset(2)
        elif token == TY_ESC('o') : self._useCharset(3)
        elif token == TY_ESC('7') : self._saveCursor()
        elif token == TY_ESC('8') : self._restoreCursor()

        elif token == TY_ESC('=') : self.setMode(MODE_AppKeyPad)
        elif token == TY_ESC('>') : self.resetMode(MODE_AppKeyPad)
        elif token == TY_ESC('<') : self.setMode(MODE_Ansi) # VT52

        elif token == TY_ESC_CS('(', '0') : self._setCharset(0, '0') # VT100
        elif token == TY_ESC_CS('(', 'A') : self._setCharset(0, 'A') # VT100
        elif token == TY_ESC_CS('(', 'B') : self._setCharset(0, 'B') # VT100
        elif token == TY_ESC_CS('(', 'K') : self._setCharset(0, 'K') # VT220
        elif token == TY_ESC_CS('(', 'R') : self._setCharset(0, 'R') # VT220

        elif token == TY_ESC_CS(')', '0') : self._setCharset(1, '0') # VT100
        elif token == TY_ESC_CS(')', 'A') : self._setCharset(1, 'A') # VT100
        elif token == TY_ESC_CS(')', 'B') : self._setCharset(1, 'B') # VT100
        elif token == TY_ESC_CS(')', 'K') : self._setCharset(1, 'K') # VT220
        elif token == TY_ESC_CS(')', 'R') : self._setCharset(1, 'R') # VT220

        elif token == TY_ESC_CS('*', '0') : self._setCharset(2, '0') # VT100
        elif token == TY_ESC_CS('*', 'A') : self._setCharset(2, 'A') # VT100
        elif token == TY_ESC_CS('*', 'B') : self._setCharset(2, 'B') # VT100
        elif token == TY_ESC_CS('*', 'K') : self._setCharset(2, 'K') # VT220
        elif token == TY_ESC_CS('*', 'R') : self._setCharset(2, 'R') # VT220

        elif token == TY_ESC_CS('+', '0') : self._setCharset(3, '0') # VT100
        elif token == TY_ESC_CS('+', 'A') : self._setCharset(3, 'A') # VT100
        elif token == TY_ESC_CS('+', 'B') : self._setCharset(3, 'B') # VT100
        elif token == TY_ESC_CS('+', 'K') : self._setCharset(3, 'K') # VT220
        elif token == TY_ESC_CS('+', 'R') : self._setCharset(3, 'R') # VT220

        elif token == TY_ESC_CS('%', 'G') : self._setCodec(1) # LINUX
        elif token == TY_ESC_CS('%', '@') : self._setCodec(0) # LINUX

        elif token == TY_ESC_DE('3') : pass # IGNORED: double high, top half
        elif token == TY_ESC_DE('4') : pass # IGNORED: double high, bottom half
        elif token == TY_ESC_DE('5') : pass # IGNORED: single width, single high
        elif token == TY_ESC_DE('6') : pass # IGNORED: double width, single high
        elif token == TY_ESC_DE('8') : self._scr.helpAlign()

        elif token == TY_CSI_PS('K',   0): self._scr.clearToEndOfLine()
        elif token == TY_CSI_PS('K',   1): self._scr.clearToBeginOfLine()
        elif token == TY_CSI_PS('K',   2): self._scr.clearEntireLine()
        elif token == TY_CSI_PS('J',   0): self._scr.clearToEndOfScreen()
        elif token == TY_CSI_PS('J',   1): self._scr.clearToBeginOfScreen()
        elif token == TY_CSI_PS('J',   2): self._scr.clearEntireScreen()
        elif token == TY_CSI_PS('g',   0): self._scr.changeTabStop(False)  # VT100
        elif token == TY_CSI_PS('g',   3): self._scr.clearTabStops()       # VT100
        elif token == TY_CSI_PS('h',   4): self._scr.setMode(screen.MODE_Insert)
        elif token == TY_CSI_PS('h',  20): self.setMode(screen.MODE_NewLine)
        elif token == TY_CSI_PS('i',   0): pass # IGNORE: attached printer # VT100
        elif token == TY_CSI_PS('i',   4): pass # IGNORE: attached printer # VT100
        elif token == TY_CSI_PS('i',   5): self.setPrinterMode(True)     # VT100
        elif token == TY_CSI_PS('l',   4): self._scr.resetMode(screen.MODE_Insert)
        elif token == TY_CSI_PS('l',  20): self.resetMode(screen.MODE_NewLine)
        elif token == TY_CSI_PS('s',   0): self._saveCursor()    # XXX Not in spec
        elif token == TY_CSI_PS('u',   0): self._restoreCursor() # XXX Not in spec

        elif token == TY_CSI_PS('m',   0): self._scr.setDefaultRendition()
        elif token == TY_CSI_PS('m',   1): self._scr.setRendition(ca.RE_BOLD)      # VT100
        elif token == TY_CSI_PS('m',   4): self._scr.setRendition(ca.RE_UNDERLINE) # VT100
        elif token == TY_CSI_PS('m',   5): self._scr.setRendition(ca.RE_BLINK)     # VT100
        elif token == TY_CSI_PS('m',   7): self._scr.setRendition(ca.RE_REVERSE)
        elif token == TY_CSI_PS('m',  10): pass # IGNORED: mapping related # LINUX
        elif token == TY_CSI_PS('m',  11): pass # IGNORED: mapping related # LINUX
        elif token == TY_CSI_PS('m',  12): pass # IGNORED: mapping related # LINUX
        elif token == TY_CSI_PS('m',  22): self._scr.resetRendition(ca.RE_BOLD)
        elif token == TY_CSI_PS('m',  24): self._scr.resetRendition(ca.RE_UNDERLINE)
        elif token == TY_CSI_PS('m',  25): self._scr.resetRendition(ca.RE_BLINK)
        elif token == TY_CSI_PS('m',  27): self._scr.resetRendition(ca.RE_REVERSE)

        elif token == TY_CSI_PS('m',  30): self._scr.setForeColor(0)
        elif token == TY_CSI_PS('m',  31): self._scr.setForeColor(1)
        elif token == TY_CSI_PS('m',  32): self._scr.setForeColor(2)
        elif token == TY_CSI_PS('m',  33): self._scr.setForeColor(3)
        elif token == TY_CSI_PS('m',  34): self._scr.setForeColor(4)
        elif token == TY_CSI_PS('m',  35): self._scr.setForeColor(5)
        elif token == TY_CSI_PS('m',  36): self._scr.setForeColor(6)
        elif token == TY_CSI_PS('m',  37): self._scr.setForeColor(7)
        elif token == TY_CSI_PS('m',  39): self._scr.setForeColorToDefault()

        elif token == TY_CSI_PS('m',  40): self._scr.setBackColor(0)
        elif token == TY_CSI_PS('m',  41): self._scr.setBackColor(1)
        elif token == TY_CSI_PS('m',  42): self._scr.setBackColor(2)
        elif token == TY_CSI_PS('m',  43): self._scr.setBackColor(3)
        elif token == TY_CSI_PS('m',  44): self._scr.setBackColor(4)
        elif token == TY_CSI_PS('m',  45): self._scr.setBackColor(5)
        elif token == TY_CSI_PS('m',  46): self._scr.setBackColor(6)
        elif token == TY_CSI_PS('m',  47): self._scr.setBackColor(7)
        elif token == TY_CSI_PS('m',  49): self._scr.setBackColorToDefault()

        elif token == TY_CSI_PS('m',  90): self._scr.setForeColor( 8)
        elif token == TY_CSI_PS('m',  91): self._scr.setForeColor( 9)
        elif token == TY_CSI_PS('m',  92): self._scr.setForeColor(10)
        elif token == TY_CSI_PS('m',  93): self._scr.setForeColor(11)
        elif token == TY_CSI_PS('m',  94): self._scr.setForeColor(12)
        elif token == TY_CSI_PS('m',  95): self._scr.setForeColor(13)
        elif token == TY_CSI_PS('m',  96): self._scr.setForeColor(14)
        elif token == TY_CSI_PS('m',  97): self._scr.setForeColor(15)

        elif token == TY_CSI_PS('m', 100): self._scr.setBackColor( 8)
        elif token == TY_CSI_PS('m', 101): self._scr.setBackColor( 9)
        elif token == TY_CSI_PS('m', 102): self._scr.setBackColor(10)
        elif token == TY_CSI_PS('m', 103): self._scr.setBackColor(11)
        elif token == TY_CSI_PS('m', 104): self._scr.setBackColor(12)
        elif token == TY_CSI_PS('m', 105): self._scr.setBackColor(13)
        elif token == TY_CSI_PS('m', 106): self._scr.setBackColor(14)
        elif token == TY_CSI_PS('m', 107): self._scr.setBackColor(15)

        elif token == TY_CSI_PS('n', 5): self.reportStatus()
        elif token == TY_CSI_PS('n', 6): self.reportCursorPosition()
        elif token == TY_CSI_PS('q', 0): pass # IGNORED: LEDs off # VT100 XXX Not in spec
        elif token == TY_CSI_PS('q', 1): pass # IGNORED: LED1 on  # VT100 XXX Not in spec
        elif token == TY_CSI_PS('q', 2): pass # IGNORED: LED2 on  # VT100 XXX Not in spec
        elif token == TY_CSI_PS('q', 3): pass # IGNORED: LED3 on  # VT100 XXX Not in spec
        elif token == TY_CSI_PS('q', 4): pass # IGNORED: LED4 on  # VT100 XXX Not in spec
        elif token == TY_CSI_PS('x', 0):self.reportTerminalParams(2) # VT100
        elif token == TY_CSI_PS('x', 1):self.reportTerminalParams(3) # VT100

        elif token == TY_CSI_PN('@'): self._scr.insertChars(p)
        elif token == TY_CSI_PN('A'): self._scr.cursorUp(p)       # VT100
        elif token == TY_CSI_PN('B'): self._scr.cursorDown(p)     # VT100
        elif token == TY_CSI_PN('C'): self._scr.cursorRight(p)    # VT100
        elif token == TY_CSI_PN('D'): self._scr.cursorLeft(p)     # VT100
        elif token == TY_CSI_PN('G'): self._scr.setCursorX(p)     # LINUX
        elif token == TY_CSI_PN('H'): self._scr.setCursorYX(p, q) # VT100
        elif token == TY_CSI_PN('L'): self._scr.insertLines(p)
        elif token == TY_CSI_PN('M'): self._scr.deleteLines(p)
        elif token == TY_CSI_PN('P'): self._scr.deleteChars(p)
        elif token == TY_CSI_PN('X'): self._scr.eraseChars (p)
        elif token == TY_CSI_PN('c'): self.reportTerminalType()   # VT100
        elif token == TY_CSI_PN('d'): self._scr.setCursorY(p)     # LINUX
        elif token == TY_CSI_PN('f'): self._scr.setCursorYX(p, q) # VT100
        elif token == TY_CSI_PN('r'): self._setMargins(p, q)      # VT100 XXX Not in spec
        elif token == TY_CSI_PN('y'): pass # IGNORED: Confidence test # VT100 XXX Not in spec

        elif token == TY_CSI_PR('h',  1): self.setMode(MODE_AppCuKeys)     # VT100
        elif token == TY_CSI_PR('l',  1): self.resetMode(MODE_AppCuKeys)   # VT100
        elif token == TY_CSI_PR('s',  1): self.saveMode(MODE_AppCuKeys)    # FIXME
        elif token == TY_CSI_PR('r',  1): self.restoreMode(MODE_AppCuKeys) # FIXME

        elif token == TY_CSI_PR('l',  2): self.resetMode(MODE_Ansi) # VT100

        elif token == TY_CSI_PR('h',  3): self._setColumns(132) # VT100
        elif token == TY_CSI_PR('l',  3): self._setColumns(80)  # VT100

        elif token == TY_CSI_PR('h',  4): pass # IGNORED: soft scrolling # VT100
        elif token == TY_CSI_PR('l',  4): pass # IGNORED: soft scrolling # VT100

        elif token == TY_CSI_PR('h',  5): self._scr.setMode(screen.MODE_Screen)   # VT100
        elif token == TY_CSI_PR('l',  5): self._scr.resetMode(screen.MODE_Screen) # VT100

        elif token == TY_CSI_PR('h',  6): self._scr.setMode(screen.MODE_Origin)     # VT100
        elif token == TY_CSI_PR('l',  6): self._scr.resetMode(screen.MODE_Origin)   # VT100
        elif token == TY_CSI_PR('s',  6): self._scr.saveMode(screen.MODE_Origin)    # FIXME
        elif token == TY_CSI_PR('r',  6): self._scr.restoreMode(screen.MODE_Origin) # FIXME

        elif token == TY_CSI_PR('h',  7): self._scr.setMode(screen.MODE_Wrap)     # VT100
        elif token == TY_CSI_PR('l',  7): self._scr.resetMode(screen.MODE_Wrap)   # VT100
        elif token == TY_CSI_PR('s',  7): self._scr.saveMode(screen.MODE_Wrap)    # FIXME
        elif token == TY_CSI_PR('r',  7): self._scr.restoreMode(screen.MODE_Wrap) # FIXME

        elif token == TY_CSI_PR('h',  8): pass # IGNORED: autorepeat on  # VT100
        elif token == TY_CSI_PR('l',  8): pass # IGNORED: autorepeat off # VT100

        elif token == TY_CSI_PR('h',  9): pass # IGNORED: interlace # VT100
        elif token == TY_CSI_PR('l',  9): pass # IGNORED: interlace # VT100

        elif token == TY_CSI_PR('h', 25): self.setMode(screen.MODE_Cursor)   # VT100
        elif token == TY_CSI_PR('l', 25): self.resetMode(screen.MODE_Cursor) # VT100

        elif token == TY_CSI_PR('h', 41): pass # IGNORED: obsolete more(1) fix # XTERM
        elif token == TY_CSI_PR('l', 41): pass # IGNORED: obsolete more(1) fix # XTERM
        elif token == TY_CSI_PR('s', 41): pass # IGNORED: obsolete more(1) fix # XTERM
        elif token == TY_CSI_PR('r', 41): pass # IGNORED: obsolete more(1) fix # XTERM

        elif token == TY_CSI_PR('h', 47): self.setMode(MODE_AppScreen)     # VT100
        elif token == TY_CSI_PR('l', 47): self.resetMode(MODE_AppScreen)   # VT100
        elif token == TY_CSI_PR('s', 47): self.saveMode(MODE_AppScreen)    # XTERM
        elif token == TY_CSI_PR('r', 47): self.restoreMode(MODE_AppScreen) # XTERM

        #  XTerm defines the following modes:
        #  SET_VT200_MOUSE             1000
        #  SET_VT200_HIGHLIGHT_MOUSE   1001
        #  SET_BTN_EVENT_MOUSE         1002
        #  SET_ANY_EVENT_MOUSE         1003
        #
        #  FIXME: Modes 1000,1002 and 1003 have subtle differences which we don't
        #  support yet, we treat them all the same.

        elif token == TY_CSI_PR('h', 1000): self.setMode(MODE_Mouse1000) # XTERM
        elif token == TY_CSI_PR('l', 1000): self.resetMode(MODE_Mouse1000) # XTERM
        elif token == TY_CSI_PR('s', 1000): self.saveMode(MODE_Mouse1000) # XTERM
        elif token == TY_CSI_PR('r', 1000): self.restoreMode(MODE_Mouse1000) # XTERM

        elif token == TY_CSI_PR('h', 1001): pass # IGNORED: hilite mouse tracking # XTERM
        elif token == TY_CSI_PR('l', 1001): self.resetMode(MODE_Mouse1000)        # XTERM
        elif token == TY_CSI_PR('s', 1001): pass # IGNORED: hilite mouse tracking # XTERM
        elif token == TY_CSI_PR('r', 1001): pass # IGNORED: hilite mouse tracking # XTERM

        elif token == TY_CSI_PR('h', 1002): self.setMode(MODE_Mouse1000)     # XTERM
        elif token == TY_CSI_PR('l', 1002): self.resetMode(MODE_Mouse1000)   # XTERM
        elif token == TY_CSI_PR('s', 1002): self.saveMode(MODE_Mouse1000)    # XTERM
        elif token == TY_CSI_PR('r', 1002): self.restoreMode(MODE_Mouse1000) # XTERM

        elif token == TY_CSI_PR('h', 1003): self.setMode(MODE_Mouse1000)     # XTERM
        elif token == TY_CSI_PR('l', 1003): self.resetMode(MODE_Mouse1000)   # XTERM
        elif token == TY_CSI_PR('s', 1003): self.saveMode(MODE_Mouse1000)    # XTERM
        elif token == TY_CSI_PR('r', 1003): self.restoreMode(MODE_Mouse1000) # XTERM

        elif token == TY_CSI_PR('h', 1047): self.setMode(MODE_AppScreen) # XTERM
        elif token == TY_CSI_PR('l', 1047): # XTERM
            self._screen[1].clearEntireScreen()
            self.resetMode(MODE_AppScreen)
        elif token == TY_CSI_PR('s', 1047): self.saveMode(MODE_AppScreen)    # XTERM
        elif token == TY_CSI_PR('r', 1047): self.restoreMode(MODE_AppScreen) # XTERM

        # FIXME: Unitoken: save translations
        elif token == TY_CSI_PR('h', 1048): self._saveCursor() # XTERM
        elif token == TY_CSI_PR('l', 1048): self._restoreCursor() # XTERM
        elif token == TY_CSI_PR('s', 1048): self._saveCursor() # XTERM
        elif token == TY_CSI_PR('r', 1048): self._restoreCursor() # XTERM

        # FIXME: every once new sequences like this pop up in xterm.
        #        Here's a guess of what they could mean.
        elif token == TY_CSI_PR('h', 1049): # XTERM
            self._saveCursor()
            self._screen[1].clearEntireScreen()
            self.setMode(MODE_AppScreen)
        elif token == TY_CSI_PR('l', 1049): # XTERM
            self.resetMode(MODE_AppScreen)
            self._restoreCursor()

        # FIXME: when changing between vt52 and ansi mode evtl do some resetting.
        elif token == TY_VT52('A'): self._scr.cursorUp(1)    # VT52
        elif token == TY_VT52('B'): self._scr.cursorDown(1)  # VT52
        elif token == TY_VT52('C'): self._scr.cursorRight(1) # VT52
        elif token == TY_VT52('D'): self._scr.cursorLeft(1)  # VT52

        elif token == TY_VT52('F'): self._setAndUseCharset(0, '0') # VT52
        elif token == TY_VT52('G'): self._setAndUseCharset(0, 'B') # VT52

        elif token == TY_VT52('H'): self._scr.setCursorYX(1, 1) # VT52
        elif token == TY_VT52('I'): self._scr.reverseIndex() # VT52
        elif token == TY_VT52('J'): self._scr.clearToEndOfScreen() # VT52
        elif token == TY_VT52('K'): self._scr.clearToEndOfLine()       # VT52
        elif token == TY_VT52('Y'): self._scr.setCursorYX(p-31, q-31 ) # VT52
        elif token == TY_VT52('Z'): self.reportTerminalType()        # VT52
        elif token == TY_VT52('<'): self.setMode(MODE_Ansi)            # VT52
        elif token == TY_VT52('='): self.setMode(MODE_AppKeyPad)       # VT52
        elif token == TY_VT52('>'): self.resetMode(MODE_AppKeyPad)     # VT52

        elif token == TY_CSI_PG('c') : self.reportSecondaryAttributes() # VT100

        else:
            self.reportErrorToken(token, p, q);

    def reportErrorToken(self, token, p, q):
        api.devlog('undecodable %r, %r, %r' % (token, p, q))

    def reportCursorPosition(self):
        self.sendString("\033[%d;%dR" % (self._scr.getCursorX()+1,
                                         self._scr.getCursorY()+1))

    def setPrinterMode(self, on):
        if on:
            cmd = os.getenv("PRINT_COMMAND", "cat > /dev/null")
            self._print_fd = os.popen(cmd, "w")
        else:
            self._print_fd = None

    def printScan(self, cc):
        assert self._print_fd
        if cc == CTRL('Q') or cc == CTRL('S') or cc == 0:
            return
        self._pbuf.append(cc) # advance the state
        s = self._pbuf
        p = len(self._pbuf)
        if lec(p, s, 1, 0, ESC): return
        if lec(p, s, 2, 1, ord('[')): return
        if lec(p, s, 3, 2, ord('4')): return
        if lec(p, s, 3, 2, ord('5')): return
        if lec(p, s, 4, 3, ord('i')) and s[2] == ord('4'):
            self.setPrinterMode(False)
            self._resetToken()
            return
        self._print_fd.write(''.join([chr(c) for c in s]))
        self._resetToken()

    def _XtermHack(self):
        i = 2
        arg = ''
        while ord('0') <= self._pbuf[i] < ord('9'):
            arg += chr(self._pbuf[i])
            i += 1
        arg = int(arg)
        if self._pbuf[i] != ord(';'):
            self.reportErrorToken('xterm hack', len(self._pbuf), self._pbuf[-1])
        string = ''.join([chr(c) for c in self._pbuf[i+1:-1]])
        # arg=0 changes title and icon, arg=1 only icon, arg=2 only title
        self.myemit('changeTitle', (arg, string))

    # Obsolete stuff

    def reportTerminalType(self):
        if self.getMode(MODE_Ansi):
            self.sendString("\033[?1;2c") # I'm a VT100
        else:
            self.sendString("\033/Z")     # I'm a VT52

    def reportSecondaryAttributes(self):
        if self.getMode(MODE_Ansi):
            self.sendString("\033[>0;115;0c") # Why 115 ?
        else:
            self.sendString("\033/Z")     # I don't think VT52 knows about it...

    def reportTerminalParams(self, p):
        self.sendString("\033[%d;1;1;112;112;1;0x" % p) # Not really true

    def reportStatus(self):
        """VT100. Device status report. 0 = Ready"""
        self.sendString("\033[0n")

    def reportAnswerBack(self):
        """ANSWER_BACK "" // This is really obsolete VT100 stuff."""
        self.sendString(os.getenv("ANSWER_BACK", ''))

    # Mouse Handling ##########################################################

    def onMouse(self, cb, cx, cy):
        """Mouse clicks are possibly reported to the client application if
        it has issued interest in them.
        They are normally consumed by the widget for copy and paste, but may
        be propagated from the widget when gui->setMouseMarks is set via
        setMode(MODE_Mouse1000).

               `x',`y' are 1-based.
               `ev' (event) indicates the button pressed (0-2)
                            or a general mouse release (3).
        """
        if self._connected:
            self.sendString("\033[M%c%c%c" % (cb+040, cx+040, cy+040))

    # Keyboard Handling #######################################################

    def scrollLock(self, lock):
        self._hold_screen = lock
        if lock:
            self.sendString("\023") # XOFF (^S)
        else:
            self.sendString("\021") # XON (^Q)

    def _onScrollLock(self):
        self.scrollLock(not self._hold_screen)

    def onKeyPress(self, ev):
        """char received from the gui"""
        if not self._connected: # Someone else gets the keys
            return
        self.myemit("notifySessionState", (NOTIFYNORMAL,))
        ev_state = ev.state()
        try:
            entry = self._key_trans.findEntry(ev.key(),
                                              self.getMode(screen.MODE_NewLine),
                                              self.getMode(MODE_Ansi),
                                              self.getMode(MODE_AppCuKeys),
                                              ev_state & ControlButton == ControlButton,
                                              ev_state & ShiftButton == ShiftButton,
                                              ev_state & AltButton == AltButton)
        except kt.EntryNotFound:
            cmd = kt.CMD_none # if it ends up here the key is skipped
        else:
            cmd = entry.cmd
            if   cmd == kt.CMD_emitClipboard:   self._gui.emitSelection(False, False)
            elif cmd == kt.CMD_emitSelection:   self._gui.emitSelection(True, False)
            elif cmd == kt.CMD_scrollPageUp:    self._gui.doScroll(-self._gui.lines/2)
            elif cmd == kt.CMD_scrollPageDown:  self._gui.doScroll(+self._gui.lines/2)
            elif cmd == kt.CMD_scrollLineUp:    self._gui.doScroll(-1)
            elif cmd == kt.CMD_scrollLineDown:  self._gui.doScroll(+1)
            elif cmd == kt.CMD_prevSession:
                if qt.QApplication.reverseLayout():
                    self.myemit("nextSession")
                else:
                    self.myemit("prevSession")
            elif cmd == kt.CMD_nextSession:
                if qt.QApplication.reverseLayout():
                    self.myemit("prevSession")
                else:
                    self.myemit("nextSession")
            elif cmd == kt.CMD_newSession: self.myemit("newSession")
            elif cmd == kt.CMD_renameSession: self.myemit("renameSession")
            elif cmd == kt.CMD_activateMenu: self.myemit("activateMenu")
            elif cmd == kt.CMD_moveSessionLeft:
                if qt.QApplication.reverseLayout():
                    self.myemit("moveSessionRight")
                else:
                    self.myemit("moveSessionLeft")
            elif cmd == kt.CMD_moveSessionRight:
                if qt.QApplication.reverseLayout():
                    self.myemit("moveSessionLeft")
                else:
                    self.myemit("moveSessionRight")
            elif cmd == kt.CMD_scrollLock: self._onScrollLock()

        # Revert to non-history when typing
        if self._scr.hist_cursor != self._scr.getHistLines() and not ev.text().isEmpty() or \
           ev.key() == qt.QEvent.Key_Down or ev.key() == qt.QEvent.Key_Up or \
           ev.key() == qt.QEvent.Key_Left or ev.key() == qt.QEvent.Key_Right or \
           ev.key() == qt.QEvent.Key_PageUp or ev.key() == qt.QEvent.Key_PageDown:
            self._scr.hist_cursor = self._scr.getHistLines()

        if cmd == kt.CMD_send:
            #TODO: check whats up with the ALT escape... should we sendENTER too??
            if ev_state & AltButton and not entry.metaspecified():
                self.sendString("\033") # ESC this is the ALT prefix

            s_input = entry.txt
            api.devlog(">>>> CMD_send - s_input = %s" % s_input.encode("hex"))
            # if ENTER key was pressed we call this to emit a signal to process
            # user input
            if ev.key() == qt.Qt.Key_Return or ev.key() == qt.Qt.Key_Enter:
                new_input,old_input,old_len = self.sendENTER()
                # if input was changed (this could be due to a plugin that processed
                # the user input as a command and changed the options), we have to
                # verify it and send it to the tty
                if new_input is not None: # means something changed
                    self.sendString(new_input, True, old_len)
                    
            #api.devlog("Keypress:" + str(ev.key()) )
            if ev.key() == 32:
                self.sendCTRLSPACE()
            elif ev.key() == 4114: #left
                self.sendLEFT()
            elif ev.key() == 4116: #right
                self.sendRIGHT()
            elif ev.key() == 4115: #up
                self.sendUP()
            elif ev.key() == 4117: #down
                self.sendDOWN()
             
            
            self.sendString(s_input)
            return

        # fall back handling
        if not ev.text().isEmpty():
            if ev_state & AltButton:
                self.sendString("\033") # ESC this is the ALT prefix
            s = self._codec.fromUnicode(ev.text()) # Encode for application
            # FIXME: In Qt 2, QKeyEvent::text() would return "\003" for Ctrl-C etc.
            #        while in Qt 3 it returns the actual key ("c" or "C") which caused
            #        the ControlButton to be ignored. This hack seems to work for
            #        latin1 locales at least. Please anyone find a clean solution (malte)
            if ev_state & ControlButton:
                #print ev.ascii(), ev.key()
                s.fill(chr(ev.ascii()), 1)
            self.sendString(str(s))

    # Charset related part of the emulation state #############################

    def _applyCharset(self, c):
        return self._charset[self._scr is self._screen[1]].applyCharset(c)

    def _resetCharset(self, scrno):
        self._charset[scrno].reset()

    def _setCharset(self, n, cs):
        self._charset[0].setCharset(n, cs)
        self._charset[1].setCharset(n, cs)

    def _setAndUseCharset(self, n, cs):
        self._charset[self._scr is self._screen[1]].setCharset(n, cs)

    def _useCharset(self, n):
        self._charset[self._scr is self._screen[1]].useCharset(n)

    def _saveCursor(self):
        """save cursor position and rendition attribute _plugin_settings"""
        self._charset[self._scr is self._screen[1]].save()
        self._scr.saveCursor()

    def _restoreCursor(self):
        """restor cursor position and rendition attribute _plugin_settings"""
        self._charset[self._scr is self._screen[1]].restore()
        self._scr.restoreCursor()

    # Mode Operations #########################################################
    #
    # Some of the emulations state is either added to the state of the screens.
    #
    # This causes some scoping problems, since different emulations choose to
    # located the mode either to the current screen or to both.
    #
    # For strange reasons, the extend of the rendition attributes ranges over
    # all screens and not over the actual screen.
    #
    # We decided on the precise precise extend, somehow.

    def _resetModes(self):
        """Mode related part of the state. These are all booleans."""
        self.resetMode(MODE_Mouse1000)
        self.saveMode(MODE_Mouse1000)
        self.resetMode(MODE_AppScreen)
        self.saveMode(MODE_AppScreen)
        self.setMode(MODE_Ansi)
        self._hold_screen = False
        # Obsolete modes
        self.resetMode(MODE_AppCuKeys)
        self.saveMode(MODE_AppCuKeys)
        self.resetMode(screen.MODE_NewLine)
        # XXX those initialisations were missing from cpp code
        self.resetMode(MODE_AppKeyPad)
        self.resetMode(screen.MODE_Cursor)

    def setMode(self, m):
        self._curr_mode[m] = True
        if m == MODE_Mouse1000:
            self._gui.setMouseMarks(False)
        elif m == MODE_AppScreen:
            self._setScreen(1)
        if m < screen.MODES_SCREEN:
            self._screen[0].setMode(m)
            self._screen[1].setMode(m)

    def resetMode(self, m):
        self._curr_mode[m] = False
        if m == MODE_Mouse1000:
            self._gui.setMouseMarks(True)
        elif m == MODE_AppScreen:
            self._setScreen(0)
        if m < screen.MODES_SCREEN:
            self._screen[0].resetMode(m)
            self._screen[1].resetMode(m)

    def saveMode(self, m):
        self._save_mode[m] = self._curr_mode[m]

    def restoreMode(self, m):
        if self._save_mode[m]:
            self.setMode(m)
        else:
            self.resetMode(m)

    def getMode(self, m):
        return self._curr_mode[m]

    def setConnect(self, c):
        super(EmuVt102, self).setConnect(c)
        if c:
            # Refresh mouse mode
            if self.getMode(MODE_Mouse1000):
                self.setMode(MODE_Mouse1000)
            else:
                self.resetMode(MODE_Mouse1000)

    def _setMargins(self, t, b):
        self._screen[0].setMargins(t, b)
        self._screen[1].setMargins(t, b)

    # private #################################################################

    def _resetToken(self):
        self._pbuf = []
        self._argv = [0]

    def _addDigit(self, dig):
        self._argv[-1] = 10*self._argv[-1] + dig

########NEW FILE########
__FILENAME__ = keytrans
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""Provide the KeyTrans class.

The keyboard translation table allows to configure pyonsoles behavior
on key strokes.
FIXME: some bug crept in, disallowing '\0' to be emitted.

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Sylvain Thenault
@copyright: 2003, 2005, 2006
@organization: Logilab
@license: CECILL
"""

__revision__ = '$Id: keytrans.py,v 1.15 2006-02-15 10:24:01 alf Exp $'


import re
import sys
from os.path import basename, dirname, splitext, join, isfile
import os
import qt
#TODO: check all these paths!!
for _path in [dirname(__file__),
              join(sys.exec_prefix, 'share/pyqonsole'),
              join(dirname(__file__), "../../../../share/pyqonsole"),
              join(dirname(__file__), "../../../share/pyqonsole/ "),
              os.environ.get('PYQONSOLE_KEYTAB_DIR', './'),
              ]:
    DEFAULT_KEYTAB_FILE = join(_path, 'default.keytab')
    if isfile(DEFAULT_KEYTAB_FILE):
        break
else:
    raise ValueError("Unable to find default.keytab."
                     "Set the PYQONSOLE_KEYTAB_DIR environment variable.")
del _path

BITS_NewLine   = 0
BITS_BsHack    = 1
BITS_Ansi      = 2
BITS_AppCuKeys = 3
BITS_Control   = 4
BITS_Shift     = 5
BITS_Alt       = 6
BITS_COUNT     = 7

def encodeModes(newline, ansi, appcukeys):
    return newline + (ansi << BITS_Ansi) + (appcukeys << BITS_AppCuKeys)

def encodeButtons(control, shift, alt):
    return (control << BITS_Control) + (shift << BITS_Shift) + (alt << BITS_Alt)

CMD_none             = -1
CMD_send             =  0
CMD_emitSelection    =  1
CMD_scrollPageUp     =  2
CMD_scrollPageDown   =  3
CMD_scrollLineUp     =  4
CMD_scrollLineDown   =  5
CMD_prevSession      =  6
CMD_nextSession      =  7
CMD_newSession       =  8
CMD_activateMenu     =  9
CMD_moveSessionLeft  = 10
CMD_moveSessionRight = 11
CMD_scrollLock       = 12
CMD_emitClipboard    = 13
CMD_renameSession    = 14

_KEYMAPS = {}

def loadAll():
    kt = KeyTrans()
    kt.addKeyTrans()
    # XXX load other keytab files ?

def find(ktid=0):
    if isinstance(ktid, int):
        try:
            return _KEYMAPS[ktid]
        except KeyError:
            pass
    for kt in _KEYMAPS.values():
        if kt.id == ktid:
            return kt
    return _KEYMAPS[0]

def count():
    return len(_KEYMAPS)

class EntryNotFound(Exception): pass

class KeyEntry:
    """instances represent the individual assignments"""
    def __init__(self, ref, key, bits, mask, cmd, txt):
        self.ref = ref
        self.key = key
        self.bits = bits
        self.mask = mask
        self.cmd = cmd
        self.txt = txt

    def matches(self, key, bits, mask):
        m = self.mask & mask
        return key == self.key and (self.bits & m) == (bits & m)

    def metaspecified(self):
        return (self.mask & (1 << BITS_Alt)) and (self.bits & (1 << BITS_Alt))


class KeyTrans:
    """combines the individual assignments to a proper map
    Takes part in a collection themself.
    """

    def __init__(self, path='[builtin]'):
        self._hdr = ''
        self.num = 0
        self.path = path
        if path == '[builtin]':
            self.id = 'default'
        else:
            self.id = splitext(basename(path))[0]
        self._file_read = False
        self._table = []

    def addKeyTrans(self):
        """XXX why is this here ??"""
        self.num = count()
        _KEYMAPS[self.num] = self

    def readConfig(self):
        if self._file_read:
            return
        self._file_read = True
        if self.path == '[builtin]':
            buf = open(DEFAULT_KEYTAB_FILE)
        else:
            buf = open(self.path)
        ktr = KeytabReader(self.path, buf)
        ktr.parseTo(self)

    def addEntry(self, ref, key, bits, mask, cmd, txt):
        """returns conflicting entry if any, else create it, add it to the
        table, and return None
        """
        try:
            return self._findEntry(key, bits, mask)
        except EntryNotFound:
            entry = KeyEntry(ref, key, bits, mask, cmd, txt)
            self._table.append(entry)

    def findEntry(self, key, newline, ansi, appcukeys, control, shift, alt):
        if not self._file_read:
            self.readConfig()
        bits = encodeModes(newline, ansi, appcukeys) + encodeButtons(control, shift, alt)
        return self._findEntry(key, bits)

    def _findEntry(self, key, bits, mask=0xffff):
        for entry in self._table:
            if entry.matches(key, bits, 0xffff):
                return entry
        raise EntryNotFound('no entry matching %s %s %0x' % (key, bits, mask))

    def hdr(self):
        if not self._file_read:
            self.readConfig()
        return self._hdr



# Scanner for keyboard configuration ##########################################

OPR_SYMS = {
  "scrollLineUp":  CMD_scrollLineUp  ,
  "scrollLineDown":CMD_scrollLineDown,
  "scrollPageUp":  CMD_scrollPageUp  ,
  "scrollPageDown":CMD_scrollPageDown,
  "emitSelection": CMD_emitSelection ,
  "prevSession":   CMD_prevSession   ,
  "nextSession":   CMD_nextSession   ,
  "newSession":    CMD_newSession    ,
  "activateMenu":  CMD_activateMenu  ,
  "renameSession":  CMD_renameSession ,
  "moveSessionLeft":  CMD_moveSessionLeft   ,
  "moveSessionRight": CMD_moveSessionRight  ,
  "scrollLock":    CMD_scrollLock,
  "emitClipboard": CMD_emitClipboard,
    }

MOD_SYMS = {
  # Modifier
  "Shift":      BITS_Shift        ,
  "Control":    BITS_Control      ,
  "Alt":        BITS_Alt          ,
  # Modes
  "BsHack":     BITS_BsHack       , # deprecated
  "Ansi":       BITS_Ansi         ,
  "NewLine":    BITS_NewLine      ,
  "AppCuKeys":  BITS_AppCuKeys    ,
    }

KEY_SYMS = {
  # Grey keys
  "Escape":       qt.Qt.Key_Escape      ,
  "Tab":          qt.Qt.Key_Tab         ,
  "Backtab":      qt.Qt.Key_Backtab     ,
  "Backspace":    qt.Qt.Key_Backspace   ,
  "Return":       qt.Qt.Key_Return      ,
  "Enter":        qt.Qt.Key_Enter       ,
  "Insert":       qt.Qt.Key_Insert      ,
  "Delete":       qt.Qt.Key_Delete      ,
  "Pause":        qt.Qt.Key_Pause       ,
  "Print":        qt.Qt.Key_Print       ,
  "SysReq":       qt.Qt.Key_SysReq      ,
  "Home":         qt.Qt.Key_Home        ,
  "End":          qt.Qt.Key_End         ,
  "Left":         qt.Qt.Key_Left        ,
  "Up":           qt.Qt.Key_Up          ,
  "Right":        qt.Qt.Key_Right       ,
  "Down":         qt.Qt.Key_Down        ,
  "Prior":        qt.Qt.Key_Prior       ,
  "Next":         qt.Qt.Key_Next        ,
  "Shift":        qt.Qt.Key_Shift       ,
  "Control":      qt.Qt.Key_Control     ,
  "Meta":         qt.Qt.Key_Meta        ,
  "Alt":          qt.Qt.Key_Alt         ,
  "CapsLock":     qt.Qt.Key_CapsLock    ,
  "NumLock":      qt.Qt.Key_NumLock     ,
  "ScrollLock":   qt.Qt.Key_ScrollLock  ,
  "F1":           qt.Qt.Key_F1          ,
  "F2":           qt.Qt.Key_F2          ,
  "F3":           qt.Qt.Key_F3          ,
  "F4":           qt.Qt.Key_F4          ,
  "F5":           qt.Qt.Key_F5          ,
  "F6":           qt.Qt.Key_F6          ,
  "F7":           qt.Qt.Key_F7          ,
  "F8":           qt.Qt.Key_F8          ,
  "F9":           qt.Qt.Key_F9          ,
  "F10":          qt.Qt.Key_F10         ,
  "F11":          qt.Qt.Key_F11         ,
  "F12":          qt.Qt.Key_F12         ,
  "F13":          qt.Qt.Key_F13         ,
  "F14":          qt.Qt.Key_F14         ,
  "F15":          qt.Qt.Key_F15         ,
  "F16":          qt.Qt.Key_F16         ,
  "F17":          qt.Qt.Key_F17         ,
  "F18":          qt.Qt.Key_F18         ,
  "F19":          qt.Qt.Key_F19         ,
  "F20":          qt.Qt.Key_F20         ,
  "F21":          qt.Qt.Key_F21         ,
  "F22":          qt.Qt.Key_F22         ,
  "F23":          qt.Qt.Key_F23         ,
  "F24":          qt.Qt.Key_F24         ,
  "F25":          qt.Qt.Key_F25         ,
  "F26":          qt.Qt.Key_F26         ,
  "F27":          qt.Qt.Key_F27         ,
  "F28":          qt.Qt.Key_F28         ,
  "F29":          qt.Qt.Key_F29         ,
  "F30":          qt.Qt.Key_F30         ,
  "F31":          qt.Qt.Key_F31         ,
  "F32":          qt.Qt.Key_F32         ,
  "F33":          qt.Qt.Key_F33         ,
  "F34":          qt.Qt.Key_F34         ,
  "F35":          qt.Qt.Key_F35         ,
  "Super_L":      qt.Qt.Key_Super_L     ,
  "Super_R":      qt.Qt.Key_Super_R     ,
  "Menu":         qt.Qt.Key_Menu        ,
  "Hyper_L":      qt.Qt.Key_Hyper_L     ,
  "Hyper_R":      qt.Qt.Key_Hyper_R     ,
  # Regular keys
  "Space":        qt.Qt.Key_Space       ,
  "Exclam":       qt.Qt.Key_Exclam      ,
  "QuoteDbl":     qt.Qt.Key_QuoteDbl    ,
  "NumberSign":   qt.Qt.Key_NumberSign  ,
  "Dollar":       qt.Qt.Key_Dollar      ,
  "Percent":      qt.Qt.Key_Percent     ,
  "Ampersand":    qt.Qt.Key_Ampersand   ,
  "Apostrophe":   qt.Qt.Key_Apostrophe  ,
  "ParenLeft":    qt.Qt.Key_ParenLeft   ,
  "ParenRight":   qt.Qt.Key_ParenRight  ,
  "Asterisk":     qt.Qt.Key_Asterisk    ,
  "Plus":         qt.Qt.Key_Plus        ,
  "Comma":        qt.Qt.Key_Comma       ,
  "Minus":        qt.Qt.Key_Minus       ,
  "Period":       qt.Qt.Key_Period      ,
  "Slash":        qt.Qt.Key_Slash       ,
  "0":            qt.Qt.Key_0           ,
  "1":            qt.Qt.Key_1           ,
  "2":            qt.Qt.Key_2           ,
  "3":            qt.Qt.Key_3           ,
  "4":            qt.Qt.Key_4           ,
  "5":            qt.Qt.Key_5           ,
  "6":            qt.Qt.Key_6           ,
  "7":            qt.Qt.Key_7           ,
  "8":            qt.Qt.Key_8           ,
  "9":            qt.Qt.Key_9           ,
  "Colon":        qt.Qt.Key_Colon       ,
  "Semicolon":    qt.Qt.Key_Semicolon   ,
  "Less":         qt.Qt.Key_Less        ,
  "Equal":        qt.Qt.Key_Equal       ,
  "Greater":      qt.Qt.Key_Greater     ,
  "Question":     qt.Qt.Key_Question    ,
  "At":           qt.Qt.Key_At          ,
  "A":            qt.Qt.Key_A           ,
  "B":            qt.Qt.Key_B           ,
  "C":            qt.Qt.Key_C           ,
  "D":            qt.Qt.Key_D           ,
  "E":            qt.Qt.Key_E           ,
  "F":            qt.Qt.Key_F           ,
  "G":            qt.Qt.Key_G           ,
  "H":            qt.Qt.Key_H           ,
  "I":            qt.Qt.Key_I           ,
  "J":            qt.Qt.Key_J           ,
  "K":            qt.Qt.Key_K           ,
  "L":            qt.Qt.Key_L           ,
  "M":            qt.Qt.Key_M           ,
  "N":            qt.Qt.Key_N           ,
  "O":            qt.Qt.Key_O           ,
  "P":            qt.Qt.Key_P           ,
  "Q":            qt.Qt.Key_Q           ,
  "R":            qt.Qt.Key_R           ,
  "S":            qt.Qt.Key_S           ,
  "T":            qt.Qt.Key_T           ,
  "U":            qt.Qt.Key_U           ,
  "V":            qt.Qt.Key_V           ,
  "W":            qt.Qt.Key_W           ,
  "X":            qt.Qt.Key_X           ,
  "Y":            qt.Qt.Key_Y           ,
  "Z":            qt.Qt.Key_Z           ,
  "BracketLeft":  qt.Qt.Key_BracketLeft ,
  "Backslash":    qt.Qt.Key_Backslash   ,
  "BracketRight": qt.Qt.Key_BracketRight,
  "AsciiCircum":  qt.Qt.Key_AsciiCircum ,
  "Underscore":   qt.Qt.Key_Underscore  ,
  "QuoteLeft":    qt.Qt.Key_QuoteLeft   ,
  "BraceLeft":    qt.Qt.Key_BraceLeft   ,
  "Bar":          qt.Qt.Key_Bar         ,
  "BraceRight":   qt.Qt.Key_BraceRight  ,
  "AsciiTilde":   qt.Qt.Key_AsciiTilde  ,
    }

KEY_DEF_SPLIT_RGX = re.compile('[+-]?\W*\w+')

class KeytabReader:
    """Scanner for keyboard configuration"""

    def __init__(self, path, stream):
        self.stream = stream
        self.path = path
        self.linno = None

    def parseTo(self, kt):
        """fill the given KeyTrans according to the parsed stream

        XXX: need to check that keyboard header is encountered first
        """
        self.linno = 1
        for line in self.stream:
            line = line.strip()
            self.linno += 1
            if not line or line.startswith('#'):
                continue
            # remove comments at the end of the line
            line = line.split('#', 1)[0]
            words = line.split()
            linetype = words.pop(0)
            # check the line begins with word "key"
            if linetype == 'keyboard':
                self._parseKeyboard(kt, ' '.join(words))
            elif linetype == 'key':
                self._parseKey(kt, ' '.join(words))
            else:
                self._reportError('malformed line')

    def _parseKeyboard(self, kt, string):
        '''example keyboard line:

        keyboard "XTerm (XFree 4.x.x)"

        here only the last part is received ("keyboard" has been removed)
        '''
        if not (string[0] == '"' and string[-1] == '"'):
            self._reportError('malformed string %s' % string)
        else:
            kt._hdr = string[1:-1] # unquote

    def _parseKey(self, kt, string):
        '''example key lines

        key Escape             : "\E"
        key Tab   -Shift       : "\t"
        key Tab   +Shift-Ansi  : "\t"
        key Return-Shift+NewLine : "\r\n"
        key Return+Shift         : "\EOM"

        here only the last part is received ("key" has been removed)
        '''
        symbols, keystr = [w.strip() for w in string.split(':', 1)]
        # symbols should be a list of names with +- to concatenate them
        key = None
        mode = 0
        mask = 0
        for op_sym in KEY_DEF_SPLIT_RGX.findall(symbols):
            op_sym = op_sym.strip()
            if key is None:
                try:
                    key = KEY_SYMS[op_sym]# - 1 # XXX why -1 ?
                except KeyError:
                    self._reportError('%s is not a valid key' % op_sym)
                    return
            else:
                # search +/-
                op, mod = op_sym[0], op_sym[1:].strip()
                if not op in '+-':
                    self._reportError('expect + or - before modifier %s' % mod)
                    return
                on = op == '+'
                try:
                    bits = MOD_SYMS[mod]# - 1 # XXX why -1
                except KeyError:
                    self._reportError('%s is not a valid mode or modifier' % mod)
                    return
                if mask & (1 << bits):
                    self._reportError('mode name %s used multible times' % mod)
                else:
                    mode |= (on << bits)
                    mask |= (1 << bits)
        # decode the key
        try:
            cmd = OPR_SYMS[keystr]# - 1 # XXX why -1
        except KeyError:
            if not (keystr[0] == '"' and keystr[-1] == '"'):
                self._reportError('malformed string or operation %s' % string)
                return
            else:
                cmd = CMD_send
                keystr = eval(keystr) # unquote + evaluation of special characters
                keystr = keystr.replace('\\E', '\033')
        entry = kt.addEntry(self.linno, key, mode, mask, cmd, keystr)
        if entry:
            self._reportError('keystroke already assigned in line %d' % entry.ref)

    def _reportError(self, msg):
        print >> sys.stderr, '%s line %s: %s' % (self.linno, self.path, msg)


loadAll()

########NEW FILE########
__FILENAME__ = procctrl
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""KPROCESSCONTROLLER -- A helper class for KProcess


using a struct which contains both the pid and the status makes it
easier to write and read the data into the pipe.
especially this solves a problem which appeared on my box where
slotDoHouseKeeping() received only 4 bytes (with some debug output
around the write()'s it received all 8 bytes). don't know why this
happened, but when writing all 8 bytes at once it works here, aleXXX

struct waitdata
{
  pid_t pid
  int status
}

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Sylvain Thenault
@copyright: 2003, 2005, 2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CECILL

XXX review singleton aspect
"""
__revision__ = '$Id: procctrl.py,v 1.10 2006-02-15 10:24:01 alf Exp $'

import os
import errno
import fcntl
import select
import signal
import struct
import sys
import qt
from model.api import devlog

def waitChildren():
    """wait for all children process, yield (pid, status) each time one
    is existing
    """
    while 1:
        try:
            yield os.waitpid(-1, os.WNOHANG)
        except OSError, ex:
            if ex.errno == errno.ECHILD:
                break
            raise

theProcessController = None

class ProcessController(qt.QObject):
    """ A class for internal use by Process only. -- Exactly one instance
    of this class is generated by the first instance of Process that is
    created (a pointer to it gets stored in @ref theProcessController ).

    This class takes care of the actual (UN*X) signal handling.
    """

    def __init__(self):
        super(ProcessController, self).__init__()
        #global theProcessController
        #assert theProcessController is None
        self.old_sigCHLDHandler = None
        self.handler_set = False
        self.process_list = []
        self.fd = os.pipe()
        # delayed children cleanup timer
        self._dcc_timer = qt.QTimer()
        fcntl.fcntl(self.fd[0], fcntl.F_SETFL, os.O_NONBLOCK)
        notifier = qt.QSocketNotifier(self.fd[0], qt.QSocketNotifier.Read, self)
        self.connect(notifier, qt.SIGNAL('activated(int)'),
                     self.slotDoHousekeeping)
        self.connect(self._dcc_timer, qt.SIGNAL('timeout()'),
                                self.delayedChildrenCleanup)
        #theProcessController = self
        self.setupHandlers()

##     def __del__(self):
##         global theProcessController
##         assert theProcessController is self
##         self.resetHandlers()
##         self.notifier.setEnabled(False)
##         os.close(self.fd[0])
##         os.close(self.fd[1])
##         del self.notifier
##         theProcessController = None

    def setupHandlers(self):
        if self.handler_set:
            return
        self.old_sigCHLDHandler = signal.getsignal(signal.SIGCHLD)
        signal.signal(signal.SIGCHLD, self.sigCHLDHandler)
        #sigaction( SIGCHLD, &act, &self.old_sigCHLDHandler )
        #act.sa_handler=SIG_IGN
        #sigemptyset(&(act.sa_mask))
        #sigaddset(&(act.sa_mask), SIGPIPE)
        #act.sa_flags = 0
        #sigaction( SIGPIPE, &act, 0L)
        signal.signal(signal.SIGPIPE, signal.SIG_IGN)
        self.handler_set = True

    def resetHandlers(self):
        if not self.handler_set:
            return
        signal.signal(signal.SIGCHLD, self.old_sigCHLDHandler)
        # there should be no problem with SIGPIPE staying SIG_IGN
        self.handler_set = False

    def addProcess(self, process):
        # XXX block SIGCHLD handler, because it accesses self.process_list
        #sigset_t newset, oldset
        #sigemptyset( &newset )
        #sigaddset( &newset, SIGCHLD )
        #sigprocmask( SIG_BLOCK, &newset, &oldset )
        self.process_list.append(process)
        #sigprocmask( SIG_SETMASK, &oldset, 0 )

    def removeProcess(self, process):
        # XXX block SIGCHLD handler, because it accesses self.process_list
        #sigset_t newset, oldset
        #sigemptyset( &newset )
        #sigaddset( &newset, SIGCHLD )
        #sigprocmask( SIG_BLOCK, &newset, &oldset )
        self.process_list.remove(process)
        #sigprocmask( SIG_SETMASK, &oldset, 0 )


    def sigCHLDHandler(self, sig, frame):
        """SIGCHLD handler

        :signal: int
        :frame: frame object

        Automatically called upon SIGCHLD.

        Normally you do not need to do anything with this function but
        if your application needs to disable SIGCHLD for some time for
        reasons beyond your control, you should call this function afterwards
        to make sure that no SIGCHLDs where missed.
        """
        found = False
        # iterating the list doesn't perform any system call
        for process in self.process_list:
            if process.pid is None:
                continue
            if not process.running:
                continue
            try:
                wpid, status = os.waitpid(process.pid, os.WNOHANG)
            except OSError:
                # [Errno 10] No child processes
                # XXX: bug in process.py ?
                continue
            if wpid > 0:
                os.write(self.fd[1], struct.pack('II', wpid, status))
                devlog("sigCHLDHandler - signal = %d - wpid = %d - status = %d" % (sig, wpid, status))
                found = True
        if (not found and
            not self.old_sigCHLDHandler in (signal.SIG_IGN, signal.SIG_DFL)):
            self.old_sigCHLDHandler(sig) # call the old handler
        # handle the rest
        # XXX
        #os.write(self.fd[1], struct.pack('II', 0, 0)) # delayed waitpid()

    def slotDoHousekeeping(self, _):
        """NOTE: It can happen that QSocketNotifier fires while
        we have already read from the socket. Deal with it.

        read pid and status from the pipe.
        """
        bytes_read = ''
        while not bytes_read:
            try:
                bytes_read = os.read(self.fd[0], struct.calcsize('II'))
            except OSError, ex:
                if ex.errno == errno.EAGAIN:
                    return
                if ex.errno == errno.EINTR:
                    msg = ("Error: pipe read returned errno=%d "
                           "in ProcessController::slotDoHousekeeping")
                    print >> sys.stderr, msg % ex.errno
                    return
        if len(bytes_read) != struct.calcsize('II'):
            msg = "Error: Could not read info from signal handler %d <> %d!"
            print >> sys.stderr, msg % (len(bytes_read), struct.calcsize('II'))
            return
        pid, status = struct.unpack('II', bytes_read)
        devlog("slotDoHousekeeping - pid = %d - status = %d" % (pid, status))
        # if status != 0 means it didn't exit gracefully (running exit command for example)
         # but it was killed somehow
        if pid == 0:
            #XXX: we don't start the timer because delayedChildrenCleanup would be triggered
            # and that enters into an infinite loop that hangs the application
            #self._dcc_timer.start(100, True)
            return
        for process in self.process_list:
            if process.pid == pid:
                process.processHasExited(status)
                return

    def delayedChildrenCleanup(self):
        """this is needed e.g. for popen(), which calls waitpid() checking
        // for its forked child, if we did waitpid() directly in the SIGCHLD
        // handler, popen()'s waitpid() call would fail
        """
        for wpid, status in waitChildren():
            for process in self.process_list:
                if not process.running or process.pid != wpid:
                    continue
                # it's Process, handle it
                os.write(self.fd[1], struct.pack('II', wpid, status))
                break

    def waitForProcessExit(self, timeout):
        """
        * Wait for any process to exit and handle their exit without
        * starting an event loop.
        * This function may cause Process to emit any of its signals.
        *
        * return True if a process exited, False if no process exited within
          @p timeout seconds.
        // Due to a race condition the signal handler may have
        // failed to detect that a pid belonged to a Process
        // and defered handling to delayedChildrenCleanup()
        // Make sure to handle that first.
        """
        if self._dcc_timer.isActive():
            self._dcc_timer.stop()
            self.delayedChildrenCleanup()
        while True:
            rlist, wlist, xlist  = select.select([self.fd[0]], [], [], timeout)
            if not rlist:
                return False
            else:
                self.slotDoHousekeeping(self.fd[0])
                break
        return True


theProcessController = ProcessController()

########NEW FILE########
__FILENAME__ = session
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""Provides the Session class. Sessions are combinations of PtyProcess and
Emulation.

The stuff in here does not really belong to the terminal emulation framework. It
serves it's duty by providing a single reference to TEPTy/Emulation pairs. In
fact, it is only there to demonstrate one of the abilities of the framework:
multible sessions.

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Sylvain Thenault
@copyright: 2003, 2005-2006
@organization: Logilab
@license: CECILL
"""

__revision__ = '$Id: session.py,v 1.13 2006-02-15 10:24:01 alf Exp $'

import os
import qt
import shell.core.signalable as signalable
import shell.core.qt3.pty_ as pty_
import emulation
import emuVt102


class Session(signalable.Signalable, qt.QObject):
    """A Session is a combination of one PTyProcess and one Emulation instances
    """

    SILENCE_TIMEOUT = 10000 # milliseconds

    def __init__(self, gui, pgm, args, term, sessionid='session-1', cwd=None):
        super(Session, self).__init__()
        self.monitor_activity = False
        self._monitor_silence = False # see the property below
        self.master_mode = False
        # FIXME: using the indices here is propably very bad. We should use a
        # persistent reference instead.
        self.schema_no = 0
        self.font_no = 3
        self.app_id = "qonsole"
        self.icon_name = 'openterm'
        self.icon_text = 'qonsole'
        self.state_icon_name = ''
        self.title = ''
        self.user_title = ''
        self.te = gui
        self.pgm = pgm
        self.args = args
        self.term = term
        self.session_id = sessionid
        self.cwd = cwd
        #XXX: IMPORTANT ABOUT USER INPUT AND PROCESS OUPUT
        # PtyProcess in method dataReceived gets the child output
        # in method sendBytes it has the user input
        self.sh = pty_.PtyProcess()
        # Emulation in method sendString also has the user input
        # also check method onKeyPressed to identify when an ENTER key is pressed
        self.em = emuVt102.EmuVt102(self.te)
        self.monitor_timer = qt.QTimer(self)
        self.sh.setSize(self.te.lines, self.te.columns)
        self.sh.myconnect('block_in', self.em.onRcvBlock)
        self.sh.myconnect('done', self.done)
        self.em.myconnect('imageSizeChanged', self.sh.setSize)
        self.em.myconnect('sndBlock', self.sh.sendBytes)
        self.em.myconnect('changeTitle', self.setUserTitle)
        self.em.myconnect('notifySessionState', self.notifySessionState)
        self.connect(self.monitor_timer, qt.SIGNAL('timeout()'), self.monitorTimerDone)

    def __del__(self):
        self.sh.mydisconnect('done', self.done)

    def setMonitorSilence(self, monitor):
        if self._monitor_silence == monitor:
            return
        self._monitor_silence = monitor
        if monitor:
            self.monitor_timer.start(self.SILENCE_TIMEOUT, True)
        else:
            self.monitor_timer.stop()

    def getMonitorSilence(self):
        return self._monitor_silence

    monitor_silence = property(getMonitorSilence, setMonitorSilence)

    def run(self):
        cwd_save = os.getcwd()
        if self.cwd:
            os.chdir(self.cwd)
        self.sh.run(self.pgm, self.args, self.term, True)
        if self.cwd:
            os.chdir(cwd_save)
        # We are reachable via kwrited XXX not needed by pyqonsole ?
        self.sh.setWriteable(False)


    def setUserTitle(self, what, caption):
        """
        what=0 changes title and icon
        what=1 only icon
        what=2 only title
        """
        if what in (0, 2):
            self.user_title = caption
        if what in (0, 1):
            self.icon_text = caption
        self.myemit('updateTitle', ())

    def fullTitle(self):
        if self.user_title:
            return '%s - %s' % (self.user_title, self.title)
        return self.title

    def testAndSetStateIconName(self, newname):
        if (newname != self.state_icon_name):
            self.state_icon_name = newname
            return True
        return False

    def monitorTimerDone(self):
        self.myemit('notifySessionState', (emulation.NOTIFYSILENCE,))
        self.monitor_timer.start(self.SILENCE_TIMEOUT, True)

    def notifySessionState(self, state):
        if state == emulation.NOTIFYACTIVITY:
            if self.monitor_silence:
                self.monitor_timer.stop()
                self.monitor_timer.start(self.SILENCE_TIMEOUT, True)
            if not self.monitor_activity:
                return
        self.myemit('notifySessionState', (state,))

    def done(self, status):
        self.myemit('done', (self, status,))

    def terminate(self):
        self.sh.mydisconnect('done', self.done)
        self.sh.sendBytes("exit\r")

    def sendSignal(self, signal):
        return self.sh.kill(signal)

    def setConnect(self, connected):
        self.em.setConnect(connected)

    def keymap(self):
        return self.em.keymap()

    def setKeymap(self, kn):
        self.em.setKeymap(kn)

    def setHistory(self, history):
        self.em.setHistory(history)

    def history(self):
        return self.em.history()

    def get_shell_ps1(self):
        self.sh.sendBytes("echo $PS1")

    def set_shell_ps1(self, format):
        self.sh.sendBytes("export PS1=\"%s\"\r" % format)
        #self.sh.sendBytes("export PS1=\"\\e[1;32m<[\\u@\\h \\W]>\\$ \\e[m\"\r")
        self.sh.sendBytes("clear\r")

    def updateLastUserInputLine(self):
        """
        this is called when an interactive command finished and
        we want to save the cursor x,y coordinates for future
        user input parsing
        The coordinates are really stored in the emulation
        """
        self.em.updateLastCursorPos(True)

########NEW FILE########
__FILENAME__ = ca
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble 
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""Provide the Ca class and some other rendering utilities.

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Benjamin Longuet
@author: Frederic Mantegazza
@author: Cyrille Boullier
@author: Sylvain Thenault
@copyright: 2003, 2005-2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CECILL
"""

__revision__ = "$Id: ca.py,v 1.16 2006-02-15 10:24:01 alf Exp $"

BASE_COLORS = 2+8
_INTENSITIES = 2
TABLE_COLORS = _INTENSITIES * BASE_COLORS

DEFAULT_FORE_COLOR = -1
DEFAULT_BACK_COLOR = 0

DEFAULT_RENDITION = 0
RE_BOLD = 2**0
RE_BLINK = 2**1
RE_UNDERLINE = 2**2
RE_REVERSE = 2**3
RE_CURSOR = 2**4

    
class Ca(object):
    """a character with background / foreground colors and rendition attributes
    """
    __slots__ = ('c', 'f', 'b', 'r')
    
    def __init__(self, c=u' ', f=DEFAULT_FORE_COLOR,
                 b=DEFAULT_BACK_COLOR, r=DEFAULT_RENDITION):
        self.c = c            
        self.f = f                   
        self.b = b                   
        self.r = r            
        
    def __eq__(self, other):
        """implements the '==' operator"""
        return (self.c == other.c and self.f == other.f and 
                self.b == other.b and self.r == other.r)
    
    def __ne__(self, other):
        """implements the '!=' operator"""
        return (self.c != other.c or self.f != other.f or 
                self.b != other.b or self.r != other.r)

    def __repr__(self):
        """to help debugging"""
        return '%r %s %s %r' % (self.c, self.f, self.b, self.r)

    def isSpace(self):
        """return true if this character can be considered as a space"""
        return self.c.isspace()

    def charClass(self, word_characters=u":@-./_~"):
        """return a kind of category for this char
        * space ('  ')
        * alpha numeric ('a')
        * other (1)
        """
        char = self.c
        if char.isspace():
            return ' '
        if char.isalnum() or char in word_characters:
            return 'a'
                                  
        return 1

                          
                         
                                                     
                      
                      
                         
                               

DCA = Ca()                                         


class ColorEntry:
    """a color with additional attribute (transparent / bold)
    """
    def __init__(self, c=None, tr=False, b=False):
        self.color = c
        self.transparent = tr                
        self.bold = b                

########NEW FILE########
__FILENAME__ = common
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
"""
This module contains common functions that can be used by the shell
"""
                               
def CTRL(c):
    """return the code of the given character when typed with the control
    button enabled
    """
    return ord(c) - ord("@")

########NEW FILE########
__FILENAME__ = helpers
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""This module contains all C implemented function.
"""
__revision__ = '$Id: helpers.py,v 1.4 2006-02-15 10:24:01 alf Exp $'

from _helpers import *

########NEW FILE########
__FILENAME__ = helpers_python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
"""
 * This is an implementation of wcwidth() and wcswidth() (defined in
 * IEEE Std 1002.1-2001) for Unicode.
 *
 * http://www.opengroup.org/onlinepubs/007904975/functions/wcwidth.html
 * http://www.opengroup.org/onlinepubs/007904975/functions/wcswidth.html
 *
 * In fixed-width output devices, Latin characters all occupy a single
 * "cell" position of equal width, whereas ideographic CJK characters
 * occupy two such cells. Interoperability between terminal-line
 * applications and (teletype-style) character terminals using the
 * UTF-8 encoding requires agreement on which character should advance
 * the cursor by how many cell positions. No established formal
 * standards exist at present on which Unicode character shall occupy
 * how many cell positions on character terminals. These routines are
 * a first attempt of defining such behavior based on simple rules
 * applied to data provided by the Unicode Consortium.
 *
 * For some graphical characters, the Unicode standard explicitly
 * defines a character-cell width via the definition of the East Asian
 * FullWidth (F), Wide (W), Half-width (H), and Narrow (Na) classes.
 * In all these cases, there is no ambiguity about which width a
 * terminal shall use. For characters in the East Asian Ambiguous (A)
 * class, the width choice depends purely on a preference of backward
 * compatibility with either historic CJK or Western practice.
 * Choosing single-width for these characters is easy to justify as
 * the appropriate long-term solution, as the CJK practice of
 * displaying these characters as double-width comes from historic
 * implementation simplicity (8-bit encoded characters were displayed
 * single-width and 16-bit ones double-width, even for Greek,
 * Cyrillic, etc.) and not any typographic considerations.
 *
 * Much less clear is the choice of width for the Not East Asian
 * (Neutral) class. Existing practice does not dictate a width for any
 * of these characters. It would nevertheless make sense
 * typographically to allocate two character cells to characters such
 * as for instance EM SPACE or VOLUME INTEGRAL, which cannot be
 * represented adequately with a single-width glyph. The following
 * routines at present merely assign a single-cell width to all
 * neutral characters, in the interest of simplicity. This is not
 * entirely satisfactory and should be reconsidered before
 * establishing a formal standard in this area. At the moment, the
 * decision which Not East Asian (Neutral) characters should be
 * represented by double-width glyphs cannot yet be answered by
 * applying a simple rule from the Unicode database content. Setting
 * up a proper standard for the behavior of UTF-8 character terminals
 * will require a careful analysis not only of each Unicode character,
 * but also of each presentation form, something the author of these
 * routines has avoided to do so far.
 *
 * http://www.unicode.org/unicode/reports/tr11/
 *
 * Markus Kuhn -- 2003-05-20 (Unicode 4.0)
 *
 * Permission to use, copy, modify, and distribute this software
 * for any purpose and without fee is hereby granted. The author
 * disclaims all warranties with regard to this software.
 *
 * Latest version: http://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c

 """


# auxiliary function for binary search in interval table 
def _bisearch(ucs, table):
  min = 0
  max = len(table)-1

  if ucs < table[0][0] or ucs > table[max][1]:
    return 0
  while max >= min:
    mid = (min + max) / 2
    if ucs > table[mid][1]:
      min = mid + 1
    elif ucs < table[mid][0]:
      max = mid - 1
    else:
      return 1

  return 0

"""
 * The following two functions define the column width of an ISO 10646
 * character as follows:
 *
 *    - The null character (U+0000) has a column width of 0.
 *
 *    - Other C0/C1 control characters and DEL will lead to a return
 *      value of -1.
 *
 *    - Non-spacing and enclosing combining characters (general
 *      category code Mn or Me in the Unicode database) have a
 *      column width of 0.
 *
 *    - SOFT HYPHEN (U+00AD) has a column width of 1.
 *
 *    - Other format characters (general category code Cf in the Unicode
 *      database) and ZERO WIDTH SPACE (U+200B) have a column width of 0.
 *
 *    - Hangul Jamo medial vowels and final consonants (U+1160-U+11FF)
 *      have a column width of 0.
 *
 *    - Spacing characters in the East Asian Wide (W) or East Asian
 *      Full-width (F) category as defined in Unicode Technical
 *      Report #11 have a column width of 2.
 *
 *    - All remaining characters (including all printable
 *      ISO 8859-1 and WGL4 characters, Unicode control characters,
 *      etc.) have a column width of 1.
 *
 * This implementation assumes that wchar_t characters are encoded
 * in ISO 10646.
 """

"""
sorted list of non-overlapping intervals of non-spacing characters 
generated by "uniset +cat=Me +cat=Mn +cat=Cf -00AD +1160-11FF +200B c"
"""

_combining = [
  ( 0x0300, 0x0357 ), ( 0x035D, 0x036F ), ( 0x0483, 0x0486 ),
  ( 0x0488, 0x0489 ), ( 0x0591, 0x05A1 ), ( 0x05A3, 0x05B9 ),
  ( 0x05BB, 0x05BD ), ( 0x05BF, 0x05BF ), ( 0x05C1, 0x05C2 ),
  ( 0x05C4, 0x05C4 ), ( 0x0600, 0x0603 ), ( 0x0610, 0x0615 ),
  ( 0x064B, 0x0658 ), ( 0x0670, 0x0670 ), ( 0x06D6, 0x06E4 ),
  ( 0x06E7, 0x06E8 ), ( 0x06EA, 0x06ED ), ( 0x070F, 0x070F ),
  ( 0x0711, 0x0711 ), ( 0x0730, 0x074A ), ( 0x07A6, 0x07B0 ),
  ( 0x0901, 0x0902 ), ( 0x093C, 0x093C ), ( 0x0941, 0x0948 ),
  ( 0x094D, 0x094D ), ( 0x0951, 0x0954 ), ( 0x0962, 0x0963 ),
  ( 0x0981, 0x0981 ), ( 0x09BC, 0x09BC ), ( 0x09C1, 0x09C4 ),
  ( 0x09CD, 0x09CD ), ( 0x09E2, 0x09E3 ), ( 0x0A01, 0x0A02 ),
  ( 0x0A3C, 0x0A3C ), ( 0x0A41, 0x0A42 ), ( 0x0A47, 0x0A48 ),
  ( 0x0A4B, 0x0A4D ), ( 0x0A70, 0x0A71 ), ( 0x0A81, 0x0A82 ),
  ( 0x0ABC, 0x0ABC ), ( 0x0AC1, 0x0AC5 ), ( 0x0AC7, 0x0AC8 ),
  ( 0x0ACD, 0x0ACD ), ( 0x0AE2, 0x0AE3 ), ( 0x0B01, 0x0B01 ),
  ( 0x0B3C, 0x0B3C ), ( 0x0B3F, 0x0B3F ), ( 0x0B41, 0x0B43 ),
  ( 0x0B4D, 0x0B4D ), ( 0x0B56, 0x0B56 ), ( 0x0B82, 0x0B82 ),
  ( 0x0BC0, 0x0BC0 ), ( 0x0BCD, 0x0BCD ), ( 0x0C3E, 0x0C40 ),
  ( 0x0C46, 0x0C48 ), ( 0x0C4A, 0x0C4D ), ( 0x0C55, 0x0C56 ),
  ( 0x0CBC, 0x0CBC ), ( 0x0CBF, 0x0CBF ), ( 0x0CC6, 0x0CC6 ),
  ( 0x0CCC, 0x0CCD ), ( 0x0D41, 0x0D43 ), ( 0x0D4D, 0x0D4D ),
  ( 0x0DCA, 0x0DCA ), ( 0x0DD2, 0x0DD4 ), ( 0x0DD6, 0x0DD6 ),
  ( 0x0E31, 0x0E31 ), ( 0x0E34, 0x0E3A ), ( 0x0E47, 0x0E4E ),
  ( 0x0EB1, 0x0EB1 ), ( 0x0EB4, 0x0EB9 ), ( 0x0EBB, 0x0EBC ),
  ( 0x0EC8, 0x0ECD ), ( 0x0F18, 0x0F19 ), ( 0x0F35, 0x0F35 ),
  ( 0x0F37, 0x0F37 ), ( 0x0F39, 0x0F39 ), ( 0x0F71, 0x0F7E ),
  ( 0x0F80, 0x0F84 ), ( 0x0F86, 0x0F87 ), ( 0x0F90, 0x0F97 ),
  ( 0x0F99, 0x0FBC ), ( 0x0FC6, 0x0FC6 ), ( 0x102D, 0x1030 ),
  ( 0x1032, 0x1032 ), ( 0x1036, 0x1037 ), ( 0x1039, 0x1039 ),
  ( 0x1058, 0x1059 ), ( 0x1160, 0x11FF ), ( 0x1712, 0x1714 ),
  ( 0x1732, 0x1734 ), ( 0x1752, 0x1753 ), ( 0x1772, 0x1773 ),
  ( 0x17B4, 0x17B5 ), ( 0x17B7, 0x17BD ), ( 0x17C6, 0x17C6 ),
  ( 0x17C9, 0x17D3 ), ( 0x17DD, 0x17DD ), ( 0x180B, 0x180D ),
  ( 0x18A9, 0x18A9 ), ( 0x1920, 0x1922 ), ( 0x1927, 0x1928 ),
  ( 0x1932, 0x1932 ), ( 0x1939, 0x193B ), ( 0x200B, 0x200F ),
  ( 0x202A, 0x202E ), ( 0x2060, 0x2063 ), ( 0x206A, 0x206F ),
  ( 0x20D0, 0x20EA ), ( 0x302A, 0x302F ), ( 0x3099, 0x309A ),
  ( 0xFB1E, 0xFB1E ), ( 0xFE00, 0xFE0F ), ( 0xFE20, 0xFE23 ),
  ( 0xFEFF, 0xFEFF ), ( 0xFFF9, 0xFFFB ), ( 0x1D167, 0x1D169 ),
  ( 0x1D173, 0x1D182 ), ( 0x1D185, 0x1D18B ), ( 0x1D1AA, 0x1D1AD ),
  ( 0xE0001, 0xE0001 ), ( 0xE0020, 0xE007F ), ( 0xE0100, 0xE01EF )
]

def wcwidth(c):
  """
  Return the width in character cells of the Unicode character
  whose code is c
  """

  ucs = ord(c)
  # test for 8-bit control characters 
  if ucs == 0:
    return 0
  if ucs < 32 or (ucs >= 0x7f and ucs < 0xa0):
    return -1

  # binary search in table of non-spacing characters 
  if _bisearch(ucs, _combining):
    return 0

  # if we arrive here, ucs is not a combining or C0/C1 control character 

  return 1+ \
    (ucs >= 0x1100 and
     (ucs <= 0x115f or                  # Hangul Jamo init. consonants 
      ucs == 0x2329 or ucs == 0x232a or
      (ucs >= 0x2e80 and ucs <= 0xa4cf and
       ucs != 0x303f) or                # CJK ... Yi 
      (ucs >= 0xac00 and ucs <= 0xd7a3) or # Hangul Syllables 
      (ucs >= 0xf900 and ucs <= 0xfaff) or # CJK Compatibility Ideographs *
      (ucs >= 0xfe30 and ucs <= 0xfe6f) or # CJK Compatibility Forms 
      (ucs >= 0xff00 and ucs <= 0xff60) or # Fullwidth Forms 
      (ucs >= 0xffe0 and ucs <= 0xffe6) or
      (ucs >= 0x20000 and ucs <= 0x2fffd) or
      (ucs >= 0x30000 and ucs <= 0x3fffd)))

def wcswidth( pwcs ):

  """
  Return the width in character cells of the unicode string pwcs,
  or -1 if the string contains non-printable characters.
  """
  
  width = 0
  for c in pwcs:
    w = wcwidth(c)
    if w < 0:
      return -1
    else:
      width += w
  return width


"""
sorted list of non-overlapping intervals of East Asian Ambiguous
characters, generated by "uniset +WIDTH-A -cat=Me -cat=Mn -cat=Cf c"
"""
_ambiguous = [
  ( 0x00A1, 0x00A1 ), ( 0x00A4, 0x00A4 ), ( 0x00A7, 0x00A8 ),
  ( 0x00AA, 0x00AA ), ( 0x00AE, 0x00AE ), ( 0x00B0, 0x00B4 ),
  ( 0x00B6, 0x00BA ), ( 0x00BC, 0x00BF ), ( 0x00C6, 0x00C6 ),
  ( 0x00D0, 0x00D0 ), ( 0x00D7, 0x00D8 ), ( 0x00DE, 0x00E1 ),
  ( 0x00E6, 0x00E6 ), ( 0x00E8, 0x00EA ), ( 0x00EC, 0x00ED ),
  ( 0x00F0, 0x00F0 ), ( 0x00F2, 0x00F3 ), ( 0x00F7, 0x00FA ),
  ( 0x00FC, 0x00FC ), ( 0x00FE, 0x00FE ), ( 0x0101, 0x0101 ),
  ( 0x0111, 0x0111 ), ( 0x0113, 0x0113 ), ( 0x011B, 0x011B ),
  ( 0x0126, 0x0127 ), ( 0x012B, 0x012B ), ( 0x0131, 0x0133 ),
  ( 0x0138, 0x0138 ), ( 0x013F, 0x0142 ), ( 0x0144, 0x0144 ),
  ( 0x0148, 0x014B ), ( 0x014D, 0x014D ), ( 0x0152, 0x0153 ),
  ( 0x0166, 0x0167 ), ( 0x016B, 0x016B ), ( 0x01CE, 0x01CE ),
  ( 0x01D0, 0x01D0 ), ( 0x01D2, 0x01D2 ), ( 0x01D4, 0x01D4 ),
  ( 0x01D6, 0x01D6 ), ( 0x01D8, 0x01D8 ), ( 0x01DA, 0x01DA ),
  ( 0x01DC, 0x01DC ), ( 0x0251, 0x0251 ), ( 0x0261, 0x0261 ),
  ( 0x02C4, 0x02C4 ), ( 0x02C7, 0x02C7 ), ( 0x02C9, 0x02CB ),
  ( 0x02CD, 0x02CD ), ( 0x02D0, 0x02D0 ), ( 0x02D8, 0x02DB ),
  ( 0x02DD, 0x02DD ), ( 0x02DF, 0x02DF ), ( 0x0391, 0x03A1 ),
  ( 0x03A3, 0x03A9 ), ( 0x03B1, 0x03C1 ), ( 0x03C3, 0x03C9 ),
  ( 0x0401, 0x0401 ), ( 0x0410, 0x044F ), ( 0x0451, 0x0451 ),
  ( 0x2010, 0x2010 ), ( 0x2013, 0x2016 ), ( 0x2018, 0x2019 ),
  ( 0x201C, 0x201D ), ( 0x2020, 0x2022 ), ( 0x2024, 0x2027 ),
  ( 0x2030, 0x2030 ), ( 0x2032, 0x2033 ), ( 0x2035, 0x2035 ),
  ( 0x203B, 0x203B ), ( 0x203E, 0x203E ), ( 0x2074, 0x2074 ),
  ( 0x207F, 0x207F ), ( 0x2081, 0x2084 ), ( 0x20AC, 0x20AC ),
  ( 0x2103, 0x2103 ), ( 0x2105, 0x2105 ), ( 0x2109, 0x2109 ),
  ( 0x2113, 0x2113 ), ( 0x2116, 0x2116 ), ( 0x2121, 0x2122 ),
  ( 0x2126, 0x2126 ), ( 0x212B, 0x212B ), ( 0x2153, 0x2154 ),
  ( 0x215B, 0x215E ), ( 0x2160, 0x216B ), ( 0x2170, 0x2179 ),
  ( 0x2190, 0x2199 ), ( 0x21B8, 0x21B9 ), ( 0x21D2, 0x21D2 ),
  ( 0x21D4, 0x21D4 ), ( 0x21E7, 0x21E7 ), ( 0x2200, 0x2200 ),
  ( 0x2202, 0x2203 ), ( 0x2207, 0x2208 ), ( 0x220B, 0x220B ),
  ( 0x220F, 0x220F ), ( 0x2211, 0x2211 ), ( 0x2215, 0x2215 ),
  ( 0x221A, 0x221A ), ( 0x221D, 0x2220 ), ( 0x2223, 0x2223 ),
  ( 0x2225, 0x2225 ), ( 0x2227, 0x222C ), ( 0x222E, 0x222E ),
  ( 0x2234, 0x2237 ), ( 0x223C, 0x223D ), ( 0x2248, 0x2248 ),
  ( 0x224C, 0x224C ), ( 0x2252, 0x2252 ), ( 0x2260, 0x2261 ),
  ( 0x2264, 0x2267 ), ( 0x226A, 0x226B ), ( 0x226E, 0x226F ),
  ( 0x2282, 0x2283 ), ( 0x2286, 0x2287 ), ( 0x2295, 0x2295 ),
  ( 0x2299, 0x2299 ), ( 0x22A5, 0x22A5 ), ( 0x22BF, 0x22BF ),
  ( 0x2312, 0x2312 ), ( 0x2460, 0x24E9 ), ( 0x24EB, 0x254B ),
  ( 0x2550, 0x2573 ), ( 0x2580, 0x258F ), ( 0x2592, 0x2595 ),
  ( 0x25A0, 0x25A1 ), ( 0x25A3, 0x25A9 ), ( 0x25B2, 0x25B3 ),
  ( 0x25B6, 0x25B7 ), ( 0x25BC, 0x25BD ), ( 0x25C0, 0x25C1 ),
  ( 0x25C6, 0x25C8 ), ( 0x25CB, 0x25CB ), ( 0x25CE, 0x25D1 ),
  ( 0x25E2, 0x25E5 ), ( 0x25EF, 0x25EF ), ( 0x2605, 0x2606 ),
  ( 0x2609, 0x2609 ), ( 0x260E, 0x260F ), ( 0x2614, 0x2615 ),
  ( 0x261C, 0x261C ), ( 0x261E, 0x261E ), ( 0x2640, 0x2640 ),
  ( 0x2642, 0x2642 ), ( 0x2660, 0x2661 ), ( 0x2663, 0x2665 ),
  ( 0x2667, 0x266A ), ( 0x266C, 0x266D ), ( 0x266F, 0x266F ),
  ( 0x273D, 0x273D ), ( 0x2776, 0x277F ), ( 0xE000, 0xF8FF ),
  ( 0xFFFD, 0xFFFD ), ( 0xF0000, 0xFFFFD ), ( 0x100000, 0x10FFFD )
]

"""
 * The following functions are the same as mk_wcwidth() and
 * mk_wcwidth_cjk(), except that spacing characters in the East Asian
 * Ambiguous (A) category as defined in Unicode Technical Report #11
 * have a column width of 2. This variant might be useful for users of
 * CJK legacy encodings who want to migrate to UCS without changing
 * the traditional terminal character-width behaviour. It is not
 * otherwise recommended for general use.
"""

def wcwidth_cjk(ucs):
  """ As wcwidth above, but spacing characters in the East Asian
  Ambiguous (A) category as defined in Unicode Technical Report #11
  have a column width of 2.
  """
  if _bisearch(ucs, _ambiguous):
    return 2
  else:
    return wcwidth(ucs)

def wcswidth_cjk(pwcs):
  """ As wcswidth above, but spacing characters in the East Asian
  Ambiguous (A) category as defined in Unicode Technical Report #11
  have a column width of 2.
  """
  width = 0
  for c in pwcs:
    w = wcwidth_cjk(c)
    if w < 0:
      return -1
    else:
      width += w
  return width

#####################################################################

def _measure_string(ucs, length):
  t = 0
  i = 0
  while t < length and i < len(ucs):
    t += wcswidth(ucs[i])
    i += 1
  return (ucs[:i], t)

def rpadstring(ucs, length, padchar=' '):
  """ Right-pad a Unicode string with padchar so that its width in
  character cells is length.  Padchar must be of width 1.  The string
  is truncated if it is too long."""

  s, t = _measure_string(ucs,length)

  if t > length:
    return s[:-1] + padchar
  elif t < length:
    return s + padchar * (length-t)
  else:
    return s

def truncatestring(ucs, length):
  """ Truncate a Unicode string so that its length is as long as it
  can be without exceeding length."""

  s, t = _measure_string(ucs,length)

  if t > length:
    return s[:-1]
  else:
    return s

def wcWidth(c):
    return wcwidth(chr(c))

########NEW FILE########
__FILENAME__ = history
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble 
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""Provides the History class.

An arbitrary long scroll.

   One can modify the scroll only by adding either cells
   or newlines, but access it randomly.

   The model is that of an arbitrary wide typewriter scroll
   in that the scroll is a serie of lines and each line is
   a serie of cells with no overwriting permitted.

   The implementation provides arbitrary length and numbers
   of cells and line/column indexed read access to the scroll
   at constant costs.

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Benjamin Longuet
@author: Frederic Mantegazza
@author: Cyrille Boullier
@author: Sylvain Thenault
@copyright: 2003, 2005, 2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CECILL
"""

__revision__ = '$Id: history.py,v 1.10 2006-02-15 10:24:01 alf Exp $'
    
    
class HistoryTypeNone(object):
    """History Type which does nothing"""
    nb_lines = 0
    
    def getScroll(self, old=None):
        """return an instance of history implementation associated with
        this type
        """
        return HistoryScrollNone()
        

class HistoryTypeBuffer(HistoryTypeNone):
    """History Type using a buffer"""
    def __init__(self, nb_lines):
        super(HistoryTypeBuffer, self).__init__()
        self.nb_lines = nb_lines
        
    def getScroll(self, old=None):
        """return an instance of history implementation associated with
        this type
        """
        if not old:
            return HistoryScrollBuffer(self.nb_lines)
        if isinstance(old, HistoryScrollBuffer):
            old.setMaxLines(self.nb_lines)
            return old
        scroll = HistoryScrollBuffer(self.nb_lines)
        start = 0
        if self.nb_lines < old.lines:
            start = old.lines - self.nb_lines
        for i in xrange(start, old.lines):
            scroll.addCells(old.getCells(i, 0), old.isWrappedLine(i))
        return scroll

    
class HistoryScrollNone(object):
    """History Scroll which does nothing"""
    
    def __init__(self, type_=HistoryTypeNone()):
        self.type = type_
        self.lines = 0
        
    def getLineLen(self, lineno):
        """return the size of the given line"""
        return 0
    
    def isWrappedLine(self, lineno):
        """tells wether the given line is a wrapped line"""
        return False
        
    def hasScroll(self):
        """return True if this history is scrollable"""
        return False
    
    def getCells(self, lineno, colno, count=None):
        """return cells of the given line"""
        return None
    
    def addCells(self, cells, wrapped=False):
        """add a line to the history with cells a list of Ca()"""
        pass
   

class HistoryScrollBuffer(HistoryScrollNone):
    """History Scroll using a circulary buffer"""
    
    def __init__(self, max_lines):
        super (HistoryScrollBuffer, self).__init__(HistoryTypeBuffer(max_lines))
        self.max_lines = max_lines
        self.lines = 0
        self.array_index = 0
        self.buff_filled = False
        self.hist_buffer = [None] * max_lines
        self.wrapped_line = [False] * max_lines
        
    def hasScroll(self):
        """return True if this history is scrollable"""
        return True
    
    def addCells(self, cells, wrapped=False):
        """add a line to the history with cells a list of Ca()"""
        self.hist_buffer[self.array_index] = cells
        self.wrapped_line[self.array_index] = wrapped
        self.array_index += 1
        if self.array_index >= self.max_lines:
            self.array_index = 0
            self.buff_filled = True
        if self.lines < self.max_lines - 1:
            self.lines += 1

    def getLineLen(self, lineno):
        """return the size of the given line"""
        if lineno >= self.max_lines:
            return 0
        line = self.hist_buffer[self._adjustLineNo(lineno)]
        if line is not None:
            return len(line)
        return 0

    def isWrappedLine(self, lineno):
        """tells wether the given line is a wrapped line"""
        if lineno >= self.max_lines:
            return 0
        return self.wrapped_line[self._adjustLineNo(lineno)]

    def getCells(self, lineno, colno, count=None):
        """return cells of the given line"""
        assert lineno < self.max_lines
        lineno = self._adjustLineNo(lineno)
        line = self.hist_buffer[lineno]
        assert line is not None
        if count is None:
            count = len(line)
        return line[colno:colno + count]

    def setMaxLines(self, max_lines):
        """change the maximum number of lines for the history"""
        self._normalize()
        if self.max_lines > max_lines:
            start = max(0, self.array_index + 2 - max_lines)
            end = start + max_lines
            self.hist_buffer = self.hist_buffer[start:end]
            self.wrapped_line = self.wrapped_line[start:end]
            if self.array_index > max_lines:
                self.array_index = max_lines - 2
        else:
            self.hist_buffer += [None] * (max_lines - self.max_lines)
            self.wrapped_line += [False] * (max_lines - self.max_lines)
        self.max_lines = max_lines
        if self.lines > max_lines - 2:
            self.lines = max_lines - 2
        self.type = HistoryTypeBuffer(max_lines)

    def _normalize(self):
        """normalize the history buffer"""
        if not self.buff_filled: # or not self.array_index:
            return
        max_lines = self.max_lines
        hist_buffer = [None] * max_lines
        wrapped_line = [False] * max_lines
        for k, i in enumerate(xrange(self.array_index - 1,
                                     self.array_index-max_lines+1, -1)):
            hist_buffer[max_lines - 3 - k] = self.hist_buffer[i]
            wrapped_line[max_lines - 3 - k] = self.wrapped_line[i]
        self.hist_buffer = hist_buffer
        self.wrapped_line = wrapped_line
        self.array_index = max_lines - 2
        self.buff_filled = False
        self.lines = max_lines - 2

    def _adjustLineNo(self, lineno):
        """adjust the given line number according to the buffer state"""
        if self.buff_filled:
            return (lineno + self.array_index + 2) % self.max_lines
        else:
            return lineno

########NEW FILE########
__FILENAME__ = pty_
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
"""Pseudo Terminal Device

    Pseudo terminals are a unique feature of UNIX, and always come in form of
    pairs of devices (/dev/ptyXX and /dev/ttyXX), which are connected to each
    other by the operating system. One may think of them as two serial devices
    linked by a null-modem cable. Being based on devices the number of
    simultanous instances of this class is (globally) limited by the number of
    those device pairs, which is 256.

    Another technic are UNIX 98 PTY's. These are supported also, and prefered
    over the (obsolete) predecessor.

    There's a sinister ioctl(2), signal(2) and job control stuff
    nessesary to make everything work as it should.

    Much of the stuff can be simplified by using openpty from glibc2.
    Compatibility issues with obsolete installations and other unixes
    may prevent this.

Based on the konsole code from Lars Doelle.


@author: Lars Doelle
@author: Sylvain Thenault
@copyright: 2003, 2005, 2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CECILL
"""

__revision__ = '$Id: pty_.py,v 1.23 2006-02-15 10:24:01 alf Exp $'

import os
import errno
import select
import signal
import stat
import sys
from pty import openpty
from struct import pack
from fcntl import ioctl, fcntl, F_SETFL
from resource import getrlimit, RLIMIT_NOFILE
from termios import tcgetattr, tcsetattr, VINTR, VQUIT, VERASE, \
     TIOCSPGRP, TCSANOW, TIOCSWINSZ, TIOCSCTTY

import qt
import shell.core.signalable as signalable
from shell.core.common import CTRL
import shell.controller.qt3.procctrl as procctrl


class Job:
    def __init__(self, string):
        self.start = 0
        self.string = string
        self.length = len(string)

    def finished(self):
        return self.start == len(self.string)


class PtyProcess(signalable.Signalable, qt.QObject):
    """fork a process using a controlling terminal

    Ptys provide a pseudo terminal connection to a program, with child process
    invocation, monitoring and control.

    Although closely related to pipes, these pseudo terminal connections have
    some ability, that makes it nessesary to uses them. Most importent, they
    know about changing screen sizes and UNIX job control.

    Within the terminal emulation framework, this class represents the
    host side of the terminal together with the connecting serial line.

    One can create many instances of this class within a program.
    As a side effect of using this class, a signal(2) handler is
    installed on SIGCHLD.
    """

    def __init__(self):
        super(PtyProcess, self).__init__()
        # the process id of the process.
        # If it is called after the process has exited, it returns the process
        # id of the last child process that was created by this instance of
        # Process.
        # Calling it before any child process has been started by this
        # Process instance causes pid to be 0.
        self.pid = None
        # The process' exit status as returned by "waitpid".
        self.status = None
        # True if the process is currently running.
        self.running = False
        # the stdout socket descriptors
        self.out = [-1, -1]
        # the socket notifiers for the above socket descriptors
        self._outnot = None
        procctrl.theProcessController.addProcess(self)
        self.wsize = (0, 0)
        self.addutmp = False
        self.term = None
        self.openPty()
        self._pending_send_jobs = []
        self._pending_send_job_timer = None
        self.myconnect('receivedStdout', self.dataReceived)
        self.myconnect('processExited',  self.donePty)

    def XXX__del__(self):
        # destroying the Process instance sends a SIGKILL to the
        # child process (if it is running) after removing it from the
        # list of valid processes
        procctrl.theProcessController.removeProcess(self)
        # this must happen before we kill the child
        # TODO: block the signal while removing the current process from the
        # process list
        if self.running:
            self.kill(signal.SIGKILL)
        # Clean up open fd's and socket notifiers.
        self.closeStdout()
        # TODO: restore SIGCHLD and SIGPIPE handler if this is the last Process

    def run(self, pgm, args, term, addutmp):
        """start the client program

        having a `run' separate from the constructor allows to make
        the necessary connections to the signals and slots of the
        instance before starting the execution of the client
        """
        self.term = term
        self.addutmp = addutmp
        self.start([pgm] + args)
        self.resume()

    def openPty(self):
        """"""
        self.master_fd, self.slave_fd = openpty()
        #print os.ttyname(self.master_fd)
        #print os.ttyname(self.slave_fd)
        fcntl(self.master_fd, F_SETFL, os.O_NDELAY)
        return self.master_fd

    def setWriteable(self, writeable):
        """set the slave pty writable"""
        ttyname = os.ttyname(self.slave_fd)
        mode = os.stat(ttyname).st_mode
        if writeable:
            mode |= stat.S_IWGRP
        else:
            mode &= ~(stat.S_IWGRP|stat.S_IWOTH)
        os.chmod(ttyname, mode)

    def setSize(self, lines, columns):
        """Informs the client program about the actual size of the window."""
        #print 'PTY set size', lines, columns
        self.wsize = (lines, columns)
        if self.master_fd is None:
            return
        #print 'PTY propagate size'
        ioctl(self.master_fd, TIOCSWINSZ, pack('4H', lines, columns, 0, 0))

    def setupCommunication(self):
        """overriden from Process"""
        self.out[0] = self.master_fd
        self.out[1] = os.dup(2) # Dummy

    def sendBytes(self, string):
        """sends len bytes through the line"""
        #XXX: print "INPUT (sendByte): ", string
        if self._pending_send_jobs:
            self.appendSendJob(string)
        else:
            written = 0
            while written < len(string):
                try:
                    written += os.write(self.master_fd, string[written:])
                except OSError, ex:
                    if ex.errno in (errno.EAGAIN, errno.EINTR):
                        self.appendSendJob(string)
                    return

    def appendSendJob(self, string):
        """"""
        self._pending_send_jobs.append(Job(string))
        if not self._pending_send_job_timer:
            self._pending_send_job_timer = qt.QTimer()
            self._pending_send_job_timer.connect(self._pending_send_job_timer,
                                                 qt.SIGNAL('timeout()'),
                                                 self.doSendJobs)
        self._pending_send_job_timer.start(0)

    def doSendJobs(self):
        """qt slot"""
        while self._pending_send_jobs:
            job = self._pending_send_jobs[0]
            job.start += os.write(self.master_fd, job.string[job.start:])
            #if ( errno!=EAGAIN and errno!=EINTR )
            #   self._pending_send_jobs.remove(self._pending_send_jobs.begin())
            #   return
            if job.finished():
                self._pending_send_jobs.remove(job)
        if self._pending_send_job_timer:
            self._pending_send_job_timer.stop()

    def dataReceived(self, fd, lenlist):
        """qt slot: indicates that a block of data is received """
        try:
            buf = os.read(fd, 4096)
        except OSError:
            import traceback
            traceback.print_exc()
            return
        lenlist[0] = len(buf)
        if not buf:
            return

        #XXX: these two signals are the same and we could have used the same one
        # but it is just to order code
        
        #TODO: consider the option of not sending the block_in signal here
        # and avoid showing things on the terminal and wait until plugin processed
        # the output to see if a different thing has to be shown
        self.myemit('block_in', (buf,)) # signal to show it on screen
        self.myemit('processOutput', (buf,)) # signal to pass it to plugins

    def donePty(self):
        """qt slot"""
##         if HAVE_UTEMPTER and self.addutmp:
##             utmp = UtmpProcess(self.master_fd, '-d',
##                                os.ttyname(self.slave_fd))
##             utmp.start(RUN_BLOCK)
        # this is called when the shell process exits
        self.myemit('done', (self.exitStatus(),))

    def detach(self):
        """Detaches Process from child process. All communication is closed.

        No exit notification is emitted any more for the child process.
        Deleting the Process will no longer kill the child process.
        Note that the current process remains the parent process of the child
        process.
        """
        procctrl.theProcessController.removeProcess(self)
        self.running = False
        self.pid = 0
        # clean up open fd's and socket notifiers.
        self.closeStdout()

    def closeStdout(self):
        """This causes the stdout file descriptor of the child process to be
        closed.

        return False if no communication to the process's stdout
        had been specified in the call to start().
        """
        self.suspend(delete=True)
        self._outnot = None
        os.close(self.out[0])

    def normalExit(self):
        """return True if the process has already finished and has exited
        "voluntarily", ie: it has not been killed by a signal.

        Note that you should check exitStatus() to determine
        whether the process completed its task successful or not.
        """
        return self.pid and not self.running and os.WIFEXITED(self.status)

    def exitStatus(self):
        """Returns the exit status of the process.

        Please use normalExit() to check whether the process has
        exited cleanly (i.e., normalExit() returns True)
        before calling this function because if the process did not exit
        normally, it does not have a valid exit status.
        """
        return os.WEXITSTATUS(self.status)

    def processHasExited(self, state):
        """Immediately called after a process has exited. This function normally
        calls commClose to close all open communication channels to this
        process and emits the "processExited" signal.
        """
        if self.running:
            self.running = False
            self.status = state
        self.commClose()
        # also emit a signal if the process was run Blocking
        self.myemit('processExited')

    def childOutput(self, fdno):
        """Called by "slotChildOutput" this function copies data arriving from
        the child process's stdout to the respective buffer and emits the
        signal "receivedStdout".
        """
        len_ = -1
        # NB <alf>:the slot is supposed to change the value of
        # len_ at least, dataReceived does it in the c++
        # version. I emulate this by passing a list
        lenlist = [len_]
        self.myemit("receivedStdout", (fdno, lenlist))
        len_ = lenlist[0]
        return len_

    def _parentSetupCommunication(self):
        """Called right after a (successful) fork on the parent side. This
        function will do some communications cleanup, like closing
        the reading end of the "stdin" communication channel.

        Furthermore, it must also create the "outnot" QSocketNotifiers
        and connect its Qt slots to the respective member functions.
        """
        os.close(self.out[1])
        # fcntl(out[0], F_SETFL, O_NONBLOCK))
        self._outnot = qt.QSocketNotifier(self.out[0],
                                          qt.QSocketNotifier.Read, self)
        self.connect(self._outnot, qt.SIGNAL('activated(int)'),
                     self.slotChildOutput)
        self.suspend()

    def commClose(self):
        """Should clean up the communication links to the child after it has
        exited. Should be called from "processHasExited".
        """
        # If both channels are being read we need to make sure that one socket
        # buffer doesn't fill up whilst we are waiting for data on the other
        # (causing a deadlock). Hence we need to use select.
        # Once one or other of the channels has reached EOF (or given an error)
        # go back to the usual mechanism.
        fcntl(self.out[0], F_SETFL, os.O_NONBLOCK)
        self.suspend(delete=True)
        self._outnot = None
        while True:
            # * If the process is still running we block until we
            # receive data. (p_timeout = 0, no timeout)
            # * If the process has already exited, we only check
            # the available data, we don't wait for more.
            # (p_timeout = &timeout, timeout immediately)
            if self.running:
                timeout = None
            else:
                timeout = 0
            rfds = [self.out[0]]
            rlist = select.select(rfds, [], [], timeout)[0]
            if not rlist:
                break
            ret = 1
            while ret > 0:
                ret = self.childOutput(self.out[0])
            if ret == 0:
                break
        os.close(self.out[0])

    def start(self, arguments):
        """Starts the process.

        For a detailed description of the various run modes and communication
        semantics, have a look at the general description of the Process class.

        The following problems could cause this function to raise an exception:

        * The process is already running.
        * The command line argument list is empty.
        * The starting of the process failed (could not fork).
        * The executable was not found.

        param comm  Specifies which communication links should be
        established to the child process (stdin/stdout/stderr). By default,
        no communication takes place and the respective communication
        signals will never get emitted.

        return True on success, False on error
        (see above for error conditions)
        """
        uid, gid = self._startInit(arguments)
        fd = os.pipe()
        # note that we use fork() and not vfork() because vfork() has unclear
        # semantics and is not standardized.
        self.pid = os.fork()
        #print 'pid', self.pid
        if 0 == self.pid:
            self._childStart(uid, gid, fd, arguments)
        else:
            self._parentStart(fd)

    def _startInit(self, arguments):
        """initialisation part of the start method"""
        if self.running:
            raise Exception('cannot start a process that is already running')
        if not arguments:
            raise Exception('no executable has been assigned')
        self.status = 0
        self.setupCommunication()
        # We do this in the parent because if we do it in the child process
        # gdb gets confused when the application runs from gdb.
        uid = os.getuid()
        gid = os.getgid()
        self.running = True
        return uid, gid

    def _childStart(self, uid, gid, fd, arguments):
        """parent process part of the start method"""
        if fd[0]:
            os.close(fd[0])
        # drop privileges
        os.setgid(gid)
        os.setuid(uid)
        tt = self.slave_fd
        # reset signal handlers for child process
        for i in range(1, signal.NSIG):
            try:
                signal.signal(i, signal.SIG_DFL)
            except RuntimeError, ex:
                #print 'error resetting signal handler for sig %d: %s' % (i, ex)
                continue
        # Don't know why, but his is vital for SIGHUP to find the child.
        # Could be, we get rid of the controling terminal by this.
        soft = getrlimit(RLIMIT_NOFILE)[0]
        # We need to close all remaining fd's.
        # Especially the one used by Process.start to see if we are running ok.
        for i in range(soft):
            # FIXME: (result of merge) Check if (not) closing fd is OK)
            if i != tt:# and i != self.master_fd):
                try:
                    os.close(i)
                except OSError:
                    continue
        os.dup2(tt, sys.stdin.fileno())
        os.dup2(tt, sys.stdout.fileno())
        os.dup2(tt, sys.stderr.fileno())
        if tt > 2:
            os.close(tt)
        # Setup job control
        # This is pretty obscure stuff which makes the session
        # to be the controlling terminal of a process group.
        os.setsid()
        ioctl(0, TIOCSCTTY, '')
        # This sequence is necessary for event propagation. Omitting this
        # is not noticeable with all clients (bash,vi). Because bash
        # heals this, use '-e' to test it.
        pgrp = os.getpid()
        ioctl(0, TIOCSPGRP, pack('i', pgrp))

        # XXX FIXME: the following crashes
#        os.setpgid(0, 0)
#        os.close(os.open(os.ttyname(tt), os.O_WRONLY))
#        os.setpgid(0, 0)

        tty_attrs = tcgetattr(0)
        tty_attrs[-1][VINTR] = CTRL('C')
        tty_attrs[-1][VQUIT] = CTRL('\\')
        tty_attrs[-1][VERASE] = 0177
        tcsetattr(0, TCSANOW, tty_attrs);

        #os.close(self.master_fd)
        # propagate emulation
        if self.term:
            os.environ['TERM'] = self.term
        ioctl(0, TIOCSWINSZ, pack('4H', self.wsize[0], self.wsize[1], 0, 0))
        # finally, pass to the new program
        os.execvp(arguments[0], arguments)
        sys.exit(1) # control should never come here.

    def _parentStart(self, fd):
        """parent process part of the start method"""
        if fd[1]:
            os.close(fd[1])
        # Check whether client could be started.
        if fd[0]:
            while True:
                bytes = os.read(fd[0], 1)
                if not bytes:
                    break # success
                if ord(bytes) == 1:
                    # Error
                    self.running = False
                    os.close(fd[0])
                    self.pid = 0
                    return False
                break # success
        if fd[0]:
            os.close(fd[0])
        self._parentSetupCommunication()

    def kill(self, signo):
        """Stop the process (by sending it a signal).

        param signo	The signal to send. The default is SIGTERM.
        return True if the signal was delivered successfully.
        """
        os.kill(self.pid, signo)

    def suspend(self, delete=False):
        """Suspend processing of data from stdout of the child process.
        """
        if self._outnot:
            self._outnot.setEnabled(False)
            if delete:
                self._outnot.deleteLater()

    def resume(self):
        """Resume processing of data from stdout of the child process.
        """
        if self._outnot:
            self._outnot.setEnabled(True)

    def slotChildOutput(self, fdno):
        """This slot gets activated when data from the child's stdout arrives.
        It usually calls "childOutput"
        """
        if not self.childOutput(fdno):
            self.closeStdout()

########NEW FILE########
__FILENAME__ = screen
# Copyright (c) 2005-2006 LOGILAB S.A. (Paris, FRANCE).
# Copyright (c) 2005-2006 CEA Grenoble
# http://www.logilab.fr/ -- mailto:contact@logilab.fr
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the CECILL license, available at
# http://www.inria.fr/valorisation/logiciels/Licence.CeCILL-V2.pdf
#
""" Provide the Screen class.

The image manipulated by the emulation.

    This class implements the operations of the terminal emulation framework.
    It is a complete passive device, driven by the emulation decoder
    (EmuVT102). By this it forms in fact an ADT, that defines operations
    on a rectangular image.

    It does neither know how to display its image nor about escape sequences.
    It is further independent of the underlying toolkit. By this, one can even
    use this module for an ordinary text surface.

    Since the operations are called by a specific emulation decoder, one may
    collect their different operations here.

    The state manipulated by the operations is mainly kept in `image', though
    it is a little more complex beyond this..

Based on the konsole code from Lars Doelle.

@author: Lars Doelle
@author: Benjamin Longuet
@author: Frederic Mantegazza
@author: Cyrille Boullier
@author: Sylvain Thenault
@copyright: 2003, 2005-2006
@organization: CEA-Grenoble
@organization: Logilab
@license: CECILL
"""

__revision__ = "$Id: screen.py,v 1.32 2006-02-15 10:24:01 alf Exp $"

from ca import *
from helpers import wcWidth
from history import HistoryScrollBuffer

MODE_Origin  = 0
MODE_Wrap    = 1
MODE_Insert  = 2
MODE_Screen  = 3
MODE_Cursor  = 4
MODE_NewLine = 5
MODES_SCREEN = 6

BS_CLEARS = False

#REVERSE_WRAPPED_LINES = True # For debug wrapped lines


class Screen(object):
    """
    the screen is a list of lists (columns * lines), i.e. get column 4
    of line 2 with _image[3][1] (index start at 0...)

    coordonate are stored as 2d point (y, x)
    """

    def __init__(self, l=1, c=1):
        # Screen image
        self.lines = l
        self.columns = c
        self._image = [[DCA for _ in xrange(c)] for _ in xrange(l+1)]
        self._line_wrapped = [False for _ in xrange(l+1)]
        # History buffer
        self.hist_cursor = 0
        self._hist = HistoryScrollBuffer(1000)
        # Cursor location
        self._cu_x = 0
        self._cu_y = 0
        # Cursor color and rendition info
        self._cu_fg = 0
        self._cu_bg = 0
        self._cu_re = 0
        # Margins top / bottom
        self._margin_t = 0
        self._margin_b = 0
        # States
        self._curr_mode = [None, None, None, None, None, None]
        self._save_mode = [None, None, None, None, None, None]
        self.__tabStops = None
        # Effective color and rendition
        self._eff_fg = 0
        self._eff_bg = 0
        self._eff_re = 0
        # Save cursor location
        self.__saCuX = 0
        self.__saCuY = 0
        # save cursor color and rendition info
        self.__saCuFg = 0
        self.__saCuBg = 0
        self.__saCuRe = 0
        # Selection
        self.busy_selecting = False # Busy making a selection
        self.clearSelection()
        #
        self.__initTabStops()
        self.reset()

    # Screen operations

    # The `cursor' is a location within the screen that is implicitely used in
    # many operations. The operations within this section allow to manipulate
    # the cursor explicitly and to obtain it's value.

    # The position of the cursor is guarantied to be between (including) 0 and
    # `columns-1' and `lines-1'.

    # Cursor movement

    def cursorUp(self, n):
        """CUU"""
        if not n:
            n = 1
        if self._cu_y < self._margin_t:
            stop = 0
        else:
            stop = self._margin_t
        self._cu_x = min(self.columns-1, self._cu_x)
        self._cu_y = max(stop, self._cu_y-n)

    def cursorDown(self, n):
        """CUD"""
        if not n:
            n = 1
        if self._cu_y > self._margin_t:
            stop = self.lines-1
        else:
            stop = self._margin_b
        self._cu_x = min(self.columns-1, self._cu_x)
        self._cu_y = max(stop, self._cu_y+n)

    def cursorLeft(self, n):
        """CUB"""
        if not n:
            n = 1
        self._cu_x = min(self.columns-1, self._cu_x)
        self._cu_x = max(0, self._cu_x-n)

    def cursorRight(self, n):
        """CUF"""
        if not n:
            n = 1
        self._cu_x = min(self.columns-1, self._cu_x+n)

    def setCursorX(self, x):
        if not x:
            x = 1
        x -= 1
        self._cu_x = max(0, min(self.columns-1, x))

    def setCursorY(self, y):
        if not y:
            y = 1
        y -= 1
        if self.getMode(MODE_Origin):
            dy = self._margin_t
        else:
            dy = 0
        self._cu_y = max(0, min(self.lines-1, y+dy))

    def setCursorYX(self, y, x):
        self.setCursorX(x)
        self.setCursorY(y)

    def setMargins(self, top, bot):
        """Set top and bottom margin"""
        if top == 0:
            top = 1
        if bot == 0:
            bot = self.lines
        top -= 1
        bot -= 1
        if not (0 <= top and top < bot and bot < self.lines):
            api.devlog("setMargins(%d, %d) : bad range" % (top, bot))
            return
        self._margin_t = top
        self._margin_b = bot
        self._cu_x = 0
        if self.getMode(MODE_Origin):
            self._cu_y = top
        else:
            self._cu_y = 0

    # Cursor movement with scrolling
    def newLine(self):
        """
        This behaves either as index() or as nextLine()
        depending on the NewLine Mode (LNM). This mode also
        affects the key sequence returned for newline ([CR]LF).
        """
        if self.getMode(MODE_NewLine):
            self.return_()
        self.index()

    def nextLine(self):
        self.return_()
        self.index()

    def index(self):
        """Move the cursor down one line.

        If cursor is on bottom margin, the region between the
        actual top and bottom margin is scrolled up instead.
        """
        if self._cu_y == self._margin_b:
            if self._margin_t == 0 and self._margin_b == self.lines-1:
                self._addHistoryLine()
            self._scrollUp(self._margin_t, 1)
        elif self._cu_y < self.lines:
            self._cu_y += 1

    def reverseIndex(self):
        """Move the cursor up one line.

        If cursor is on the top margin, the region between the
        actual top and bottom margin is scrolled down instead.
        """
        if self._cu_y == self._margin_t:
            self._scrollDown(self._margin_t, 1)
        elif self._cu_y > 0:
            self._cu_y -= 1

    def return_(self):
        self._cu_x = 0

    def tabulate(self):
        self.cursorRight(1)
        while self._cu_x < self.columns-1 and not self.__tabStops[self._cu_x]:
            self.cursorRight(1)

    def backSpace(self):
        """Move the cursor to left one column"""
        self._cu_x = max(0, self._cu_x-1)
        if (BS_CLEARS):
            oldca = self._image[self._cu_y][self._cu_x]
            self._image[self._cu_y][self._cu_x] = Ca(u' ', oldca.f, oldca.b, oldca.r)

    def clear(self):
        """Clear the entire screen and home the cursor"""
        self.clearEntireScreen()
        self.home()

    def home(self):
        """home the cursor"""
        self._cu_x = self._cu_y = 0

    def reset(self):
        self.setMode(MODE_Wrap)      # Wrap at end of margin
        self.saveMode(MODE_Wrap)
        self.resetMode(MODE_Origin)  # Position refere to [1,1]
        self.saveMode(MODE_Origin)
        self.resetMode(MODE_Insert)  # Overstroke
        self.saveMode(MODE_Insert)
        self.setMode(MODE_Cursor)    # Cursor visible
        self.resetMode(MODE_Screen)  # Screen not inversed
        self.resetMode(MODE_NewLine)
        self._margin_t = 0
        self._margin_b = self.lines-1
        self.setDefaultRendition()
        self.saveCursor()
        self.clear()

    def eraseChars(self, n):
        if n == 0:
            n = 1
        p = max(0, min(self._cu_x+n-1, self.columns-1))
        self._clearImage([self._cu_y, self._cu_x], [self._cu_y, p], u' ')

    def deleteChars(self, n):
        if n == 0:
            n = 1
        p = max(0, min(self._cu_x+n, self.columns-1))
        self._moveImage([self._cu_y, self._cu_x], [self._cu_y, p], [self._cu_y, self.columns-1])
        self._clearImage([self._cu_y, self.columns-n], [self._cu_y, self.columns-1], u' ')

    def insertChars(self, n):
        if n == 0:
            n = 1
        p = max(0, min(self.columns-1-n, self.columns-1))
        q = max(0, min(self._cu_x+n, self.columns-1))
        self._moveImage([self._cu_y, q], [self._cu_y, self._cu_x], [self._cu_y, p])
        self._clearImage([self._cu_y, self._cu_x], [self._cu_y, q-1], u' ')

    def deleteLines(self, n):
        if n == 0:
            n = 1
        self._scrollUp(self._cu_y, n)

    def insertLines(self, n):
        if n == 0:
            n = 1
        self._scrollDown(self._cu_y, n)

    def clearTabStops(self):
        for i in xrange(self.columns):
            self.__tabStops[i-1] = False

    def changeTabStop(self, set):
        if self._cu_x >= self.columns:
            return
        self.__tabStops[self._cu_x] = set

    def setMode(self, m):
        self._curr_mode[m] = True
        if m == MODE_Origin:
            self._cu_x = 0
            self._cu_y = self._margin_t

    def resetMode(self, m):
        self._curr_mode[m] = False
        if m == MODE_Origin:
            self._cu_x = self._cu_y = 0

    def saveMode(self, m):
        self._save_mode[m] = self._curr_mode[m]

    def restoreMode(self, m):
        self._curr_mode[m] = self._save_mode[m]

    def saveCursor(self):
        self.__saCuX = self._cu_x
        self.__saCuY = self._cu_y
        self.__saCuRe = self._cu_re
        self.__saCuFg = self._cu_fg
        self.__saCuBg = self._cu_bg

    def restoreCursor(self):
        self._cu_x = min(self.__saCuX, self.columns-1)
        self._cu_y = min(self.__saCuY, self.lines-1)
        self._cu_re = self.__saCuRe
        self._cu_fg = self.__saCuFg
        self._cu_bg = self.__saCuBg
        self._effectiveRendition()

    def clearEntireScreen(self):
        self._clearImage([0, 0], [self.lines-1, self.columns-1], u' ')

    def clearToEndOfScreen(self):
        self._clearImage([self._cu_y, self._cu_x],
                         [self.lines-1, self.columns-1], u' ')

    def clearToBeginOfScreen(self):
        self._clearImage([0, 0], [self._cu_y, self._cu_x], u' ')

    def clearEntireLine(self):
        self._clearImage([self._cu_y, 0], [self._cu_y, self.columns-1], u' ')

    def clearToEndOfLine(self):
        self._clearImage([self._cu_y, self._cu_x],
                         [self._cu_y, self.columns-1], u' ')

    def clearToBeginOfLine(self):
        self._clearImage([self._cu_y, 0], [self._cu_y, self._cu_x], u' ')

    def helpAlign(self):
        self._clearImage([0, 0], [self.lines-1, self.columns-1], u'E')

    def setRendition(self, re):
        self._cu_re = self._cu_re | re
        self._effectiveRendition()

    def resetRendition(self, re):
        self._cu_re = self._cu_re & ~re
        self._effectiveRendition()

    def setForeColor(self, fgcolor):
        if fgcolor & 8:
            self._cu_fg = (fgcolor & 7) + 4+8
        else:
            self._cu_fg = (fgcolor & 7) + 2
        self._effectiveRendition()

    def setBackColor(self, bgcolor):
        if bgcolor & 8:
            self._cu_bg = (bgcolor & 7) + 4+8
        else:
            self._cu_bg = (bgcolor & 7) + 2
        self._effectiveRendition()

    def setDefaultRendition(self):
        self.setForeColorToDefault()
        self.setBackColorToDefault()
        self._cu_re = DEFAULT_RENDITION
        self._effectiveRendition()

    def setForeColorToDefault(self):
        self._cu_fg = DEFAULT_FORE_COLOR
        self._effectiveRendition()

    def setBackColorToDefault(self):
        self._cu_bg = DEFAULT_BACK_COLOR
        self._effectiveRendition()

    def getMode(self, n):
        return self._curr_mode[n]

    def getCursorX(self):
        return self._cu_x

    def getCursorY(self):
        return self._cu_y

    def showCharacter(self, c):
        #print 'screen.showcharacter', chr(c)
        w = wcWidth(c)
        if w <= 0:
            return
        if self._cu_x+w > self.columns:
            if self.getMode(MODE_Wrap):
                self._line_wrapped[self._cu_y] = True
                self.nextLine()
            else:
                self._cu_x = self.columns-w
        if self.getMode(MODE_Insert):
            self.insertChars(w)
        cpt = [self._cu_y, self._cu_x]
        self.checkSelection(cpt, cpt)
        line = self._image[self._cu_y]
        line[self._cu_x] = Ca(unichr(c), self._eff_fg, self._eff_bg,
                              self._eff_re)
        self._cu_x += w
        for i in xrange(1, w):
            line[self._cu_x + i] = Ca(None, self._eff_fg, self._eff_bg,
                                      self._eff_re)

    def resizeImage(self, lines, columns):
        if lines == self.lines and columns == self.columns:
            return
        if self._cu_y > lines+1:
            self._margin_b = self.lines-1
            for i in xrange(self._cu_y - (lines-1)):
                self._addHistoryLine()
                self._scrollUp(self._margin_t, 1)
        # Make new image
        newimg = [[DCA for x in xrange(columns)] for y in xrange(lines+1)]
        newwrapped = [False for y in xrange(lines+1)]
        # Copy to new image
        for y in xrange(min(lines, self.lines)):
            for x in xrange(min(columns, self.columns)):
                newimg[y][x] = self._image[y][x]
            newwrapped[y] = self._line_wrapped[y]
        self._image = newimg
        self._line_wrapped = newwrapped
        self.lines = lines
        self.columns = columns
        self._cu_x = min(self._cu_x, self.columns-1)
        self._cu_y = min(self._cu_y, lines-1)
        self._margin_t = 0
        self._margin_b = self.lines - 1
        self.__initTabStops()
        self.clearSelection()

    def getCookedImage(self):
        image = [[DCA for x in xrange(self.columns)] for y in xrange(self.lines)]
        wrapped = [False for i in xrange(self.lines)]
        hist = self._hist
        actual_y = hist.lines - self.hist_cursor
        # get lines from history
        for y in xrange(min(self.lines, actual_y)):
            yq = y + self.hist_cursor
            len_ = min(self.columns, hist.getLineLen(yq))
            image[y][:len_] = hist.getCells(yq, 0, len_)
            for x in xrange(self.columns):
                q = [yq, x]
                if q >= self._sel_topleft and q <= self._sel_bottomright:
                    self._reverseRendition(image, x, y)
            wrapped[y] = self._hist.isWrappedLine(y+self.hist_cursor)
        # get lines from the actual screen
        for y in xrange(actual_y, self.lines):
            yq = y + self.hist_cursor
            yr = y - actual_y
            for x in xrange(self.columns):
                q = [yq, x]
                image[y][x] = self._image[yr][x]
                if q >= self._sel_topleft and q <= self._sel_bottomright:
                    self._reverseRendition(image, x, y)

            wrapped[y] = self._line_wrapped[y-actual_y]
        # reverse rendition on screen mode
        if self.getMode(MODE_Screen):
            for y in xrange(self.lines):
                for x in xrange(self.columns):
                    self._reverseRendition(image, x, y)
        # update cursor
        cuy = self._cu_y + actual_y
        if self.getMode(MODE_Cursor) and \
               cuy < self.lines and self._cu_x < self.columns:
            ca = image[cuy][self._cu_x]
            image[cuy][self._cu_x] = Ca(ca.c, ca.f, ca.b, ca.r | RE_CURSOR)
        return image, wrapped

    def getHistLines(self):
        return self._hist.lines

    def setScroll(self, scroll_type):
        self.clearSelection()
        self._hist = scroll_type.getScroll(self._hist)
        self.hist_cursor = self._hist.lines

    def getScroll(self):
        return self._hist.getType()

    def hasScroll(self):
        return self._hist.hasScroll()

    def _clearImage(self, loca, loce, c):
        # Clear entire selection if overlaps region to be moved
        if self._overlapSelection(loca, loce):
            self.clearSelection()
        ca = Ca(c, self._eff_fg, self._eff_bg, DEFAULT_RENDITION)
        for y in xrange(loca[0], loce[0]+1):
            for x in xrange(loca[1], loce[1]+1):
                self._image[y][x] = ca
            self._line_wrapped[y] = False

    def _moveImage(self, dest, loca, loce):
        #print 'move image', dest, loca, loce
        assert loce >= loca
        # XXX x coordonates are not always considered. Is it enough actually ?
        ys = loca[0]
        if dest[0] != ys:
            dy = loce[0] - ys + 1
            self._image[dest[0]:dest[0]+dy] = [lines[:] for lines in self._image[ys:ys+dy]]
            for i in xrange(dy):
                self._line_wrapped[dest[0]+i] = self._line_wrapped[ys+i]
        else:
            xs = loca[1]
            dx = loce[1] - xs + 1
            self._image[ys][dest[1]:dest[1]+dx] = self._image[ys][xs:xs+dx]
        # Adjust selection to follow scroll
        if self._sel_begin != [-1, -1]:
            beginIsSTL = (self._sel_begin == self._sel_topleft)
            diff = self._subPoints(dest, loca) # Scroll by this amount
            scr_topleft = [self._hist.lines, 0]
            srca = self._addPoints(loca, scr_topleft) # Translate index from screen to global
            srce = self._addPoints(loce, scr_topleft)
            desta = self._addPoints(srca, diff)
            deste = self._addPoints(srce, diff)
            if self._sel_topleft >= srca and self._sel_topleft <= srce:
                self._sel_topleft = self._addPoints(self._sel_topleft, diff)
            elif self._sel_topleft >= desta and self._sel_topleft <= deste:
                self._sel_bottomright = [-1, -1] # Clear selection (see below)
            if self._sel_bottomright >= srca and self._sel_bottomright <= srce:
                self._sel_bottomright = self._addPoints(self._sel_bottomright, diff)
            elif self._sel_bottomright >= desta and self._sel_bottomright <= deste:
                self._sel_bottomright = [-1, -1] # Clear selection (see below)
            if self._sel_bottomright < [0, 0]:
                self.clearSelection()
            elif self._sel_topleft < [0, 0]:
                self._sel_topleft = [0, 0]
            if beginIsSTL:
                self._sel_begin = self._sel_topleft
            else:
                self._sel_begin = self._sel_bottomright

    def _scrollUp(self, from_, n):
        if n <= 0 or from_+n > self._margin_b:
            return
        ecoord = [self._margin_b, self.columns-1]
        self._moveImage([from_, 0], [from_+n, 0], ecoord)
        self._clearImage([self._margin_b-n+1, 0], ecoord, u' ')

    def _scrollDown(self, from_, n):
        if n <= 0 or from_ > self._margin_b:
            return
        if from_+n > self._margin_b:
            n = self._margin_b-from_
        self._moveImage([from_+n, 0], [from_, 0],
                        [self._margin_b-n, self.columns-1])
        self._clearImage([from_, 0], [from_+n-1, self.columns-1], u' ')

    def _addHistoryLine(self):
        """Add the first image's line to history buffer
        Take care about scrolling too...
        """
        assert self.hasScroll() or self.hist_cursor == 0
        if not self.hasScroll():
            return
        end = self.columns - 1
        while end >= 0 and (self._image[0][end] is DCA or
                            self._image[0][end] == DCA) and not self._line_wrapped[0]:
            end -= 1
        oldHistLines = self._hist.lines
        self._hist.addCells(self._image[0][:end+1], self._line_wrapped[0])
        newHistLines = self._hist.lines
        # Adjust history cursor
        beginIsTL = (self._sel_begin == self._sel_topleft)
        if newHistLines > oldHistLines:
            self.hist_cursor += 1
            # Adjust selection for the new point of reference
            if self._sel_begin != [-1, -1]:
                self._sel_topleft[0] += 1
                self._sel_bottomright[0] += 1
        # Scroll up if user is looking at the history and we can scroll up
        if self.hist_cursor > 0 and (self.hist_cursor != newHistLines
                                     or self.busy_selecting):
            self.hist_cursor -= 1
        # Scroll selection in history up
        if self._sel_begin != [-1, -1]:
            topBR = [1+newHistLines, 0]
            if self._sel_topleft < topBR:
                self._sel_topleft[0] -= 1
            if self._sel_bottomright < topBR:
                self._sel_bottomright[0] -= 1
            if self._sel_bottomright < [0, 0]:
                self.clearSelection()
            elif self._sel_topleft < [0, 0]:
                self._sel_topleft = [0, 0]
            if beginIsTL:
                self._sel_begin = self._sel_topleft
            else:
                self._sel_begin = self._sel_bottomright

    def __initTabStops(self):
        self.__tabStops = self.columns*[False]
        for i in xrange(self.columns):
            self.__tabStops[i] = ((i % 8 == 0) and i != 0)

    def _effectiveRendition(self):
        self._eff_re = self._cu_re & (RE_UNDERLINE | RE_BLINK)
        if self._cu_re & RE_REVERSE:
            self._eff_fg = self._cu_bg
            self._eff_bg = self._cu_fg
        else:
            self._eff_fg = self._cu_fg
            self._eff_bg = self._cu_bg
        if self._cu_re & RE_BOLD:
            if self._eff_fg < BASE_COLORS:
                self._eff_fg += BASE_COLORS
            else:
                self._eff_fg -= BASE_COLORS

    def _reverseRendition(self, image, x, y):
#        image[coord] = p = image[coord].dump()
        p = image[y][x]
        image[y][x] = Ca(p.c, p.b, p.f, p.r)

    # selection handling ######################################################

    def setSelBeginXY(self, x, y):
        self._sel_begin = [y+self.hist_cursor, x]
        if x == self.columns:
            self._incPoint(self._sel_begin, -1)
        self._sel_bottomright = self._sel_begin
        self._sel_topleft = self._sel_begin

    def setSelExtendXY(self, x, y):
        if self._sel_begin == [-1, -1]:
            return
        l = [y+self.hist_cursor, x]
        if l < self._sel_begin:
            self._sel_topleft = l
            self._sel_bottomright = self._sel_begin
        else:
            if x == self.columns:
                self._incPoint(l, -1)
            self._sel_topleft = self._sel_begin
            self._sel_bottomright = l

    def testIsSelected(self, x, y):
        pos = [y+self.hist_cursor, x]
        return pos >= self._sel_topleft and pos <= self._sel_bottomright

    def clearSelection(self):
        self._sel_begin = [-1, -1]      # First location selected
        self._sel_topleft = [-1, -1]    # Top-left location
        self._sel_bottomright = [-1, -1]# Bottom-right location

    def getSelText(self, preserve_line_break):
        if self._sel_begin == [-1, -1]:
            return
        histBR = [self._hist.lines, 0]
        hY = self._sel_topleft[0]
        hX = self._sel_topleft[1]
        m = []

        s = self._sel_topleft[:]

        if preserve_line_break:
            eol_char = '\n'
        else:
            eol_char = ' '

        #s es el begin!
        while s <= self._sel_bottomright:
            # XXX in the first if branch, eol is scalar while in the else branch, it's a point !
            if s < histBR:
                eol = self._hist.getLineLen(hY)
                if hY == self._sel_bottomright[0] and eol > self._sel_bottomright[1]:
                    eol = self._sel_bottomright[1] + 1
                while hX < eol:
                    c = self._hist.getCells(hY, hX, 1)[0].c
                    if c is not None:
                        m.append(c)
                    self._incPoint(s)
                    hX += 1
                if s <= self._sel_bottomright:
                    if eol % self.columns == 0:
                        if eol == 0:
                            m.append(eol_char)
                        elif not self._hist.isWrappedLine(hY):
                            m.append(eol_char)
                    elif (eol + 1) % self.columns == 0:
                        if not self._hist.isWrappedLine(hY):
                            m.append(eol_char)
                    else:
                        m.append(eol_char)
                hY += 1
                hX = 0
                s = [hY, 0]
            else:
                eol = [s[0]+1, 0]
                self._incPoint(eol, -1)
                addNewLine = False
                if eol < self._sel_bottomright:
                    while eol > s:
                        pt = self._subPoints(eol, histBR)
                        ca = self._image[pt[0]][pt[1]]

                        if (not ca.c or ca.isSpace()):
                            if not self._line_wrapped[pt[0]]:
                                break
                        else:
                            # found a valid char!
                            break
                        self._incPoint(eol, -1)
                elif eol == self._sel_bottomright:
                    pt = self._subPoints(eol, histBR)
                    if not self._line_wrapped[pt[0]]:
                        addNewLine = True
                else:
                    eol = self._sel_bottomright
                while s <= eol:
                    pt = self._subPoints(s, histBR)
                    c = self._image[pt[0]][pt[1]].c
                    if c is not None:
                        m.append(c)
                    self._incPoint(s)
                if eol < self._sel_bottomright:
                    if eol[1] +1 == self.columns: #(eol + 1) % self.columns == 0:
                        if (not self._hist.isWrappedLine(eol[0]-histBR[0]) and
                            not self._line_wrapped[eol[0]-histBR[0]]):
                            m.append(eol_char)
                    else:
                        m.append(eol_char)
                elif addNewLine and preserve_line_break:
                    m.append('\n')
                s = [eol[0]+1, 0]
        # skip trailing spaces
        m = [line.rstrip() for line in ''.join(m).splitlines()]
        return '\n'.join(m)

    def setBackgroundColor(self, from_xy, to_xy, color):
        #self.setSelBeginXY(from_xy[0], from_xy[1])
        #self.setSelExtendXY(to_xy[0], to_xy[1])
        #self.getSelText(False)

        from_x = from_xy[0]
        from_y = from_xy[1]

        to_x   = to_xy[0]
        to_y   = to_xy[1]

        begin = [from_y+self.hist_cursor, from_x]
        end = [to_y+self.hist_cursor, to_x]

        if from_x == self.columns:
            self._incPoint(begin, -1)

        if end < begin:
            start_highl = end
            end_highl = begin
        else:
            if to_x == self.columns:
                self._incPoint(end, -1)
            start_highl = begin
            end_highl = end

        ##################################
        #self._sel_begin = begin
        #self._sel_topleft = self._sel_begin
        #self._sel_bottomright = end
        #self.getSelText(False)
        
        self._paintBackground(start_highl, end_highl, color)
        
    def _paintBackground(self, start_xy, end_xy, color):

        if start_xy == [-1, -1]:
            return

        histBR = [self._hist.lines, 0]
        hY = start_xy[0]
        hX = start_xy[1]
        m = []

        s = start_xy[:]
        eol_char = ' '

        #s es el begin!
        while s <= end_xy:
            # XXX in the first if branch, eol is scalar while in the else branch, it's a point !
            if s < histBR:
                eol = self._hist.getLineLen(hY)
                if hY == end_xy[0] and eol > end_xy[1]:
                    eol = end_xy[1] + 1
                while hX < eol:
                    ca = self._hist.getCells(hY, hX, 1)[0].b = color
                    self._incPoint(s)
                    hX += 1
                hY += 1
                hX = 0
                s = [hY, 0]
            else:
                eol = [s[0]+1, 0]
                self._incPoint(eol, -1)

                if eol < end_xy:
                    while eol > s:
                        pt = self._subPoints(eol, histBR)
                        ca = self._image[pt[0]][pt[1]]                        
                        self._image[pt[0]][pt[1]] = Ca(ca.c, ca.f, color, ca.r)

                        self._incPoint(eol, -1)
                elif eol == end_xy:
                    pt = self._subPoints(eol, histBR)
                else:
                    eol = end_xy

                while s <= eol:
                    pt = self._subPoints(s, histBR)
                    ca = self._image[pt[0]][pt[1]]

                    self._image[pt[0]][pt[1]] = Ca(ca.c, ca.f, color, ca.r)
                    self._incPoint(s)


                s = [eol[0]+1, 0]

    def checkSelection(self, from_, to):
        if self._sel_begin == [-1, -1]:
            return
        # Clear entire selection if overlaps region to be moved
        if self._overlapSelection(from_, to):
            self.clearSelection()

    def _overlapSelection(self, from_, to):
        assert isinstance(from_, list), from_
        assert isinstance(to, list), to
        scr_topleft = [self._hist.lines, 0]
        # Clear entire selection if overlaps region [from_, to]
        if self._sel_bottomright > self._addPoints(from_, scr_topleft) and \
               self._sel_topleft < self._addPoints(to, scr_topleft):
            return True
        return False


    # point manipulation ######################################################

    def _incPoint(self, point, inc=1):
        x = point[1] + inc
        if x < 0 or x >= self.columns:
            dy, x = divmod(x, self.columns)
            point[0] += dy
        point[1] = x

    def _addPoints(self, point1, point2):
        x = point1[1] + point2[1]
        y = point1[0] + point2[0]
        if x < 0 or x >= self.columns:
            dy, x = divmod(x, self.columns)
            y += dy
        return [y, x]

    def _subPoints(self, point1, point2):
        x = point1[1] - point2[1]
        y = point1[0] - point2[0]
        if x < 0 or x >= self.columns:
            dy, x = divmod(x, self.columns)
            y += dy
        return [y, x]

########NEW FILE########
__FILENAME__ = signalable
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

                                                
                                                                               
                        
class Signalable(object):
    """a class implementing a signal API similar to the qt's one"""

    def __init__(self, *args):
        super(Signalable, self).__init__(*args)
        self.__connected = {}

    def myconnect(self, signal, callback):
        """connect the given callback to the signal"""
        self.__connected.setdefault(signal, []).append(callback)

    def mydisconnect(self, signal, callback):
        """disconnect the given callback from the signal"""
        self.__connected[signal].remove(callback)

    def myemit(self, signal, args=()):
        """emit the given signal with the given arguments if any"""
        for callback in self.__connected.get(signal, []):
            try:
                callback(*args)
            except Exception:
                import traceback
                traceback.print_exc()

########NEW FILE########
__FILENAME__ = command_history
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import unittest
import sys
import os
sys.path.append(os.path.abspath(os.getcwd()))
# from plugins import core
# from plugins import managers
import re

from model.commands_history import CommandRunInformation
from model.controller import ModelController
from plugins.core import PluginController

from model.workspace import WorkspaceOnCouch, WorkspaceOnFS, WorkspaceManager
from mockito import mock

from time import time

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

from managers.all import CommandManager, CouchdbManager, PersistenceManagerFactory

class CommandHistoryTestSuite(unittest.TestCase):

    def setUp(self):
        pass
        # self.couch_host = "http://192.168.33.101:5984"
        # CONF.setCouchUri(self.couch_host)

    def test_valid_command_creation(self):
        information = self.getDefaultCommandInfo()

        command_info = CommandRunInformation(**information)
        self.assertIsNotNone(command_info, "Command wrongly created")

        self.assertEquals(command_info.command, information['command'], \
                "Field %s not instantiated" % information['command'])

        self.assertEquals(command_info.parameters, information['parameters'], \
                "Field %s not instantiated" % information['parameters'])

        self.assertEquals(command_info.itime, information['itime'], \
                "Field %s not instantiated" % information['itime'])

        self.assertEquals(command_info.duration, information['duration'], \
                "Field %s not instantiated" % information['duration'])

        self.assertEquals(command_info.workspace, information['workspace'], \
                "Field %s not instantiated" % information['workspace'])

    def test_create_command_manager(self):
        """ Tests the command manager creation """
        cm = CommandManager()
        self.assertIsNotNone(cm, "Command Manager not instantiated")

    def test_save_command_in_couch(self):
        """ Tests if command is saved in couch """
        cm = CommandManager()

        exec_command = CommandRunInformation(**self.getDefaultCommandInfo())

        wm = WorkspaceManager(mock(ModelController), mock(PluginController))
        workspace = wm.createWorkspace(exec_command.workspace, workspaceClass=WorkspaceOnCouch)

        res = cm.saveCommand(exec_command, workspace)

        self._manager = PersistenceManagerFactory.getInstance()
        saved_doc = self._manager.getDocument(exec_command.workspace, res['id'] )

        self.assertEquals(exec_command.command, saved_doc['command'], 'Saved command diffier')
        self.assertEquals(exec_command.parameters, saved_doc['parameters'], 'Saved command diffier')
        self.assertEquals(exec_command.itime, saved_doc['itime'], 'Saved command diffier')
        self.assertEquals(exec_command.duration, saved_doc['duration'], 'Saved command diffier')

    def test_save_command_in_fs(self):
        """ Tests if command is saved in couch """
        wm = WorkspaceManager(mock(ModelController), mock(PluginController))

        command_info = self.getDefaultCommandInfo()
        command_info['workspace'] = 'new_workspace'
        exec_command = CommandRunInformation(**command_info)

        workspace = wm.createWorkspace(exec_command.workspace, workspaceClass=WorkspaceOnFS)
        wm.setActiveWorkspace(workspace)

        cm = CommandManager()

        res = cm.saveCommand(exec_command, workspace)

        self._manager = PersistenceManagerFactory.getInstance()
        # saved_doc = self._manager.getDocument(exec_command.workspace, res['id'])

        # After all
        wm.removeWorkspace(command_info['workspace'])


    def getDefaultCommandInfo(self):
        information = { 'command' : 'nmap',
                        'parameters' : '-Sv',
                        'itime' : time(),
                        'duration' : 5,
                        'workspace' : 'default'
                        }

        return information


if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = integration_cases
#!/usr/bin/python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from unittest import TestCase
import unittest
import sys
sys.path.append('.')
import model.controller as controller
import plugins.core as plcore
from mockito import mock
from model import api
from model.hosts import Host, Interface, Service
from model.workspace import WorkspaceOnCouch, WorkspaceManager, WorkspaceOnFS
import random
from persistence.orm import WorkspacePersister

def new_random_workspace_name():
    return ("aworkspace" + "".join(random.sample([chr(i) for i in range(65, 90) ], 10 ))).lower() 

def create_host(self, host_name="pepito", os="linux"):
    host = Host(host_name, os)
    self.model_controller.addHostSYNC(host)
    return host

def create_interface(self, host, iname="coqiuto", mac="00:03:00:03:04:04"):
    interface = Interface(name=iname, mac=mac)
    self.model_controller.addInterfaceSYNC(host.getName(), interface)
    return interface

def create_service(self, host, interface, service_name = "coquito"):
    service = Service(service_name)
    self.model_controller.addServiceToInterfaceSYNC(host.getID(),
                                interface.getID(), service)
    return service

class TestModelObjectCRUD(TestCase):
    """docstring for TestModelObjectCRUD"""

    @classmethod
    def setUpClass(cls):
        cls.model_controller = controller.ModelController(mock())
        api.setUpAPIs(cls.model_controller)

    def setUp(self):
        self.wm = WorkspaceManager(self.model_controller, mock(plcore.PluginController))
        self.workspace = self.wm.createWorkspace(new_random_workspace_name(), workspaceClass=WorkspaceOnCouch) 
        self.wm.setActiveWorkspace(self.workspace)
        WorkspacePersister.stopThreads()

    def tearDown(self):
        self.wm.removeWorkspace(self.workspace.name)


    def test_create_and_remove_host_from_controller(self):
        host1 = create_host(self, "coquito")
        hosts_ids = [ h.getID() for h in self.model_controller.getAllHosts() ]

        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        self.model_controller.delHostSYNC(host1.name)

        hosts_ids = [ h.getID() for h in self.model_controller.getAllHosts() ]
        self.assertNotIn(host1.getID(), hosts_ids,
                                "Host not deleted")

    def test_delete_interface(self):
        host1 = create_host(self, "coquito")
        interface1 = create_interface(self, host1, iname = "pepito")

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()] 
        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        host1 = self.model_controller.getHost(host1.getID())

        interfaces_ids = [i.getID() for i in host1.getAllInterfaces()]
        self.assertIn(interface1.getID(), interfaces_ids,
                                "Interface not in host!")

        self.model_controller.delInterfaceSYNC(host1.getID(), "pepito")

        
        interfaces_ids = [i.getID() for i in
                self.model_controller.getHost(host1.getID()).getAllInterfaces()]

        self.assertNotIn(interface1.getID(), interfaces_ids,
                                "Interface not in host!")


    def test_delete_service(self):
        host1 = create_host(self, "coquito")
        interface1 = create_interface(self, host1, iname="pepito")
        service1 = create_service(self, host1, interface1)

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()] 
        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        host1 = self.model_controller.getHost(host1.getID())
        interfaces_ids = [i.getID() for i in host1.getAllInterfaces()]
        self.assertIn(interface1.getID(), interfaces_ids,
                                "Interface not in host!")

        services_ids = [s.getID() for s in self.model_controller.getHost(host1.getID())
                        .getInterface(interface1.getID()).getAllServices() ]

        self.assertIn(service1.getID(), services_ids,
                                "Service not in Interface!")

        self.model_controller.delServiceFromInterfaceSYNC(host1.getID(),
                                    interface1.getID(), service1.getID())

        services_ids = [s.getID() for s in self.model_controller.getHost(host1.getID())
                        .getInterface(interface1.getID()).getAllServices() ]

        self.assertNotIn(service1.getID(), services_ids, \
                        "Service not deleted")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = model_object
#!/usr/bin/python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from unittest import TestCase
import unittest
import sys
sys.path.append('.')
import model.controller as controller
import plugins.core as plcore
from mockito import mock
from model import api
from model.hosts import Host, Interface, Service
from model.workspace import WorkspaceOnCouch, WorkspaceManager, WorkspaceOnFS
from model.common import ModelObjectVuln, ModelObjectVulnWeb, ModelObjectNote
from persistence.orm import WorkspacePersister
import random


from managers.all import CommandManager, CouchdbManager, PersistenceManagerFactory

def new_random_workspace_name():
    return ("aworkspace" + "".join(random.sample([chr(i) for i in range(65, 90)
                                ], 10 ))).lower()

def create_host(self, host_name="pepito", os="linux"):
    host = Host(host_name, os)
    self.model_controller.addHostSYNC(host)
    return host

def create_interface(self, host, iname="coqiuto", mac="00:03:00:03:04:04"):
    interface = Interface(name=iname, mac=mac)
    self.model_controller.addInterfaceSYNC(host.getName(), interface)
    return interface

def create_service(self, host, interface, service_name = "coquito"):
    service = Service(service_name)
    self.model_controller.addServiceToInterfaceSYNC(host.getID(),
                                interface.getID(), service)
    return service

class ModelObjectCRUD(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.model_controller = controller.ModelController(mock())
        api.setUpAPIs(cls.model_controller)

    def setUp(self):
        self.wm = WorkspaceManager(self.model_controller,
                                    mock(plcore.PluginController))
        self.temp_workspace = self.wm.createWorkspace(
                                        new_random_workspace_name(),
                                        workspaceClass=WorkspaceOnCouch)

        self.wm.setActiveWorkspace(self.temp_workspace)
        WorkspacePersister.stopThreads()

    def tearDown(self):
        self.wm.removeWorkspace(self.temp_workspace.name)

    def testAddHost(self):
        """ This test case creates a host within the Model Controller context
        then checks it's vality"""
        # When
        hostname = 'host'
        _ = create_host(self, host_name=hostname, os='windows')

        # #Then
        added_host = self.model_controller.getHost(hostname)

        self.assertEquals(added_host.getName(), hostname,
                'Saved object name is not correctly saved')


    def testAddVulnToHost(self):
        """ This test case creates a host within the Model Controller context
        then adds a VULN"""

        # When
        h = create_host(self)
        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='high')
        self.model_controller.addVulnToHostSYNC(h.getID(), vuln)

        added_host = self.model_controller.getHost(h.getName())
        vulns = added_host.getVulns()
        #Then
        self.assertIn(vuln, vulns, 'Vuln not added')



    def testAddVulnToInterface(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds a VULN"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToInterfaceSYNC(host.getID(),
                                interface.getID(), vuln)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        vulns = added_interface.getVulns()
        # Then
        self.assertIn(vuln, vulns, 'Vuln not added')

    def testAddVulnToService(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds service then a VULN"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)
        service = create_service(self, host, interface)

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                service.getID(), vuln)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        added_service = added_interface.getService(service.getID())
        vulns = added_service.getVulns()
        # Then
        self.assertIn(vuln, vulns, 'Vuln not added')


    def testAddVulnWebToHost(self):
        """ This test case creates a host within the Model Controller context
        then adds a VulnWeb"""

        # When
        h = create_host(self)
        vuln = ModelObjectVulnWeb(name='VulnTest', desc='TestDescription',
                                        severity='high')
        self.model_controller.addVulnToHostSYNC(h.getID(), vuln)

        added_host = self.model_controller.getHost(h.getName())
        vulns = added_host.getVulns()
        # Then
        self.assertIn(vuln, vulns, 'Vuln not added')


    def testAddVulnWebToInterface(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds a VulnWeb"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)

        vuln = ModelObjectVulnWeb(name='VulnTest', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToInterfaceSYNC(host.getID(),
                                interface.getID(), vuln)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        vulns = added_interface.getVulns()
        self.assertIn(vuln, vulns, 'Vuln not added')

        self.temp_workspace.load()

        # Then
        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        vulns = added_interface.getVulns()
        self.assertIn(vuln.getID(), [v.getID() for v in vulns],
                'Vuln not reloaded')


    def testAddVulnWebToService(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds service then a VulnWeb"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)
        service = create_service(self, host, interface)

        vuln = ModelObjectVulnWeb(name='VulnTest', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                service.getID(), vuln)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        added_service = added_interface.getService(service.getID())
        vulns = added_service.getVulns()
        # Then
        self.assertIn(vuln, vulns, 'Vuln not added')


    def testAddNoteToHost(self):
        """ This test case creates a host within the Model Controller context
        then adds a Note"""

        # When
        h = create_host(self)
        note = ModelObjectNote(name='NoteTest', text='TestDescription')
        self.model_controller.addNoteToHostSYNC(h.getID(), note)

        # Then
        added_host = self.model_controller.getHost(h.getName())
        notes = added_host.getNotes()
        self.assertIn(note, notes, 'Note not added')


    def testAddNoteToInterface(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds a Note"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)

        note = ModelObjectNote(name='NoteTest', text='TestDescription')

        self.model_controller.addNoteToInterfaceSYNC(host.getID(),
                                interface.getID(), note)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        notes = added_interface.getNotes()
        # Then
        self.assertIn(note, notes, 'Note not added')


    def testAddNoteToService(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds service then a Note"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)
        service = create_service(self, host, interface)

        note = ModelObjectNote(name='NoteTest', text='TestDescription')

        self.model_controller.addNoteToServiceSYNC(host.getID(),
                                service.getID(), note)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        added_service = added_interface.getService(service.getID())
        notes = added_service.getNotes()
        # Then
        self.assertIn(note, notes, 'Note not added')

    def testDeleteHost(self):
        """ Creates a Host to test it's removal from the controllers list """

        host1 = create_host(self, "coquito")
        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()]

        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        self.model_controller.delHostSYNC(host1.name)

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()]
        self.assertNotIn(host1.getID(), hosts_ids,
                                "Host not deleted")

    def testDeleteInterface(self):
        """ Creates a Host and an Interface, then deletes the interface
        to test it's removal from the controllers list """

        host1 = create_host(self, "coquito")
        interface1 = create_interface(self, host1, iname="pepito")

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()]
        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        host1 = self.model_controller.getHost(host1.getID())

        interfaces_ids = [i.getID() for i in host1.getAllInterfaces()]
        self.assertIn(interface1.getID(), interfaces_ids,
                                "Interface not in host!")

        self.model_controller.delInterfaceSYNC(host1.getID(), "pepito")

        
        interfaces_ids = [i.getID() for i in
                self.model_controller.getHost(host1.getID()).getAllInterfaces()]

        self.assertNotIn(interface1.getID(), interfaces_ids,
                                "Interface not in host!")


    def testDeleteService(self):
        """ Creates a Host an Interface and a Service, then deletes the Service
        to test it's removal from the controllers list """

        host1 = create_host(self, "coquito")
        interface1 = create_interface(self, host1, iname="pepito")
        service1 = create_service(self, host1, interface1)

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()]
        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        host1 = self.model_controller.getHost(host1.getID())
        interfaces_ids = [i.getID() for i in host1.getAllInterfaces()]
        self.assertIn(interface1.getID(), interfaces_ids,
                                "Interface not in host!")

        services_ids = [s.getID() for s in \
                            self.model_controller.getHost(host1.getID())
                            .getInterface(interface1.getID()).getAllServices()]

        self.assertIn(service1.getID(), services_ids,
                                "Service not in Interface!")

        self.model_controller.delServiceFromInterfaceSYNC(host1.getID(),
                                    interface1.getID(), service1.getID())

        services_ids = [s.getID() for s in \
                            self.model_controller.getHost(host1.getID())
                            .getInterface(interface1.getID()).getAllServices()]

        self.assertNotIn(service1.getID(), services_ids, \
                        "Service not deleted")

    def testDeleteVulnFromHost(self):
        """ Creates a Host adds a Vuln then removes """

        host1 = create_host(self, "coquito")

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToHostSYNC(host1.getID(), vuln)

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()]

        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        self.model_controller.delVulnFromHostSYNC(host1.getID(), vuln.getID())

        added_host = self.model_controller.getHost(host1.getName())

        self.assertNotIn(vuln, added_host.getVulns(), 'Vuln not removed')


    def testDelVulnFromInterface(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds a VULN"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToInterfaceSYNC(host.getID(),
                                interface.getID(), vuln)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        vulns = added_interface.getVulns()
        self.assertIn(vuln, vulns, 'Vuln not added')

        # Then
        self.model_controller.delVulnFromInterfaceSYNC(host.getID(),
                            interface.getID(), vuln.getID())

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        vulns = added_interface.getVulns()

        self.assertNotIn(vuln, vulns, 'Vuln not removed')



    def testDelVulnFromService(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds service then a Vuln, then removes the
        Vuln"""

        # When
        host = create_host(self)
        interface = create_interface(self, host)
        service = create_service(self, host, interface)

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                service.getID(), vuln)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        added_service = added_interface.getService(service.getID())
        vulns = added_service.getVulns()
        self.assertIn(vuln, vulns, 'Vuln not added')

        # Then

        self.model_controller.delVulnFromServiceSYNC(host.getID(),
                            service.getID(), vuln.getID())

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        added_service = added_interface.getService(service.getID())
        vulns = added_service.getVulns()
        self.assertNotIn(vuln, vulns, 'Vuln not removed')

    def testDeleteNoteFromHost(self):
        """ Creates a Host adds a Note then removes """

        host1 = create_host(self, "coquito")

        note = ModelObjectNote(name='NoteTest', text='TestDescription')

        self.model_controller.addNoteToHostSYNC(host1.getID(), note)

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()]

        self.assertIn(host1.getID(), hosts_ids,
                                "Host not in controller")

        self.model_controller.delNoteFromHostSYNC(host1.getID(), note.getID())

        added_host = self.model_controller.getHost(host1.getName())

        self.assertNotIn(note, added_host.getNotes(), 'Note not removed')


    def testDelNoteFromInterface(self):
        """ Creates a Hosts, adds an Interface and a Note, then removes the
        note """

        # When
        host = create_host(self)
        interface = create_interface(self, host)

        note = ModelObjectNote(name='NoteTest', text='TestDescription')

        self.model_controller.addNoteToInterfaceSYNC(host.getID(),
                                interface.getID(), note)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        notes = added_interface.getNotes()
        self.assertIn(note, notes, 'Note not added')

        # Then
        self.model_controller.delNoteFromInterfaceSYNC(host.getID(),
                            interface.getID(), note.getID())

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        notes = added_interface.getNotes()

        self.assertNotIn(note, notes, 'Note not removed')



    def testDelNoteFromService(self):
        """ Creates a Hosts, adds an Interface, a Service and a Note, then removes the
        note """

        # When
        host = create_host(self)
        interface = create_interface(self, host)
        service = create_service(self, host, interface)

        note = ModelObjectNote(name='NoteTest', text='TestDescription')

        self.model_controller.addNoteToServiceSYNC(host.getID(),
                                service.getID(), note)

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        added_service = added_interface.getService(service.getID())
        notes = added_service.getNotes()
        self.assertIn(note, notes, 'Note not added')

        # Then

        self.model_controller.delNoteFromServiceSYNC(host.getID(),
                            service.getID(), note.getID())

        added_host = self.model_controller.getHost(host.getName())
        added_interface = added_host.getInterface(interface.getID())
        added_service = added_interface.getService(service.getID())
        notes = added_service.getNotes()
        self.assertNotIn(note, notes, 'Note not removed')

if __name__ == '__main__':
    unittest.main()



########NEW FILE########
__FILENAME__ = nessus_plugin_with_api
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import unittest
import sys
import os
sys.path.append('.')
import model.controller as controller
from model.workspace import Workspace
from model.container import ModelObjectContainer
import model.api as api
#from model import controller
#from model import api
from plugins.repo.nessus import plugin
from plugins.core import PluginControllerForApi
from mockito import mock, when
from managers.all import CommandManager


class NessusPluginTest(unittest.TestCase):

    def setUp(self):
        """
        Generic test to verify that the object exists and can be
        instantiated without problems.
        """
        self.model_controller = controller.ModelController(mock())
        self.workspace = mock(Workspace)
        when(self.workspace).getContainee().thenReturn(ModelObjectContainer())
        self.cm = mock(CommandManager)
        when(self.cm).saveCommand().thenReturn(True)
        self.model_controller.setWorkspace(self.workspace)
        self._plugin_controller = PluginControllerForApi("test", {"netsparker": plugin.NessusPlugin()}, self.cm)
        api.setUpAPIs(self.model_controller)

    def test_report(self):
        output_file = open(os.path.join(os.getcwd(), 'test_cases/data/nessus_plugin_with_api.nessus'))
        output = output_file.read() 
        self._plugin_controller.processCommandInput("./nessus report")
        self._plugin_controller.onCommandFinished("./nessus report", output)
        self.model_controller.processAllPendingActions()
        self.assertEquals(len(self.model_controller.getAllHosts()), 7,
                "Not all hosts added to model")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = netsparker_plugin_with_api
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import unittest
import sys
import os
sys.path.append('.')
import model.controller as controller
from model.workspace import Workspace
from model.container import ModelObjectContainer
import model.api as api
#from model import controller
#from model import api
from plugins.repo.netsparker import plugin
from plugins.core import PluginControllerForApi
from mockito import mock, when
from managers.all import CommandManager


class NetsparkerPluginTest(unittest.TestCase):

    def setUp(self):
        """
        Generic test to verify that the object exists and can be
        instantiated without problems.
        """
        self.model_controller = controller.ModelController(mock())
        self.workspace = mock(Workspace)
        when(self.workspace).getContainee().thenReturn(ModelObjectContainer())
        self.cm = mock(CommandManager)
        when(self.cm).saveCommand().thenReturn(True)
        self.model_controller.setWorkspace(self.workspace)
        self._plugin_controller = PluginControllerForApi("test", {"netsparker": plugin.NetsparkerPlugin()}, self.cm)
        api.setUpAPIs(self.model_controller)

    def test_report(self):
        output_file = open(os.path.join(os.getcwd(), 'test_cases/data/netsparker_plugin_with_api.xml'))
        output = output_file.read()
        self._plugin_controller.processCommandInput("./netsparker report")
        self._plugin_controller.onCommandFinished("./netsparker report", output)
        self.model_controller.processAllPendingActions()
        self.assertEquals(len(self.model_controller.getAllHosts()), 1,
                "Not all hosts added to model")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = nmap_plugin_with_api
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import unittest
import sys
import os
sys.path.append('.')
import model.controller as controller
from model.workspace import Workspace
from model.container import ModelObjectContainer
import model.api as api
#from model import controller
#from model import api
from plugins.repo.nmap import plugin
from plugins.core import PluginControllerForApi
from mockito import mock, when
from managers.all import CommandManager


class TestSequenceFunctions(unittest.TestCase):

    def setUp(self):
        """
        Generic test to verify that the object exists and can be
        instantiated without problems.
        """
        self.model_controller = controller.ModelController(mock())
        self.workspace = mock(Workspace)
        when(self.workspace).getContainee().thenReturn(ModelObjectContainer())
        self.cm = mock(CommandManager)
        when(self.cm).saveCommand().thenReturn(True)
        self.model_controller.setWorkspace(self.workspace)
        self._plugin_controller = PluginControllerForApi("test", {"nmap": plugin.NmapPlugin()}, self.cm)
        api.setUpAPIs(self.model_controller)

    def test_ping_scan(self):
        output_file = open(os.path.join(os.getcwd(), 'test_cases/data/nmap_plugin_with_api.xml'))
        output = output_file.read()
        self._plugin_controller.processCommandInput("nmap localhost")
        self._plugin_controller.onCommandFinished("nmap localhost", output)
        self.model_controller.processAllPendingActions()
        self.assertEquals(len(self.model_controller.getAllHosts()), 1,
                "Not all hosts added to model")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = pluginbase_api
#!/usr/bin/python

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

from unittest import TestCase
import unittest
import sys
sys.path.append('.')
import model.controller as controller
from mockito import mock, when
from model import api
from plugins.core import PluginBase, PluginController
from model.workspace import Workspace
from model.container import ModelObjectContainer
from managers.all import CommandManager


class TestPluginCreateModelObject(TestCase):
    """docstring for TestModelObjectCRUD"""
    def setUp(self):
        self._model_controller = controller.ModelController(mock())
        self.cm = mock(CommandManager)
        when(self.cm).saveCommand().thenReturn(True)
        self._plugin_controller = PluginController("test", {}, self.cm)

        class PluginTest(PluginBase):
            def __init__(self):
                PluginBase.__init__(self)
                self.id = "Test"
                self.name = "Test"

            def parseOutputString(self, output, debug=False):
                pass

        self.workspace = mock(Workspace)
        when(self.workspace).getContainee().thenReturn(ModelObjectContainer())
        self._model_controller.setWorkspace(self.workspace)

        self.plugin = PluginTest()
        api.setUpAPIs(self._model_controller)

        self._plugin_controller.setActivePlugin(self.plugin)

    def test_create_host(self):
        """
        Testing the creation of one host
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        self.assertTrue(h is not None, "host should have an ID")
        self.assertTrue(len(self._model_controller.getAllHosts()) == 1, "The controller should have one host")
        self.assertTrue(self._model_controller.getHost(h) is not None, "The host should be in the controller")

    def test_create_same_host_two_times(self):
        """
        Testing the creation of the same host, two times.
        This simulates two plugins creating the host with the same name
        We should end up with just one host in the controller
        """
        h1 = self.plugin.createAndAddHost("pepito", "linux")
        h2 = self.plugin.createAndAddHost("pepito", "linux")
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        self.assertTrue(len(self._model_controller.getAllHosts()) == 1, "The controller should have just one host")
        self.assertTrue(self._model_controller.getHost(h1) == self._model_controller.getHost(h2), "The host should be the same")

    def test_create_host_with_interface(self):
        """
        Testing the creation of one host, with one interface
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        self.assertTrue(i is not None, "interface should have an ID")
        host = self._model_controller.getHost(h)
        self.assertTrue(len(host.getAllInterfaces()) == 1, "Host should have one interface")
        self.assertTrue(host.getInterface(i) is not None, "The interface should be the one we've just create")

    def test_create_interface_two_times(self):
        """
        Testing the creation of the same interface, two times.
        This simulates two plugins creating the host with the same interface
        We should end up with just one interface in that host
        """
        h1 = self.plugin.createAndAddHost("pepito", "linux")
        i1 = self.plugin.createAndAddInterface(h1, "1.2.3.4")

        h2 = self.plugin.createAndAddHost("pepito", "linux")
        i2 = self.plugin.createAndAddInterface(h2, "1.2.3.4")

        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        self.assertTrue(len(self._model_controller.getAllHosts()) == 1, "The controller should have just one host")
        self.assertTrue(len(self._model_controller.getHost(h1).getAllInterfaces()) == 1, "The host should have just one interface")

    def test_create_host_with_interface_with_service(self):
        """
        Testing the creation of one host, with one interface and one service on that interface
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        s = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['80'])
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        host = self._model_controller.getHost(h)
        interface = host.getInterface(i)
        self.assertTrue(len(interface.getAllServices()) == 1, "The interface should have just one service")
        self.assertTrue(interface.getService(s) is not None, "The service should be the one we've just create")

    def test_create_two_services_different_names_equal_port(self):
        """
        Testing the creation of two services with different names but same protocol and port
        The result should only one services being created, since both have the same id
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        s1 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['80'])
        s2 = self.plugin.createAndAddServiceToInterface(h, i, "test", protocol="tcp", ports=['80'])
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        host = self._model_controller.getHost(h)
        interface = host.getInterface(i)
        self.assertEqual(s1, s2, "Both services should have the same id")
        self.assertTrue(len(interface.getAllServices()) == 1, "The interface should have just one service")

    def test_create_two_services_same_names_different_port(self):
        """
        Testing the creation of two services with same names but different port
        The result should only two services being created, since both have the different ids
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        s1 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['80'])
        s2 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['443'])
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        host = self._model_controller.getHost(h)
        interface = host.getInterface(i)
        self.assertNotEqual(s1, s2, "Both services should have the same id")
        self.assertTrue(len(interface.getAllServices()) == 2, "The interface should have two services")

    def test_create_vuln_to_service(self):
        """
        Testing the creation of a vuln to a service
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        s1 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['80'])
        s2 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['443'])
        v = self.plugin.createAndAddVulnToService(h, s1, "vuln1", "descripcion")
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        host = self._model_controller.getHost(h)
        interface = host.getInterface(i)
        service1 = interface.getService(s1)
        service2 = interface.getService(s2)
        self.assertTrue(len(service1.getVulns()) == 1, "The service should have one vuln")
        self.assertTrue(service1.getVuln(v) is not None, "The vuln should be the one we've just create")
        self.assertTrue(len(service2.getVulns()) == 0, "The service should't have any vuln")

    def test_create_note_to_service(self):
        """
        Testing the creation of a vuln to a service
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        s1 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['80'])
        s2 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['443'])
        n = self.plugin.createAndAddNoteToService(h, s1, "note1", "desc1")
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        host = self._model_controller.getHost(h)
        interface = host.getInterface(i)
        service1 = interface.getService(s1)
        service2 = interface.getService(s2)
        self.assertTrue(len(service1.getNotes()) == 1, "The service should have one vuln")
        self.assertTrue(service1.getNote(n) is not None, "The vuln should be the one we've just create")
        self.assertTrue(len(service2.getNotes()) == 0, "The service should't have any vuln")

    def test_create_note_to_note_service(self):
        """
        Testing the creation of a vuln to a service
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        s1 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['80'])
        s2 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['443'])
        n = self.plugin.createAndAddNoteToService(h, s1, "note1", "desc1")
        n2 = self.plugin.createAndAddNoteToNote(h, s1, n, "note2", "desc2")
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        host = self._model_controller.getHost(h)
        interface = host.getInterface(i)
        service1 = interface.getService(s1)
        service2 = interface.getService(s2)
        note1 = service1.getNote(n)
        self.assertTrue(service1.getNote(n) is not None, "The note should be the one we've just create")
        self.assertTrue(len(note1.getNotes()) == 1, "The note should have a nested note")

    def test_create_cred_to_service(self):
        """
        Testing the creation of a vuln to a service
        """
        h = self.plugin.createAndAddHost("pepito", "linux")
        i = self.plugin.createAndAddInterface(h, "1.2.3.4")
        s1 = self.plugin.createAndAddServiceToInterface(h, i, "unknown", protocol="tcp", ports=['80'])
        c = self.plugin.createAndAddCredToService(h, s1, "user", "pass")
        self._plugin_controller.setLastCommandInformation("mock")
        self._plugin_controller.onCommandFinished()
        self._model_controller.processAllPendingActions()
        
        host = self._model_controller.getHost(h)
        interface = host.getInterface(i)
        service1 = interface.getService(s1)
        cred = service1.getCred(c)
        self.assertTrue(service1.getCred(c) is not None, "The cred should be the one we've just create")
        self.assertTrue(len(service1.getCreds()) == 1, "The service should have a nested note")

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = plugin_controller
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import unittest
import sys
import os
sys.path.append(os.path.abspath(os.getcwd()))
import model.api
from plugins.core import  PluginController
from managers.all import PluginManager
import re
from mockito import mock, when
from model.controller import ModelController
from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()
from model.workspace import WorkspaceOnCouch, WorkspaceManager
from auth.manager import SecurityManager


class PluginControllerTestSuite(unittest.TestCase):

    def setUp(self):
        self.plugin_repo_path = os.path.join(os.getcwd(), "plugins", "repo")
        self.plugin_manager = PluginManager(self.plugin_repo_path)

        controller = ModelController(mock(SecurityManager))

        wm = WorkspaceManager(controller, mock(PluginController))
        work = wm.createWorkspace('default', workspaceClass=WorkspaceOnCouch)
        work.setModelController(controller)
        controller.setWorkspace(work)
        model.api.setUpAPIs(controller)


        class WorkspaceStub():
            def __init__(self):
                self.id = "test_space"
        self.controller = self.plugin_manager.createController(WorkspaceStub())

    def tearDown(self):
        pass

    def test_instantiation(self):
        """
        Generic test to verify that the object exists and can be
        instantiated without problems.
        """
        controller = PluginController("test", {}, mock())
        self.assertTrue(controller is not None)

    def test_sanitation_checker(self):
        """
        The object of this test is to verify that the plugin controller
        is able to detect and avoid malicious commands sent by rogue plugins.
        The mechanism is not intend to be perfect but at least should give some
        amount of protection.
        """
        controller = PluginController("test", {}, mock())

        original_command = "nmap -v -iR 10000 -PN -p 80"
        modified_command = "nmap -v -iR 10000 -PN -p 80|"

        self.assertTrue(controller._is_command_malformed(original_command, modified_command), 
                'Modified command is malformed')

        original_command = "nmap -v -iR 10000 -PN -p 80"
        modified_command = "nmap -v -i#R 10000 -PN -p 80"
        self.assertTrue(controller._is_command_malformed(original_command, modified_command), 
                'Modified command is malformed')

        original_command = "nmap -v -iR 10000 -PN -p 80"
        modified_command = "nmap -v -iR $10000 -PN -p 80"
        self.assertTrue(controller._is_command_malformed(original_command, modified_command), 
                'Modified command is malformed')

        original_command = "nmap -v -iR 10000 -PN -p 80"
        modified_command = "nmap -v -iR 10000 -PN -p 80"

        self.assertTrue( not controller._is_command_malformed(original_command, modified_command), 
                    "Original Command same as modified command but is malformed")

    def test_input_processing(self):
        """
        Check that the controller is able to give the active plugin an input and
        verify that what the plugin gives back to it is a safe command string.

        TODO: Fix the docstring. It sucks.
        TODO: Use a generic plugin.
        """

        prompt = "fdeguzman@testserver:$"

        command_string = "nmap localhost"
        modified_string = self.controller.processCommandInput(prompt, "", "", 
                                                         command_string, False)
        arg_search = re.match(r"^.*(-oX\s*[^\s]+).*$", modified_string)
        self.assertTrue(arg_search is not None)

        command_string = "nmap -oX benito_camelas.xml localhost"
        modified_string = self.controller.processCommandInput(prompt, "", "",  command_string, False)
        arg_search = re.match(r"^.*(-oX benito_camelas\.xml).*$", modified_string)
        self.assertTrue(arg_search is None)

    def test_process_command_keep_information(self):

        prompt = "fdeguzman@testserver:$"

        command_string = "nmap -oX benito_camelas.xml localhost"
        modified_string = self.controller.processCommandInput(prompt, "", "",  command_string, False)

        self.assertIsNotNone(self.controller.last_command_information, "Command Information not saved")



if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = plugin_controller_api
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import unittest
import os
import requests
import json
import sys
import base64
from mockito import mock, when

sys.path.append('.')

from managers.all import PluginManager
import plugins.api
import model.api
import model.controller
from model.workspace import Workspace
from model.container import ModelObjectContainer
from managers.all import PersistenceManager


class TestPluginControllerApi(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        plugin_repo_path = os.path.join(os.getcwd(), "plugins", "repo")
        plugin_manager = PluginManager(plugin_repo_path)
        plugins.api.startPluginControllerAPI(plugin_manager)

    @classmethod
    def tearDownClass(cls):
        plugins.api.stopPluginControllerAPI()

    def setUp(self):
        self.model_controller = model.controller.ModelController(mock())
        self.workspace = mock(Workspace)
        self.workspace.name = "default"
        self.workspace._dmanager = mock(PersistenceManager())
        when(self.workspace._dmanager).saveDocument().thenReturn(True)
        when(self.workspace).getContainee().thenReturn(ModelObjectContainer())
        self.model_controller.setWorkspace(self.workspace)

        model.api.setUpAPIs(self.model_controller)
        self.url_input = "http://127.0.0.1:9977/cmd/input"
        self.url_output = "http://127.0.0.1:9977/cmd/output"
        self.url_active_plugins = "http://127.0.0.1:9977/cmd/active-plugins"
        self.headers = {'Content-type': 'application/json', 'Accept': 'application/json'}

    def tearDown(self):
        requests.delete(self.url_active_plugins)

    def test_cmd_input_ls(self):
        cmd = "ls"
        data = {"cmd": cmd}
        response = requests.post(self.url_input,
                                 data=json.dumps(data),
                                 headers=self.headers)

        self.assertEquals(response.status_code, 204, "Status Code should be 204: No Content, but received: %d" % response.status_code)


    def test_cmd_input_ping(self):
        cmd = "ping 127.0.0.1"
        data = {"cmd": cmd}
        response = requests.post(self.url_input,
                                 data=json.dumps(data),
                                 headers=self.headers)
        json_response = response.json()

        self.assertEquals(response.status_code, 200, "Status Code should be 200: OK, but received: %d" % response.status_code)
        self.assertIn("cmd", json_response.keys(), "Json response should have a cmd key")
        self.assertIn("custom_output_file", json_response.keys(), "Json response should have a custom_output_file key")
        self.assertIsNone(json_response.get("cmd"), "cmd should be None")
        self.assertIsNone(json_response.get("custom_output_file"), "custom_output_file should be None")

    def test_cmd_input_nmap(self):
        cmd = "nmap 127.0.0.1"
        data = {"cmd": cmd}
        response = requests.post(self.url_input,
                                 data=json.dumps(data),
                                 headers=self.headers)
        json_response = response.json()

        self.assertEquals(response.status_code, 200, "Status Code should be 200: OK, but received: %d" % response.status_code)
        self.assertIn("cmd", json_response.keys(), "Json response should have a cmd key")
        self.assertIn("custom_output_file", json_response.keys(), "Json response should have a custom_output_file key")
        self.assertIsNotNone(json_response.get("cmd"), "cmd shouldn't be None")
        self.assertIsNotNone(json_response.get("custom_output_file"), "custom_output_file shouldn't be None")

    def test_cmd_input_get_instead_post(self):
        cmd = "ls"
        data = {"cmd": cmd}
        response = requests.get(self.url_input,
                                data=json.dumps(data),
                                headers=self.headers)

        self.assertEquals(response.status_code, 405, "Status code should be 405, but received: %d" % response.status_code)

    def test_cmd_output_nmap(self):
        # send input to register the active plugin
        cmd = "nmap 127.0.0.1"
        data = {"cmd": cmd}
        response = requests.post(self.url_input,
                                 data=json.dumps(data),
                                 headers=self.headers)

        #send output, using a fake nmap xml ouput
        output_file = open(os.path.join(os.getcwd(), 'test_cases/data/nmap_plugin_with_api.xml'))
        output = base64.b64encode(output_file.read())
        data = {"cmd": cmd, "output": output}
        response = requests.post(self.url_output,
                                 data=json.dumps(data),
                                 headers=self.headers)
        self.model_controller.processAllPendingActions()

        self.assertEquals(response.status_code, 200, "Status Code should be 200: OK, but received: %d" % response.status_code)
        self.assertEquals(len(self.model_controller.getAllHosts()), 1, "Controller should have 1 host")

    def test_cmd_output_plugin_not_active(self):
        #send output, using a fake nmap xml ouput
        cmd = "nmap 127.0.0.1"
        output_file = open(os.path.join(os.getcwd(), 'test_cases/data/nmap_plugin_with_api.xml'))
        output = base64.b64encode(output_file.read())
        data = {"cmd": cmd, "output": output}
        response = requests.post(self.url_output,
                                 data=json.dumps(data),
                                 headers=self.headers)

        self.assertEquals(response.status_code, 400, "Status Code should be 400: Bad Request, but received: %d" % response.status_code)

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = vulns
#!/usr/bin/python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
from unittest import TestCase
import unittest
import sys
sys.path.append('.')
import model.controller as controller
import plugins.core as plcore
from mockito import mock
from model import api
from model.hosts import Host, Interface, Service
from model.workspace import WorkspaceOnCouch, WorkspaceManager, WorkspaceOnFS
from model.common import ModelObjectVuln, ModelObjectVulnWeb
from persistence.orm import WorkspacePersister
import random
from persistence.orm import WorkspacePersister


from managers.all import CommandManager, CouchdbManager, PersistenceManagerFactory

def new_random_workspace_name():
    return ("aworkspace" + "".join(random.sample([chr(i) for i in range(65, 90)
                                ], 10 ))).lower() 

def create_host(self, host_name="pepito", os="linux"):
    host = Host(host_name, os)
    self.model_controller.addHostSYNC(host)
    return host

def create_interface(self, host, iname="coqiuto", mac="00:03:00:03:04:04"):
    interface = Interface(name=iname, mac=mac)
    self.model_controller.addInterfaceSYNC(host.getName(), interface)
    return interface

def create_service(self, host, interface, service_name = "coquito"):
    service = Service(service_name)
    self.model_controller.addServiceToInterfaceSYNC(host.getID(),
                                interface.getID(), service)
    return service

class VulnerabilityCreationTests(unittest.TestCase):

    @classmethod
    def setUpClass(cls):
        cls.model_controller = controller.ModelController(mock())
        api.setUpAPIs(cls.model_controller)

    def setUp(self):
        self.wm = WorkspaceManager(self.model_controller, mock(plcore.PluginController))
        self.temp_workspace = self.wm.createWorkspace(new_random_workspace_name(),
                                        workspaceClass=WorkspaceOnCouch) 

        self.wm.setActiveWorkspace(self.temp_workspace)
        WorkspacePersister.stopThreads()

    def tearDown(self):
        self.wm.removeWorkspace(self.temp_workspace.name)

    def testStandarizeNumericVulnSeverity(self):
        """ Verifies numeric severity transformed into 'info, low, high,
        critical' severity"""

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity=0)

        self.assertEquals(vuln.severity, 'info',
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity=1)

        self.assertEquals(vuln.severity, 'low',
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity=2)

        self.assertEquals(vuln.severity, 'med',
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity=3)

        self.assertEquals(vuln.severity, 'high',
                    'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity=4)

        self.assertEquals(vuln.severity, 'critical', 
                'Vulnerability severity not transformed correctly')


        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity=5)

        self.assertEquals(vuln.severity, 'unclassified', 
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity=-1)

        self.assertEquals(vuln.severity, 'unclassified', 
                'Vulnerability severity not transformed correctly')

    def testStandarizeShortnameVulnSeverity(self):
        """ Verifies longname  severity transformed into 'info, low, high,
        critical' severity (informational -> info)"""

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='informational')

        self.assertEquals(vuln.severity, 'info',
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='medium')

        self.assertEquals(vuln.severity, 'med',
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='highest')

        self.assertEquals(vuln.severity, 'high',
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='criticalosiuos')

        self.assertEquals(vuln.severity, 'critical',
                'Vulnerability severity not transformed correctly')

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='tuvieja')

        self.assertEquals(vuln.severity, 'unclassified',
                'Vulnerability severity not transformed correctly')

    def testStandarizeUpdatedSeverity(self):
        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                                severity='informational')

        self.assertEquals(vuln.severity, 'info',
                'Vulnerability severity not transformed correctly')

        vuln.updateAttributes(severity='3')
        self.assertEquals(vuln.severity, 'high',
                'Vulnerability severity not transformed correctly')



if __name__ == '__main__':
    unittest.main()


########NEW FILE########
__FILENAME__ = w3af_plugin_with_api
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import unittest
import sys
import os
sys.path.append('.')
import model.controller as controller
from model.workspace import Workspace
from model.container import ModelObjectContainer
import model.api as api
#from model import controller
#from model import api
from plugins.repo.w3af import plugin
from plugins.core import PluginControllerForApi
from mockito import mock, when
from managers.all import CommandManager


class W3afPluginTest(unittest.TestCase):

    def setUp(self):
        """
        Generic test to verify that the object exists and can be
        instantiated without problems.
        """
        self.model_controller = controller.ModelController(mock())
        self.workspace = mock(Workspace)
        when(self.workspace).getContainee().thenReturn(ModelObjectContainer())
        self.cm = mock(CommandManager)
        when(self.cm).saveCommand().thenReturn(True)
        self.model_controller.setWorkspace(self.workspace)
        self._plugin_controller = PluginControllerForApi("test", {"w3af": plugin.W3afPlugin()}, self.cm)
        api.setUpAPIs(self.model_controller)

    def test_report(self):
        output_file = open(os.path.join(os.getcwd(), 'test_cases/data/w3af_plugin_with_api.xml'))
        output = output_file.read() 
        self._plugin_controller.processCommandInput("./w3af report")
        self._plugin_controller.onCommandFinished("./w3af report", output)
        self.model_controller.processAllPendingActions()
        self.assertEquals(len(self.model_controller.getAllHosts()), 1,
                "Not all hosts added to model")


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = workspace
#!/usr/bin/python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import unittest
import os
import sys
sys.path.append('.')
from model.workspace import (CouchdbManager, WorkspaceManager,
                             WorkspaceOnCouch, WorkspaceOnFS)
from model.controller import ModelController

from plugins.core import PluginController
import random

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()

from mockito import mock


class TestWorkspacesManagement(unittest.TestCase):

    def setUp(self):
        self.couch_uri = CONF.getCouchURI()
        self.cdm = CouchdbManager(uri=self.couch_uri)
        self.wm = WorkspaceManager(mock(ModelController),
                                   mock(PluginController))
        self._fs_workspaces = []
        self._couchdb_workspaces = []

    def tearDown(self):
        self.cleanCouchDatabases()
        self.cleanFSWorkspaces()
        # pass

    def new_random_workspace_name(self):
        return ("aworkspace" + "".join(random.sample(
            [chr(i) for i in range(65, 90)], 10))).lower()

    def cleanFSWorkspaces(self):
        import shutil
        basepath = os.path.expanduser("~/.faraday/persistence/")

        for d in self._fs_workspaces:
            wpath = os.path.join(basepath, d)
            if os.path.isdir(wpath):
                shutil.rmtree(wpath)

    def cleanCouchDatabases(self):
        try:
            for wname in self._couchdb_workspaces:
                self.cdm.removeWorkspace(wname)
        except Exception as e:
            print e

    def test_create_fs_workspace(self):
        """
        Verifies the creation of a filesystem workspace
        """
        wname = self.new_random_workspace_name()
        self._fs_workspaces.append(wname)
        self.wm.createWorkspace(wname, workspaceClass=WorkspaceOnFS)

        self.assertFalse(self.cdm.existWorkspace(wname))

        wpath = os.path.expanduser("~/.faraday/persistence/%s" % wname)
        self.assertTrue(os.path.exists(wpath))

    def test_create_couch_workspace(self):
        """
        Verifies the creation of a couch workspace
        """
        wname = self.new_random_workspace_name()
        self._couchdb_workspaces.append(wname)
        self.wm.createWorkspace(wname, workspaceClass=WorkspaceOnCouch)

        self.assertTrue(self.cdm.existWorkspace(wname))

        wpath = os.path.expanduser("~/.faraday/persistence/%s" % wname)
        self.assertFalse(os.path.exists(wpath))

    def test_delete_couch_workspace(self):
        """
        Verifies the deletion of a couch workspace
        """
        wname = self.new_random_workspace_name()
        self.wm.createWorkspace(wname, workspaceClass=WorkspaceOnCouch)

        self.assertTrue(self.cdm.existWorkspace(wname))

        #Delete workspace
        self.wm.removeWorkspace(wname)
        self.assertFalse(self.cdm.existWorkspace(wname))

    def test_delete_fs_workspace(self):
        """
        Verifies the deletion of a filesystem workspace
        """
        wname = self.new_random_workspace_name()
        self.wm.createWorkspace(wname, workspaceClass=WorkspaceOnFS)

        wpath = os.path.expanduser("~/.faraday/persistence/%s" % wname)
        self.assertTrue(os.path.exists(wpath))

        #Delete workspace
        self.wm.removeWorkspace(wname)
        self.assertFalse(os.path.exists(wpath))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = workspace_manager
#!/usr/bin/python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import unittest
import sys
sys.path.append('.')
import model.controller as controller
import plugins.core as plcore
from mockito import mock
from model import api
from model.hosts import Host, Interface, Service
from model.common import (ModelObjectVuln, ModelObjectVulnWeb,
                          ModelObjectNote, ModelObjectCred)
from model.workspace import WorkspaceOnCouch, WorkspaceManager, WorkspaceOnFS
import random
from persistence.orm import WorkspacePersister
from managers.all import CouchdbManager

from config.configuration import getInstanceConfiguration
CONF = getInstanceConfiguration()


def new_random_workspace_name():
    return ("aworkspace" + "".join(random.sample(
        [chr(i) for i in range(65, 90)], 10))).lower()


def create_host(self, host_name="pepito", os="linux"):
    host = Host(host_name, os)
    self.model_controller.addHostSYNC(host)
    return host


def create_interface(self, host, iname="coquito", mac="00:03:00:03:04:04",
                     ip="127.0.0.1"):
    interface = Interface(name=iname, mac=mac, ipv4_address=ip)
    self.model_controller.addInterfaceSYNC(host.getName(), interface)
    return interface


def create_service(self, host, interface, service_name="coquito", ports=999):
    service = Service(service_name, ports=ports)
    self.model_controller.addServiceToInterfaceSYNC(host.getID(),
                                                    interface.getID(),
                                                    service)
    return service


class TestWorkspaceManager(unittest.TestCase):
    """docstring for TestWorspace"""
    @classmethod
    def setUpClass(cls):
        cls.model_controller = controller.ModelController(mock())
        api.setUpAPIs(cls.model_controller)
        cls.couch_uri = CONF.getCouchURI()
        cls.cdm = CouchdbManager(uri=cls.couch_uri)

    def setUp(self):
        self._couchdb_workspaces = []
        self.wm = WorkspaceManager(self.model_controller,
                                   mock(plcore.PluginController))

    def tearDown(self):
        self.cleanCouchDatabases()

    def cleanCouchDatabases(self):
        try:
            for wname in self._couchdb_workspaces:
                self.cdm.removeWorkspace(wname)
        except Exception as e:
            print e

    def test_switch_workspace_with_objects(self):
        workspace = self.wm.createWorkspace(new_random_workspace_name(),
                                            workspaceClass=WorkspaceOnCouch)
        self._couchdb_workspaces.append(workspace.name)
        self.wm.setActiveWorkspace(workspace)
        WorkspacePersister.stopThreads()

        host1 = create_host(self, "coquito")
        interface1 = create_interface(self, host1, iname="pepito")
        service1 = create_service(self, host1, interface1)

        self.assertIn(host1, self.model_controller.getAllHosts(),
                      "Host not in controller")
        self.assertIn(interface1, host1.getAllInterfaces(),
                      "Interface not in host!")
        self.assertIn(service1, interface1.getAllServices(),
                      "Service not in Interface!")

        workspace2 = self.wm.createWorkspace(new_random_workspace_name(),
                                             workspaceClass=WorkspaceOnCouch)
        self._couchdb_workspaces.append(workspace2.name)
        self.wm.setActiveWorkspace(workspace2)
        WorkspacePersister.stopThreads()

        self.assertNotIn(host1, self.model_controller.getAllHosts(),
                         "Host in controller, should be removed when \
                         switching workspaces")

        self.wm.setActiveWorkspace(workspace)
        WorkspacePersister.stopThreads()
        self.assertIn(host1, self.model_controller.getAllHosts(),
                      "Host not in controller")
        self.assertIn(interface1, host1.getAllInterfaces(),
                      "Interface not in host!")
        self.assertIn(service1, interface1.getAllServices(),
                      "Service not in Interface!")

    def test_remove_active_workspace(self):
        workspace = self.wm.createWorkspace(new_random_workspace_name(),
                                            workspaceClass=WorkspaceOnCouch)

        self.wm.setActiveWorkspace(workspace)
        WorkspacePersister.stopThreads()
        host1 = create_host(self, "coquito")

        self.wm.removeWorkspace(workspace.name)

        hosts_ids = [h.getID() for h in self.model_controller.getAllHosts()]
        self.assertNotIn(host1.getID(), hosts_ids,
                         'Host not removed while removing active workspace')

    def test_remove_active_workspace_fs(self):
        workspace = self.wm.createWorkspace(new_random_workspace_name(),
                                            workspaceClass=WorkspaceOnFS)
        self.wm.setActiveWorkspace(workspace)
        WorkspacePersister.stopThreads()
        host1 = create_host(self, "coquito")

        self.wm.removeWorkspace(workspace.name)

        self.assertNotIn(host1, self.model_controller.getAllHosts(),
                         'Host not removed while removing active workspace')

    def test_remove_another_workspace(self):
        workspace = self.wm.createWorkspace(new_random_workspace_name(),
                                            workspaceClass=WorkspaceOnCouch)

        workspace2 = self.wm.createWorkspace(new_random_workspace_name(),
                                             workspaceClass=WorkspaceOnCouch)
        self._couchdb_workspaces.append(workspace2.name)

        self.wm.setActiveWorkspace(workspace)
        WorkspacePersister.stopThreads()
        create_host(self, "coquito")
        self.wm.setActiveWorkspace(workspace2)
        WorkspacePersister.stopThreads()
        self.wm.removeWorkspace(workspace.name)

        self.assertNotIn(workspace.name, self.wm.getWorkspacesNames(),
                         "Workspace not removed")
        self.assertIn(workspace2.name, self.wm.getWorkspacesNames(),
                      "Workspace removed while removing another workspace")

    def test_load_workspace_on_couch(self):
        """ This test case creates a host within the Model Controller context
        adds an interface to it then adds a VulnWeb"""

        """
        We are going to test this structure:
        host -> interface1 -> service1 -> vuln_web
                                       -> vuln
                                       -> note
                           -> service2 -> vuln
                                       -> vuln
             -> vuln
             -> note
             -> note

             -> interface2 -> service3 -> note
                                       -> credential
                                       -> vuln
                           -> vuln
        """

        workspace = self.wm.createWorkspace(new_random_workspace_name(),
                                            workspaceClass=WorkspaceOnCouch)
        self._couchdb_workspaces.append(workspace.name)
        self.wm.setActiveWorkspace(workspace)
        WorkspacePersister.stopThreads()

        host = create_host(self)
        interface = create_interface(self, host, ip="127.0.0.1")
        interface2 = create_interface(self, host, ip="127.0.0.2")
        service = create_service(self, host, interface, ports=1)
        service2 = create_service(self, host, interface, ports=2)
        service3 = create_service(self, host, interface2, ports=3)

        vulnweb = ModelObjectVulnWeb(name='VulnWebTest',
                                     desc='TestDescription',
                                     severity='high')

        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                                   service.getID(),
                                                   vulnweb)

        vuln = ModelObjectVuln(name='VulnTest', desc='TestDescription',
                               severity='high')
        vuln2 = ModelObjectVuln(name='VulnTest2', desc='TestDescription',
                                severity='high')
        vuln3 = ModelObjectVuln(name='VulnTest3', desc='TestDescription',
                                severity='high')
        vuln4 = ModelObjectVuln(name='VulnTest4', desc='TestDescription',
                                severity='high')
        vuln5 = ModelObjectVuln(name='VulnTest5', desc='TestDescription',
                                severity='high')
        vuln6 = ModelObjectVuln(name='VulnTest6', desc='TestDescription',
                                severity='high')

        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                                   service.getID(),
                                                   vuln)
        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                                   service2.getID(),
                                                   vuln2)
        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                                   service2.getID(),
                                                   vuln3)
        self.model_controller.addVulnToHostSYNC(host.getID(),
                                                vuln4)
        self.model_controller.addVulnToServiceSYNC(host.getID(),
                                                   service3.getID(),
                                                   vuln5)
        self.model_controller.addVulnToInterfaceSYNC(host.getID(),
                                                     interface2.getID(),
                                                     vuln6)

        note = ModelObjectNote(name='NoteTest', text='TestDescription')
        note2 = ModelObjectNote(name='NoteTest2', text='TestDescription')
        note3 = ModelObjectNote(name='NoteTest3', text='TestDescription')
        note4 = ModelObjectNote(name='NoteTest4', text='TestDescription')

        self.model_controller.addNoteToServiceSYNC(host.getID(),
                                                   service.getID(),
                                                   note)
        self.model_controller.addNoteToHostSYNC(host.getID(),
                                                note2)
        self.model_controller.addNoteToHostSYNC(host.getID(),
                                                note3)
        self.model_controller.addNoteToServiceSYNC(host.getID(),
                                                   service3.getID(),
                                                   note4)

        cred = ModelObjectCred(username='user', password='pass')

        self.model_controller.addCredToServiceSYNC(host.getID(),
                                                   service3.getID(),
                                                   cred)

        # First, we test if the structure was correctly created

        # one host with two interfaces, one vuln and two notes

        self.assertEquals(len(self.model_controller.getAllHosts()), 1,
                          "Host not created")
        added_host = self.model_controller.getHost(host.getID())

        self.assertEquals(len(added_host.getAllInterfaces()), 2,
                          "Interfaces not added to Host")
        self.assertEquals(len(added_host.getVulns()), 1,
                          "Vuln not created")
        self.assertEquals(len(added_host.getNotes()), 2,
                          "Notes not created")

        # one interface with two services, and another one
        # with a service and a vuln

        added_interface1 = added_host.getInterface(interface.getID())
        added_interface2 = added_host.getInterface(interface2.getID())

        self.assertEquals(len(added_interface1.getAllServices()), 2,
                          "Services not created")

        self.assertEquals(len(added_interface2.getAllServices()), 1,
                          "Service not created")

        self.assertEquals(len(added_interface2.getVulns()), 1,
                          "Vulns not created")

        # one service with a note, a vuln and a vuln web
        added_service1 = added_interface1.getService(service.getID())
        self.assertEquals(len(added_service1.getNotes()), 1,
                          "Note not created")
        self.assertEquals(len(added_service1.getVulns()), 2,
                          "Vulns not created")
        added_vuln_web = added_service1.getVuln(vulnweb.getID())
        self.assertEquals(added_vuln_web.class_signature, "VulnerabilityWeb",
                          "Not a vuln web")

        # one service with two vulns
        added_service2 = added_interface1.getService(service2.getID())
        self.assertEquals(len(added_service2.getVulns()), 2,
                          "Services not created")

        # one service with a note, a vuln and a credential

        added_service3 = added_interface2.getService(service3.getID())
        self.assertEquals(len(added_service3.getVulns()), 1,
                          "Vuln not created")
        self.assertEquals(len(added_service3.getNotes()), 1,
                          "Note not created")
        self.assertEquals(len(added_service3.getCreds()), 1,
                          "Cred not created")

        # So, now we reload the worskpace and check everything again

        workspace.load()

        # one host with two interfaces, one vuln and two notes

        self.assertEquals(len(self.model_controller.getAllHosts()), 1,
                          "Host not created")
        added_host = self.model_controller.getHost(host.getID())

        self.assertEquals(len(added_host.getAllInterfaces()), 2,
                          "Interfaces not added to Host")
        self.assertEquals(len(added_host.getVulns()), 1,
                          "Vuln not created")
        self.assertEquals(len(added_host.getNotes()), 2,
                          "Notes not created")

        # one interface with two services, and another one
        # with a service and a vuln

        added_interface1 = added_host.getInterface(interface.getID())
        added_interface2 = added_host.getInterface(interface2.getID())

        self.assertEquals(len(added_interface1.getAllServices()), 2,
                          "Services not created")

        self.assertEquals(len(added_interface2.getAllServices()), 1,
                          "Service not created")

        self.assertEquals(len(added_interface2.getVulns()), 1,
                          "Vulns not created")

        # one service with a note, a vuln and a vuln web
        added_service1 = added_interface1.getService(service.getID())
        self.assertEquals(len(added_service1.getNotes()), 1,
                          "Note not created")
        self.assertEquals(len(added_service1.getVulns()), 2,
                          "Vulns not created")
        added_vuln_web = added_service1.getVuln(vulnweb.getID())
        self.assertEquals(added_vuln_web.class_signature, "VulnerabilityWeb",
                          "Not a vuln web")

        # one service with two vulns
        added_service2 = added_interface1.getService(service2.getID())
        self.assertEquals(len(added_service2.getVulns()), 2,
                          "Services not created")

        # one service with a note, a vuln and a credential

        added_service3 = added_interface2.getService(service3.getID())
        self.assertEquals(len(added_service3.getVulns()), 1,
                          "Vuln not created")
        self.assertEquals(len(added_service3.getNotes()), 1,
                          "Note not created")
        self.assertEquals(len(added_service3.getCreds()), 1,
                          "Cred not created")
   

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = common
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import hashlib
import uuid
import time
import socket
import struct
import sys

def get_hash(parts):
                                     
    return hashlib.sha1("._.".join(parts)).hexdigest()

def new_id():
    return uuid.uuid4()
    
def get_macaddress(host):
    if sys.platform in ['linux','linux2']:
        with open("/proc/net/arp") as fh:
            for line in fh:
                fields = line.strip().split()
                if fields[0] == host:
                    return fields[3]
    else:
        return None
    
def gateway():
    ip=""
    if sys.platform in ['linux','linux2']:
        with open("/proc/net/route") as fh:
            for line in fh:
                fields = line.strip().split()
                if fields[1] != '00000000' or not int(fields[3], 16) & 2:
                    continue
                ip=socket.inet_ntoa(struct.pack("<L", int(fields[2], 16)))
                mac=get_macaddress(ip)
                return [str(ip),str(mac)]
    elif sys.platform in ['darwin']:
                                    
        return None
    else:
        return None
    

                                                       
########NEW FILE########
__FILENAME__ = decorators
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

from persistence.orm import WorkspacePersister 
import restkit.errors
import model

def simple_decorator(decorator):
    '''this decorator can be used to turn simple functions
    into well-behaved decorators, so long as the decorators
    are fairly simple. If a decorator expects a function and
    returns a function (no descriptors), and if it doesn't
    modify function attributes or docstring, then it is
    eligible to use this. Simply apply @simple_decorator to
    your decorator and it will automatically preserve the
    docstring and function attributes of functions to which
    it is applied.'''
    def new_decorator(f):
        g = decorator(f)
        g.__name__ = f.__name__
        g.__doc__ = f.__doc__
        g.__dict__.update(f.__dict__)
        return g
                                                            
                                  
    new_decorator.__name__ = decorator.__name__
    new_decorator.__doc__ = decorator.__doc__
    new_decorator.__dict__.update(decorator.__dict__)
    return new_decorator
 

@simple_decorator
def modify_class_field(func):
    def wrapper(self, *args, **kwargs):
        self.cuca = "eehh"
        return func(self, *args, **kwargs)
    return wrapper


@simple_decorator
def updateLocalMetadata(func):
    def wrapper(self, *args, **kwargs):
        self.updateMetadata()
        return func(self, *args, **kwargs)
    return wrapper

@simple_decorator
def passPermissionsOrRaise(func):
    def wrapper(self, *args, **kwargs):
        self.checkPermissions(op = func.func_name)
        return func(self, *args, **kwargs)
    return wrapper

                              
@simple_decorator
def lockModel(func):
    def wrapper(self, *args, **kwargs):
        self.setSavingModel(True)
        res=func(self, *args, **kwargs)
        self.setSavingModel(False)
        return res
    return wrapper

                                               
@simple_decorator
def save(func):
    def wrapper(self, *args, **kwargs):
        func(self, *args, **kwargs)
        WorkspacePersister.save(self)
    return wrapper


@simple_decorator
def trap_timeout(func):
    def wrapper(self, *args, **kwargs):
        try:
            if self._lostConnection:
                WorkspacePersister.addPendingAction(self, func, args, kwargs)
            return func(self, *args, **kwargs)
        except restkit.errors.RequestError as req_error:
            self.lostConnectionResolv()
            WorkspacePersister.stopThreads()
            WorkspacePersister.addPendingAction(self, func, args, kwargs)
            WorkspacePersister.notifyPersisterConnectionLost()
            model.api.devlog("Operation [%s] timeout" % func.__name__)
            return func(self, *args, **kwargs)
    return wrapper


                                                 
@simple_decorator
def delete(func):
    def wrapper(self, *args, **kwargs):
        func(self, *args, **kwargs)
        WorkspacePersister.delete(self)
    return wrapper

########NEW FILE########
__FILENAME__ = error_report
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
"""
This module will help us to retrieve information
about the app state and system information and
report it to developers to be able to get information about
a crash or bug
"""
import sys
import traceback
import threading
import model.guiapi
from cStringIO import StringIO
from gui.customevents import ShowExceptionCustomEvent
from gui.customevents import EXCEPTION_ID
from config.configuration import getInstanceConfiguration
import json
import time

CONF = getInstanceConfiguration()



def get_crash_log():
    pass

def get_system_info():
    pass


def exception_handler(type, value, tb):
    """
    This is a custom exception handler to replace the python original one.
    The idea is to show the user a dialog with the information and let him/her
    decide wether to send the developers a report with additional info.
    The report is created and sent using the callback.
    Since this handler may be called from threads, the dialog must be created
    using qt custom events to avoid issues.
    """
    import requests
    import hashlib
    import platform
    from pip.commands import freeze

    text = StringIO()
    traceback.print_exception(type, value, tb, file=text)
     
                          

        
    excepts = """
    Traceback: %s
    """ % (text.getvalue() )

    exception_hash = hashlib.sha256(excepts).hexdigest()
    os_dist = " ".join(platform.dist())
    python_version = platform.python_version()
    modules_info = ",".join([ "%s=%s" % (x.key, x.version) 
                        for x in freeze.get_installed_distributions()])

    python_dist = "Python %s \n Modules: [ %s ]" % (python_version, modules_info)

    description = """
    Exception: %s
    Identifier: %s
    Versions: OS: %s, 
              Python Versions: %s
    """ % (excepts, exception_hash, os_dist, python_dist)
        


    event = ShowExceptionCustomEvent(description, reportToDevelopers)
    model.guiapi.postCustomEvent(event)
    text.seek(0)
    text.truncate()
    del text

                      
                                             
                                                                                                   
                                                                                                


def reportToDevelopers(self, *description):
    try:
        import requests
        import hashlib
        import platform
        from pip.commands import freeze

        uri = CONF.getTktPostUri()
        headers = json.loads(CONF.getApiParams())
        params = json.loads(CONF.getApiParams())

        params['description'] = description[0]
        params['summary'] = 'autoreport %s' % time.time()

        resp = requests.post(uri, 
                            headers = headers,
                            data = params, timeout = 1, verify=True)
        model.api.devlog("Report sent it to faraday server")
    except Exception as e: 
        model.api.devlog("Error reporting to developers:")
        model.api.devlog(e)

def installThreadExcepthook():
    """
    Workaround for sys.excepthook thread bug from
    http://spyced.blogspot.com/2007/06/workaround-for-sysexcepthook-bug.html
    (https://sourceforge.net/tracker/?func=detail&atid=105470&aid=1230540&group_id=5470).
    Call once from __main__ before creating any threads.
    If using psyco, call psyco.cannotcompile(threading.Thread.run)
    since this replaces a new-style class method.
    """
    init_old = threading.Thread.__init__
    def init(self, *args, **kwargs):
        init_old(self, *args, **kwargs)
        run_old = self.run
        def run_with_except_hook(*args, **kw):
            try:
                run_old(*args, **kw)
            except (KeyboardInterrupt, SystemExit):
                raise
            except Exception:
                sys.excepthook(*sys.exc_info())
        self.run = run_with_except_hook
    threading.Thread.__init__ = init

########NEW FILE########
__FILENAME__ = ipython_shell
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
"""
This module contains some useful functions to embedd an IPython shell.
This allows to interactively test things.
TODO: create a QT Widget capable of running the IPython shell whitout
blocking the entire app. Kind of the http://ipython.scipy.org/moin/Cookbook/EmbeddingInGTK
"""

import traceback
import model.api

IPYTHON_BANNER = "\n".join(["-"*45,
                          "Starting embedded IPython Shell...",
                          "Press CTRL + D to exit.",
                          "-"*45])

IPYTHON_EXIT_MSG = "\n".join(["-"*45,
                          "Exiting IPython Shell...",
                          "Returning normal execution.",
                          "-"*45])

__ipython_active = False

                                                               
                                                                           

def embedd_ipython011(local_ns={}, global_ns={}):
    from IPython.config.loader import Config
    from IPython.frontend.terminal.embed import InteractiveShellEmbed
    cfg = Config()    
    ipshell = InteractiveShellEmbed(config=cfg,
                                    banner1 = IPYTHON_BANNER,
                                    exit_msg = IPYTHON_EXIT_MSG)
                         
    ipshell(local_ns=local_ns, global_ns=global_ns)


def embedd_ipython010(local_ns={}, global_ns={}):
    from IPython.Shell import IPShellEmbed
    ipshell = IPShellEmbed( [""],
                            banner = IPYTHON_BANNER,
                            exit_msg = IPYTHON_EXIT_MSG
                          )
    ipshell(local_ns=local_ns, global_ns=global_ns)
    

def embedd(local_ns={}, global_ns={}):
    global __ipython_active
    if __ipython_active:
        return

    __ipython_active = True
    try:
        import IPython
        version = IPython.__version__.split(".")[1]
        if int(version) > 10:
            embedd_ipython011(local_ns, global_ns)
        else:
            embedd_ipython010(local_ns, global_ns)
            
    except Exception, e:
        msg = "An error ocurred while trying to embedd the IPython Shell\n%s"
        model.api.log(msg % str(e), "ERROR")
        model.api.devlog(msg % traceback.format_exc())
    finally:
        __ipython_active = False


def embeddQT(local_ns={}, global_ns={}):
                                             

    global __ipython_active
    if __ipython_active:
        return
    __ipython_active = True
    try:
        from IPython.Shell import IPShellQt
        ipshell = IPShellQt( [""],
                                user_ns=local_ns,
                                user_global_ns=global_ns
                              )
        ipshell.run()
    except Exception:
        model.api.devlog("An error ocurred while trying to embedd the IPython Shell\n%s" % traceback.format_exc())
    finally:
        __ipython_active = False

########NEW FILE########
__FILENAME__ = logs
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
import logging
import logging.config


logging.config.fileConfig('utils/log.conf')

def getLogger(obj):
    # create logger
    logger = logging.getLogger(obj.__class__.__name__)
    return logger


########NEW FILE########
__FILENAME__ = pickled_dict
#!/usr/bin/env python

'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
'''
File: pickled_dict.py
Author: Daniel J. Foguelman
Description: A persist-to-disk picklebased dictionary with all the normal features.
'''

import cPickle as pickle
import IPython
import os
import threading
import unittest

class PickleBackedDict(dict): 
    def __init__(self, path, filename = None):
        self.path = os.path.join(path, filename) if not filename is None else path
        self.lock = threading.Lock()
        if os.path.exists(self.path):
            with open(self.path, 'rb') as f:
                self.dict = pickle.load(f)
        else:
            self.dict = {}

    def cleanUp(self):
        with self.lock:
            with open(self.path, 'wb', 0) as writer:
                self.dict = {}
                pickle.dump(self.dict, writer)


    def __setitem__(self, key, value):
        with self.lock:
            with open(self.path, 'wb', 0) as writer:
                self.dict.__setitem__(key, value)
                pickle.dump(self.dict, writer)

    def __getitem__(self, key):
        return self.dict.__getitem__(key)

    def __repr__(self):
        return self.dict.__repr__()

    def __str__(self):
        return self.dict.__str__()

class TestPickledDict(unittest.TestCase):
    def setUp(self):
        pass

    def tearDown(self):
        """docstring for tearDown"""
        pass

    def test_time_insert_and_retrieve(self):
        from time import time
        d_file = os.tmpfile()
        d = PickleBackedDict(path = d_file.name)

                                                   
        it = time() * 1000
        for i in range(10):
            d[i] = range(50) 
        et = time() * 1000

        self.assertTrue( et - it < 2500, "Inserting a millon records takes more than a 2.5sec")

        it = time() * 1000
        a = d[3]
        et = time() * 1000
        self.assertTrue( et - it < 500, "reading is a heavy task")

if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = plot_history
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''
'''
File: plot_history.py
Author: Dj Foguel
Description: This is a library to graph the MetadataHistoryObject. I'll produce a png until we have this feature attached to the UI.
Dependencies: pydot
'''
import sys
from os.path import join
from os import getcwd
sys.path.append(getcwd())

from model.hosts import Host, HostApplication, Interface, Service
from model.common import ModelObjectVuln, MetadataHistory
import model.controller as controller


def plot_graph():
    import pydot
                                                                                  

                                                                       


                                                                 

    edges_list = []
    metadata = MetadataHistory()

    for obj in ModelObjectIterator():
        history = metadata.getHistory(obj.getID())
        for i in range(len(history) - 1):
            f = lambda x: "%s -> %s" % (obj.getID(), x.update_controller_action)
            edge = (f(history[i]), f(history[i + 1]))
            edges_list.append(edge)

    graph = pydot.graph_from_edges(edges_list, directed=True)

    graph.write_png("/home/danito/.faraday/history.png")


class ModelObjectIterator(object):
    """This should solve the iteration problem over ModelObjects"""
    def __init__(self, **kwarg):
        self._to_visit = []
        self._visited = []
        self._model_controller = controller.ModelController()
        self._model_controller.setPersistDir(dir = "/home/danito/.faraday/persistence/Untitled")
        self._model_controller.loadPersistedData(full = True)
        all_hosts = self._model_controller.getAllHosts()

        self._to_visit.extend(all_hosts)

    def __iter__(self):
        return self

    def next(self):
        next_it = None
        try:
            next_it = self._to_visit.pop()
            if next_it in self._visited:
                raise IndexError("No double visit on ModelObject tree")
        except IndexError:
            raise StopIteration 

        self._visited.append(next_it)
        self._to_visit.extend(self._findFollowers(next_it))
        return next_it

    def _findFollowers(self, model_obj):
        followers = []
        cl_name = model_obj.__class__.__name__
        dispatch_methods = follows[cl_name] 

        for dm in dispatch_methods:
            followers.extend(dm(model_obj))

        return followers


follows = { "Host": [Host.getAllApplications, Host.getAllInterfaces, Host.getAllServices, Host.getVulns],
            "Interface": [Interface.getAllServices, Interface.getVulns],
            "HostApplication": [HostApplication.getAllServices, HostApplication.getVulns],
            "Service": [Service.getAllInterfaces, Service.getAllApplications, Service.getVulns]
            }


if __name__ == '__main__':
                                           

    plot_graph()

########NEW FILE########
__FILENAME__ = profilehooks
"""
Profiling hooks

This module contains a couple of decorators (`profile` and `coverage`) that
can be used to wrap functions and/or methods to produce profiles and line
coverage reports.  There's a third convenient decorator (`timecall`) that
measures the duration of function execution without the extra profiling
overhead.

Usage example (Python 2.4 or newer)::

    from profilehooks import profile, coverage

    @profile    # or @coverage
    def fn(n):
        if n < 2: return 1
        else: return n * fn(n-1)

    print fn(42)

Usage example (Python 2.3 or older)::

    from profilehooks import profile, coverage

    def fn(n):
        if n < 2: return 1
        else: return n * fn(n-1)

    # Now wrap that function in a decorator
    fn = profile(fn) # or coverage(fn)

    print fn(42)

Reports for all thusly decorated functions will be printed to sys.stdout
on program termination.  You can alternatively request for immediate
reports for each call by passing immediate=True to the profile decorator.

There's also a @timecall decorator for printing the time to sys.stderr
every time a function is called, when you just want to get a rough measure
instead of a detailed (but costly) profile.

Caveats

  A thread on python-dev convinced me that hotshot produces bogus numbers.
  See http://mail.python.org/pipermail/python-dev/2005-November/058264.html

  I don't know what will happen if a decorated function will try to call
  another decorated function.  All decorators probably need to explicitly
  support nested profiling (currently TraceFuncCoverage is the only one
  that supports this, while HotShotFuncProfile has support for recursive
  functions.)

  Profiling with hotshot creates temporary files (*.prof for profiling,
  *.cprof for coverage) in the current directory.  These files are not
  cleaned up.  Exception: when you specify a filename to the profile
  decorator (to store the pstats.Stats object for later inspection),
  the temporary file will be the filename you specified with '.raw'
  appended at the end.

  Coverage analysis with hotshot seems to miss some executions resulting
  in lower line counts and some lines errorneously marked as never
  executed.  For this reason coverage analysis now uses trace.py which is
  slower, but more accurate.

Copyright (c) 2004--2008 Marius Gedminas <marius@pov.lt>
Copyright (c) 2007 Hanno Schlichting
Copyright (c) 2008 Florian Schulze

Released under the MIT licence since December 2006:

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.

(Previously it was distributed under the GNU General Public Licence.)
"""
      

__author__ = "Marius Gedminas (marius@gedmin.as)"
__copyright__ = "Copyright 2004-2009 Marius Gedminas"
__license__ = "MIT"
__version__ = "1.4"
__date__ = "2009-03-31"


import atexit
import inspect
import sys
import re

               
from profile import Profile
import pstats

                                     
try:
    import hotshot
    import hotshot.stats
except ImportError:
    hotshot = None

                       
import trace

                                                                         
if hotshot is not None:
    import _hotshot
    import hotshot.log

                               
try:
    import cProfile
except ImportError:
    cProfile = None

              
import time


                                 
AVAILABLE_PROFILERS = {}


def profile(fn=None, skip=0, filename=None, immediate=False, dirs=False,
            sort=None, entries=40,
            profiler=('cProfile', 'profile', 'hotshot')):
    """Mark `fn` for profiling.

    If `skip` is > 0, first `skip` calls to `fn` will not be profiled.

    If `immediate` is False, profiling results will be printed to
    sys.stdout on program termination.  Otherwise results will be printed
    after each call.

    If `dirs` is False only the name of the file will be printed.
    Otherwise the full path is used.

    `sort` can be a list of sort keys (defaulting to ['cumulative',
    'time', 'calls']).  The following ones are recognized::

        'calls'      -- call count
        'cumulative' -- cumulative time
        'file'       -- file name
        'line'       -- line number
        'module'     -- file name
        'name'       -- function name
        'nfl'        -- name/file/line
        'pcalls'     -- call count
        'stdname'    -- standard name
        'time'       -- internal time

    `entries` limits the output to the first N entries.

    `profiler` can be used to select the preferred profiler, or specify a
    sequence of them, in order of preference.  The default is ('cProfile'.
    'profile', 'hotshot').

    If `filename` is specified, the profile stats will be stored in the
    named file.  You can load them pstats.Stats(filename).

    Usage::

        def fn(...):
            ...
        fn = profile(fn, skip=1)

    If you are using Python 2.4, you should be able to use the decorator
    syntax::

        @profile(skip=3)
        def fn(...):
            ...

    or just ::

        @profile
        def fn(...):
            ...

    """
    if fn is None:                                                
        def decorator(fn):
            return profile(fn, skip=skip, filename=filename,
                           immediate=immediate, dirs=dirs,
                           sort=sort, entries=entries,
                           profiler=profiler)
        return decorator
                                            
    if isinstance(profiler, str):
        profiler = [profiler]
    for p in profiler:
        if p in AVAILABLE_PROFILERS:
            profiler_class = AVAILABLE_PROFILERS[p]
            break
    else:
        raise ValueError('only these profilers are available: %s'
                             % ', '.join(AVAILABLE_PROFILERS))
    fp = profiler_class(fn, skip=skip, filename=filename,
                        immediate=immediate, dirs=dirs,
                        sort=sort, entries=entries)
                                                                    
                                
                                                                            
                                                              
    def new_fn(*args, **kw):
        return fp(*args, **kw)
    new_fn.__doc__ = fn.__doc__
    new_fn.__name__ = fn.__name__
    new_fn.__dict__ = fn.__dict__
    new_fn.__module__ = fn.__module__
    return new_fn


def coverage(fn):
    """Mark `fn` for line coverage analysis.

    Results will be printed to sys.stdout on program termination.

    Usage::

        def fn(...):
            ...
        fn = coverage(fn)

    If you are using Python 2.4, you should be able to use the decorator
    syntax::

        @coverage
        def fn(...):
            ...

    """
    fp = TraceFuncCoverage(fn)                         
                                                                            
                                                              
    def new_fn(*args, **kw):
        return fp(*args, **kw)
    new_fn.__doc__ = fn.__doc__
    new_fn.__name__ = fn.__name__
    new_fn.__dict__ = fn.__dict__
    new_fn.__module__ = fn.__module__
    return new_fn


def coverage_with_hotshot(fn):
    """Mark `fn` for line coverage analysis.

    Uses the 'hotshot' module for fast coverage analysis.

    BUG: Produces inaccurate results.

    See the docstring of `coverage` for usage examples.
    """
    fp = HotShotFuncCoverage(fn)
                                                                            
                                                              
    def new_fn(*args, **kw):
        return fp(*args, **kw)
    new_fn.__doc__ = fn.__doc__
    new_fn.__name__ = fn.__name__
    new_fn.__dict__ = fn.__dict__
    new_fn.__module__ = fn.__module__
    return new_fn


class FuncProfile(object):
    """Profiler for a function (uses profile)."""

                                               
    in_profiler = False

    Profile = Profile

    def __init__(self, fn, skip=0, filename=None, immediate=False, dirs=False,
                 sort=None, entries=40):
        """Creates a profiler for a function.

        Every profiler has its own log file (the name of which is derived
        from the function name).

        FuncProfile registers an atexit handler that prints profiling
        information to sys.stderr when the program terminates.
        """
        self.fn = fn
        self.skip = skip
        self.filename = filename
        self.immediate = immediate
        self.dirs = dirs
        self.sort = sort or ('cumulative', 'time', 'calls')
        if isinstance(self.sort, str):
            self.sort = (self.sort, )
        self.entries = entries
        self.reset_stats()
        atexit.register(self.atexit)

    def __call__(self, *args, **kw):
        """Profile a singe call to the function."""
        self.ncalls += 1
        if self.skip > 0:
            self.skip -= 1
            self.skipped += 1
            return self.fn(*args, **kw)
        if FuncProfile.in_profiler:
                                    
            return self.fn(*args, **kw)
                                                                          
                              
        profiler = self.Profile()
        try:
            FuncProfile.in_profiler = True
            return profiler.runcall(self.fn, *args, **kw)
        finally:
            FuncProfile.in_profiler = False
            self.stats.add(profiler)
            if self.immediate:
                self.print_stats()
                self.reset_stats()

    def print_stats(self):
        """Print profile information to sys.stdout."""
        funcname = self.fn.__name__
        filename = self.fn.func_code.co_filename
        lineno = self.fn.func_code.co_firstlineno
        print
        print "*** PROFILER RESULTS ***"
        print "%s (%s:%s)" % (funcname, filename, lineno)
        print "function called %d times" % self.ncalls,
        if self.skipped:
            print "(%d calls not profiled)" % self.skipped
        else:
            print
        print
        stats = self.stats
        if self.filename:
            stats.dump_stats(self.filename)
        if not self.dirs:
            stats.strip_dirs()
        stats.sort_stats(*self.sort)
        stats.print_stats(self.entries)

    def reset_stats(self):
        """Reset accumulated profiler statistics."""
                                                                       
        self.stats = pstats.Stats(Profile())
        self.ncalls = 0
        self.skipped = 0

    def atexit(self):
        """Stop profiling and print profile information to sys.stdout.

        This function is registered as an atexit hook.
        """
        if not self.immediate:
            self.print_stats()


AVAILABLE_PROFILERS['profile'] = FuncProfile


if cProfile is not None:

    class CProfileFuncProfile(FuncProfile):
        """Profiler for a function (uses cProfile)."""

        Profile = cProfile.Profile

    AVAILABLE_PROFILERS['cProfile'] = CProfileFuncProfile


if hotshot is not None:

    class HotShotFuncProfile(object):
        """Profiler for a function (uses hotshot)."""

                                                   
        in_profiler = False

        def __init__(self, fn, skip=0, filename=None):
            """Creates a profiler for a function.

            Every profiler has its own log file (the name of which is derived
            from the function name).

            HotShotFuncProfile registers an atexit handler that prints
            profiling information to sys.stderr when the program terminates.

            The log file is not removed and remains there to clutter the
            current working directory.
            """
            self.fn = fn
            self.filename = filename
            if self.filename:
                self.logfilename = filename + ".raw"
            else:
                self.logfilename = fn.__name__ + ".prof"
            self.profiler = hotshot.Profile(self.logfilename)
            self.ncalls = 0
            self.skip = skip
            self.skipped = 0
            atexit.register(self.atexit)

        def __call__(self, *args, **kw):
            """Profile a singe call to the function."""
            self.ncalls += 1
            if self.skip > 0:
                self.skip -= 1
                self.skipped += 1
                return self.fn(*args, **kw)
            if HotShotFuncProfile.in_profiler:
                                        
                return self.fn(*args, **kw)
            try:
                HotShotFuncProfile.in_profiler = True
                return self.profiler.runcall(self.fn, *args, **kw)
            finally:
                HotShotFuncProfile.in_profiler = False

        def atexit(self):
            """Stop profiling and print profile information to sys.stderr.

            This function is registered as an atexit hook.
            """
            self.profiler.close()
            funcname = self.fn.__name__
            filename = self.fn.func_code.co_filename
            lineno = self.fn.func_code.co_firstlineno
            print
            print "*** PROFILER RESULTS ***"
            print "%s (%s:%s)" % (funcname, filename, lineno)
            print "function called %d times" % self.ncalls,
            if self.skipped:
                print "(%d calls not profiled)" % self.skipped
            else:
                print
            print
            stats = hotshot.stats.load(self.logfilename)
                                                                                   
                                                    
            if self.filename:
                stats.dump_stats(self.filename)
                                                  
            stats.strip_dirs()
            stats.sort_stats('cumulative', 'time', 'calls')
            stats.print_stats(40)

    AVAILABLE_PROFILERS['hotshot'] = HotShotFuncProfile


    class HotShotFuncCoverage:
        """Coverage analysis for a function (uses _hotshot).

        HotShot coverage is reportedly faster than trace.py, but it appears to
        have problems with exceptions; also line counts in coverage reports
        are generally lower from line counts produced by TraceFuncCoverage.
        Is this my bug, or is it a problem with _hotshot?
        """

        def __init__(self, fn):
            """Creates a profiler for a function.

            Every profiler has its own log file (the name of which is derived
            from the function name).

            HotShotFuncCoverage registers an atexit handler that prints
            profiling information to sys.stderr when the program terminates.

            The log file is not removed and remains there to clutter the
            current working directory.
            """
            self.fn = fn
            self.logfilename = fn.__name__ + ".cprof"
            self.profiler = _hotshot.coverage(self.logfilename)
            self.ncalls = 0
            atexit.register(self.atexit)

        def __call__(self, *args, **kw):
            """Profile a singe call to the function."""
            self.ncalls += 1
            return self.profiler.runcall(self.fn, args, kw)

        def atexit(self):
            """Stop profiling and print profile information to sys.stderr.

            This function is registered as an atexit hook.
            """
            self.profiler.close()
            funcname = self.fn.__name__
            filename = self.fn.func_code.co_filename
            lineno = self.fn.func_code.co_firstlineno
            print
            print "*** COVERAGE RESULTS ***"
            print "%s (%s:%s)" % (funcname, filename, lineno)
            print "function called %d times" % self.ncalls
            print
            fs = FuncSource(self.fn)
            reader = hotshot.log.LogReader(self.logfilename)
            for what, (filename, lineno, funcname), tdelta in reader:
                if filename != fs.filename:
                    continue
                if what == hotshot.log.LINE:
                    fs.mark(lineno)
                if what == hotshot.log.ENTER:
                                                                                 
                                                                                
                                                                                 
                                                                 
                    if lineno == fs.firstlineno:
                        lineno = fs.firstcodelineno
                    fs.mark(lineno)
            reader.close()
            print fs


class TraceFuncCoverage:
    """Coverage analysis for a function (uses trace module).

    HotShot coverage analysis is reportedly faster, but it appears to have
    problems with exceptions.
    """

                                                            
    tracer = trace.Trace(count=True, trace=False,
                         ignoredirs=[sys.prefix, sys.exec_prefix])

                                                    
    tracing = False

    def __init__(self, fn):
        """Creates a profiler for a function.

        Every profiler has its own log file (the name of which is derived
        from the function name).

        TraceFuncCoverage registers an atexit handler that prints
        profiling information to sys.stderr when the program terminates.

        The log file is not removed and remains there to clutter the
        current working directory.
        """
        self.fn = fn
        self.logfilename = fn.__name__ + ".cprof"
        self.ncalls = 0
        atexit.register(self.atexit)

    def __call__(self, *args, **kw):
        """Profile a singe call to the function."""
        self.ncalls += 1
        if TraceFuncCoverage.tracing:
            return self.fn(*args, **kw)
        try:
            TraceFuncCoverage.tracing = True
            return self.tracer.runfunc(self.fn, *args, **kw)
        finally:
            TraceFuncCoverage.tracing = False

    def atexit(self):
        """Stop profiling and print profile information to sys.stderr.

        This function is registered as an atexit hook.
        """
        funcname = self.fn.__name__
        filename = self.fn.func_code.co_filename
        lineno = self.fn.func_code.co_firstlineno
        print
        print "*** COVERAGE RESULTS ***"
        print "%s (%s:%s)" % (funcname, filename, lineno)
        print "function called %d times" % self.ncalls
        print
        fs = FuncSource(self.fn)
        for (filename, lineno), count in self.tracer.counts.items():
            if filename != fs.filename:
                continue
            fs.mark(lineno, count)
        print fs
        never_executed = fs.count_never_executed()
        if never_executed:
            print "%d lines were not executed." % never_executed


class FuncSource:
    """Source code annotator for a function."""

    blank_rx = re.compile(r"^\s*finally:\s*(#.*)?$")

    def __init__(self, fn):
        self.fn = fn
        self.filename = inspect.getsourcefile(fn)
        self.source, self.firstlineno = inspect.getsourcelines(fn)
        self.sourcelines = {}
        self.firstcodelineno = self.firstlineno
        self.find_source_lines()

    def find_source_lines(self):
        """Mark all executable source lines in fn as executed 0 times."""
        strs = trace.find_strings(self.filename)
        lines = trace.find_lines_from_code(self.fn.func_code, strs)
        self.firstcodelineno = sys.maxint
        for lineno in lines:
            self.firstcodelineno = min(self.firstcodelineno, lineno)
            self.sourcelines.setdefault(lineno, 0)
        if self.firstcodelineno == sys.maxint:
            self.firstcodelineno = self.firstlineno

    def mark(self, lineno, count=1):
        """Mark a given source line as executed count times.

        Multiple calls to mark for the same lineno add up.
        """
        self.sourcelines[lineno] = self.sourcelines.get(lineno, 0) + count

    def count_never_executed(self):
        """Count statements that were never executed."""
        lineno = self.firstlineno
        counter = 0
        for line in self.source:
            if self.sourcelines.get(lineno) == 0:
                if not self.blank_rx.match(line):
                    counter += 1
            lineno += 1
        return counter

    def __str__(self):
        """Return annotated source code for the function."""
        lines = []
        lineno = self.firstlineno
        for line in self.source:
            counter = self.sourcelines.get(lineno)
            if counter is None:
                prefix = ' ' * 7
            elif counter == 0:
                if self.blank_rx.match(line):
                    prefix = ' ' * 7
                else:
                    prefix = '>' * 6 + ' '
            else:
                prefix = '%5d: ' % counter
            lines.append(prefix + line)
            lineno += 1
        return ''.join(lines)


def timecall(fn=None, immediate=True):
    """Wrap `fn` and print its execution time.

    Example::

        @timecall
        def somefunc(x, y):
            time.sleep(x * y)

        somefunc(2, 3)

    will print the time taken by somefunc on every call.  If you want just
    a summary at program termination, use

        @timecall(immediate=False)

    """
    if fn is None:                                                 
        def decorator(fn):
            return timecall(fn, immediate=immediate)
        return decorator
                                             
    fp = FuncTimer(fn, immediate=immediate)
                                                                            
                                                              
    def new_fn(*args, **kw):
        return fp(*args, **kw)
    new_fn.__doc__ = fn.__doc__
    new_fn.__name__ = fn.__name__
    new_fn.__dict__ = fn.__dict__
    new_fn.__module__ = fn.__module__
    return new_fn


class FuncTimer(object):

    def __init__(self, fn, immediate):
        self.fn = fn
        self.ncalls = 0
        self.totaltime = 0
        self.immediate = immediate
        if not immediate:
            atexit.register(self.atexit)

    def __call__(self, *args, **kw):
        """Profile a singe call to the function."""
        fn = self.fn
        self.ncalls += 1
        try:
            start = time.time()
            return fn(*args, **kw)
        finally:
            duration = time.time() - start
            self.totaltime += duration
            if self.immediate:
                funcname = fn.__name__
                filename = fn.func_code.co_filename
                lineno = fn.func_code.co_firstlineno
                print >> sys.stderr, "\n  %s (%s:%s):\n    %.3f seconds\n" % (
                                        funcname, filename, lineno, duration)
    def atexit(self):
        if not self.ncalls:
            return
        funcname = self.fn.__name__
        filename = self.fn.func_code.co_filename
        lineno = self.fn.func_code.co_firstlineno
        print ("\n  %s (%s:%s):\n"
               "    %d calls, %.3f seconds (%.3f seconds per call)\n" % (
                                funcname, filename, lineno, self.ncalls,
                                self.totaltime, self.totaltime / self.ncalls))


########NEW FILE########
__FILENAME__ = plugin_controller_client
#!/usr/bin/env python
'''
Faraday Penetration Test IDE - Community Version
Copyright (C) 2013  Infobyte LLC (http://www.infobytesec.com/)
See the file 'doc/LICENSE' for the license information

'''

import json
import requests
import sys
import uuid
import os
import base64

#TODO: load output dir from faraday config
#check if output dir already exists, otherwise create it
file_path = os.path.realpath(__file__)
output_folder = "%s/output" % os.path.dirname(file_path)
if not os.path.exists(output_folder):
    os.mkdir(output_folder)

#TODO: Load this from faraday config
host = "127.0.0.1"
port = 9977

url_input = "http://%s:%d/cmd/input" % (host, port)
url_output = "http://%s:%d/cmd/output" % (host, port)
url_active_plugins = "http://%s:%d/cmd/active-plugins" % (host, port)
headers = {'Content-type': 'application/json', 'Accept': 'application/json'}


def send_cmd(cmd):
    data = {"cmd": cmd}
    new_cmd = cmd
    result = False
    try:
        response = requests.post(url_input,
                                 data=json.dumps(data),
                                 headers=headers)

        if response.status_code == 200:
            json_response = response.json()
            if "cmd" in json_response.keys():
                if json_response.get("cmd") is not None:
                    new_cmd = json_response.get("cmd")
            if "custom_output_file" in json_response.keys():
                output_file = json_response.get("custom_output_file")
                if output_file is None:
                    output_file = "%s/%s.output" % (output_folder, uuid.uuid4())
                    new_cmd += " >&1 > %s" % output_file

                new_cmd += " && python2 %s send_output %s \"%s\"" % (file_path, base64.b64encode(cmd), output_file)
        result = True
    except:
        new_cmd = cmd
    finally:
        print new_cmd
        return result


def send_output(cmd, output_file):
    output_file = open(output_file)
    output = output_file.read()
    data = {"cmd": base64.b64decode(cmd), "output": base64.b64encode(output)}
    response = requests.post(url_output,
                             data=json.dumps(data),
                             headers=headers)
    if response.status_code != 200:
        print "something wrong"
        print response.json()
        return True
    return False


def main(argv):
    if len(argv) < 3:
        sys.exit(0)

    action = argv[1]

    dispatcher = {'send_cmd': send_cmd, 'send_output': send_output}

    if action in dispatcher.keys():
        if len(argv[2:]) > 0:
            dispatcher[action](*argv[2:])

    #sys.exit(0)

if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
