__FILENAME__ = create_bootstrap_script
#!/usr/bin/env python
# coding: utf-8

"""
    Create/update the virtualenv bootstrap script BOOTSTRAP_SCRIPT from
    the BOOTSTRAP_SOURCE file.
"""

import os
import sys
import pprint

try:
    import virtualenv
except ImportError, err:
    print "Import error:", err
    print
    print "Please install virtualenv!"
    print "e.g.: easy_install virtualenv"
    print "More info:"
    print "http://pypi.python.org/pypi/virtualenv"
    print
    sys.exit(-1)

try:
    import pylucid_project
except ImportError, err:
    print "Import error:", err
    print
    print "Not running in activated virtualenv?"
    print
    sys.exit(-1)


PYLUCID_BASE_PATH = os.path.abspath(os.path.dirname(pylucid_project.__file__))

ROOT = os.path.dirname(os.path.abspath(__file__))
BOOTSTRAP_SCRIPT = os.path.join(ROOT, "pylucid-boot.py")
BOOTSTRAP_SOURCE = os.path.join(ROOT, "source-pylucid-boot.py")


def parse_requirements(filename):
    filepath = os.path.join(PYLUCID_BASE_PATH, "../requirements", filename)
    f = file(filepath, "r")
    entries = []
    for line in f:
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("-r"):
            recursive_filename = line.split("-r ")[1]
            entries += parse_requirements(recursive_filename)
            continue
        if line.startswith("-e"):
            url = line.split("-e ")[1]
            entries.append("--editable=%s" % url)
        else:
            entries.append(line)
    f.close()
    return entries

def requirements_definitions():
    content = []
    for filename in ("normal_installation.txt", "developer_installation.txt"):
        content.append("\n# requirements from %s" % filename)
        requirements_list = parse_requirements(filename)

        req_type = os.path.splitext(filename)[0].upper()
        content.append(
            "%s = %s" % (req_type, pprint.pformat(requirements_list))
        )

    return "\n".join(content)


def create_bootstrap_script():
    content = ""

    content += requirements_definitions()

    info = "source bootstrap script: %r" % BOOTSTRAP_SOURCE
    print "read", info
    content += "\n\n# %s\n" % info
    f = file(BOOTSTRAP_SOURCE, "r")
    content += f.read()
    f.close()

    print "Create/Update %r" % BOOTSTRAP_SCRIPT

    output = virtualenv.create_bootstrap_script(content)

    # Add info lines
    output_lines = output.splitlines()
    generator_filepath = "/PyLucid_env/" + __file__.split("/PyLucid_env/")[1]
    output_lines.insert(2, "## Generated with %r" % generator_filepath)
    output_lines.insert(2, "## using: %r v%s" % (virtualenv.__file__, virtualenv.virtualenv_version))
    output_lines.insert(2, "## python v%s" % sys.version.replace("\n", " "))
    output = "\n".join(output_lines)
    #print output

    f = file(BOOTSTRAP_SCRIPT, 'w')
    f.write(output)
    f.close()


if __name__ == "__main__":
    create_bootstrap_script()
    print " -- END -- "

########NEW FILE########
__FILENAME__ = create_standalone_package
#!/usr/bin/env python
# coding: utf-8

"""
    Create from a existing Pylucid virtual environment a standalone package.
"""

import os
import sys
import shutil
import optparse
import warnings
import subprocess
import pkg_resources
import time
import codecs
import random


__version__ = (0, 2, 1)


#------------------------------------------------------------------------------


VERSION_STRING = '.'.join(str(part) for part in __version__)


#GET_GIT_VER_VERBOSE = True
GET_GIT_VER_VERBOSE = False

def _error(msg):
    if GET_GIT_VER_VERBOSE:
        warnings.warn(msg)
    return ""

def get_commit_timestamp(path=None):
    if path is None:
        path = os.path.abspath(os.path.dirname(__file__))

    try:
        process = subprocess.Popen(
            # %ct: committer date, UNIX timestamp  
            ["/usr/bin/git", "log", "--pretty=format:%ct", "-1", "HEAD"],
            shell=False, cwd=path,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE,
        )
    except Exception, err:
        return _error("Can't get git hash: %s" % err)

    process.wait()
    returncode = process.returncode
    if returncode != 0:
        return _error(
            "Can't get git hash, returncode was: %r"
            " - git stdout: %r"
            " - git stderr: %r"
            % (returncode, process.stdout.readline(), process.stderr.readline())
        )

    output = process.stdout.readline().strip()
    try:
        timestamp = int(output)
    except Exception, err:
        return _error("git log output is not a number, output was: %r" % output)

    try:
        return time.strftime(".%m%d", time.gmtime(timestamp))
    except Exception, err:
        return _error("can't convert %r to time string: %s" % (timestamp, err))


VERSION_STRING += get_commit_timestamp()


#------------------------------------------------------------------------------


USAGE = """
%prog [OPTIONS] PYLUCID_ENV_DIR DEST
"""

COPYTREE_IGNORE_FILES = (
    '*.pyc', 'tmp*', '.tmp*', "*~",
    "local_settings.py", "*.db3",
    "*.pth", "*.egg", "*.egg-link", "*.egg-info",
    "AUTHORS", "INSTALL", "README.*", "LICENSE", "MANIFEST.in", "setup.*"
)
COPYTREE_IGNORE_DIRS = (
    "dist", "build", "bootstrap", "docs", "extras", "pip", "tests", "scripts",
)

KEEP_ROOT_FILES = (
    "feedparser.py",
)

EXECUTEABLE_FILES = (
    "index.cgi", "index.fcgi", "index.wsgi",
    "install_pylucid.cgi",
    "manage.py",
)

SCRIPT_PATCH_DATA = (
    ('os.environ["VIRTUALENV_FILE"] = ', '# Not needed in standalone package!\n# os.environ["VIRTUALENV_FILE"] = '),
    ('    activate_virtualenv()', '    # Not needed in standalone package!\n    # activate_virtualenv()'),
)

PKG_CHECK_CONTENT = """
# overwritten by %s
# original file can be found here:
# http://github.com/jedie/PyLucid/blob/master/pylucid_project/apps/pylucid/__init__.py
"""

PROJECT_INIT_FILE = '''# coding: utf-8
"""
    PyLucid version string
    ~~~~~~~~~~~~~~~~~~~~~~
    this file was generated with: %s
    original file can be found here:
    http://github.com/jedie/PyLucid/blob/master/pylucid_project/__init__.py
"""
__version__ = %s
VERSION_STRING = "%s"
'''



class CopyTreeError(Exception):
    pass

def copytree2(src, dst, ignore, ignore_path=None):
    """
    similar to shutil.copytree, except:
        + don't copy links as symlinks
        + create destination dir, only if not exist
        + ignore items starts with "." (e.g.: .svn, .git)
    """
    names = os.listdir(src)

    ignored_names = ignore(src, names)

    errors = []

    if not os.path.isdir(dst):
        try:
            os.makedirs(dst)
        except OSError, why:
            errors.extend((dst, str(why)))

    for name in names:
        if name in ignored_names:
            continue
        if name.startswith("."):
            continue
        srcname = os.path.join(src, name)
        dstname = os.path.join(dst, name)
        try:
            if os.path.isdir(srcname):
                if ignore_path and name in ignore_path:
                    continue
                copytree2(srcname, dstname, ignore, ignore_path)
            else:
                shutil.copy2(srcname, dstname)
#                print count, srcname
        except (IOError, os.error), why:
            errors.append((srcname, dstname, str(why)))
        # catch the Error from the recursive copytree so that we can
        # continue with other files
        except CopyTreeError, err:
            errors.extend(err.args[0])

    try:
        shutil.copystat(src, dst)
    except OSError, why:
        errors.extend((src, dst, str(why)))

    if errors:
        raise CopyTreeError(errors)


class ReqInfo(object):
    """
    Information witch paths we must copied.
    Get this information from pylucid's setup.py
    """
    def __init__(self, project_name):
        self.dists = pkg_resources.require(project_name)
        self.paths = self.get_paths()

    def get_paths(self):
        paths = []
        for dist in self.dists:
            path = dist.location
            if path not in paths:
                paths.append(path)
        return paths

    def debug(self):
        for dist in self.dists:
            print "_"*79
            print dist
            print "project_name..:", dist.project_name
            print "location......:", dist.location


class StandalonePackageMaker(object):
    def __init__(self, dest_dir):
        self.dest_dir = self._make_abspath(dest_dir)
        self.dest_package_dir = os.path.join(self.dest_dir, "PyLucid_standalone")

        env_path = os.environ.get("VIRTUAL_ENV")
        if env_path is None:
            print "Error: VIRTUAL_ENV not in environment!"
            print "Have you activate the virtualenv?"
            sys.exit(-1)
        if not os.path.isdir(env_path):
            print "Error: VIRTUAL_ENV path %r doesn't exist?!?!" % env_path
            sys.exit(-1)

        self.pylucid_env_dir = env_path
        self.pylucid_dir = os.path.join(self.pylucid_env_dir, "src", "pylucid")

        self.precheck()

        print "\nuse %r as source" % self.pylucid_env_dir
        print "create standalone package in %r\n" % self.dest_package_dir

        self.pylucid_version = self.get_pylucid_version()
        print "found: PyLucid v%s\n" % self.pylucid_version

        self.req = ReqInfo("pylucid")

        self.check_if_dest_exist()
        self.copy_packages()
        self.cleanup_dest_dir()
        self.create_local_settings()
        self.copy_standalone_script_files()
        self.patch_script_files()
        self.chmod()
        self.remove_pkg_check()
        self.hardcode_version_string()
        self.merge_static_files()

        print
        print "_" * 79
        print "Create 7zip and zip archive files in '%s' ?" % self.dest_dir
        print
        raw_input("(Press any key or abort with Strg-C)")

        archive_file_prefix = os.path.join(self.dest_dir,
            "PyLucid_standalone_%s" % self.pylucid_version.replace(".", "-")
        )
        self.create_archive(archive_file_prefix + ".7z", switches=["-t7z"])
        self.create_archive(archive_file_prefix + ".zip", switches=["-tzip"])

    def _make_abspath(self, path):
        path = os.path.expanduser(path)
        path = os.path.normpath(path)
        path = os.path.abspath(path)
        return path

    def precheck(self):
        if not os.path.isdir(self.pylucid_env_dir):
            print "Wrong PYLUCID_ENV_DIR: %r doesn't exist." % self.pylucid_env_dir
            sys.exit(3)

        test_file = os.path.join(self.pylucid_env_dir, "bin", "activate_this.py")
        if not os.path.isfile(test_file):
            print "Wrong PYLUCID_ENV_DIR: %r doesn't exist." % test_file
            sys.exit(3)

    def get_pylucid_version(self):
        process = subprocess.Popen(
           [os.path.join(self.pylucid_env_dir, "bin", "python"), "setup.py", "--version"],
           cwd=self.pylucid_dir, stdout=subprocess.PIPE
        )
        pylucid_version = process.stdout.readline().strip()
        return pylucid_version

    def check_if_dest_exist(self):
        if os.path.isdir(self.dest_package_dir):
            print "Error: destination dir %r exist!" % self.dest_package_dir
            if raw_input("Delete the entire directory tree? [y/n]").lower() not in ("y", "j"):
                print "Abort!"
                sys.exit(1)

            print "delete tree...",
            shutil.rmtree(self.dest_package_dir)
            print "OK"
            if os.path.isdir(self.dest_package_dir):
                raw_input("Path exist?!?!? continue? (Abort with Strg-C)")
        else:
            raw_input("continue? (Abort with Strg-C)")

    def _patch_file(self, filepath, patch_data):
        print "Patch file %r..." % filepath
        f = codecs.open(filepath, "r", encoding="utf-8")
        content = f.read()
        f.close()

        for placeholder, new_value in patch_data:
            if not placeholder in content:
                print "Warning: String %r not found in %r!" % (placeholder, filepath)
            else:
                content = content.replace(placeholder, new_value)

        f = codecs.open(filepath, "w", encoding="utf-8")
        f.write(content)
        f.close()

    def create_local_settings(self):
        print "_"*79
        print "Create local_settings.py file..."

        sourcepath = os.path.join(self.pylucid_dir, "scripts", "local_settings_example.py")
        destpath = os.path.join(self.dest_package_dir, "local_settings.py")

        print "copy %s -> %s" % (sourcepath, destpath)
        shutil.copy2(sourcepath, destpath)

        secret_key = ''.join(
            [random.choice('abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)') for i in range(50)]
        )
        patch_data = [
            (
                'STATIC_ROOT = "/var/www/YourSite/static/"',
                'STATIC_ROOT = os.path.join(os.getcwd(), "media")'
            ),
            (
                'SECRET_KEY = "add-a-secret-key"',
                'SECRET_KEY = "Please change this! %s"' % secret_key
            ),
        ]

        self._patch_file(destpath, patch_data)

    def copy_packages(self):
        for path in self.req.paths:
            print "_" * 79
            print "copy %s" % path

            if not os.path.isdir(path):
                print "Error: %r doesn't exist!" % path
                sys.exit(3)

            print "%s -> %s" % (path, self.dest_package_dir)
            try:
                copytree2(
                    path, self.dest_package_dir,
                    shutil.ignore_patterns(*COPYTREE_IGNORE_FILES),
                    ignore_path=COPYTREE_IGNORE_DIRS
                )
            except OSError, why:
                print "copytree2 error: %s" % why
            else:
                print "OK"

    def cleanup_dest_dir(self):
        print "_"*79
        print "Cleanup dest dir:"
        for filename in os.listdir(self.dest_package_dir):
            path = os.path.join(self.dest_package_dir, filename)
            if not os.path.isfile(path):
                continue
            if filename in KEEP_ROOT_FILES:
                continue
            print "remove: %r (%s)" % (filename, path)
            os.remove(path)

    def copy_standalone_script_files(self):
        print
        print "_" * 79
        print "copy standalone script files"

        def copy_files(scripts_sub_dir):
            src = os.path.join(self.pylucid_dir, "scripts", scripts_sub_dir)
            print "%s -> %s" % (src, self.dest_package_dir)
            try:
                copytree2(src, self.dest_package_dir, ignore=shutil.ignore_patterns(*COPYTREE_IGNORE_FILES))
            except OSError, why:
                print "copytree2 error: %s" % why
            else:
                print "OK"

        copy_files("apache_files")
        copy_files("standalone")

        old = os.path.join(self.dest_package_dir, "default.htaccess")
        new = os.path.join(self.dest_package_dir, ".htaccess")
        print "rename %r to %r" % (old, new)
        os.rename(old, new)

    def patch_script_files(self):
        print
        print "_" * 79
        print "patch script files"
        for filename in ("index.cgi", "index.fcgi", "index.wsgi"):
            filepath = os.path.join(self.dest_package_dir, filename)
            self._patch_file(filepath, SCRIPT_PATCH_DATA)

    def chmod(self):
        print
        print "_" * 79
        print "make files executeable"
        for filename in EXECUTEABLE_FILES:
            filepath = os.path.join(self.dest_package_dir, filename)
            print "chmod 0755 %s" % filepath
            os.chmod(filepath, 0755)

    def remove_pkg_check(self):
        """
        overwrite pylucid_project/apps/pylucid/__init__.py
        and remove pkg_resources.require() check.
        Because it can't work in standalone version
        """
        print
        print "_" * 79
        pylucid_app = os.path.join(self.dest_package_dir, "pylucid_project", "apps", "pylucid")
        pylucid_app_init = os.path.join(pylucid_app, "__init__.py")
        print "Remove pkg_resources.require() check, by overwrite:"
        print pylucid_app_init

        f = open(pylucid_app_init, 'w')
        f.write(PKG_CHECK_CONTENT % __file__)
        f.close()
        print "OK"

    def hardcode_version_string(self):
        """
        Overwrite pylucid version file pylucid_project/__init__.py
        and 'hardcode' complete version string
        """
        print
        print "_" * 79
        version_file = os.path.join(self.dest_package_dir, "pylucid_project", "__init__.py")
        print "'hardcode' PyLucid version string, by overwrite:"
        print version_file

        version_string2 = []
        for part in self.pylucid_version.split("."):
            if part.isdigit():
                part = int(part)
            version_string2.append(part)
        version_string2 = repr(tuple(version_string2))

        f = open(version_file, "w")
        f.write(PROJECT_INIT_FILE % (__file__, version_string2, self.pylucid_version))
        f.close()
        print "OK"

    def cleanup_external_plugins(self):
        print
        print "_" * 79
        print "cleanup external_plugins directory"
        external_plugins = os.path.join(self.dest_package_dir, "pylucid_project", "external_plugins")
        for dir_item in os.listdir(external_plugins):
            if dir_item == "__init__.py":
                continue
            full_path = os.path.join(external_plugins, dir_item)
            print "remove %r..." % full_path,
            shutil.rmtree(full_path)
            print "OK"

    def merge_static_files(self):
        print "_" * 79
        print "move PyLucid/Django static media files together"
        dest_media = os.path.join(self.dest_package_dir, "media")

        pylucid_src_media = os.path.join(self.dest_package_dir, "pylucid_project", "media")
        pylucid_dst_media = os.path.join(dest_media)
        print "move files from %s to %s" % (pylucid_src_media, pylucid_dst_media)
        shutil.move(pylucid_src_media, pylucid_dst_media)
        print "OK"

        django_src_media = os.path.join(self.dest_package_dir, "django", "contrib", "admin", "media")
        django_dst_media = os.path.join(dest_media, "django")
        print "move files from %s to %s" % (django_src_media, django_dst_media)
        shutil.move(django_src_media, django_dst_media)
        print "OK"

    def create_archive(self, archive_file, switches):
        """
        create standalone package archive with 7zip
        needed package is: p7zip-full
        
        FIXME: Can't create a windows exe file with -sfx7z.sfx
        because 7z.sfx doesn't exist in linux version of 7zip :(
        """
        assert isinstance(switches, list)
        if os.path.isfile(archive_file):
            # Delete old archive, otherwise 7zip add new files
            os.remove(archive_file)

        seven_zip = "/usr/bin/7z"
        cmd = [seven_zip, "a", "-mx9"] + switches + [archive_file, self.dest_package_dir]
        print "run:\n%s" % " ".join(cmd)
        try:
            process = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        except OSError, err:
            import errno
            if err.errno == errno.ENOENT: # No 2: No such file or directory
                print "Error: '%s' not found: %s" % (seven_zip, err)
                print "Please install it."
                print "e.g.: sudo aptitude install p7zip-full"
                sys.exit(2)
            raise

        while True:
            line = process.stdout.readline()
            if not line:
                break
            line = line.strip()
            if line.startswith("Compressing"):
                line = line[-79:]
                line += " " * (79 - len(line))
                sys.stdout.write('\r' + line)
            else:
                print line

        print "\n-- END --\n"




def main():
    parser = optparse.OptionParser(version=VERSION_STRING, usage=USAGE)
    options, args = parser.parse_args()

    if len(args) != 1:
        print(
            "You must give the destination path as command argument!"
            " (you gave %r)" % repr(args)[1:-1]
        )
        parser.print_help()
        sys.exit(2)

    dest_dir = args[0]
    StandalonePackageMaker(dest_dir)

    print "\n\nPyLucid standalone package created."



if __name__ == '__main__':
    main()

########NEW FILE########
__FILENAME__ = pylucid-boot
#!/usr/bin/env python
## WARNING: This file is generated
## python v2.7.4 (default, Apr 19 2013, 18:28:01)  [GCC 4.7.3]
## using: '/home/jens/PyLucid_env/local/lib/python2.7/site-packages/virtualenv.pyc' v1.9.1
## Generated with '/PyLucid_env/src/pylucid/bootstrap/create_bootstrap_script.py'
#!/usr/bin/env python
"""Create a "virtual" Python installation
"""

# If you change the version here, change it in setup.py
# and docs/conf.py as well.
__version__ = "1.9.1"  # following best practices
virtualenv_version = __version__  # legacy, again

import base64
import sys
import os
import codecs
import optparse
import re
import shutil
import logging
import tempfile
import zlib
import errno
import glob
import distutils.sysconfig
from distutils.util import strtobool
import struct
import subprocess

if sys.version_info < (2, 5):
    print('ERROR: %s' % sys.exc_info()[1])
    print('ERROR: this script requires Python 2.5 or greater.')
    sys.exit(101)

try:
    set
except NameError:
    from sets import Set as set
try:
    basestring
except NameError:
    basestring = str

try:
    import ConfigParser
except ImportError:
    import configparser as ConfigParser

join = os.path.join
py_version = 'python%s.%s' % (sys.version_info[0], sys.version_info[1])

is_jython = sys.platform.startswith('java')
is_pypy = hasattr(sys, 'pypy_version_info')
is_win = (sys.platform == 'win32')
is_cygwin = (sys.platform == 'cygwin')
is_darwin = (sys.platform == 'darwin')
abiflags = getattr(sys, 'abiflags', '')

user_dir = os.path.expanduser('~')
if is_win:
    default_storage_dir = os.path.join(user_dir, 'virtualenv')
else:
    default_storage_dir = os.path.join(user_dir, '.virtualenv')
default_config_file = os.path.join(default_storage_dir, 'virtualenv.ini')

if is_pypy:
    expected_exe = 'pypy'
elif is_jython:
    expected_exe = 'jython'
else:
    expected_exe = 'python'


REQUIRED_MODULES = ['os', 'posix', 'posixpath', 'nt', 'ntpath', 'genericpath',
                    'fnmatch', 'locale', 'encodings', 'codecs',
                    'stat', 'UserDict', 'readline', 'copy_reg', 'types',
                    're', 'sre', 'sre_parse', 'sre_constants', 'sre_compile',
                    'zlib']

REQUIRED_FILES = ['lib-dynload', 'config']

majver, minver = sys.version_info[:2]
if majver == 2:
    if minver >= 6:
        REQUIRED_MODULES.extend(['warnings', 'linecache', '_abcoll', 'abc'])
    if minver >= 7:
        REQUIRED_MODULES.extend(['_weakrefset'])
    if minver <= 3:
        REQUIRED_MODULES.extend(['sets', '__future__'])
elif majver == 3:
    # Some extra modules are needed for Python 3, but different ones
    # for different versions.
    REQUIRED_MODULES.extend(['_abcoll', 'warnings', 'linecache', 'abc', 'io',
                             '_weakrefset', 'copyreg', 'tempfile', 'random',
                             '__future__', 'collections', 'keyword', 'tarfile',
                             'shutil', 'struct', 'copy', 'tokenize', 'token',
                             'functools', 'heapq', 'bisect', 'weakref',
                             'reprlib'])
    if minver >= 2:
        REQUIRED_FILES[-1] = 'config-%s' % majver
    if minver == 3:
        import sysconfig
        platdir = sysconfig.get_config_var('PLATDIR')
        REQUIRED_FILES.append(platdir)
        # The whole list of 3.3 modules is reproduced below - the current
        # uncommented ones are required for 3.3 as of now, but more may be
        # added as 3.3 development continues.
        REQUIRED_MODULES.extend([
            #"aifc",
            #"antigravity",
            #"argparse",
            #"ast",
            #"asynchat",
            #"asyncore",
            "base64",
            #"bdb",
            #"binhex",
            #"bisect",
            #"calendar",
            #"cgi",
            #"cgitb",
            #"chunk",
            #"cmd",
            #"codeop",
            #"code",
            #"colorsys",
            #"_compat_pickle",
            #"compileall",
            #"concurrent",
            #"configparser",
            #"contextlib",
            #"cProfile",
            #"crypt",
            #"csv",
            #"ctypes",
            #"curses",
            #"datetime",
            #"dbm",
            #"decimal",
            #"difflib",
            #"dis",
            #"doctest",
            #"dummy_threading",
            "_dummy_thread",
            #"email",
            #"filecmp",
            #"fileinput",
            #"formatter",
            #"fractions",
            #"ftplib",
            #"functools",
            #"getopt",
            #"getpass",
            #"gettext",
            #"glob",
            #"gzip",
            "hashlib",
            #"heapq",
            "hmac",
            #"html",
            #"http",
            #"idlelib",
            #"imaplib",
            #"imghdr",
            "imp",
            "importlib",
            #"inspect",
            #"json",
            #"lib2to3",
            #"logging",
            #"macpath",
            #"macurl2path",
            #"mailbox",
            #"mailcap",
            #"_markupbase",
            #"mimetypes",
            #"modulefinder",
            #"multiprocessing",
            #"netrc",
            #"nntplib",
            #"nturl2path",
            #"numbers",
            #"opcode",
            #"optparse",
            #"os2emxpath",
            #"pdb",
            #"pickle",
            #"pickletools",
            #"pipes",
            #"pkgutil",
            #"platform",
            #"plat-linux2",
            #"plistlib",
            #"poplib",
            #"pprint",
            #"profile",
            #"pstats",
            #"pty",
            #"pyclbr",
            #"py_compile",
            #"pydoc_data",
            #"pydoc",
            #"_pyio",
            #"queue",
            #"quopri",
            #"reprlib",
            "rlcompleter",
            #"runpy",
            #"sched",
            #"shelve",
            #"shlex",
            #"smtpd",
            #"smtplib",
            #"sndhdr",
            #"socket",
            #"socketserver",
            #"sqlite3",
            #"ssl",
            #"stringprep",
            #"string",
            #"_strptime",
            #"subprocess",
            #"sunau",
            #"symbol",
            #"symtable",
            #"sysconfig",
            #"tabnanny",
            #"telnetlib",
            #"test",
            #"textwrap",
            #"this",
            #"_threading_local",
            #"threading",
            #"timeit",
            #"tkinter",
            #"tokenize",
            #"token",
            #"traceback",
            #"trace",
            #"tty",
            #"turtledemo",
            #"turtle",
            #"unittest",
            #"urllib",
            #"uuid",
            #"uu",
            #"wave",
            #"weakref",
            #"webbrowser",
            #"wsgiref",
            #"xdrlib",
            #"xml",
            #"xmlrpc",
            #"zipfile",
        ])

if is_pypy:
    # these are needed to correctly display the exceptions that may happen
    # during the bootstrap
    REQUIRED_MODULES.extend(['traceback', 'linecache'])

class Logger(object):

    """
    Logging object for use in command-line script.  Allows ranges of
    levels, to avoid some redundancy of displayed information.
    """

    DEBUG = logging.DEBUG
    INFO = logging.INFO
    NOTIFY = (logging.INFO+logging.WARN)/2
    WARN = WARNING = logging.WARN
    ERROR = logging.ERROR
    FATAL = logging.FATAL

    LEVELS = [DEBUG, INFO, NOTIFY, WARN, ERROR, FATAL]

    def __init__(self, consumers):
        self.consumers = consumers
        self.indent = 0
        self.in_progress = None
        self.in_progress_hanging = False

    def debug(self, msg, *args, **kw):
        self.log(self.DEBUG, msg, *args, **kw)
    def info(self, msg, *args, **kw):
        self.log(self.INFO, msg, *args, **kw)
    def notify(self, msg, *args, **kw):
        self.log(self.NOTIFY, msg, *args, **kw)
    def warn(self, msg, *args, **kw):
        self.log(self.WARN, msg, *args, **kw)
    def error(self, msg, *args, **kw):
        self.log(self.ERROR, msg, *args, **kw)
    def fatal(self, msg, *args, **kw):
        self.log(self.FATAL, msg, *args, **kw)
    def log(self, level, msg, *args, **kw):
        if args:
            if kw:
                raise TypeError(
                    "You may give positional or keyword arguments, not both")
        args = args or kw
        rendered = None
        for consumer_level, consumer in self.consumers:
            if self.level_matches(level, consumer_level):
                if (self.in_progress_hanging
                    and consumer in (sys.stdout, sys.stderr)):
                    self.in_progress_hanging = False
                    sys.stdout.write('\n')
                    sys.stdout.flush()
                if rendered is None:
                    if args:
                        rendered = msg % args
                    else:
                        rendered = msg
                    rendered = ' '*self.indent + rendered
                if hasattr(consumer, 'write'):
                    consumer.write(rendered+'\n')
                else:
                    consumer(rendered)

    def start_progress(self, msg):
        assert not self.in_progress, (
            "Tried to start_progress(%r) while in_progress %r"
            % (msg, self.in_progress))
        if self.level_matches(self.NOTIFY, self._stdout_level()):
            sys.stdout.write(msg)
            sys.stdout.flush()
            self.in_progress_hanging = True
        else:
            self.in_progress_hanging = False
        self.in_progress = msg

    def end_progress(self, msg='done.'):
        assert self.in_progress, (
            "Tried to end_progress without start_progress")
        if self.stdout_level_matches(self.NOTIFY):
            if not self.in_progress_hanging:
                # Some message has been printed out since start_progress
                sys.stdout.write('...' + self.in_progress + msg + '\n')
                sys.stdout.flush()
            else:
                sys.stdout.write(msg + '\n')
                sys.stdout.flush()
        self.in_progress = None
        self.in_progress_hanging = False

    def show_progress(self):
        """If we are in a progress scope, and no log messages have been
        shown, write out another '.'"""
        if self.in_progress_hanging:
            sys.stdout.write('.')
            sys.stdout.flush()

    def stdout_level_matches(self, level):
        """Returns true if a message at this level will go to stdout"""
        return self.level_matches(level, self._stdout_level())

    def _stdout_level(self):
        """Returns the level that stdout runs at"""
        for level, consumer in self.consumers:
            if consumer is sys.stdout:
                return level
        return self.FATAL

    def level_matches(self, level, consumer_level):
        """
        >>> l = Logger([])
        >>> l.level_matches(3, 4)
        False
        >>> l.level_matches(3, 2)
        True
        >>> l.level_matches(slice(None, 3), 3)
        False
        >>> l.level_matches(slice(None, 3), 2)
        True
        >>> l.level_matches(slice(1, 3), 1)
        True
        >>> l.level_matches(slice(2, 3), 1)
        False
        """
        if isinstance(level, slice):
            start, stop = level.start, level.stop
            if start is not None and start > consumer_level:
                return False
            if stop is not None and stop <= consumer_level:
                return False
            return True
        else:
            return level >= consumer_level

    #@classmethod
    def level_for_integer(cls, level):
        levels = cls.LEVELS
        if level < 0:
            return levels[0]
        if level >= len(levels):
            return levels[-1]
        return levels[level]

    level_for_integer = classmethod(level_for_integer)

# create a silent logger just to prevent this from being undefined
# will be overridden with requested verbosity main() is called.
logger = Logger([(Logger.LEVELS[-1], sys.stdout)])

def mkdir(path):
    if not os.path.exists(path):
        logger.info('Creating %s', path)
        os.makedirs(path)
    else:
        logger.info('Directory %s already exists', path)

def copyfileordir(src, dest):
    if os.path.isdir(src):
        shutil.copytree(src, dest, True)
    else:
        shutil.copy2(src, dest)

def copyfile(src, dest, symlink=True):
    if not os.path.exists(src):
        # Some bad symlink in the src
        logger.warn('Cannot find file %s (bad symlink)', src)
        return
    if os.path.exists(dest):
        logger.debug('File %s already exists', dest)
        return
    if not os.path.exists(os.path.dirname(dest)):
        logger.info('Creating parent directories for %s' % os.path.dirname(dest))
        os.makedirs(os.path.dirname(dest))
    if not os.path.islink(src):
        srcpath = os.path.abspath(src)
    else:
        srcpath = os.readlink(src)
    if symlink and hasattr(os, 'symlink') and not is_win:
        logger.info('Symlinking %s', dest)
        try:
            os.symlink(srcpath, dest)
        except (OSError, NotImplementedError):
            logger.info('Symlinking failed, copying to %s', dest)
            copyfileordir(src, dest)
    else:
        logger.info('Copying to %s', dest)
        copyfileordir(src, dest)

def writefile(dest, content, overwrite=True):
    if not os.path.exists(dest):
        logger.info('Writing %s', dest)
        f = open(dest, 'wb')
        f.write(content.encode('utf-8'))
        f.close()
        return
    else:
        f = open(dest, 'rb')
        c = f.read()
        f.close()
        if c != content.encode("utf-8"):
            if not overwrite:
                logger.notify('File %s exists with different content; not overwriting', dest)
                return
            logger.notify('Overwriting %s with new content', dest)
            f = open(dest, 'wb')
            f.write(content.encode('utf-8'))
            f.close()
        else:
            logger.info('Content %s already in place', dest)

def rmtree(dir):
    if os.path.exists(dir):
        logger.notify('Deleting tree %s', dir)
        shutil.rmtree(dir)
    else:
        logger.info('Do not need to delete %s; already gone', dir)

def make_exe(fn):
    if hasattr(os, 'chmod'):
        oldmode = os.stat(fn).st_mode & 0xFFF # 0o7777
        newmode = (oldmode | 0x16D) & 0xFFF # 0o555, 0o7777
        os.chmod(fn, newmode)
        logger.info('Changed mode of %s to %s', fn, oct(newmode))

def _find_file(filename, dirs):
    for dir in reversed(dirs):
        files = glob.glob(os.path.join(dir, filename))
        if files and os.path.isfile(files[0]):
            return True, files[0]
    return False, filename

def _install_req(py_executable, unzip=False, distribute=False,
                 search_dirs=None, never_download=False):

    if search_dirs is None:
        search_dirs = file_search_dirs()

    if not distribute:
        egg_path = 'setuptools-*-py%s.egg' % sys.version[:3]
        found, egg_path = _find_file(egg_path, search_dirs)
        project_name = 'setuptools'
        bootstrap_script = EZ_SETUP_PY
        tgz_path = None
    else:
        # Look for a distribute egg (these are not distributed by default,
        # but can be made available by the user)
        egg_path = 'distribute-*-py%s.egg' % sys.version[:3]
        found, egg_path = _find_file(egg_path, search_dirs)
        project_name = 'distribute'
        if found:
            tgz_path = None
            bootstrap_script = DISTRIBUTE_FROM_EGG_PY
        else:
            # Fall back to sdist
            # NB: egg_path is not None iff tgz_path is None
            # iff bootstrap_script is a generic setup script accepting
            # the standard arguments.
            egg_path = None
            tgz_path = 'distribute-*.tar.gz'
            found, tgz_path = _find_file(tgz_path, search_dirs)
            bootstrap_script = DISTRIBUTE_SETUP_PY

    if is_jython and os._name == 'nt':
        # Jython's .bat sys.executable can't handle a command line
        # argument with newlines
        fd, ez_setup = tempfile.mkstemp('.py')
        os.write(fd, bootstrap_script)
        os.close(fd)
        cmd = [py_executable, ez_setup]
    else:
        cmd = [py_executable, '-c', bootstrap_script]
    if unzip and egg_path:
        cmd.append('--always-unzip')
    env = {}
    remove_from_env = ['__PYVENV_LAUNCHER__']
    if logger.stdout_level_matches(logger.DEBUG) and egg_path:
        cmd.append('-v')

    old_chdir = os.getcwd()
    if egg_path is not None and os.path.exists(egg_path):
        logger.info('Using existing %s egg: %s' % (project_name, egg_path))
        cmd.append(egg_path)
        if os.environ.get('PYTHONPATH'):
            env['PYTHONPATH'] = egg_path + os.path.pathsep + os.environ['PYTHONPATH']
        else:
            env['PYTHONPATH'] = egg_path
    elif tgz_path is not None and os.path.exists(tgz_path):
        # Found a tgz source dist, let's chdir
        logger.info('Using existing %s egg: %s' % (project_name, tgz_path))
        os.chdir(os.path.dirname(tgz_path))
        # in this case, we want to be sure that PYTHONPATH is unset (not
        # just empty, really unset), else CPython tries to import the
        # site.py that it's in virtualenv_support
        remove_from_env.append('PYTHONPATH')
    elif never_download:
        logger.fatal("Can't find any local distributions of %s to install "
                     "and --never-download is set.  Either re-run virtualenv "
                     "without the --never-download option, or place a %s "
                     "distribution (%s) in one of these "
                     "locations: %r" % (project_name, project_name,
                                        egg_path or tgz_path,
                                        search_dirs))
        sys.exit(1)
    elif egg_path:
        logger.info('No %s egg found; downloading' % project_name)
        cmd.extend(['--always-copy', '-U', project_name])
    else:
        logger.info('No %s tgz found; downloading' % project_name)
    logger.start_progress('Installing %s...' % project_name)
    logger.indent += 2
    cwd = None
    if project_name == 'distribute':
        env['DONT_PATCH_SETUPTOOLS'] = 'true'

    def _filter_ez_setup(line):
        return filter_ez_setup(line, project_name)

    if not os.access(os.getcwd(), os.W_OK):
        cwd = tempfile.mkdtemp()
        if tgz_path is not None and os.path.exists(tgz_path):
            # the current working dir is hostile, let's copy the
            # tarball to a temp dir
            target = os.path.join(cwd, os.path.split(tgz_path)[-1])
            shutil.copy(tgz_path, target)
    try:
        call_subprocess(cmd, show_stdout=False,
                        filter_stdout=_filter_ez_setup,
                        extra_env=env,
                        remove_from_env=remove_from_env,
                        cwd=cwd)
    finally:
        logger.indent -= 2
        logger.end_progress()
        if cwd is not None:
            shutil.rmtree(cwd)
        if os.getcwd() != old_chdir:
            os.chdir(old_chdir)
        if is_jython and os._name == 'nt':
            os.remove(ez_setup)

def file_search_dirs():
    here = os.path.dirname(os.path.abspath(__file__))
    dirs = ['.', here,
            join(here, 'virtualenv_support')]
    if os.path.splitext(os.path.dirname(__file__))[0] != 'virtualenv':
        # Probably some boot script; just in case virtualenv is installed...
        try:
            import virtualenv
        except ImportError:
            pass
        else:
            dirs.append(os.path.join(os.path.dirname(virtualenv.__file__), 'virtualenv_support'))
    return [d for d in dirs if os.path.isdir(d)]

def install_setuptools(py_executable, unzip=False,
                       search_dirs=None, never_download=False):
    _install_req(py_executable, unzip,
                 search_dirs=search_dirs, never_download=never_download)

def install_distribute(py_executable, unzip=False,
                       search_dirs=None, never_download=False):
    _install_req(py_executable, unzip, distribute=True,
                 search_dirs=search_dirs, never_download=never_download)

_pip_re = re.compile(r'^pip-.*(zip|tar.gz|tar.bz2|tgz|tbz)$', re.I)
def install_pip(py_executable, search_dirs=None, never_download=False):
    if search_dirs is None:
        search_dirs = file_search_dirs()

    filenames = []
    for dir in search_dirs:
        filenames.extend([join(dir, fn) for fn in os.listdir(dir)
                          if _pip_re.search(fn)])
    filenames = [(os.path.basename(filename).lower(), i, filename) for i, filename in enumerate(filenames)]
    filenames.sort()
    filenames = [filename for basename, i, filename in filenames]
    if not filenames:
        filename = 'pip'
    else:
        filename = filenames[-1]
    easy_install_script = 'easy_install'
    if is_win:
        easy_install_script = 'easy_install-script.py'
    # There's two subtle issues here when invoking easy_install.
    # 1. On unix-like systems the easy_install script can *only* be executed
    #    directly if its full filesystem path is no longer than 78 characters.
    # 2. A work around to [1] is to use the `python path/to/easy_install foo`
    #    pattern, but that breaks if the path contains non-ASCII characters, as
    #    you can't put the file encoding declaration before the shebang line.
    # The solution is to use Python's -x flag to skip the first line of the
    # script (and any ASCII decoding errors that may have occurred in that line)
    cmd = [py_executable, '-x', join(os.path.dirname(py_executable), easy_install_script), filename]
    # jython and pypy don't yet support -x
    if is_jython or is_pypy:
        cmd.remove('-x')
    if filename == 'pip':
        if never_download:
            logger.fatal("Can't find any local distributions of pip to install "
                         "and --never-download is set.  Either re-run virtualenv "
                         "without the --never-download option, or place a pip "
                         "source distribution (zip/tar.gz/tar.bz2) in one of these "
                         "locations: %r" % search_dirs)
            sys.exit(1)
        logger.info('Installing pip from network...')
    else:
        logger.info('Installing existing %s distribution: %s' % (
                os.path.basename(filename), filename))
    logger.start_progress('Installing pip...')
    logger.indent += 2
    def _filter_setup(line):
        return filter_ez_setup(line, 'pip')
    try:
        call_subprocess(cmd, show_stdout=False,
                        filter_stdout=_filter_setup)
    finally:
        logger.indent -= 2
        logger.end_progress()

def filter_ez_setup(line, project_name='setuptools'):
    if not line.strip():
        return Logger.DEBUG
    if project_name == 'distribute':
        for prefix in ('Extracting', 'Now working', 'Installing', 'Before',
                       'Scanning', 'Setuptools', 'Egg', 'Already',
                       'running', 'writing', 'reading', 'installing',
                       'creating', 'copying', 'byte-compiling', 'removing',
                       'Processing'):
            if line.startswith(prefix):
                return Logger.DEBUG
        return Logger.DEBUG
    for prefix in ['Reading ', 'Best match', 'Processing setuptools',
                   'Copying setuptools', 'Adding setuptools',
                   'Installing ', 'Installed ']:
        if line.startswith(prefix):
            return Logger.DEBUG
    return Logger.INFO


class UpdatingDefaultsHelpFormatter(optparse.IndentedHelpFormatter):
    """
    Custom help formatter for use in ConfigOptionParser that updates
    the defaults before expanding them, allowing them to show up correctly
    in the help listing
    """
    def expand_default(self, option):
        if self.parser is not None:
            self.parser.update_defaults(self.parser.defaults)
        return optparse.IndentedHelpFormatter.expand_default(self, option)


class ConfigOptionParser(optparse.OptionParser):
    """
    Custom option parser which updates its defaults by by checking the
    configuration files and environmental variables
    """
    def __init__(self, *args, **kwargs):
        self.config = ConfigParser.RawConfigParser()
        self.files = self.get_config_files()
        self.config.read(self.files)
        optparse.OptionParser.__init__(self, *args, **kwargs)

    def get_config_files(self):
        config_file = os.environ.get('VIRTUALENV_CONFIG_FILE', False)
        if config_file and os.path.exists(config_file):
            return [config_file]
        return [default_config_file]

    def update_defaults(self, defaults):
        """
        Updates the given defaults with values from the config files and
        the environ. Does a little special handling for certain types of
        options (lists).
        """
        # Then go and look for the other sources of configuration:
        config = {}
        # 1. config files
        config.update(dict(self.get_config_section('virtualenv')))
        # 2. environmental variables
        config.update(dict(self.get_environ_vars()))
        # Then set the options with those values
        for key, val in config.items():
            key = key.replace('_', '-')
            if not key.startswith('--'):
                key = '--%s' % key  # only prefer long opts
            option = self.get_option(key)
            if option is not None:
                # ignore empty values
                if not val:
                    continue
                # handle multiline configs
                if option.action == 'append':
                    val = val.split()
                else:
                    option.nargs = 1
                if option.action == 'store_false':
                    val = not strtobool(val)
                elif option.action in ('store_true', 'count'):
                    val = strtobool(val)
                try:
                    val = option.convert_value(key, val)
                except optparse.OptionValueError:
                    e = sys.exc_info()[1]
                    print("An error occured during configuration: %s" % e)
                    sys.exit(3)
                defaults[option.dest] = val
        return defaults

    def get_config_section(self, name):
        """
        Get a section of a configuration
        """
        if self.config.has_section(name):
            return self.config.items(name)
        return []

    def get_environ_vars(self, prefix='VIRTUALENV_'):
        """
        Returns a generator with all environmental vars with prefix VIRTUALENV
        """
        for key, val in os.environ.items():
            if key.startswith(prefix):
                yield (key.replace(prefix, '').lower(), val)

    def get_default_values(self):
        """
        Overridding to make updating the defaults after instantiation of
        the option parser possible, update_defaults() does the dirty work.
        """
        if not self.process_default_values:
            # Old, pre-Optik 1.5 behaviour.
            return optparse.Values(self.defaults)

        defaults = self.update_defaults(self.defaults.copy())  # ours
        for option in self._get_all_options():
            default = defaults.get(option.dest)
            if isinstance(default, basestring):
                opt_str = option.get_opt_string()
                defaults[option.dest] = option.check_value(opt_str, default)
        return optparse.Values(defaults)


def main():
    parser = ConfigOptionParser(
        version=virtualenv_version,
        usage="%prog [OPTIONS] DEST_DIR",
        formatter=UpdatingDefaultsHelpFormatter())

    parser.add_option(
        '-v', '--verbose',
        action='count',
        dest='verbose',
        default=0,
        help="Increase verbosity")

    parser.add_option(
        '-q', '--quiet',
        action='count',
        dest='quiet',
        default=0,
        help='Decrease verbosity')

    parser.add_option(
        '-p', '--python',
        dest='python',
        metavar='PYTHON_EXE',
        help='The Python interpreter to use, e.g., --python=python2.5 will use the python2.5 '
        'interpreter to create the new environment.  The default is the interpreter that '
        'virtualenv was installed with (%s)' % sys.executable)

    parser.add_option(
        '--clear',
        dest='clear',
        action='store_true',
        help="Clear out the non-root install and start from scratch")

    parser.set_defaults(system_site_packages=False)
    parser.add_option(
        '--no-site-packages',
        dest='system_site_packages',
        action='store_false',
        help="Don't give access to the global site-packages dir to the "
             "virtual environment (default)")

    parser.add_option(
        '--system-site-packages',
        dest='system_site_packages',
        action='store_true',
        help="Give access to the global site-packages dir to the "
             "virtual environment")

    parser.add_option(
        '--unzip-setuptools',
        dest='unzip_setuptools',
        action='store_true',
        help="Unzip Setuptools or Distribute when installing it")

    parser.add_option(
        '--relocatable',
        dest='relocatable',
        action='store_true',
        help='Make an EXISTING virtualenv environment relocatable.  '
        'This fixes up scripts and makes all .pth files relative')

    parser.add_option(
        '--distribute', '--use-distribute',  # the second option is for legacy reasons here. Hi Kenneth!
        dest='use_distribute',
        action='store_true',
        help='Use Distribute instead of Setuptools. Set environ variable '
        'VIRTUALENV_DISTRIBUTE to make it the default ')

    parser.add_option(
        '--no-setuptools',
        dest='no_setuptools',
        action='store_true',
        help='Do not install distribute/setuptools (or pip) '
        'in the new virtualenv.')

    parser.add_option(
        '--no-pip',
        dest='no_pip',
        action='store_true',
        help='Do not install pip in the new virtualenv.')

    parser.add_option(
        '--setuptools',
        dest='use_distribute',
        action='store_false',
        help='Use Setuptools instead of Distribute.  Set environ variable '
        'VIRTUALENV_SETUPTOOLS to make it the default ')

    # Set this to True to use distribute by default, even in Python 2.
    parser.set_defaults(use_distribute=False)

    default_search_dirs = file_search_dirs()
    parser.add_option(
        '--extra-search-dir',
        dest="search_dirs",
        action="append",
        default=default_search_dirs,
        help="Directory to look for setuptools/distribute/pip distributions in. "
        "You can add any number of additional --extra-search-dir paths.")

    parser.add_option(
        '--never-download',
        dest="never_download",
        action="store_true",
        help="Never download anything from the network.  Instead, virtualenv will fail "
        "if local distributions of setuptools/distribute/pip are not present.")

    parser.add_option(
        '--prompt',
        dest='prompt',
        help='Provides an alternative prompt prefix for this environment')

    if 'extend_parser' in globals():
        extend_parser(parser)

    options, args = parser.parse_args()

    global logger

    if 'adjust_options' in globals():
        adjust_options(options, args)

    verbosity = options.verbose - options.quiet
    logger = Logger([(Logger.level_for_integer(2 - verbosity), sys.stdout)])

    if options.python and not os.environ.get('VIRTUALENV_INTERPRETER_RUNNING'):
        env = os.environ.copy()
        interpreter = resolve_interpreter(options.python)
        if interpreter == sys.executable:
            logger.warn('Already using interpreter %s' % interpreter)
        else:
            logger.notify('Running virtualenv with interpreter %s' % interpreter)
            env['VIRTUALENV_INTERPRETER_RUNNING'] = 'true'
            file = __file__
            if file.endswith('.pyc'):
                file = file[:-1]
            popen = subprocess.Popen([interpreter, file] + sys.argv[1:], env=env)
            raise SystemExit(popen.wait())

    # Force --distribute on Python 3, since setuptools is not available.
    if majver > 2:
        options.use_distribute = True

    if os.environ.get('PYTHONDONTWRITEBYTECODE') and not options.use_distribute:
        print(
            "The PYTHONDONTWRITEBYTECODE environment variable is "
            "not compatible with setuptools. Either use --distribute "
            "or unset PYTHONDONTWRITEBYTECODE.")
        sys.exit(2)
    if not args:
        print('You must provide a DEST_DIR')
        parser.print_help()
        sys.exit(2)
    if len(args) > 1:
        print('There must be only one argument: DEST_DIR (you gave %s)' % (
            ' '.join(args)))
        parser.print_help()
        sys.exit(2)

    home_dir = args[0]

    if os.environ.get('WORKING_ENV'):
        logger.fatal('ERROR: you cannot run virtualenv while in a workingenv')
        logger.fatal('Please deactivate your workingenv, then re-run this script')
        sys.exit(3)

    if 'PYTHONHOME' in os.environ:
        logger.warn('PYTHONHOME is set.  You *must* activate the virtualenv before using it')
        del os.environ['PYTHONHOME']

    if options.relocatable:
        make_environment_relocatable(home_dir)
        return

    create_environment(home_dir,
                       site_packages=options.system_site_packages,
                       clear=options.clear,
                       unzip_setuptools=options.unzip_setuptools,
                       use_distribute=options.use_distribute,
                       prompt=options.prompt,
                       search_dirs=options.search_dirs,
                       never_download=options.never_download,
                       no_setuptools=options.no_setuptools,
                       no_pip=options.no_pip)
    if 'after_install' in globals():
        after_install(options, home_dir)

def call_subprocess(cmd, show_stdout=True,
                    filter_stdout=None, cwd=None,
                    raise_on_returncode=True, extra_env=None,
                    remove_from_env=None):
    cmd_parts = []
    for part in cmd:
        if len(part) > 45:
            part = part[:20]+"..."+part[-20:]
        if ' ' in part or '\n' in part or '"' in part or "'" in part:
            part = '"%s"' % part.replace('"', '\\"')
        if hasattr(part, 'decode'):
            try:
                part = part.decode(sys.getdefaultencoding())
            except UnicodeDecodeError:
                part = part.decode(sys.getfilesystemencoding())
        cmd_parts.append(part)
    cmd_desc = ' '.join(cmd_parts)
    if show_stdout:
        stdout = None
    else:
        stdout = subprocess.PIPE
    logger.debug("Running command %s" % cmd_desc)
    if extra_env or remove_from_env:
        env = os.environ.copy()
        if extra_env:
            env.update(extra_env)
        if remove_from_env:
            for varname in remove_from_env:
                env.pop(varname, None)
    else:
        env = None
    try:
        proc = subprocess.Popen(
            cmd, stderr=subprocess.STDOUT, stdin=None, stdout=stdout,
            cwd=cwd, env=env)
    except Exception:
        e = sys.exc_info()[1]
        logger.fatal(
            "Error %s while executing command %s" % (e, cmd_desc))
        raise
    all_output = []
    if stdout is not None:
        stdout = proc.stdout
        encoding = sys.getdefaultencoding()
        fs_encoding = sys.getfilesystemencoding()
        while 1:
            line = stdout.readline()
            try:
                line = line.decode(encoding)
            except UnicodeDecodeError:
                line = line.decode(fs_encoding)
            if not line:
                break
            line = line.rstrip()
            all_output.append(line)
            if filter_stdout:
                level = filter_stdout(line)
                if isinstance(level, tuple):
                    level, line = level
                logger.log(level, line)
                if not logger.stdout_level_matches(level):
                    logger.show_progress()
            else:
                logger.info(line)
    else:
        proc.communicate()
    proc.wait()
    if proc.returncode:
        if raise_on_returncode:
            if all_output:
                logger.notify('Complete output from command %s:' % cmd_desc)
                logger.notify('\n'.join(all_output) + '\n----------------------------------------')
            raise OSError(
                "Command %s failed with error code %s"
                % (cmd_desc, proc.returncode))
        else:
            logger.warn(
                "Command %s had error code %s"
                % (cmd_desc, proc.returncode))


def create_environment(home_dir, site_packages=False, clear=False,
                       unzip_setuptools=False, use_distribute=False,
                       prompt=None, search_dirs=None, never_download=False,
                       no_setuptools=False, no_pip=False):
    """
    Creates a new environment in ``home_dir``.

    If ``site_packages`` is true, then the global ``site-packages/``
    directory will be on the path.

    If ``clear`` is true (default False) then the environment will
    first be cleared.
    """
    home_dir, lib_dir, inc_dir, bin_dir = path_locations(home_dir)

    py_executable = os.path.abspath(install_python(
        home_dir, lib_dir, inc_dir, bin_dir,
        site_packages=site_packages, clear=clear))

    install_distutils(home_dir)

    if not no_setuptools:
        if use_distribute:
            install_distribute(py_executable, unzip=unzip_setuptools,
                               search_dirs=search_dirs, never_download=never_download)
        else:
            install_setuptools(py_executable, unzip=unzip_setuptools,
                               search_dirs=search_dirs, never_download=never_download)

        if not no_pip:
            install_pip(py_executable, search_dirs=search_dirs, never_download=never_download)

    install_activate(home_dir, bin_dir, prompt)

def is_executable_file(fpath):
    return os.path.isfile(fpath) and os.access(fpath, os.X_OK)

def path_locations(home_dir):
    """Return the path locations for the environment (where libraries are,
    where scripts go, etc)"""
    # XXX: We'd use distutils.sysconfig.get_python_inc/lib but its
    # prefix arg is broken: http://bugs.python.org/issue3386
    if is_win:
        # Windows has lots of problems with executables with spaces in
        # the name; this function will remove them (using the ~1
        # format):
        mkdir(home_dir)
        if ' ' in home_dir:
            import ctypes
            GetShortPathName = ctypes.windll.kernel32.GetShortPathNameW
            size = max(len(home_dir)+1, 256)
            buf = ctypes.create_unicode_buffer(size)
            try:
                u = unicode
            except NameError:
                u = str
            ret = GetShortPathName(u(home_dir), buf, size)
            if not ret:
                print('Error: the path "%s" has a space in it' % home_dir)
                print('We could not determine the short pathname for it.')
                print('Exiting.')
                sys.exit(3)
            home_dir = str(buf.value)
        lib_dir = join(home_dir, 'Lib')
        inc_dir = join(home_dir, 'Include')
        bin_dir = join(home_dir, 'Scripts')
    if is_jython:
        lib_dir = join(home_dir, 'Lib')
        inc_dir = join(home_dir, 'Include')
        bin_dir = join(home_dir, 'bin')
    elif is_pypy:
        lib_dir = home_dir
        inc_dir = join(home_dir, 'include')
        bin_dir = join(home_dir, 'bin')
    elif not is_win:
        lib_dir = join(home_dir, 'lib', py_version)
        multiarch_exec = '/usr/bin/multiarch-platform'
        if is_executable_file(multiarch_exec):
            # In Mageia (2) and Mandriva distros the include dir must be like:
            # virtualenv/include/multiarch-x86_64-linux/python2.7
            # instead of being virtualenv/include/python2.7
            p = subprocess.Popen(multiarch_exec, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
            stdout, stderr = p.communicate()
            # stdout.strip is needed to remove newline character
            inc_dir = join(home_dir, 'include', stdout.strip(), py_version + abiflags)
        else:
            inc_dir = join(home_dir, 'include', py_version + abiflags)
        bin_dir = join(home_dir, 'bin')
    return home_dir, lib_dir, inc_dir, bin_dir


def change_prefix(filename, dst_prefix):
    prefixes = [sys.prefix]

    if is_darwin:
        prefixes.extend((
            os.path.join("/Library/Python", sys.version[:3], "site-packages"),
            os.path.join(sys.prefix, "Extras", "lib", "python"),
            os.path.join("~", "Library", "Python", sys.version[:3], "site-packages"),
            # Python 2.6 no-frameworks
            os.path.join("~", ".local", "lib","python", sys.version[:3], "site-packages"),
            # System Python 2.7 on OSX Mountain Lion
            os.path.join("~", "Library", "Python", sys.version[:3], "lib", "python", "site-packages")))

    if hasattr(sys, 'real_prefix'):
        prefixes.append(sys.real_prefix)
    if hasattr(sys, 'base_prefix'):
        prefixes.append(sys.base_prefix)
    prefixes = list(map(os.path.expanduser, prefixes))
    prefixes = list(map(os.path.abspath, prefixes))
    # Check longer prefixes first so we don't split in the middle of a filename
    prefixes = sorted(prefixes, key=len, reverse=True)
    filename = os.path.abspath(filename)
    for src_prefix in prefixes:
        if filename.startswith(src_prefix):
            _, relpath = filename.split(src_prefix, 1)
            if src_prefix != os.sep: # sys.prefix == "/"
                assert relpath[0] == os.sep
                relpath = relpath[1:]
            return join(dst_prefix, relpath)
    assert False, "Filename %s does not start with any of these prefixes: %s" % \
        (filename, prefixes)

def copy_required_modules(dst_prefix):
    import imp
    # If we are running under -p, we need to remove the current
    # directory from sys.path temporarily here, so that we
    # definitely get the modules from the site directory of
    # the interpreter we are running under, not the one
    # virtualenv.py is installed under (which might lead to py2/py3
    # incompatibility issues)
    _prev_sys_path = sys.path
    if os.environ.get('VIRTUALENV_INTERPRETER_RUNNING'):
        sys.path = sys.path[1:]
    try:
        for modname in REQUIRED_MODULES:
            if modname in sys.builtin_module_names:
                logger.info("Ignoring built-in bootstrap module: %s" % modname)
                continue
            try:
                f, filename, _ = imp.find_module(modname)
            except ImportError:
                logger.info("Cannot import bootstrap module: %s" % modname)
            else:
                if f is not None:
                    f.close()
                # special-case custom readline.so on OS X, but not for pypy:
                if modname == 'readline' and sys.platform == 'darwin' and not (
                        is_pypy or filename.endswith(join('lib-dynload', 'readline.so'))):
                    dst_filename = join(dst_prefix, 'lib', 'python%s' % sys.version[:3], 'readline.so')
                else:
                    dst_filename = change_prefix(filename, dst_prefix)
                copyfile(filename, dst_filename)
                if filename.endswith('.pyc'):
                    pyfile = filename[:-1]
                    if os.path.exists(pyfile):
                        copyfile(pyfile, dst_filename[:-1])
    finally:
        sys.path = _prev_sys_path


def subst_path(prefix_path, prefix, home_dir):
    prefix_path = os.path.normpath(prefix_path)
    prefix = os.path.normpath(prefix)
    home_dir = os.path.normpath(home_dir)
    if not prefix_path.startswith(prefix):
        logger.warn('Path not in prefix %r %r', prefix_path, prefix)
        return
    return prefix_path.replace(prefix, home_dir, 1)


def install_python(home_dir, lib_dir, inc_dir, bin_dir, site_packages, clear):
    """Install just the base environment, no distutils patches etc"""
    if sys.executable.startswith(bin_dir):
        print('Please use the *system* python to run this script')
        return

    if clear:
        rmtree(lib_dir)
        ## FIXME: why not delete it?
        ## Maybe it should delete everything with #!/path/to/venv/python in it
        logger.notify('Not deleting %s', bin_dir)

    if hasattr(sys, 'real_prefix'):
        logger.notify('Using real prefix %r' % sys.real_prefix)
        prefix = sys.real_prefix
    elif hasattr(sys, 'base_prefix'):
        logger.notify('Using base prefix %r' % sys.base_prefix)
        prefix = sys.base_prefix
    else:
        prefix = sys.prefix
    mkdir(lib_dir)
    fix_lib64(lib_dir)
    stdlib_dirs = [os.path.dirname(os.__file__)]
    if is_win:
        stdlib_dirs.append(join(os.path.dirname(stdlib_dirs[0]), 'DLLs'))
    elif is_darwin:
        stdlib_dirs.append(join(stdlib_dirs[0], 'site-packages'))
    if hasattr(os, 'symlink'):
        logger.info('Symlinking Python bootstrap modules')
    else:
        logger.info('Copying Python bootstrap modules')
    logger.indent += 2
    try:
        # copy required files...
        for stdlib_dir in stdlib_dirs:
            if not os.path.isdir(stdlib_dir):
                continue
            for fn in os.listdir(stdlib_dir):
                bn = os.path.splitext(fn)[0]
                if fn != 'site-packages' and bn in REQUIRED_FILES:
                    copyfile(join(stdlib_dir, fn), join(lib_dir, fn))
        # ...and modules
        copy_required_modules(home_dir)
    finally:
        logger.indent -= 2
    mkdir(join(lib_dir, 'site-packages'))
    import site
    site_filename = site.__file__
    if site_filename.endswith('.pyc'):
        site_filename = site_filename[:-1]
    elif site_filename.endswith('$py.class'):
        site_filename = site_filename.replace('$py.class', '.py')
    site_filename_dst = change_prefix(site_filename, home_dir)
    site_dir = os.path.dirname(site_filename_dst)
    writefile(site_filename_dst, SITE_PY)
    writefile(join(site_dir, 'orig-prefix.txt'), prefix)
    site_packages_filename = join(site_dir, 'no-global-site-packages.txt')
    if not site_packages:
        writefile(site_packages_filename, '')

    if is_pypy or is_win:
        stdinc_dir = join(prefix, 'include')
    else:
        stdinc_dir = join(prefix, 'include', py_version + abiflags)
    if os.path.exists(stdinc_dir):
        copyfile(stdinc_dir, inc_dir)
    else:
        logger.debug('No include dir %s' % stdinc_dir)

    platinc_dir = distutils.sysconfig.get_python_inc(plat_specific=1)
    if platinc_dir != stdinc_dir:
        platinc_dest = distutils.sysconfig.get_python_inc(
            plat_specific=1, prefix=home_dir)
        if platinc_dir == platinc_dest:
            # Do platinc_dest manually due to a CPython bug;
            # not http://bugs.python.org/issue3386 but a close cousin
            platinc_dest = subst_path(platinc_dir, prefix, home_dir)
        if platinc_dest:
            # PyPy's stdinc_dir and prefix are relative to the original binary
            # (traversing virtualenvs), whereas the platinc_dir is relative to
            # the inner virtualenv and ignores the prefix argument.
            # This seems more evolved than designed.
            copyfile(platinc_dir, platinc_dest)

    # pypy never uses exec_prefix, just ignore it
    if sys.exec_prefix != prefix and not is_pypy:
        if is_win:
            exec_dir = join(sys.exec_prefix, 'lib')
        elif is_jython:
            exec_dir = join(sys.exec_prefix, 'Lib')
        else:
            exec_dir = join(sys.exec_prefix, 'lib', py_version)
        for fn in os.listdir(exec_dir):
            copyfile(join(exec_dir, fn), join(lib_dir, fn))

    if is_jython:
        # Jython has either jython-dev.jar and javalib/ dir, or just
        # jython.jar
        for name in 'jython-dev.jar', 'javalib', 'jython.jar':
            src = join(prefix, name)
            if os.path.exists(src):
                copyfile(src, join(home_dir, name))
        # XXX: registry should always exist after Jython 2.5rc1
        src = join(prefix, 'registry')
        if os.path.exists(src):
            copyfile(src, join(home_dir, 'registry'), symlink=False)
        copyfile(join(prefix, 'cachedir'), join(home_dir, 'cachedir'),
                 symlink=False)

    mkdir(bin_dir)
    py_executable = join(bin_dir, os.path.basename(sys.executable))
    if 'Python.framework' in prefix:
        # OS X framework builds cause validation to break
        # https://github.com/pypa/virtualenv/issues/322
        if os.environ.get('__PYVENV_LAUNCHER__'):
          os.unsetenv('__PYVENV_LAUNCHER__')
        if re.search(r'/Python(?:-32|-64)*$', py_executable):
            # The name of the python executable is not quite what
            # we want, rename it.
            py_executable = os.path.join(
                    os.path.dirname(py_executable), 'python')

    logger.notify('New %s executable in %s', expected_exe, py_executable)
    pcbuild_dir = os.path.dirname(sys.executable)
    pyd_pth = os.path.join(lib_dir, 'site-packages', 'virtualenv_builddir_pyd.pth')
    if is_win and os.path.exists(os.path.join(pcbuild_dir, 'build.bat')):
        logger.notify('Detected python running from build directory %s', pcbuild_dir)
        logger.notify('Writing .pth file linking to build directory for *.pyd files')
        writefile(pyd_pth, pcbuild_dir)
    else:
        pcbuild_dir = None
        if os.path.exists(pyd_pth):
            logger.info('Deleting %s (not Windows env or not build directory python)' % pyd_pth)
            os.unlink(pyd_pth)

    if sys.executable != py_executable:
        ## FIXME: could I just hard link?
        executable = sys.executable
        shutil.copyfile(executable, py_executable)
        make_exe(py_executable)
        if is_win or is_cygwin:
            pythonw = os.path.join(os.path.dirname(sys.executable), 'pythonw.exe')
            if os.path.exists(pythonw):
                logger.info('Also created pythonw.exe')
                shutil.copyfile(pythonw, os.path.join(os.path.dirname(py_executable), 'pythonw.exe'))
            python_d = os.path.join(os.path.dirname(sys.executable), 'python_d.exe')
            python_d_dest = os.path.join(os.path.dirname(py_executable), 'python_d.exe')
            if os.path.exists(python_d):
                logger.info('Also created python_d.exe')
                shutil.copyfile(python_d, python_d_dest)
            elif os.path.exists(python_d_dest):
                logger.info('Removed python_d.exe as it is no longer at the source')
                os.unlink(python_d_dest)
            # we need to copy the DLL to enforce that windows will load the correct one.
            # may not exist if we are cygwin.
            py_executable_dll = 'python%s%s.dll' % (
                sys.version_info[0], sys.version_info[1])
            py_executable_dll_d = 'python%s%s_d.dll' % (
                sys.version_info[0], sys.version_info[1])
            pythondll = os.path.join(os.path.dirname(sys.executable), py_executable_dll)
            pythondll_d = os.path.join(os.path.dirname(sys.executable), py_executable_dll_d)
            pythondll_d_dest = os.path.join(os.path.dirname(py_executable), py_executable_dll_d)
            if os.path.exists(pythondll):
                logger.info('Also created %s' % py_executable_dll)
                shutil.copyfile(pythondll, os.path.join(os.path.dirname(py_executable), py_executable_dll))
            if os.path.exists(pythondll_d):
                logger.info('Also created %s' % py_executable_dll_d)
                shutil.copyfile(pythondll_d, pythondll_d_dest)
            elif os.path.exists(pythondll_d_dest):
                logger.info('Removed %s as the source does not exist' % pythondll_d_dest)
                os.unlink(pythondll_d_dest)
        if is_pypy:
            # make a symlink python --> pypy-c
            python_executable = os.path.join(os.path.dirname(py_executable), 'python')
            if sys.platform in ('win32', 'cygwin'):
                python_executable += '.exe'
            logger.info('Also created executable %s' % python_executable)
            copyfile(py_executable, python_executable)

            if is_win:
                for name in 'libexpat.dll', 'libpypy.dll', 'libpypy-c.dll', 'libeay32.dll', 'ssleay32.dll', 'sqlite.dll':
                    src = join(prefix, name)
                    if os.path.exists(src):
                        copyfile(src, join(bin_dir, name))

    if os.path.splitext(os.path.basename(py_executable))[0] != expected_exe:
        secondary_exe = os.path.join(os.path.dirname(py_executable),
                                     expected_exe)
        py_executable_ext = os.path.splitext(py_executable)[1]
        if py_executable_ext == '.exe':
            # python2.4 gives an extension of '.4' :P
            secondary_exe += py_executable_ext
        if os.path.exists(secondary_exe):
            logger.warn('Not overwriting existing %s script %s (you must use %s)'
                        % (expected_exe, secondary_exe, py_executable))
        else:
            logger.notify('Also creating executable in %s' % secondary_exe)
            shutil.copyfile(sys.executable, secondary_exe)
            make_exe(secondary_exe)

    if '.framework' in prefix:
        if 'Python.framework' in prefix:
            logger.debug('MacOSX Python framework detected')
            # Make sure we use the the embedded interpreter inside
            # the framework, even if sys.executable points to
            # the stub executable in ${sys.prefix}/bin
            # See http://groups.google.com/group/python-virtualenv/
            #                              browse_thread/thread/17cab2f85da75951
            original_python = os.path.join(
                prefix, 'Resources/Python.app/Contents/MacOS/Python')
        if 'EPD' in prefix:
            logger.debug('EPD framework detected')
            original_python = os.path.join(prefix, 'bin/python')
        shutil.copy(original_python, py_executable)

        # Copy the framework's dylib into the virtual
        # environment
        virtual_lib = os.path.join(home_dir, '.Python')

        if os.path.exists(virtual_lib):
            os.unlink(virtual_lib)
        copyfile(
            os.path.join(prefix, 'Python'),
            virtual_lib)

        # And then change the install_name of the copied python executable
        try:
            mach_o_change(py_executable,
                          os.path.join(prefix, 'Python'),
                          '@executable_path/../.Python')
        except:
            e = sys.exc_info()[1]
            logger.warn("Could not call mach_o_change: %s. "
                        "Trying to call install_name_tool instead." % e)
            try:
                call_subprocess(
                    ["install_name_tool", "-change",
                     os.path.join(prefix, 'Python'),
                     '@executable_path/../.Python',
                     py_executable])
            except:
                logger.fatal("Could not call install_name_tool -- you must "
                             "have Apple's development tools installed")
                raise

    if not is_win:
        # Ensure that 'python', 'pythonX' and 'pythonX.Y' all exist
        py_exe_version_major = 'python%s' % sys.version_info[0]
        py_exe_version_major_minor = 'python%s.%s' % (
            sys.version_info[0], sys.version_info[1])
        py_exe_no_version = 'python'
        required_symlinks = [ py_exe_no_version, py_exe_version_major,
                         py_exe_version_major_minor ]

        py_executable_base = os.path.basename(py_executable)

        if py_executable_base in required_symlinks:
            # Don't try to symlink to yourself.
            required_symlinks.remove(py_executable_base)

        for pth in required_symlinks:
            full_pth = join(bin_dir, pth)
            if os.path.exists(full_pth):
                os.unlink(full_pth)
            os.symlink(py_executable_base, full_pth)

    if is_win and ' ' in py_executable:
        # There's a bug with subprocess on Windows when using a first
        # argument that has a space in it.  Instead we have to quote
        # the value:
        py_executable = '"%s"' % py_executable
    # NOTE: keep this check as one line, cmd.exe doesn't cope with line breaks
    cmd = [py_executable, '-c', 'import sys;out=sys.stdout;'
        'getattr(out, "buffer", out).write(sys.prefix.encode("utf-8"))']
    logger.info('Testing executable with %s %s "%s"' % tuple(cmd))
    try:
        proc = subprocess.Popen(cmd,
                            stdout=subprocess.PIPE)
        proc_stdout, proc_stderr = proc.communicate()
    except OSError:
        e = sys.exc_info()[1]
        if e.errno == errno.EACCES:
            logger.fatal('ERROR: The executable %s could not be run: %s' % (py_executable, e))
            sys.exit(100)
        else:
            raise e

    proc_stdout = proc_stdout.strip().decode("utf-8")
    proc_stdout = os.path.normcase(os.path.abspath(proc_stdout))
    norm_home_dir = os.path.normcase(os.path.abspath(home_dir))
    if hasattr(norm_home_dir, 'decode'):
        norm_home_dir = norm_home_dir.decode(sys.getfilesystemencoding())
    if proc_stdout != norm_home_dir:
        logger.fatal(
            'ERROR: The executable %s is not functioning' % py_executable)
        logger.fatal(
            'ERROR: It thinks sys.prefix is %r (should be %r)'
            % (proc_stdout, norm_home_dir))
        logger.fatal(
            'ERROR: virtualenv is not compatible with this system or executable')
        if is_win:
            logger.fatal(
                'Note: some Windows users have reported this error when they '
                'installed Python for "Only this user" or have multiple '
                'versions of Python installed. Copying the appropriate '
                'PythonXX.dll to the virtualenv Scripts/ directory may fix '
                'this problem.')
        sys.exit(100)
    else:
        logger.info('Got sys.prefix result: %r' % proc_stdout)

    pydistutils = os.path.expanduser('~/.pydistutils.cfg')
    if os.path.exists(pydistutils):
        logger.notify('Please make sure you remove any previous custom paths from '
                      'your %s file.' % pydistutils)
    ## FIXME: really this should be calculated earlier

    fix_local_scheme(home_dir)

    if site_packages:
        if os.path.exists(site_packages_filename):
            logger.info('Deleting %s' % site_packages_filename)
            os.unlink(site_packages_filename)

    return py_executable


def install_activate(home_dir, bin_dir, prompt=None):
    home_dir = os.path.abspath(home_dir)
    if is_win or is_jython and os._name == 'nt':
        files = {
            'activate.bat': ACTIVATE_BAT,
            'deactivate.bat': DEACTIVATE_BAT,
            'activate.ps1': ACTIVATE_PS,
        }

        # MSYS needs paths of the form /c/path/to/file
        drive, tail = os.path.splitdrive(home_dir.replace(os.sep, '/'))
        home_dir_msys = (drive and "/%s%s" or "%s%s") % (drive[:1], tail)

        # Run-time conditional enables (basic) Cygwin compatibility
        home_dir_sh = ("""$(if [ "$OSTYPE" "==" "cygwin" ]; then cygpath -u '%s'; else echo '%s'; fi;)""" %
                       (home_dir, home_dir_msys))
        files['activate'] = ACTIVATE_SH.replace('__VIRTUAL_ENV__', home_dir_sh)

    else:
        files = {'activate': ACTIVATE_SH}

        # suppling activate.fish in addition to, not instead of, the
        # bash script support.
        files['activate.fish'] = ACTIVATE_FISH

        # same for csh/tcsh support...
        files['activate.csh'] = ACTIVATE_CSH

    files['activate_this.py'] = ACTIVATE_THIS
    if hasattr(home_dir, 'decode'):
        home_dir = home_dir.decode(sys.getfilesystemencoding())
    vname = os.path.basename(home_dir)
    for name, content in files.items():
        content = content.replace('__VIRTUAL_PROMPT__', prompt or '')
        content = content.replace('__VIRTUAL_WINPROMPT__', prompt or '(%s)' % vname)
        content = content.replace('__VIRTUAL_ENV__', home_dir)
        content = content.replace('__VIRTUAL_NAME__', vname)
        content = content.replace('__BIN_NAME__', os.path.basename(bin_dir))
        writefile(os.path.join(bin_dir, name), content)

def install_distutils(home_dir):
    distutils_path = change_prefix(distutils.__path__[0], home_dir)
    mkdir(distutils_path)
    ## FIXME: maybe this prefix setting should only be put in place if
    ## there's a local distutils.cfg with a prefix setting?
    home_dir = os.path.abspath(home_dir)
    ## FIXME: this is breaking things, removing for now:
    #distutils_cfg = DISTUTILS_CFG + "\n[install]\nprefix=%s\n" % home_dir
    writefile(os.path.join(distutils_path, '__init__.py'), DISTUTILS_INIT)
    writefile(os.path.join(distutils_path, 'distutils.cfg'), DISTUTILS_CFG, overwrite=False)

def fix_local_scheme(home_dir):
    """
    Platforms that use the "posix_local" install scheme (like Ubuntu with
    Python 2.7) need to be given an additional "local" location, sigh.
    """
    try:
        import sysconfig
    except ImportError:
        pass
    else:
        if sysconfig._get_default_scheme() == 'posix_local':
            local_path = os.path.join(home_dir, 'local')
            if not os.path.exists(local_path):
                os.mkdir(local_path)
                for subdir_name in os.listdir(home_dir):
                    if subdir_name == 'local':
                        continue
                    os.symlink(os.path.abspath(os.path.join(home_dir, subdir_name)), \
                                                            os.path.join(local_path, subdir_name))

def fix_lib64(lib_dir):
    """
    Some platforms (particularly Gentoo on x64) put things in lib64/pythonX.Y
    instead of lib/pythonX.Y.  If this is such a platform we'll just create a
    symlink so lib64 points to lib
    """
    if [p for p in distutils.sysconfig.get_config_vars().values()
        if isinstance(p, basestring) and 'lib64' in p]:
        logger.debug('This system uses lib64; symlinking lib64 to lib')
        assert os.path.basename(lib_dir) == 'python%s' % sys.version[:3], (
            "Unexpected python lib dir: %r" % lib_dir)
        lib_parent = os.path.dirname(lib_dir)
        top_level = os.path.dirname(lib_parent)
        lib_dir = os.path.join(top_level, 'lib')
        lib64_link = os.path.join(top_level, 'lib64')
        assert os.path.basename(lib_parent) == 'lib', (
            "Unexpected parent dir: %r" % lib_parent)
        if os.path.lexists(lib64_link):
            return
        os.symlink('lib', lib64_link)

def resolve_interpreter(exe):
    """
    If the executable given isn't an absolute path, search $PATH for the interpreter
    """
    if os.path.abspath(exe) != exe:
        paths = os.environ.get('PATH', '').split(os.pathsep)
        for path in paths:
            if os.path.exists(os.path.join(path, exe)):
                exe = os.path.join(path, exe)
                break
    if not os.path.exists(exe):
        logger.fatal('The executable %s (from --python=%s) does not exist' % (exe, exe))
        raise SystemExit(3)
    if not is_executable(exe):
        logger.fatal('The executable %s (from --python=%s) is not executable' % (exe, exe))
        raise SystemExit(3)
    return exe

def is_executable(exe):
    """Checks a file is executable"""
    return os.access(exe, os.X_OK)

############################################################
## Relocating the environment:

def make_environment_relocatable(home_dir):
    """
    Makes the already-existing environment use relative paths, and takes out
    the #!-based environment selection in scripts.
    """
    home_dir, lib_dir, inc_dir, bin_dir = path_locations(home_dir)
    activate_this = os.path.join(bin_dir, 'activate_this.py')
    if not os.path.exists(activate_this):
        logger.fatal(
            'The environment doesn\'t have a file %s -- please re-run virtualenv '
            'on this environment to update it' % activate_this)
    fixup_scripts(home_dir)
    fixup_pth_and_egg_link(home_dir)
    ## FIXME: need to fix up distutils.cfg

OK_ABS_SCRIPTS = ['python', 'python%s' % sys.version[:3],
                  'activate', 'activate.bat', 'activate_this.py']

def fixup_scripts(home_dir):
    # This is what we expect at the top of scripts:
    shebang = '#!%s/bin/python' % os.path.normcase(os.path.abspath(home_dir))
    # This is what we'll put:
    new_shebang = '#!/usr/bin/env python%s' % sys.version[:3]
    if is_win:
        bin_suffix = 'Scripts'
    else:
        bin_suffix = 'bin'
    bin_dir = os.path.join(home_dir, bin_suffix)
    home_dir, lib_dir, inc_dir, bin_dir = path_locations(home_dir)
    for filename in os.listdir(bin_dir):
        filename = os.path.join(bin_dir, filename)
        if not os.path.isfile(filename):
            # ignore subdirs, e.g. .svn ones.
            continue
        f = open(filename, 'rb')
        try:
            try:
                lines = f.read().decode('utf-8').splitlines()
            except UnicodeDecodeError:
                # This is probably a binary program instead
                # of a script, so just ignore it.
                continue
        finally:
            f.close()
        if not lines:
            logger.warn('Script %s is an empty file' % filename)
            continue
        if not lines[0].strip().startswith(shebang):
            if os.path.basename(filename) in OK_ABS_SCRIPTS:
                logger.debug('Cannot make script %s relative' % filename)
            elif lines[0].strip() == new_shebang:
                logger.info('Script %s has already been made relative' % filename)
            else:
                logger.warn('Script %s cannot be made relative (it\'s not a normal script that starts with %s)'
                            % (filename, shebang))
            continue
        logger.notify('Making script %s relative' % filename)
        script = relative_script([new_shebang] + lines[1:])
        f = open(filename, 'wb')
        f.write('\n'.join(script).encode('utf-8'))
        f.close()

def relative_script(lines):
    "Return a script that'll work in a relocatable environment."
    activate = "import os; activate_this=os.path.join(os.path.dirname(os.path.realpath(__file__)), 'activate_this.py'); execfile(activate_this, dict(__file__=activate_this)); del os, activate_this"
    # Find the last future statement in the script. If we insert the activation
    # line before a future statement, Python will raise a SyntaxError.
    activate_at = None
    for idx, line in reversed(list(enumerate(lines))):
        if line.split()[:3] == ['from', '__future__', 'import']:
            activate_at = idx + 1
            break
    if activate_at is None:
        # Activate after the shebang.
        activate_at = 1
    return lines[:activate_at] + ['', activate, ''] + lines[activate_at:]

def fixup_pth_and_egg_link(home_dir, sys_path=None):
    """Makes .pth and .egg-link files use relative paths"""
    home_dir = os.path.normcase(os.path.abspath(home_dir))
    if sys_path is None:
        sys_path = sys.path
    for path in sys_path:
        if not path:
            path = '.'
        if not os.path.isdir(path):
            continue
        path = os.path.normcase(os.path.abspath(path))
        if not path.startswith(home_dir):
            logger.debug('Skipping system (non-environment) directory %s' % path)
            continue
        for filename in os.listdir(path):
            filename = os.path.join(path, filename)
            if filename.endswith('.pth'):
                if not os.access(filename, os.W_OK):
                    logger.warn('Cannot write .pth file %s, skipping' % filename)
                else:
                    fixup_pth_file(filename)
            if filename.endswith('.egg-link'):
                if not os.access(filename, os.W_OK):
                    logger.warn('Cannot write .egg-link file %s, skipping' % filename)
                else:
                    fixup_egg_link(filename)

def fixup_pth_file(filename):
    lines = []
    prev_lines = []
    f = open(filename)
    prev_lines = f.readlines()
    f.close()
    for line in prev_lines:
        line = line.strip()
        if (not line or line.startswith('#') or line.startswith('import ')
            or os.path.abspath(line) != line):
            lines.append(line)
        else:
            new_value = make_relative_path(filename, line)
            if line != new_value:
                logger.debug('Rewriting path %s as %s (in %s)' % (line, new_value, filename))
            lines.append(new_value)
    if lines == prev_lines:
        logger.info('No changes to .pth file %s' % filename)
        return
    logger.notify('Making paths in .pth file %s relative' % filename)
    f = open(filename, 'w')
    f.write('\n'.join(lines) + '\n')
    f.close()

def fixup_egg_link(filename):
    f = open(filename)
    link = f.readline().strip()
    f.close()
    if os.path.abspath(link) != link:
        logger.debug('Link in %s already relative' % filename)
        return
    new_link = make_relative_path(filename, link)
    logger.notify('Rewriting link %s in %s as %s' % (link, filename, new_link))
    f = open(filename, 'w')
    f.write(new_link)
    f.close()

def make_relative_path(source, dest, dest_is_directory=True):
    """
    Make a filename relative, where the filename is dest, and it is
    being referred to from the filename source.

        >>> make_relative_path('/usr/share/something/a-file.pth',
        ...                    '/usr/share/another-place/src/Directory')
        '../another-place/src/Directory'
        >>> make_relative_path('/usr/share/something/a-file.pth',
        ...                    '/home/user/src/Directory')
        '../../../home/user/src/Directory'
        >>> make_relative_path('/usr/share/a-file.pth', '/usr/share/')
        './'
    """
    source = os.path.dirname(source)
    if not dest_is_directory:
        dest_filename = os.path.basename(dest)
        dest = os.path.dirname(dest)
    dest = os.path.normpath(os.path.abspath(dest))
    source = os.path.normpath(os.path.abspath(source))
    dest_parts = dest.strip(os.path.sep).split(os.path.sep)
    source_parts = source.strip(os.path.sep).split(os.path.sep)
    while dest_parts and source_parts and dest_parts[0] == source_parts[0]:
        dest_parts.pop(0)
        source_parts.pop(0)
    full_parts = ['..']*len(source_parts) + dest_parts
    if not dest_is_directory:
        full_parts.append(dest_filename)
    if not full_parts:
        # Special case for the current directory (otherwise it'd be '')
        return './'
    return os.path.sep.join(full_parts)



############################################################
## Bootstrap script creation:

def create_bootstrap_script(extra_text, python_version=''):
    """
    Creates a bootstrap script, which is like this script but with
    extend_parser, adjust_options, and after_install hooks.

    This returns a string that (written to disk of course) can be used
    as a bootstrap script with your own customizations.  The script
    will be the standard virtualenv.py script, with your extra text
    added (your extra text should be Python code).

    If you include these functions, they will be called:

    ``extend_parser(optparse_parser)``:
        You can add or remove options from the parser here.

    ``adjust_options(options, args)``:
        You can change options here, or change the args (if you accept
        different kinds of arguments, be sure you modify ``args`` so it is
        only ``[DEST_DIR]``).

    ``after_install(options, home_dir)``:

        After everything is installed, this function is called.  This
        is probably the function you are most likely to use.  An
        example would be::

            def after_install(options, home_dir):
                subprocess.call([join(home_dir, 'bin', 'easy_install'),
                                 'MyPackage'])
                subprocess.call([join(home_dir, 'bin', 'my-package-script'),
                                 'setup', home_dir])

        This example immediately installs a package, and runs a setup
        script from that package.

    If you provide something like ``python_version='2.5'`` then the
    script will start with ``#!/usr/bin/env python2.5`` instead of
    ``#!/usr/bin/env python``.  You can use this when the script must
    be run with a particular Python version.
    """
    filename = __file__
    if filename.endswith('.pyc'):
        filename = filename[:-1]
    f = codecs.open(filename, 'r', encoding='utf-8')
    content = f.read()
    f.close()
    py_exe = 'python%s' % python_version
    content = (('#!/usr/bin/env %s\n' % py_exe)
               + '## WARNING: This file is generated\n'
               + content)
    return content.replace('##EXT' 'END##', extra_text)


# requirements from normal_installation.txt
NORMAL_INSTALLATION = ['feedparser>=5.1.2,<5.2',
 'Pygments>=1.5,<1.6',
 'flup>=1.0.2,<1.1',
 'django-reversion>=1.6.2,<1.7',
 'django-dbtemplates>=1.3,<1.4',
 'django_compressor>=1.2,<1.3',
 'django-tagging>=0.3.1,<0.4',
 'South>=0.7.5,<0.8',
 'Django>=1.4,<1.5',
 'python-creole>=0.8.2,<1.1.0',
 'django-dbpreferences>=0.4.2,<0.5',
 'django-tools>=0.25,<0.26',
 'django-processinfo>=0.4',
 'django-reversion-compare>=0.3.1',
 '--editable=git+git://github.com/jedie/PyLucid.git#egg=pylucid']

# requirements from developer_installation.txt
DEVELOPER_INSTALLATION = ['feedparser>=5.1.2,<5.2',
 'Pygments>=1.5,<1.6',
 'flup>=1.0.2,<1.1',
 'django-reversion>=1.6.2,<1.7',
 'django-dbtemplates>=1.3,<1.4',
 'django_compressor>=1.2,<1.3',
 'django-tagging>=0.3.1,<0.4',
 'South>=0.7.5,<0.8',
 'docutils',
 '--editable=git+git://github.com/django/django.git@stable/1.4.x#egg=django',
 '--editable=git+git@github.com:jedie/python-creole.git#egg=python-creole',
 '--editable=git+git@github.com:jedie/django-dbpreferences.git#egg=django-dbpreferences',
 '--editable=git+git@github.com:jedie/django-tools.git#egg=django-tools',
 '--editable=git+git@github.com:jedie/django-processinfo.git#egg=django-processinfo',
 '--editable=git+git@github.com:jedie/django-reversion-compare.git#egg=django-reversion-compare',
 '--editable=git+git@github.com:jedie/PyLucid.git#egg=pylucid']

# source bootstrap script: '/home/jens/PyLucid_env/src/pylucid/bootstrap/source-pylucid-boot.py'
#-----------------------------------------------------------------------------
# PyLucid bootstrap script START

"""
    PyLucid virtual environment bootstrap
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This file would be merged into pylucid-boot.py with the
    script create_bootstrap_script.py
"""


MENU_TXT = """
Please select how the pylucid own projects should be checkout:

(1) normal installation
(2) developer installation
"""
INSTALL_NORMAL = "normal"
INSTALL_DEV = "developer"
CHOICES = {"1":INSTALL_NORMAL, "2":INSTALL_DEV}
DEFAULT_MENU_CHOICE = CHOICES["1"]


class SysPath(object):
    """
    Helper to find a file in system path.
    >>> SysPath().find("python")
    '/usr/bin/python'
    """
    def __init__(self):
        self.sys_path = os.environ["PATH"].split(":")

    def find(self, filename):
        for path in self.sys_path:
            filepath = os.path.join(path, filename)
            if os.path.isfile(filepath):
                return filepath


class ColorOut(object):
    """
    Borrowed from Django:
    http://code.djangoproject.com/browser/django/trunk/django/utils/termcolors.py
    
    >>> c = ColorOut()
    >>> c.supports_colors()
    True
    >>> c.color_support = True
    >>> c.colorize('no color')
    'no color'
    >>> c.colorize('bold', opts=("bold",))
    '\\x1b[1mbold\\x1b[0m'
    >>> c.colorize("colors!", foreground="red", background="blue", opts=("bold", "blink"))
    '\\x1b[31;44;1;5mcolors!\\x1b[0m'
    """
    color_names = ('black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white')
    foreground_colors = dict([(color_names[x], '3%s' % x) for x in range(8)])
    background_colors = dict([(color_names[x], '4%s' % x) for x in range(8)])
    opt_dict = {'bold': '1', 'underscore': '4', 'blink': '5', 'reverse': '7', 'conceal': '8'}

    def __init__(self):
        self.color_support = self.supports_colors()

    def supports_colors(self):
        if sys.platform in ('win32', 'Pocket PC'):
            return False

        # isatty is not always implemented!
        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
            return True
        else:
            return False

    def colorize(self, text, foreground=None, background=None, opts=()):
        """
        Returns your text, enclosed in ANSI graphics codes.
        """
        if not self.color_support:
            return text

        code_list = []

        if foreground:
            code_list.append(self.foreground_colors[foreground])
        if background:
            code_list.append(self.background_colors[background])

        for option in opts:
            code_list.append(self.opt_dict[option])

        if not code_list:
            return text

        return "\x1b[%sm%s\x1b[0m" % (';'.join(code_list), text)
c = ColorOut()


def get_requirement_choice():
    """
    Display menu and select a number.
    """
    choice_keys = CHOICES.keys()
    input_msg = "%s (%s) (default: %s) " % (
        c.colorize("Please select:", opts=("bold",)),
        "/".join(choice_keys),
        DEFAULT_MENU_CHOICE
    )

    print MENU_TXT
    try:
        input = raw_input(input_msg)
    except KeyboardInterrupt:
        print(c.colorize("Abort, ok.", foreground="blue"))
        sys.exit()

    if input == "":
        return DEFAULT_MENU_CHOICE

    try:
        return CHOICES[input]
    except KeyError:
        print c.colorize("Error:", foreground="red"), "%r is not a valid choice!" % (
            c.colorize(number, opts=("bold",))
        )
        sys.exit(-1)


def extend_parser(parser):
    """
    extend optparse options.
    """
    parser.add_option("-t", "--type", type="string",
        dest="pip_type", default=None,
        help="pip install type: %s" % ", ".join(CHOICES.values())
    )



def adjust_options(options, args):
    """
    Display MENU_TXT
    """
    print c.colorize("PyLucid virtual environment bootstrap", opts=("bold", "underscore"))
    print

    try:
        home_dir = args[0]
    except IndexError:
        return # Error message would be created later

    print "Create PyLucid environment in:", c.colorize(home_dir, foreground="blue", opts=("bold",))
    print

    p = SysPath()

    git_path = p.find("git")
    if git_path:
        print "git found in:", c.colorize(git_path, opts=("bold",))
    else:
        print c.colorize("ERROR:", foreground="red", opts=("underscore",)),
        print "git not found in path!"

    if options.pip_type == None:
        options.pip_type = get_requirement_choice()
    elif options.pip_type not in CHOICES.values():
        print "pip type wrong!"
        sys.exit(-1)


class AfterInstall(object):
    def __init__(self, options, home_dir):
        self.options = options
        self.home_dir = home_dir
        self.abs_home_dir = os.path.abspath(home_dir)
        self.logfile = os.path.join(self.abs_home_dir, "PyLucid_pip.log")
        bin_dir = os.path.join(self.abs_home_dir, "bin")
        self.easy_install = os.path.join(bin_dir, "easy_install")
        self.pip_cmd = os.path.join(bin_dir, "pip")

        self.subprocess_defaults = {
            "cwd": bin_dir,
            "env": {
                "VIRTUAL_ENV": home_dir,
                "PATH": bin_dir + ":" + os.environ["PATH"],
            }
        }

        # NORMAL_INSTALLATION and DEVELOPER_INSTALLATION added by create_bootstrap_script.py!
        if self.options.pip_type == INSTALL_NORMAL:
            self.dev_install = False
        elif self.options.pip_type == INSTALL_DEV:
            self.dev_install = True
        else:
            raise ValueError

    def run_cmd(self, cmd):
        print "_" * 79
        for part in cmd:
            if part.startswith("/") or part.startswith("-"):
                print c.colorize(part, foreground="blue"),
            else:
                print c.colorize(part, foreground="blue", opts=("bold",)),
        print
        subprocess.call(cmd, **self.subprocess_defaults)
        print

    def run_pip(self, info_text, pip_lines):
        print
        print c.colorize(info_text, foreground="green", opts=("bold", "underscore"))

        for pip_line in pip_lines:
            assert isinstance(pip_line, basestring)
            cmd = [self.pip_cmd, "install", "--log=%s" % self.logfile, pip_line]
            
            if "PyLucid.git" in pip_line or "django-processinfo" in pip_line:
                # FIXME: How to handle this better?
                #
                # PyLucid setup.py does contains all dependencies and it will
                # fail on django-compressor==dev with python 2.6, see:
                #     https://github.com/jedie/PyLucid/issues/74
                #
                # django-processinfo has "Django>=1.3,<1.5" which is
                # Django v1.3.x - v1.4.x and will install django 1.3
                #
                cmd.append("--no-dependencies")
                
            self.run_cmd(cmd)

    def install_pip(self):
        print
        if os.path.isfile(self.pip_cmd):
            print c.colorize("update existing pip", foreground="green", opts=("bold", "underscore"))
            self.run_cmd([self.pip_cmd, 'install', "--upgrade", 'pip'])
        else:
            print c.colorize("install pip", foreground="green", opts=("bold", "underscore"))
            self.run_cmd([self.easy_install, '--always-copy', 'pip'])

    def install_packages(self):
        """
        DEVELOPER_INSTALLATION and NORMAL_INSTALLATION would be inserted
        via create_bootstrap_script.py
        """
        if self.dev_install:
            install_data = DEVELOPER_INSTALLATION
        else:
            install_data = NORMAL_INSTALLATION

        self.run_pip("install PyLucid projects", install_data)

    def verbose_symlink(self, source_path, dst_path):
        print("\nsymlink: %s\nto: %s\n" % (
            c.colorize(source_path, opts=("bold",)),
            c.colorize(dst_path, opts=("bold",)))
        )
        try:
            os.symlink(source_path, dst_path)
        except Exception, e:
            import traceback
            sys.stderr.write(traceback.format_exc())

    def symlink_scripts(self):
        """ symlink needfull scripts into env root directory """
        def symlink_pylucid_script(filename):
            source_path = os.path.join(self.abs_home_dir, "src", "pylucid", "scripts", filename)
            dst_path = os.path.join(self.abs_home_dir, filename)
            self.verbose_symlink(source_path, dst_path)

        # symlink some PyLucid scripts from pylucid/scripts/ into virtualenv root
        symlink_pylucid_script("create_page_instance.sh")

        if self.dev_install:
            symlink_pylucid_script("upgrade_pylucid_dev_env.sh")
        else:
            symlink_pylucid_script("upgrade_pylucid_env.sh")

#        # symlink "upgrade_virtualenv.py" from django-tools into  virtualenv root
#        filename = "upgrade_virtualenv.py"
#        source_path = os.path.join(self.abs_home_dir, "src", "django-tools", "django_tools", filename)
#        dst_path = os.path.join(self.abs_home_dir, filename)
#        self.verbose_symlink(source_path, dst_path)



def after_install(options, home_dir):
    """
    called after virtualenv was created and setuptools installed.
    Now we installed PyLucid and used libs/packages.
    """
    a = AfterInstall(options, home_dir)
    a.install_pip()
    a.install_packages()
    a.symlink_scripts()

    print
    print "PyLucid environment created in:", c.colorize(home_dir, foreground="blue", opts=("bold",))
    print
    print "Now you can create a new page instance, more info:"
    print "http://www.pylucid.org/permalink/355/create-a-new-page-instance"
    print

# PyLucid bootstrap script END
#-----------------------------------------------------------------------------


def convert(s):
    b = base64.b64decode(s.encode('ascii'))
    return zlib.decompress(b).decode('utf-8')

##file site.py
SITE_PY = convert("""
eJzFPf1z2zaWv/OvwMqToZTIdOK0vR2nzo2TOK3v3MTbpLO5dT1aSoIs1hTJEqRl7c3d337vAwAB
kpLtTXdO04klEnh4eHhfeHgPHQwGJ0Uhs7lY5fM6lULJuJwtRRFXSyUWeSmqZVLO94u4rDbwdHYT
X0slqlyojYqwVRQET7/yEzwVn5eJMijAt7iu8lVcJbM4TTciWRV5Wcm5mNdlkl2LJEuqJE6Tf0CL
PIvE06/HIDjLBMw8TWQpbmWpAK4S+UJcbKplnolhXeCcX0Tfxi9HY6FmZVJU0KDUOANFlnEVZFLO
AU1oWSsgZVLJfVXIWbJIZrbhOq/TuSjSeCbF3//OU6OmYRiofCXXS1lKkQEyAFMCrALxgK9JKWb5
XEZCvJGzGAfg5w2xAoY2xjVTSMYsF2meXcOcMjmTSsXlRgyndUWACGUxzwGnBDCokjQN1nl5o0aw
pLQea3gkYmYPfzLMHjBPHL/LOYDjxyz4JUvuxgwbuAfBVUtmm1IukjsRI1j4Ke/kbKKfDZOFmCeL
BdAgq0bYJGAElEiT6UFBy/G9XqHXB4SV5coYxpCIMjfml9QjCs4qEacK2LYukEaKMH8np0mcATWy
WxgOIAJJg75x5omq7Dg0O5EDgBLXsQIpWSkxXMVJBsz6UzwjtP+aZPN8rUZEAVgtJX6rVeXOf9hD
AGjtEGAc4GKZ1ayzNLmR6WYECHwG7Eup6rRCgZgnpZxVeZlIRQAAtY2Qd4D0WMSl1CRkzjRyOyb6
E02SDBcWBQwFHl8iSRbJdV2ShIlFApwLXPH+48/i3embs5MPmscMMJbZ6xXgDFBooR2cYABxUKvy
IM1BoKPgHP+IeD5HIbvG8QGvpsHBvSsdDGHuRdTu4yw4kF0vrh4G5liBMqGxAur339BlrJZAn/+5
Z72D4GQbVWji/G29zEEms3glxTJm/kLOCL7XcF5HRbV8BdygEE4FpFK4OIhggvCAJC7NhnkmRQEs
liaZHAVAoSm19VcRWOFDnu3TWrc4ASCUQQYvnWcjGjGTMNEurFeoL0zjDc1MNwnsOq/ykhQH8H82
I12UxtkN4aiIofjbVF4nWYYIIS8E4V5IA6ubBDhxHolzakV6wTQSIWsvbokiUQMvIdMBT8q7eFWk
cszii7p1txqhwWQlzFqnzHHQsiL1SqvWTLWX9w6jLy2uIzSrZSkBeD31hG6R52MxBZ1N2BTxisWr
WufEOUGPPFEn5AlqCX3xO1D0RKl6Je1L5BXQLMRQwSJP03wNJDsKAiH2sJExyj5zwlt4B/8CXPw3
ldVsGQTOSBawBoXIbwOFQMAkyExztUbC4zbNym0lk2SsKfJyLksa6mHEPmDEH9gY5xp8yCtt1Hi6
uMr5KqlQJU21yUzY4mVhxfrxFc8bpgGWWxHNTNOGTiucXlos46k0LslULlAS9CK9sssOYwY9Y5It
rsSKrQy8A7LIhC1Iv2JBpbOoJDkBAIOFL86Sok6pkUIGEzEMtCoI/ipGk55rZwnYm81ygAqJzfcM
7A/g9g8Qo/UyAfrMAAJoGNRSsHzTpCrRQWj0UeAbfdOfxwdOPVto28RDLuIk1VY+zoIzenhaliS+
M1lgr7EmhoIZZhW6dtcZ0BHFfDAYBIFxhzbKfM1VUJWbI2AFYcaZTKZ1goZvMkFTr3+ogEcRzsBe
N9vOwgMNYTp9ACo5XRZlvsLXdm6fQJnAWNgj2BMXpGUkO8geJ75C8rkqvTBN0XY77CxQDwUXP5++
P/ty+kkci8tGpY3b+uwKxjzNYmBrsgjAVK1hG10GLVHxJaj7xHsw78QUYM+oN4mvjKsaeBdQ/1zW
9BqmMfNeBqcfTt6cn05++XT68+TT2edTQBDsjAz2aMpoHmtwGFUEwgFcOVeRtq9Bpwc9eHPyyT4I
JomafPcNsBs8GV7LCpi4HMKMxyJcxXcKGDQcU9MR4thpABY8HI3Ea3H49OnLQ4JWbIoNAAOz6zTF
hxNt0SdJtsjDETX+jV36Y1ZS2n+7PPrmShwfi/C3+DYOA/ChmqbMEj+ROH3eFBK6VvBnmKtREMzl
AkTvRqKADp+SXzziDrAk0DLXdvq3PMnMe+ZKdwjSH0PqAThMJrM0VgobTyYhEIE69HygQ8TONUrd
EDoWG7frSKOCn1LCwmbYZYz/9KAYT6kfosEoul1MIxDX1SxWklvR9KHfZII6azIZ6gFBmEliwOFi
NRQK0wR1VpmAX0uchzpsqvIUfyJ81AIkgLi1Qi2Ji6S3TtFtnNZSDZ1JARGHwxYZUdEmivgRXJQh
WOJm6UajNjUNz0AzIF+agxYtW5TDzx74O6CuzCYON3q892KaIab/wTsNwgFczhDVvVItKKwdxcXp
hXj5/HAf3RnYc84tdbzmaKGTrJb24QJWy8gDI8y9jLy4dFmgnsWnR7thriK7Ml1WWOglLuUqv5Vz
wBYZ2Fll8TO9gZ05zGMWwyqCXid/gFWo8Rtj3Ify7EFa0HcA6q0Iill/s/R7HAyQmQJFxBtrIrXe
9bMpLMr8NkFnY7rRL8FWgrJEi2kcm8BZOI/J0CSChgAvOENKrWUI6rCs2WElvBEk2ot5o1gjAneO
mvqKvt5k+Tqb8E74GJXucGRZFwVLMy82aJZgT7wHKwRI5rCxa4jGUMDlFyhb+4A8TB+mC5SlvQUA
AkOvaLvmwDJbPZoi7xpxWIQxeiVIeEuJ/sKtGYK2WoYYDiR6G9kHRksgJJicVXBWNWgmQ1kzzWBg
hyQ+151HvAX1AbSoGIHZHGpo3MjQ7/IIlLM4d5WS0w8t8pcvX5ht1JLiK4jYFCeNLsSCjGVUbMCw
JqATjEfG0RpigzU4twCmVpo1xf4nkRfsjcF6XmjZBj8AdndVVRwdHKzX60hHF/Ly+kAtDr7983ff
/fk568T5nPgHpuNIiw61RQf0Dj3a6HtjgV6blWvxY5L53EiwhpK8MnJFEb8f6mSei6P9kdWfyMWN
mcZ/jSsDCmRiBmUqA20HDUZP1P6T6KUaiCdknW3b4Yj9Em1SrRXzrS70qHLwBMBvmeU1muqGE5R4
BtYNduhzOa2vQzu4ZyPND5gqyunQ8sD+iyvEwOcMw1fGFE9QSxBboMV3SP8zs01M3pHWEEheNFGd
3fOmX4sZ4s4fLu/W13SExswwUcgdKBF+kwcLoG3clRz8aNcW7Z7j2pqPZwiMpQ8M82rHcoiCQ7jg
WoxdqXO4Gj1ekKY1q2ZQMK5qBAUNTuKUqa3BkY0MESR6N2azzwurWwCdWpFDEx8wqwAt3HE61q7N
Co4nhDxwLF7QEwku8lHn3XNe2jpNKaDT4lGPKgzYW2i00znw5dAAGItB+cuAW5ptysfWovAa9ADL
OQaEDLboMBO+cX3Awd6gh506Vn9bb6ZxHwhcpCHHoh4EnVA+5hFKBdJUDP2e21jcErc72E6LQ0xl
lolEWm0Rrrby6BWqnYZpkWSoe51FimZpDl6x1YrESM1731mgfRA+7jNmWgI1GRpyOI2OydvzBDDU
7TB8dl1joMGNwyBGq0SRdUMyLeEfcCsovkHBKKAlQbNgHipl/sT+AJmz89VftrCHJTQyhNt0mxvS
sRgajnm/J5CMOhoDUpABCbvCSK4jq4MUOMxZIE+44bXcKt0EI1IgZ44FITUDuNNLb4ODTyI8ASEJ
Rch3lZKFeCYGsHxtUX2Y7v5DudQEIYZOA3IVdPTi2I1sOFGN41aUw2doP75BZyVFDhw8BZfHDfS7
bG6Y1gZdwFn3FbdFCjQyxWEGIxfVK0MYN5j8p2OnRUMsM4hhKG8g70jHjDQK7HJr0LDgBoy35u2x
9GM3YoF9h2GuDuXqDvZ/YZmoWa5Cipm0YxfuR3NFlzYW2/NkOoA/3gIMRlceJJnq+AVGWf6JQUIP
etgH3ZsshkXmcblOspAUmKbfsb80HTwsKT0jd/CJtlMHMFGMeB68L0FA6OjzAMQJNQHsymWotNvf
BbtzigMLl7sPPLf58ujlVZe4420RHvvpX6rTu6qMFa5WyovGQoGr1TXgqHRhcnG20YeX+nAbtwll
rmAXKT5++iKQEBzXXcebx029YXjE5t45eR+DOui1e8nVmh2xCyCCWhEZ5SB8PEc+HNnHTm7HxB4B
5FEMs2NRDCTNJ/8MnF0LBWPszzcZxtHaKgM/8Pq7byY9kVEXye++GdwzSosYfWI/bHmCdmROKtg1
21LGKbkaTh8KKmYN69g2xYj1OW3/NI9d9ficGi0b++5vgR8DBUPqEnyE5+OGbN2p4sd3p7bC03Zq
B7DObtV89mgRYG+fT3+DHbLSQbXbOEnpXAEmv7+PytVs7jle0a89PEg7FYxDgr79l7p8DtwQcjRh
1J2OdsZOTMC5ZxdsPkWsuqjs6RyC5gjMywtwjz+7ULUFM4z7nI8XDntUkzfjPmfia9Qqfv4QDWSB
eTQY9JF9Kzv+f8zy+b9mkg+cijm5/gOt4SMB/VEzYePB0LTx8GH1L7trdw2wB5inLW7nDrewOzSf
VS6Mc8cqSYmnqLueijWlK1BsFU+KAMqc/b4eOLiM+tD7bV2WfHRNKrCQ5T4ex44FZmoZz6/XxOyJ
gw+yQkxssxnFqp28nrxPjYQ6+mxnEjb7hn45W+YmZiWz26SEvqBwh+GPH386DftNCMZxodPDrcjD
/QaE+wimDTVxwsf0YQo9pss/L1XtrYtPUJMRYCLCmmy99sEPBJs4Qv8a3BMR8g5s+Zgdd+izpZzd
TCSlDiCbYlcnKP4WXyMmNqPAz/9S8YKS2GAms7RGWrHjjdmHizqb0flIJcG/0qnCmDpECQEc/luk
8bUYUuc5hp40N1J06jYutfdZlDkmp4o6mR9cJ3Mhf6/jFLf1crEAXPDwSr+KeHiKQIl3nNPASYtK
zuoyqTZAgljl+uyP0h+chtMNT3ToIcnHPExATIg4Ep9w2vieCTc35DLBAf/EAyeJ+27s4CQrRPQc
3mf5BEedUI7vmJHqnsvT46A9Qg4ABgAU5j8Y6cid/0bSK/eAkdbcJSpqSY+UbqQhJ2cMoQxHGOng
3/TTZ0SXt7Zgeb0dy+vdWF63sbzuxfLax/J6N5auSODC2qCVkYS+wFX7WKM338aNOfEwp/Fsye0w
9xNzPAGiKMwG28gUp0B7kS0+3yMgpLadA2d62OTPJJxUWuYcAtcgkfvxEEtv5k3yutOZsnF0Z56K
cWe35RD5fQ+iiFLFptSd5W0eV3HkycV1mk9BbC264wbAWLTTiThWmt1OphzdbVmqwcV/ff7x4wds
jqAGJr2BuuEiomHBqQyfxuW16kpTs/krgB2ppZ+IQ900wL0HRtZ4lD3+5x1leCDjiDVlKOSiAA+A
srpsMzf3KQxbz3WSlH7OTM6HTcdikFWDZlJbiHRycfHu5PPJgEJ+g/8duAJjaOtLh4uPaWEbdP03
t7mlOPYBodaxrcb4uXPyaN1wxP021oDt+PCtB4cPMdi9YQJ/lv9SSsGSAKEiHfx9DKEevAf6qm1C
hz6GETvJf+7JGjsr9p0je46L4oh+37FDewD/sBP3GBMggHahhmZn0GymWkrfmtcdFHWAPtDX++ot
WHvr1d7J+BS1k+hxAB3K2mbb3T/vnIaNnpLVm9Mfzj6cn725OPn8o+MCoiv38dPBoTj96Yug/BA0
YOwTxZgaUWEmEhgWt9BJzHP4r8bIz7yuOEgMvd6dn+uTmhWWumDuM9qcCJ5zGpOFxkEzjkLbhzr/
CDFK9QbJqSmidB2qOcL90orrWVSu86OpVGmKzmqtt166VszUlNG5dgTSB41dUjAITjGDV5TFXpld
YckngLrOqgcpbaNtYkhKQcFOuoBz/mVOV7xAKXWGJ01nregvQxfX8CpSRZrATu5VaGVJd8P0mIZx
9EN7wM149WlApzuMrBvyrLdigVbrVchz0/1HDaP9XgOGDYO9g3lnktJDKAMbk9tEiI34JCeUd/DV
Lr1eAwULhgd9FS6iYboEZh/D5losE9hAAE8uwfriPgEgtFbCPxA4cqIDMsfsjPDtar7/l1ATxG/9
6689zasy3f+bKGAXJDiVKOwhptv4HWx8IhmJ04/vRyEjR6m54i81lgeAQ0IBUEfaKX+JT9AnQyXT
hc4v8fUBvtB+Ar1udS9lUeru/a5xiBLwRA3Ja3iiDP1CTPeysMc4lVELNFY+WMywgtBNQzCfPfFp
KdNU57ufvTs/Bd8RizFQgvjc7RSG43gJHqHr5DuucGyBwgN2eF0iG5fowlKSxTzymvUGrVHkqLeX
l2HXiQLD3V6dKHAZJ8pFe4jTZlimnCBCVoa1MMvKrN1qgxR22xDFUWaYJSYXJSWw+jwBvExPY94S
wV4JSz1MBJ5PkZOsMhmLaTIDPQoqFxTqGIQEiYv1jMR5ecYx8LxUpgwKHhabMrleVni6AZ0jKsHA
5j+dfDk/+0BlCYcvG6+7hznHtBMYcxLJMaYIYrQDvrhpf8hVk0kfz+pXCAO1D/xpv+LslGMeoNOP
A4v4p/2K69COnZ0gzwAUVF20xQM3AE63PrlpZIFxtftg/LgpgA1mPhiKRWLZi070cOfX5UTbsmVK
KO5jXj7iAGdR2JQ03dlNSWt/9BwXBZ5zzYf9jeBtn2yZzxS63nTebEt+cz8dKcSSWMCo29ofw2SH
dZrq6TjMto1baFurbeyvmRMrddrNMhRlIOLQ7TxymaxfCevmzIFeGnUHmPheo2sksVeVD37NBtrD
8DCxxO7sU0xHKmMhI4CRDKlrf2rwodAigAKh7N+hI7nj0dNDb46ONbh/jlp3gW38ERShzsWlGo+8
BE6EL7+z48ivCC3Uo0cidDyVTGa5zRPDz3qJXuULf469MkBBTBS7Ms6u5ZBhjQ3MZz6xt4RgSdt6
pL5MrvoMizgD5/RuC4d35aL/4MSg1mKETrsbuWmrI5882KC3FGQnwXzwZbwG3V/U1ZBXcss5dG8t
3Xao90PE7ENoqk/fhyGGY34Pt6xPA7iXGhoWeni/bzmF5bUxjqy1j62qptC+0B7srIStWaXoWMYp
TjS+qPUCGoN73Jj8gX2qE4Xs7546MScmZIHy4C5Ib24D3aAVThhwuRJXjiaUDt9U0+h3c3krUzAa
YGSHWO3wm612GEU2nNKbB/bV2F1sLjb9uNGbBrMjU46BnpkqYP2iTFYHiE5vxGcXZg0yuNS/6i1J
nN2Ql/z2r2dj8fbDz/DvG/kRTCkWP47F3wAN8TYvYX/J1bt0rQJWclS8ccxrhRWSBI2OKvgGCnTb
Ljw647GILjHxa0usphSYVVuu+NoTQJEnSBXtjZ9gCifgt6nsanmjxlPsW5SBfok02F7sggUiB7pl
tKxWKdoLJ0rSrObl4Pzs7emHT6dRdYccbn4OnCiKn5CF09FnxCWeh42FfTKr8cmV4zj/KNOix2/W
m05TOIObThHCvqSwG02+UiO2m4u4xMiBKDbzfBZhS2B5rtWr1uBIj5z95b2G3rOyCGs40qdojTeP
j4Ea4te2IhpAQ+qj50Q9CaF4ikVj/Dga9JvisaDQNvx5erOeu5FxXf1DE2xj2sx66He3unDJdNbw
LCcRXsd2GUxBaJrEajWduYWCHzOhb0QBLUfnHHIR12klZAaSS5t8upoCNL1b28cSwqzC5owK3ihM
k67jjXKSkGIlBjjqgKrr8UCGIoawB/8pvmF7gEWHouZaaIBOiNL+KXe6qnq2ZAnmLRFRryfxYJ1k
L918Hk1hHpR3yLPGkYV5otvIGF3LSs+fHwxHly+aTAeKSs+8yt5ZAVbPZZM9UJ3F06dPB+Lf7/d+
GJUozfMbcMsAdq/Xck6vt1huPTm7Wl3P3ryJgB9nS3kJD64oem6f1xmFJnd0pQWR9q+BEeLahJYZ
TfuWXeagXckHzdyCD6y05fglS+jeIwwtSVS2+vooDDsZaSKWBMUQxmqWJCGHKWA9NnmNRXkYZtT8
Iu+A4xMEM8a3eELGW+0lepiUQGu5x6JzLAYEeEC5ZTwaVTVTWRrgObnYaDQnZ1lSNfUkz93DU30X
QGWvM9J8JeI1SoaZR4sYTn2nx6qNh53vZFFvx5LPLt2AY2uW/Po+3IG1QdLyxcJgCg/NIs1yWc6M
OcUVS2ZJ5YAx7RAOd6ZbnMj6REEPSgNQ72QV5lai7ds/2XVxMf1I58j7ZiSdPlTZm7E4OBRnrQTD
KGrGpzCUJaTlW/NlBKN8oLC29gS8scSfdFAViwm8CzzcusY60xdzcP5Gc1sHwKHLoKyCtOzo6Qjn
BjILn5l2y3Ua+KEtOuF2m5RVHacTff/DBB22iT1Y13jaeridlZ7WWwEnPwcPeF+n7oPjYLJskJ6Y
emtKM47FQocoIrfEzK/GKnL08g7ZVwKfAikzn5jCaBNEurTsaitOdc6mo+IR1DNTxbTFMzflM53K
ExfzMeU5mbqHLV60waV9kYV4fSyGL8bi29ZGaFZs8GInQPnJPHoyD32fjLpeHh02dqa78WxB2Ark
5dWjp5smU5pe2Jdzfn9fnXSIG8AVyM4ikfP9JwqxY5y/FqqG0sxrO6fQjLEkfc9mPelq7KZGhUrR
puDVrxuF4qgW43/aQUyZt9YDXBGLQssWyFbxm8STVvKfvbcNEwM1ev7Koucy6Tucwm94Wwq81wR1
HZ2th5Y6rd6C7dmT69pJPoJqGjYcf69H9ShRaueId1rh8WQjcS7rP4KHQ7pZhpjmWetY+F/JPJy0
v+1wsYPld9/swtNVML1lEj0Lurt2gZe6XbDQLLf59Ie6PEbp6/pVAuNAaUQHvD5z+SP5a0eYD8y3
uuQ2L3iF1yvSWS/allS6/gfvSfkeLXQIaBNO6VmwFuCS1As8mr2l2yJPFKWR4aUv3xy+GJtaWwak
J/AyevlMX6pI3cx1Ar6zOtabIHip+x1G/+YASyq/t33V2RbQtI5btyv5g4UUjxpFE0uHxnLcX1nR
rFks8BbChpjspNorNd6D2zAFh8FcJ5qD5wM7u6gPXVdjNNK7TbVtEeCtwUP72SY5D+raKFJEepew
bVOeuxTno0VB9+q3ILgXR85fxvwGfaq6OLKxKmNT8Cxx6OZH4qe66a3kYnuCxrW6CXdNn/vvmrtu
EdiZm/SAztz9ik2XBrrvdivaRwOOE2hCPKjooNH4/cbEtQNjnZXSH/PWHyS/2wlnusWs3AfG5MBg
BJ3YU2NvzP4qnrnfMcVqn684dgt0e52N1rQ7NqPN8Q/xFDidBJ/bmn3KEZprDuSNB91ZN+Gs04m8
vlaTGO9LnNBulTKkOtsQs/95T9fdyVhtzLYFrwECEIabdC6rm64OjAG6ku9t5gQj574XQUNTGq6T
16uSOZsEvUcCcBGHHqm/CW1zYu4glRgxVnVZlLCtHOjbfTnzpS9ZuAFqImGrWN0Y1E2Psb7slRQr
pVuZol4OeLbSZoAIbMQ7pmEyse+AV543FxckY8sMMqtXsoyr5tIe/4w9Ea+dEaiMGxfXiXM1Utni
EhexxPKGgxRGmuz3Z7BD83anO24qGFlt93B2oh46dvqYSxAcY2S4OLmzF/a5F0XN6bJo1zu0zRqu
s5cUwTKY2+dIR+qgE7/VN2Lxra0cEkf/0uEfkHe3ltHP67bqjL1bi4bzzFUI3SuQsAafjHPfzYYd
DujeYdjaodrxfX1hGaXjYW5pbKmoffJehdOMNmpCMZiCeU8oxk+zf2QoxoP/wFCMvocSDI3GR+uB
3sT7e2I2rB7cSx0bRoA+EyASHgm3rgQ0pnLoprEXuUruBvaKZtaVTm2cMQ/Ikd3bvggEX96o3Jxf
73K1XaEYX7ro8Q/nH9+cnBMtJhcnb//z5AdKc8Jzh5atenCsKsv3mdr7XkK1G7fSqSl9gzfY9ty5
ylVBGkLnfedUvwdCfwVY34K2FZn7eluHTiVNtxMgvnvaLajbVHYv5I5fpqs23ISUVuZzoJ9ymqr5
5Zz1m0fmyIvFoTnSMu+bUwgto50g7baFcxJGu+pE+6v6Xs0tAeSRTVumFcDDB+Qve/ZgalBshJsd
lPb/OINyrbF+z9xJA1I4k87diHQtIoOq/P9DRwnKLsa9HTuKY3vbNbXjcxZlr3HHQ9SZjAxBvAK6
QXd+rrDPZbqFCkHACk/f/MeIGP2nTybtOf4TJS73qVR3H5XNlf2Fa6ad278meFpf2Ru0FKf88Hkl
NF7UqXsCb/t0OpDTR8c6+cKpDQHNdwB0bsRTAXujv8QKcboRIWwctUuG6aZER339nYM82k0He0Or
52J/WyGnW8goxIvtDeetWknd45B7qHt6qNqUyzkWGPMet1VoitcEmc8FBV2Z5TkfeBitt/3w9fby
xZGN0iO/42tHkVB+1sAx7JdOfuPOaxqd7sQs5ZgS4HCv5tT36hZXDlT2CbbtbTpFHlv2PyZhgCEN
vPf9ITPTw7vMftDG1LLeEUxJDJ+oEU3LKYvRuNsno+50G7XVBcIlPg8A0lGBAAvBdHSjk3K54bzp
4XO9G5zWdMGte1QTOlJB6Vc+R3AP4/s1+LW7U2nug7oziqY/N2hzoF5yEG72HbjVyAuFbDcJ7ak3
fLDFBeAq5/7+Lx7Qv5sYaLsf7vKrbauXvZV17MtiLimm2LRIZB5HYGRAbw5JW2MBghF0vNiloaPL
UM3ckC/Q8aP8VLy+mjYY5MxOtAdgjULwf2RtvCc=
""")

##file ez_setup.py
EZ_SETUP_PY = convert("""
eJzNWmmP20YS/a5fwSgYSIJlDu9DhrzIJg5gIMgGuYCFPavpc8SYIhWS8li7yH/f181DJDWcJIt8
WAbOzJDN6qpXVa+qWvr8s+O52ufZbD6f/z3Pq7IqyNEoRXU6VnmelkaSlRVJU1IlWDR7K41zfjIe
SVYZVW6cSjFcq54WxpGwD+RBLMr6oXk8r41fTmWFBSw9cWFU+6ScySQV6pVqDyHkIAyeFIJVeXE2
HpNqbyTV2iAZNwjn+gW1oVpb5Ucjl/VOrfzNZjYzcMkiPxji3zt930gOx7yolJa7i5Z63fDWcnVl
WSF+PUEdgxjlUbBEJsz4KIoSIKi9L6+u1e9YxfPHLM0Jnx2SosiLtZEXGh2SGSStRJGRSnSLLpau
9aYMq3hulLlBz0Z5Oh7Tc5I9zJSx5Hgs8mORqNfzo3KCxuH+fmzB/b05m/2oYNK4Mr2xkiiM4oTf
S2UKK5KjNq/xqtby+FAQ3vejqYJh1oBXnsvZV2++/uKnb37c/fzm+x/e/uNbY2vMLTNgtj3vHv30
/TcKV/VoX1XHze3t8XxMzDq4zLx4uG2Cory9KW/xX7fb7dy4UbuYDb7vNu7dbHbg/o6TikDgf7TH
Fpc3XmJzar88nh3TNcXDw2JjLKLIcRiRsWU7vsUjL6JxHNBQOj4LRMDIYv2MFK+VQsOYRMSzXOH5
liMpjXwhXGnHnh26PqMTUpyhLn7gh6Ef84gEPJLM86zQIjG3Qid0eBw/L6XTxYMBJOJ2EHOHiiCw
JXEdEgjfEZ6MnCmL3KEulLo2syQL3TgmgeuHcRz6jPBY+sQK7OhZKZ0ubkQihrs8EIw7juOF0g5j
GXISBLEkbEKKN9QlcCzPJ44nuCdsQVkYSmG5MSGeCGQo/GelXHBh1CF25EOPiBMmJXW4DX0sl7rU
Zt7TUtgoXqgrHer7bswD+DWUoUd4GNsOBJHYiiYsYuN4gT1ccCAZhNzhjpTC9iwrdgNPOsSb8DSz
raEyDHA4hPrcJZbjB54fwD/MdiPLIqEVW8+L6bTxQ44X4aOYRlYYOsyPie+SyHNd4nM+iUwtxm/F
cOEFhEXAMg5ZFPt+6AhfRD7CUdCIhc+LCTptIoFMIkJaAQBymAg824M0B0YC8Alvg1SG2DiUCIIc
tl2O95FGTiRCSnzqE2jExfNiLp7igRvLmFoQ5jHP8eLQcj0umCOYxZxJT9lDbAKPxZ50qQxJiCh0
BYtcYVEH7g69mDrPi+mwoZLEjm1ZlMNNHDkBSYJzF44PPCsKJsSMeEZaVuBRGRDi0JBbUAvIeghs
K7JD5kw5asQzgR3YsSMEc33phQJeswPGA2I7kOqEU1JGPCPtCAQF8uUSoUIcP2YxpEibhzSM5ARb
sRHPCEvw0Asih8VxRCUNgXRkIXot+Dy0p5ztDp1EqJB2IDmHYb7v217k2SwEf/E4igN/SsqIrahF
Y9u1CSPUdSyAAZ4LpecxH0QR2vJZKZ1FCBKJPQPuSSpdZBSVsRcwC1CB9cRUwHhDiyLF1iB+12Gc
xix0KJMe6MsJpBMROcVW/tAiIWLJIwvqICERsdIV4HQ/BGHwyA6mPO0PLSISXMUlqoodWrYQADdE
cfIpQ8EjwRTL+CMfRdyVAQjBY4yQKLQ9BA53Q8oYd7nPJ6QEQ4uQMBGqfGTbASpRFHmhAxGomL4X
I7WniDMYVTfmB0T6IQW+6B6QDYEFQzzPRYL5ZIobgqFF1JERCX0HxR60S10UaQuu5sKXaCV8d0JK
OKI7Cz6SMeHMJYHtC9+2faQhWooIFDgZL+GoEpBIxr6HKsDB5ZakQcikLR24AY+cqQwIhxZ5qLEE
fCvRMiABPdezbVtyEbk2/oVTukSjbshSvZATA5GYo36oEASBR66lGivreSmdRYwSNwI3oOfwIpdZ
KmYRbQCbobJMloFoaJEdOnYIkoOjY85s3/Jji/gRdQXyPPanPB0PLYLuzLPQzNgKYerFgfCYpMKK
YCuzpjwdj5gBQYbGDrXVjSIegJ2IEFYA8mKB6031d42UziIp4FpX+MQOqe0wuIn5nk1D1F5UfjFV
SeJhPWIEaWNLxZrEERzEZMcuKltI/dhBjwMpv816EwHGm3JWFedNPXDtSblPE9rOW+jdZ+ITExg1
3uo7b9RI1KzFw/66GRfS2H0kaYJuX+xwawmddhnmwbWhBoDVRhuQSKO9r2bGdjyoH6qLJ5gtKowL
SoR+0dyLT/VdzHftMshpVn627aS8a0XfXeSpC3MXpsHXr9V0UlZcFJjrloMV6porkxoLmvnwBlMY
wRjGPzOM5Xd5WSY07Y1/GOnw9+Fvq/mVsJvOzMGj1eAvpY/4lFRLp75fwLlFpuGqAR0Nh3pRM15t
R8PculNrR0kptr2Bbo1JcYdRdZuXJjsV+K0Opu4FLlJy3tr+rHESxsYvTlV+AA4M0+UZo2jGbzuz
eycFaq4/kA/wJYbnj4CKKIAAnjLtSKp9Pc7fN0rfG+U+P6VcTbOkxrovrZ3Ms9OBisKo9qQyMAh3
grUsNQFnCl1DYurtlDplXL8ijPsBEPeGGmmXj/uE7dvdBbRWRxO1PGNxu1iZULJG6V5tqeT0jjH2
ohgckDwmmLnpJRIEXyMi6wDXKmc58EgLQfj5oj72eCt76mnY9XbN2YQWUzVaamlUaFUaQPSJBcsz
XtbYtGocCQJFgQpEVFolVQLXZQ+984za4439eSb0eUJ9NsJrvQBqnioMnzwfUVo2hw2iEabPcor8
hJ1ErUqdZ8Q4iLIkD6I+4Lgk3f29jpeCJKUwfjiXlTi8+aTwympHZAapcK8+2SBUUYsyXoWgMqY+
9TDbCNU/H0m5q1kI9m+NxfHDw64QZX4qmCgXimHU9oecn1JRqlOSHoGOH9c5gazjiIMGtuXqwiQq
5LaXpOnlZYPYKAXbtFuPEu3CAW2SmEBWFNXSWqtNeiTXEHW306v+6Q5tj/l2jWN2mpi3SkbtIBD7
WNYAIP3wCYbvXmoJqQ9I8+h6h4Foswmu5fyi8evt/EUD1epVI7uvwlDAz/XKL/NMpgmrAM2mz/59
z/9Ztp//uL9E/0S8L19vb8pVl8ttDuujzPfZkPDnjGSLSqVUlyLgDHV8p3OkOa5T2XLKMoSyaXyX
CkRIu/xKnsohlcogIAFbWg1lUpQA4lSqdFhAwrl1vfHyp57yC3Mk7332Plt+eSoKSAOd1wJuilHd
WqFqXWJZmKR4KN9Zd8/XrCd991WCwEzoSdXRb/Pq6xzs3AsUUpazJtvS4ZvrfkK+G6XznXrlc4Ci
CT//MKiZ/RCti+dTmfpXV1CVz8i4Qen86ok6qTOTXHjeSHNWdxmaEWsbkqo+9NVdw/9p3axZVx3r
t3Xz98qmuqd2va6ZNZXfX8rgRKnL6wLX1jdVJ1h1IunFiKZuDGtD+6lBgfJBHUTWHvGY1kHbtqBb
o8dPL29KtNM3peqm5/1cGJ1q14EPuf1yoDAzXgy7vpJ8FNB+iy675vlf8iRbtlWhXVqLKwumxOnW
91sU6LZbVuzTvo68K6tyWYtdbVQyfPExT1QAHQVRJbBVp+ySbUDR6tKhyCFIoVG2KKX5w2CV6q+V
X4bvqgsrzUdSZEuF88u/7qo/9Gi4siHn8qkov9EhoT4MWYqPIlN/wJwjlJ3tRXpUrdzbOtp67UQX
Kug3VPyrj2uWCooZWH5tgKpm6tYB6ZwJAIlXkIeqmQXpikdFsQQTalnqt/u0rknZnDVbgo2btuWy
I1TmbTSbs9kSjCg2CmEt5kDYXnVQPBd1rdnDvVCiesyLD82ma+NYF4ycVqT5qE0xhWaJG5CpYhEg
wHQjrhdA8iUTm8wpRFOA+gaYq7/SiwiK9VXI9Ej3qkfSUbZW2XT1GpoEHaxVoobFphdKhTi+qn8s
R+3UMDpbGtalrpzrLUalTKdcww8mfuZHkS2vln1ufI8+/vaxSCqQD3wMfHUHDQ7/sFaf9j0q76kO
gBUqDUGNLC+Kkw6OVIyEab/3w0M11pXQ61tObK/mk7OpuRoGmGrGWK6GGtcsoq2puWI9f6RzwIkH
prajnqy7lzDfqTlvM6YAbLDRu7A0L8VydUURZbXRQvvPm2rWkhYUTNUvLW3N/sil6vcBkb5ED/Jx
PVWxLzX37XOfg+oa+wbdUrOqLRBP9cejz5efa47reaDj6iuJlzXPzwx6+Lauu6zhZDAYDLTPVGr0
xgGWHw4w1By0he0JDWlmrPZqfKQhTlELNM6rF+oA5W6lw/RRLAod1sJQZfx3Q0VZqnAe1Sql9nUN
waJThqHuw7IzS6TlsMHvmbbbNWjtdsYWU55lWqa9+NNd/z9B8Jpc1ahLyzwVyNWJabft41FM6l79
qkcvxCH/qPlWe6L+GoMealE5KlBv+ju8O2q+J7vsJql+HTYrvWGq3+1cz3d/YEbDz2ea+dEgtpmO
9v85JJ9Ls07w70q5iuan8q5Nt7vhGK7BtlYIfFilqj8cx3SkqCdPR6ja5S8CoFNfa37BZbCldqAO
8/kPV23RfN0yyhwk+KALUaFOdBGEaJIuAT1/Qt5i+T3aqXn7hRvzeB4OlPP6qzTX3zYxV4vmpPLY
1ad2hCkv9PyTfmqoFKGnJK1e1ke/EPmgJsWzYuR+FBfN/KN6rfaouBN7AUT33JfuWv2pViwvXbUW
0tZCXTQXBV1cnnUnx+rdu+bUWbZF9cmTZ9kVu3oErEv0u7n646bY4N8aXIHxoek064as3chE8T2U
y9Vd97JZwuKudB7VUDGf15NCXaT7wMADGCGrdmLQXxHatnfNB1HVSavuL/uT9E53DLtdE/UdJI2M
taFhedW0RC0Ar8bGHkiFaXALPc1SkILtl/P3Wf8rPu+z5bt//Xb3YvXbXLcnq/4Yo9/ucdETjI1C
rr9klRpCscBn8+skbRmxVhX/f7fRgk3dei/t1R3GMA3kC/20fojRFY82d0+bv3hsYkI27VGneg+A
GcxocdxuF7udStjdbtF9sJEqiVBT5/BrR5fD9u939h3eefkSYNWp0itfvdzpljubu6fqouaIi0y1
qL7+C1AkCcw=
""")

##file distribute_from_egg.py
DISTRIBUTE_FROM_EGG_PY = convert("""
eJw9j8tqAzEMRfcG/4MgmxQyptkGusonZBmGoGTUGYFfWPKE6dfXTkM3gqt7rh47OKP3NMF3SQFW
LlrRU1zhybpAxoKBlIqcrNnBdRjQP3GTocYfzmNrrCPQPN9iwzpxSQfQhWBi0cL3qtRtYIG/4Mv0
KApY5hooqrOGQ05FQTaxptF9Fnx16Rq0XofjaE1XGXVxHIWK7j8P8EY/rHndLqQ1a0pe3COFgHFy
hLLdWkDbi/DeEpCjNb3u/zccT2Ob8gtnwVyI
""")

##file distribute_setup.py
DISTRIBUTE_SETUP_PY = convert("""
eJztPGtz2ziS3/UrcHK5SOUkxs7MzV25TlOVmTizrs0mKdvZ/ZC4aIiEJI75GpC0ov311403SEp2
LrMfruq8O7ZENBqNfncDzMm/1ft2W5WT6XT6S1W1TctpTdIM/marrmUkK5uW5jltMwCaXK3JvurI
jpYtaSvSNYw0rO3qtqryBmBxlJOaJg90w4JGDkb1fk5+75oWAJK8Sxlpt1kzWWc5oocvgIQWDFbl
LGkrvie7rN2SrJ0TWqaEpqmYgAsibFvVpFrLlTT+i4vJhMDPmleFQ30sxklW1BVvkdrYUivg/Ufh
bLBDzv7ogCxCSVOzJFtnCXlkvAFmIA126hw/A1Ra7cq8oumkyDiv+JxUXHCJloTmLeMlBZ5qILvj
uVg0Aai0Ik1FVnvSdHWd77NyM8FN07rmVc0znF7VKAzBj/v7/g7u76PJ5BbZJfibiIURIyO8g88N
biXhWS22p6QrqKw3nKauPCNUioliXtXoT822a7PcfNubgTYrmP68LgvaJlszxIoa6THfKXe/wo5q
yhs2mRgB4hqNllxebSaTlu8vrJCbDJVTDn+6ubyOb65uLyfsa8JgZ1fi+SVKQE4xEGRJ3lclc7Dp
fXQr4HDCmkZqUsrWJJa2ESdFGr6gfNPM5BT8wa+ALIT9R+wrS7qWrnI2n5F/F0MGjgM7eemgjxJg
eCiwkeWSnE0OEn0CdgCyAcmBkFOyBiFJgsir6Ic/lcgT8kdXtaBr+LgrWNkC69ewfAmqasHgEWKq
wRsAMQWSHwDMD68Cu6QmCxEy3ObMH1N4Avgf2D6MD4cdtgXT02YakFMEHMApmP6Q2vRnS4FgHXxQ
KzZ3felUTdTUFIwyhE8f43+8vrqdkx7TyAtXZm8u377+9O42/vvl9c3Vh/ew3vQs+in64cepGfp0
/Q4fb9u2vnj5st7XWSRFFVV881L5yOZlA34sYS/Tl9ZtvZxObi5vP328/fDh3U389vVfL9/0FkrO
z6cTF+jjX3+Lr96//YDj0+mXyd9YS1Pa0sXfpbe6IOfR2eQ9uNkLx8InZvS0mdx0RUHBKshX+Jn8
pSrYogYKxffJ6w4o5+7nBStolssn77KElY0CfcOkfxF48QEQBBI8tKPJZCLUWLmiEFzDCv7OtW+K
ke3LcDbTRsG+QoxKhLaKcCDhxWBb1OBSgQfa30TFQ4qfwbPjOPiRaEd5GQaXFgkoxWkTzNVkCVjl
abxLARHow4a1yS5VGIzbEFBgzFuYE7pTBRQVREgnF1U1K/W2LEys9qH27E2OkrxqGIYja6GbShGL
mzaBwwCAg5FbB6Jq2m6j3wFeETbHhzmol0Pr57O72XAjEosdsAx7X+3IruIPLsc0tEOlEhqGrSGO
KzNI3hhlD2aufymr1vNogY7wsFygkMPHF65y9DyMXe8GdBgyB1huBy6N7HgFH9OOa9Vxc5vIoaOH
hTEBzdAzkwJcOFgFoavqkfUnoXJmbVJBGNWu+5UHoPyNfLjOSlh9TJ+k+lncMuRGvGg5Y0bblOGs
ugzA2WYTwn9zYuynrWIE+3+z+T9gNkKGIv6WBKQ4gugXA+HYDsJaQUh5W04dMqPFH/h7hfEG1UY8
WuA3+MUdRH+Kksr9Sb3XusdZ0+Wtr1pAiARWTkDLAwyqaRsxbGngNIOc+uqDSJbC4Neqy1MxS/BR
Wutmg9apbCSFLamkO1T5+9yk4fGKNkxv23mcspzu1arI6L6SKPjABu7FabOo96dpBP9Hzo6mNvBz
SiwVmGaoLxAD1xVo2MjD87vZ89mjjAYINntxSoQD+z9Ea+/nAJes1j3hjgSgyCKRfPDAjLfh2ZxY
+at83C/UnKpkpctUnTLEoiBYCsOR8u4VRWrHy17S1uPA0kncRrkhd7BEA+j4CBOW5/8xB+HEa/rA
lre8Y8b3FlQ4gKaDSnIn0nmho3TVVDmaMfJiYpdwNA1A8G/ocm9Hm1hyiaGvDeqHTQwmJfLIRqTV
yN+iSrucNVjafTG7CSxX+oBDP+19cUTjrecDSOXc0oa2LQ89QDCUOHWi/mhZgLMVB8frAjHkl+x9
EOUcbDVlIA4VWmamjM7f4y0OM89jRqT6CuHUsuTn5RTqMrXebISw/j58jCqV/7Uq13mWtP7iDPRE
1jOJ8CfhDDxKX3SuXg25j9MhFEIWFO04FN/hAGJ6K3y72FjqtkmcdlL48/IUiqisEaKmj1BCiOrq
Szkd4sPuT0LLoMVEShk7YN5tsbMhWkKqkwGfeFdifInIx5yBgEbx6W4HJUXFkdQE00JN6DrjTTsH
4wQ0o9MDQLzXTocsPjn7CqIR+C/llzL8teMcVsn3EjE55TNA7kUAFmEWi5nFUJml0LI2fOWPsbwZ
sRDQQdIzOsfCP/c8xR1OwdgselHVw6EC+1vs4VlR5JDNjOq1yXZg1fdV+7bqyvS7zfZJMsdIHKRC
xxxWnHBGW9b3VzFuTligybJExDoSqL83bImfkdilQpZyxFCkv7FtSWOvIrSa5icYX14lol4SrVnF
+ayV3caSFkxmjfeK9nvICkVytsIW6iPNMw+7Nr2yK1aMg0lTYcvGLQhc2LIUWbFo45jeKaiBmMLI
vcePe4KNlxCcRLLVq7MylZET+8qUBC+DWUTuJU/ucUWvOAAHwzjTWaSp5PQqLI3kHgUHzXS1B9EV
TqoyFf3ZmmKsX7E1+htsxSZtR3PbJRb7a7HUaiMthn9JzuCFIyHUjkMlvhKBiGFrXvXIeY5118Qx
x9Fw6aB4NTa33fwzRnXAfpSXH0dYp23+iR5QSV824rmXrqIgIRhqLDIFpI8MWHogC9egKsHkCaKD
fal+r2OuvdRZop1dIM9fP1YZanWNppsacmySM4jqpn4x1iOcfDOd45Z8ny2JUlwKB8Mn5JrR9KUI
rgQjDORnQDpZgck9zPFUYIdKiOFQ+hbQ5KTiHNyFsL4eMtit0GptLxmez7RMwGsV1j/YKcQMgSeg
DzTtJVWSjYJoyaw5me5W0wGQygsQmR0bOE0lCVhrJMcAAnQN34MH/CPxDhZ14W07V0gY9pILS1Ay
1tUgOOwG3Neq+hquuzJBd6a8oBh2x0XTd05evHjYzY5kxvJIwtYoarq2jDfatdzI58eS5j4s5s1Q
ao8lzEjtY1bJBtag+e/+1LRpBgP9lSJcByQ9fG4WeQYOAwuYDs+r8XRIlC9YKD0jtbET3lIAeHZO
3593WIZKebRGeKJ/Up3VMkO6jzNoVASjad04pKv1rt5qTRdkxegdQjSEOTgM8AFla4P+P0R0o8lD
Vwt/sZa5NSvlliC265C01k4AMc1UhAAXCg4vVmgBYu16kLVnncCm4YSlJsmy7gS8HyLZa66OtMNe
+xBuI1axw6qJnfURobFKiPQESDQxasTCTdiNeXsFC9wFY2FUOTzN0/EkcT3moYTSTxzxwHqu23FG
jNfCM3LNt1FpfreAFHFHhKRpGXBNUlCynY76+BQieBB9ePcmOm3wDA/PhyP8NWgrXyM6GTgxaxLt
TLlDjVH1l7Fwxq/h2KgiXz+0tBbVIyTiYHSx2/EP65wmbAtmxHSXvJchZA32OYdgPvGfygeIsd5h
AuR0ahPO3MMKusaaxvNsmOnq+xFOE3qcFKBaHbdH6m+Ic+dut+cF9iMXWHj0A4lefOCHV6AnDy5b
1n7pZTlg+6+iOnDvELjr9hgw6SnB36pHVAGWM3kAXXUtZtPolHZ0b01WV1D9TNBhzpxIy1HE9+Sp
5jt8sEFCGR4QHXuw0pq8yDSYJN2smjEnI6ezqqeu+DmIGZYXYAe07+HmxKdmVJVOAPOO5KwNGoJq
b3x6n59GzRS/UdNCtz047zUW1eEB3rvAjw73NIZj8lAw3llfv4etQHp1tOtqBliGucKYVoJPlocC
wFZNrOLEgRZ9cGNvNaVOAyLo7cR354c8Td+5H4Izrp6uIVE3J+JIgOKKEwARxNzfMT1xYySW+VgI
AQY8kAOPXhRARVytfg/Nceos0o30GopNqOhkZHyqgeH5NkX4t8zxXK5LLyjlSJ32lBseEbfmju5Z
DF2QYNX+UTAJjE4FqvDZZzKy2LQbVaHcsSN1JNRYPwgLfPG0Ljx0NWIuafsGt9cjZeABNS+HLnDU
90jwI56n78N/RfnLQD6Y5edOJlcx/tIkWSqlvywfM16VaGy9vN4turEc3kJ5R2rGi6xp9M04WUaf
Ygf0IatroGl6ZBtD+lRuN+rEBcDhPE+KqzWJ3WFxOXoSwYSgnxf12NluHalaDqrHT6WpHhlOI7Cv
M0/v7ykz7/m7Z7mTycyvWUwEttnliYprEA6TB9TqDL+N1QoHbUVm85e//bZASWI8A6nKz99gK9kg
Gz8a9A8FqOcGeaunTqA/ULgA8cWD4Zv/6CgrZk94mSc5d8yi/zTTcljhlVBKW8arKDVoL8yIdqwJ
r4PQ+ots1x6MrSNnkAqz6EnHNWfr7Guoo44NdCbiijCljl8p3zxe9PyRTcbVZUYN+Fl/gJCdsq9O
DIda6/zizmR1YniuLz2ysisYp/I6pNsjQlB5nVjmf4sFh93KGyFyG/1yAbYBOCJYlbcN9tNRj5cY
1CSekQZUW9VKOGJmnWdtGOA6y2D2edE7h3SYoBnoLqZw9Q/DJFVYqEoqRg+Xc1BOeYfzZ8mf8V6Z
R27zWUAid4d0fiutlkpgb9cwHohTFHs5WR2LYsd6tDc1toqZPWIdUisH6tpX+JuEisNT54xVX08d
M+CD1wCO9eJOyI4FYFUJkDCSdDj5Nqikc8MprZhkSsNYgYHdPQoetn3E1x2ajF+8qDtYyIbhhpxw
hJkyTN41EWaR/hm3j/FaHnRjehKJy+u96okzEepxfCnctq+zXqpzu6/ZgF/YjHXOyl5/vPpXEmyp
s0VqfxlQT1813Xtu7osgbskk2wbjgjohKWuZuk+I8RzvIJigiHqb9jNsc/647JMX6aG+drsvqDhF
mVwadF03a0ZWUbwQpynSN6J6Ct+YfRXE1rx6zFKWyndVsrWCd9+KaZzWSKquIhZze5qjG61uPeSH
kjHKxqWgsAFD532CAZE8BBq7hDv0bfJ+PtCyherocAXlZWZgo1KOjXuRUW1pZBMRK1MVRMR9uQOb
KhfynqMVnkcHWvvhLt+oVPVkRRrgGPO3I00f5yrsYZIOJVEjpBzPqRSJ4aGUFHXO75Z8Q1p6MC89
0lvv8cafN+yuu7phzizRrMXBuvSQ4pDb8f4l64vWLwi+V55DeiEmFTUQyZxDgZx2ZbK1mZ190g+e
12rE2zhGO1mWinfIJIToSeiXjCRUndWkoPwBbzJUhIrjZ2onrLqNKp6K9BzfaQkWiX8RHhIJvFaU
s4VqTSzYV/GaGSTQi4KWEMPT4M4geXUICWdJxTWkes9HJJwXP9xhwiIpAFcyNvDKCaV6+OzO9EGw
Xegms5/9N2vuILnS0yYah7jzNPrSlBGJcxG8YflanhgspxHU+QXDuxjNEqOVPepSl9fF2bqCkAe3
4l4FBxFKeeHXRF7b0ne39f7sHRH09vjKX7UrsZIvqhRfDpSRBc84BIDbk7CHoBpJBuotOn2gSGkT
kXvcQGDu2uCbeoB0zQQhg6vrQKjiAHyEyWpHAfp4mQTTXBBR4JuX4v4N8FOQLFqfGg+eLSj7gOi0
2pMNaxWucOZfSlGJX1LVe/c7VH1QW6h7lpKh8gq/BlCMt5cxXQ6APtyZjEOLZZBp6AGM+vl6Yuoc
WEl4WohVCsQr09Ww6vz3PN6JJsyjR90RauiaoVRZ76aEhYxoDeVuGqo1fCep6VoKbkX46ygg3tHD
XtGPP/6XTIuSrAD5ifoMCDz7z7MzJ/vL15GSvUYqtd+kK9cM3QEjDbLfpdm1b7eZSf6bhK/m5EeH
RWhkOJ/xEDCczxHPq9loXZIUtYCJsCUhASN7LtfnGyINJeZxAC6pD8dOXQaIHth+qTUwwhsUoL9I
c4AEBDNMxAU2eSNbMwiSQnF5BnAZEzZmi7or5IFZYp95Pa1zxj0ixfnnaBNFS9xn0OA6gpBysgXi
rIwV3tkQsBPnqs8ATLawsyOAuvnqmOz/4iqxVFGcnAP3cyi4z4fFtrio3Svkx65+CGRxutqEoIRT
5VvwlUW8RMZ670G5L4aF6k1pGwLE31/MSyL2bVfwpoF6uVbHLGK6NZV+e8gUY6o89r2js7L0aooZ
iooIK35Nn+elDhjjT4cytKnsHui71g35qF8L/glDNOSjjPeuZ8lL8Tf7pmXFJcbWcydpcgjXTk03
KLymggtomrVgWpLZPS5/xBEZS+WhE0Sakjkdp8YDF4jELUb1Lnj0QUAJNFy5AgkU0TSNJQ5b72qC
8WJr0y4Dl9nwkIo7PcugabH114IrEJBr2uWqPLd3Z7csr5c6PUIbF8wWL5wruZPwGOtnwXOo1Rfz
FnjX0ZDt3YAMMJNp6SPly+mn63dTS6KmfPTur6Rf/3MDmNTgjVgRmNXN1speCxxXbLUDJai5ztzU
jlyh60S2Av6onMMYFcUu6qYEjqeuGmnxCw0qKDjGAzedrUZdHft3CoTPvqTNXkFpldL/TsLSV1PZ
/zn6ipR/wVrbr/fUM4zhy8vHvBF4rExcM8RaLRbtwDhGPsSxepHeZMCCOzDhfwBqDMd7
""")

##file activate.sh
ACTIVATE_SH = convert("""
eJytVVFvokAQfudXTLEPtTlLeo9tvMSmJpq02hSvl7u2wRUG2QR2DSxSe7n/frOACEVNLlceRHa+
nfl25pvZDswCnoDPQ4QoTRQsENIEPci4CsBMZBq7CAsuLOYqvmYKTTj3YxnBgiXBudGBjUzBZUJI
BXEqgCvweIyuCjeG4eF2F5x14bcB9KQiQQWrjSddI1/oQIx6SYYeoFjzWIoIhYI1izlbhJjkKO7D
M/QEmKfO9O7WeRo/zr4P7pyHwWxkwitcgwpQ5Ej96OX+PmiFwLeVjFUOrNYKaq1Nud3nR2n8nI2m
k9H0friPTGVsUdptaxGrTEfpNVFEskxpXtUkkCkl1UNF9cgLBkx48J4EXyALuBtAwNYIjF5kcmUU
abMKmMq1ULoiRbgsDEkTSsKSGFCJ6Z8vY/2xYiSacmtyAfCDdCNTVZoVF8vSTQOoEwSnOrngBkws
MYGMBMg8/bMBLSYKS7pYEXP0PqT+ZmBT0Xuy+Pplj5yn4aM9nk72JD8/Wi+Gr98sD9eWSMOwkapD
BbUv91XSvmyVkICt2tmXR4tWmrcUCsjWOpw87YidEC8i0gdTSOFhouJUNxR+4NYBG0MftoCTD9F7
2rTtxG3oPwY1b2HncYwhrlmj6Wq924xtGDWqfdNxap+OYxplEurnMVo9RWks+rH8qKEtx7kZT5zJ
4H7oOFclrN6uFe+d+nW2aIUsSgs/42EIPuOhXq+jEo3S6tX6w2ilNkDnIpHCWdEQhFgwj9pkk7FN
l/y5eQvRSIQ5+TrL05lewxWpt/Lbhes5cJF3mLET1MGhcKCF+40tNWnUulxrpojwDo2sObdje3Bz
N3QeHqf3D7OjEXMVV8LN3ZlvuzoWHqiUcNKHtwNd0IbvPGKYYM31nPKCgkUILw3KL+Y8l7aO1ArS
Ad37nIU0fCj5NE5gQCuC5sOSu+UdI2NeXg/lFkQIlFpdWVaWZRfvqGiirC9o6liJ9FXGYrSY9mI1
D/Ncozgn13vJvsznr7DnkJWXsyMH7e42ljdJ+aqNDF1bFnKWFLdj31xtaJYK6EXFgqmV/ymD/ROG
+n8O9H8f5vsGOWXsL1+1k3g=
""")

##file activate.fish
ACTIVATE_FISH = convert("""
eJyVVWFv2jAQ/c6vuBoqQVWC9nVSNVGVCaS2VC2rNLWVZZILWAs2s52wVvvxsyEJDrjbmgpK7PP5
3bt3d22YLbmGlGcIq1wbmCPkGhPYcLMEEsGciwGLDS+YwSjlekngLFVyBe73GXSXxqw/DwbuTS8x
yyKpFr1WG15lDjETQhpQuQBuIOEKY5O9tlppLqxHKSDByjVAPwEy+mXtCq5MzjIUBTCRgEKTKwFG
gpBqxTLYXgN2myspVigMaYF92tZSowGZJf4mFExxNs9Qb614CgZtmH0BpEOn11f0cXI/+za8pnfD
2ZjA1sg9zlV/8QvcMhxbNu0QwgYokn/d+n02nt6Opzcjcnx1vXcIoN74O4ymWQXmHURfJw9jenc/
vbmb0enj6P5+cuVhqlKm3S0u2XRtRbA2QQAhV7VhBF0rsgUX9Ur1rBUXJgVSy8O751k8mzY5OrKH
RW3eaQhYGTr8hrXO59ALhxQ83mCsDLAid3T72CCSdJhaFE+fXgicXAARUiR2WeVO37gH3oYHzFKo
9k7CaPZ1UeNwH1tWuXA4uFKYYcEa8vaKqXl7q1UpygMPhFLvlVKyNzsSM3S2km7UBOl4xweUXk5u
6e3wZmQ9leY1XE/Ili670tr9g/5POBBpGIJXCCF79L1siarl/dbESa8mD8PL61GpzqpzuMS7tqeB
1YkALrRBloBMbR9yLcVx7frQAgUqR7NZIuzkEu110gbNit1enNs82Rx5utq7Z3prU78HFRgulqNC
OTwbqJa9vkJFclQgZSjbKeBgSsUtCtt9D8OwAbIVJuewQdfvQRaoFE9wd1TmCuRG7OgJ1bVXGHc7
z5WDL/WW36v2oi37CyVBak61+yPBA9C1qqGxzKQqZ0oPuocU9hpud0PIp8sDHkXR1HKkNlzjuUWA
a0enFUyzOWZA4yXGP+ZMI3Tdt2OuqU/SO4q64526cPE0A7ZyW2PMbWZiZ5HamIZ2RcCKLXhcDl2b
vXL+eccQoRzem80mekPDEiyiWK4GWqZmwxQOmPM0eIfgp1P9cqrBsewR2p/DPMtt+pfcYM+Ls2uh
hALufTAdmGl8B1H3VPd2af8fQAc4PgqjlIBL9cGQqNpXaAwe3LrtVn8AkZTUxg==
""")

##file activate.csh
ACTIVATE_CSH = convert("""
eJx9VG1P2zAQ/u5fcYQKNgTNPtN1WxlIQ4KCUEGaxuQ6yYVYSuzKdhqVX7+zk3bpy5YPUXL3PPfc
ne98DLNCWshliVDV1kGCUFvMoJGugMjq2qQIiVSxSJ1cCofD1BYRnOVGV0CfZ0N2DD91DalQSjsw
tQLpIJMGU1euvPe7QeJlkKzgWixlhnAt4aoUVsLnLBiy5NtbJWQ5THX1ZciYKKWwkOFaE04dUm6D
r/zh7pq/3D7Nnid3/HEy+wFHY/gEJydg0aFaQrBFgz1c5DG1IhTs+UZgsBC2GMFBlaeH+8dZXwcW
VPvCjXdlAvCfQsE7al0+07XjZvrSCUevR5dnkVeKlFYZmUztG4BdzL2u9KyLVabTU0bdfg7a0hgs
cSmUg6UwUiQl2iHrcbcVGNvPCiLOe7+cRwG13z9qRGgx2z6DHjfm/Op2yqeT+xvOLzs0PTKHDz2V
tkckFHoQfQRXoGJAj9el0FyJCmEMhzgMS4sB7KPOE2ExoLcSieYwDvR+cP8cg11gKkVJc2wRcm1g
QhYFlXiTaTfO2ki0fQoiFM4tLuO4aZrhOzqR4dIPcWx17hphMBY+Srwh7RTyN83XOWkcSPh1Pg/k
TXX/jbJTbMtUmcxZ+/bbqOsy82suFQg/BhdSOTRhMNBHlUarCpU7JzBhmkKmRejKOQzayQe6MWoa
n1wqWmuh6LZAaHxcdeqIlVLhIBJdO9/kbl0It2oEXQj+eGjJOuvOIR/YGRqvFhttUB2XTvLXYN2H
37CBdbW2W7j2r2+VsCn0doVWcFG1/4y1VwBjfwAyoZhD
""")

##file activate.bat
ACTIVATE_BAT = convert("""
eJx9UdEKgjAUfW6wfxjiIH+hEDKUFHSKLCMI7kNOEkIf9P9pTJ3OLJ/03HPPPed4Es9XS9qqwqgT
PbGKKOdXL4aAFS7A4gvAwgijuiKlqOpGlATS2NeMLE+TjJM9RkQ+SmqAXLrBo1LLIeLdiWlD6jZt
r7VNubWkndkXaxg5GO3UaOOKS6drO3luDDiO5my3iA0YAKGzPRV1ack8cOdhysI0CYzIPzjSiH5X
0QcvC8Lfaj0emsVKYF2rhL5L3fCkVjV76kShi59NHwDniAHzkgDgqBcwOgTMx+gDQQqXCw==
""")

##file deactivate.bat
DEACTIVATE_BAT = convert("""
eJxzSE3OyFfIT0vj4ipOLVEI8wwKCXX0iXf1C7Pl4spMU0hJTcvMS01RiPf3cYmHyQYE+fsGhCho
cCkAAUibEkTEVhWLMlUlLk6QGixStlyaeCyJDPHw9/Pw93VFsQguim4ZXAJoIUw5DhX47XUM8UCx
EchHtwsohN1bILUgw61c/Vy4AJYPYm4=
""")

##file activate.ps1
ACTIVATE_PS = convert("""
eJylWdmS40Z2fVeE/oHT6rCloNUEAXDThB6wAyQAEjsB29GBjdgXYiWgmC/zgz/Jv+AEWNVd3S2N
xuOKYEUxM+/Jmzfvcm7W//zXf/+wUMOoXtyi1F9kbd0sHH/hFc2iLtrK9b3FrSqyxaVQwr8uhqJd
uHaeg9mqzRdR8/13Pyy8qPLdJh0+LMhi0QCoXxYfFh9WtttEnd34H8p6/f1300KauwrULws39e18
0ZaLNm9rgN/ZVf3h++/e124Vlc0vKsspHy+Yyi5+XbzPhijvCtduoiL/kA1ukWV27n0o7Sb8LIFj
CvWR5GQgUJdp1Pw8TS9+rPy6SDv/+e3d+0+4qw8f3v20+PliV37efEYBAB9FTKC+RHn/Cfxn3rdv
00Fube5O+iyCtHDs9BfPfz3q4sfFv9d91Ljhfy7ei0VO+nVTtdOkv/jpt0l2AX6iG1jXgKnnDuD4
ke2k/i8fzzz5UedkVcP4pwF+Wvz2FJl+3vt598urXf5Y6LNA5WcFOP7r0sW7b9a+W/xcu0Xpv5zk
Kfq3P9Dz9di/fCxS72MXVU1rpx9L4Bxl85Wmn5a+zP76Zuh3pL9ROWr87PN+//GHIl+oOtvn9XSU
qH+p0gQBFnx1uV+JLH5O5zv+PXW+WepXVVHZT0+oQezkIATcIm+ivPV/z5J/+cYj3ir4w0Lx09vC
e5n/y5/Y5LPPfdrqb88ga/PabxZRVfmp39l588m/6u+/e+OpP+dF7n1WZpJ9//Z4v372fDDz9eHB
7Juvs/BLMHzrxL9+9twXpJfhd1/DrpQ5Euu/vlss3wp9HXC/54C/Ld69m6zwdx3tC0d8daSv0V8B
n4b9YYF53sJelJV/ix6LZspw/sJtqyl5LJ5r/23htA1Imfm/gt9R7dqVB1LjhydAX4Gb+zksQF59
9+P7H//U+376afFuvh2/T6P85Xr/5c8C6OXyFY4BGuN+EE0+GeR201b+wkkLN5mmBY5TfMw8ngqL
CztXxCSXKMCYrRIElWkEJlEPYsSOeKBVZCAQTKBhApMwRFQzmCThE0YQu2CdEhgjbgmk9GluHpfR
/hhwJCZhGI5jt5FsAkOrObVyE6g2y1snyhMGFlDY1x+BoHpCMulTj5JYWNAYJmnKpvLxXgmQ8az1
4fUGxxcitMbbhDFcsiAItg04E+OSBIHTUYD1HI4FHH4kMREPknuYRMyhh3AARWMkfhCketqD1CWJ
mTCo/nhUScoQcInB1hpFhIKoIXLo5jLpwFCgsnLCx1QlEMlz/iFEGqzH3vWYcpRcThgWnEKm0QcS
rA8ek2a2IYYeowUanOZOlrbWSJUC4c7y2EMI3uJPMnMF/SSXdk6E495VLhzkWHps0rOhKwqk+xBI
DhJirhdUCTamMfXz2Hy303hM4DFJ8QL21BcPBULR+gcdYxoeiDqOFSqpi5B5PUISfGg46gFZBPo4
jdh8lueaWuVSMTURfbAUnLINr/QYuuYoMQV6l1aWxuZVTjlaLC14UzqZ+ziTGDzJzhiYoPLrt3uI
tXkVR47kAo09lo5BD76CH51cTt1snVpMOttLhY93yxChCQPI4OBecS7++h4p4Bdn4H97bJongtPk
s9gQnXku1vzsjjmX4/o4YUDkXkjHwDg5FXozU0fW4y5kyeYW0uJWlh536BKr0kMGjtzTkng6Ep62
uTWnQtiIqKnEsx7e1hLtzlXs7Upw9TwEnp0t9yzCGgUJIZConx9OHJArLkRYW0dW42G9OeR5Nzwk
yk1mX7du5RGHT7dka7N3AznmSif7y6tuKe2N1Al/1TUPRqH6E2GLVc27h9IptMLkCKQYRqPQJgzV
2m6WLsSipS3v3b1/WmXEYY1meLEVIU/arOGVkyie7ZsH05ZKpjFW4cpY0YkjySpSExNG2TS8nnJx
nrQmWh2WY3cP1eISP9wbaVK35ZXc60yC3VN/j9n7UFoK6zvjSTE2+Pvz6Mx322rnftfP8Y0XKIdv
Qd7AfK0nexBTMqRiErvCMa3Hegpfjdh58glW2oNMsKeAX8x6YJLZs9K8/ozjJkWL+JmECMvhQ54x
9rsTHwcoGrDi6Y4I+H7yY4/rJVPAbYymUH7C2D3uiUS3KQ1nrCAUkE1dJMneDQIJMQQx5SONxoEO
OEn1/Ig1eBBUeEDRuOT2WGGGE4bNypBLFh2PeIg3bEbg44PHiqNDbGIQm50LW6MJU62JHCGBrmc9
2F7WBJrrj1ssnTAK4sxwRgh5LLblhwNAclv3Gd+jC/etCfyfR8TMhcWQz8TBIbG8IIyAQ81w2n/C
mHWAwRzxd3WoBY7BZnsqGOWrOCKwGkMMNfO0Kci/joZgEocLjNnzgcmdehPHJY0FudXgsr+v44TB
I3jnMGnsK5veAhgi9iXGifkHMOC09Rh9cAw9sQ0asl6wKMk8mpzFYaaDSgG4F0wisQDDBRpjCINg
FIxhlhQ31xdSkkk6odXZFpTYOQpOOgw9ugM2cDQ+2MYa7JsEirGBrOuxsQy5nPMRdYjsTJ/j1iNw
FeSt1jY2+dd5yx1/pzZMOQXUIDcXeAzR7QlDRM8AMkUldXOmGmvYXPABjxqkYKO7VAY6JRU7kpXr
+Epu2BU3qFFXClFi27784LrDZsJwbNlDw0JzhZ6M0SMXE4iBHehCpHVkrQhpTFn2dsvsZYkiPEEB
GSEAwdiur9LS1U6P2U9JhGp4hnFpJo4FfkdJHcwV6Q5dV1Q9uNeeu7rV8PAjwdFg9RLtroifOr0k
uOiRTo/obNPhQIf42Fr4mtThWoSjitEdAmFW66UCe8WFjPk1YVNpL9srFbond7jrLg8tqAasIMpy
zkH0SY/6zVAwJrEc14zt14YRXdY+fcJ4qOd2XKB0/Kghw1ovd11t2o+zjt+txndo1ZDZ2T+uMVHT
VSXhedBAHoJIID9xm6wPQI3cXY+HR7vxtrJuCKh6kbXaW5KkVeJsdsjqsYsOwYSh0w5sMbu7LF8J
5T7U6LJdiTx+ca7RKlulGgS5Z1JSU2Llt32cHFipkaurtBrvNX5UtvNZjkufZ/r1/XyLl6yOpytL
Km8Fn+y4wkhlqZP5db0rooqy7xdL4wxzFVTX+6HaxuQJK5E5B1neSSovZ9ALB8091dDbbjVxhWNY
Ve5hn1VnI9OF0wpvaRm7SZuC1IRczwC7GnkhPt3muHV1YxUJfo+uh1sYnJy+vI0ZwuPV2uqWJYUH
bmBsi1zmFSxHrqwA+WIzLrHkwW4r+bad7xbOzJCnKIa3S3YvrzEBK1Dc0emzJW+SqysQfdEDorQG
9ZJlbQzEHQV8naPaF440YXzJk/7vHGK2xwuP+Gc5xITxyiP+WQ4x18oXHjFzCBy9kir1EFTAm0Zq
LYwS8MpiGhtfxiBRDXpxDWxk9g9Q2fzPPAhS6VFDAc/aiNGatUkPtZIStZFQ1qD0IlJa/5ZPAi5J
ySp1ETDomZMnvgiysZSBfMikrSDte/K5lqV6iwC5q7YN9I1dBZXUytDJNqU74MJsUyNNLAPopWK3
tzmLkCiDyl7WQnj9sm7Kd5kzgpoccdNeMw/6zPVB3pUwMgi4C7hj4AMFAf4G27oXH8NNT9zll/sK
S6wVlQwazjxWKWy20ZzXb9ne8ngGalPBWSUSj9xkc1drsXkZ8oOyvYT3e0rnYsGwx85xZB9wKeKg
cJKZnamYwiaMymZvzk6wtDUkxmdUg0mPad0YHtvzpjEfp2iMxvORhnx0kCVLf5Qa43WJsVoyfEyI
pzmf8ruM6xBr7dnBgzyxpqXuUPYaKahOaz1LrxNkS/Q3Ae5AC+xl6NbxAqXXlzghZBZHmOrM6Y6Y
ctAkltwlF7SKEsShjVh7QHuxMU0a08/eiu3x3M+07OijMcKFFltByXrpk8w+JNnZpnp3CfgjV1Ax
gUYCnWwYow42I5wHCcTzLXK0hMZN2DrPM/zCSqe9jRSlJnr70BPE4+zrwbk/xVIDHy2FAQyHoomT
Tt5jiM68nBQut35Y0qLclLiQrutxt/c0OlSqXAC8VrxW97lGoRWzhOnifE2zbF05W4xuyhg7JTUL
aqJ7SWDywhjlal0b+NLTpERBgnPW0+Nw99X2Ws72gOL27iER9jgzj7Uu09JaZ3n+hmCjjvZpjNst
vOWWTbuLrg+/1ltX8WpPauEDEvcunIgTxuMEHweWKCx2KQ9DU/UKdO/3za4Szm2iHYL+ss9AAttm
gZHq2pkUXFbV+FiJCKrpBms18zH75vax5jSo7FNunrVWY3Chvd8KKnHdaTt/6ealwaA1x17yTlft
8VBle3nAE+7R0MScC3MJofNCCkA9PGKBgGMYEwfB2QO5j8zUqa8F/EkWKCzGQJ5EZ05HTly1B01E
z813G5BY++RZ2sxbQS8ZveGPJNabp5kXAeoign6Tlt5+L8i5ZquY9+S+KEUHkmYMRFBxRrHnbl2X
rVemKnG+oB1yd9+zT+4c43jQ0wWmQRR6mTCkY1q3VG05Y120ZzKOMBe6Vy7I5Vz4ygPB3yY4G0FP
8RxiMx985YJPXsgRU58EuHj75gygTzejP+W/zKGe78UQN3yOJ1aMQV9hFH+GAfLRsza84WlPLAI/
9G/5JdcHftEfH+Y3/fHUG7/o8bv98dzzy3e8S+XCvgqB+VUf7sH0yDHpONdbRE8tAg9NWOzcTJ7q
TuAxe/AJ07c1Rs9okJvl1/0G60qvbdDzz5zO0FuPFQIHNp9y9Bd1CufYVx7dB26mAxwa8GMNrN/U
oGbNZ3EQ7inLzHy5tRg9AXJrN8cB59cCUBeCiVO7zKM0jU0MamhnRThkg/NMmBOGb6StNeD9tDfA
7czsAWopDdnGoXUHtA+s/k0vNPkBcxEI13jVd/axp85va3LpwGggXXWw12Gwr/JGAH0b8CPboiZd
QO1l0mk/UHukud4C+w5uRoNzpCmoW6GbgbMyaQNkga2pQINB18lOXOCJzSWPFOhZcwzdgrsQnne7
nvjBi+7cP2BbtBeDOW5uOLGf3z94FasKIguOqJl+8ss/6Kumns4cuWbqq5592TN/RNIbn5Qo6qbi
O4F0P9txxPAwagqPlftztO8cWBzdN/jz3b7GD6JHYP/Zp4ToAMaA74M+EGSft3hEGMuf8EwjnTk/
nz/P7SLipB/ogQ6xNX0fDqNncMCfHqGLCMM0ZzFa+6lPJYQ5p81vW4HkCvidYf6kb+P/oB965g8K
C6uR0rdjX1DNKc5pOSTquI8uQ6KXxYaKBn+30/09tK4kMpJPgUIQkbENEPbuezNPPje2Um83SgyX
GTCJb6MnGVIpgncdQg1qz2bvPfxYD9fewCXDomx9S+HQJuX6W3VAL+v5WZMudRQZk9ZdOk6GIUtC
PqEb/uwSIrtR7/edzqgEdtpEwq7p2J5OQV+RLrmtTvFwFpf03M/VrRyTZ73qVod7v7Jh2Dwe5J25
JqFOU2qEu1sP+CRotklediycKfLjeIZzjJQsvKmiGSNQhxuJpKa+hoWUizaE1PuIRGzJqropwgVB
oo1hr870MZLgnXF5ZIpr6mF0L8aSy2gVnTAuoB4WEd4d5NPVC9TMotYXERKlTcwQ2KiB/C48AEfH
Qbyq4CN8xTFnTvf/ebOc3isnjD95s0QF0nx9s+y+zMmz782xL0SgEmRpA3x1w1Ff9/74xcxKEPdS
IEFTz6GgU0+BK/UZ5Gwbl4gZwycxEw+Kqa5QmMkh4OzgzEVPnDAiAOGBFaBW4wkDmj1G4RyElKgj
NlLCq8zsp085MNh/+R4t1Q8yxoSv8PUpTt7izZwf2BTHZZ3pIZpUIpuLkL1nNL6sYcHqcKm237wp
T2+RCjgXweXd2Zp7ZM8W6dG5bZsqo0nrJBTx8EC0+CQQdzEGnabTnkzofu1pYkWl4E7XSniECdxy
vLYavPMcL9LW5SToJFNnos+uqweOHriUZ1ntIYZUonc7ltEQ6oTRtwOHNwez2sVREskHN+bqG3ua
eaEbJ8XpyO8CeD9QJc8nbLP2C2R3A437ISUNyt5Yd0TbDNcl11/DSsOzdbi/VhCC0KE6v1vqVNkq
45ZnG6fiV2NwzInxCNth3BwL0+8814jE6+1W1EeWtpWbSZJOJNYXmWRXa7vLnAljE692eHjZ4y5u
y1u63De0IzKca7As48Z3XshVF+3XiLNz0JIMh/JOpbiNLlMi672uO0wYzOCZjRxcxj3D+gVenGIE
MvFUGGXuRps2RzMcgWIRolHXpGUP6sMsQt1hspUBnVKUn/WQj2u6j3SXd9Xz0QtEzoM7qTu5y7gR
q9gNNsrlEMLdikBt9bFvBnfbUIh6voTw7eDsyTmPKUvF0bHqWLbHe3VRHyRZnNeSGKsB73q66Vsk
taxWYmwz1tYVFG/vOQhlM0gUkyvIab3nv2caJ1udU1F3pDMty7stubTE4OJqm0i0ECfrJIkLtraC
HwRWKzlqpfhEIqYH09eT9WrOhQyt8YEoyBlnXtAT37WHIQ03TIuEHbnRxZDdLun0iok9PUC79prU
m5beZzfQUelEXnhzb/pIROKx3F7qCttYIFGh5dXNzFzID7u8vKykA8Uejf7XXz//S4nKvW//ofS/
QastYw==
""")

##file distutils-init.py
DISTUTILS_INIT = convert("""
eJytV1uL4zYUfvevOE0ottuMW9q3gVDa3aUMXXbLMlDKMBiNrSTqOJKRlMxkf33PkXyRbGe7Dw2E
UXTu37lpxLFV2oIyifAncxmOL0xLIfcG+gv80x9VW6maw7o/CANSWWBwFtqeWMPlGY6qPjV8A0bB
C4eKSTgZ5LRgFeyErMEeOBhbN+Ipgeizhjtnhkn7DdyjuNLPoCS0l/ayQTG0djwZC08cLXozeMss
aG5EzQ0IScpnWtHSTXuxByV/QCmxE7y+eS0uxWeoheaVVfqSJHiU7Mhhi6gULbOHorshkrEnKxpT
0n3A8Y8SMpuwZx6aoix3ouFlmW8gHRSkeSJ2g7hU+kiHLDaQw3bmRDaTGfTnty7gPm0FHbIBg9U9
oh1kZzAFLaue2R6htPCtAda2nGlDSUJ4PZBgCJBGVcwKTAMz/vJiLD+Oin5Z5QlvDPdulC6EsiyE
NFzb7McNTKJzbJqzphx92VKRFY1idenzmq3K0emRcbWBD0ryqc4NZGmKOOOX9Pz5x+/l27tP797c
f/z0d+4NruGNai8uAM0bfsYaw8itFk8ny41jsfpyO+BWlpqfhcG4yxLdi/0tQqoT4a8Vby382mt8
p7XSo7aWGdPBc+b6utaBmCQ7rQKQoWtAuthQCiold2KfJIPTT8xwg9blPumc+YDZC/wYGdAyHpJk
vUbHbHWAp5No6pK/WhhLEWrFjUwtPEv1Agf8YmnsuXUQYkeZoHm8ogP16gt2uHoxcEMdf2C6pmbw
hUMsWGhanboh4IzzmsIpWs134jVPqD/c74bZHdY69UKKSn/+KfVhxLgUlToemayLMYQOqfEC61bh
cbhwaqoGUzIyZRFHPmau5juaWqwRn3mpWmoEA5nhzS5gog/5jbcFQqOZvmBasZtwYlG93k5GEiyw
buHhMWLjDarEGpMGB2LFs5nIJkhp/nUmZneFaRth++lieJtHepIvKgx6PJqIlD9X2j6pG1i9x3pZ
5bHuCPFiirGHeO7McvoXkz786GaKVzC9DSpnOxJdc4xm6NSVq7lNEnKdVlnpu9BNYoKX2Iq3wvgh
gGEUM66kK6j4NiyoneuPLSwaCWDxczgaolEWpiMyDVDb7dNuLAbriL8ig8mmeju31oNvQdpnvEPC
1vAXbWacGRVrGt/uXN/gU0CDDwgooKRrHfTBb1/s9lYZ8ZqOBU0yLvpuP6+K9hLFsvIjeNhBi0KL
MlOuWRn3FRwx5oHXjl0YImUx0+gLzjGchrgzca026ETmYJzPD+IpuKzNi8AFn048Thd63OdD86M6
84zE8yQm0VqXdbbgvub2pKVnS76icBGdeTHHXTKspUmr4NYo/furFLKiMdQzFjHJNcdAnMhltBJK
0/IKX3DVFqvPJ2dLE7bDBkH0l/PJ29074+F0CsGYOxsb7U3myTUncYfXqnLLfa6sJybX4g+hmcjO
kMRBfA1JellfRRKJcyRpxdS4rIl6FdmQCWjo/o9Qz7yKffoP4JHjOvABcRn4CZIT2RH4jnxmfpVG
qgLaAvQBNfuO6X0/Ux02nb4FKx3vgP+XnkX0QW9pLy/NsXgdN24dD3LxO2Nwil7Zlc1dqtP3d7/h
kzp1/+7hGBuY4pk0XD/0Ao/oTe/XGrfyM773aB7iUhgkpy+dwAMalxMP0DrBcsVw/6p25+/hobP9
GBknrWExDhLJ1bwt1NcCNblaFbMKCyvmX0PeRaQ=
""")

##file distutils.cfg
DISTUTILS_CFG = convert("""
eJxNj00KwkAMhfc9xYNuxe4Ft57AjYiUtDO1wXSmNJnK3N5pdSEEAu8nH6lxHVlRhtDHMPATA4uH
xJ4EFmGbvfJiicSHFRzUSISMY6hq3GLCRLnIvSTnEefN0FIjw5tF0Hkk9Q5dRunBsVoyFi24aaLg
9FDOlL0FPGluf4QjcInLlxd6f6rqkgPu/5nHLg0cXCscXoozRrP51DRT3j9QNl99AP53T2Q=
""")

##file activate_this.py
ACTIVATE_THIS = convert("""
eJyNU01v2zAMvetXEB4K21jmDOstQA4dMGCHbeihlyEIDMWmG62yJEiKE//7kXKdpN2KzYBt8euR
fKSyLPs8wiEo8wh4wqZTGou4V6Hm0wJa1cSiTkJdr8+GsoTRHuCotBayiWqQEYGtMCgfD1KjGYBe
5a3p0cRKiAe2NtLADikftnDco0ko/SFEVgEZ8aRC5GLux7i3BpSJ6J1H+i7A2CjiHq9z7JRZuuQq
siwTIvpxJYCeuWaBpwZdhB+yxy/eWz+ZvVSU8C4E9FFZkyxFsvCT/ZzL8gcz9aXVE14Yyp2M+2W0
y7n5mp0qN+avKXvbsyyzUqjeWR8hjGE+2iCE1W1tQ82hsCZN9UzlJr+/e/iab8WfqsmPI6pWeUPd
FrMsd4H/55poeO9n54COhUs+sZNEzNtg/wanpjpuqHJaxs76HtZryI/K3H7KJ/KDIhqcbJ7kI4ar
XL+sMgXnX0D+Te2Iy5xdP8yueSlQB/x/ED2BTAtyE3K4SYUN6AMNfbO63f4lBW3bUJPbTL+mjSxS
PyRfJkZRgj+VbFv+EzHFi5pKwUEepa4JslMnwkowSRCXI+m5XvEOvtuBrxHdhLalG0JofYBok6qj
YdN2dEngUlbC4PG60M1WEN0piu7Nq7on0mgyyUw3iV1etLo6r/81biWdQ9MWHFaePWZYaq+nmp+t
s3az+sj7eA0jfgPfeoN1
""")

MH_MAGIC = 0xfeedface
MH_CIGAM = 0xcefaedfe
MH_MAGIC_64 = 0xfeedfacf
MH_CIGAM_64 = 0xcffaedfe
FAT_MAGIC = 0xcafebabe
BIG_ENDIAN = '>'
LITTLE_ENDIAN = '<'
LC_LOAD_DYLIB = 0xc
maxint = majver == 3 and getattr(sys, 'maxsize') or getattr(sys, 'maxint')


class fileview(object):
    """
    A proxy for file-like objects that exposes a given view of a file.
    Modified from macholib.
    """

    def __init__(self, fileobj, start=0, size=maxint):
        if isinstance(fileobj, fileview):
            self._fileobj = fileobj._fileobj
        else:
            self._fileobj = fileobj
        self._start = start
        self._end = start + size
        self._pos = 0

    def __repr__(self):
        return '<fileview [%d, %d] %r>' % (
            self._start, self._end, self._fileobj)

    def tell(self):
        return self._pos

    def _checkwindow(self, seekto, op):
        if not (self._start <= seekto <= self._end):
            raise IOError("%s to offset %d is outside window [%d, %d]" % (
                op, seekto, self._start, self._end))

    def seek(self, offset, whence=0):
        seekto = offset
        if whence == os.SEEK_SET:
            seekto += self._start
        elif whence == os.SEEK_CUR:
            seekto += self._start + self._pos
        elif whence == os.SEEK_END:
            seekto += self._end
        else:
            raise IOError("Invalid whence argument to seek: %r" % (whence,))
        self._checkwindow(seekto, 'seek')
        self._fileobj.seek(seekto)
        self._pos = seekto - self._start

    def write(self, bytes):
        here = self._start + self._pos
        self._checkwindow(here, 'write')
        self._checkwindow(here + len(bytes), 'write')
        self._fileobj.seek(here, os.SEEK_SET)
        self._fileobj.write(bytes)
        self._pos += len(bytes)

    def read(self, size=maxint):
        assert size >= 0
        here = self._start + self._pos
        self._checkwindow(here, 'read')
        size = min(size, self._end - here)
        self._fileobj.seek(here, os.SEEK_SET)
        bytes = self._fileobj.read(size)
        self._pos += len(bytes)
        return bytes


def read_data(file, endian, num=1):
    """
    Read a given number of 32-bits unsigned integers from the given file
    with the given endianness.
    """
    res = struct.unpack(endian + 'L' * num, file.read(num * 4))
    if len(res) == 1:
        return res[0]
    return res


def mach_o_change(path, what, value):
    """
    Replace a given name (what) in any LC_LOAD_DYLIB command found in
    the given binary with a new name (value), provided it's shorter.
    """

    def do_macho(file, bits, endian):
        # Read Mach-O header (the magic number is assumed read by the caller)
        cputype, cpusubtype, filetype, ncmds, sizeofcmds, flags = read_data(file, endian, 6)
        # 64-bits header has one more field.
        if bits == 64:
            read_data(file, endian)
        # The header is followed by ncmds commands
        for n in range(ncmds):
            where = file.tell()
            # Read command header
            cmd, cmdsize = read_data(file, endian, 2)
            if cmd == LC_LOAD_DYLIB:
                # The first data field in LC_LOAD_DYLIB commands is the
                # offset of the name, starting from the beginning of the
                # command.
                name_offset = read_data(file, endian)
                file.seek(where + name_offset, os.SEEK_SET)
                # Read the NUL terminated string
                load = file.read(cmdsize - name_offset).decode()
                load = load[:load.index('\0')]
                # If the string is what is being replaced, overwrite it.
                if load == what:
                    file.seek(where + name_offset, os.SEEK_SET)
                    file.write(value.encode() + '\0'.encode())
            # Seek to the next command
            file.seek(where + cmdsize, os.SEEK_SET)

    def do_file(file, offset=0, size=maxint):
        file = fileview(file, offset, size)
        # Read magic number
        magic = read_data(file, BIG_ENDIAN)
        if magic == FAT_MAGIC:
            # Fat binaries contain nfat_arch Mach-O binaries
            nfat_arch = read_data(file, BIG_ENDIAN)
            for n in range(nfat_arch):
                # Read arch header
                cputype, cpusubtype, offset, size, align = read_data(file, BIG_ENDIAN, 5)
                do_file(file, offset, size)
        elif magic == MH_MAGIC:
            do_macho(file, 32, BIG_ENDIAN)
        elif magic == MH_CIGAM:
            do_macho(file, 32, LITTLE_ENDIAN)
        elif magic == MH_MAGIC_64:
            do_macho(file, 64, BIG_ENDIAN)
        elif magic == MH_CIGAM_64:
            do_macho(file, 64, LITTLE_ENDIAN)

    assert(len(what) >= len(value))
    do_file(open(path, 'r+b'))


if __name__ == '__main__':
    main()

## TODO:
## Copy python.exe.manifest
## Monkeypatch distutils.sysconfig
########NEW FILE########
__FILENAME__ = source-pylucid-boot
#-----------------------------------------------------------------------------
# PyLucid bootstrap script START

"""
    PyLucid virtual environment bootstrap
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    This file would be merged into pylucid-boot.py with the
    script create_bootstrap_script.py
"""


MENU_TXT = """
Please select how the pylucid own projects should be checkout:

(1) normal installation
(2) developer installation
"""
INSTALL_NORMAL = "normal"
INSTALL_DEV = "developer"
CHOICES = {"1":INSTALL_NORMAL, "2":INSTALL_DEV}
DEFAULT_MENU_CHOICE = CHOICES["1"]


class SysPath(object):
    """
    Helper to find a file in system path.
    >>> SysPath().find("python")
    '/usr/bin/python'
    """
    def __init__(self):
        self.sys_path = os.environ["PATH"].split(":")

    def find(self, filename):
        for path in self.sys_path:
            filepath = os.path.join(path, filename)
            if os.path.isfile(filepath):
                return filepath


class ColorOut(object):
    """
    Borrowed from Django:
    http://code.djangoproject.com/browser/django/trunk/django/utils/termcolors.py
    
    >>> c = ColorOut()
    >>> c.supports_colors()
    True
    >>> c.color_support = True
    >>> c.colorize('no color')
    'no color'
    >>> c.colorize('bold', opts=("bold",))
    '\\x1b[1mbold\\x1b[0m'
    >>> c.colorize("colors!", foreground="red", background="blue", opts=("bold", "blink"))
    '\\x1b[31;44;1;5mcolors!\\x1b[0m'
    """
    color_names = ('black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white')
    foreground_colors = dict([(color_names[x], '3%s' % x) for x in range(8)])
    background_colors = dict([(color_names[x], '4%s' % x) for x in range(8)])
    opt_dict = {'bold': '1', 'underscore': '4', 'blink': '5', 'reverse': '7', 'conceal': '8'}

    def __init__(self):
        self.color_support = self.supports_colors()

    def supports_colors(self):
        if sys.platform in ('win32', 'Pocket PC'):
            return False

        # isatty is not always implemented!
        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
            return True
        else:
            return False

    def colorize(self, text, foreground=None, background=None, opts=()):
        """
        Returns your text, enclosed in ANSI graphics codes.
        """
        if not self.color_support:
            return text

        code_list = []

        if foreground:
            code_list.append(self.foreground_colors[foreground])
        if background:
            code_list.append(self.background_colors[background])

        for option in opts:
            code_list.append(self.opt_dict[option])

        if not code_list:
            return text

        return "\x1b[%sm%s\x1b[0m" % (';'.join(code_list), text)
c = ColorOut()


def get_requirement_choice():
    """
    Display menu and select a number.
    """
    choice_keys = CHOICES.keys()
    input_msg = "%s (%s) (default: %s) " % (
        c.colorize("Please select:", opts=("bold",)),
        "/".join(choice_keys),
        DEFAULT_MENU_CHOICE
    )

    print MENU_TXT
    try:
        input = raw_input(input_msg)
    except KeyboardInterrupt:
        print(c.colorize("Abort, ok.", foreground="blue"))
        sys.exit()

    if input == "":
        return DEFAULT_MENU_CHOICE

    try:
        return CHOICES[input]
    except KeyError:
        print c.colorize("Error:", foreground="red"), "%r is not a valid choice!" % (
            c.colorize(number, opts=("bold",))
        )
        sys.exit(-1)


def extend_parser(parser):
    """
    extend optparse options.
    """
    parser.add_option("-t", "--type", type="string",
        dest="pip_type", default=None,
        help="pip install type: %s" % ", ".join(CHOICES.values())
    )



def adjust_options(options, args):
    """
    Display MENU_TXT
    """
    print c.colorize("PyLucid virtual environment bootstrap", opts=("bold", "underscore"))
    print

    try:
        home_dir = args[0]
    except IndexError:
        return # Error message would be created later

    print "Create PyLucid environment in:", c.colorize(home_dir, foreground="blue", opts=("bold",))
    print

    p = SysPath()

    git_path = p.find("git")
    if git_path:
        print "git found in:", c.colorize(git_path, opts=("bold",))
    else:
        print c.colorize("ERROR:", foreground="red", opts=("underscore",)),
        print "git not found in path!"

    if options.pip_type == None:
        options.pip_type = get_requirement_choice()
    elif options.pip_type not in CHOICES.values():
        print "pip type wrong!"
        sys.exit(-1)


class AfterInstall(object):
    def __init__(self, options, home_dir):
        self.options = options
        self.home_dir = home_dir
        self.abs_home_dir = os.path.abspath(home_dir)
        self.logfile = os.path.join(self.abs_home_dir, "PyLucid_pip.log")
        bin_dir = os.path.join(self.abs_home_dir, "bin")
        self.easy_install = os.path.join(bin_dir, "easy_install")
        self.pip_cmd = os.path.join(bin_dir, "pip")

        self.subprocess_defaults = {
            "cwd": bin_dir,
            "env": {
                "VIRTUAL_ENV": home_dir,
                "PATH": bin_dir + ":" + os.environ["PATH"],
            }
        }

        # NORMAL_INSTALLATION and DEVELOPER_INSTALLATION added by create_bootstrap_script.py!
        if self.options.pip_type == INSTALL_NORMAL:
            self.dev_install = False
        elif self.options.pip_type == INSTALL_DEV:
            self.dev_install = True
        else:
            raise ValueError

    def run_cmd(self, cmd):
        print "_" * 79
        for part in cmd:
            if part.startswith("/") or part.startswith("-"):
                print c.colorize(part, foreground="blue"),
            else:
                print c.colorize(part, foreground="blue", opts=("bold",)),
        print
        subprocess.call(cmd, **self.subprocess_defaults)
        print

    def run_pip(self, info_text, pip_lines):
        print
        print c.colorize(info_text, foreground="green", opts=("bold", "underscore"))

        for pip_line in pip_lines:
            assert isinstance(pip_line, basestring)
            cmd = [self.pip_cmd, "install", "--log=%s" % self.logfile, pip_line]
            
            if "PyLucid.git" in pip_line or "django-processinfo" in pip_line:
                # FIXME: How to handle this better?
                #
                # PyLucid setup.py does contains all dependencies and it will
                # fail on django-compressor==dev with python 2.6, see:
                #     https://github.com/jedie/PyLucid/issues/74
                #
                # django-processinfo has "Django>=1.3,<1.5" which is
                # Django v1.3.x - v1.4.x and will install django 1.3
                #
                cmd.append("--no-dependencies")
                
            self.run_cmd(cmd)

    def install_pip(self):
        print
        if os.path.isfile(self.pip_cmd):
            print c.colorize("update existing pip", foreground="green", opts=("bold", "underscore"))
            self.run_cmd([self.pip_cmd, 'install', "--upgrade", 'pip'])
        else:
            print c.colorize("install pip", foreground="green", opts=("bold", "underscore"))
            self.run_cmd([self.easy_install, '--always-copy', 'pip'])

    def install_packages(self):
        """
        DEVELOPER_INSTALLATION and NORMAL_INSTALLATION would be inserted
        via create_bootstrap_script.py
        """
        if self.dev_install:
            install_data = DEVELOPER_INSTALLATION
        else:
            install_data = NORMAL_INSTALLATION

        self.run_pip("install PyLucid projects", install_data)

    def verbose_symlink(self, source_path, dst_path):
        print("\nsymlink: %s\nto: %s\n" % (
            c.colorize(source_path, opts=("bold",)),
            c.colorize(dst_path, opts=("bold",)))
        )
        try:
            os.symlink(source_path, dst_path)
        except Exception, e:
            import traceback
            sys.stderr.write(traceback.format_exc())

    def symlink_scripts(self):
        """ symlink needfull scripts into env root directory """
        def symlink_pylucid_script(filename):
            source_path = os.path.join(self.abs_home_dir, "src", "pylucid", "scripts", filename)
            dst_path = os.path.join(self.abs_home_dir, filename)
            self.verbose_symlink(source_path, dst_path)

        # symlink some PyLucid scripts from pylucid/scripts/ into virtualenv root
        symlink_pylucid_script("create_page_instance.sh")

        if self.dev_install:
            symlink_pylucid_script("upgrade_pylucid_dev_env.sh")
        else:
            symlink_pylucid_script("upgrade_pylucid_env.sh")

#        # symlink "upgrade_virtualenv.py" from django-tools into  virtualenv root
#        filename = "upgrade_virtualenv.py"
#        source_path = os.path.join(self.abs_home_dir, "src", "django-tools", "django_tools", filename)
#        dst_path = os.path.join(self.abs_home_dir, filename)
#        self.verbose_symlink(source_path, dst_path)



def after_install(options, home_dir):
    """
    called after virtualenv was created and setuptools installed.
    Now we installed PyLucid and used libs/packages.
    """
    a = AfterInstall(options, home_dir)
    a.install_pip()
    a.install_packages()
    a.symlink_scripts()

    print
    print "PyLucid environment created in:", c.colorize(home_dir, foreground="blue", opts=("bold",))
    print
    print "Now you can create a new page instance, more info:"
    print "http://www.pylucid.org/permalink/355/create-a-new-page-instance"
    print

# PyLucid bootstrap script END
#-----------------------------------------------------------------------------

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

"""
    i18n forms
    ~~~~~~~~~~~

    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django import forms


class LanguageSelectForm(forms.Form):
    language = forms.ChoiceField()

    def __init__(self, languages, *args, **kwargs):
        """ Change form field data in a DRY way """
        super(LanguageSelectForm, self).__init__(*args, **kwargs)
        self.fields['language'].choices = [(lang.code, lang.description) for lang in languages]

########NEW FILE########
__FILENAME__ = models
# coding: utf-8

"""
    i18n models
    ~~~~~~~~~~~
    
    TODO: move language models from pylucid app to this app!
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    i18n unittests
    ~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - related test in pylucid_plugins/language/tests.py
    
    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
from django.utils.log import getLogger
import logging

if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#    tests = "pylucid.tests.test_i18n.TestI18n.test_other_language_in_url"

    from pylucid_project.tests import run_test_directly
    run_test_directly(tests,
        verbosity=2,
#        failfast=True,
        failfast=False,
    )
    sys.exit()

from django.conf import settings
from django.contrib.auth.models import Group
from django.contrib.sites.models import Site
from django.core.cache import cache

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import Language


class TestI18nWithCache(basetest.BaseLanguageTestCase):
    def test_other_language_in_url(self):
        """
        Request a English page as a German user.
        """
        #self.enable_i18n_debug()

        cache.clear()
        response = self.client.get("/en/welcome/", HTTP_ACCEPT_LANGUAGE="de-de,de;q=0.8,en-us;q=0.5,en;q=0.3")
        self.assertRedirect(response, url="http://testserver/de/welcome/", status_code=301)


class TestI18n(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.default_language - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def setUp(self):
        cache.clear()

    def test_no_accept_language(self):
        """
        request root page without any HTTP_ACCEPT_LANGUAGE
        the default language should be returned
        """
        response = self.client.get("/")
        self.assertRedirect(response, url="http://testserver/en/welcome/", status_code=302)

        response = self.client.get("/en/welcome/")
        self.assertStatusCode(response, 200)
        self.assertContentLanguage(response, self.default_language)

    def test_accept_language_de(self):
        """
        we must get german.
        """
        accept_languages = "de-de,de;q=0.8,en-us;q=0.5,en;q=0.3"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_languages)
        self.assertRedirect(response, url="http://testserver/de/welcome/", status_code=302)

        response = self.client.get("/de/welcome/", HTTP_ACCEPT_LANGUAGE=accept_languages)
        self.assertStatusCode(response, 200)
        self.assertContentLanguage(response, self.other_language)

    def test_fallback_language(self):
        """ the first part of a language code must be used as a fallback """
        accept_languages = "de-AT;q=0.9,de-de;q=0.8,en-us;q=0.5"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_languages)
        self.assertRedirect(response, url="http://testserver/de/welcome/", status_code=302)

    def test_no_lang_code(self):
        """
        test pylucid.views.resolve_url: url without a language code, should redirect to full url
        """
        response = self.client.get("/example-pages/markups/", HTTP_ACCEPT_LANGUAGE="de-de,de;q=0.8,en-us;q=0.5,en;q=0.3")
        self.assertRedirect(response, url="http://testserver/de/example-pages/markups/", status_code=302)

    def test_page_without_lang(self):
        """
        test pylucid.views.page_without_lang: url without a language code, should redirect to full url
        """
        response = self.client.get("/welcome/", HTTP_ACCEPT_LANGUAGE="de-de,de;q=0.8,en-us;q=0.5,en;q=0.3")
        self.assertRedirect(response, url="http://testserver/de/welcome/", status_code=302)

    def test_not_existing_language(self):
        """
        test pylucid.views.page_without_lang: url without a language code, should redirect to full url
        """
        response = self.client.get("/hr/", HTTP_ACCEPT_LANGUAGE="en-us;q=0.5,en;q=0.3")
        self.assertRedirect(response, url="http://testserver/en/", status_code=301)

    def test_permit_group(self):
        """
        Test if language.permitViewGroup works.
        """
        lang_code = "de"
        self.failUnless(lang_code != self.default_language.code)

        test_group = Group(name="language test")
        test_group.save()
        lang = Language.objects.get(code=lang_code)
        lang.permitViewGroup = test_group
        lang.save()

        response = self.client.get("/de/welcome/", HTTP_ACCEPT_LANGUAGE=lang_code)
        self.assertRedirect(response, url="http://testserver/en/welcome/", status_code=301)

    def test_no_language_on_site(self):
        """
        replace the site on all languages, with a not existing one.
        So we must fallback to the default language. 
        """
        test_site = Site(domain="not_exist.tld")
        test_site.save()

        # replace sites on all languages
        for language in Language.objects.all():
#            print language, language.sites.all()
            language.sites.clear()
            language.sites.add(test_site)
#            print language, language.sites.all()

        response = self.client.get("/")
        self.assertRedirect(response, url="http://testserver/en/welcome/", status_code=302)

        response = self.client.get("/en/welcome/")
        self.assertResponse(response,
            must_contain=("<body", 'Welcome to your PyLucid CMS =;-)'),
            must_not_contain=("Traceback",)
        )


class TestI18nMoreLanguages(basetest.BaseMoreLanguagesTestCase):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.default_language - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
        
    inherited from BaseMoreLanguagesTestCase:
        - created languages: "es", "es-ar", "pt", "hr"
        - self.languages - A dict with language code as keys and language instance as values
    """
    def setUp(self):
        cache.clear()

    def assertItsCroatian_with_en(self, response):
        """
        Croatian doesn't exist. But it's a supported language.
            - The ContentPage is in EN
            - gettext translations works and used croatian.
        """
        self.assertStatusCode(response, 200)
        self.assertContentLanguage(response, self.default_language)
        self.assertResponse(response,
            must_contain=(
                '<html lang="en">',
                '<h2 id="page_title">Welcome to your PyLucid CMS =;-)</h2>',
                '''<strong title="Current used language is 'Croatian'.">Croatian</strong>''',
                '>Prijavi se<', # 'Login in' translated in croatian 
            ),
            must_not_contain=("Traceback",)
        )

    def assertItsCroatian_with_de(self, response):
        """
        Croatian doesn't exist. But it's a supported language.
            - The ContentPage is in DE
            - gettext translations works and used croatian.
        """
        self.assertStatusCode(response, 200)
        self.assertContentLanguage(response, self.other_language)
        self.assertResponse(response,
            must_contain=(
                '<html lang="de">',
                '<h2 id="page_title">Willkommen auf deiner PyLucid CMS Seite =;-)</h2>',
                '''<strong title="Current used language is 'Croatian'.">Croatian</strong>''',
                '>Prijavi se<', # 'Login in' translated in croatian 
            ),
            must_not_contain=("Traceback",)
        )

    def assertItsNotCroation_its_de(self, response):
        self.assertContentLanguage(response, self.other_language)
        self.assertResponse(response,
            must_contain=(
                '<html lang="de">',
                '<h2 id="page_title">Willkommen auf deiner PyLucid CMS Seite =;-)</h2>',
                '''<strong title="Current used language is 'Deutsch'.">Deutsch</strong>''',

            ),
            must_not_contain=("Traceback",
                '''<strong title="Current used language is 'Croatian'.">Croatian</strong>''',
                'Prijavi se', # 'Login in' translated in croatian
            )
        )

    def test_language_exists(self):
        """ test if we really have more languages ;) """
        self.failUnless(Language.objects.count() >= 6)

    def test_cache_language_collision(self):
#        self.enable_i18n_debug()

#        logger = getLogger("PyLucidCacheMiddleware")
#        logger.setLevel(logging.DEBUG)
#        logger.addHandler(logging.StreamHandler())

        accept_language = "hr;q=0.8,en;q=0.3"

        response = self.client.get("/de/welcome/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/en/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=301)
        self.assertFalse(response._from_cache)

        # add hr to cache
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertItsCroatian_with_en(response)
        self.assertFalse(response._from_cache)

        # add de to cache
        response = self.client.get("/de/welcome/", HTTP_ACCEPT_LANGUAGE="de")
        self.assertItsNotCroation_its_de(response)
        self.assertFalse(response._from_cache)

        # check hr cached version:
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertItsCroatian_with_en(response)
        self.assertTrue(response._from_cache)

        # check de cached version:        
        response = self.client.get("/de/welcome/", HTTP_ACCEPT_LANGUAGE="de")
        self.assertItsNotCroation_its_de(response)
        self.assertTrue(response._from_cache)

    def test_accept_language_hr_fallback_to_en(self):
        accept_language = "hr;q=0.8,en;q=0.3"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/en/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=302)
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertItsCroatian_with_en(response)

    def test_accept_language_hr_fallback_to_de(self):
        accept_language = "hr;q=0.8,de;q=0.3"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/de/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=302)
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertItsCroatian_with_de(response)

    def test_accept_language_hr_fallback_to_default(self):
        accept_language = "hr;q=0.8,xx;q=0.3"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/en/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=302)
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertItsCroatian_with_en(response)

    def test_use_first_supported(self):
        """
        Croatian doesn't exist. But it's a supported language.
        We must get the ContentPage in system default language.
        But Croatian must be active.
        
        pt-br, Brazilian Portuguese is not installed
        the first useable language is Croatian.
        """
        accept_language = "not-exist;q=0.9,pt-br;q=0.8,hr;q=0.8,en;q=0.3"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/en/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=302)
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertItsCroatian_with_en(response)

    def test_not_exist_language(self):
        accept_language = "not-exist;q=0.9,ja;q=0.8"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/en/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=302)
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertContentLanguage(response, self.default_language)

    def test_fallback_language_anonymous(self):
        """
        "pt-br"  (Brazilian Portuguese) is not installed, but "pt" (Portuguese) exist.
        PyLucid must fallback to pt, even if it's not in accept language
        
        Anonymous users didn't get a information message, cause of not cacheable if messages exist
        """
        accept_language = "not-exist;q=0.9,pt-br;q=0.8"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/en/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=302)
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertContentLanguage(response, self.default_language)
        self.assertResponse(response,
            must_contain=(
                '''<strong title="Current used language is 'Portuguese'.">Portuguese</strong>''',
                '>Entrar<', # 'Login in' translated in Portuguese 
            ),
            must_not_contain=("Traceback",)
        )

    def test_fallback_language_user_information(self):
        """
        "pt-br"  (Brazilian Portuguese) is not installed, but "pt" (Portuguese) exist.
        PyLucid must fallback to pt, even if it's not in accept language
        """
        self.login("normal") # users get a messages

        accept_language = "not-exist;q=0.9,pt-br;q=0.8"
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE=accept_language)
        redirected_url = "http://testserver/en/welcome/"
        self.assertRedirect(response, url=redirected_url, status_code=302)
        response = self.client.get(redirected_url, HTTP_ACCEPT_LANGUAGE=accept_language)
        self.assertContentLanguage(response, self.default_language)
        self.assertResponse(response,
            must_contain=(
                '<a href="?auth=logout">Sair [normal test user]</a>', # logout in Portuguese
                '''<strong title="Current used language is 'Portuguese'.">Portuguese</strong>''',
                'PageMeta welcome doesn&#39;t exist in client favored language Portuguese, use English entry.',
            ),
            must_not_contain=("Traceback",)
        )



########NEW FILE########
__FILENAME__ = translate
# coding: utf-8

"""
    google translation service
    ~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    
    Note:
        Google Translate API v1 will be shut off completely on (December 1, 2011)
"""

import re, urllib

from django.utils import simplejson
from pylucid_project import VERSION_STRING


class UrlOpener(urllib.FancyURLopener):
    version = "pylucid/%s" % VERSION_STRING


BASE_URL = "http://ajax.googleapis.com/ajax/services/language/translate"


def translate(phrase, src="uk", to="en", debug=False):
    """
    https://code.google.com/apis/language/translate/overview.html
    
    based on:
    http://code.google.com/p/py-gtranslate/source/browse/trunk/gtrans.py
    """
    phrase = phrase.replace("\r\n", "<br />").replace("\r", "<br />").replace("\n", "<br />")

    data = urllib.urlencode({'v': '1.0', 'langpair': '%s|%s' % (src, to), 'q': phrase.encode('utf-8')})

    url_opener = UrlOpener()
    url = '%s?%s' % (BASE_URL, data)
    if debug:
        print "Request %r" % url
    f = url_opener.open(url)
    resp = simplejson.load(f)

    if debug:
        print "Response: %s" % repr(resp)

    content = ""
    error = None

    if resp["responseStatus"] != 200:
        error = resp["responseDetails"]
    else:
        try:
            content = resp['responseData']['translatedText']
        except KeyError, err:
            error = str(err)
        else:
            content = content.replace("<br />", "\n")

    return content, error


def prefill(source_form, dest_form, source_language, dest_language, only_fields=None, exclude_fields=None, debug=False):
    if exclude_fields is None:
        exclude_fields = ()

    filled_fields = []
    errors = []
    for field_name, source_value in source_form.cleaned_data.items():
        if only_fields is not None and field_name not in only_fields:
            continue
        if field_name in exclude_fields:
            continue

        if not isinstance(source_value, basestring):
            errors.append(
                "Can't translate '%(field_name)s', it's not a string. (value: %(value)s)" % {
                    "field_name":field_name, "value":repr(source_value)
                }
            )
            continue

        if not source_value:
            # Skip empty fields
            continue

        dest_key = dest_form.add_prefix(field_name)
        dest_value = dest_form.data[dest_key]
        if dest_value:
            # Don't overwrite content from the user.
            continue

        try:
            dest_value, error = translate(
                source_value, src=source_language.code, to=dest_language.code, debug=debug
            )
        except ValueError, err:
            errors.append(
                "Can't translate %(field_name)s with google: %(err)s" % {
                    "field_name":field_name, "err":err
                }
            )
        else:
            if error is not None:
                errors.append(error)
            if debug:
                print "%r translated to %r" % (source_value, dest_value)
            filled_fields.append(field_name)
            dest_form.data._mutable = True
            dest_form.data[dest_key] = dest_value
            dest_form.data._mutable = False
            dest_form.initial[field_name] = dest_value
            dest_form.fields[field_name].widget.attrs['class'] = 'auto_translated'

    return dest_form, filled_fields, errors


if __name__ == "__main__":
    print translate(phrase=u"Der bersetzungsdienst von google...\n...ist das toll.", src="de", to="en")

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    i18n views
    ~~~~~~~~~~~
    
    TODO: move language views to this app!
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.utils.translation import ugettext as _
from django.contrib import messages
from django import http

from pylucid_project.apps.pylucid.models.language import Language
from pylucid_project.apps.i18n.forms import LanguageSelectForm


def select_language(request, cancel_url, source_language, source_entry_name):
    """
    choose the translation destination language.
    If only one other language is available -> return it directly.
    """
    if "cancel" in request.GET:
        messages.info(request, _("Choose translate aborted, ok."))
        return http.HttpResponseRedirect(cancel_url)

    other_languages = Language.objects.exclude(code=source_language.code)
    if len(other_languages) == 0:
        # should not happen
        messages.error(request, "Error: There exist only one Language!")
        return http.HttpResponseRedirect(cancel_url)
    elif len(other_languages) == 1:
        # Only one other language available, so the user must not choose one ;)
        return other_languages[0]
    else:
        # There are more than one other language -> display a form for choose one.
        if "language" in request.GET:
            form = LanguageSelectForm(other_languages, request.GET)
            if form.is_valid():
                lang_code = form.cleaned_data["language"]
                for lang in other_languages:
                    if lang.code == lang_code:
                        return lang
                raise RuntimeError() # should never happen
        else:
            default_lang_entry = Language.objects.get_or_create_default(request)
            form = LanguageSelectForm(other_languages, initial={
                    "language": default_lang_entry.code, # FIXME: Seems not to work
                })
        context = {
            "title": _("Select destination language for translation of '%(name)s' (%(desc_lang)s):") % {
                "name": source_entry_name,
                "desc_lang": source_language.description
            },
            "template_name": "i18n/select_translate_language.html",
            "form": form,
            "other_languages": other_languages,
        }
        return context

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    PyLucid.admin
    ~~~~~~~~~~~~~

    Register all PyLucid model in django admin interface.

    TODO:
        * if http://code.djangoproject.com/ticket/3400 is implement:
            Add site to list_filter for e.g. PageMeta, PageContent etc.
        * split this file
    
    :copyleft: 2008-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

from django import forms
from django.conf import settings
from django.conf.urls.defaults import patterns, url
from django.contrib import admin, messages
from django.contrib.admin.sites import NotRegistered
from django.contrib.admin.util import unquote
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from django.http import HttpResponse, HttpResponseRedirect
from django.template.loader import render_to_string
from django.utils.timesince import timesince
from django.utils.translation import ugettext_lazy as _

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from dbtemplates.admin import TemplateAdmin, TemplateAdminForm
from dbtemplates.models import Template

from pylucid_project.apps.pylucid import models
from pylucid_project.apps.pylucid.base_admin import BaseAdmin
from pylucid_project.apps.pylucid.forms.pagemeta import PageMetaForm
from pylucid_project.apps.pylucid.markup import hightlighter
from pylucid_project.apps.pylucid.markup.admin import MarkupPreview
from django.shortcuts import render_to_response
from pylucid_project.apps.pylucid.decorators import render_to
from django.template.context import RequestContext


class PageTreeAdmin(BaseAdmin, CompareVersionAdmin):
    #prepopulated_fields = {"slug": ("title",)}
    list_display = (
        "id", "parent", "slug", "showlinks", "site", "view_on_site_link", "lastupdatetime", "lastupdateby"
    )
    list_display_links = ("id", "slug")
    list_filter = (
        "site", "page_type", "permitViewGroup", "showlinks", "createby", "lastupdateby", "design",
    )
    date_hierarchy = 'lastupdatetime'
    search_fields = ("slug",)

    def delete_view(self, request, object_id, extra_context=None):
        """
        Redirect to parent page, after deletion.
        """
        if request.POST: # The user has already confirmed the deletion.
            pagetree = self.get_object(request, unquote(object_id))
            parent = pagetree.parent

        response = super(PageTreeAdmin, self).delete_view(request, object_id, extra_context)
        if request.POST and isinstance(response, HttpResponseRedirect):
            # Object has been deleted.
            if parent is None:
                url = "/"
            else:
                url = parent.get_absolute_url()
            return HttpResponseRedirect(url)

        return response

admin.site.register(models.PageTree, PageTreeAdmin)


class BanEntryAdmin(admin.ModelAdmin):
    list_display = list_display_links = ("ip_address", "createtime",)
    search_fields = ("ip_address",)
admin.site.register(models.BanEntry, BanEntryAdmin)


class LanguageAdmin(CompareVersionAdmin):
    list_display = ("code", "description", "site_info", "permitViewGroup")
    list_display_links = ("code", "description")
    list_filter = ("permitViewGroup",)
admin.site.register(models.Language, LanguageAdmin)


class LogEntryAdmin(BaseAdmin):
    def age(self, obj):
        """ view on site link in admin changelist, try to use complete uri with site info. """
        createtime = obj.createtime
        return timesince(createtime)

    age.short_description = _("age")

    list_display = (
        "createtime", "age", "createby", "view_on_site_link", "app_label", "action", "message"
    )
    list_filter = (
        "site", "app_label", "action", "createby", "remote_addr",
    )
    search_fields = ("app_label", "action", "message", "long_message", "data")
admin.site.register(models.LogEntry, LogEntryAdmin)


#class OnSitePageMeta(models.PageMeta):
#    def get_site(self):
#        return self.page.site
#    site = property(get_site)
#    class Meta:
#        proxy = True



class PageMetaAdmin(BaseAdmin, CompareVersionAdmin):
    form = PageMetaForm
    list_display = ("id", "get_title", "get_site", "view_on_site_link", "lastupdatetime", "lastupdateby",)
    list_display_links = ("id", "get_title")
    list_filter = ("language", "createby", "lastupdateby", "tags")#"keywords"
    date_hierarchy = 'lastupdatetime'
    search_fields = ("description", "keywords")

admin.site.register(models.PageMeta, PageMetaAdmin)


class PageContentInline(admin.StackedInline):
    model = models.PageContent

class PageContentAdmin(BaseAdmin, MarkupPreview, CompareVersionAdmin):
    """
    inherited attributes from BaseAdmin:
        view_on_site_link -> html link with the absolute uri.
        
    inherited from MarkupPreview:
        ajax_markup_preview() -> the markup content ajax preview view
        get_urls()            -> add ajax view to admin urls 
    """
    list_display = ("id", "get_title", "get_site", "view_on_site_link", "lastupdatetime", "lastupdateby",)
    list_display_links = ("id", "get_title")
    list_filter = ("markup", "createby", "lastupdateby",)
    date_hierarchy = 'lastupdatetime'
    search_fields = ("content",) # it would be great if we can add "get_title"

admin.site.register(models.PageContent, PageContentAdmin)


class PluginPageAdmin(BaseAdmin, CompareVersionAdmin):
    list_display = (
        "id", "get_plugin_name", "app_label",
        "get_site", "view_on_site_link", "lastupdatetime", "lastupdateby",
    )
    list_display_links = ("get_plugin_name", "app_label")
    list_filter = ("createby", "lastupdateby",)
    date_hierarchy = 'lastupdatetime'
    search_fields = ("app_label",)

admin.site.register(models.PluginPage, PluginPageAdmin)


#------------------------------------------------------------------------------


class ColorAdmin(CompareVersionAdmin):
    def preview(self, obj):
        return '<span style="background-color:#%s;" title="%s">&nbsp;&nbsp;&nbsp;</span>' % (
            obj.value, obj.name
        )
    preview.short_description = 'color preview'
    preview.allow_tags = True

    # disable delete all admin actions
    # User should not use delete colors, because model.delete() would
    # not called, read "warning" box on:
    # http://docs.djangoproject.com/en/dev/ref/contrib/admin/actions/
    actions = None

    list_display = ("id", "name", "value", "preview", "colorscheme")
    list_filter = ("colorscheme",)

admin.site.register(models.Color, ColorAdmin)

class ColorInline(admin.TabularInline):
    model = models.Color
    extra = 0


class ColorSchemeAdmin(CompareVersionAdmin):

    def clone(self, request, object_id):
        """ Clone a color scheme """
        colorscheme = models.ColorScheme.objects.get(id=object_id)
        old_name = colorscheme.name
        new_name = old_name + "_cloned"

        colors = models.Color.objects.filter(colorscheme=colorscheme)

        colorscheme.pk = None # make the object "new" ;)
        colorscheme.name = new_name
        colorscheme.save(force_insert=True)

        for color in colors:
            color.pk = None # make the object "new" ;)
            color.colorscheme = colorscheme
            color.save(force_insert=True)

        messages.success(request,
            _("Colorscheme %(old_name)s cloned to %(new_name)s") % {
                "old_name": old_name, "new_name": new_name
            }
        )
        url = reverse("admin:pylucid_colorscheme_changelist")
        return HttpResponseRedirect(url)

    def cleanup(self, request, object_id):
        """ remove all unused colors """

        colorscheme = models.ColorScheme.objects.get(id=object_id)
        colorscheme.cleanup(request)

        url = reverse("admin:pylucid_colorscheme_change", args=(object_id,))
        return HttpResponseRedirect(url)

    def get_urls(self):
        urls = super(ColorSchemeAdmin, self).get_urls()
        my_urls = patterns('',
            (r'^(.+?)/clone/$', self.admin_site.admin_view(self.clone)),
            (r'^(.+?)/cleanup/$', self.admin_site.admin_view(self.cleanup)),
        )
        return my_urls + urls

    def preview(self, obj):
        colors = models.Color.objects.all().filter(colorscheme=obj)
        context = {
            "colorscheme": obj,
            "colors": colors
        }
        return render_to_string("admin/pylucid/includes/colorscheme_preview.html", context)
    preview.short_description = 'color scheme preview'
    preview.allow_tags = True

    def design_usage_info(self, obj):
        designs = models.Design.objects.all().filter(colorscheme=obj)
        context = {"designs": designs}
        return render_to_string("admin/pylucid/includes/design_usage_info.html", context)
    design_usage_info.short_description = 'used in designs'
    design_usage_info.allow_tags = True

    change_list_template = "admin/pylucid/change_list_with_design_link.html"
    list_display = ("id", "name", "preview", "design_usage_info", "lastupdatetime", "lastupdateby")
    list_display_links = ("name",)
    search_fields = ("name",)
    inlines = [ColorInline, ]

admin.site.register(models.ColorScheme, ColorSchemeAdmin)


#------------------------------------------------------------------------------


class DesignAdminForm(forms.ModelForm):
    class Meta:
        model = models.Design

    def clean(self):
        """ Check if all pages exist on the site. """
        cleaned_data = self.cleaned_data

        if "sites" in cleaned_data:
            sites = cleaned_data["sites"]
            queryset = models.PageTree.objects.all().filter(design=self.instance).exclude(site__in=sites)
            page_count = queryset.count()
            if page_count > 0:
                site = queryset[0].site
                msg = _("Error: At least %(count)s page(s) used this design on site %(site)s!") % {
                    "count": page_count, "site": site
                }
                self._errors["sites"] = self.error_class([msg])

        return cleaned_data


class DesignAdmin(CompareVersionAdmin):
    def page_count(self, obj):
        queryset = models.PageTree.objects.all().filter(design=obj)
        count = queryset.count()
        if count > 0:
            first_page = queryset[0]
        else:
            first_page = None

        context = {
            "design": obj,
            "count":count,
            "first_page": first_page,
        }
        return render_to_string("admin/pylucid/design_page_count.html", context)

    page_count.short_description = 'page count'
    page_count.allow_tags = True

    def template_usage(self, obj):
        template_path = obj.template
        try:
            dbtemplate_entry = Template.objects.get(name=template_path)
        except Template.DoesNotExist:
            dbtemplate_entry = None

        context = {
            "design": obj,
            "dbtemplate_entry":dbtemplate_entry,
        }
        return render_to_string("admin/pylucid/design_template_info.html", context)

    template_usage.short_description = 'Template'
    template_usage.allow_tags = True
    template_usage.admin_order_field = "template"

    def color_info(self, obj):
        colorscheme = obj.colorscheme
        colors = models.Color.objects.all().filter(colorscheme=colorscheme)
        context = {
            "add_colorscheme_name": True,
            "colorscheme": colorscheme,
            "colors": colors
        }
        return render_to_string("admin/pylucid/includes/colorscheme_preview.html", context)

    color_info.short_description = 'color scheme information'
    color_info.allow_tags = True
    color_info.admin_order_field = "colorscheme"

    def headfiles_info(self, obj):
        colorscheme = obj.colorscheme
        colors = models.Color.objects.all().filter(colorscheme=colorscheme)
        headfiles = obj.headfiles.all()
        for headfile in headfiles:
            if headfile.render:
                headfile.absolute_url = headfile.get_absolute_url(colorscheme)
            else:
                headfile.absolute_url = headfile.get_absolute_url()

        context = {
            "design": obj,
            "headfiles": headfiles,
            "colorscheme": obj.colorscheme,
            "colors": colors,
        }
        return render_to_string("admin/pylucid/design_headfiles_info.html", context)

    headfiles_info.short_description = 'used headfiles'
    headfiles_info.allow_tags = True

    form = DesignAdminForm
    list_display = ("id", "name", "page_count", "template_usage", "color_info", "headfiles_info", "site_info", "lastupdatetime", "lastupdateby")
    list_display_links = ("name",)
    ordering = ("name",)
    list_filter = ("sites", "template", "colorscheme", "createby", "lastupdateby")
    search_fields = ("name", "template", "colorscheme")

admin.site.register(models.Design, DesignAdmin)


#------------------------------------------------------------------------------


class EditableHtmlHeadFileAdminForm(forms.ModelForm):
    class Meta:
        model = models.EditableHtmlHeadFile
    class Media:
        js = (
            settings.STATIC_URL + "PyLucid/codemirror_editable_headfile.js",
        )

    def __init__(self, *args, **kwargs):
        super(EditableHtmlHeadFileAdminForm, self).__init__(*args, **kwargs)
        # Make mimetype optinal, so the user can leave to empty and auto_mimetype
        # would be used in model.clean_fields()
        self.fields["mimetype"].required = False


class EditableHtmlHeadFileAdmin(CompareVersionAdmin):
    form = EditableHtmlHeadFileAdminForm
    change_list_template = "admin/pylucid/change_list_with_design_link.html"
    list_display = ("id", "filepath", "render", "description", "lastupdatetime", "lastupdateby")
    list_display_links = ("filepath", "description")
    list_filter = ("render",)

admin.site.register(models.EditableHtmlHeadFile, EditableHtmlHeadFileAdmin)


#-----------------------------------------------------------------------------


class UserProfileAdmin(CompareVersionAdmin):
    class SiteForm(forms.Form):
        _selected_action = forms.CharField(widget=forms.MultipleHiddenInput)
        sites = forms.ModelMultipleChoiceField(Site.objects)

    def set_site(self, request, queryset):
        if "cancel" in request.POST:
            # User has clicked on the cancel form submit button
            self.message_user(request, "Cancelled 'set site'")
            return HttpResponseRedirect(request.get_full_path())

        if "save" in request.POST:
            form = self.SiteForm(request.POST)
            if form.is_valid():
                sites = form.cleaned_data["sites"]
                count = 0
                for userprofile in queryset:
                    userprofile.sites = sites
                    userprofile.save()
                    count += 1
                self.message_user(request, _("Saved sites to %i userprofiles." % count))
                return HttpResponseRedirect(request.get_full_path())
        else:
            selected_action = request.POST.getlist(admin.ACTION_CHECKBOX_NAME)
            form = self.SiteForm(initial={"_selected_action": selected_action})

        context = {
            "queryset": queryset,
            "form": form,
            "abort_url": request.get_full_path(),
            "form_url":request.get_full_path(),
        }
        return render_to_response("admin/set_user_sites.html", context, context_instance=RequestContext(request))

    set_site.short_description = "Change the site for selected users."

    list_display = ("id", "user", "site_info", "lastupdatetime", "lastupdateby")
    list_display_links = ("user",)
    list_filter = ("sites",)
    actions = ["set_site"]

admin.site.register(models.UserProfile, UserProfileAdmin)



#-----------------------------------------------------------------------------
# Add ID to site admin by "reregister"
# FIXME: Is there a simpler way to do this?

class SiteAdmin(admin.ModelAdmin):
    list_display = ("id", 'domain', 'name')
    search_fields = ("id", 'domain', 'name')
    list_display_links = ("id", "domain")

admin.site.unregister(Site)
admin.site.register(Site, SiteAdmin)


#-----------------------------------------------------------------------------
# Use CompareVersionAdmin and own ColorMirror editor in dbtemplates

class DBTemplatesAdminAdminForm(TemplateAdminForm):
    class Media:
        js = (settings.STATIC_URL + "PyLucid/codemirror_dbtemplates.js",)

#    def __init__(self, *args, **kwargs):
#        super(DBTemplatesAdminAdminForm, self).__init__(*args, **kwargs)



class DBTemplatesAdmin(CompareVersionAdmin, TemplateAdmin):
    def _filesystem_template_path(self, template_name):
        """ return absolute filesystem path to given template name """
        for dir in settings.TEMPLATE_DIRS:
            abs_path = os.path.join(dir, template_name)
            if os.path.isfile(abs_path):
                return abs_path

    def _get_filesystem_template(self, template_path):
        """ return template content from filesystem """
        f = file(template_path, "r")
        content = f.read()
        f.close()
        return content

    def diff_view(self, request, object_id):
        """
        AJAX view to display a diff between current edited content
        and the template content from filesystem, if found.
        """
        if request.is_ajax() != True or request.method != 'POST' or "content" not in request.POST:
            return HttpResponse("ERROR: Wrong request")

        edit_content = request.POST["content"]

        try:
            dbtemplate_obj = Template.objects.only("name").get(id=object_id)
        except Template.DoesNotExist, err:
            msg = "Template with ID %r doesn't exist!" % object_id
            return HttpResponse(msg)

        templatename = dbtemplate_obj.name

        template_path = self._filesystem_template_path(templatename)
        if template_path is None:
            msg = "Error: Template %r not found on filesystem." % templatename
            return HttpResponse(msg)

        try:
            filesystem_template = self._get_filesystem_template(template_path)
        except Exception, err:
            msg = "Error: Can't read %r: %s" % (template_path, err)
            return HttpResponse(msg)

        diff_html = hightlighter.get_pygmentize_diff(filesystem_template, edit_content)

        return HttpResponse(diff_html)

    def get_urls(self):
        """Returns the additional urls."""
        urls = super(DBTemplatesAdmin, self).get_urls()
        admin_site = self.admin_site
        opts = self.model._meta
        info = opts.app_label, opts.module_name,
        new_urls = patterns("",
            url("^(.+)/diff/$", admin_site.admin_view(self.diff_view), name='%s_%s_diff' % info),
        )
        return new_urls + urls

    def usage_info(self, obj):
        designs = models.Design.objects.all().filter(template=obj.name)

        context = {
            "designs": designs,
        }
        return render_to_string("admin/pylucid/dbtemplate_usage_info.html", context)

    usage_info.short_description = 'used in PyLucid design'
    usage_info.allow_tags = True

    form = DBTemplatesAdminAdminForm
    change_list_template = "admin/pylucid/change_list_with_design_link.html"
    list_display = ('name', "usage_info", 'creation_date', 'last_changed', 'site_list')
    ordering = ("-last_changed",)

try:
    admin.site.unregister(Template)
except NotRegistered, err:
    pass
admin.site.register(Template, DBTemplatesAdmin)

########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8


"""
    PyLucid App. settings
    ~~~~~~~~~~~~~~~~~~~~~
    
    settings witch only used in the PyLucid app.
    
    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


# Every Plugin output gets a html DIV or SPAN tag around.
# Here you can defined witch CSS class name the tag should used:
CSS_PLUGIN_CLASS_NAME = "PyLucidPlugins"

HEADFILE_INLINE_TEMPLATES = "pylucid/headfile_%s_inline.html"
HEADFILE_LINK_TEMPLATES = "pylucid/headfile_%s_link.html"
HEAD_FILES_URL_PREFIX = "headfile"

PERMALINK_URL_PREFIX = "permalink"
OLD_PERMALINK_PREFIX = "_goto"

# i18n stuff:
I18N_DEBUG = False # Display many info around detecting current language

HTTP_GET_VIEW_NAME = "http_get_view"

# All PyLucid media files stored in a sub directory under the django media
# path. Used for building filesystem path and URLs.
# filesystem path: STATIC_ROOT + PYLUCID_MEDIA_DIR
# URLs: STATIC_URL + PYLUCID_MEDIA_DIR
PYLUCID_MEDIA_DIR = "PyLucid" # Without slashes at begin/end!

AUTH_LOGOUT_GET_VIEW = "auth=logout"
AUTH_GET_VIEW = "auth=login"
AUTH_NEXT_URL = "%%(path)s?%s&next_url=%%(next_url)s" % AUTH_GET_VIEW
# e.g.: settings.PYLUCID.AUTH_NEXT_URL % {"path": request.path, "next_url": url}


#UPDATE_LIST_FILENAME = "update_list"
#UPDATE_LIST_VIEWNAME = "get_update_list"
SEARCH_FILENAME = "search"
SEARCH_CLASSNAME = "Search"

# plugin update hook
UPDATE08_PLUGIN_FILENAME = "update"
UPDATE08_PLUGIN_VIEWNAME = "update08"

# Number of seconds after the IP ban cleanup method would be called.
# This removed the outdated IPs from the ban list.
CLEANUP_IP_BAN = 60
# How long should a IP address banned in minutes:
BAN_RELEASE_TIME = 15

# internal placeholder: The PyLucid TOC Plugin insert it and the HeadlineAnchorMiddleware
# replaced it with the Table of contents html code.
TOC_PLACEHOLDER = u"<!-- lucidTag TOC -->"

########NEW FILE########
__FILENAME__ = base_admin
# coding: utf-8

from django.utils.translation import ugettext_lazy as _
from django.template.loader import render_to_string
from django.http import HttpResponseRedirect
from django.contrib import admin, messages
from django.conf import settings


class BaseAdmin(admin.ModelAdmin):
    def view_on_site_link(self, obj):
        """ view on site link in admin changelist, try to use complete uri with site info. """
        absolute_url = obj.get_absolute_url()
        if hasattr(obj, "get_absolute_uri"):
            url = obj.get_absolute_uri() # complete uri contains protocol and site domain.
        else:
            url = absolute_url

        context = {"absolute_url": absolute_url, "url": url}
        html = render_to_string('admin/pylucid/includes/view_on_site_link.html', context)
        return html

    def response_change(self, request, obj):
        """
        Don't leave in admin, after edit a object -> goto obj.get_absolute_url()
        """
        response = super(BaseAdmin, self).response_change(request, obj)

        if not hasattr(obj, "get_absolute_url"):
            return response

        if isinstance(response, HttpResponseRedirect):
            url = response["location"]
            #messages.debug(request, "redirect to %r" % url)
            if url in ('../', '../../../'):
                # Don't got to admin index or change-list page -> goto changed object
                try:
                    # FIXME: We should check if the obj is on the current site!
                    # See: https://github.com/jedie/PyLucid/issues/60
                    url = obj.get_absolute_url()
                except Exception, err:
                    if settings.DEBUG or request.user.is_staff:
                        messages.error(request, "Can't get_absolute_url() from object %r: %s" % (obj, err))

                return HttpResponseRedirect(url)
        return response

    view_on_site_link.short_description = _("View on site")
    view_on_site_link.allow_tags = True


class RedirectToPageAdmin(object):
    """
    redirect to the site, after model was added or changed.
    The model object must have get_absolute_url() method!
    """
    def redirect_to_page(self, obj):
        url = obj.get_absolute_url()
        return HttpResponseRedirect(url)

    def response_add(self, request, obj, **kwargs):
        """ goto site after creation """
        response = super(RedirectToPageAdmin, self).response_add(request, obj, **kwargs) # create user message
        if response['Location'] == "../":
            # goto site, if we redirectet to the change list
            response = self.redirect_to_page(obj)
        return response

    def response_change(self, request, obj, **kwargs):
        """ goto site after editing """
        response = super(RedirectToPageAdmin, self).response_change(request, obj, **kwargs) # create user message
        if response['Location'] == "../":
            # goto site, if we redirectet to the change list
            response = self.redirect_to_page(obj)
        return response

########NEW FILE########
__FILENAME__ = context_processors
# coding: utf-8


"""
setup some "static" variables
"""


import datetime
try:
    from functools import wraps
except ImportError:
    from django.utils.functional import wraps  # Python 2.3, 2.4 fallback.

from django.conf import settings
from django.contrib import messages
from django.contrib.sites.models import Site
from django.utils.safestring import mark_safe

from dbtemplates.models import Template

from pylucid_project import VERSION_STRING
from pylucid_project.utils import slug


class NowUpdateInfo(object):
    """
    For adding page update information into context by pylucid context processor
    Useful in plugins views witch allays generate new content (e.g. search result page) 
    """
    def __init__(self, request):
        self.createby = request.user
        self.lastupdateby = request.user
        self.createtime = self.lastupdatetime = datetime.datetime.now()


def add_plugin_info(view_function):
    """ Add css anchor into context. Used information from lucidTagNode. """
    @wraps(view_function)
    def _inner(request):
        context = view_function(request)

        if getattr(request, "plugin_name", None) != None:
            # Add css anchor info
            plugin_name = request.plugin_name
            method_name = request.method_name

            if not hasattr(request, "css_id_list"):
                request.css_id_list = []

            css_plugin_id = plugin_name + u"_" + method_name
            existing_slugs = request.css_id_list
            css_plugin_id = slug.makeUniqueSlug(css_plugin_id, existing_slugs)

            request.css_id_list.append(css_plugin_id)

            context["css_plugin_id"] = css_plugin_id
            context["css_plugin_class"] = plugin_name

        return context
    return _inner


@add_plugin_info
def pylucid(request):
    """
    A django TEMPLATE_CONTEXT_PROCESSORS
    http://www.djangoproject.com/documentation/templates_python/#writing-your-own-context-processors
    """
    if hasattr(request.PYLUCID, "context"):
        # reuse a exsiting context, so we save a few database requests
        context = request.PYLUCID.context
    else:
        # create a new context
        context = {
            "powered_by": mark_safe('<a href="http://www.pylucid.org">PyLucid v%s</a>' % VERSION_STRING),
            # This value would be changed in index._render_cms_page(), if the
            # plugin manager or any plugin set request.anonymous_view = False
            "robots": "index,follow", # TODO: remove in v0.9, see: ticket:161

            "CSS_PLUGIN_CLASS_NAME": settings.PYLUCID.CSS_PLUGIN_CLASS_NAME,

            "current_site": Site.objects.get_current(),
            "sites": Site.objects.all(),

            "PYLUCID": request.PYLUCID,
        }

        pagetree = getattr(request.PYLUCID, "pagetree", None)
        if pagetree:
            if "design_switch_pk" in request.session:
                # The user has switch the design with pylucid_plugins.design
                from pylucid_project.apps.pylucid.models import Design # import here, agains import loops

                design_id = request.session["design_switch_pk"]
                try:
                    pagetree.design = Design.on_site.get(id=design_id)
                except Design.DoesNotExist, err:
                    messages.error(request, "Can't switch to design with ID %i: %s" % (design_id, err))
                    del(request.session["design_switch_pk"])

            template_name = pagetree.design.template
            # Used e.g.: in plugin templates: {% extends template_name %}
            context["template_name"] = template_name

            # Add the dbtemplates entry.
            # Used in pylucid_admin_menu.html for generating the "edit page template" link
            try:
                context["template"] = Template.on_site.get(name=template_name)
            except Template.DoesNotExist:
                context["template"] = None

        pagemeta = getattr(request.PYLUCID, "pagemeta", None)
        if pagemeta:
            context.update({
                "pagemeta": pagemeta,
                "page_title": pagemeta.get_title(),
                "page_keywords": pagemeta.keywords,
                "page_description": pagemeta.description,
                "page_robots": pagemeta.robots,
                "page_language": pagemeta.language.code,
                "page_permalink": pagemeta.get_permalink(),
                "page_absolute_url": pagemeta.get_absolute_url(),
            })

    # Update page updateinfo (a plugin can change it)
    if hasattr(request.PYLUCID, "updateinfo_object"):
        for itemname in ("createby", "lastupdateby", "createtime", "lastupdatetime"):
            context["page_%s" % itemname] = getattr(request.PYLUCID.updateinfo_object, itemname, None)

    return context

########NEW FILE########
__FILENAME__ = decorators
# coding: utf-8

"""
    PyLucid decorators
    ~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import sys
import warnings
from pylucid_project.apps.pylucid.shortcuts import bad_request
try:
    from functools import wraps
except ImportError:
    from django.utils.functional import wraps  # Python 2.3, 2.4 fallback.

from django.conf import settings
from django.contrib import messages
from django.core.exceptions import PermissionDenied
from django.http import HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.models import LogEntry


def check_permissions(superuser_only, permissions=(), must_staff=None):
    """
    Protect a view and limit it to users witch are log in and has the permissions.
    If the user is not log in -> Redirect him to a log in view with a next_url back to the requested page.
    
    must_staff is optional: User must be staff user, if no permissions given
    
    Usage:
    --------------------------------------------------------------------------
    from pylucid_project.apps.pylucid.decorators import check_permissions
    
    @check_permissions(superuser_only=False, permissions=(u'appname.add_modelname', u'appname.change_modelname'))
    def my_view(request):
        ...
        
    @check_permissions(superuser_only=False, must_staff=True)
    def view_only_for staff_members(request):
        ...
    --------------------------------------------------------------------------
    """
    assert isinstance(superuser_only, bool)
    assert isinstance(permissions, (list, tuple))

    if must_staff is None:
        if permissions:
            must_staff = False
        else:
            must_staff = True

    assert isinstance(must_staff, bool)

    def _inner(view_function):
        @wraps(view_function)
        def _check_permissions(request, *args, **kwargs):
            user = request.user

            if not user.is_authenticated():
                msg = _("Permission denied for anonymous user. Please log in.")
                LogEntry.objects.log_action(app_label="PyLucid", action="auth error", message=msg)
                messages.error(request, msg)
                url = settings.PYLUCID.AUTH_NEXT_URL % {"path": "/", "next_url": request.path}
                return HttpResponseRedirect(url)

            def permission_denied(msg):
                LogEntry.objects.log_action(app_label="PyLucid", action="auth error", message=msg)
                raise PermissionDenied()

            if superuser_only and user.is_superuser != True:
                return permission_denied("Your are not a superuser!")

            if must_staff and user.is_staff != True:
                return permission_denied("Your are not a staff member!")

            if not user.has_perms(permissions):
                msg = "User %r has not all permissions: %r (existing permissions: %r)" % (
                    user, permissions, user.get_all_permissions()
                )
                return permission_denied(msg)

            return view_function(request, *args, **kwargs)

        # Add superuser_only and permissions attributes, so they are accessible
        # Used to build the admin menu
        _check_permissions.access_permissions = (superuser_only, permissions, must_staff)

        return _check_permissions
    return _inner


def superuser_only(view_function):
    """
    Limit view to superusers only.
    TODO: Add a log entry, if PermissionDenied raised.
    
    Usage:
    --------------------------------------------------------------------------
    from pylucid_project.apps.pylucid.decorators import superuser_only
    
    @superuser_only
    def my_view(request):
        ...
    --------------------------------------------------------------------------
    
    or in urls:
    
    --------------------------------------------------------------------------
    urlpatterns = patterns('',
        (r'^foobar/(.*)', is_staff(my_view)),
    )
    --------------------------------------------------------------------------    
    """
    @wraps(view_function)
    def _inner(request, *args, **kwargs):
        if not request.user.is_superuser:
            raise PermissionDenied
        return view_function(request, *args, **kwargs)
    return _inner


def check_request(app_label, action, must_post=False, must_ajax=False):
    assert (must_post or must_ajax), "must_post or must_ajax must be set to True!"
    def _inner(view_function):
        @wraps(view_function)
        def _wrapper(request, *args, **kwargs):
            if must_post and request.method != 'POST':
                return bad_request(app_label=app_label, action=action,
                    debug_msg="request method %r wrong, only POST allowed" % request.method
                )
            if must_ajax and request.is_ajax() != True:
                return bad_request(app_label=app_label, action=action,
                    debug_msg="request is not a ajax request"
                )
            return view_function(request, *args, **kwargs)
        return _wrapper
    return _inner


# TODO: Use this from django-tools!
def render_to(template_name=None, debug=False):
    """
    Based on the decorators from django-annoying.

    Example:
 
        @render_to('foo/template.html')
        def PyLucidPluginFoo(request):
            bar = Bar.object.all()  
            return {'bar': bar}
        
    The view can also insert the template name in the context, e.g.:

        @render_to
        def PyLucidPluginFoo(request):
            bar = Bar.object.all()  
            return {'bar': bar, 'template_name': 'foo/template.html'}

    TODO: merge render_to() and render_pylucid_response()
    """
    def renderer(function):
        @wraps(function)
        def wrapper(request, *args, **kwargs):
            context = function(request, *args, **kwargs)

            if not isinstance(context, dict):
                if debug:
                    msg = (
                        "renter_to info: %s (template: %r)"
                        " has not return a dict, has return: %r (%r)"
                    ) % (function.__name__, template_name, type(context), function.func_code)
                    messages.info(request, msg)
                return context

            template_name2 = context.pop('template_name', template_name)
            assert template_name2 != None, \
                ("Template name must be passed as render_to parameter"
                " or 'template_name' must be inserted into context!")

            response = render_to_response(template_name2, context, context_instance=RequestContext(request))

            if debug:
                messages.info(request, "render debug for %r (template: %r):" % (function.__name__, template_name2))
                messages.info(request, "local view context:", context)
                messages.info(request, "response:", response.content)

            return response
        return wrapper
    return renderer

########NEW FILE########
__FILENAME__ = extraheadBlock
# coding: utf-8

"""
    PyLucid {% extrahead %} block tag
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Simple django template block tag. "Redirect" extra head content
    into request.PYLUCID.extrahead
    This data would be inserted with pylucid_plugin.extrahead.context_middleware
    
    PyLucid plugins should use {% extrahead %} block tag in plugin template for
    insert e.g. CSS/JS file links into html head.

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django import template

def do_extrahead(parser, token):
    nodelist = parser.parse(('endextrahead',))
    parser.delete_first_token()
    return ExtraheadNode(nodelist)

class ExtraheadNode(template.Node):
    def __init__(self, nodelist):
        self.nodelist = nodelist

    def render(self, context):
        """ put head data into pylucid_plugin.head_files.context_middleware """
        output = self.nodelist.render(context)
        try:
            request = context["request"]
        except KeyError:
            raise RuntimeError("Plugin must use RequestContext() or request.PYLUCID.context !")

        extrahead = request.PYLUCID.extrahead
        # FIXME: We check double extrahead entries, but only the whole block. This doesn't work good.
        #        We should check the real link path of every JS/CSS file here.
        # See also: http://trac.pylucid.net/ticket/338
        if output not in extrahead:
            extrahead.append(output)
#            messages.info(request, "Insert extrahead:", output)
#        else:
#            messages.info(request, "Skip extrahead:", output)
        return u""

########NEW FILE########
__FILENAME__ = localtime

from pylucid_project.utils import timezone

from datetime import datetime


TZ_OFFSET = timezone.utc_offset()


def to_utc(value, arg=None):
    """Formats a date as the time since that date (i.e. "4 days, 6 hours")."""
    assert isinstance(value, datetime)

    value = value - TZ_OFFSET
    return value


########NEW FILE########
__FILENAME__ = lucidTag
# -*- coding: utf-8 -*-

"""
    {% lucidTag ... %}
    ~~~~~~~~~~~~~~~~~~

    the special PyLucid tag who starts a plugin with the plugin manager.
    e.g.: {% lucidTag plugin_name.method_name key1="value1" key2="value2" %}

    registered in: ./PyLucid/defaulttags/__init__.py

    :copyleft: 2007 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import re
import sys
import shlex
import traceback

if __name__ == "__main__":
    # For doctest only
    import os
    os.environ["DJANGO_SETTINGS_MODULE"] = "django.conf.global_settings"

from django import template
from django.conf import settings
from django.contrib import messages
from django.http import HttpResponse
from django.utils.safestring import mark_safe

#from pylucid_project.apps.pylucid.system import pylucid_plugin
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS


# FIXME: The re should be more fault-tolerant:
KWARGS_REGEX = re.compile('''(\w*?)\=['"](.*?)['"]''')


# For str2dict()
KEYWORD_MAP = {
    "True": True,
    "False": False,
    "None": None,
}

def str2dict(raw_content):
    """
    convert a string into a dictionary. e.g.:

    >>> str2dict('key1="value1" key2="value2"')
    {'key2': 'value2', 'key1': 'value1'}

    >>> str2dict('A="B" C=1 D=1.1 E=True F=False G=None')
    {'A': 'B', 'C': 1, 'E': True, 'D': '1.1', 'G': None, 'F': False}
    
    >>> str2dict('''key1="'1'" key2='"2"' key3="""'3'""" ''')
    {'key3': 3, 'key2': 2, 'key1': 1}

    >>> str2dict(u'unicode=True')
    {'unicode': True}
    """
    if isinstance(raw_content, unicode):
        # shlex.split doesn't work with unicode?!?
        raw_content = raw_content.encode(settings.DEFAULT_CHARSET)

    parts = shlex.split(raw_content)

    result = {}
    for part in parts:
        key, value = part.split("=", 1)

        if value in KEYWORD_MAP:
            # True False or None
            value = KEYWORD_MAP[value]
        else:
            # A number?
            try:
                value = int(value.strip("'\""))
            except ValueError:
                pass

        result[key] = value

    return result



class lucidTagNodeError(template.Node):
    """
    display a error messages in the cms page for a wrong lucidTag.
    """
    def __init__(self, plugin_name, method_name, msg):
        self.plugin_name = plugin_name
        self.method_name = method_name
        self.msg = msg

    def render(self, context):
        return u"[lucidTag %s.%s syntax error: %s]" % (self.plugin_name, self.method_name, self.msg)


class lucidTagNode(template.Node):
    def __init__(self, raw_content, plugin_name, method_name, method_kwargs):
        self.raw_content = raw_content
        self.plugin_name = plugin_name
        self.method_name = method_name
        self.method_kwargs = method_kwargs

    def __repr__(self):
        return "<lucidTag node ('%s.%s' kwargs:%s)>" % (
            self.plugin_name, self.method_name, self.method_kwargs)

    def render(self, context):
        """ Call the plugin view an return his reponse """
        try:
            request = context["request"]
        except KeyError:
            raise KeyError("request object not in context! You must add it into the template context!")

        if getattr(request, "_dont_call_lucid_tags", False) == True:
            # request._dont_call_lucid_tags = True was set in
            # pylucid.system.pylucid_plugin.context_middleware_request()
            return u"Skip any lucidTags!"

        plugin_name = self.plugin_name
        method_name = self.method_name
        method_kwargs = self.method_kwargs

        try:
            plugin_instance = PYLUCID_PLUGINS[plugin_name]
        except KeyError:
            return u"[PyLucid Plugin %s unknown]" % plugin_name

        try:
            response = plugin_instance.call_plugin_view(request, "views", method_name, method_kwargs)
        except Exception, err:
            pkg = "%s.views.%s" % (plugin_name, method_name)
            # Base error message for all users:
            msg = u"Error call PyLucid plugin view %s" % pkg

            if settings.DEBUG:
                # insert more information into the traceback and re-raise the original error
                etype, evalue, etb = sys.exc_info()
                evalue = etype('%s (%r): %s' % (msg, self.raw_content, evalue))
                raise etype, evalue, etb

            if request.user.is_staff:
                # add more info for staff members
                msg += u" (%s)" % err

            if request.user.is_superuser:
                # put the full traceback into page_msg, but only for superusers
                messages.info(request, mark_safe("%s:<pre>%s</pre>" % (msg, traceback.format_exc())))

            return u"[%s]" % msg

        # FIXME: Witch error should we raised here?
        if response == None:
            return u""
        elif isinstance(response, basestring):
            return response
        elif isinstance(response, HttpResponse):
            status_code = response.status_code
            assert status_code == 200, "Response status code %r != 200 ???" % status_code
            return response.content

        raise RuntimeError("pylucid plugins must return None, a basestring or a HttpResponse instance!")





def lucidTag(parser, token):
    """
    Parse the lucidTags.

    syntax e.g.:
        {% lucidTag PluginName %}
        {% lucidTag PluginName kwarg1="value1" %}
        {% lucidTag PluginName kwarg1="value1" kwarg2="value2" %}
    """
    raw_content = token.contents
    content = raw_content.split(" ", 2)[1:]
    plugin_name = content.pop(0)

    if "." in plugin_name:
        plugin_name, method_name = plugin_name.split(".", 1)
    else:
        method_name = "lucidTag"

    if content:
        raw_kwargs = content[0]
        try:
            method_kwargs = str2dict(raw_kwargs)
        except Exception, err:
            if settings.DEBUG:
                raise
            return lucidTagNodeError(plugin_name, method_name, msg="Wrong tag parameter")
    else:
        method_kwargs = {}

    return lucidTagNode(raw_content, plugin_name, method_name, method_kwargs)



if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = sourcecode
# coding: utf-8

"""
    PyLucid {% sourcecode %} block tag
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Last commit info:
    ~~~~~~~~~
    $LastChangedDate: $
    $Rev: $
    $Author: JensDiemer $

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django import template

from pylucid_project.apps.pylucid.markup.hightlighter import make_html


class SourcecodeNode(template.Node):
    def __init__(self, raw_content, source_type):
        self.raw_content = raw_content
        self.source_type = source_type

    def render(self, context):
        """ put head data into pylucid_plugin.head_files.context_middleware """
        source_html = make_html(
            sourcecode=self.raw_content, source_type=self.source_type,
            django_escape=True
        )
        return source_html


def do_sourcecode(parser, token):
    """
    example:
        {% sourcecode ext=".py" %}
        print "This python script is pygmentize"
        {% endsourcecode %}
    
    With ext argument, get_lexer_by_name used.
    Without it, guess_lexer used. 
    """
    args = token.contents
    try:
        source_type = args.rsplit("=", 1)[-1]
    except (ValueError, IndexError):
        source_type = ""

    # assembles the original content
    raw_content = ""
    while parser.tokens:
        token = parser.next_token()
        if token.token_type == template.TOKEN_TEXT:
            raw_content += token.contents
        elif token.token_type == template.TOKEN_VAR:
            raw_content += "{{ %s }}" % token.contents
        elif token.token_type == template.TOKEN_BLOCK:
            if "endsourcecode" in token.contents:
                # put token back on token list so calling code knows why it terminated
                parser.prepend_token(token)
                break

            raw_content += "{%% %s %%}" % token.contents

    parser.delete_first_token()
    return SourcecodeNode(raw_content, source_type)
do_sourcecode.is_safe = True

########NEW FILE########
__FILENAME__ = comma_separated_field
# coding: utf-8
"""
    django addon - comma separated field
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    TODO: FIXME ;)

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate: $
    $Rev: $
    $Author: $

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django import forms
from django.db import models


def list2string(l):
    if not l:
        return ""
    assert isinstance(l, list)
    return ", ".join([i.strip() for i in l if i])
def string2list(s):
    assert isinstance(s, basestring)
    return [i.strip() for i in s.split(",") if i]


class CommaSeparatedFormWidget(forms.TextInput):
    """ comma separated - form widget """
    def render(self, name, value, attrs=None):
        if isinstance(value, list):
            value = list2string(value)
        return super(CommaSeparatedFormWidget, self).render(name, value, attrs)


class CommaSeparatedFormField(forms.CharField):
    """ comma separated - form field """
#    widget = CommaSeparatedFormWidget
    
    def clean(self, value):
        value = super(CommaSeparatedFormField, self).clean(value)
        try:
            return string2list(value)
        except Exception, err:
            raise forms.ValidationError("Can't deserialize: %s" % err)


class CommaSeparatedCharField(models.CharField):
    """ comma separated - model field """
    __metaclass__ = models.SubfieldBase

    def to_python(self, value):
        if isinstance(value, list):
            return value
        return string2list(value)

    def get_db_prep_save(self, value):
        assert isinstance(value, list)
        return list2string(value)
    
    def formfield(self, **kwargs):
        # Always use own form field and widget:
        kwargs['form_class'] = CommaSeparatedFormField
        kwargs['widget'] = CommaSeparatedFormWidget
        return super(CommaSeparatedCharField, self).formfield(**kwargs)
########NEW FILE########
__FILENAME__ = fields
# coding: utf-8

"""
    PyLucid fields
    ~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import re

if __name__ == "__main__":
    # For doctest only
    import os
    os.environ["DJANGO_SETTINGS_MODULE"] = "django.conf.global_settings"

from django import forms
from django.db import models
from django.core import exceptions
from django.utils.translation import ugettext as _

from south.modelsinspector import add_introspection_rules

from pylucid_project.apps.pylucid.markup.widgets import MarkupContentWidget, \
    MarkupSelectWidget
from pylucid_project.apps.pylucid.markup import MARKUP_CHOICES

CSS_VALUE_RE = re.compile(r'[a-f0-9]{6}$', re.IGNORECASE) # For validation of a CSS value


def validate_css_color_value(value):
    """
    validate a CSS hex color value
    
    >>> validate_css_color_value("00aaff")
    >>> validate_css_color_value("00AAFF")
    
    >>> validate_css_color_value("0aF")
    Traceback (most recent call last):
    ...
    ValidationError: Error: '0aF' has wrong length (only 6 characters allowed)
    
    >>> validate_css_color_value("Maroon")
    Traceback (most recent call last):
    ...
    ValidationError: Error: 'Maroon' is not a CSS hex color value
    """
    if not isinstance(value, basestring):
        raise exceptions.ValidationError(_("CSS color value is not a basestring!"))

    if len(value) != 6:
        raise exceptions.ValidationError(
            _("Error: %r has wrong length (only 6 characters allowed)") % value
        )

    if not CSS_VALUE_RE.match(value):
        raise exceptions.ValidationError(_("Error: %r is not a CSS hex color value") % value)


#-----------------------------------------------------------------------------


class ColorValueInputWidget(forms.TextInput):
    """
    Add background-ColorValue into input tag
    
    >>> ColorValueInputWidget().render("foo", "1234af")
    u'<input style="background-ColorValue:#1234af;" type="text" name="foo" value="1234af" />'
    
    TODO: Change text ColorValue, if background is to dark ;)
    TODO2: Use jQuery to change the <td> background ColorValue ;)
    """
    def render(self, name, value, attrs=None):
        if not attrs:
            attrs = {}
        attrs["style"] = "background-ColorValue:#%s;" % value
        return super(ColorValueInputWidget, self).render(name, value, attrs)


class ColorValueFormField(forms.CharField):
    """ form field for a CSS ColorValue value """
    widget = ColorValueInputWidget
    def clean(self, value):
        """ validate the form data """
        value = super(ColorValueFormField, self).clean(value)
        validate_css_color_value(value)
        self.value = value
        return value


class ColorValueField(models.CharField):
    """
    CSS ColorValue hex value field.
    >>> ColorValueField().to_python("11AAFF")
    '11AAFF'
    
    >>> ColorValueField().to_python("0aF")
    Traceback (most recent call last):
    ...
    ValidationError: Error: '0aF' has wrong length (only 6 characters allowed)
    """
    #__metaclass__ = models.SubfieldBase
    def __init__(self, *args, **kwargs):
        kwargs['max_length'] = 6
        models.CharField.__init__(self, *args, **kwargs)

    def get_db_prep_save(self, value, connection):
        "Returns field's value prepared for saving into a database."
        validate_css_color_value(value)
        return value

    def to_python(self, value):
        validate_css_color_value(value)
        return value

    def formfield(self, **kwargs):
        # Always use own form field and widget:
        kwargs['form_class'] = ColorValueFormField
        kwargs['widget'] = ColorValueInputWidget
        return super(ColorValueField, self).formfield(**kwargs)


#______________________________________________________________________________
# Markup


class MarkupContentModelField(models.TextField):
    def formfield(self, **kwargs):
        # Use our own widget and put JavaScript preview stuff into page.
        kwargs['widget'] = MarkupContentWidget()
        return super(MarkupContentModelField, self).formfield(**kwargs)

add_introspection_rules([], ["^pylucid_project\.apps\.pylucid\.fields\.MarkupContentModelField"])


class MarkupModelField(models.PositiveSmallIntegerField):
    # TODO: update in next migration release. Original was: models.IntegerField
    def __init__(self, *args, **kwargs):
        defaults = {
            "choices": MARKUP_CHOICES,
            "help_text": _("the used markup language for this entry"),
        }
        defaults.update(kwargs)
        super(MarkupModelField, self).__init__(*args, **defaults)

    def formfield(self, **kwargs):
        # Use our own widget to put markup select field id into a JavaScript variable
        kwargs['widget'] = MarkupSelectWidget()
        return super(MarkupModelField, self).formfield(**kwargs)

add_introspection_rules([], ["^pylucid_project\.apps\.pylucid\.fields\.MarkupModelField"])


class RootAppChoiceField(models.CharField):
    def get_choices_default(self):
        from pylucid_project.apps.pylucid.models.pluginpage import PluginPage # import loops
        PluginPage.objects.get_app_choices()


try:
    from south.modelsinspector import add_introspection_rules
except ImportError:
    pass
else:
    add_introspection_rules([], ["^pylucid_project\.apps\.pylucid\.fields.\ColorValueFormField"])
    add_introspection_rules([], ["^pylucid_project\.apps\.pylucid\.fields.\ColorValueField"])
    add_introspection_rules([], ["^pylucid_project\.apps\.pylucid\.fields.\MarkupContentModelField"])
    add_introspection_rules([], ["^pylucid_project\.apps\.pylucid\.fields.\MarkupModelField"])
    add_introspection_rules([], ["^pylucid_project\.apps\.pylucid\.fields.\RootAppChoiceField"])


if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = pagemeta
# coding: utf-8

"""
    PyLucid PageMeta Form
    ~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django import forms
from django.conf import settings

from django_tools.middlewares import ThreadLocal

from pylucid_project.apps.pylucid.models.pagemeta import PageMeta
from pylucid_project.apps.pylucid.models.pagetree import PageTree


class PageMetaForm(forms.ModelForm):

    def _setup_tag_filter(self):
        """
        prepare the tag queryset filter
        """
        def get_data(field_name):
            return self.initial.get(field_name, None) or self.data.get(field_name, None)

        language = get_data("language")
        if not language:
            # Use current language for tag queryset filter
            request = ThreadLocal.get_current_request()
            language = request.PYLUCID.current_language

        pagetree_id = get_data("pagetree")
        if pagetree_id:
            pagetree = PageTree.objects.only("site").get(id=pagetree_id)
            site = pagetree.site
        else:
            # Use current site for tag queryset filter
            site = settings.SITE_ID

        # change the tag queryset filter:
        self.fields["tags"].widget.tag_queryset_filters = {
            "language": language,
            "pagetree__site": site,
        }

    def __init__(self, *args, **kwargs):
        super(PageMetaForm, self).__init__(*args, **kwargs)
        self._setup_tag_filter()


    class Meta:
        model = PageMeta

########NEW FILE########
__FILENAME__ = utils
# coding: utf-8

"""
    PyLucid forms utils
    ~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings

from django_tools.middlewares import ThreadLocal


class TagLanguageSitesFilter(object):
    """
    Helper class for django-tagging & django-tools jQueryTagModelField tag field:
    Display in the jQuery help_text only the tags with the same language and sites.
    
    uses in Blog and Lexicon model form
    
    Usage e.g.:
    ---------------------------------------------------------------------------
    from pylucid_project.apps.pylucid.forms.utils import TagLanguageSitesFilter
    
    class FooBarModelForm(TagLanguageSitesFilter, forms.ModelForm):
        class Meta:
            model = MyModel
    ---------------------------------------------------------------------------
    IMPORANT: TagLanguageSitesFilter must used before forms.ModelForm!
    """
    sites_filter = "sites__id__in"

    def __init__(self, *args, **kwargs):
        """
        prepare the tag queryset filter
        """
        super(TagLanguageSitesFilter, self).__init__(*args, **kwargs)

        def get_data(field_name):
            return self.initial.get(field_name, None) or self.data.get(field_name, None)

        language = get_data("language")
        if not language:
            # Use current language for tag queryset filter
            request = ThreadLocal.get_current_request()
            language = request.PYLUCID.current_language

        sites = get_data("sites")
        if not sites:
            # Use current site for tag queryset filter
            sites = [settings.SITE_ID]

        # change the tag queryset filter:
        self.fields["tags"].widget.tag_queryset_filters = {
            "language": language,
            self.sites_filter: sites,
        }




########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    PyLucid markup ajax preview admin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.conf.urls.defaults import patterns

from pylucid_project.apps.pylucid.markup.views import markup_preview


class MarkupPreview(object):
    """
    For Admin class inherit
    """
    save_on_top = True

    def ajax_markup_preview(self, request, object_id):
        return markup_preview(request)

    def get_urls(self):
        urls = super(MarkupPreview, self).get_urls()
        my_urls = patterns('',
            (r'^(.+?)/preview/$', self.admin_site.admin_view(self.ajax_markup_preview)),
        )
        return my_urls + urls




########NEW FILE########
__FILENAME__ = converter
# -*- coding: utf-8 -*-

"""
    PyLucid markup converter
    ~~~~~~~~~~~~~~~~~~~~~~~~

    apply a markup to a content

    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

import re



if __name__ == "__main__":
    # For doctest only
    import os
    os.environ["DJANGO_SETTINGS_MODULE"] = "PyLucid.settings"


from django.conf import settings
from django.contrib import messages
from django.utils.safestring import mark_safe
from django.utils.encoding import smart_str, force_unicode

from django_tools.utils.messages import FileLikeMessages

from pylucid_project.apps.pylucid.markup import MARKUP_TINYTEXTILE, \
    MARKUP_TEXTILE, MARKUP_MARKDOWN, MARKUP_REST, MARKUP_CREOLE, MARKUP_HTML, \
    MARKUP_HTML_EDITOR, MARKUP_DICT
from pylucid_project.apps.pylucid.markup.django_tags import DjangoTagAssembler
from pylucid_project.utils.SimpleStringIO import SimpleStringIO
from pylucid_project.utils.escape import escape_django_tags as escape_django_template_tags

#______________________________________________________________________________
# MARKUP

BLOCK_RE = re.compile("\n{2,}")

LINK_RE = re.compile(
    r'''(?<!=")(?P<url>(http|ftp|svn|irc)://(?P<title>[^\s\<]+))(?uimx)'''
)

def fallback_markup(content):
    """
    A simplest markup, build only paragraphs.
    >>> fallback_markup("line one\\nline two\\n\\nnext block")
    '<p>line one<br />\\nline two</p>\\n\\n<p>next block</p>'

    >>> fallback_markup("url: http://pylucid.org END")
    '<p>url: <a href="http://pylucid.org">pylucid.org</a> END</p>'
    """
    content = content.replace("\r\n", "\n").replace("\r", "\n")
    blocks = BLOCK_RE.split(content)
    blocks = [line.replace("\n", "<br />\n") for line in blocks]
    content = "<p>" + "</p>\n\n<p>".join(blocks) + "</p>"
    content = LINK_RE.sub(r'<a href="\g<url>">\g<title></a>', content)
    return content

def apply_tinytextile(content, page_msg):
    """ tinyTextile markup """
    from pylucid_project.apps.pylucid.markup.tinyTextile import TinyTextileParser
    out_obj = SimpleStringIO()
    markup_parser = TinyTextileParser(out_obj, page_msg)
    markup_parser.parse(smart_str(content))
    return force_unicode(out_obj.getvalue())


def apply_textile(content, page_msg):
    """ Original textile markup """
    try:
        import textile
    except ImportError:
        page_msg(
            "Markup error: The Python textile library isn't installed."
            " Download: http://cheeseshop.python.org/pypi/textile"
        )
        return fallback_markup(content)
    else:
        return force_unicode(textile.textile(
            smart_str(content),
            encoding=settings.DEFAULT_CHARSET,
            output=settings.DEFAULT_CHARSET
        ))

def apply_markdown(content, page_msg):
    """ Markdown markup """
    try:
        import markdown
    except ImportError:
        page_msg(
            "Markup error: The Python markdown library isn't installed."
            " Download: http://sourceforge.net/projects/python-markdown/"
        )
        return fallback_markup(content)
    else:
        # unicode support only in markdown v1.7 or above.
        # version_info exist only in markdown v1.6.2rc-2 or above.
        if getattr(markdown, "version_info", None) < (1, 7):
            return force_unicode(markdown.markdown(smart_str(content)))
        else:
            return markdown.markdown(content)


def apply_restructuretext(content, page_msg):
    from creole.exceptions import DocutilsImportError
    try:
        from creole.rest2html.clean_writer import rest2html
    except DocutilsImportError:
        page_msg(
            "Markup error: The Python docutils library isn't installed."
            " Download: http://docutils.sourceforge.net/"
        )
        return fallback_markup(content)
    else:
        #docutils_settings = getattr(settings, "RESTRUCTUREDTEXT_FILTER_SETTINGS", {})
        rest = rest2html(content)
        return rest


def apply_creole(content, page_msg):
    """
    Use python-creole:
    http://code.google.com/p/python-creole/

    We used verbose for insert error information (e.g. not existing macro)
    into the generated page
    """
    from creole import creole2html
    from pylucid_project.apps.pylucid.markup import PyLucid_creole_macros

    if settings.DEBUG:
        verbose = 2
    else:
        verbose = 1

    try:
        # new python-creole v1.0 API
        return creole2html(content, macros2=PyLucid_creole_macros, stderr=page_msg, verbose=verbose)
    except TypeError:
        # TODO: Remove work-a-round in future release
        # old python-creole API
        emitter_kwargs = {
            "macros":PyLucid_creole_macros,
            "verbose": verbose,
            "stderr": page_msg
        }
        return creole2html(content, emitter_kwargs=emitter_kwargs)


def convert(raw_content, markup_no, page_msg):
    if markup_no == MARKUP_TINYTEXTILE: # PyLucid's TinyTextile
        html_content = apply_tinytextile(raw_content, page_msg)
    elif markup_no == MARKUP_TEXTILE: # Textile (original)
        html_content = apply_textile(raw_content, page_msg)
    elif markup_no == MARKUP_MARKDOWN:
        html_content = apply_markdown(raw_content, page_msg)
    elif markup_no == MARKUP_REST:
        html_content = apply_restructuretext(raw_content, page_msg)
    elif markup_no == MARKUP_CREOLE:
        html_content = apply_creole(raw_content, page_msg)
    elif markup_no in (MARKUP_HTML, MARKUP_HTML_EDITOR):
        html_content = raw_content
    else:
        raise AssertionError("markup no %r unknown!" % markup_no)

    return html_content


def apply_markup(raw_content, markup_no, request, escape_django_tags=False):
    """ render markup content to html. """
    page_msg = FileLikeMessages(request, messages.INFO)

    assemble_tags = markup_no not in (MARKUP_HTML, MARKUP_HTML_EDITOR)
    if assemble_tags:
        # cut out every Django tags from content
        assembler = DjangoTagAssembler()
        raw_content2, cut_data = assembler.cut_out(raw_content)
    else:
        raw_content2 = raw_content

    html_content = convert(raw_content2, markup_no, page_msg)

    if assemble_tags:
        # reassembly cut out django tags into text
        if not isinstance(html_content, unicode):
            if settings.DEBUG:
                markup_name = MARKUP_DICT[markup_no]
                page_msg("Info: Markup converter %r doesn't return unicode!" % markup_name)
            html_content = force_unicode(html_content)

        html_content2 = assembler.reassembly(html_content, cut_data)
    else:
        # html "markup" used
        html_content2 = raw_content

    if escape_django_tags:
        html_content2 = escape_django_template_tags(html_content2)

    return mark_safe(html_content2) # turn Django auto-escaping off


def convert_markup(raw_content, source_markup_no, dest_markup_no, request):
    """
    Convert one markup in a other.
    """
    page_msg = FileLikeMessages(request, messages.INFO)

    html_source = source_markup_no in (MARKUP_HTML, MARKUP_HTML_EDITOR)
    html_dest = dest_markup_no in (MARKUP_HTML, MARKUP_HTML_EDITOR)

    if source_markup_no == dest_markup_no or (html_source and html_dest):
        # Nothing to do ;)
        return raw_content

    if not html_dest and dest_markup_no != MARKUP_CREOLE:
        raise NotImplementedError("Converting into %r not supported." % dest_markup_no)

    if html_source: # Source markup is HTML
        html_content = raw_content
    else:
        # cut out every Django tags from content
        assembler = DjangoTagAssembler()
        raw_content2, cut_data = assembler.cut_out(raw_content)

        # convert to html
        html_content = convert(raw_content2, source_markup_no, page_msg)

    if html_dest: # Destination markup is HTML
        new_content = html_content
    else:
        # Skip: if dest_markup_no == MARKUP_CREOLE: - only creole supported here
        from creole import html2creole
        new_content = html2creole(html_content)

    if not html_source: # Source markup is not HTML
        # reassembly cut out django tags into text
        new_content = assembler.reassembly(new_content, cut_data)

    return new_content



if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = django_tags
# coding: utf-8


"""
    django tag assembler
    ~~~~~~~~~~~~~~~~~~~~

    -cut out django template tags from text.
    -reassembly cut out parts into text.

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import re


# FIXME: How can we better match on creole image, without a list of known image extensions?
CUT_OUT_RE = re.compile(r'''
    (?P<creole_image> {{ .+?(.jpg|.jpeg|.gif|.png).*? }} )
    |
    (?P<creole_pre_inline> {{{ (\n|.)*? }}} )
    |
    (?P<block>
        \{% \s* (?P<pass_block_start>.+?) .*? %\}
        (\n|.)*?
        \{% \s* end(?P=pass_block_start) \s* %\}
    )
    |
    (?P<tag>
        \{% [^\{\}]*? %\}
    )
    |
    (?P<variable>
        \{\{ [^\{\}]*? \}\}
    )
''', re.VERBOSE | re.UNICODE | re.MULTILINE | re.IGNORECASE)

# Ignore this re groups:
LEAVE_KEYS = ("creole_image", "creole_pre_inline")

# Cut out this re groups:
CUT_OUT_KEYS = ("block", "tag", "variable")

ALL_KEYS = LEAVE_KEYS + CUT_OUT_KEYS

ESCAPE = ("Tag", "TagTag") # For mask existing placeholder
PLACEHOLDER_CUT_OUT = u"DjangoTag%iAssembly"


class DjangoTagAssembler(object):

    def cut_out(self, text):
        cut_data = []

        def cut(match):
            groups = match.groupdict()

            for key in ALL_KEYS:
                if groups[key] != None:
                    data = groups[key]
                    if key in LEAVE_KEYS:
                        # Don't replace this re match
                        return data
                    data = data.replace(ESCAPE[1], ESCAPE[0])
                    cut_out_pos = len(cut_data)
                    cut_data.append(data)
                    return PLACEHOLDER_CUT_OUT % cut_out_pos

        text = text.replace(ESCAPE[0], ESCAPE[1])
        text = CUT_OUT_RE.sub(cut, text)
        return text, cut_data

    def reassembly(self, text, cut_data):
        for no in xrange(len(cut_data) - 1, -1, -1):
            data = cut_data[no]
            placeholder = PLACEHOLDER_CUT_OUT % no
            text = text.replace(placeholder, data)
        text = text.replace(ESCAPE[1], ESCAPE[0])
        return text


########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

"""
    PyLucid markup preview form
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django import forms

from pylucid_project.apps.pylucid.models.pagecontent import PageContent


class MarkupPreviewForm(forms.ModelForm):
    class Meta:
        model = PageContent
        fields = ('content', 'markup')

########NEW FILE########
__FILENAME__ = hightlighter
# coding: utf-8


"""
    PyLucid <-> Pygments
    ~~~~~~~~~~~~~~~~~~~~

    hightlight sourcecode with http://pygments.org/

    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.conf import settings
from django.contrib import messages
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

from pylucid_project.utils.SimpleStringIO import SimpleStringIO
from pylucid_project.utils.escape import escape, escape_django_tags
from pylucid_project.utils.diff import make_diff


try:
    import pygments
    from pygments import lexers
    from pygments.formatters import HtmlFormatter
    from pygments import highlight
    PYGMENTS_AVAILABLE = True
except ImportError, err:
    PYGMENTS_AVAILABLE = False
    import_error = err

HTML = (
    u'<fieldset class="pygments_code">\n'
    '<legend class="pygments_code">%(lexer_name)s</legend>'
    '%(code_html)s'
    '</fieldset>\n'
)
# There exist a bug in pygments, if cssclass is given as unicode:
# http://dev.pocoo.org/projects/pygments/ticket/371
CSSCLASS = "pygments"

def make_html(sourcecode, source_type, django_escape=False):
    code_html, lexer_name = pygmentize(sourcecode, source_type)
    code = HTML % {"lexer_name": lexer_name, "code_html": code_html}
    if django_escape:
        code = escape_django_tags(code)
    return mark_safe(code)

def no_hightlight(code):
    html = u'\n<pre><code>%s</code></pre>\n' % escape(code)
    return html

def get_formatter():
    formatter = HtmlFormatter(
        linenos=True, encoding="utf-8", style='colorful',
        outencoding="utf-8",
        cssclass=CSSCLASS,
    )
    return formatter


def get_lexer(source_type, sourcecode):
    errors = []
    try:
        if source_type == "":
            return lexers.guess_lexer(sourcecode)
        else:
            return lexers.get_lexer_by_name(source_type)
    except lexers.ClassNotFound, err:
        errors.append(err)

    try: # try if given source_type is a filename
        return lexers.get_lexer_for_filename(source_type, sourcecode)
    except lexers.ClassNotFound, err:
        errors.append(err)

    try: # try if given source_type is a mimetype
        return lexers.get_lexer_for_mimetype(source_type)
    except lexers.ClassNotFound, err:
        errors.append(err)

    raise lexers.ClassNotFound(",\n ".join([str(err) for err in errors]))


def pygmentize(sourcecode, source_type):
    """
    returned html-code and the lexer_name
    """
    if not PYGMENTS_AVAILABLE:
        lexer_name = escape(source_type)
        html = no_hightlight(sourcecode)
        return html, lexer_name

    source_type = source_type.lower().strip("'\" ").lstrip(".")

    try:
        lexer = get_lexer(source_type, sourcecode)
    except lexers.ClassNotFound, err:
        info = _("unknown type")
        lexer_name = u'<small title="%s">%s</small>' % (err, info)
        html = no_hightlight(sourcecode)
        return html, lexer_name

    lexer_name = lexer.name

    formatter = get_formatter()

    out_object = SimpleStringIO()
    try:
        highlight(sourcecode, lexer, formatter, out_object)
    except Exception, err:
        if settings.DEBUG:
            raise
        html = no_hightlight(sourcecode)
        lexer_name += " (Error: %s)" % err
    else:
        html = out_object.getvalue()

        # If there is e.g. html code with django tags, we must escape this:
        html = escape_django_tags(html)
        html = html.decode("utf-8")

    return html, lexer_name


def get_pygmentize_diff(content1, content2):
    """
    returns the HTML-Diff hightlighted with Pygments
    Note: the complete content will be returned and not only the "diff-lines".
    """
    diff = make_diff(content1, content2, mode="Differ")
    diff = "\n".join(diff)

    # hightlight with Pygments
    diff_html = make_html(diff, source_type="diff", django_escape=True)

    return diff_html



########NEW FILE########
__FILENAME__ = PyLucid_creole_macros
# coding: utf-8

"""
    PyLucid own creole2html macros
    
    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


# use all existing macros
try:
    # python-creole < v0.6
    from creole.default_macros import *
except ImportError:
    # python-creole >= v0.6
    from creole.shared.example_macros import *


from pylucid_project.apps.pylucid.markup.hightlighter import make_html


def code(ext, text):
    """
    Highlight sourcecode using
    Macro tag <<code ext=.EXT>>...<</code>>
    """
    try:
        source_type = ext.rsplit("=", 1)[-1]
    except (ValueError, IndexError):
        source_type = ""

    source_html = make_html(
        sourcecode=text, source_type=source_type, django_escape=True
    )
    return source_html

########NEW FILE########
__FILENAME__ = tinyTextile
# -*- coding: utf-8 -*-

"""
    tinyTextile
    ~~~~~~~~~~~

    PyLucid builtin markup engine. Based on the textile markup.

    ToDo
    ~~~~
    Most parts works well, but the code is very old and process in a stream was
    not the best idea: e.g. sourceode parts doesn't work well, there should be
    exctract/insert before the markup applied. So these engine should be
    complete rewritten.
    other todos:
      * lists are not good indented

    links
    ~~~~~
    http://www.pylucid.org/_goto/5/Markup/
    http://dealmeida.net/en/Projects/PyTextile/
    http://www.solarorange.com/projects/textile/mtmanual_textile2.htm

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate:2008-05-13 18:26:55 +0200 (Di, 13 Mai 2008) $
    $Rev:1561 $
    $Author:JensDiemer $

    :copyleft: 2007-2008 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


__version__ = "$Rev:1561 $"

import sys, re

from xml.sax.saxutils import escape


class TinyTextileParser:
    def __init__(self, out_obj, page_msg):
        self.out = out_obj
        self.page_msg = page_msg

        # Blockelements
        self.block_rules = self._compile_rules([
            [ # <h1>-Headlines
                r"\Ah(\d)\. (.+)(?usm)",
                r"<h\1>\2</h\1>"
            ],
        ])

        # Inlineelements
        self.inline_rules = self._compile_rules([
            [ # HTML-Escaping
                r"={2,2}(.+?)={2,2}(?usm)",
                self.escaping
            ],
            [ # Kleiner Text - Bsp.: Ich bin ein --kleines-- Wort.
                r"-{2,2}([^-]+?)-{2,2}",
                r"<small>\1</small>"
            ],
            [ # Fettschrift - Bsp.: Das Wort ist in *fett* geschrieben.
                r"\*([^*\n]+?)\*(?uism)",
                r"<strong>\1</strong>"
            ],
            [ # manuell linebreak
                r"\\{2,2}",
                r"<br />"
            ],
            [ # img-Tag - Bsp.: !/Bilder/MeinBild.jpg!
                r'\!([^!\n ]+?)\!(?uis)',
                r'<img src="\1">'
            ],
            [ # Link + LinkText - e.g.: "LinkText":http://www.beispiel.de
              # old link format!
                r'"([^"]+?)":([^\s\<]+)',
                r'<a href="\2">\1</a>'
            ],
            [ # Link + LinkText - e.g.: "LinkText":http://www.beispiel.de
              # new link format - e.g.: [http://domain.dtl link text]
                r'\[([^\s\<]+) (.+?)\]',
                r'<a href="\1">\2</a>'
            ],
            [ # interne PyLucid Links - Bsp.:
              # Das ist ein [[InternerLink]] zur Seite InternerLink ;)
                r'\[\[(.+?)\]\]',
                self.shortcutLink
            ],
            [
                # Links allein im Text
                # Bsp.: Das wird ein Link: http://www.beispiel.de
                r'''
                    (?<!=") # Ist noch kein HTML-Link
                    (?P<url>(http|ftp|svn|irc)://([^\s\<]+))
                    (?uimx)
                ''',
                r'<a href="\g<url>">\g<url></a>'
            ],
            [ # EMails
                r'mailto:([^\s\<]+)',
                r'<a href="mailto:\1">\1</a>'
            ],
        ])

        # Pre-Process Regeln
        self.pre_process_rules = self._compile_rules([
            [ # Text vor einer "*"-Liste mit noch einem \n trennen
                r"""
                    (^[^*\n].+?$) # Text-Zeile vor einer Liste
                    (\n^\*) # Absatz + erstes List-Zeichen
                    (?uimx)
                """,
                r"\1\n\2",
            ],
            [ # Text vor einer "#"-Liste mit noch einem \n trennen
                r"""
                    (^[^#\n].+?$) # Text-Zeile vor einer Liste
                    (\n^\#) # Absatz + erstes List-Zeichen
                    (?uimx)
                """,
                r"\1\n\2",
            ],
            [ # insert \n before and after a "|"-Table
                r"(?ms)(^\|.*?\|\n(?!\|))", # match the complete table block
                r"\n\1\n",
            ],
            [
                # Text *vor* einem <pre>, <python> oder <code> Block mit noch
                # einem \n trennen
                r"\n(?P<tag><(pre|python|code[^>]*?)>)\n",
                r"\n\n\g<tag>\n",
            ],
            [
                # Text *nach* einem <pre>, <python> oder <code> Block mit noch
                # einem \n trennen
                r"\n(?P<tag></(pre|python|code)>)\n",
                r"\n\g<tag>\n\n",
            ],
#            [
#                "(?ms)(<(pre|python|code[^>]*?)>.*?</(pre|python|code)>)",
#                r"\n\1\n"
#            ]
        ])

        self.area_rules = (
            [
                "==", "==",
                self.escape_area_start, self.escape_area, self.escape_area_end
            ],
            [
                "<pre>", "</pre>",
                self.pre_area, self.pre_area, self.pre_area
            ],
            [
                "<python>", "</python>",
                self.python_area_start, self.python_area, self.python_area_end
            ],
            [
                "<code", "</code>",
                self.code_area_start, self.code_area, self.code_area_end
            ],
        )

    def _compile_rules(self, rules):
        "Kompliliert die RE-Ausdrcke"
        for rule in rules:
            rule[0] = re.compile(rule[0])
        return rules

    def parse(self, txt):
        "Parsed den Text in's out_obj"
        txt = self.pre_process(txt)
        self.make_paragraphs(txt)

    def escaping(self, matchobj):
        return escape(matchobj.group(1))

    def shortcutLink(self, matchobj):
        shortcut = matchobj.group(1)
        url = "/%s/" % shortcut.strip("/")
        link = '<a href="%s">%s</a>' % (
            url, shortcut
        )
        return link

    def pre_process(self, txt):
        "Vorab Verarbeitung des Textes"

        # Zeilenenden vereinheitlichen
        txt = txt.replace("\r\n", "\n").replace("\r", "\n")

        # Leerzeilen vorn und hinten abschneiden
        txt = txt.strip()

        # Preprocess rules anwenden
        for rule in self.pre_process_rules:
            #~ self.page_msg(rule)
            #~ self.page_msg(txt)
            txt = rule[0].sub(rule[1], txt)
            #~ self.page_msg(txt)

        return txt

    def make_paragraphs(self, txt):
        """
        Verarbeitung des Textes.
        Wendet Blockelement-Regeln und Inlineelement-Regeln an.
        """
        blocks = re.split("\n{2,}", txt)
        #~ self.page_msg(escape(str(blocks)))
        current_area = None
        for block in blocks:
            current_area = self.handle_areas(block, current_area)
            if current_area != None:
                # Wir sind in einer Area und der Block wurde schon abgehandelt
                continue

            block = block.strip()
            if len(block) == 0:
                continue

            #~ if self.is_html.findall(block) != []:
            if block[0] == "<":
                # Der Block scheint schon HTML-Code zu sein
                self.out.write("%s\n" % block)
                #~ self.page_msg("Is HTML:", escape(block))
                continue

            # inline-rules Anwenden
            for inlinerule in self.inline_rules:
                block = inlinerule[0].sub(inlinerule[1], block)

            # Block-rules Anwenden
            self.blockelements(block)

    #_________________________________________________________________________
    # Areas

    def handle_areas(self, block, current_area):
        """
        Areas anhandeln
        """
        #~ self.page_msg(current_area, "--", escape(block))

        def handle_end(current_area, block):
            if block.endswith(current_area[1]):
                # Die aktuelle Area ist zuende
                inner_block = block[:-len(current_area[1])].rstrip()
                # Erstmal die restlichen Daten verabeiten
                current_area[3](inner_block)

                current_area[4](current_area[1]) # Endmethode aufrufen
                return False

        if (current_area != None) and (current_area != False):
            # Wir sind gerade in einer area

            if handle_end(current_area, block) == False:
                # Ende erreicht
                return False

            # Methode die fr die area zustndig ist aufrufen
            current_area[3]("\n%s\n" % block)

            # In der area bleiben
            return current_area

        #~ self.page_msg("handle:", escape(block))
        for current_area in self.area_rules:
            #~ self.page_msg(escape(current_area[0]), block)
            if block.startswith(current_area[0]): # Start einer neuen area
                area_tag = current_area[0]

                # Area-Start-Methode aufrufen
                current_area[2](area_tag)

                rest_block = block[len(area_tag):]
                try:
                    if rest_block[0] == "\n":
                        # Evtl. vorhandene Leerzeile ignorieren
                        rest_block = rest_block[1:]
                except IndexError:
                    # Es ist ein Leerzeichen zwischem Tag und Inhalt
                    # (kommt selten vor)
                    pass

                if handle_end(current_area, rest_block) == False:
                    # Das Ende schon erreicht
                    return False

                # Das Ende ist noch nicht erreicht, also
                # den Restlichen Block durch die normale Methode jagen
                current_area[3](rest_block)

                # In-der-Area-Methode "merken"
                return current_area

        # Wir sind nicht in einer Area
        return None

    #_________________________________________________________________________

    def escape_area_start(self, block):
        self.escape_area_first_line = True
        pass

    def escape_area(self, block):
        if self.escape_area_first_line == True:
            block = block.strip()
            self.escape_area_first_line = False

        block = block.splitlines()
        block = "".join(["%s<br />\n" % escape(line) for line in block])
        self.out.write(block)

    def escape_area_end(self, block):
        pass

    #_________________________________________________________________________

    def pre_area(self, block):
        self.out.write(block + "\n")

    #_________________________________________________________________________

    def python_area_start(self, block):
        """
        Python-Source-Code area
        """
        self.sourcecode_data = []

    def python_area(self, block):
        self.sourcecode_data.append(block)
        if not block.endswith("\n"):
            self.sourcecode_data.append("\n")

    def python_area_end(self, dummy):
        self.hightlight("python", self.sourcecode_data)

    #_________________________________________________________________________

    def code_area_start(self, block):
        """
        Sourcecode mit pygments
        """
        self.first_sourcecode_block = True
        self.sourcecode_type = None
        self.sourcecode_data = []

    def code_area(self, block):
        if self.first_sourcecode_block:
            # Aus der ersten Zeile den Typ des Sourcecodes ermitteln:
            # <code=sql> oder <code=.sh> oder <code>
            self.first_sourcecode_block = False
            code_type, block = block.split(">", 1)
            self.sourcecode_type = code_type.lstrip("=.")

        self.sourcecode_data.append("\n%s\n" % block)

    def code_area_end(self, dummy):
        """
        Wir sind, beim Endtag angekommen, dann zeigen wir mal den
        sourcecode... :)
        """
        self.hightlight(self.sourcecode_type, self.sourcecode_data)

    #_________________________________________________________________________

    def table(self, text):
        result = ""
        for line in text.splitlines():
            line = line.strip("|").split("|")
            result_line = ""
            for cell in line:
                if cell.startswith("="):
                    tag = "th"
                    cell = cell[1:]
                else:
                    tag = "td"
                cell = cell.strip()
                result_line += "\t<%(t)s>%(c)s</%(t)s>\n" % {
                    "t": tag, "c": cell
                }

            result += "<tr>\n%s</tr>\n" % result_line

        result = '<table>\n%s</table>\n' % result
        self.out.write(result)

    #_________________________________________________________________________

    def hightlight(self, source_type, code_lines):
        """
        Display Sourcecode.
        Try to use pygments, if exists.
        """
#        self.page_msg("Source type: '%s'" % source_type)

        code = "".join(code_lines)
        code = code.strip()

        from pylucid_project.apps.pylucid.markup.hightlighter import make_html
        html = make_html(code, source_type, django_escape=True)
        self.out.write(html)

    #_________________________________________________________________________

    def blockelements(self, block):
        "Anwenden der Block-rules. Formatieren des Absatzes"

        if block[0] in ("*", "#"):
            # Aktueller Block ist eine Liste
            self.build_list(block)
            return

        if block[0] == "|":
            # current block is a table
            self.table(block)
            return

        for rule in self.block_rules:
            txt, count = rule[0].subn(rule[1], block)

            if count != 0:
                # Ein Blockelement wurde gefunden
                self.out.write("%s\n" % txt)
                return

        # Kein Blockelement gefunden -> Formatierung des Absatzes
        block = block.strip().replace("\n", "<br />\n")
        self.out.write("<p>%s</p>\n" % block)

    def build_list(self, listitems):
        "Erzeugt eine Liste aus einem Absatz"

        def spacer(deep):
            return " " * (deep * 3)

        def write(number, tag, spacer):
            for i in range(number):
                self.out.write(spacer + tag)

        deep = 0
        for item in re.findall("([\*#]+) (.*)", listitems):
            currentlen = len(item[0])
            if item[0][0] == "*":
                # normale Aufzhlungsliste
                pre_tag = "<ul>\n"
                post_tag = "</ul>\n"
            else:
                # Nummerierte Liste
                pre_tag = "<ol>\n"
                post_tag = "</ol>\n"

            if currentlen > deep:
                write(currentlen - deep, pre_tag, spacer(deep))
                deep = currentlen
            elif currentlen < deep:
                write(deep - currentlen, post_tag, spacer(deep))
                deep = currentlen

            self.out.write(
                "%s<li>%s</li>\n" % (spacer(deep), item[1])
            )

        for i in range(deep):
            self.out.write(post_tag)

if __name__ == "__main__":
    # Quick test
    from tests.utils.FakeRequest import get_fake_context
    fake_context = get_fake_context()
    textile = TinyTextileParser(sys.stdout, fake_context)
    textile.parse(r"""
        a windows path:
        C:\windows\foo\bar
        a linux path:
        /usr/bin/python
        a manuel linebreak\\with two backslashes
    """)


########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid markup ajax preview view
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.core.exceptions import SuspiciousOperation, PermissionDenied
from django.http import HttpResponse

from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid.markup.forms import MarkupPreviewForm


def markup_preview(request):
    """
    markup preview AJAX view.
    """
    if not request.user.is_authenticated():
        raise PermissionDenied()

    if not request.is_ajax() or request.method != 'POST':
        raise SuspiciousOperation()

    form = MarkupPreviewForm(request.POST)
    if not form.is_valid():
        return HttpResponse("Error: Form not valid: %r" % form.errors)

    content = form.cleaned_data["content"]
    markup = form.cleaned_data["markup"]

    html = apply_markup(content, markup, request, escape_django_tags=True)

    return HttpResponse(html)




########NEW FILE########
__FILENAME__ = widgets
# coding: utf-8

"""
    PyLucid markup content form widget
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.forms.widgets import Textarea, Select
from django.template.loader import render_to_string


class MarkupContentWidget(Textarea):
    def render(self, name, value, attrs=None):
        form_field_html = super(MarkupContentWidget, self).render(name, value, attrs)
        context = {
            "form_field_html": form_field_html,
            "field_id": attrs['id'],
        }
        return render_to_string("pylucid/markup/content_widget.html", context)


class MarkupSelectWidget(Select):
    def render(self, name, value, attrs=None):
        form_field_html = super(MarkupSelectWidget, self).render(name, value, attrs)
        context = {
            "form_field_html": form_field_html,
            "field_id": attrs['id'],
        }
        return render_to_string("pylucid/markup/select_widget.html", context)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'ColorScheme'
        db.create_table('pylucid_colorscheme', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='colorscheme_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='colorscheme_lastupdateby', null=True, to=orm['auth.User'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=255)),
        ))
        db.send_create_signal('pylucid', ['ColorScheme'])

        # Adding model 'Color'
        db.create_table('pylucid_color', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='color_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='color_lastupdateby', null=True, to=orm['auth.User'])),
            ('colorscheme', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.ColorScheme'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('value', self.gf('pylucid_project.apps.pylucid.fields.ColorValueField')(max_length=6)),
        ))
        db.send_create_signal('pylucid', ['Color'])

        # Adding unique constraint on 'Color', fields ['colorscheme', 'name']
        db.create_unique('pylucid_color', ['colorscheme_id', 'name'])

        # Adding model 'Design'
        db.create_table('pylucid_design', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='design_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='design_lastupdateby', null=True, to=orm['auth.User'])),
            ('name', self.gf('django.db.models.fields.CharField')(unique=True, max_length=150)),
            ('template', self.gf('django.db.models.fields.CharField')(max_length=128)),
            ('colorscheme', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.ColorScheme'], null=True, blank=True)),
        ))
        db.send_create_signal('pylucid', ['Design'])

        # Adding M2M table for field sites on 'Design'
        db.create_table('pylucid_design_sites', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('design', models.ForeignKey(orm['pylucid.design'], null=False)),
            ('site', models.ForeignKey(orm['sites.site'], null=False))
        ))
        db.create_unique('pylucid_design_sites', ['design_id', 'site_id'])

        # Adding M2M table for field headfiles on 'Design'
        db.create_table('pylucid_design_headfiles', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('design', models.ForeignKey(orm['pylucid.design'], null=False)),
            ('editablehtmlheadfile', models.ForeignKey(orm['pylucid.editablehtmlheadfile'], null=False))
        ))
        db.create_unique('pylucid_design_headfiles', ['design_id', 'editablehtmlheadfile_id'])

        # Adding model 'EditableHtmlHeadFile'
        db.create_table('pylucid_editablehtmlheadfile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='editablehtmlheadfile_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='editablehtmlheadfile_lastupdateby', null=True, to=orm['auth.User'])),
            ('filepath', self.gf('django.db.models.fields.CharField')(unique=True, max_length=255)),
            ('mimetype', self.gf('django.db.models.fields.CharField')(max_length=64)),
            ('html_attributes', self.gf('django.db.models.fields.CharField')(max_length=256, blank=True)),
            ('render', self.gf('django.db.models.fields.BooleanField')(default=False)),
            ('description', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('content', self.gf('django.db.models.fields.TextField')()),
        ))
        db.send_create_signal('pylucid', ['EditableHtmlHeadFile'])

        # Adding model 'LogEntry'
        db.create_table('pylucid_logentry', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='logentry_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='logentry_lastupdateby', null=True, to=orm['auth.User'])),
            ('site', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sites.Site'])),
            ('app_label', self.gf('django.db.models.fields.CharField')(max_length=255, db_index=True)),
            ('action', self.gf('django.db.models.fields.CharField')(max_length=128, db_index=True)),
            ('message', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('long_message', self.gf('django.db.models.fields.TextField')(null=True, blank=True)),
            ('data', self.gf('dbpreferences.fields.DictField')(null=True, blank=True)),
            ('uri', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('used_language', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.Language'], null=True, blank=True)),
            ('remote_addr', self.gf('django.db.models.fields.IPAddressField')(db_index=True, max_length=15, null=True, blank=True)),
            ('remote_user', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('request_method', self.gf('django.db.models.fields.CharField')(max_length=8, null=True, blank=True)),
            ('query_string', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('http_referer', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('http_user_agent', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('http_accept_encoding', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
            ('http_accept_language', self.gf('django.db.models.fields.CharField')(max_length=255, null=True, blank=True)),
        ))
        db.send_create_signal('pylucid', ['LogEntry'])

        # Adding model 'BanEntry'
        db.create_table('pylucid_banentry', (
            ('ip_address', self.gf('django.db.models.fields.IPAddressField')(max_length=15, primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
        ))
        db.send_create_signal('pylucid', ['BanEntry'])

        # Adding model 'Language'
        db.create_table('pylucid_language', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='language_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='language_lastupdateby', null=True, to=orm['auth.User'])),
            ('code', self.gf('django_tools.fields.language_code.LanguageCodeModelField')(unique=True, max_length=10)),
            ('description', self.gf('django.db.models.fields.CharField')(max_length=150, blank=True)),
            ('permitViewGroup', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='language_permitViewGroup', null=True, to=orm['auth.Group'])),
        ))
        db.send_create_signal('pylucid', ['Language'])

        # Adding M2M table for field sites on 'Language'
        db.create_table('pylucid_language_sites', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('language', models.ForeignKey(orm['pylucid.language'], null=False)),
            ('site', models.ForeignKey(orm['sites.site'], null=False))
        ))
        db.create_unique('pylucid_language_sites', ['language_id', 'site_id'])

        # Adding model 'PageContent'
        db.create_table('pylucid_pagecontent', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagecontent_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagecontent_lastupdateby', null=True, to=orm['auth.User'])),
            ('pagemeta', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['pylucid.PageMeta'], unique=True)),
            ('content', self.gf('pylucid_project.apps.pylucid.fields.MarkupContentModelField')(blank=True)),
            ('markup', self.gf('pylucid_project.apps.pylucid.fields.MarkupModelField')(db_column='markup_id')),
        ))
        db.send_create_signal('pylucid', ['PageContent'])

        # Adding model 'PageMeta'
        db.create_table('pylucid_pagemeta', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagemeta_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagemeta_lastupdateby', null=True, to=orm['auth.User'])),
            ('pagetree', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.PageTree'])),
            ('language', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.Language'])),
            ('name', self.gf('django.db.models.fields.CharField')(max_length=150, blank=True)),
            ('title', self.gf('django.db.models.fields.CharField')(max_length=256, blank=True)),
            ('tags', self.gf('django_tools.tagging_addon.fields.jQueryTagModelField')()),
            ('keywords', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('description', self.gf('django.db.models.fields.CharField')(max_length=255, blank=True)),
            ('robots', self.gf('django.db.models.fields.CharField')(default='index,follow', max_length=255, blank=True)),
            ('permitViewGroup', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagemeta_permitViewGroup', null=True, to=orm['auth.Group'])),
        ))
        db.send_create_signal('pylucid', ['PageMeta'])

        # Adding unique constraint on 'PageMeta', fields ['pagetree', 'language']
        db.create_unique('pylucid_pagemeta', ['pagetree_id', 'language_id'])

        # Adding model 'PageTree'
        db.create_table('pylucid_pagetree', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagetree_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagetree_lastupdateby', null=True, to=orm['auth.User'])),
            ('parent', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.PageTree'], null=True, blank=True)),
            ('position', self.gf('django.db.models.fields.SmallIntegerField')(default=0)),
            ('slug', self.gf('django.db.models.fields.SlugField')(max_length=50, db_index=True)),
            ('site', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['sites.Site'])),
            ('page_type', self.gf('django.db.models.fields.CharField')(max_length=1)),
            ('design', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.Design'])),
            ('showlinks', self.gf('django.db.models.fields.BooleanField')(default=True)),
            ('permitViewGroup', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagetree_permitViewGroup', null=True, to=orm['auth.Group'])),
            ('permitEditGroup', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pagetree_permitEditGroup', null=True, to=orm['auth.Group'])),
        ))
        db.send_create_signal('pylucid', ['PageTree'])

        # Adding unique constraint on 'PageTree', fields ['site', 'slug', 'parent']
        db.create_unique('pylucid_pagetree', ['site_id', 'slug', 'parent_id'])

        # Adding model 'PluginPage'
        db.create_table('pylucid_pluginpage', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pluginpage_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='pluginpage_lastupdateby', null=True, to=orm['auth.User'])),
            ('pagetree', self.gf('django.db.models.fields.related.OneToOneField')(to=orm['pylucid.PageTree'], unique=True)),
            ('app_label', self.gf('pylucid_project.apps.pylucid.fields.RootAppChoiceField')(max_length=256)),
            ('urls_filename', self.gf('django.db.models.fields.CharField')(default='urls.py', max_length=256)),
        ))
        db.send_create_signal('pylucid', ['PluginPage'])

        # Adding model 'UserProfile'
        db.create_table('pylucid_userprofile', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='userprofile_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='userprofile_lastupdateby', null=True, to=orm['auth.User'])),
            ('user', self.gf('django.db.models.fields.related.ForeignKey')(related_name='userprofile_user', unique=True, to=orm['auth.User'])),
            ('sha_login_checksum', self.gf('django.db.models.fields.CharField')(max_length=192)),
            ('sha_login_salt', self.gf('django.db.models.fields.CharField')(max_length=5)),
        ))
        db.send_create_signal('pylucid', ['UserProfile'])

        # Adding M2M table for field sites on 'UserProfile'
        db.create_table('pylucid_userprofile_sites', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('userprofile', models.ForeignKey(orm['pylucid.userprofile'], null=False)),
            ('site', models.ForeignKey(orm['sites.site'], null=False))
        ))
        db.create_unique('pylucid_userprofile_sites', ['userprofile_id', 'site_id'])


    def backwards(self, orm):
        
        # Removing unique constraint on 'PageTree', fields ['site', 'slug', 'parent']
        db.delete_unique('pylucid_pagetree', ['site_id', 'slug', 'parent_id'])

        # Removing unique constraint on 'PageMeta', fields ['pagetree', 'language']
        db.delete_unique('pylucid_pagemeta', ['pagetree_id', 'language_id'])

        # Removing unique constraint on 'Color', fields ['colorscheme', 'name']
        db.delete_unique('pylucid_color', ['colorscheme_id', 'name'])

        # Deleting model 'ColorScheme'
        db.delete_table('pylucid_colorscheme')

        # Deleting model 'Color'
        db.delete_table('pylucid_color')

        # Deleting model 'Design'
        db.delete_table('pylucid_design')

        # Removing M2M table for field sites on 'Design'
        db.delete_table('pylucid_design_sites')

        # Removing M2M table for field headfiles on 'Design'
        db.delete_table('pylucid_design_headfiles')

        # Deleting model 'EditableHtmlHeadFile'
        db.delete_table('pylucid_editablehtmlheadfile')

        # Deleting model 'LogEntry'
        db.delete_table('pylucid_logentry')

        # Deleting model 'BanEntry'
        db.delete_table('pylucid_banentry')

        # Deleting model 'Language'
        db.delete_table('pylucid_language')

        # Removing M2M table for field sites on 'Language'
        db.delete_table('pylucid_language_sites')

        # Deleting model 'PageContent'
        db.delete_table('pylucid_pagecontent')

        # Deleting model 'PageMeta'
        db.delete_table('pylucid_pagemeta')

        # Deleting model 'PageTree'
        db.delete_table('pylucid_pagetree')

        # Deleting model 'PluginPage'
        db.delete_table('pylucid_pluginpage')

        # Deleting model 'UserProfile'
        db.delete_table('pylucid_userprofile')

        # Removing M2M table for field sites on 'UserProfile'
        db.delete_table('pylucid_userprofile_sites')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'pylucid.banentry': {
            'Meta': {'ordering': "('-createtime',)", 'object_name': 'BanEntry'},
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'primary_key': 'True'})
        },
        'pylucid.color': {
            'Meta': {'ordering': "('colorscheme', 'name')", 'unique_together': "(('colorscheme', 'name'),)", 'object_name': 'Color'},
            'colorscheme': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.ColorScheme']"}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'color_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'color_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'value': ('pylucid_project.apps.pylucid.fields.ColorValueField', [], {'max_length': '6'})
        },
        'pylucid.colorscheme': {
            'Meta': {'object_name': 'ColorScheme'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'colorscheme_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'colorscheme_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'pylucid.design': {
            'Meta': {'ordering': "('template',)", 'object_name': 'Design'},
            'colorscheme': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.ColorScheme']", 'null': 'True', 'blank': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'design_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'headfiles': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['pylucid.EditableHtmlHeadFile']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'design_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '150'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'template': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'pylucid.editablehtmlheadfile': {
            'Meta': {'ordering': "('filepath',)", 'object_name': 'EditableHtmlHeadFile'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'editablehtmlheadfile_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'filepath': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'html_attributes': ('django.db.models.fields.CharField', [], {'max_length': '256', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'editablehtmlheadfile_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'render': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'pylucid.language': {
            'Meta': {'ordering': "('code',)", 'object_name': 'Language'},
            'code': ('django_tools.fields.language_code.LanguageCodeModelField', [], {'unique': 'True', 'max_length': '10'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'pylucid.logentry': {
            'Meta': {'ordering': "('-createtime',)", 'object_name': 'LogEntry'},
            'action': ('django.db.models.fields.CharField', [], {'max_length': '128', 'db_index': 'True'}),
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'logentry_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'data': ('dbpreferences.fields.DictField', [], {'null': 'True', 'blank': 'True'}),
            'http_accept_encoding': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_accept_language': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_referer': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_user_agent': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'logentry_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'long_message': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'query_string': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'remote_addr': ('django.db.models.fields.IPAddressField', [], {'db_index': 'True', 'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'remote_user': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'request_method': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True', 'blank': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'uri': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'used_language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']", 'null': 'True', 'blank': 'True'})
        },
        'pylucid.pagecontent': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'object_name': 'PageContent'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {'blank': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagecontent_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagecontent_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {'db_column': "'markup_id'"}),
            'pagemeta': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['pylucid.PageMeta']", 'unique': 'True'})
        },
        'pylucid.pagemeta': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'unique_together': "(('pagetree', 'language'),)", 'object_name': 'PageMeta'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'keywords': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'pagetree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.PageTree']"}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'robots': ('django.db.models.fields.CharField', [], {'default': "'index,follow'", 'max_length': '255', 'blank': 'True'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'blank': 'True'})
        },
        'pylucid.pagetree': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'unique_together': "(('site', 'slug', 'parent'),)", 'object_name': 'PageTree'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'design': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Design']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'page_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.PageTree']", 'null': 'True', 'blank': 'True'}),
            'permitEditGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_permitEditGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'position': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'showlinks': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'pylucid.pluginpage': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'object_name': 'PluginPage'},
            'app_label': ('pylucid_project.apps.pylucid.fields.RootAppChoiceField', [], {'max_length': '256'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pluginpage_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pluginpage_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'pagetree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['pylucid.PageTree']", 'unique': 'True'}),
            'urls_filename': ('django.db.models.fields.CharField', [], {'default': "'urls.py'", 'max_length': '256'})
        },
        'pylucid.userprofile': {
            'Meta': {'ordering': "('user',)", 'object_name': 'UserProfile'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'userprofile_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'userprofile_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'sha_login_checksum': ('django.db.models.fields.CharField', [], {'max_length': '192'}),
            'sha_login_salt': ('django.db.models.fields.CharField', [], {'max_length': '5'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'userprofile_user'", 'unique': 'True', 'to': "orm['auth.User']"})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['pylucid']

########NEW FILE########
__FILENAME__ = 0002_auto__chg_field_pagecontent_markup
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Renaming column for 'PageContent.markup' to match new field type.
        db.rename_column('pylucid_pagecontent', 'markup_id', 'markup')
        # Changing field 'PageContent.markup'
        db.alter_column('pylucid_pagecontent', 'markup', self.gf('pylucid_project.apps.pylucid.fields.MarkupModelField')())


    def backwards(self, orm):
        # Renaming column for 'PageContent.markup' to match new field type.
        db.rename_column('pylucid_pagecontent', 'markup', 'markup_id')
        # Changing field 'PageContent.markup'
        db.alter_column('pylucid_pagecontent', 'markup_id', self.gf('pylucid_project.apps.pylucid.fields.MarkupModelField')(db_column='markup_id'))


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'pylucid.banentry': {
            'Meta': {'ordering': "('-createtime',)", 'object_name': 'BanEntry'},
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'primary_key': 'True'})
        },
        'pylucid.color': {
            'Meta': {'ordering': "('colorscheme', 'name')", 'unique_together': "(('colorscheme', 'name'),)", 'object_name': 'Color'},
            'colorscheme': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.ColorScheme']"}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'color_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'color_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'value': ('pylucid_project.apps.pylucid.fields.ColorValueField', [], {'max_length': '6'})
        },
        'pylucid.colorscheme': {
            'Meta': {'object_name': 'ColorScheme'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'colorscheme_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'colorscheme_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'pylucid.design': {
            'Meta': {'ordering': "('template',)", 'object_name': 'Design'},
            'colorscheme': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.ColorScheme']", 'null': 'True', 'blank': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'design_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'headfiles': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['pylucid.EditableHtmlHeadFile']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'design_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '150'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'template': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'pylucid.editablehtmlheadfile': {
            'Meta': {'ordering': "('filepath',)", 'object_name': 'EditableHtmlHeadFile'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'editablehtmlheadfile_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'filepath': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'html_attributes': ('django.db.models.fields.CharField', [], {'max_length': '256', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'editablehtmlheadfile_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'render': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'pylucid.language': {
            'Meta': {'ordering': "('code',)", 'object_name': 'Language'},
            'code': ('django_tools.fields.language_code.LanguageCodeModelField', [], {'unique': 'True', 'max_length': '10'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'pylucid.logentry': {
            'Meta': {'ordering': "('-createtime',)", 'object_name': 'LogEntry'},
            'action': ('django.db.models.fields.CharField', [], {'max_length': '128', 'db_index': 'True'}),
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'logentry_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'data': ('dbpreferences.fields.DictField', [], {'null': 'True', 'blank': 'True'}),
            'http_accept_encoding': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_accept_language': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_referer': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_user_agent': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'logentry_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'long_message': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'query_string': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'remote_addr': ('django.db.models.fields.IPAddressField', [], {'db_index': 'True', 'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'remote_user': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'request_method': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True', 'blank': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'uri': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'used_language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']", 'null': 'True', 'blank': 'True'})
        },
        'pylucid.pagecontent': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'object_name': 'PageContent'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {'blank': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagecontent_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagecontent_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {}),
            'pagemeta': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['pylucid.PageMeta']", 'unique': 'True'})
        },
        'pylucid.pagemeta': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'unique_together': "(('pagetree', 'language'),)", 'object_name': 'PageMeta'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'keywords': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'pagetree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.PageTree']"}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'robots': ('django.db.models.fields.CharField', [], {'default': "'index,follow'", 'max_length': '255', 'blank': 'True'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'blank': 'True'})
        },
        'pylucid.pagetree': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'unique_together': "(('site', 'slug', 'parent'),)", 'object_name': 'PageTree'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'design': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Design']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'page_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.PageTree']", 'null': 'True', 'blank': 'True'}),
            'permitEditGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_permitEditGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'position': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'showlinks': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50', 'db_index': 'True'})
        },
        'pylucid.pluginpage': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'object_name': 'PluginPage'},
            'app_label': ('pylucid_project.apps.pylucid.fields.RootAppChoiceField', [], {'max_length': '256'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pluginpage_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pluginpage_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'pagetree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['pylucid.PageTree']", 'unique': 'True'}),
            'urls_filename': ('django.db.models.fields.CharField', [], {'default': "'urls.py'", 'max_length': '256'})
        },
        'pylucid.userprofile': {
            'Meta': {'ordering': "('user',)", 'object_name': 'UserProfile'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'userprofile_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'userprofile_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'sha_login_checksum': ('django.db.models.fields.CharField', [], {'max_length': '192'}),
            'sha_login_salt': ('django.db.models.fields.CharField', [], {'max_length': '5'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'userprofile_user'", 'unique': 'True', 'to': "orm['auth.User']"})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['pylucid']

########NEW FILE########
__FILENAME__ = 0003_django_v1_4
# coding: utf-8

import datetime
from south.db import db
from south.v2 import DataMigration
from django.db import models

class Migration(DataMigration):

    def forwards(self, orm):
        "Write your forwards methods here."
        for template in orm['dbtemplates.template'].objects.all():
            content = template.content
            content = content.replace(u"{{ Django_media_prefix }}", u"{{ STATIC_URL }}admin/")
            content = content.replace(u"{{ PyLucid_media_url }}", u"{{ STATIC_URL }}PyLucid/")
            if content != template.content:
                print " * Update template: %r" % template.name
                template.content = content
                template.save()

    def backwards(self, orm):
        "Write your backwards methods here."
        for template in orm['dbtemplates.template'].objects.all():
            content = template.content
            content = content.replace(u"{{ STATIC_URL }}admin/", u"{{ Django_media_prefix }}")
            content = content.replace(u"{{ STATIC_URL }}PyLucid/", u"{{ PyLucid_media_url }}")
            if content != template.content:
                print " * Revered template: %r" % template.name
                template.save()

    models = {
        'dbtemplates.template': {
            'Meta': {'ordering': "('name',)", 'object_name': 'Template', 'db_table': "'django_template'"},
            'content': ('django.db.models.fields.TextField', [], {'blank': 'True'}),
            'creation_date': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'last_changed': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['sites.Site']", 'null': 'True', 'blank': 'True'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['dbtemplates']
    symmetrical = True

########NEW FILE########
__FILENAME__ = 0004_salt_length
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    def forwards(self, orm):
        # Changing field 'UserProfile.sha_login_salt'
        db.alter_column('pylucid_userprofile', 'sha_login_salt', self.gf('django.db.models.fields.CharField')(max_length=12))

    def backwards(self, orm):
        # Changing field 'UserProfile.sha_login_salt'
        db.alter_column('pylucid_userprofile', 'sha_login_salt', self.gf('django.db.models.fields.CharField')(max_length=5))

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'pylucid.banentry': {
            'Meta': {'ordering': "('-createtime',)", 'object_name': 'BanEntry'},
            'createtime': ('django.db.models.fields.DateTimeField', [], {}),
            'ip_address': ('django.db.models.fields.IPAddressField', [], {'max_length': '15', 'primary_key': 'True'})
        },
        'pylucid.color': {
            'Meta': {'ordering': "('colorscheme', 'name')", 'unique_together': "(('colorscheme', 'name'),)", 'object_name': 'Color'},
            'colorscheme': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.ColorScheme']"}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'color_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'color_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'value': ('pylucid_project.apps.pylucid.fields.ColorValueField', [], {'max_length': '6'})
        },
        'pylucid.colorscheme': {
            'Meta': {'object_name': 'ColorScheme'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'colorscheme_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'colorscheme_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '255'})
        },
        'pylucid.design': {
            'Meta': {'ordering': "('template',)", 'object_name': 'Design'},
            'colorscheme': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.ColorScheme']", 'null': 'True', 'blank': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'design_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'headfiles': ('django.db.models.fields.related.ManyToManyField', [], {'symmetrical': 'False', 'to': "orm['pylucid.EditableHtmlHeadFile']", 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'design_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '150'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'template': ('django.db.models.fields.CharField', [], {'max_length': '128'})
        },
        'pylucid.editablehtmlheadfile': {
            'Meta': {'ordering': "('filepath',)", 'object_name': 'EditableHtmlHeadFile'},
            'content': ('django.db.models.fields.TextField', [], {}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'editablehtmlheadfile_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'filepath': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '255'}),
            'html_attributes': ('django.db.models.fields.CharField', [], {'max_length': '256', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'editablehtmlheadfile_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'mimetype': ('django.db.models.fields.CharField', [], {'max_length': '64'}),
            'render': ('django.db.models.fields.BooleanField', [], {'default': 'False'})
        },
        'pylucid.language': {
            'Meta': {'ordering': "('code',)", 'object_name': 'Language'},
            'code': ('django_tools.fields.language_code.LanguageCodeModelField', [], {'unique': 'True', 'max_length': '10'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'pylucid.logentry': {
            'Meta': {'ordering': "('-createtime',)", 'object_name': 'LogEntry'},
            'action': ('django.db.models.fields.CharField', [], {'max_length': '128', 'db_index': 'True'}),
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '255', 'db_index': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'logentry_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'data': ('dbpreferences.fields.DictField', [], {'null': 'True', 'blank': 'True'}),
            'http_accept_encoding': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_accept_language': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_referer': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'http_user_agent': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'logentry_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'long_message': ('django.db.models.fields.TextField', [], {'null': 'True', 'blank': 'True'}),
            'message': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'query_string': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'remote_addr': ('django.db.models.fields.IPAddressField', [], {'db_index': 'True', 'max_length': '15', 'null': 'True', 'blank': 'True'}),
            'remote_user': ('django.db.models.fields.CharField', [], {'max_length': '255', 'null': 'True', 'blank': 'True'}),
            'request_method': ('django.db.models.fields.CharField', [], {'max_length': '8', 'null': 'True', 'blank': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'uri': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'used_language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']", 'null': 'True', 'blank': 'True'})
        },
        'pylucid.pagecontent': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'object_name': 'PageContent'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {'blank': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagecontent_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagecontent_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {}),
            'pagemeta': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['pylucid.PageMeta']", 'unique': 'True'})
        },
        'pylucid.pagemeta': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'unique_together': "(('pagetree', 'language'),)", 'object_name': 'PageMeta'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'keywords': ('django.db.models.fields.CharField', [], {'max_length': '255', 'blank': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'pagetree': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.PageTree']"}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagemeta_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'robots': ('django.db.models.fields.CharField', [], {'default': "'index,follow'", 'max_length': '255', 'blank': 'True'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {}),
            'title': ('django.db.models.fields.CharField', [], {'max_length': '256', 'blank': 'True'})
        },
        'pylucid.pagetree': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'unique_together': "(('site', 'slug', 'parent'),)", 'object_name': 'PageTree'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'design': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Design']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'page_type': ('django.db.models.fields.CharField', [], {'max_length': '1'}),
            'parent': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.PageTree']", 'null': 'True', 'blank': 'True'}),
            'permitEditGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_permitEditGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pagetree_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'position': ('django.db.models.fields.SmallIntegerField', [], {'default': '0'}),
            'showlinks': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'site': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['sites.Site']"}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '50'})
        },
        'pylucid.pluginpage': {
            'Meta': {'ordering': "('-lastupdatetime',)", 'object_name': 'PluginPage'},
            'app_label': ('pylucid_project.apps.pylucid.fields.RootAppChoiceField', [], {'max_length': '256'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pluginpage_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'pluginpage_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'pagetree': ('django.db.models.fields.related.OneToOneField', [], {'to': "orm['pylucid.PageTree']", 'unique': 'True'}),
            'urls_filename': ('django.db.models.fields.CharField', [], {'default': "'urls.py'", 'max_length': '256'})
        },
        'pylucid.userprofile': {
            'Meta': {'ordering': "('user',)", 'object_name': 'UserProfile'},
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'userprofile_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'userprofile_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'sha_login_checksum': ('django.db.models.fields.CharField', [], {'max_length': '192'}),
            'sha_login_salt': ('django.db.models.fields.CharField', [], {'max_length': '12'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'user': ('django.db.models.fields.related.ForeignKey', [], {'related_name': "'userprofile_user'", 'unique': 'True', 'to': "orm['auth.User']"})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['pylucid']

########NEW FILE########
__FILENAME__ = colorscheme
# coding: utf-8


"""
    PyLucid models
    ~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import re

from django.contrib import messages
from django.core.exceptions import ValidationError
from django.db import models
from django.db.utils import IntegrityError
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

from django_tools.utils.messages import failsafe_message
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.apps.pylucid.fields import ColorValueField
from pylucid_project.utils.css_color_utils import get_new_css_names


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


def slugify_colorname(value):
    """
    Normalizes string, converts, removes non-alpha characters,
    and converts spaces to "_".
    
    Based on code from: django.template.defaultfilters.slugify
    """
    import unicodedata
    value = unicodedata.normalize('NFKD', value).encode('ascii', 'ignore')
    value = unicode(re.sub('[^\w\s-]', '', value))
    return re.sub('[-\s]+', '_', value)



class ColorScheme(UpdateInfoBaseModel):
    """
    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    name = models.CharField(max_length=255, help_text="The name of this color scheme.")

    def cleanup(self, request):
        """ remove all unused colors """
        from pylucid_project.apps.pylucid.models import Design, Color

        existing_colors = set()
        designs = Design.objects.all().filter(colorscheme=self)
        for design in designs:
            headfiles = design.headfiles.all().filter(render=True)
            for headfile in headfiles:
                css_names = get_new_css_names(existing_colors=(), content=headfile.content)
                existing_colors.update(set(css_names))

        messages.info(request,
            _("existing colors: %s") % ", ".join(['"%s"' % c for c in existing_colors])
        )

        queryset = Color.objects.all().filter(colorscheme=self).exclude(name__in=existing_colors)
        color_names = queryset.values_list('name', flat=True)
        if not color_names:
            messages.info(request, _("No unused colors found, ok."))
        else:
            messages.info(request, _("remove %(count)i colors: %(names)s") % {
                "count": len(color_names),
                "names": ", ".join(['"%s"' % n for n in color_names]),
            })
        queryset.delete()

    def score_match(self, colors):
        """ Weighted matches of the given color values. """
        queryset = Color.objects.filter(colorscheme=self)
        existing_colors = queryset.values_list('value', flat=True)

        score = 0
        for color in colors:
            if color in existing_colors:
                score += 1
            else:
                score -= 1

        return score

    def get_color_dict(self):
        queryset = Color.objects.filter(colorscheme=self)
        color_list = queryset.values_list('name', 'value')
        return dict(color_list)

    def get_color_names(self):
        queryset = Color.objects.filter(colorscheme=self)
        color_list = queryset.values_list('name', flat=True)
        return color_list

    def __unicode__(self):
        return self.name

    class Meta:
        app_label = 'pylucid'



class Color(UpdateInfoBaseModel):
    """
    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    colorscheme = models.ForeignKey(ColorScheme)
    name = models.CharField(max_length=128,
        help_text="Name if this color (e.g. main_color, head_background)"
    )
    value = ColorValueField(help_text="CSS hex color value.")

    def clean_fields(self, exclude):
        message_dict = {}

        if "name" not in exclude:
            self.name = self.name.strip()
            test_name = slugify_colorname(self.name)
            if self.name != test_name:
                message_dict["name"] = [mark_safe(_("Name is not a slug! Use e.g.: <strong>%s</strong>") % test_name)]

        if message_dict:
            raise ValidationError(message_dict)

    def delete(self, *args, **kwargs):
        """ Check if this color is in use somewhere """
        from design import Design # import here, against import loops
        designs = Design.objects.all().filter(colorscheme=self.colorscheme)
        placeholder = u"{{ %s }}" % self.name
        for design in designs:
            headfiles = design.headfiles.all().filter(render=True)
            for headfile in headfiles:
                content = headfile.content
                if placeholder in content:
                    raise IntegrityError(
                        "Color %r can't be deleted, because it used at least in headfile %s" % (
                            self.name, headfile
                        )

                    )
        return super(Color, self).delete(*args, **kwargs)

    def save(self, *args, **kwargs):
        if kwargs.pop("skip_renaming", False):
            # Other color was renamed in the past, we are here inner
            # renaming process, don't check renaming here, becuase we must
            # skip a closed renaming loop ;)
            super(Color, self).save(*args, **kwargs)
            return

        new_name = old_name = self.name
        try:
            old_name = Color.objects.get(id=self.id).name
        except Color.DoesNotExist:
            # New color
            pass

        if new_name != old_name:
            # Color name has been changed.
            from pylucid_project.apps.pylucid.models import Design

            changed_headfiles = []
            processed_headfiles = []
            changed_colorschemes = [self.colorscheme]

            # process every headfile witch has the same colorscheme 
            designs = Design.objects.all().filter(colorscheme=self.colorscheme)
            for design in designs:
                headfiles = design.headfiles.all().filter(render=True)
                for headfile in headfiles:
                    if headfile in processed_headfiles:
                        continue
                    processed_headfiles.append(headfile)
                    changed = headfile.rename_color(new_name, old_name)
                    if changed:
                        changed_headfiles.append(headfile)

            # process every colorscheme from the processed headfiles
            designs = Design.objects.all().exclude(colorscheme=self.colorscheme)
            for design in designs:
                colorscheme = design.colorscheme
                if colorscheme in changed_colorschemes:
                    continue
                headfiles = design.headfiles.all().filter(render=True)
                for headfile in headfiles:
                    if headfile in processed_headfiles:

                        color = Color.objects.get(colorscheme=colorscheme, name=old_name)
                        color.name = new_name
                        color.save(skip_renaming=True)

                        changed_colorschemes.append(colorscheme)
                        break

            failsafe_message(
                _(
                    'Color "%(old_name)s" renamed to "%(new_name)s":'
                    'Headfiles %(headfiles)s and colorschemes %(schemes)s updated.'
                ) % {
                    "old_name": old_name, "new_name": new_name,
                    "headfiles": ", ".join(['"%s"' % h.filepath for h in changed_headfiles]),
                    "schemes": ", ".join(['"%s"' % s.name for s in changed_colorschemes]),

                }
            )

        super(Color, self).save(*args, **kwargs)

    def __unicode__(self):
        return u"Color '%s' #%s (%s)" % (self.name, self.value, self.colorscheme)

    class Meta:
        app_label = 'pylucid'
        unique_together = (("colorscheme", "name"),)
        ordering = ("colorscheme", "name")



########NEW FILE########
__FILENAME__ = design
# coding: utf-8


"""
    PyLucid Design model
    ~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.core.exceptions import ValidationError
from django.db import models
from django.template import TemplateDoesNotExist
from django.template.loader import find_template, render_to_string
from django.utils.translation import ugettext_lazy as _

from django_tools.models import UpdateInfoBaseModel

from pylucid_project.base_models.many2many import SiteM2M

# other PyLucid models
from colorscheme import ColorScheme


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


class DesignManager(models.Manager):
    pass


class Design(SiteM2M, UpdateInfoBaseModel):
    """
    Page design: template + CSS/JS files 

    inherited attributes from SiteM2M:
        sites   -> ManyToManyField to Site
        on_site -> sites.managers.CurrentSiteManager instance

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = DesignManager()

    name = models.CharField(unique=True, max_length=150, help_text=_("Name of this design combination"),)
    template = models.CharField(max_length=128, help_text="filename of the used template for this page")
    headfiles = models.ManyToManyField("pylucid.EditableHtmlHeadFile", null=True, blank=True,
        help_text=_("Static files (stylesheet/javascript) for this page, included in html head via link tag")
    )
    colorscheme = models.ForeignKey(ColorScheme, null=True, blank=True)

    def clean_fields(self, exclude):
        message_dict = {}

        if "template" not in exclude:
            try:
                find_template(self.template)
            except TemplateDoesNotExist, err:
                message_dict["template"] = [_("Template doesn't exist.")]

        if message_dict:
            raise ValidationError(message_dict)

    def get_headfile_data(self):
        """
        Returns all headfiles with inline compressed data
        """
        colorscheme = self.colorscheme
        headfiles = self.headfiles.all()

        inline_css_data = []
        inline_js_data = []

        for headfile in headfiles:
            headfile_type = headfile.get_type()
            inline_html = headfile.get_inline_html(colorscheme)

            if headfile_type == "css":
                inline_css_data.append(inline_html)
            elif headfile_type == "js":
                inline_js_data.append(inline_html)
            else:
                raise NotImplementedError("Datatype %r unknown!" % headfile_type)

        context = {
            "design": self,
            "colorscheme": self.colorscheme,
            "inline_css_data": inline_css_data,
            "inline_js_data": inline_js_data
        }
        headfile_data = render_to_string("pylucid/headfile_data.html", context)
        return headfile_data

    def __unicode__(self):
        sites = self.sites.values_list('name', flat=True)
        return u"Page design '%s' (on sites: %r)" % (self.name, sites)

    class Meta:
        app_label = 'pylucid'
        ordering = ("template",)

########NEW FILE########
__FILENAME__ = editable_headfile
# coding: utf-8


"""
    PyLucid models
    ~~~~~~~~~~~~~~

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os
import mimetypes

from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.urlresolvers import reverse, NoReverseMatch
from django.db import models
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools.models import UpdateInfoBaseModel
from django_tools.template import render
from django_tools.utils.messages import failsafe_message

from pylucid_project.utils.css_color_utils import unify_spelling, \
                        get_new_css_names, replace_css_name, unique_color_name
from pylucid_project.apps.pylucid.system import headfile

# other PyLucid models
from colorscheme import Color
from design import Design
from django.template.loader import render_to_string


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


class EditableHtmlHeadFileManager(models.Manager):
    def iter_headfiles_by_colorscheme(self, colorscheme):
        designs = Design.objects.all().filter(colorscheme=colorscheme)
        for design in designs:
            headfiles = design.headfiles.all()
            for headfile in headfiles:
                yield headfile

    def get_HeadfileLink(self, filename):
        """
        returns a pylucid.system.headfile.Headfile instance
        """
        db_instance = self.get(filename=filename)
        return headfile.HeadfileLink(filename=db_instance.filename)


class EditableHtmlHeadFile(UpdateInfoBaseModel):
    """
    Storage for editable static text files, e.g.: stylesheet / javascript.

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = EditableHtmlHeadFileManager()

    filepath = models.CharField(max_length=255, unique=True)
    mimetype = models.CharField(max_length=64,
        help_text=_("MIME type for this file. (Leave empty for guess by filename)")
    )
    html_attributes = models.CharField(max_length=256, null=False, blank=True,
        help_text=_('Additional html tag attributes (CSS example: media="screen")')
    )
    render = models.BooleanField(default=False,
        help_text=_("Are there CSS ColorScheme entries in the content?")
    )
    description = models.TextField(null=True, blank=True)
    content = models.TextField()

    def get_filename(self):
        """ returns only the filename """
        return os.path.split(self.filepath)[1]

    def get_file_extension(self):
        """ return the file extension, e.g.: '.css' or '.js' """
        return os.path.splitext(self.filepath)[1].lower()

    def get_type(self):
        return self.get_file_extension().lstrip(".")

    def get_rendered(self, colorscheme):
        color_dict = colorscheme.get_color_dict()

        for name, value in color_dict.iteritems():
            color_dict[name] = "#%s" % value

        rendered_content = render.render_string_template(self.content, color_dict)
        return rendered_content

    def get_inline_html(self, colorscheme=None):
        if colorscheme:
            rendered_content = self.get_rendered(colorscheme)
        else:
            if self.render == True:
                raise AssertionError("This file should be rendered, but no colorscheme given!")
            rendered_content = self.content

        file_type = self.get_type()
        template = "pylucid/headfile_inline_%s.html" % file_type

        context = {
            "instance": self,
            "colorscheme": colorscheme,
            "rendered_content": rendered_content,
        }
        inline_html = render_to_string(template, context)
        return inline_html

    def iter_colorschemes(self, skip_colorschemes=None):
        """ TODO: Optimizes this """
        if skip_colorschemes is None:
            skip_colorschemes = []

        designs = Design.objects.all().filter()
        for design in designs:
            colorscheme = design.colorscheme
            if colorscheme in skip_colorschemes:
                continue
            headfiles = design.headfiles.filter(pk=self.pk)
            for headfile in headfiles:
                if headfile == self:
                    skip_colorschemes.append(colorscheme)
                    yield colorscheme

    def clean_fields(self, exclude):
        message_dict = {}

        if not self.mimetype and self.filepath:
            # Set mimetype by guess type from filepath
            self.mimetype = self.auto_mimetype()

        if "mimetype" not in exclude:
            all_mimetypes = set(mimetypes.types_map.values())
            if self.mimetype not in all_mimetypes:
                failsafe_message(
                    "Warning: Mimetype %(mimetype)r for headfile %(headfile)r unknown!" % {
                        "mimetype": self.mimetype, "headfile": self.filepath
                    }
                )

        if "filepath" not in exclude:
            try:
                # "validate" the filepath with the url re. 
                reverse('PyLucid-send_head_file', kwargs={"filepath": self.filepath})
            except NoReverseMatch, err:
                message_dict["filepath"] = [_(
                    "filepath %(filepath)r contains invalid characters!"
                    " (Original error: %(err)s)" % {
                        "filepath": self.filepath,
                        "err": err,
                    }
                )]

        if "render" not in exclude and self.render:
            has_colorscheme = False
            designs = Design.objects.all().exclude(colorscheme=None)
            for design in designs:
                its_me = design.headfiles.filter(pk=self.pk).count()
                if its_me:
                    has_colorscheme = True
                    break
            if not has_colorscheme:
                message_dict["render"] = [_("This headfile can't be rendered, because it's not used in a design witch has a colorscheme!")]

        if "content" not in exclude and self.render:
            for colorscheme in self.iter_colorschemes():
                existing_colors = colorscheme.get_color_names()
                css_names = get_new_css_names(existing_colors, self.content)
                if css_names:
                    if "content" not in message_dict:
                        message_dict["content"] = []
                    message_dict["content"].append(
                        _("Theses CSS color names %(css_names)s are unknown in %(colorscheme)s") % {
                            "colorscheme": colorscheme,
                            "css_names": ", ".join(["'%s'" % css_name for css_name in css_names])
                        }
                    )

        if message_dict:
            raise ValidationError(message_dict)

    def auto_mimetype(self):
        """ returns the mimetype for the current filename """
        fileext = self.get_file_extension()
        if fileext == ".css":
            return u"text/css"
        elif fileext == ".js":
            return u"text/javascript"
        else:
            return mimetypes.guess_type(self.filepath)[0] or u"application/octet-stream"

    def rename_color(self, new_name, old_name):
        """
        Rename a color in headfile content.
        called e.g. from Color model
        """
        # Replace color name in headfile content
        old_content = self.content
        new_content = replace_css_name(old_name, new_name, old_content)
        if old_content == new_content:
            if settings.DEBUG:
                failsafe_message(
                    'Color "{{ %s }}" not exist in headfile "%s"' % (old_name, self.filepath)
                )
            return False
        else:
            self.content = new_content
            self.save()
            if settings.DEBUG:
                failsafe_message(
                    "change color name from '%s' to '%s' in %r" % (old_name, new_name, self.filepath)
                )
            return True

    def update_colorscheme(self):
        """
        merge colors from headfiles with the colorscheme.
        """
        if not self.render:
            # No CSS ColorScheme entries in the content -> do nothing
            return

        # Get all existing color values from content 
        content, content_colors = unify_spelling(self.content)

        # Find the most appropriate entry that has the most match colors.
        best_score = None
        best_colorscheme = None
        tested_colorschemes = 0
        for colorscheme in self.iter_colorschemes():
            tested_colorschemes += 1
            score = colorscheme.score_match(content_colors)
            if score > best_score:
                best_colorscheme = colorscheme
                best_score = score

        if best_colorscheme is None:
            failsafe_message(
                _('No existing colorscheme to merge colors found, ok. (tested %s colorschemes)') % tested_colorschemes
            )
            best_colorscheme_dict = {}
            values2colors = {}
            colorschemes_data = {}
        else:
            failsafe_message(
                _('Merge colors with colorscheme "%(name)s" (score: %(score)s, tested %(count)s colorschemes)') % {
                    "name": best_colorscheme.name,
                    "score": best_score,
                    "count": tested_colorschemes,
                }
            )
            best_colorscheme_dict = best_colorscheme.get_color_dict()
            values2colors = dict([(v, k) for k, v in best_colorscheme_dict.iteritems()])
            colorschemes_data = {best_colorscheme:best_colorscheme_dict}

        existing_color_names = set(best_colorscheme_dict.keys())
        if settings.DEBUG:
            failsafe_message("Use existing colors: %r" % existing_color_names)

        # Check witch colors are not exist in best colorscheme, yet:
        best_colorscheme_values = best_colorscheme_dict.values()
        new_color_values = []
        for color_value in content_colors:
            if color_value not in best_colorscheme_values:
                new_color_values.append(color_value)

        # Collect color information from all other colorschemes witch used this headfile:
        for colorscheme in self.iter_colorschemes(skip_colorschemes=colorschemes_data.keys()):
            color_dict = colorscheme.get_color_dict()
            colorschemes_data[colorscheme] = color_dict
            for color_name, color_value in color_dict.iteritems():
                existing_color_names.add(color_name)
                if color_value not in values2colors:
                    values2colors[color_value] = color_name

        # Create all new colors in any other colorscheme witch used this headfile:
        for new_color_value in new_color_values:
            if new_color_value in values2colors:
                # Use color name from a other colorscheme
                color_name = values2colors[new_color_value]
            else:
                # this color value doesn't exist in any colorscheme, give it a unique name
                color_name = unique_color_name(existing_color_names, new_color_value)
                values2colors[new_color_value] = color_name
                existing_color_names.add(color_name)

        # Replace colors in content and create not existing in every colorscheme
        update_info = {}
        for color_value, color_name in values2colors.iteritems():
            # Replace colors with django template placeholders
            content = content.replace("#%s;" % color_value, "{{ %s }};" % color_name)

            # Create new colors
            for colorscheme in self.iter_colorschemes():
                color_dict = colorschemes_data[colorscheme]
                if color_name in color_dict:
                    # This color exist in this colorscheme
                    continue

                color, created = Color.objects.get_or_create(
                    colorscheme=colorscheme, name=color_name,
                    defaults={"value": color_value}
                )
                color.save()
                if created:
                    if colorscheme not in update_info:
                        update_info[colorscheme] = []
                    update_info[colorscheme].append(color)

        # Create page messages
        for colorscheme, created_colors in update_info.iteritems():
            msg = _('Colors %(colors)s created in colorscheme "%(scheme)s"') % {
                "colors": ", ".join(['"%s:%s"' % (c.name, c.value) for c in created_colors]),
                "scheme": colorscheme.name,
            }
            failsafe_message(msg)

        self.content = content

    def save(self, *args, **kwargs):
        self.update_colorscheme()
        super(EditableHtmlHeadFile, self).save(*args, **kwargs)

    def __unicode__(self):
        return self.filepath

    class Meta:
        app_label = 'pylucid'
        ordering = ("filepath",)





########NEW FILE########
__FILENAME__ = ip_ban_list
# coding: utf-8

"""
    PyLucid IP ban model
    ~~~~~~~~~~~~~~~~~~~~
    
    A simple model witch contains IP addresses with a timestamp.
    
    TODO: Move IP-Ban + Log stuff into a separate app
        
    e.g. usage in plugins:
    --------------------------------------------------------------------------
    from pylucid_project.apps.pylucid.models import LogEntry, BanEntry
    
    LogEntry.objects.log_action(app_label="plugin_name", action="ban ip", message="Add to ban because...")
    BanEntry.objects.add(request) # raised Http404!
    --------------------------------------------------------------------------

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import datetime

from django.http import Http404
from django.db import models
from django.utils.translation import ugettext_lazy as _
from django.utils.timesince import timesince

from log import LogEntry
from django.db.utils import IntegrityError


class BanEntryManager(models.Manager):
    def cleanup(self, request, timedelta):
        """
        Clean all old BanEntry.
        Creates a log message after delete a BanEntry.
        This method called from pylucid_project.middlewares.ip_ban.IPBanMiddleware
        """
        now = datetime.datetime.now()
        point_in_time = now - timedelta
        queryset = self.all().filter(createtime__lte=point_in_time)
        for entry in queryset:
            if entry.createtime is None:
                # Work-a-round if createtime is None
                entry.createtime = now
                entry.save()
                LogEntry.objects.log_action(
                    app_label="pylucid", action="ip ban error.",
                    request=request,
                    message="Create time is None: %s" % entry,
                )
                return

            try:
                how_old_txt = timesince(entry.createtime, now=datetime.datetime.now())
            except Exception, err:
                # FIXME: e.g.:
                # TypeError: can't subtract offset-naive and offset-aware datetimes
                LogEntry.objects.log_action(
                    app_label="pylucid", action="release ip ban",
                    request=request, message="FIXME: %s" % err,
                )
            else:
                LogEntry.objects.log_action(
                    app_label="pylucid", action="release ip ban",
                    request=request,
                    message="Entry for %s was %s old" % (entry.ip_address, how_old_txt),
                    data={"ip_address": entry.ip_address, "createtime": entry.createtime},
                )
            entry.delete()

    def add(self, request):
        """
        Add current user ban list
        Note: raised 404 after adding the current client to the ban list!
        """
        remote_addr = request.META["REMOTE_ADDR"]
        try:
            self.model(ip_address=remote_addr).save()
        except IntegrityError, err:
            # If a client does many request shortly and get banned we get e.g.:
            # IntegrityError: (1062, "Duplicate entry '123.123.123.123' for key 'PRIMARY'")
            LogEntry.objects.log_action(
                app_label="pylucid", action="add ip ban",
                message="IntegrityError on add %s to ban list: %s" % (remote_addr, err)
            )
        else:
            LogEntry.objects.log_action(
                app_label="pylucid", action="add ip ban",
                message="Add %s to ban list." % remote_addr
            )
            
        raise Http404("You are now banned.")


class BanEntry(models.Model):
    """
    IP Address in this model would be banned in:
        pylucid_project.middlewares.ip_ban.IPBanMiddleware
    The middleware also remove IP after some times with BanEntry.objects.cleanup()
    """
    objects = BanEntryManager()

    ip_address = models.IPAddressField(_('Remote IP Address'),
        primary_key=True, help_text="This IP address will be banned."
    )
    createtime = models.DateTimeField(help_text="Create time")

    def save(self, *args, **kwargs):
        if self.createtime is None:
            # New entry
            now = datetime.datetime.now()
            self.createtime = now
        return super(BanEntry, self).save(*args, **kwargs)

    def __unicode__(self):
        return u"BanEntry %s %s" % (self.ip_address, self.createtime)

    class Meta:
        app_label = 'pylucid'
        verbose_name = _('IP ban entry')
        verbose_name_plural = _('IP ban entries')
        ordering = ('-createtime',)



########NEW FILE########
__FILENAME__ = language
# coding: utf-8

"""
    PyLucid models
    ~~~~~~~~~~~~~~
    
    TODO: move this model to i18n app!

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.models import Group
from django.core.exceptions import ValidationError
from django.db import models
from django.utils.translation.trans_real import parse_accept_lang_header

# http://code.google.com/p/django-tools/
from django_tools.fields.language_code import LanguageCodeModelField
from django_tools.middlewares import ThreadLocal
from django_tools.models import UpdateInfoBaseModel
from django_tools.utils.messages import failsafe_message

from pylucid_project.base_models.many2many import AutoSiteM2M


supported_languages = dict(settings.LANGUAGES)

TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


ACCESSIBLE_LANG_CACHE = {}



class LanguageManager(models.Manager):

    def is_language_code(self, code):
        """ return True if given language code exist in settings.LANGUAGES """
        return code.lower() in supported_languages

    def filter_accessible(self, queryset, user):
        """ filter all languages with can't accessible for the given user """

        if user.is_anonymous():
            # Anonymous user are in no user group
            return queryset.filter(permitViewGroup__isnull=True)

        if user.is_superuser:
            # Superuser can see everything ;)
            return queryset

        # filter pages for not superuser and not anonymous
        user_groups = user.groups.values_list('pk', flat=True)

        if not user_groups:
            # User is in no group
            return queryset.filter(permitViewGroup__isnull=True)

        # Filter out all view group
        return queryset.filter(
            models.Q(permitViewGroup__isnull=True) | models.Q(permitViewGroup__in=user_groups)
        )

    def all_accessible(self, user):
        """ returns a QuerySet of all languages that the given user can access. """
        queryset = self.model.on_site.all()
        queryset = self.filter_accessible(queryset, user)
        return queryset

    def get_cached_languages(self, user):
        """
        returns a cached *list* of all languages that the given user can access
        on the current site.
        """
        cache_key = (user, settings.SITE_ID)
        if cache_key not in ACCESSIBLE_LANG_CACHE:
            languages = self.all_accessible(user)
#            if settings.PYLUCID.I18N_DEBUG:
#                failsafe_message("all accessible languages from db: %r" % languages)
            ACCESSIBLE_LANG_CACHE[cache_key] = list(languages)
#        elif settings.PYLUCID.I18N_DEBUG:
#                failsafe_message("all accessible languages from cache: %r" % ACCESSIBLE_LANG_CACHE[cache_key])

        return ACCESSIBLE_LANG_CACHE[cache_key][:]

    def get_choices(self):
        """ return a tuple list for e.g. forms.ChoiceField """
        return self.values_list('code', 'description')

    default_lang_entry = None
    def get_or_create_default(self, request):
        """
        return Language instance with code from settings.LANGUAGE_CODE
        Create if not exist.
        """
        if self.default_lang_entry is None:
            language_code = settings.LANGUAGE_CODE

            self.default_lang_entry = self.get_from_code(request, language_code)
            if self.default_lang_entry is None:
                failsafe_message("Default language entry not in language list?")
                self.default_lang_entry, created = self.get_or_create(
                    code=language_code, defaults={'description': language_code}
                )
                if created:
                    failsafe_message("Default language entry %r created." % self.default_lang_entry)
        return self.default_lang_entry

    def _get_default_language(self):
        """
        return Languange instance with code from settings.LANGUAGE_CODE
        Should normaly not used! Use request.PYLUCID.default_language !
        e.g. needed in unittest
        """
        if self.default_lang_entry is None:
            language_code = settings.LANGUAGE_CODE
            self.default_lang_entry = self.model.on_site.get(code=language_code)
        return self.default_lang_entry

    def _get_language_codes(self, request):
        """
        Create a language code list.
         - use all client accepted languages
         - add current used language and system default language        
        """
        current_lang_code = getattr(request, "LANGUAGE_CODE", None)
        default_lang_code = settings.LANGUAGE_CODE

        accept_lang_codes = []
        unsupported_lang_codes = []
        fallback_lang_codes = []

        accept = request.META.get('HTTP_ACCEPT_LANGUAGE', '')
#        if settings.PYLUCID.I18N_DEBUG:
#            messages.info(request, "HTTP_ACCEPT_LANGUAGE: %r" % accept)

        if not accept:
            if current_lang_code:
                accept_lang_codes = [current_lang_code, default_lang_code]
            else:
                accept_lang_codes = [default_lang_code]

            return accept_lang_codes, [], []

        accept_lang_headers = parse_accept_lang_header(accept)
#        print "accept_lang_headers:", accept_lang_headers
        for accept_lang, unused in accept_lang_headers:
            if "-" in accept_lang:
                # remember the first part for later adding as a fallback language
                fallback_lang = accept_lang.split("-", 1)[0]
                if fallback_lang in supported_languages and fallback_lang not in fallback_lang_codes:
                    fallback_lang_codes.append(fallback_lang)

            if accept_lang not in supported_languages:
                unsupported_lang_codes.append(accept_lang)
                continue

            if accept_lang not in accept_lang_codes:
                accept_lang_codes.append(accept_lang)

        if current_lang_code:
            # insert/move current language at the beginning
            if not accept_lang_codes:
                accept_lang_codes = [current_lang_code]
            elif accept_lang_codes[0] != current_lang_code:
                if current_lang_code in accept_lang_codes:
                    pos = accept_lang_codes.index(current_lang_code)
                    del(accept_lang_codes[pos])

                accept_lang_codes.insert(0, current_lang_code)

        # append fallback languages
        for fallback_lang in fallback_lang_codes:
            if fallback_lang not in accept_lang_codes:
                accept_lang_codes.append(fallback_lang)

        # append default language at the end
        if default_lang_code not in accept_lang_codes:
            accept_lang_codes.append(default_lang_code)

        return accept_lang_codes, unsupported_lang_codes, fallback_lang_codes

    def get_languages(self, request):
        """
        Create a list of all languages sorted by client accept language priority.
        
        added to request.PYLUCID.languages
        
        Cache key: The language entry can have a permitViewGroup,
            so we must use different caches for different user groups.
        """
        if hasattr(request, "PYLUCID") and hasattr(request.PYLUCID, "languages"):
            if settings.PYLUCID.I18N_DEBUG:
                messages.debug(request,
                    "return request.PYLUCID.languages: %r" % request.PYLUCID.languages
                )
            return request.PYLUCID.languages

        user = request.user
        languages = self.get_cached_languages(user)

        if settings.PYLUCID.I18N_DEBUG:
            failsafe_message("all accessible languages: %r" % languages)

        accept_lang_codes, unsupported_lang_codes, fallback_lang_codes = self._get_language_codes(request)

        if settings.PYLUCID.I18N_DEBUG:
            messages.debug(request, "accept_lang_codes: %r" % accept_lang_codes)
            messages.debug(request, "unsupported_lang_codes: %r" % unsupported_lang_codes)
            messages.debug(request, "fallback_lang_codes: %r" % fallback_lang_codes)

        # XXX: Test QuerySet order
#            language_codes.sort()
#            language_codes.sort(reverse=True)

        # sort the language in the same order than language_codes list was.
        # XXX: It there a better way to do this?
        language_list = []
        for language_code in accept_lang_codes:
            for index, language in enumerate(languages):
                if language.code.lower() == language_code.lower():
                    if language not in language_list:
                        language_list.append(language)
                    del(languages[index])
                    break

        if languages:
            # The Client has not all existing languages in his HTTP_ACCEPT_LANGUAGE
            # Append the rest
            if settings.PYLUCID.I18N_DEBUG:
                messages.info(request,
                    "client not accepted languages to append: %s" % ", ".join([l.code for l in languages])
                )
            language_list += languages

        if settings.PYLUCID.I18N_DEBUG:
            messages.info(request, "language_list: %s" % ", ".join([l.code for l in language_list]))

        return language_list

    def get_from_code(self, request, language_code):
        language_list = self.get_languages(request)
        for language in language_list:
            if language.code.lower() == language_code.lower():
                return language

    def get_current(self, request=None):
        """ return client Language instance, if not available, use get_default_lang_entry() """
        if request == None:
            request = ThreadLocal.get_current_request()

        if request == None:
            # no request available, e.g. loading fixtures
            return self._get_default_language()

        language_list = self.get_languages(request)
        return language_list[0]

#        if request:
#            if hasattr(request, "PYLUCID"):
#                return request.PYLUCID.current_language
#
#            if hasattr(request, "LANGUAGE_CODE"):
#                lang_code = request.LANGUAGE_CODE
#                if "-" in lang_code:
#                    lang_code = lang_code.split("-", 1)[0]
#                try:
#                    return self.get(code=lang_code)
#                except Language.DoesNotExist:
#                    if settings.PYLUCID.I18N_DEBUG:
#                        msg = (
#                            'Favored language "%s" does not exist -> use default lang from system preferences'
#                        ) % request.LANGUAGE_CODE
#                        failsafe_message(msg)
#
#        return self.get_or_create_default(request)




class Language(AutoSiteM2M, UpdateInfoBaseModel):
    """
    inherited attributes from AutoSiteM2M:
        sites   -> ManyToManyField to Site
        on_site -> sites.managers.CurrentSiteManager instance
        
    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = LanguageManager()

    code = LanguageCodeModelField(unique=True, max_length=10)
    description = models.CharField(max_length=150, blank=True,
        help_text="Description of the Language (filled automaticly)"
    )

    permitViewGroup = models.ForeignKey(Group, related_name="%(class)s_permitViewGroup",
        help_text="Limit viewable to a group for a complete language section?",
        null=True, blank=True,
    )

    def clean_fields(self, exclude):
        message_dict = {}

        if "code" not in exclude and self.code not in supported_languages:
            message_dict["code"] = (
                "Language is not in settings.LANGUAGES!",
                "Supported languages are: %s" % ",".join(sorted(supported_languages.keys()))
            )

        if message_dict:
            raise ValidationError(message_dict)

    def save(self, *args, **kwargs):
        global ACCESSIBLE_LANG_CACHE
        ACCESSIBLE_LANG_CACHE = {}

        if not self.description:
            self.description = supported_languages[self.code]

        super(Language, self).save(*args, **kwargs)

    def __unicode__(self):
        return u"Language %s - %s" % (self.code, self.description)

    class Meta:
        app_label = 'pylucid'
        ordering = ("code",)

########NEW FILE########
__FILENAME__ = log
# coding: utf-8

"""
    Log model
    ~~~~~~~~~
    
    TODO:
    * Move IP-Ban + Log stuff into a separate app
    * handel proxy's 'HTTP_X_FORWARDED_FOR' values.
        See notes here:
        http://docs.djangoproject.com/en/1.0/ref/middleware/#reverse-proxy-middleware
    
    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import datetime

from django.conf import settings
from django.contrib import messages
from django.contrib.admin.util import quote
from django.contrib.auth.models import User
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.managers import CurrentSiteManager
from django.contrib.sites.models import Site
from django.db import models
from django.utils.encoding import smart_unicode
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools.middlewares import ThreadLocal
from django_tools.models import UpdateInfoBaseModel

# http://code.google.com/p/django-dbpreferences/
from dbpreferences.fields import DictField


META_KEYS = (
    "REMOTE_ADDR", "REMOTE_USER", "REQUEST_METHOD", "QUERY_STRING",
    "HTTP_REFERER", "HTTP_USER_AGENT", "HTTP_ACCEPT_ENCODING", "HTTP_ACCEPT_LANGUAGE"
)


class LogEntryManager(models.Manager):
    def get_same_remote_addr(self, request):
        """
        return a QuerySet with all entries from the current remote Address.
        """
        current_remote_addr = request.META["REMOTE_ADDR"]
        queryset = self.model.on_site.all()
        queryset = queryset.filter(remote_addr=current_remote_addr)
        return queryset

    def last_remote_addr_actions(self, request, seconds):
        """
        creates a queryset with all items from the same REMOTE_ADDR in the last seconds.
        """
        queryset = self.get_same_remote_addr(request)

        timedelta = datetime.timedelta(seconds=seconds)
        point_in_time = datetime.datetime.now() - timedelta
        queryset = queryset.filter(createtime__gte=point_in_time)

        return queryset

    def request_limit(self, request, min_pause, ban_limit, app_label, action="error", no_page_msg=False):
        """
        Monitor request min_pause and ban_limit.
        """
        # Count the last requests for this app_label
        queryset = self.last_remote_addr_actions(request, min_pause)
        queryset = queryset.filter(app_label=app_label)
        queryset = queryset.filter(action=action)
        last_actions = queryset.count()

        if last_actions >= ban_limit:
            msg = _(
                "Add ban entry, because %(last_actions)s request for %(app_label)s"
                " in the last %(min_pause)ssec."
            ) % {
                "last_actions": last_actions,
                "app_label": app_label,
                "min_pause": min_pause,
            }
            self.log_action(app_label=app_label, action="ban ip", message=msg)

            from pylucid_project.apps.pylucid.models import BanEntry
            BanEntry.objects.add(request) # raise 404 after adding the client IP!

        if last_actions > 0:
            msg = _("Request too fast!")
            debug_msg = " (%s in the last %ssec. IP is blocked by %s overruns.)" % (
                last_actions, min_pause, ban_limit
            )
            if settings.DEBUG:
                msg += debug_msg
            if no_page_msg == False:
                messages.error(request, msg)
            LogEntry.objects.log_action(
                app_label=app_label, action="request aborted", message=debug_msg,
            )
            raise self.model.RequestTooFast(msg)

    def log_action(self, app_label, action, request=None, message=None, long_message=None, data=None):
        if request is None:
            request = ThreadLocal.get_current_request()

        kwargs = {
            "uri": request.build_absolute_uri(),
            "app_label": app_label,
            "action": action,
            "message": message,
            "long_message": long_message,
            "data": data,
        }

        if hasattr(request, "PYLUCID"):
            kwargs["used_language"] = request.PYLUCID.current_language
            preferences = request.PYLUCID.preferences # Get SystemPreferences
        else:
            from pylucid_project.apps.pylucid.preference_forms import SystemPreferencesForm # import loops
            preferences_form = SystemPreferencesForm()
            preferences = preferences_form.get_preferences()

        for key in META_KEYS:
            value = request.META.get(key)
            if value and len(value) > 255:
                value = "%s..." % value[:252]
            kwargs[key.lower()] = value

        new_entry = self.model(**kwargs)
        new_entry.save()

        # Auto cleanup Log Table to protect against overloading.                 
        max_count = preferences.get("max_log_entries", 1000)
        queryset = LogEntry.objects.order_by('-createtime')
        ids = tuple(queryset[max_count:].values_list('id', flat=True))
        if ids:
            queryset.filter(id__in=ids).delete()

        return new_entry


class LogEntry(UpdateInfoBaseModel):
    """
    PyLucid action log entries.

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    class RequestTooFast(Exception):
        pass

    objects = LogEntryManager()

    site = models.ForeignKey(Site, default=Site.objects.get_current)
    on_site = CurrentSiteManager()

    # Log information:
    app_label = models.CharField(_('App Label'), max_length=255, db_index=True,
        help_text="The App name witch has created this log entry."
    )
    action = models.CharField(_('Action'), max_length=128, db_index=True,
        help_text="Short action key. (e.g.: 'do search', 'login')"
    )
    message = models.CharField(_('Message'), max_length=255, blank=True, null=True,
        help_text="Short/one line log message. (e.g.: 'user FooBar login')"
    )
    long_message = models.TextField(_('long Message'), blank=True, null=True,
        help_text="Complete log message."
    )
    # From django-dbpreferences
    data = DictField(blank=True, null=True, help_text="serialized dictionary data")

    # Own meta data:
    uri = models.CharField(_('URL'), max_length=255,
        help_text="absolute URI form request.build_absolute_uri()"
    )
    used_language = models.ForeignKey("pylucid.Language", blank=True, null=True)

    # Data from request.META
    remote_addr = models.IPAddressField(_('Remote IP Address'), blank=True, null=True, db_index=True,
        help_text="The IP address of the client. From request.META['REMOTE_ADDR']"
    )
    remote_user = models.CharField(_('Remote User'), max_length=255, blank=True, null=True,
        help_text="The user authenticated by the web server, if any. From request.META['REMOTE_USER']"
    )
    request_method = models.CharField(_('Request Method'), max_length=8, blank=True, null=True,
        help_text="Request method, e.g.: 'GET', 'POST'. From request.META['REQUEST_METHOD']"
    )
    query_string = models.CharField(_('Query String'), max_length=255, blank=True, null=True,
        help_text="The query string, as a single **unparsed** string. From request.META['QUERY_STRING']"
    )
    http_referer = models.CharField(_('Referer'), max_length=255, blank=True, null=True,
        help_text="The referring page, if any. From request.META['HTTP_REFERER']"
    )
    http_user_agent = models.CharField(_('User Agent'), max_length=255, blank=True, null=True,
        help_text="The client's user-agent string. From request.META['HTTP_USER_AGENT']"
    )
    http_accept_encoding = models.CharField(_('Accept Encoding'), max_length=255, blank=True, null=True,
        help_text="from request.META['HTTP_ACCEPT_ENCODING']"
    )
    http_accept_language = models.CharField(_('Accept Language'), max_length=255, blank=True, null=True,
        help_text="from request.META['HTTP_ACCEPT_LANGUAGE']"
    )

    def get_absolute_url(self):
        return self.uri

    def pformat(self):
        """ Usefull for debugging """
        output = ""
        for field in self._meta.fields:
            value = repr(getattr(self, field.name))
            if isinstance(value, basestring):
                value = value.replace("\\n", "\\n\n")
                value = "\n ... ".join([line for line in value.split("\n")])
            output += "%-21s: %s\n" % (field.name, value)
        return output

    def __unicode__(self):
        return u"LogEntry %s %s %s" % (self.createby, self.createtime, self.action)

    class Meta:
        app_label = 'pylucid'
        verbose_name = _('log entry')
        verbose_name_plural = _('log entries')
        ordering = ('-createtime',)



########NEW FILE########
__FILENAME__ = pagecontent
# coding: utf-8

"""
    PyLucid models
    ~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.db import models
from django.core.cache import cache
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools import model_utils
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.base_models.base_markup_model import MarkupBaseModel
from pylucid_project.base_models.base_models import BaseModelManager, BaseModel


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


class PageContentManager(BaseModelManager):
    """
    Manager class for PageContent model

    inherited from models.Manager:
        get_or_create() method, witch expected a request object as the first argument.
    """
    pass


class PageContent(BaseModel, MarkupBaseModel, UpdateInfoBaseModel):
    """
    A normal CMS Page with text content.

    signals connection is in pylucid_project.apps.pylucid.models.__init__

    inherited attributes from MarkupBaseModel:
        content field
        markup field
        get_html() method

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = PageContentManager()

    pagemeta = models.OneToOneField("pylucid.PageMeta")

    def get_absolute_url(self):
        """ absolute url *with* language code (without domain/host part) """
        lang_code = self.pagemeta.language.code
        page_url = self.pagemeta.pagetree.get_absolute_url()
        return "/" + lang_code + page_url

    def get_site(self):
        return self.pagemeta.pagetree.site

    def get_update_info(self):
        """ update info for update_journal.models.UpdateJournal used by update_journal.save_receiver """
        if self.pagemeta.permitViewGroup != None or self.pagemeta.pagetree.permitViewGroup != None:
            # This entry should not be inserted in the update journal
            return None

        data = {
            "lastupdatetime": self.lastupdatetime,
            "user_name": self.lastupdateby,
            "language": self.pagemeta.language,
            "object_url": self.get_absolute_url(),
            "title": self.get_title()
        }
        return data

    def get_name(self):
        """ Page name is optional, return PageTree slug if page name not exist """
        return self.pagemeta.name or self.pagemeta.pagetree.slug

    def get_title(self):
        """ The page title is optional, if not exist, used the slug from the page tree """
        return self.pagemeta.title or self.pagemeta.pagetree.slug

    def save(self, *args, **kwargs):
        if self.pagemeta.pagetree.page_type != self.pagemeta.pagetree.PAGE_TYPE:
            # TODO: move to django model validation
            raise AssertionError("PageContent can only exist on a page type tree entry!")

        try:
            cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
        except AttributeError:
            # No SmoothCacheBackend used -> clean the complete cache
            cache.clear()

        return super(PageContent, self).save(*args, **kwargs)

    def __unicode__(self):
        return u"PageContent %r (lang: %s, site: %s)" % (
            self.pagemeta.pagetree.slug, self.pagemeta.language.code, self.get_site().domain
        )

    class Meta:
        app_label = 'pylucid'
        verbose_name_plural = verbose_name = "PageContent"
        ordering = ("-lastupdatetime",)
#        ordering = ("pagetree", "language")


# Check Meta.unique_together manually
model_utils.auto_add_check_unique_together(PageContent)

########NEW FILE########
__FILENAME__ = pagemeta
# coding: utf-8

"""
    PyLucid models
    ~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.models import Group
from django.core.cache import cache
from django.core.exceptions import ValidationError, ObjectDoesNotExist
from django.core.urlresolvers import reverse
from django.db import models
from django.template.defaultfilters import slugify
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools import model_utils
from django_tools.local_sync_cache.local_sync_cache import LocalSyncCache
from django_tools.middlewares import ThreadLocal
from django_tools.tagging_addon.fields import jQueryTagModelField
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.base_models.base_models import BaseModelManager, BaseModel
from pylucid_project.base_models.permissions import PermissionsBase


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"



class CurrentSiteManager(models.Manager):
    """
    Use this to limit objects to those associated with the current site.
    Based on django.contrib.sites.managers.CurrentSiteManager()
    """
    def get_query_set(self):
        queryset = super(CurrentSiteManager, self).get_query_set()
        return queryset.filter(pagetree__site__id__exact=settings.SITE_ID)


class PageMetaManager(BaseModelManager):
    """
    inherited from BaseModelManager:
        easy_create()
    """
    def verbose_get_or_create(self, request, pagetree, lang_entry, show_lang_errors=True):
        """
        returns PageMeta, create it if not exist.
        
        If show_lang_errors==True:
            create a page_msg if PageMeta doesn't exist in client favored language.
        """
        if settings.DEBUG:
            assert pagetree.page_type == pagetree.PLUGIN_TYPE, "should only used for PluginPages!"

        pagemeta, created = self.model.on_site.get_or_create(pagetree=pagetree, language=lang_entry)
        if created:
            msg = "auto create %s" % pagemeta

            from pylucid_project.apps.pylucid.models import LogEntry # against import loops.
            LogEntry.objects.log_action(
                app_label="pylucid", action="auto create PageMeta", request=request, message=msg
            )
            if show_lang_errors or settings.DEBUG or request.user.is_superuser:
                messages.info(request, msg)

        return pagemeta


class PageMeta(BaseModel, UpdateInfoBaseModel, PermissionsBase):
    """
    Meta data for PageContent or PluginPage

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who created this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
        
    inherited from PermissionsBase:
        validate_permit_group()
        check_sub_page_permissions()
    """
    objects = PageMetaManager()
    on_site = CurrentSiteManager()

    pagetree = models.ForeignKey("pylucid.PageTree") # Should we add null=True, blank=True here? see clean_fields() below
    language = models.ForeignKey("pylucid.Language")

    name = models.CharField(blank=True, max_length=150,
        help_text="Sort page name (for link text in e.g. menu)"
    )
    title = models.CharField(blank=True, max_length=256,
        help_text="A long page title (for e.g. page title or link title text)"
    )

    tags = jQueryTagModelField() # a django-tagging model field modified by django-tools

    keywords = models.CharField(blank=True, max_length=255,
        help_text="Keywords for the html header. (separated by commas)"
    )
    description = models.CharField(blank=True, max_length=255, help_text="For html header")

    robots = models.CharField(blank=True, max_length=255, default="index,follow",
        help_text="for html 'robots' meta content."
    )

    permitViewGroup = models.ForeignKey(Group, related_name="%(class)s_permitViewGroup",
        help_text="Limit viewable this page in this language to a user group?",
        null=True, blank=True,
    )
    # FIXME: Add permitEditGroup, too.
    # e.g.: allow only usergroup X to edit this page in language Y
    # https://github.com/jedie/PyLucid/issues/57

    def clean_fields(self, exclude):
        super(PageMeta, self).clean_fields(exclude)

        message_dict = {}

        try:
            # We can only check the sub pages, if exists ;)
            pagetree = self.pagetree
        except ObjectDoesNotExist:
            # FIXME: Should self.pagetree() field has null=True, blank=True ?
            return

        # Prevents that a unprotected page created below a protected page.
        # TODO: Check this in unittests
        # validate_permit_group() method inherited from PermissionsBase
        self.validate_permit_group("permitViewGroup", exclude, message_dict)

        # Warn user if PageMeta permissions mismatch with sub pages
        # TODO: Check this in unittests
        queryset = PageMeta.objects.filter(pagetree__parent=self.pagetree)
        self.check_sub_page_permissions(# method inherited from PermissionsBase
            ("permitViewGroup",), # TODO: permitEditGroup, read above
            exclude, message_dict, queryset
        )

        if message_dict:
            raise ValidationError(message_dict)

    def recusive_attribute(self, attribute):
        """
        Goes the pagetree back to root and return the first match of attribute if not None.
        
        used e.g.
            with permitViewGroup and permitEditGroup
            from self.validate_permit_group() and self.check_sub_page_permissions()
        """
        parent_pagetree = self.pagetree.parent
        if parent_pagetree is None: # parent is the tree root
            return None

        request = ThreadLocal.get_current_request()
        if request is None:
            # Check only if we are in a request
            return

        queryset = PageMeta.objects.filter(pagetree=parent_pagetree)
        parent_pagemeta = None
        languages = request.PYLUCID.languages # languages are in client prefered order
        for language in languages:
            try:
                parent_pagemeta = queryset.get(language=language)
            except PageMeta.DoesNotExist:
                continue
            else:
                break

        if parent_pagemeta is None:
            return

        if getattr(parent_pagemeta, attribute) is not None:
            # the attribute was set by parent page
            return parent_pagemeta
        else:
            # go down to root
            return parent_pagemeta.recusive_attribute(attribute)

    _url_cache = LocalSyncCache(id="PageMeta_absolute_url")
    def get_absolute_url(self):
        """ absolute url *with* language code (without domain/host part) """
        if self.pk in self._url_cache:
            #print "PageMeta url cache len: %s, pk: %s" % (len(self._url_cache), self.pk)
            return self._url_cache[self.pk]

        lang_code = self.language.code
        page_url = self.pagetree.get_absolute_url()
        url = "/" + lang_code + page_url

        self._url_cache[self.pk] = url
        return url

    _permalink_cache = LocalSyncCache(id="PageMeta_permalink")
    def get_permalink(self):
        """
        return a permalink. Use page slug/name/title or nothing as additional text.
        """
        if self.pk in self._permalink_cache:
            #print "PageMeta permalink_cache len: %s, pk: %s" % (len(self._permalink_cache), self.pk)
            return self._permalink_cache[self.pk]

        # Get the system preferences
        request = ThreadLocal.get_current_request()
        sys_pref = request.PYLUCID.preferences
        sys_pref_form = request.PYLUCID.preferences_form

        use_additions = sys_pref.get("permalink_additions", sys_pref_form.PERMALINK_USE_TITLE)

        do_slugify = False
        if use_additions == sys_pref_form.PERMALINK_USE_TITLE:
            # Append the PageMeta title (language dependent)
            addition_txt = self.get_title()
            do_slugify = True
        elif use_additions == sys_pref_form.PERMALINK_USE_NAME:
            addition_txt = self.get_name()
            do_slugify = True
        elif use_additions == sys_pref_form.PERMALINK_USE_SLUG:
            addition_txt = self.pagetree.slug
        else:
            addition_txt = ""

        if do_slugify:
            addition_txt = slugify(addition_txt)

        url = reverse('PyLucid-permalink', kwargs={'page_id': self.pagetree.id, 'url_rest': addition_txt})
        self._permalink_cache[self.pk] = url
        return url

    def save(self, *args, **kwargs):
        """ reset PageMeta and PageTree url cache """
        # Clean the local url cache dict
        self._url_cache.clear()
        self._permalink_cache.clear()
        self.pagetree._url_cache.clear()

        # FIXME: We must only update the cache for the current SITE not for all sites.
        try:
            cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
        except AttributeError:
            # No SmoothCacheBackend used -> clean the complete cache
            cache.clear()

        return super(PageMeta, self).save(*args, **kwargs)

    def get_site(self):
        """ used e.g. for self.get_absolute_uri() and the admin page """
        return self.pagetree.site
    get_site.short_description = _('on site')
    get_site.allow_tags = False

    def get_other_languages(self):
        return PageMeta.objects.all().filter(pagetree=self.pagetree).exclude(language=self.language)

    def get_title(self):
        """ The page title is optional, if not exist, used the slug from the page tree """
        return self.title or self.get_name()

    def get_name(self):
        return self.name or self.pagetree.slug

    def __unicode__(self):
        return u"PageMeta for page: %r (lang: %s, site: %s)" % (
            self.pagetree.slug, self.language.code, self.get_site().domain
        )

    class Meta:
        app_label = 'pylucid'
        verbose_name_plural = verbose_name = "PageMeta"
        unique_together = (("pagetree", "language"),)
        ordering = ("-lastupdatetime",)
#        ordering = ("pagetree", "language")

# Check Meta.unique_together manually
model_utils.auto_add_check_unique_together(PageMeta)

########NEW FILE########
__FILENAME__ = pagetree
# coding: utf-8

"""
    PyLucid models
    ~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import sys
from xml.sax.saxutils import escape

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.models import Group
from django.contrib.sites.managers import CurrentSiteManager
from django.contrib.sites.models import Site
from django.core.cache import cache
from django.core.exceptions import PermissionDenied, ValidationError
from django.db import models
from django.http import Http404
from django.template.defaultfilters import slugify
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools import model_utils
from django_tools.local_sync_cache.local_sync_cache import LocalSyncCache
from django_tools.middlewares import ThreadLocal
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.apps.pylucid.tree_model import BaseTreeModel, TreeGenerator
from pylucid_project.base_models.base_models import BaseModelManager, BaseModel
from pylucid_project.base_models.permissions import PermissionsBase


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


class PageTreeManager(BaseModelManager):
    """
    Manager class for PageTree model

    inherited from models.Manager:
        get_or_create() method, witch expected a request object as the first argument.
    """
    def filter_accessible(self, queryset, user):
        """
        exclude form pagetree queryset all pages which the given user can't see
        by checking PageTree.permitViewGroup
        TODO: Check in unittests
        """
        if user.is_anonymous():
            # Anonymous user are in no user group
            return queryset.filter(permitViewGroup__isnull=True)

        if user.is_superuser:
            # Superuser can see everything ;)
            return queryset

        # filter pages for authenticated,normal users

        user_groups = user.groups.values_list('pk', flat=True)

        if not user_groups:
            # User is in no group
            return queryset.filter(permitViewGroup__isnull=True)

        # Filter out all view group
        return queryset.filter(
            models.Q(permitViewGroup__isnull=True) | models.Q(permitViewGroup__in=user_groups)
        )

    def all_accessible(self, user=None, filter_showlinks=False):
        """ returns a PageTree queryset with all items that the given user can access. """
        if user == None:
            user = ThreadLocal.get_current_user()

        queryset = self.model.on_site.order_by("position")
        queryset = self.filter_accessible(queryset, user)

        if filter_showlinks:
            # Filter PageTree.showlinks
            queryset = queryset.filter(showlinks=True)

        return queryset

    def get_tree(self, user=None, filter_showlinks=False, exclude_plugin_pages=False, exclude_extras=None):
        """ return a TreeGenerator instance with all accessable page tree instance """
        queryset = self.all_accessible(user, filter_showlinks)

        if exclude_plugin_pages:
            queryset = queryset.exclude(page_type=PageTree.PLUGIN_TYPE)
        if exclude_extras:
            queryset = queryset.exclude(**exclude_extras)

        items = queryset.values("id", "parent", "slug")
        tree = TreeGenerator(items, skip_no_parent=True)
        return tree

    def get_choices(self, user=None, exclude_extras=None):
        """ returns a choices list for e.g. a forms select widget. """
        tree = PageTree.objects.get_tree(user, exclude_plugin_pages=True, exclude_extras=exclude_extras)
        choices = [("", "---------")] + [
            (node.id, node.get_absolute_url()) for node in tree.iter_flat_list()
        ]
        return choices

    def get_root_page(self, user, filter_parent=True):
        """ returns the 'first' root page tree entry witch the user can access """
        queryset = self.all_accessible(user)

        if filter_parent:
            # All "root" pages
            queryset = queryset.filter(parent=None)
        else:
            # fallback if no "root" page is accessable
            queryset = queryset.order_by("parent", "position")

        try:
            return queryset[0]
        except IndexError, err:
            if self.model.on_site.count() == 0:
                raise PageTree.DoesNotExist("There exist no PageTree items!")
            elif filter_parent == True:
                # If all root pages not accessible for the current user
                # -> try to get the first accessable page
                return self.get_root_page(user, filter_parent=False)
            else:
                raise

    def get_pagemeta(self, request, pagetree, show_lang_errors=True):
        """
        return PageMeta instance witch associated to the given >pagetree< instance.
        
        raise PermissionDenied if current user hasn't the pagemeta.permitViewGroup permissions. 
        
        dissolving language in client favored languages
        if not exist:
            return system default language
            
        If show_lang_errors==True:
            create a page_msg if PageMeta doesn't exist in client favored language.
        """
        from pylucid_project.apps.pylucid.models import PageMeta  # against import loops.      

        # client favored Language instance:
        lang_entry = request.PYLUCID.current_language

        if pagetree.page_type == pagetree.PLUGIN_TYPE:
            # Automatic create a not existing PageMeta on PluginPages
            pagemeta = PageMeta.objects.verbose_get_or_create(
                request, pagetree, lang_entry, show_lang_errors=show_lang_errors
            )
            return pagemeta

        queryset = PageMeta.objects.filter(pagetree=pagetree)
        pagemeta, tried_languages = self.get_by_prefered_language(request, queryset, show_lang_errors=show_lang_errors)

        if pagemeta is None:
            msg = ""
            if settings.DEBUG:
                msg += "This page %r doesn't exist in any languages???" % pagetree
            raise Http404(msg)

        if tried_languages and show_lang_errors and (settings.DEBUG or request.user.is_authenticated()):
            # We should not inform anonymous user, because the page
            # would not caches, if messages exist!
            messages.info(request,
                _(
                    "PageMeta %(slug)s doesn't exist in client"
                    " favored language %(tried_languages)s,"
                    " use %(used_code)s entry."
                ) % {
                    "slug": pagetree.slug,
                    "tried_languages": ", ".join([l.description for l in tried_languages]),
                    "used_code": pagemeta.language.description,
                }
            )

        # Check PageMeta.permitViewGroup permissions:
        # TODO: Check this in unittests!
        if pagemeta.permitViewGroup == None:
            # everyone can't see this page
            return pagemeta
        elif request.user.is_superuser: # Superuser can see everything ;)
            return pagemeta
        elif request.user.is_authenticated() and pagemeta.permitViewGroup in request.user.groups:
            return pagemeta

        # The user is anonymous or is authenticated but is not in the right user group
        raise PermissionDenied

    def get_page_from_url(self, request, url_path):
        """
        returns a tuple the page tree instance from the given url_path
        XXX: move it out from model?
        """
        if not request.user.is_superuser:
            user_groups = request.user.groups.all()

        path = url_path.strip("/").split("/")
        page = None
        for no, page_slug in enumerate(path):
            if slugify(page_slug) != page_slug.lower():
                raise PageTree.DoesNotExist("url part %r is not slugify" % page_slug)

            try:
                page = PageTree.on_site.get(parent=page, slug=page_slug)
            except PageTree.DoesNotExist:
                etype, evalue, etb = sys.exc_info()
                evalue = etype("Wrong url %r: %s" % (page_slug, evalue))
                raise etype, evalue, etb

            page_view_group = page.permitViewGroup

            # Check permissions only for PageTree
            # Note: PageMeta.permitViewGroup would be checked in self.get_pagemeta()
            # TODO: Check this in unittests!
            if request.user.is_anonymous():
                # Anonymous user are in no user group
                if page_view_group != None:
                    msg = "Permission deny"
                    if settings.DEBUG:
                        msg += " (url part: %s)" % escape(page_slug)
                    raise PermissionDenied(msg)
            elif not request.user.is_superuser: # Superuser can see everything ;)
                if (page_view_group != None) and (page_view_group not in user_groups):
                    msg = "Permission deny"
                    if settings.DEBUG:
                        msg += " (not in view group %r, url part: %r)" % (page_view_group, escape(page_slug))
                    raise PermissionDenied(msg)

            if page.page_type == PageTree.PLUGIN_TYPE:
                # It's a plugin
                prefix_url = "/".join(path[:no + 1])
                rest_url = "/".join(path[no + 1:])
#                if not rest_url.endswith("/"):
#                    rest_url += "/"
                return (page, prefix_url, rest_url)

        return (page, None, None)

    def get_backlist(self, request, pagetree=None):
        """
        Generate a list of backlinks, usefull for generating a "You are here" breadcrumb navigation.
        TODO: filter showlinks and permit settings
        TODO: filter current site
        FIXME: Think this created many database requests
        """
        if pagetree == None:
            pagetree = request.PYLUCID.pagetree

        pagemeta = self.get_pagemeta(request, pagetree, show_lang_errors=False)
        url = pagemeta.get_absolute_url()
        page_name = pagemeta.get_name()
        page_title = pagemeta.get_title()

        backlist = [{"url": url, "name": page_name, "title": page_title}]

        parent = pagetree.parent
        if parent:
            # insert parent links
            backlist = self.get_backlist(request, parent) + backlist

        return backlist


class PageTree(BaseModel, BaseTreeModel, UpdateInfoBaseModel, PermissionsBase):
    """
    The CMS page tree

    inherited attributes from TreeBaseModel:
        parent
        position

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
        
    inherited from PermissionsBase:
        validate_permit_group()
        check_sub_page_permissions()
    """
    PAGE_TYPE = 'C'
    PLUGIN_TYPE = 'P'

    TYPE_CHOICES = (
        (PAGE_TYPE, 'CMS-Page'),
        (PLUGIN_TYPE , 'PluginPage'),
    )
    TYPE_DICT = dict(TYPE_CHOICES)

    objects = PageTreeManager()

    slug = models.SlugField(unique=False, help_text="(for building URLs)")

    site = models.ForeignKey(Site, default=Site.objects.get_current)
    on_site = CurrentSiteManager()

    page_type = models.CharField(max_length=1, choices=TYPE_CHOICES)

    design = models.ForeignKey("pylucid.Design", help_text="Page Template, CSS/JS files")

    showlinks = models.BooleanField(default=True,
        help_text="Accessable for all users, but don't put a Link to this page into menu/sitemap etc."
    )
    permitViewGroup = models.ForeignKey(Group, related_name="%(class)s_permitViewGroup",
        help_text="Limit viewable to a group?",
        null=True, blank=True,
    )
    permitEditGroup = models.ForeignKey(Group, related_name="%(class)s_permitEditGroup",
        help_text="Usergroup how can edit this page.",
        null=True, blank=True,
    )

    def clean_fields(self, exclude):
        """
        We must call clean_slug() here, because it needs a queryset. 
        """
        # check if parent is the same entry: child <-> parent loop:
        super(PageTree, self).clean_fields(exclude)

        message_dict = {}

        # Check if slug exist in the same sub tree:
        if "slug" not in exclude:
            if self.parent == None: # parent is the tree root
                if self.slug in settings.SLUG_BLACKLIST:
                    # e.g. /media/ or /pylucid_admin/
                    msg = (
                        "Sorry, page slug '/<strong>%s</strong>/' is not usable!"
                        " (Not usable slugs are: %s)"
                    ) % (self.slug, ", ".join(settings.SLUG_BLACKLIST))
                    message_dict["slug"] = (mark_safe(msg),)

            queryset = PageTree.on_site.filter(slug=self.slug, parent=self.parent)

            # Exclude the current object from the query if we are editing an
            # instance (as opposed to creating a new one)
            if self.pk is not None:
                queryset = queryset.exclude(pk=self.pk)

            exists = queryset.count()
            if exists:
                if self.parent == None: # parent is the tree root
                    parent_url = "/"
                else:
                    parent_url = self.parent.get_absolute_url()

                msg = "Page '%s<strong>%s</strong>/' exists already." % (parent_url, self.slug)
                message_dict["slug"] = (mark_safe(msg),)

        # Check if parent page is a ContentPage, a plugin page can't have any sub pages!
        if "parent" not in exclude and self.parent is not None and self.parent.page_type != self.PAGE_TYPE:
            parent_url = self.parent.get_absolute_url()
            msg = _(
                "Can't use the <strong>plugin</strong> page '%s' as parent page!"
                " Please choose a <strong>content</strong> page."
            ) % parent_url
            message_dict["parent"] = (mark_safe(msg),)

        # Prevents that a unprotected page created below a protected page.
        # TODO: Check this in unittests
        # validate_permit_group() method inherited from PermissionsBase
        self.validate_permit_group("permitViewGroup", exclude, message_dict)
        self.validate_permit_group("permitEditGroup", exclude, message_dict)

        # Warn user if PageTree permissions mismatch with sub pages
        # TODO: Check this in unittests
        queryset = PageTree.objects.filter(parent=self)
        self.check_sub_page_permissions(# method inherited from PermissionsBase
            ("permitViewGroup", "permitEditGroup"),
            exclude, message_dict, queryset
        )

        if message_dict:
            raise ValidationError(message_dict)

    def recusive_attribute(self, attribute):
        """
        Goes the pagetree back to root and return the first match of attribute if not None.
        
        used e.g.
            with permitViewGroup and permitEditGroup
            from self.validate_permit_group() and self.check_sub_page_permissions()
        """
        parent = self.parent
        if parent is None: # parent is the tree root
            return None

        if getattr(parent, attribute) is not None:
            # the attribute was set by parent page
            return parent
        else:
            # go down to root
            return parent.recusive_attribute(attribute)

    _url_cache = LocalSyncCache(id="PageTree_absolute_url")
    def get_absolute_url(self):
        """ absolute url *without* language code (without domain/host part) """
        try:
            url = self._url_cache[self.pk]
            #print "PageTree url cache len: %s, pk: %s" % (len(self._url_cache), self.pk)
        except KeyError:
            if self.parent:
                parent_shortcut = self.parent.get_absolute_url()
                url = parent_shortcut + self.slug + "/"
            else:
                url = "/" + self.slug + "/"

            self._url_cache[self.pk] = url
        return url

    def get_absolute_uri(self):
        """ absolute url with domain/host part (but without language code) """
        absolute_url = self.get_absolute_url()
        domain = self.site.domain
        return "http://" + domain + absolute_url

    def save(self, *args, **kwargs):
        """ reset PageMeta and PageTree url cache """
        from pagemeta import PageMeta # against import loops.

        # Clean the local url cache dict
        self._url_cache.clear()
        PageMeta._url_cache.clear()

        # FIXME: We must only update the cache for the current SITE not for all sites.
        try:
            cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
        except AttributeError:
            # No SmoothCacheBackend used -> clean the complete cache
            cache.clear()

        return super(PageTree, self).save(*args, **kwargs)

    def get_site(self):
        """ used e.g. for self.get_absolute_uri() and the admin page """
        return self.site

    def __unicode__(self):
        return u"PageTree %r (id: %i, site: %s, type: %s)" % (
            self.slug, self.id, self.site.domain, self.TYPE_DICT.get(self.page_type)
        )

    class Meta:
        app_label = 'pylucid'
        verbose_name_plural = verbose_name = "PageTree"
        unique_together = (("site", "slug", "parent"),)

        # FIXME: It would be great if we can order by get_absolute_url()
#        ordering = ("site", "id", "position")
        ordering = ("-lastupdatetime",)


# Check Meta.unique_together manually
model_utils.auto_add_check_unique_together(PageTree)



########NEW FILE########
__FILENAME__ = pluginpage
# coding: utf-8

"""
    PyLucid models
    ~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib.sites.models import Site
from django.core import urlresolvers
from django.core.cache import cache
from django.db import models
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools import model_utils
from django_tools.models import UpdateInfoBaseModel
from django_tools.utils import installed_apps_utils
from django_tools.utils.messages import failsafe_message

from pylucid_project.apps.pylucid.fields import RootAppChoiceField
from pylucid_project.base_models.base_models import BaseModelManager, BaseModel
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS
from django_tools.local_sync_cache.local_sync_cache import LocalSyncCache


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


_URL_RESOLVER_CACHE = LocalSyncCache(id="PluginPage_url_resolver")


class PluginPageManager(BaseModelManager):
    """
    TODO: In next release witch has a update routine: we should switch:
        from plugin_instance.installed_apps_string to plugin_instance.pkg_string
    """
    _APP_CHOICES = None
    def get_app_choices(self):
        """
        Generate a choice list with all views witch can handle a empty root url.
        But PyLucid can only handle own plugins, see:
            http://trac.pylucid.net/ticket/333
        """
        if self._APP_CHOICES == None:
            debug = settings.DEBUG and settings.RUN_WITH_DEV_SERVER

            root_apps = installed_apps_utils.get_filtered_apps(
                resolve_url="/", no_args=False, debug=debug, skip_fail=True
            )

            self._APP_CHOICES = [("", "---------")]
            for app in root_apps:
                plugin_name = app.split(".")[-1]
                if not plugin_name in PYLUCID_PLUGINS:
                    continue
                plugin_instance = PYLUCID_PLUGINS[plugin_name]

                self._APP_CHOICES.append(
                    (plugin_instance.installed_apps_string, plugin_instance.pkg_string)
                )

#            apps = [app for app in root_apps if not "pylucid_project.apps" in app]
#            self._APP_CHOICES = [("", "---------")] + [(app, app) for app in sorted(apps)]
        return self._APP_CHOICES

    def queryset_by_app_label(self, app_label, site=None):
        """
        queryset to get PluginPages on current a site by app_label
        """
        if site is None:
            site = Site.objects.get_current()

        queryset = PluginPage.objects.all()
        queryset = queryset.filter(pagetree__site=site)
        queryset = queryset.filter(app_label=app_label)
        return queryset

    def queryset_by_plugin_name(self, plugin_name, site=None):
        """
        queryset to get PluginPages on current a site by app_label
        
        usage, e.g:
        queryset = PluginPage.objects.queryset_by_plugin_name("blog")
        """
        plugin_instance = PYLUCID_PLUGINS[plugin_name]
        app_label = plugin_instance.installed_apps_string
        queryset = self.queryset_by_app_label(app_label)
        return queryset

    def get_by_plugin_name(self, plugin_name):
        """
        return PluginPage instance by plugin_name
        """
        plugin_instance = PYLUCID_PLUGINS[plugin_name]
        app_label = plugin_instance.installed_apps_string

        queryset = self.queryset_by_app_label(app_label)
        try:
            # Get the first PluginPage entry for this plugin
            plugin_page = queryset[0]
        except (IndexError, KeyError):
            msg = "Can't get a PluginPage for plugin %r, please create one." % plugin_name
            if settings.DEBUG:
                msg += " (app_label: %r)" % app_label
                failsafe_message(msg)
            raise urlresolvers.NoReverseMatch(msg)
        return plugin_page

    def get_url_resolver(self, plugin_name):
        """
        return a url resolver for the given plugin
        """
        try:
            plugin_url_resolver = _URL_RESOLVER_CACHE[plugin_name]
        except KeyError:
            plugin_instance = PYLUCID_PLUGINS[plugin_name]
            plugin_page = self.get_by_plugin_name(plugin_name)

            url_prefix = plugin_page.get_absolute_url()
            plugin_url_resolver = plugin_instance.get_plugin_url_resolver(url_prefix, plugin_page.urls_filename)
            _URL_RESOLVER_CACHE[plugin_name] = plugin_url_resolver
        return plugin_url_resolver

    def reverse(self, plugin_name, viewname, args=(), kwargs={}):
        """
        reverse a plugin url.
        Please note: this will always use the first PluginPage entry as url prefix!
        """
        plugin_url_resolver = self.get_url_resolver(plugin_name)
        url = plugin_url_resolver.reverse(viewname, *args, **kwargs)
        return url


class PluginPage(BaseModel, UpdateInfoBaseModel):
    """
    A plugin page

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = PluginPageManager()

    pagetree = models.OneToOneField("pylucid.PageTree")

    app_label = RootAppChoiceField(max_length=256,
        help_text=(
            "The plugin app label witch is in settings.INSTALLED_APPS"
            " (Only apps witch can handle a root url.)"
        )
    )
    urls_filename = models.CharField(max_length=256, default="urls.py",
        help_text="Filename of the urls.py"
    )

    def get_site(self):
        return self.pagetree.site

    def get_absolute_url(self):
        """ absolute url *with* language code (without domain/host part) """
        from pylucid_project.apps.pylucid.models import Language # import here against import loops

        pagetree_url = self.pagetree.get_absolute_url()
        language_entry = Language.objects.get_current()
        url = "/" + language_entry.code + pagetree_url
        return url

    def get_title(self):
        """ The page title is optional, if not exist, used the slug from the page tree """
        pagemeta = self.get_pagemeta()
        return pagemeta.get_title()

    def get_plugin_name(self):
        return self.app_label.split(".")[-1]

    def get_plugin(self):
        """ returns pylucid_project.system.pylucid_plugins instance """
        plugin_name = self.get_plugin_name()
        plugin_instance = PYLUCID_PLUGINS[plugin_name]
        return plugin_instance

    def save(self, *args, **kwargs):
        if not self.pagetree.page_type == self.pagetree.PLUGIN_TYPE:
            # FIXME: Better error with django model validation?
            raise AssertionError("Plugin can only exist on a plugin type tree entry!")

        _URL_RESOLVER_CACHE.clear()

        # FIXME: We must only update the cache for the current SITE not for all sites.
        try:
            cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
        except AttributeError:
            # No SmoothCacheBackend used -> clean the complete cache
            cache.clear()

        return super(PluginPage, self).save(*args, **kwargs)

    def __unicode__(self):
        return u"PluginPage '%s' (pagetree: %r)" % (self.app_label, self.pagetree)

    class Meta:
        app_label = 'pylucid'
        verbose_name_plural = verbose_name = "PluginPage"
        ordering = ("-lastupdatetime",)
#        ordering = ("pagetree", "language")

# Check Meta.unique_together manually
model_utils.auto_add_check_unique_together(PluginPage)


########NEW FILE########
__FILENAME__ = userprofile
# coding: utf-8

"""
    pylucid.models
    ~~~~~~~~~~~~~~

    :copyleft: 2009-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.db import models
from django.db.models import signals
from django.contrib.auth.models import User

# http://code.google.com/p/django-tools/
from django_tools.utils.messages import failsafe_message
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.utils import crypt
from pylucid_project.base_models.many2many import AutoSiteM2M


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


class UserProfile(AutoSiteM2M, UpdateInfoBaseModel):
    """
    Stores additional information about PyLucid users
    http://docs.djangoproject.com/en/dev/topics/auth/#storing-additional-information-about-users

    Created via post_save signal, if a new user created.

    inherited attributes from AutoSiteM2M:
        sites   -> ManyToManyField to Site
        on_site -> sites.managers.CurrentSiteManager instance
        
    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    user = models.ForeignKey(User, unique=True, related_name="%(class)s_user")

    sha_login_checksum = models.CharField(max_length=192,
        help_text="Checksum for PyLucid JS-SHA-Login"
    )
    sha_login_salt = models.CharField(max_length=crypt.SALT_LEN,
        help_text="Salt value for PyLucid JS-SHA-Login"
    )

    # TODO: Overwrite help_text:
#    sites = models.ManyToManyField(Site,
#        help_text="User can access only these sites."
#    )

    def set_sha_login_password(self, raw_password):
        """
        create salt+checksum for JS-SHA-Login.
        see also: http://www.pylucid.org/_goto/8/JS-SHA-Login/
        """
        raw_password = str(raw_password)
        salt, sha_checksum = crypt.make_sha_checksum2(raw_password)
        self.sha_login_salt = salt
        self.sha_login_checksum = sha_checksum
        failsafe_message("SHA Login salt+checksum set for user '%s'." % self.user)

    def __unicode__(self):
        sites = self.sites.values_list('name', flat=True)
        return u"UserProfile for user '%s' (on sites: %r)" % (self.user.username, sites)

    class Meta:
        app_label = 'pylucid'
        ordering = ("user",)

#______________________________________________________________________________
# Create user profile via signals

def create_user_profile(sender, **kwargs):
    """ signal handler: creating user profile, after a new user created. """
    user = kwargs["instance"]

    userprofile, created = UserProfile.objects.get_or_create(user=user)
    if created:
        failsafe_message("UserProfile entry for user '%s' created." % user)
#
#        if not user.is_superuser: # Info: superuser can automaticly access all sites
#            site = Site.objects.get_current()
#            userprofile.site.add(site)
#            failsafe_message("Add site '%s' to '%s' UserProfile." % (site.name, user))

signals.post_save.connect(create_user_profile, sender=User)


#______________________________________________________________________________
"""
We make a Monkey-Patch and change the method set_password() from
the model class django.contrib.auth.models.User.
We need the raw plaintext password, this is IMHO not available via signals.
"""

# Save the original method
orig_set_password = User.set_password


def set_password(user, raw_password):
    #print "set_password() debug:", user, raw_password
    if user.id == None:
        # It is a new user. We must save the django user accound first to get a
        # existing user object with a ID and then the JS-SHA-Login Data can assign to it.
        user.save()

    # Use the original method to set the django User password:
    orig_set_password(user, raw_password)

    userprofile, created = UserProfile.objects.get_or_create(user=user)
    if created:
        failsafe_message("UserProfile entry for user '%s' created." % user)

    # Save the password for the JS-SHA-Login:
    userprofile.set_sha_login_password(raw_password)
    userprofile.save()


# replace the method
User.set_password = set_password

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

"""
    PyLucid system preferences
    ~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import warnings

from django import forms
from django.contrib import messages
from django.contrib.messages import constants as message_constants
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _
from django.contrib.messages.api import MessageFailure

from dbpreferences.forms import DBPreferencesBaseForm

from django_tools.middlewares import ThreadLocal

from pylucid_project.apps.pylucid.models import Design


#if Language.objects.count() == 0:
#    # FIXME: Insert first language
#    Language(code="en", description="english").save()
#    warnings.warn("First language 'en' created.")


class SystemPreferencesForm(DBPreferencesBaseForm):
    """ test preferences form """

    # We can't use ModelChoiceField here, is not supported in DBpreferences, yet.
    # see: http://code.google.com/p/django-dbpreferences/issues/detail?id=4
#    pylucid_admin_design = forms.ChoiceField(
#        # choices= Set in __init__, so the Queryset would not execute at startup
#        initial=None,
#        help_text=_("ID of the PyLucid Admin Design. (Not used yet!)")
#    )

    PERMALINK_USE_NONE = "nothing"
    PERMALINK_USE_SLUG = "slug"
    PERMALINK_USE_NAME = "name"
    PERMALINK_USE_TITLE = "title"
    PERMALINK_USE_CHOICES = (
        (PERMALINK_USE_NONE, _("Append no additional text")),
        (PERMALINK_USE_SLUG, _("Append the PageTree slug (language independent)")),
        (PERMALINK_USE_NAME, _("Append the PageMeta name (language dependent)")),
        (PERMALINK_USE_TITLE, _("Append the PageMeta title (language dependent)")),
    )
    permalink_additions = forms.ChoiceField(
        choices=PERMALINK_USE_CHOICES,
        initial=PERMALINK_USE_TITLE,
        help_text=_("Should we append a additional text to every permalink?")
    )

    # Used in pylucid_project.middlewares.pylucid_objects.py
    LOG404_NOTHING = "nothing"
    LOG404_NOREDIRECT = "no_redirect"
    LOG404_EVERYTHING = "everything"
    LOG404_CHOICES = (
        (LOG404_NOTHING, _("Don't log 'Page not found' errors.")),
        (LOG404_NOREDIRECT, _("Log only 'Page not found' if no redirect for the url exists.")),
        (LOG404_EVERYTHING, _("Log every 'Page not found' error, although if redirect exists.")),
    )
    log404_verbosity = forms.ChoiceField(
        choices=LOG404_CHOICES,
        initial=LOG404_NOREDIRECT,
        help_text=_("Setup logging verbosity if 404 - 'Page not found' appears")
    )

    MESSAGE_LEVEL_CHOICES = (
        (message_constants.DEBUG, "Debug (%s)" % message_constants.DEBUG),
        (message_constants.INFO, "Info (%s)" % message_constants.INFO),
        (message_constants.SUCCESS, "Success (%s)" % message_constants.SUCCESS),
        (message_constants.WARNING, "Warning (%s)" % message_constants.WARNING),
        (message_constants.ERROR, "Error (%s)" % message_constants.ERROR),
    )
    message_level_anonymous = forms.ChoiceField(
        choices=MESSAGE_LEVEL_CHOICES,
        initial=message_constants.INFO,
        help_text=_("Set django message level for anonymous user to set the minimum message that will be displayed.")
    )
    message_level_normalusers = forms.ChoiceField(
        choices=MESSAGE_LEVEL_CHOICES,
        initial=message_constants.INFO,
        help_text=_("Set django message level for normal users to set the minimum message that will be displayed.")
    )
    message_level_staff = forms.ChoiceField(
        choices=MESSAGE_LEVEL_CHOICES,
        initial=message_constants.DEBUG,
        help_text=_("Set django message level for staff users to set the minimum message that will be displayed.")
    )
    message_level_superuser = forms.ChoiceField(
        choices=MESSAGE_LEVEL_CHOICES,
        initial=message_constants.DEBUG,
        help_text=_("Set django message level for superusers to set the minimum message that will be displayed.")
    )

    max_log_entries = forms.IntegerField(
        initial=1000, min_value=1,
        help_text=_("The maximal numbers of log entries. After this the oldest log entries would be automatically deleted to protect against overloading."),
    )

    ban_count = forms.IntegerField(
        help_text=_("Numbers of exceptions from one IP within 'ban_time' Sec. after IP would be banned. (Used 'REMOTE_ADDR')"),
        initial=10, min_value=1, max_value=100
    )
    ban_time = forms.IntegerField(
        help_text=_("Time period for count exceptions log messages from the same IP. (Used 'REMOTE_ADDR')"),
        initial=30, min_value=1, max_value=600
    )

#    def __init__(self, *args, **kwargs):
#        super(SystemPreferencesForm, self).__init__(*args, **kwargs)
#        existing_designs = Design.on_site.all().values_list("id", "name")
#
#        self.fields['pylucid_admin_design'].choices = existing_designs
#        self.base_fields['pylucid_admin_design'].choices = existing_designs
#
#        # Fallback if admin design not set
#        initial = existing_designs[0][0]
#        for id, name in existing_designs:
#            if name == "PyLucid Admin":
#                initial = id
#                break
#
#        self.base_fields['pylucid_admin_design'].initial = initial

    def get_preferences(self):
        """
        Fall back to initial data, if something wrong with system preferences.
        This is important, because nothing would work, if validation error raised.
        """
        try:
            return super(SystemPreferencesForm, self).get_preferences()
        except ValidationError, e:
            self.data = self.save_form_init()

            msg = 'Reset system preferences cause: %s' % e
            request = ThreadLocal.get_current_request()
            try:
                messages.info(request, msg)
            except MessageFailure:
                # If message system is not initialized, e.g.:
                # load the system preferences on module level
                warnings.warn(msg)

            return self.data

        return super(SystemPreferencesForm, self).get_preferences()

    class Meta:
        app_label = 'pylucid'

########NEW FILE########
__FILENAME__ = shortcuts
# coding:utf-8

"""
    PyLucid shortcuts
    ~~~~~~~~~~~~~~~~~
    
    render_pylucid_response() - Similar to django.shortcuts.render_to_response, can be used in
        PyLucid plugin "ajax+normal response" views.

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.conf import settings
from django.http import HttpResponse, HttpResponseBadRequest
from django.template.loader import render_to_string
from django.utils.safestring import mark_safe

from pylucid_project.apps.pylucid.models.log import LogEntry


def ajax_response(request, template_name, context, **kwargs):
    response_content = render_to_string(template_name, context, **kwargs)

    # Get the extrahead storage (pylucid.system.extrahead.ExtraHead)
    extrahead = request.PYLUCID.extrahead

    # Get the extra head content as a string
    extra_head_content = extrahead.get()

    # insert the extra head content into the response content
    # Note: In a ajax view the {% extrahead %} block would normaly not rendered into
    # the response content. Because the view returns a HttpResponse object, so all
    # other processing skip and all PyLucid context middleware (in the global template)
    # would not rendered.
    response_content = mark_safe(extra_head_content + "\n" + response_content)

    http_response_kwargs = {'mimetype': kwargs.pop('mimetype', None)}
    return HttpResponse(response_content, **http_response_kwargs)


def render_pylucid_response(request, template_name, context, **kwargs):
    """
    Similar to django.shortcuts.render_to_response.
    
    If it's a ajax request: insert extra head content and return a HttpResponse object.
    This will be send directly back to the client.
    
    If it's not a ajax request: render the plugin template and return it as a String: So it
    will be replace the cms page content in the global template. The complete page would be
    rendered.
    
    TODO: merge render_to() and render_pylucid_response()
    """
    if request.is_ajax():
#        print "make ajax response..."
        return ajax_response(request, template_name, context, **kwargs)

    response_content = render_to_string(template_name, context, **kwargs)
#    print "make normal response..."
    # Non-Ajax request: the string content would be replace the page content.
    # The {% extrahead %} content would be inserted into the globale template with
    # the PyLucid context middleware pylucid_plugin.extrahead.context_middleware
#    response = HttpResponse(response_content)
#    response.replace_main_content = True # Plugin replace the page content
#    return response
    return response_content


def bad_request(app_label, action, debug_msg):
    """
    Create a new LogEntry and return a HttpResponseBadRequest
    """
    LogEntry.objects.log_action(
        app_label=app_label, action=action, message=debug_msg,
    )
    if settings.DEBUG:
        msg = debug_msg
    else:
        msg = ""

    return HttpResponseBadRequest(msg)


########NEW FILE########
__FILENAME__ = signals
# coding:utf-8

import django.dispatch

pre_render_global_template = django.dispatch.Signal(providing_args=["request", "page_template"])
#post_render_global_template = django.dispatch.Signal(providing_args=["toppings", "size"])

########NEW FILE########
__FILENAME__ = get_codemirror_files
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid codemirror helper
    ~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Get needed CodeMirror files and save it compressed.
    use:
        http://code.google.com/closure/compiler/

    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from pylucid_project.utils.closure_compiler import ClosureCompiler


CODEMIRROR_BASE_URL = "https://github.com/marijnh/CodeMirror/raw/master/js/"
SOURCE_URLS = (
    # Library
    ("codemirror_min.js", [CODEMIRROR_BASE_URL + "codemirror.js"]),
    # base files
    ("codemirror_base.js", [
        CODEMIRROR_BASE_URL + "util.js",
        CODEMIRROR_BASE_URL + "stringstream.js",
        CODEMIRROR_BASE_URL + "select.js",
        CODEMIRROR_BASE_URL + "undo.js",
        CODEMIRROR_BASE_URL + "editor.js",
        CODEMIRROR_BASE_URL + "tokenize.js",
    ]),
    # Parsers
    ("parsecss.js", [CODEMIRROR_BASE_URL + "parsecss.js"]),
    ("tokenizejavascript.js", [CODEMIRROR_BASE_URL + "tokenizejavascript.js"]),
    ("parsejavascript.js", [CODEMIRROR_BASE_URL + "parsejavascript.js"]),
    ("parsecss.js", [CODEMIRROR_BASE_URL + "parsecss.js"]),
    ("parsehtmlmixed.js", [CODEMIRROR_BASE_URL + "parsehtmlmixed.js"]),

    # Contributed parsers
    ("parsepython.js", ["https://github.com/marijnh/CodeMirror/raw/master/contrib/python/js/parsepython.js"]),
    ("parsedjango.js", ["http://github.com/jezdez/django-dbtemplates/raw/master/dbtemplates/static/dbtemplates/js/parsedjango.js"]),
)


if __name__ == "__main__":
    cc = ClosureCompiler(".")
    for filename, urls in SOURCE_URLS:
        cc.get_and_save(filename, urls)




########NEW FILE########
__FILENAME__ = get_wysiwyg_files
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid codemirror helper
    ~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Get needed CodeMirror files and save it compressed.
    use:
        http://code.google.com/closure/compiler/

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import subprocess
from pylucid_project.utils.closure_compiler import ClosureCompiler


BASE_URL = "http://github.com/akzhan/jwysiwyg/raw/master/jwysiwyg/"
SOURCE_URLS = (
    ("jquery.wysiwyg.js", [BASE_URL + "jquery.wysiwyg.js"]),
)

WGET_BASE = ("wget", "--timestamp")
WGET_URLS = (
#    BASE_URL + "jquery.wysiwyg.js",
    BASE_URL + "jquery.wysiwyg.css",
    BASE_URL + "jquery.wysiwyg.gif",
    BASE_URL + "jquery.wysiwyg.modal.css",
)


if __name__ == "__main__":
    cc = ClosureCompiler(".")
    for filename, urls in SOURCE_URLS:
        cc.get_and_save(filename, urls)

    print "update via wget:"
    for url in WGET_URLS:
        cmd = WGET_BASE + (url,)
        print "_" * 79
        print "run:", cmd
        subprocess.Popen(cmd).wait()
        print "-" * 79




########NEW FILE########
__FILENAME__ = extrahead
# coding: utf-8

"""
    PyLucid extrahead
    ~~~~~~~~~~~~~~~~~

    Stores extra html head content.
    A instance would be added to request.PYLUCID.extrahead in:
        pylucid.system.pylucid_objects
        
    Used in e.g.:
        pylucid_plugin.extrahead.context_middleware
        pylucid.shortcuts.render_pylucid_response

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate: $
    $Rev: $
    $Author: $

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


__version__= "$Rev:$"

import os
import inspect

from django.conf import settings


FILEPATH_SPLIT = "pylucid_project"

DEBUG_INFO = """\
<!-- extrahead from %(fileinfo)s - START -->
%(content)s
<!-- extrahead from %(fileinfo)s - END -->"""


class ExtraHead(list):
    """
    Simple store extra html head content from plugins.
    """
    def __init__(self, *args, **kwargs):
        super(ExtraHead, self).__init__(*args, **kwargs)
        
        if settings.DEBUG:
            # For self._get_fileinfo():
            self.basename = os.path.basename(__file__)
            if self.basename.endswith(".pyc"):
                # cut: ".pyc" -> ".py"
                self.basename = self.basename[:-1]
                    
            # Turn debug mode in JavaScript on
            list.append(self, DEBUG_INFO % {
                    "fileinfo": os.path.basename(__file__),
                    "content": '<script type="text/javascript">var debug=true;log("debug is on");</script>'
                }
            )            
        
    def append(self, content):
        """ add new content """
        content = content.strip()
        if settings.DEBUG:
            # Add debug info around content.
            fileinfo = self._get_fileinfo()
            content = DEBUG_INFO % {"fileinfo": fileinfo, "content": content}
            
        list.append(self, content)
        
    def get(self):
        """ return all extra head content """
        return "\n".join(self)
    
    def _get_fileinfo(self):
        """ return fileinfo: Where from the extra head content comes? """       
        try:    
            for stack_frame in inspect.stack():
                filepath = stack_frame[1]              
                lineno = stack_frame[2]

                # go forward in the stack, to outside of this file.
                if os.path.basename(filepath) != self.basename:
                    break

            filepath = "..." + filepath.split(FILEPATH_SPLIT,1)[1]
            return "%s line %s" % (filepath, lineno)
        except Exception, e:
            return "(inspect Error: %s)" % e

########NEW FILE########
__FILENAME__ = headfile
# coding: utf-8


"""
    PyLucid headfile
    ~~~~~~~~~~~~~~~~

    Stores the information about CSS/JS links or content for html head.

    Used in pylucid.models and pylucid_plugins.head_files.context_middleware 

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os
import mimetypes
from xml.sax.saxutils import escape

from django.conf import settings
from django.utils import safestring
from django.template import RequestContext
from django.core.urlresolvers import reverse
from django.template.loader import render_to_string


TYPE_CSS = "css"
TYPE_JS = "js"
KNOWN_TYPES = (TYPE_CSS, TYPE_JS)

DEFAULT_INLINE_ATTRIBUTES = {
    TYPE_CSS:{"type":"text/css"},
    TYPE_JS: {"type":"text/javascript"},
}
DEFAULT_LINK_ATTRIBUTES = {
    TYPE_CSS:{"type":"text/css", "rel":"stylesheet"},
    TYPE_JS: {"type":"text/javascript"},
}


class HeadfileBase(object):
    def check_type(self):
        if self.data_type not in KNOWN_TYPES:
            raise RuntimeError("Data type %r unknown!" % self.data_type)

    def get_head_tag(self):
        return render_to_string(self.template_name, self.context)



class HeadfileInline(HeadfileBase):
    """ CSS/JS content in the html head """
    def __init__(self, data_type, content, tag_attrs={}):
        self.data_type = data_type
        self.check_type()

        self.content = content

        self.tag_attrs = DEFAULT_INLINE_ATTRIBUTES[data_type]
        self.tag_attrs.update(tag_attrs)

        self.template_name = settings.PYLUCID.HEADFILE_INLINE_TEMPLATES % self.data_type
        self.context = {"tag_attrs": self.tag_attrs, "content": self.content, }


class HeadfileLink(HeadfileBase):
    """
    Links to CSS/JS files in html head
    TODO: Should check if the file was saved into media path
    """
    def __init__(self, url, tag_attrs={}):
        self.url = url
        if "?" in url:
            path = url.split("?", 1)[0]
        else:
            path = url
        self.data_type = os.path.splitext(path)[1].lstrip(".")
        self.check_type()

        self.tag_attrs = self.make_tag_attrs(tag_attrs)

        self.template_name = settings.PYLUCID.HEADFILE_LINK_TEMPLATES % self.data_type
        self.context = {"url": self.url, "tag_attrs": self.tag_attrs}

    def make_tag_attrs(self, tag_attrs):
        attributes = DEFAULT_LINK_ATTRIBUTES[self.data_type]

        if settings.DEBUG:
            attributes["onerror"] = safestring.mark_safe(
                "JavaScript:alert('Error loading file [%s] !');" % escape(self.url)
            )

        attributes.update(tag_attrs)
        return attributes


########NEW FILE########
__FILENAME__ = i18n
# coding: utf-8


"""
    PyLucid i18n tools
    ~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p

"""


if __name__ == "__main__":
    # For doctest only
    import os
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"


from django.conf import settings
from django.contrib import messages
from django.http import HttpResponseRedirect
from django.utils import translation

from pylucid_project.apps.pylucid.models import Language


def change_url_language(old_url, new_lang_code):
    """
    >>> change_url_language("/en/foo/bar/", "de")
    '/de/foo/bar/'
    >>> change_url_language("/en/", "de")
    '/de/'
    >>> change_url_language("/", "de")
    '/de/'
    >>> change_url_language("/en/?foo=bar", "de")
    '/de/?foo=bar'
    """
#    print "old_url: %r" % old_url
    url = old_url.lstrip("/")
    if not url:
        return "/%s/" % new_lang_code

    url = url.split("/", 1)[1]
#    print "url: %r" % url
    new_url = "/%s/%s" % (new_lang_code, url)
#    print "new_url: %r" % new_url
    return new_url


def change_url(request, new_lang_code, save_get_parameter=True):
    """
    change the language code in the current url
    
    if save_get_parameter==True:
        keep GET parameter in url
    else:
        remove GET parameter
    """
    if save_get_parameter:
        old_url = request.get_full_path()
    else:
        old_url = request.path

    return change_url_language(old_url, new_lang_code)


def get_url_language(request, url=None):
    """
    return the language instance based on the language code in the url.
    If url==None: use the current request.path.
    """
    if url is None:
        url = request.path

    url = url.lstrip("/")
    language_code = url.split("/", 1)[0]
    for language in request.PYLUCID.languages:
        if language_code == language.code:
            return language


def reset_language_settings(request):
    """
    Reset the favored language information.
    -Remove language information from session
    -Delete djangos language cookie
    """
    if settings.PYLUCID.I18N_DEBUG:
        messages.success(request,
            "Reset the favored language information. (Delete session and cookie entry.)"
        )

    if "django_language" in request.session:
        # Remove language information from session.
        del(request.session["django_language"])
        request.session.modified = True

    response = HttpResponseRedirect(request.path)
    # Delete djangos language cookie.
    response.delete_cookie(settings.LANGUAGE_COOKIE_NAME)
    return response


def activate_auto_language(request):
    """
    Activate language via auto detection.
    
    Use request.LANGUAGE_CODE from django locale middleware. If this language
    doesn't exist -> fall back to language set in system preferences.
    
    FIXME: We must use the client list from request.META['HTTP_ACCEPT_LANGUAGE']
        The PyLucid admin can setup a language witch doesn't exist in django MO files. 
    """
    lang_code = request.LANGUAGE_CODE

    if settings.PYLUCID.I18N_DEBUG:
        messages.info(request, "settings.PYLUCID.I18N_DEBUG:")
        key = "HTTP_ACCEPT_LANGUAGE"
        messages.info(request, "%s: %r" % (key, request.META.get(key, '---')))
        key = settings.LANGUAGE_COOKIE_NAME
        messages.info(request, "request.PYLUCID.languages: %r" % request.PYLUCID.languages)
        messages.info(request, "request.session['django_language']: %r" % request.session.get('django_language', "---"))
        messages.info(request, "request.LANGUAGE_CODE: %r (set in django.middleware.local)" % lang_code)

    current_language = request.PYLUCID.current_language
    activate_language(request, lang_entry=current_language)

#    lang_entry = Language.objects.get_from_code(request, lang_code)
#    if lang_entry is None:
#        if settings.PYLUCID.I18N_DEBUG:
#            messages.error(request, 
#                'Favored language "%s" does not exist -> use activate_default_language()' % lang_code
#            )
#        activate_default_language(request)
#    else:
#        activate_language(request, lang_entry)


def activate_default_language(request):
    """ activate default lang from preferences """
    default_language = request.PYLUCID.default_language

    if settings.PYLUCID.I18N_DEBUG:
        messages.success(request, 'Use default language "%s"' % default_language.code)

    activate_language(request, default_language)


def activate_language(request, lang_entry, save=False):
    """
    Activate django i18n language and set some request objects:
    
         * request.PYLUCID.current_language
    Add lang_entry witch is the given Language model instance.
        
        * request.LANGUAGE_CODE
    Set LANGUAGE_CODE from django.middleware.locale.LocaleMiddleware
    see: http://docs.djangoproject.com/en/dev/topics/i18n/
    """
    if save:
        # Save language in session for next requests
        if settings.PYLUCID.I18N_DEBUG:
            messages.info(request,
                'Save lang code "%s" into request.session[\'django_language\']' % lang_entry.code
            )
        request.session["django_language"] = lang_entry.code

    if request.LANGUAGE_CODE == lang_entry.code:
        # this language is active, nothing to do
        if settings.PYLUCID.I18N_DEBUG:
            messages.info(request,
                "Activation language %r not needed: It's the current used language." % lang_entry.code
            )
        return

    request.LANGUAGE_CODE = lang_entry.code
    request.PYLUCID.current_language = lang_entry

    # activate django i18n:
    translation.activate(lang_entry.code)
    request.LANGUAGE_CODE = translation.get_language()
    if settings.DEBUG or settings.PYLUCID.I18N_DEBUG:
        if lang_entry.code != request.LANGUAGE_CODE:
            messages.error(
                request, 'Language "%s" was not activated from django! Fallback to "%s"' % (
                lang_entry.code, request.LANGUAGE_CODE)
            )
        elif settings.PYLUCID.I18N_DEBUG:
            messages.success(request, 'Language "%s" activated successfuly.' % lang_entry.code)


def assert_language(request, language, save_get_parameter=False, check_url_language=False):
    """
    return a redirect url if the current used language is not the same as the given one.
    This is useful in plugins e.g.: in the blog detail view
    """
    new_url = None

    if language != request.PYLUCID.current_language:
        if settings.PYLUCID.I18N_DEBUG:
            messages.info(request, "entry language %s is not %s" % (language, request.PYLUCID.current_language))

        activate_language(request, language, save=True)

        # change only the lang code in the url:
        new_url = change_url(request, language.code, save_get_parameter)

    if check_url_language:
        url_language = get_url_language(request)
        if url_language != language:
            # The url contains the wrong language code -> redirect to the right one
            new_url = change_url(request, language.code, save_get_parameter)

    if new_url:
        if new_url != request.path:
            # redirect, so the new selected language would be used
            return new_url
        else:
            msg = "FIXME: Redirect loop! new url: %r" % new_url
            if settings.DEBUG or request.user.is_staff:
                messages.error(request, msg)


def resort_languages(request, url_lang_code):
    """
    Put the language from the url to the first language.
    """
    if request.PYLUCID.languages[0].code == url_lang_code:
        if settings.PYLUCID.I18N_DEBUG:
            messages.info(request, "no need to resort languages: first language == url language code.")
        return

    for no, lang in enumerate(request.PYLUCID.languages):
        if lang.code == url_lang_code:
            url_lang = request.PYLUCID.languages.pop(no)
            request.PYLUCID.languages.insert(0, url_lang)
            if settings.PYLUCID.I18N_DEBUG:
                messages.info(request, "move language %r (from url code) to first." % url_lang)
            return



if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = permalink
# coding: utf-8

"""
more info: http://www.pylucid.org/permalink/319/about-permalink-for-plugin-developers
"""

import posixpath

from django.conf import settings
from django.contrib import messages


#DEBUG = True
DEBUG = False


def plugin_permalink(request, absolute_url):
    """
    Append a additional url part to the normal page permalink.
    e.g.: Deeplink to a blog entry detail view
    """
    current_url = request.PYLUCID.pagemeta.get_absolute_url()

    pagemeta = request.PYLUCID.pagemeta
    page_permalink = pagemeta.get_permalink()

    if not absolute_url.startswith(current_url):
        # Should normally never happen...
        if DEBUG or settings.DEBUG or request.user.is_staff:
            messages.error(request,
                "entry url %r doesn't start with current url %r!" % (absolute_url, current_url)
            )
        return absolute_url # fallback

    additional_url = absolute_url[len(current_url):]
    permalink = posixpath.join(page_permalink, additional_url)

    if DEBUG:
        messages.debug(request, "absolute_url: %r" % absolute_url)
        messages.debug(request, "current_url: %r" % current_url)
        messages.debug(request, "page_permalink: %r" % page_permalink)
        messages.debug(request, "additional_url: %r" % additional_url)
        messages.debug(request, "new permalink: %r" % permalink)

    return permalink

########NEW FILE########
__FILENAME__ = pylucid_objects
# coding:utf-8

"""
    PyLucid objects
    ~~~~~~~~~~~~~~~
    
    Some need full objects attached to the current request object in pylucid.views.
    
    see also: http://www.pylucid.org/_goto/187/PyLucid-objects/

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib import messages
from django.utils.safestring import mark_safe

from django_tools.utils.messages import failsafe_message

from pylucid_project.apps.pylucid.preference_forms import SystemPreferencesForm
from pylucid_project.apps.pylucid.system import extrahead
from pylucid_project.utils.escape import escape


# max value length in debug __setattr__
MAX_VALUE_LENGTH = 150


class PyLucidRequestObjects(object):
    """ PyLucid request objects """
    _check_setattr = False
    def __init__(self, request):
        self.request = request

        self.preferences_form = SystemPreferencesForm()
        self.preferences = self.preferences_form.get_preferences()

        # FIXME: import here, against import loop:
        from pylucid_project.apps.pylucid.models import Language

        self.languages = Language.objects.get_languages(request)
        self.default_language = Language.objects.get_or_create_default(request)
        try:
            self.current_language = self.languages[0]
        except IndexError, err:
            messages.info(request,
                (
                    "There exist no language on this site!"
                    " Used default one."
                    " Go into 'django admin/PyLucid/Languages' and"
                    " add at least one language to this site!"
                    " (Original error was: %s)"
                ) % err
            )
            self.languages = [self.default_language]
            self.current_language = self.default_language


        # Storing extra html head code from plugins, used in:
        # pylucid.defaulttags.extraheadBlock - redirect {% extrahead %} block tag content
        # pylucid_plugin.extrahead.context_middleware - insert the data into the global page
        self.extrahead = extrahead.ExtraHead()

        # objects witch will be set later:
        #self.object2comment - Object to comment
        #self.pagetree - The current PageTree model instance
        #self.pagemeta - The current PageMeta model instance
        #
        # if current page == PageTree.PAGE_TYPE: # a normal content page
        #     self.pagecontent - PageContent instance, attached at pylucid.views._render_page()
        # elif  current page == PageTree.PLUGIN_TYPE: # a plugin page
        #     self.pluginpage - PluginPage instance, attached at pylucid.system.pylucid_plugin.call_plugin()
        #
        #self.page_template - The global page template as a string
        #self.context - The global context

        self._check_setattr = settings.DEBUG

    def _setattr_debug(self, name, value):
        """
        debug __setattr__ to see if new attributes would be defined or existing changed.
        
        HowTo: http://www.pylucid.org/permalink/133/pylucid-objects#DEBUG
        """
        if self._check_setattr:
            if hasattr(self, name):
                action = "changed"
            else:
                action = "set"

            value_preview = repr(value)
            if len(value_preview) > MAX_VALUE_LENGTH - 3:
                value_preview = value_preview[:MAX_VALUE_LENGTH] + "..."
            value_preview = escape(value_preview)
            msg = "request.PYLUCID.<strong>%s</strong> %s to: <i>%s</i> (type: %s)" % (
                name, action, value_preview, escape(repr(type(value)))
            )
            messages.info(self.request, mark_safe(msg))

        super(PyLucidRequestObjects, self).__setattr__(name, value)


if settings.PYLUCID_OBJECTS_DEBUG:
    assert settings.DEBUG == True, "PyLucidRequestObjects works only if settings.DEBUG is on!"
    PyLucidRequestObjects.__setattr__ = PyLucidRequestObjects._setattr_debug


########NEW FILE########
__FILENAME__ = pylucid_plugin
# coding: utf-8

"""
    PyLucid plugin tools
    ~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p

"""


from django.contrib import messages
from django.core import urlresolvers
from django.http import HttpResponse
from django.views.decorators.csrf import csrf_protect

from dbpreferences.forms import DBPreferencesBaseForm


class PyLucidDBPreferencesBaseForm(DBPreferencesBaseForm):
    def get_preferences(self, request, lucidtag_kwargs):
        """
        Update the preferences dict with the given kwargs dict.
        Send a staff user feedback if a kwargs key is invalid.
        """
        preferences = super(PyLucidDBPreferencesBaseForm, self).get_preferences()
        if request.user.is_staff:
            for key in lucidtag_kwargs.keys():
                if key not in preferences:
                    messages.info(request,
                        "Keyword argument %r is invalid for lucidTag %r !" % (key, self.Meta.app_label)
                    )
        preferences.update(lucidtag_kwargs)
        return preferences


class PluginGetResolver(object):
    def __init__(self, resolver):
        self.resolver = resolver
    def __call__(self, *args, **kwargs):
        return self.resolver


def _raise_resolve_error(plugin_url_resolver, rest_url):
    tried = [i[0][0][0] for i in plugin_url_resolver.reverse_dict.values()]
#    for key, value in plugin_url_resolver.reverse_dict.values():
#        print key, value

#    tried = [prefix + pattern.regex.pattern.lstrip("^") for pattern in plugin_urlpatterns]
    raise urlresolvers.Resolver404, {'tried': tried, 'path': rest_url + "XXX"}


def call_plugin(request, url_lang_code, prefix_url, rest_url):
    """
    Call a plugin and return the response.
    used for PluginPage
    """
    lang_entry = request.PYLUCID.current_language
    pluginpage = request.PYLUCID.pluginpage
    pagemeta = request.PYLUCID.pagemeta

    # build the url prefix
    # Don't use pagemeta.language.code here, use the real url_lang_code, because of case insensitivity
    url_prefix = "^%s/%s" % (url_lang_code, prefix_url)

    # Get pylucid_project.system.pylucid_plugins instance
    plugin_instance = pluginpage.get_plugin()

    plugin_url_resolver = plugin_instance.get_plugin_url_resolver(
        url_prefix, urls_filename=pluginpage.urls_filename,
    )
    #for key, value in plugin_url_resolver.reverse_dict.items(): print key, value

    # get the plugin view from the complete url
    resolve_url = request.path_info
    result = plugin_url_resolver.resolve(resolve_url)
    if result == None:
        _raise_resolve_error(plugin_url_resolver, resolve_url)

    view_func, view_args, view_kwargs = result

    if "pylucid.views" in view_func.__module__:
        # The url is wrong, it's from PyLucid and we can get a loop!
        # FIXME: How can we better check, if the view is from the plugin and not from PyLucid???
        _raise_resolve_error(plugin_url_resolver, resolve_url)

    merged_url_resolver = plugin_instance.get_merged_url_resolver(
        url_prefix, urls_filename=pluginpage.urls_filename,
    )

    # Patch urlresolvers.get_resolver() function, so only our own resolver with urlpatterns2
    # is active in the plugin. So the plugin can build urls with normal django function and
    # this urls would be prefixed with the current PageTree url.
    old_get_resolver = urlresolvers.get_resolver
    urlresolvers.get_resolver = PluginGetResolver(merged_url_resolver)

    # Add info for pylucid_project.apps.pylucid.context_processors.pylucid
    request.plugin_name = view_func.__module__.split(".", 1)[0] # FIXME: Find a better way!
    try:
        request.method_name = view_func.__name__
    except AttributeError:
        # e.g.: it's a django.contrib.syndication.views.Feed class instance
        request.method_name = view_func.__class__.__name__

    csrf_exempt = getattr(view_func, 'csrf_exempt', False)
    if not csrf_exempt:
        view_func = csrf_protect(view_func)

    # Call the view
    response = view_func(request, *view_args, **view_kwargs)

    if csrf_exempt and isinstance(response, HttpResponse):
        response.csrf_exempt = True

    request.plugin_name = None
    request.method_name = None

    # restore the patched function
    urlresolvers.get_resolver = old_get_resolver

    return response


########NEW FILE########
__FILENAME__ = simple_menu

from django import template

from pylucid_project.apps.pylucid.models import Page08

register = template.Library()

@register.inclusion_tag('pylucid/simple_menu.html')
def simple_menu():
    pages = Page08.objects.all()
    context = {
        "pages": pages,
    }
    return context

#from django.template import add_to_builtins
#add_to_builtins('PyLucid.template_addons')
########NEW FILE########
__FILENAME__ = test_settings
# coding: utf-8

from pylucid_project.settings import *

#INSTALLED_APPS = (
#    'django.contrib.auth',
#    'django.contrib.contenttypes',
#    'django.contrib.sessions',
#    'django.contrib.sites',
#    'django.contrib.admin',
#
#    'pylucid',
#)

DATABASE_ENGINE = "sqlite3"
DATABASE_NAME = ":memory:"

SITE_ID = 1

ROOT_URLCONF = "pylucid.tests.testutils.test_urls"

TEST_RUNNER = 'django.test.simple.run_tests'
########NEW FILE########
__FILENAME__ = test_urls
# coding: utf-8

"""
    global url patterns
    ~~~~~~~~~~~~~~~~~~~


    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url, include

urlpatterns = patterns('',
    ('^', include('pylucid.urls')),
)

########NEW FILE########
__FILENAME__ = test_Design
#!/usr/bin/env python
# coding: utf-8


"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    TODO: Test colorscheme stuff
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings

from dbpreferences.tests.BrowserDebug import debug_response

from pylucid_project.tests.test_tools import basetest
from pylucid_project.tests.test_tools.scrapping import HTMLscrapper

settings.SERVE_STATIC_FILES = True
#CACHE_DIR = settings.PYLUCID.CACHE_DIR
DEBUG = settings.DEBUG
CACHE_BACKEND = settings.CACHES["default"]["BACKEND"]

COMPRESS_DIR = "/%s/" % getattr(settings, "COMPRESS_OUTPUT_DIR", "CACHE")



class DesignTestCase(basetest.BaseUnittest):
    def setUp(self):
        settings.CACHES["default"]["BACKEND"] = "django.core.cache.backends.locmem.LocMemCache"

    def tearDown(self):
        # Recover changed settings
#        settings.PYLUCID.CACHE_DIR = CACHE_DIR
        settings.CACHES["default"]["BACKEND"] = CACHE_BACKEND

    def get_headlinks(self, response, url_part):
        data = HTMLscrapper().grab(response.content, tags=("link",), attrs=("href",))
#        for url in data["href"]: print url
        return [url for url in data["href"] if url_part in url]

    def get_headfile(self, url, mimetype="text/css"):
        response = self.client.get(url)
        self.assertStatusCode(response, 200)
        self.assertEqual(response["content-type"], mimetype)
        return response.content

    def assertHeadfiles(self, urls):
        for url in urls:
            response = self.client.get(url)
            self.assertStatusCode(response, 200)
            self.assertEqual(response["content-type"], "text/css")



class DesignTest(DesignTestCase):
    def test_cached_headfiles_styles(self):
        response = self.client.get("/")
#        debug_response(response)
        urls = self.get_headlinks(response, COMPRESS_DIR)
        self.assertHeadfiles(urls)

        self.failUnlessEqual(len(urls), 1)

        content = self.get_headfile(urls[0])
        self.failUnless("headfile stylesheet 'initial_site_style/main.css'" in content)
        self.failUnless("headfile stylesheet 'pygments.css'" in content)


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
    management.call_command('test', __file__, verbosity=2)

########NEW FILE########
__FILENAME__ = test_django_tag_assembler
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - related test in pylucid_plugins/language/tests.py
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os
import unittest
from pprint import pprint


if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"


from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.markup.django_tags import DjangoTagAssembler


class Test_low_level_DjangoTagAssembler(unittest.TestCase, basetest.MarkupTestHelper):
    def setUp(self):
        self.assembler = DjangoTagAssembler()

    def test1(self):
        test_text = self._prepare_text("""
            {% extends "base_generic.html" %}

            {% block title %}
            The page title: {{ section.title }}
            {% endblock %}
            
            <h1>{{ section.title }}</h1>
            
            Don't match {{{ **this** }}} stuff.
            Or {{/image.jpg| **that** }} it's from creole markup!
            
            <h2>
              <a href="{{ story.get_absolute_url }}">
                {{ story.headline|upper }}
              </a>
            </h2>
            <p>{{ story.tease|truncatewords:"100" }}</p>
        """)

        text2, cut_data = self.assembler.cut_out(test_text)
#        pprint(cut_data)
#        print text2
        self.failUnlessEqual(cut_data, ['{% extends "base_generic.html" %}',
             '{% block title %}\nThe page title: {{ section.title }}\n{% endblock %}',
             '{{ section.title }}',
             '{{ story.get_absolute_url }}',
             '{{ story.headline|upper }}',
             '{{ story.tease|truncatewords:"100" }}'
        ])
        self.failUnlessEqual(text2, self._prepare_text("""
            DjangoTag0Assembly

            DjangoTag1Assembly
            
            <h1>DjangoTag2Assembly</h1>
            
            Don't match {{{ **this** }}} stuff.
            Or {{/image.jpg| **that** }} it's from creole markup!
            
            <h2>
              <a href="DjangoTag3Assembly">
                DjangoTag4Assembly
              </a>
            </h2>
            <p>DjangoTag5Assembly</p>
        """))
        text = self.assembler.reassembly(text2, cut_data)
        self.failUnlessEqual(test_text, text)

    def test_multilinepre(self):
        test_text = u'start paragraph\n{{{\none\ntwo\n}}}\nthe end...'
        text2, cut_data = self.assembler.cut_out(test_text)
#        pprint(cut_data)
#        print text2
        self.failUnlessEqual(cut_data, [])
        self.failUnlessEqual(text2, test_text)

    def test_creole_image(self):
        test_text = u'a {{/image.jpg}} {{image.jpeg|text}}...'
        text2, cut_data = self.assembler.cut_out(test_text)
        self.failUnlessEqual(cut_data, [])
        self.failUnlessEqual(text2, test_text)

    def test_creole_image_upcase(self):
        test_text = u'a {{/IMAGE.PNG}}...'
        text2, cut_data = self.assembler.cut_out(test_text)
#        pprint(cut_data)
#        print text2
        self.failUnlessEqual(cut_data, [])
        self.failUnlessEqual(text2, test_text)

    def test_not_a_creole_image(self):
        test_text = u'a {{ variable|filter:"/" }}...'
        text2, cut_data = self.assembler.cut_out(test_text)
        self.failUnlessEqual(cut_data, [u'{{ variable|filter:"/" }}'])
        self.failUnlessEqual(text2, u"a DjangoTag0Assembly...")

    def test_unicode(self):
        input_text = u" {{ test }} "
        text2, cut_data = self.assembler.cut_out(input_text)
        self.failUnlessEqual(cut_data, [u'{{ test }}'])
        self.failUnlessEqual(text2, u" DjangoTag0Assembly ")

        text3 = self.assembler.reassembly(text2, cut_data)
        self.failUnlessEqual(text3, input_text)

    def test_escaping(self):
        test_text = "FooDjangoTag0AssemblyBar {{ Tag }} - {% lucidTag auth %}"

        text2, cut_data = self.assembler.cut_out(test_text)
#        pprint(cut_data)
#        print text2

        self.failUnlessEqual(cut_data, ["{{ Tag }}", "{% lucidTag auth %}"])
        self.failUnlessEqual(text2,
            "FooDjangoTagTag0AssemblyBar DjangoTag0Assembly - DjangoTag1Assembly"
        )

        text = self.assembler.reassembly(text2, cut_data)
        self.failUnlessEqual(test_text, text)


    def test_more_than_ten(self):
        test_text = "\n".join(["{{ %i }}" % no for no in xrange(12)])

        text2, cut_data = self.assembler.cut_out(test_text)
#        pprint(cut_data)
#        print text2

        self.failUnlessEqual(cut_data, ["{{ %i }}" % no for no in xrange(12)])
        self.failUnlessEqual(text2,
            "\n".join(["DjangoTag%iAssembly" % no for no in xrange(12)])
        )

        text = self.assembler.reassembly(text2, cut_data)
        self.failUnlessEqual(test_text, text)




if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
#    management.call_command('test', "pylucid.tests.test_i18n.TestI18n.test_page_without_lang", verbosity=2)
    management.call_command('test', __file__,
        verbosity=2,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = test_markups
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    TODO:
        * Test other markups than only creole ;)
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os


if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"


from pylucid_project.apps.pylucid.markup import MARKUP_CREOLE
from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageContent


class MarkupTestCase(basetest.BaseUnittest, basetest.MarkupTestHelper):
    def _pre_setup(self, *args, **kwargs):
        super(MarkupTestCase, self)._pre_setup(*args, **kwargs)

        self.page_content = PageContent.objects.all()[0]
        self.url = self.page_content.get_absolute_url()

    def _compare_content(self, markup_content, html):
        self.page_content.content = markup_content
        self.page_content.save()

        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=(html,),
            must_not_contain=("Traceback",)
        )


class PageContentCreoleMarkupTest(MarkupTestCase):
    def _pre_setup(self, *args, **kwargs):
        super(PageContentCreoleMarkupTest, self)._pre_setup(*args, **kwargs)
        self.page_content.markup = MARKUP_CREOLE
        self.page_content.save()

    def test_base(self):
        self._compare_content(
            markup_content=self._prepare_text("""
                //Hello **World**!//
                creole is cool!
            """),
            html=self._prepare_text("""
                <p><i>Hello <strong>World</strong>!</i><br />
                creole is cool!</p>
            """),
        )

    def test_image_link_without_title(self):
        self._compare_content(
            markup_content="foo {{/path/to/image.jpg}} bar",
            html='<p>foo <img src="/path/to/image.jpg" alt="/path/to/image.jpg" /> bar</p>',
        )
        
    def test_image_link_with_title(self):
        self._compare_content(
            markup_content="1 {{/path/to/image.jpg|image title}} one",
            html='<p>1 <img src="/path/to/image.jpg" alt="image title" /> one</p>'
        )
        
    def test_image_upcase_extension(self):
        self._compare_content(
            markup_content=self._prepare_text("""
                1 {{/path/to/image.PNG}} one
                2 {{IMAGE.GIF|test}} two
            """),
            html=self._prepare_text("""
                <p>1 <img src="/path/to/image.PNG" alt="/path/to/image.PNG" /> one<br />
                2 <img src="IMAGE.GIF" alt="test" /> two</p>                
            """)
        )
        
    def test_singleline_pre(self):
        self._compare_content(
            markup_content="one {{{ **two** }}} **tree**!",
            html="<p>one <tt> **two** </tt> <strong>tree</strong>!</p>",
        )

    def test_multiline_pre(self):
        self._compare_content(
            markup_content=self._prepare_text("""
                start paragraph
                {{{
                one
                two
                }}}
                the end...
            """),
            html=self._prepare_text("""
                <p>start paragraph</p>
                <pre>
                one
                two
                </pre>
                <p>the end...</p>
            """),
        )





if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
#    management.call_command('test', "pylucid.tests.test_i18n.TestI18n.test_page_without_lang", verbosity=2)
    management.call_command('test', __file__,
        verbosity=2,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = test_messages
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    import pylucid_project
    PYLUCID_BASE_PATH = os.path.abspath(os.path.dirname(pylucid_project.__file__))
    path = os.path.join(PYLUCID_BASE_PATH, "tests", "unittest_plugins")

    os.environ['PYLUCID_ADD_PLUGINS_PATH'] = path
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.http import HttpRequest
from django.contrib.auth.models import Group

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import Language
from pylucid_project.apps.pylucid.models import PageTree


class TestMessages(basetest.BaseUnittest):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    """
    def test_anonymous(self):
        self.login("superuser")
        response = self.client.get("/?unittest_plugin=MSG_ERROR")
#        response = self.client.get("/pylucid_admin/plugins/internals/show_internals/")
        self.assertResponse(response,
            must_contain=("<html", "A error messages"),
            must_not_contain=("Traceback",)
        )


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__

    management.call_command('test', tests,
        verbosity=2
    )

########NEW FILE########
__FILENAME__ = test_page_permissions
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - related test in pylucid_plugins/language/tests.py
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.http import HttpRequest
from django.contrib.auth.models import Group

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import Language
from pylucid_project.apps.pylucid.models import PageTree


class TestPagePermissions(basetest.BaseUnittest):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    """
    def _pre_setup(self, *args, **kwargs):
        super(TestPagePermissions, self)._pre_setup(*args, **kwargs)

        self.test_group = Group(name="test group")
        self.test_group.save()

    def _set_pagetree_permitViewGroup(self, url):
        """ set self.test_group top the PageTree object get from url """
        user = self._get_user("superuser")
        request = HttpRequest() # Create a fake request
        request.user = user
        (page_tree, _, _) = PageTree.objects.get_page_from_url(request, url)
        page_tree.permitViewGroup = self.test_group
        page_tree.save()

    def assertCanSee(self, response):
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - The buildin creole markup.</title>',
            ),
            must_not_contain=("Traceback",)
        )
        self.assertStatusCode(response, 200)

    def test_no_permitViewGroup(self):
        """
        request a page, that is public
        """
        test_url = "example-pages/markups/creole"
        test_page_url = "/en/%s/" % test_url
        response = self.client.get(test_page_url)
        self.assertCanSee(response)

    def test_pagetree_permitViewGroup_1(self):
        """
        set a permitViewGroup on the last pagetree.
        """
        test_url = "example-pages/markups/creole"
        test_page_url = "/en/%s/" % test_url
        self._set_pagetree_permitViewGroup(test_url)
        response = self.client.get(test_page_url)
        self.assertPyLucidPermissionDenied(response)


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
    management.call_command('test', __file__,
#        verbosity=1
        verbosity=0
    )

########NEW FILE########
__FILENAME__ = tree_model
# encoding: utf-8

"""
    PyLucid - Tree Model/Manager
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Generate a tree of the cms pages, who are orginised in a parent-model.
    usefull for the main menu and the sitemap.

    Based on code by Marc 'BlackJack' Rintsch
    see: http://www.python-forum.de/topic-10852.html (de)


    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate: 2008-11-13 12:53:39 +0100 (Do, 13 Nov 2008) $
    $Rev: 1792 $
    $Author: JensDiemer $

    :copyleft: 2007-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.db import models
from django.core.exceptions import ValidationError
from django.utils.translation import ugettext_lazy as _


class MenuNode(object):
    def __init__(self, id, data=None, parent=None):
        self.id = id
        self.data = data
        self.parent = parent
        self.subnodes = []
        self.active = False  # the complete path back to root
        self.current = False # current node in main menu?
        self.visible = True  # Seen in main menu?

        self.level = None # The level count, starts with 0
        self.first = False # Is the first node in the current level
        self.last = False # Is the last node in the current level

    def css_class(self):
        """
        returns a css class string, for: ... class="{{ node.css_class }}"
        So it's not needed to add a few {% if %} template statements. 
        """
        class_names = "level_%s" % self.level
        if self.active:
            class_names += " active"
        if self.current:
            class_names += " current"
        if self.first:
            class_names += " first"
        if self.last:
            class_names += " last"
        return class_names

    def add(self, node):
        """
        add a new sub node.
        """
        self.subnodes.append(node)
        node.parent = self

    def activate(self):
        """
        activate self + all sub nodes + the parent nodes
        """
        #print " *** activate: %r" % self
        self.visible = True
        self.active = True

        # Activate all subnodes:
        for subnode in self.subnodes:
            subnode.visible = True

        # activate the parent node
        if self.parent is not None:
            self.parent.activate()

    def get_absolute_url(self):
        """ absolute url *without* language code (without domain/host part) """
        data = self.data

        if self.parent:
            parent_shortcut = self.parent.get_absolute_url()
            return parent_shortcut + data["slug"] + "/"
        else:
            return "/" # root node

    def __repr__(self):
        if self.id == None:
            return "Root MenuNode object"
        return repr(self.data)





class TreeGenerator(object):
    def __init__(self, items, skip_no_parent=False):
        """
        Load the tree with all queryset items.
        Use skip_no_parent if the tree has "holes": e.g.: Filtered not accessible items.
        """
        self.related_objects = [] # List of added related objects

        # Create a dict with all pages as nodes
        self.nodes = dict((n["id"], MenuNode(n["id"], n))
                          for n in items)

        # Create the root node
        self.root = MenuNode(id=None)
        self.nodes[None] = self.root

        if items:
            # built the node tree
            for node_data in items:
                parent_id = node_data["parent"]
                try:
                    parent = self.nodes[parent_id]
                except KeyError:
                    if skip_no_parent == True:
                        # Skip item if parent does not exist.
                        continue
                    else:
                        raise

                parent.add(self.nodes[node_data["id"]])

            # add level number to all nodes and mark first/last nodes
            self.setup_nodes()

    def get_first_nodes(self, nodes=None):
        """ return a list of all 'top' nodes (all root subnodes) """
        return self.root.subnodes
        if nodes == None:
            nodes = self.root.subnodes

        for node in nodes:
            if node.visible:
                return nodes

        for node in nodes:
            if node.subnodes:
                nodes2 = self.get_first_nodes(node.subnodes)
                if nodes2:
                    return nodes2

    def setup_nodes(self, nodes=None, level=0):
        """ add level number to all nodes and mark first/last nodes """
        if nodes == None:
            nodes = self.root.subnodes

        nodes[0].first = True
        nodes[-1].last = True

        for node in nodes:
            node.level = level
            if node.subnodes:
                self.setup_nodes(node.subnodes, level + 1)

    def debug(self, nodes=None):
        def debug1(nodes):
            for node in nodes:
                indent = "   " * (node.level - 1)
                print indent, node.id, "v:", node.visible, node

                for related_object_name in self.related_objects:
                    if hasattr(node, related_object_name):
                        print indent, "   * %r: %r" % (related_object_name, getattr(node, related_object_name))

                if node.subnodes:
                    debug1(node.subnodes)

        def debug2(nodes):
            for node in nodes:
                if node.visible:
                    indent = "   " * (node.level - 1)
                    print indent, node.id, "a:", node.active, node
                if node.subnodes:
                    debug2(node.subnodes)

        if nodes == None:
            nodes = self.root.subnodes

        print "_" * 79
        print "Tree model debug:"
        debug1(nodes)
        print "-" * 79
        print "Only visible nodes:"
        debug2(nodes)
        print "-" * 79

    def add_related(self, queryset, ids, field, attrname):
        """ Attach related objects from a queryset """
        lookup_kwargs = {"%s__in" % field: ids}
        #print "lookup_kwargs:", lookup_kwargs
        related_objects = queryset.filter(**lookup_kwargs).select_related()
        #print "related objects:", related_objects

        # Attach objects to the related node
        for related_object in related_objects:
            parent_field = getattr(related_object, field)
            parent_id = parent_field.id
            parent_node = self.nodes[parent_id]
            setattr(parent_node, attrname, related_object)

        # append the attribute name into self.related_objects list
        self.related_objects.append(attrname)


    def add_missing_related_objects(self, queryset, attrname):
        """ Adding related object items, if not all attached. """
        # Generate a id list of all menu entries witch has no related object
        ids = [
            id for id, node in self.nodes.items()
            if node.visible and id != None and not hasattr(node, attrname)
        ]
        if not ids: # All menu items has related objects entries
            return None

        # Add all missing related object from given queryset
        self.add_related(queryset, ids, field="pagetree", attrname="pagemeta")
        return ids


    def add_pagemeta(self, request):
        """ add all PageMeta objects into tree """
        # import here -> import-loop
        from pylucid_project.apps.pylucid.models import PageMeta, Language

        current_lang = request.PYLUCID.current_language
        default_lang = Language.objects.get_or_create_default(request)

        # Generate a id list of all visible nodes 
        ids = [id for id, node in self.nodes.items() if node.visible and id != None]
        #print "Get pagemeta for: %r" % ids
        queryset = PageMeta.objects.filter(language=current_lang)

        # Add all pagemeta in current client language
        self.add_related(queryset, ids, field="pagetree", attrname="pagemeta")

        # Add all missing PageMeta in system default language
        queryset = PageMeta.objects.filter(language=default_lang)
        ids = self.add_missing_related_objects(queryset, attrname="pagemeta")
        #print "Missing PageMeta added: %r" % ids

        # Add at least all missing PageMeta, no matter what language
        if ids is not None: # Skip, if all PageMeta exist previously
            queryset = PageMeta.objects.all()
            self.add_missing_related_objects(queryset, attrname="pagemeta")


    def slice_menu(self, min, max, parent=None):
        """
        Slice the visible menu items.
        """
        #print "slice menu - min: %r - max: %r" % (min, max)
        def remove_max(max, parent):
            """ Remove subnodes, if there are too deep. """
            for node in parent.subnodes:
                if node.level >= max - 1:
                    node.subnodes = [] # remove subnodes
                elif node.subnodes:
                    remove_max(max, parent=node)

        if max > 0: # skip if max == 0
            remove_max(max, parent=self.root)

        def reassign_root(min, parent):
            """ Reassign the root node, for cut the menu tree start point. """
            for node in parent.subnodes:
                if node.active != True: # Walk only through active nodes
                    continue

                if node.level < min - 1:
                    self.root = node
                    if node.level <= min - 2:
                        # Found the needed menu start point.
                        return

                if node.subnodes: # go deeper to find the menu start point.
                    reassign_root(min, parent=node)

        if min > 1: # reassign menu start point only if needed
            reassign_root(min, parent=self.root)

#        self.debug()


    def set_current_node(self, id, delete_hidden=True):
        """
        setup all node visible item for main menu template. 
        """
        self.deactivate_all()
        nodes = self.nodes
        current_node = nodes[id]
        current_node.activate()
        current_node.current = True

        if delete_hidden:
            # Remove all not visible items, because they not needed anymore.
            def build_tree(nodes):
                new_node_list = []
                for node in nodes:
                    if node.visible:
                        new_node_list.append(node)
                        if node.subnodes:
                            node.subnodes = build_tree(node.subnodes)
                return new_node_list

            self.root.subnodes = build_tree(self.root.subnodes)

    def activate_all(self):
        """
        make all nodes visible (for a sitemap)
        """
        for node in self.nodes.itervalues():
            node.visible = True

    def deactivate_all(self):
        """
        makes all nodes invisible.
        """
        for node in self.nodes.itervalues():
            node.visible = False

    def iter_flat_list(self, nodes=None):
        """
        returns a flat list of all visible pages with the level info.
        """
        if nodes == None:
            nodes = self.root.subnodes

        for node in nodes:
            if node.visible:
                yield node
            if node.subnodes:
                for node in self.iter_flat_list(nodes=node.subnodes):
                    if node.visible:
                        yield node







class TreeManager(models.Manager):
    def get_tree(self):
        data = self.model.objects.all()
        tree = TreeGenerator(data)
        return tree

class BaseTreeModel(models.Model):
    """ Base tree model used in PyLucidAdminPage and PageTree """
    objects = TreeManager()

    parent = models.ForeignKey("self", null=True, blank=True, help_text="the higher-ranking father page")
    position = models.SmallIntegerField(default=0,
        help_text="ordering weight for sorting the pages in the menu.")

    def clean_fields(self, exclude):
        """
        check if parent is the same entry: child <-> parent loop
        """
        if "parent" not in exclude and self.parent is not None and self.pk == self.parent.pk:
            message_dict = {"parent": (_("child-parent loop error!"),)}
            raise ValidationError(message_dict)

    class Meta:
        abstract = True
        # FIXME: It would be great if we can order by get_absolute_url()
        ordering = ("id", "position")



########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

"""
    PyLucid app url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~

    ?P<url_lang_code> is in Accept-Language header format, from RFC 2616, section 14.4 and 3.9.
    See also:
        django.utils.translation.trans_real.accept_language_re

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""
from django.conf import settings
from django.conf.urls.defaults import patterns, url

from pylucid_project.apps.pylucid import views

urlpatterns = patterns('',
    url(r'^$', views.root_page, name='PyLucid-root_page'),

    url(r'^%s/(?P<page_id>\d+)?/(?P<url_rest>.*?)$' % settings.PYLUCID.PERMALINK_URL_PREFIX, views.permalink,
        name='PyLucid-permalink'
    ),

    url(r'^%s/(?P<filepath>[\w/\.-]{4,})$' % settings.PYLUCID.HEAD_FILES_URL_PREFIX, views.send_head_file,
        name='PyLucid-send_head_file'
    ),

    url(r'^(?P<url_lang_code>[A-Za-z]{1,8}(?:-[A-Za-z]{1,8})*)/$',
        views.lang_root_page, name='PyLucid-lang_root_page'
    ),

    url(r'^(?P<url_lang_code>[A-Za-z]{1,8}(?:-[A-Za-z]{1,8})*)/(?P<url_path>.+?)$',
        views.resolve_url, name='PyLucid-resolve_url'
    ),

    url(r'^(?P<url_path>.+?)/$',
        views.page_without_lang, name='PyLucid-page_without_lang'
    ),
)

########NEW FILE########
__FILENAME__ = views
# coding:utf-8

"""
    PyLucid
    ~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django import http
from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.template import loader, RequestContext
from django.utils.translation import ugettext as _
from django.views.decorators.csrf import csrf_view_exempt, csrf_exempt

from django_tools.template import render

from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid.models import PageTree, PageMeta, \
        PageContent, PluginPage, ColorScheme, EditableHtmlHeadFile, Language
from pylucid_project.apps.pylucid.signals import pre_render_global_template
from pylucid_project.apps.pylucid.system import pylucid_plugin, i18n
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS
from django.template.loader import render_to_string




#_____________________________________________________________________________
# helper functions

def _get_page_content(request):
    """
    Returns the PageContent instance for the current pagetree:
    Try in client favored language, if not exist...
    ...try in default language set in the system preferences, if not exist...
    ...raise http.Http404()
    """
    pagetree = request.PYLUCID.pagetree # current PageTree instance
    pagemeta = request.PYLUCID.pagemeta # current PageMeta instance

    # client favored Language instance:
    lang_entry = request.PYLUCID.current_language
    # default Language instance set in system preferences:
    default_lang_entry = Language.objects.get_or_create_default(request)

    try:
        pagecontent = PageContent.objects.get(pagemeta=pagemeta)
    except PageContent.DoesNotExist, err:
        raise http.Http404(
            "Page '%s' does not exist in default language '%s'.\n"
            "Original error was: %s" % (
                pagetree.slug, default_lang_entry.code, err
            )
        )

    return pagecontent


def _render_page(request, pagetree, url_lang_code, prefix_url=None, rest_url=None):
    """ render a cms page """
    request.PYLUCID.pagetree = pagetree

    is_plugin_page = pagetree.page_type == PageTree.PLUGIN_TYPE

    # Get the pagemeta instance for the current pagetree and language
    try:
        pagemeta = PageTree.objects.get_pagemeta(request, pagetree, show_lang_errors=True)
    except PageMeta.DoesNotExist, err:
        # Note: This should normaly never happen. Because all PageMeta must exist at least in system
        # default language. Also: The main_manu doesn't show links to not existing PageMeta entries!
        if settings.DEBUG or settings.PYLUCID.I18N_DEBUG:
            raise
            msg = (
                "PageMeta for %r doesn't exist in system default language: %r! Please create it!"
                " (Original error was: %r)"
            ) % (pagetree, Language.objects.get_or_create_default(request), err)
            messages.error(request, msg)
        else:
            msg = ""
        raise http.Http404("<h1>Page not found</h1><h2>%s</h2>" % msg)

    request.PYLUCID.pagemeta = pagemeta

    # Changeable by plugin/get view or will be removed with PageContent instance
    request.PYLUCID.updateinfo_object = pagemeta

    # object2comment - The Object used to attach a pylucid_comment
    # should be changed in plugins, e.g.: details views in blog, lexicon plugins
    request.PYLUCID.object2comment = pagemeta

    # Check the language code in the url, if exist
    if url_lang_code and (not is_plugin_page) and (url_lang_code.lower() != pagemeta.language.code.lower()):
        # The language code in the url is wrong. e.g.: The client followed a external url with was wrong.
        # Note: The main_manu doesn't show links to not existing PageMeta entries!

        # change only the lang code in the url:
        new_url = i18n.change_url(request, new_lang_code=pagemeta.language.code)

        if settings.DEBUG or settings.PYLUCID.I18N_DEBUG:
            messages.error(request,
                "Language code in url %r is wrong! Redirect to %r." % (url_lang_code, new_url)
            )
        # redirect the client to the right url
        return http.HttpResponsePermanentRedirect(new_url)

    # Create initial context object
    request.PYLUCID.context = context = RequestContext(request)

    # it will be filled either by plugin or by PageContent:
    context["page_content"] = None

    # call a pylucid plugin "html get view", if exist
    get_view_response = PYLUCID_PLUGINS.call_get_views(request)
    if isinstance(get_view_response, http.HttpResponse):
        # Plugin would be build the complete html page
        return get_view_response
    elif isinstance(get_view_response, basestring):
        # Plugin replace the page content
        context["page_content"] = get_view_response
    elif get_view_response is not None: # Use plugin response
        raise TypeError(
            "Plugin view must return None or basestring or HttpResponse! (returned: %r)"
        ) % type(get_view_response)


    # call page plugin, if current page is a plugin page and no get view has filled the page content
    page_plugin_response = None
    if is_plugin_page and context["page_content"] is None:
        # Add to global pylucid objects. Use e.g. in admin_menu plugin
        pluginpage = PluginPage.objects.get(pagetree=pagetree)
        request.PYLUCID.pluginpage = pluginpage

        page_plugin_response = pylucid_plugin.call_plugin(request, url_lang_code, prefix_url, rest_url)
        if isinstance(page_plugin_response, http.HttpResponse):
            # Plugin would be build the complete html page
            return page_plugin_response
        elif isinstance(page_plugin_response, basestring):
            # Plugin replace the page content
            context["page_content"] = page_plugin_response
        elif page_plugin_response is not None: # Use plugin response
            raise TypeError(
                "Plugin view must return None or basestring or HttpResponse! (returned: %r)"
            ) % type(page_plugin_response)


    if context["page_content"] is None:
        # Plugin has not filled the page content
        pagecontent_instance = _get_page_content(request)
        request.PYLUCID.pagecontent = request.PYLUCID.updateinfo_object = pagecontent_instance
        context["page_content"] = apply_markup(
            pagecontent_instance.content, pagecontent_instance.markup, request
        )

    # put update information into context
    for itemname in ("createby", "lastupdateby", "createtime", "lastupdatetime"):
        context["page_%s" % itemname] = getattr(request.PYLUCID.updateinfo_object, itemname, None)

    # Render django tags in PageContent with the global context
    context["page_content"] = render.render_string_template(context["page_content"], context)

    template_name = context["template_name"] # Added in pylucid.context_processors
    page_template= loader.get_template(template_name)
    pre_render_global_template.send(sender=None, request=request, page_template=page_template)

    # Render django tags in global template with global context
    complete_page = page_template.render(context)

    # create response object
    response = http.HttpResponse(complete_page, mimetype="text/html")
    response["content-language"] = context["page_language"]

    return response








#_____________________________________________________________________________
# view functions

def send_head_file(request, filepath):
    """
    Sending a headfile
    only a fall-back method if the file can't be stored into the media path
    """
    colorscheme = None
    if "ColorScheme" in request.GET:
        raw_colorscheme_id = request.GET["ColorScheme"]
        try:
            colorscheme_id = int(raw_colorscheme_id)
        except ValueError:
            if settings.DEBUG:
                raise
            return http.HttpResponseBadRequest()

        try:
            colorscheme = ColorScheme.objects.get(pk=colorscheme_id)
        except ColorScheme.DoesNotExist:
            if settings.DEBUG:
                msg = "ColorScheme %r not found!" % colorscheme_id
            else:
                msg = ""
            raise http.Http404(msg)

    try:
        headfile = EditableHtmlHeadFile.objects.get(filepath=filepath)
    except EditableHtmlHeadFile.DoesNotExist:
        if settings.DEBUG:
            msg = "Headfile %r not found!" % filepath
        else:
            msg = ""
        raise http.Http404(msg)

    if headfile.render and colorscheme is not None:
        content = headfile.get_rendered(colorscheme)
    else:
        content = headfile.content

    mimetype = headfile.mimetype
    return http.HttpResponse(content, mimetype=mimetype)



def _prepage_request(request, lang_entry):
    """
    shared function for serval views.
    *
    """
    # setup i18n language settings
    i18n.setup_language(request, lang_entry)

#_____________________________________________________________________________
# root_page + lang_root_page views:

def _get_root_page(request):
    user = request.user
    try:
        pagetree = PageTree.objects.get_root_page(user) # Get the first PageTree entry
    except PageTree.DoesNotExist, err:
        msg = _(
            "There exist no pages!"
            " Have you load the initial pylucid.json data file?"
            " At least there must exists one page!"
            " (original error was: %s)"
        ) % err
        raise http.Http404(msg)
    return pagetree


@csrf_view_exempt
def root_page(request):
    """
    redirect to a url with language code
    We can't serve the root page here, because it will be cached in current
    language with "/" as key. So a other client with other language will see
    the page always in the cached language and not in his preferred language
    """
    # activate language via auto detection
    i18n.activate_auto_language(request)

    pagetree = _get_root_page(request)

    pagemeta = PageTree.objects.get_pagemeta(request, pagetree, show_lang_errors=False)
    url = pagemeta.get_absolute_url()

    return http.HttpResponseRedirect(url)


def _lang_code_is_pagetree(request, url_lang_code):
    """
    return True, if language code...
        ... is not in settings.LANGUAGES
    and
        ... is a pagetree slug
    """
    if Language.objects.is_language_code(url_lang_code) == True:
        # It's a valid language code
        return False

    # Check if url language code is a pagetree slug
    exist = PageTree.on_site.filter(slug=url_lang_code).count()
    if exist > 0:
        return True

    return False


@csrf_view_exempt
def lang_root_page(request, url_lang_code):
    """ url with lang code but no page slug """

    if _lang_code_is_pagetree(request, url_lang_code):
        # The url doesn't contain a language code, it's a pagetree slug
        return _i18n_redirect(request, url_path=url_lang_code)

    # activate i18n
    i18n.activate_auto_language(request)

    pagetree = _get_root_page(request)

    return _render_page(request, pagetree, url_lang_code)

#-----------------------------------------------------------------------------

def _i18n_redirect(request, url_path):
    """ Redirect to a url with the default language code. """
    # activate language via auto detection
    i18n.activate_auto_language(request)

    # Check only, if url_path is right (if there exist a pagetree object)
    # otherwise -> 404 would be raised
    _get_pagetree(request, url_path)

    lang_code = request.LANGUAGE_CODE
    url = reverse('PyLucid-resolve_url', kwargs={'url_lang_code': lang_code, 'url_path': url_path})

    if not url.endswith("/"):
        url += "/"

    if request.GET:
        # Add GET query string
        # We don't use request.GET.urlencode() here, because it can change the key positions
        full_path = request.get_full_path()
        get_string = full_path.split("?", 1)[1]
        url += "?" + get_string

    # redirect to url with lang_code
    return http.HttpResponseRedirect(url)


def _get_pagetree(request, url_path):
    try:
        return PageTree.objects.get_page_from_url(request, url_path)
    except PageTree.DoesNotExist, err:
        msg = _("Page not found")
        if settings.DEBUG or request.user.is_staff:
            msg += " url path: %r (%s)" % (url_path, err)
        raise http.Http404(msg)


# We must exempt csrf test here, but we use csrf_protect() later in:
# pylucid_project.apps.pylucid.system.pylucid_plugin.call_plugin()
# pylucid_project.system.pylucid_plugins.PyLucidPlugin.call_plugin_view()
# see also: https://docs.djangoproject.com/en/dev/ref/contrib/csrf/#view-needs-protection-for-one-path
@csrf_view_exempt
def resolve_url(request, url_lang_code, url_path):
    """ url with lang_code and sub page path """
    if _lang_code_is_pagetree(request, url_lang_code):
        # url_lang_code doesn't contain a language code, it's a pagetree slug
        new_url = "%s/%s" % (url_lang_code, url_path)
        return _i18n_redirect(request, url_path=new_url)

    # activate language via auto detection
    i18n.activate_auto_language(request)

    pagetree, prefix_url, rest_url = _get_pagetree(request, url_path)

    return _render_page(request, pagetree, url_lang_code, prefix_url, rest_url)


def page_without_lang(request, url_path):
    """
    url with sub page path, but without a lang_code part
    We redirect to a url with language code.
    """
    # redirect to a url with the default language code.
    return _i18n_redirect(request, url_path)


@csrf_exempt
def permalink(request, page_id, url_rest=""):
    """ resolve a permalink and redirect to the real url. """
    # activate language via auto detection
    i18n.activate_auto_language(request)

    try:
        pagetree = PageTree.on_site.get(id=page_id)
    except PageTree.DoesNotExist, err:
        # TODO: Try to search with the additional url data (url_rest)
        msg = "Page not found"
        if settings.DEBUG:
            msg += " PageTree ID: %r (%s)" % (page_id, err)
        raise http.Http404(msg)

    pagemeta = PageTree.objects.get_pagemeta(request, pagetree, show_lang_errors=False)

    url = pagemeta.get_absolute_url()

    if pagetree.page_type == pagetree.PLUGIN_TYPE and url_rest and "/" in url_rest:
        # pass a permalink additional to the plugin, e.g.: blog entry detail view
        additional_url = url_rest.split("/", 1)[1]
        url += additional_url

    return http.HttpResponseRedirect(url)





########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

from django.conf import settings
from django.contrib import admin
from django.contrib.auth.models import Permission
from django.contrib.contenttypes.models import ContentType
from django.core import serializers
from django.http import HttpResponse
from django.shortcuts import render_to_response

from reversion.admin import VersionAdmin

from pylucid_project.apps.pylucid_admin import models


#-----------------------------------------------------------------------------
# some django admin stuff is broken if TEMPLATE_STRING_IF_INVALID != ""
# http://code.djangoproject.com/ticket/3579

if settings.TEMPLATE_STRING_IF_INVALID != "":
    # Patch the render_to_response function ;)
    from django.contrib.auth import admin as auth_admin
    from django.contrib.admin import options

    def patched_render_to_response(*args, **kwargs):
        old = settings.TEMPLATE_STRING_IF_INVALID
        settings.TEMPLATE_STRING_IF_INVALID = ""
        result = render_to_response(*args, **kwargs)
        settings.TEMPLATE_STRING_IF_INVALID = old
        return result

    options.render_to_response = patched_render_to_response
    auth_admin.render_to_response = patched_render_to_response


#-----------------------------------------------------------------------------


def export_as_json(modeladmin, request, queryset):
    """
    from:
    http://docs.djangoproject.com/en/dev/ref/contrib/admin/actions/#actions-that-provide-intermediate-pages
    """
    response = HttpResponse(mimetype="text/javascript")
    serializers.serialize("json", queryset, stream=response, indent=4)
    return response

# Make export actions available site-wide
admin.site.add_action(export_as_json, 'export_selected_as_json')


#-----------------------------------------------------------------------------


if settings.DEBUG:
    class PermissionAdmin(admin.ModelAdmin):
        """ django auth Permission """
        list_display = ("id", "name", "content_type", "codename")
        list_display_links = ("name", "codename")
        list_filter = ("content_type",)
    admin.site.register(Permission, PermissionAdmin)

    class ContentTypeAdmin(admin.ModelAdmin):
        """ django ContentType """
        list_display = list_display_links = ("id", "app_label", "name", "model")
        list_filter = ("app_label",)
    admin.site.register(ContentType, ContentTypeAdmin)

    #-----------------------------------------------------------------------------

    from reversion.models import Revision, Version

    class RevisionAdmin(admin.ModelAdmin):
        list_display = ("id", "date_created", "user", "comment")
        list_display_links = ("date_created",)
        date_hierarchy = 'date_created'
        ordering = ('-date_created',)
        list_filter = ("user", "comment")
        search_fields = ("user", "comment")

    admin.site.register(Revision, RevisionAdmin)


    class VersionAdmin(admin.ModelAdmin):
        list_display = ("object_repr", "revision", "object_id", "content_type", "format",)
        list_display_links = ("object_repr", "object_id")
        list_filter = ("content_type", "format")
        search_fields = ("object_repr", "serialized_data")

    admin.site.register(Version, VersionAdmin)

    #-----------------------------------------------------------------------------

    class PyLucidAdminPageAdmin(VersionAdmin):
        list_display = (
            "id", "name", "get_absolute_url",
            "superuser_only", "must_staff", "permissions",
            "get_pagetree", "get_pagemeta", "get_page",
        )
        list_display_links = ("name",)
        list_filter = ("createby", "lastupdateby",)
        date_hierarchy = 'lastupdatetime'
        search_fields = ("name", "title", "url_name")

        def superuser_only(self, obj):
            access_permissions = obj.get_permissions()
            superuser_only, permissions, must_staff = access_permissions
            return superuser_only
        superuser_only.boolean = True

        def must_staff(self, obj):
            access_permissions = obj.get_permissions()
            superuser_only, permissions, must_staff = access_permissions
            return must_staff
        must_staff.boolean = True

        def permissions(self, obj):
            access_permissions = obj.get_permissions()
            superuser_only, permissions, must_staff = access_permissions
            return "<br />".join(permissions)
        permissions.allow_tags = True

    admin.site.register(models.PyLucidAdminPage, PyLucidAdminPageAdmin)

########NEW FILE########
__FILENAME__ = admin_menu
# coding:utf-8

from django.core import urlresolvers

from pylucid_project.apps.pylucid_admin.models import PyLucidAdminPage

ADMIN_SECTIONS = {
    "create content": "Create new content."
}


class AdminMenu(object):
    """
    TODO: The section should display a page with a "sub menu" of all sub sections.
    """
    def __init__(self, request, output):
        self.request = request
        self.output = output

#        sys_preferences = request.PYLUCID.preferences
#        admin_design_id = sys_preferences["pylucid_admin_design"]
#        self.admin_design = Design.objects.get(id=admin_design_id)

    def add_menu_entry(self, name, title, parent, url_name=None, **extra):
        if url_name: # verify the url
            url = urlresolvers.reverse(viewname=url_name)

        defaults = {"title": title, "parent": parent, "url_name": url_name}
        defaults.update(extra)
        adminpage_entry, created = PyLucidAdminPage.objects.get_or_create(
            name=name, defaults=defaults
        )
        if created:
            self.output.append("PyLucidAdminPage %r created." % adminpage_entry)
        else:
            self.output.append("PyLucidAdminPage %r exist." % adminpage_entry)

        return adminpage_entry

    def get_or_create_section(self, section_name):
        title = ADMIN_SECTIONS.get(section_name, section_name)
        return self.add_menu_entry(section_name, title, parent=None, url_name=None)


########NEW FILE########
__FILENAME__ = app_settings
# coding: utf-8
"""
    PyLucid Admin App. settings
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    settings witch only used in the PyLucid Admin
"""

URL_FILENAME = "admin_urls.py"

VIEW_FILENAME = "admin_views"

PLUGIN_INSTALL_VIEW_NAME = "install"

# The PyLucid admin user group:
#PYLUCID_ADMIN_GROUP = "PyLucid Admin"
USER_GROUP = "PyLucid Admin"

# The design name for the PyLucid admin section:
DESIGN_NAME = "PyLucid Admin"

########NEW FILE########
__FILENAME__ = create_initialdata
# coding:utf-8
"""
    Create serialized fixture data file for PyLucid initial data.
    
    The order of APP_MODEL_DATA is very important!
    The serialized data must be sorted by topology. 
    Otherwise the dump can't insert back into the database.
    
    TODO: add FIXTURE_FILENAME and FIXTURE_PATH to BaseCommand.option_list
"""
import os
import codecs
import pprint
from optparse import make_option

from django.conf import settings
from django.core import serializers
from django.db.models import get_model
from django.db.models.loading import get_apps, get_models
from django.core.management.base import BaseCommand, CommandError

from pylucid_project.apps.pylucid.tree_model import TreeGenerator



# IMPORANT: ordered by topology!
APP_MODEL_DATA = [
     #['auth', ('Permission', 'Group', 'User', 'Message')],
     #['contenttypes', ('ContentType',)],
     #['sessions', ('Session',)],
     ['sites', ('Site',)],
     #['admin', ('LogEntry',)],
     #['comments', ('Comment', 'CommentFlag')],
     ['pylucid', (
          'Language',
          'ColorScheme', 'Color', 'EditableHtmlHeadFile', 'Design',
          'PageTree', 'PageMeta', 'PageContent', 'PluginPage',
           #'LogEntry',
           #'BanEntry',
           #'UserProfile'
     )],
     #['pylucid_admin', ('PyLucidAdminPage',)],
     #['dbpreferences', ('Preference', 'UserSettings')],
     ['dbtemplates', ('Template',)],
     #['reversion', ('Revision', 'Version')],
     #['tagging', ('Tag', 'TaggedItem')],
     #['redirect', ('RedirectModel',)],
     ['lexicon', ('LexiconEntry',)],
     #['blog', ('BlogEntry',)],
     #['update_journal', ('UpdateJournal', 'PageUpdateListObjects')],
     #['pylucid_comments', ('PyLucidComment',)]
]

FIXTURE_FILENAME = "pylucid.json"

FIXTURE_PATH = os.path.join(settings.PYLUCID_BASE_PATH, "apps", "pylucid_admin", "fixtures")



def get_pagetree_objects(model):
    """
    The PageTree entries must be serialized in the right order. Because they
    have references to him self.
    """
    queryset = model._default_manager.all().order_by("position")
    items = queryset.values("id", "parent")
    tree = TreeGenerator(items, skip_no_parent=True)

    objects = []
    for node in tree.iter_flat_list():
        objects.append(model._default_manager.all().get(id=node.id))

    return objects



class Command(BaseCommand):
    option_list = BaseCommand.option_list + (
        make_option('--list_models', action='store_true',
            help='List all installed models.'),
        make_option('--test', action='store_true',
            help='Test existing PyLucid initial data fixtures.'),

        make_option('--indent', default=4, dest='indent', type='int',
            help='Specifies the indent level to use when pretty-printing output'),
        make_option('-e', '--exclude', default=[], dest='exclude', action='append',
            help='Exclude appname or appname.Model (you can use multiple --exclude)'),
    )

    help = 'Output the contents of the database as a fixture of the given format.'
    args = '[appname ...]'

    def handle(self, *app_labels, **options):
        if options.get("list_models", False):
            print "List all installed models:"
            data = []
            for app in get_apps():
                app_name = app.__name__.split('.')[-2] # assuming -1 is 'models' and -2 is name
                models = tuple([model.__name__ for model in get_models(app)])
                if models:
                    data.append([app_name, models])
            pprint.pprint(data)
            return

        file_path = os.path.join(FIXTURE_PATH, FIXTURE_FILENAME)

        if options.get("test", False):
            if not os.path.isfile(file_path):
                print "fixture file not exist: %r" % file_path
                return

            from django.utils import simplejson
            f = codecs.open(file_path, "r", encoding="utf-8")
            data = simplejson.load(f)
            f.close()
            print "loaded %s entries from %s" % (len(data), file_path)
            return

        json_serializer = serializers.get_serializer("json")()

        objects = []
        for app_name, model_names in APP_MODEL_DATA:
            print "App: %r" % app_name
            for model_name in model_names:
                print "\tModel: %r" % model_name
                model = get_model(app_name, model_name)

                if model_name == "PageTree":
                    # Get the PageTree objects ordered by topology!
                    data = get_pagetree_objects(model)
                else:
                    data = model._default_manager.all()

                objects.extend(data)

            print " -" * 39

        if not os.path.isdir(FIXTURE_PATH):
            print "Create dir %r" % FIXTURE_PATH
            os.makedirs(FIXTURE_PATH)

        print "Serialize data and save it into %r..." % FIXTURE_FILENAME
        try:
            with codecs.open(file_path, "w", encoding="utf-8") as out:
                json_serializer.serialize(objects, indent=options['indent'], stream=out,
                    ensure_ascii=False # http://docs.djangoproject.com/en/dev/topics/serialization/#notes-for-specific-serialization-formats
                )
        except Exception, e:
            if options['traceback']:
                raise
            raise CommandError("Unable to serialize database: %s" % e)
        else:
            print "Fixtures written in %r" % file_path


########NEW FILE########
__FILENAME__ = create_instance
# coding:utf-8
"""
    PyLucid managment command
    ~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Create a PyLucid page instance.
    

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from optparse import make_option
import codecs
import os
import shutil

from django.contrib import admin
from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
import random


ENV_PATH_PLACEHOLDER = '"/please/insert/path/to/PyLucid_env/'


class Command(BaseCommand):
    verbosity = True

    help = (
        "Create a PyLucid page instance\n"
        "destination should be the absolute path for the new page instance."
    )
    args = 'destination'

    option_list = BaseCommand.option_list

    def _set_file_rights(self, *files):
        if self.verbosity:
                self.stdout.write("\n")
        for filename in files:
            filepath = os.path.join(self.destination, filename)
            assert os.path.isfile(filepath)
            if self.verbosity:
                self.stdout.write("set chmod 0755 to: %r\n" % filepath)
            os.chmod(filepath, 0755)
        if self.verbosity:
                self.stdout.write("\n")

    def _verbose_copy(self, src, dst):
        if self.verbosity:
            self.stdout.write("\ncopy: %r\nto: %r\n" % (src, dst))
        shutil.copy2(src, dst)

    def _setup_media(self, function, src, dst):
        if self.verbosity:
            self.stdout.write("\nsrc: %r\ndst: %r\n" % (src, dst))
            self.stdout.flush()
        try:
            function(src, dst)
        except Exception, err:
            self.stderr.write(self.style.ERROR("Error: %s\n" % err))
        else:
            if self.verbosity:
                self.stdout.write("OK\n")

    def _copy_scripts(self, filepath, rel_destination):
        source_path = os.path.join(settings.PYLUCID_BASE_PATH, "../scripts", filepath)
        source_path = os.path.normpath(source_path)
        dst = os.path.join(self.destination, rel_destination)
        self._verbose_copy(source_path, dst)

    def _patch_file(self, filename, patch_data):
        self.stdout.write("\npatch file: %r\n" % filename)
        filepath = os.path.join(self.destination, filename)
        f = codecs.open(filepath, "r", encoding="utf-8")
        content = f.read()
        f.close()

        for placeholder, new_value in patch_data:
            if not placeholder in content:
                self.stderr.write(self.style.ERROR(
                    "Can't patch file %r!\n(String %r not found!)\n" % (filepath, placeholder)
                ))
            else:
                content = content.replace(placeholder, new_value)

        f = codecs.open(filepath, "w", encoding="utf-8")
        f.write(content)
        f.close()
        if self.verbosity:
            self.stdout.write("Update env path in %r\n" % filepath)

    def _patch_env_path(self, *files):
        if self.verbosity:
                self.stdout.write("\n")
        for filename in files:
            self._patch_file(filename,
                patch_data=[(ENV_PATH_PLACEHOLDER, '"%s/' % self.virtual_env_path)]
            )
        if self.verbosity:
                self.stdout.write("\n")

    def handle(self, *args, **options):
        self.verbosity = int(options.get('verbosity', 1))

        if len(args) != 1:
            raise CommandError("missing destination path argument!")

        self.destination = os.path.abspath(args[0])
        self.destination = os.path.normpath(self.destination)

        self.stdout.write("\n\n")
        self.stdout.write("_" * 80)
        self.stdout.write("\n")
        self.stderr.write(self.style.SQL_FIELD("Create a PyLucid page instance"))
        self.stdout.write("\n\n")

        self.stdout.write("source..........: %s\n" % settings.PYLUCID_BASE_PATH)
        self.stdout.write("destination.....: %s\n" % self.style.HTTP_INFO(self.destination))

        self.virtual_env_path = os.path.normpath(os.environ["VIRTUAL_ENV"])
        self.stdout.write("env path........: %s\n" % self.virtual_env_path)

        self.stdout.write("\n")

        if os.path.exists(self.destination):
            self.stderr.write(self.style.NOTICE("destination %r exist! Continue (y/n) ?" % self.destination))
            input = raw_input()
            if input.lower() not in ("y", "j"):
                self.stderr.write("Abort.\n")
                return
        else:
            self.stderr.write(self.style.SQL_COLTYPE("Is destination path ok (y/n) ?"))
            input = raw_input()
            if input.lower() not in ("y", "j"):
                self.stderr.write("Abort.\n")
                return

            if self.verbosity:
                self.stdout.write("create %r\n" % self.destination)
            os.makedirs(self.destination)


        self._copy_scripts("manage.py", "manage.py")
        self._copy_scripts("apache_files/default.htaccess", ".htaccess")
        self._copy_scripts("apache_files/index.fcgi", "index.fcgi")
        self._copy_scripts("apache_files/index.wsgi", "index.wsgi")
        self._copy_scripts("apache_files/index.cgi", "index.cgi")
        self._copy_scripts("apache_files/index.html", "index.html")
        self._copy_scripts("local_settings_example.py", "local_settings.py")


        self.stdout.write("\n")
        self.stdout.write(" -" * 39)
        self.stdout.write("\n")


        # Set path to PyLucid_env in file content:
        self._patch_env_path("manage.py", "index.fcgi", "index.wsgi", "index.cgi")

        # Set chmod 0755 to files:
        self._set_file_rights("manage.py", "index.fcgi", "index.wsgi", "index.cgi")

        django_admin_path = os.path.abspath(os.path.dirname(admin.__file__))
        django_media_src = os.path.join(django_admin_path, "media")
        pylucid_media_src = os.path.join(settings.PYLUCID_BASE_PATH, "media", "PyLucid")
        static_dest = os.path.join(self.destination, "static")
        media_dest = os.path.join(self.destination, "media")

        secret_key = ''.join(
            [random.choice('abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)') for i in xrange(50)]
        )

        patch_data = [
            (
                'STATIC_ROOT = "/var/www/YourSite/static/"',
                'STATIC_ROOT = "%s"' % static_dest
            ),
            (
                'MEDIA_ROOT = "/var/www/YourSite/media/"',
                'MEDIA_ROOT = "%s"' % media_dest
            ),
            (
                'SECRET_KEY = "add-a-secret-key"',
                'SECRET_KEY = "%s"' % secret_key
            ),
        ]

        self._patch_file("local_settings.py", patch_data)

        self.stdout.write("\n")
        self.stdout.write(" -" * 39)
        self.stdout.write("\n")

        self.create_dir("static files directory", static_dest)
        self.create_dir("media files directory", media_dest)

        self.stdout.write("\n")
        self.stdout.write(" -" * 39)
        self.stdout.write("\n")

        self.stdout.write("\nPyLucid page instance created in:\n\t%s\n" % self.destination)
        self.stdout.write("\nPlease edit the files for your needs ;)\n")
        self.stdout.write("\nInstruction for next Step can you find here:\n")
        self.stdout.write("http://www.pylucid.org/permalink/356/create-database-tables-and-insert-initial-data")

    def create_dir(self, info, path):
        self.stdout.write("%s...: %s\n" % (info, path))

        if os.path.exists(path):
            if self.verbosity:
                self.stdout.write(self.style.SQL_COLTYPE("\ndestination %r exist.\n" % path))
        else:
            os.makedirs(path)
            if self.verbosity:
                self.stdout.write(self.style.SQL_COLTYPE("\ndestination %r created.\n" % path))

########NEW FILE########
__FILENAME__ = L10n
# coding: utf-8

"""
    PyLucid managment command
    ~~~~~~~~~~~~~~~~~~~~~~~~~
    
    make-/compile-messages for pylucid apps
    
    see also: http://www.pylucid.org/permalink/314/how-to-localize-pylucid
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import sys
import traceback
from optparse import make_option

from django.conf import settings
from django.core.management.base import BaseCommand, CommandError
from django.core.management.commands.compilemessages import compile_messages
from django.core.management.commands.makemessages import make_messages
from django.utils.importlib import import_module


OWN_PROJECTS = (
    "pylucid_project",
    "django_processinfo",
    "dbpreferences",
)
MAKE_MESSAGES = "make"
COMPILE_MESSAGES = "compile"


class Command(BaseCommand):
    option_list = BaseCommand.option_list + (
        make_option('--locale', '-l', default=None, dest='locale',
            help='Creates or updates the message files for the given locale (e.g. pt_BR) or for all.'),
    )
    help = (
        'Creates (or updates) .po messages'
        ' or compiles .po files to .mo files'
        ' for use with builtin gettext support.'
    )
    args = "%s/%s [app_name-1, app_name-2 ... app_name-n]" % (MAKE_MESSAGES, COMPILE_MESSAGES)



    requires_model_validation = False
    can_import_settings = False

    def _pylucid_app_names(self):
        def is_own_project(app_name):
            for own_project in OWN_PROJECTS:
                if own_project in app_name:
                    return True
            return False

        app_names = [n for n in settings.INSTALLED_APPS if is_own_project(n)]
        return app_names

    def handle(self, *args, **options):
        self.verbosity = int(options.get('verbosity'))
        locale = options.get('locale')
        if locale is None:
            process_all = True
        else:
            process_all = False

        if len(args) == 0:
            raise CommandError("missing '%s' or '%s' argument!" % (MAKE_MESSAGES, COMPILE_MESSAGES))

        cmd_type = args[0]
        if cmd_type not in (MAKE_MESSAGES, COMPILE_MESSAGES):
            raise CommandError("First argument must be '%s' or '%s' !" % (MAKE_MESSAGES, COMPILE_MESSAGES))

        pylucid_app_names = self._pylucid_app_names()

        if len(args) > 1:
            only_apps = args[1:]
            sys.stdout.write("%s only the apps: %s" % (cmd_type, repr(only_apps)))

            app_names = []
            for app_name in only_apps:
                if app_name in pylucid_app_names:
                    app_names.append(app_name)
                else:
                    app_name = ".%s" % app_name
                    full_app_name = None
                    for app_name2 in pylucid_app_names:
                        if app_name2.endswith(app_name):
                            full_app_name = app_name2
                            break
                    if full_app_name is None:
                        sys.stderr.write("App with name %r is unknown or not a PyLucid app!" % app_name)
                    else:
                        app_names.append(full_app_name)
            if not app_names:
                raise CommandError("No valid PyLucid apps found!")
        else:
            app_names = pylucid_app_names

        for app_name in app_names:
            print "_"*79
            print "%s: %s" % (cmd_type, app_name)
            app_module = import_module(app_name)
            app_path = os.path.dirname(app_module.__file__)

            os.chdir(app_path)

            if cmd_type == COMPILE_MESSAGES:
                try:
                    compile_messages(self.stderr)
                except Exception:
                    print traceback.format_exc()
            elif cmd_type == MAKE_MESSAGES:
                try:
                    make_messages(
                        locale=locale,
                        domain="django",
                        verbosity=self.verbosity,
                        all=process_all,
                        extensions=[".html", ],
                        symlinks=True,
                        ignore_patterns=['CVS', '.*', '*~'],
                        no_wrap=False,
                        no_obsolete=True,
                    )
                except Exception:
                    print traceback.format_exc()
            else:
                raise


########NEW FILE########
__FILENAME__ = models
# coding:utf-8

"""
    PyLucid admin menu models
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.models import User, Group, Permission
from django.contrib.contenttypes.models import ContentType
from django.core import urlresolvers
from django.core.cache import cache
from django.core.exceptions import ValidationError
from django.db import models
from django.utils.translation import ugettext as _

from django_tools.middlewares import ThreadLocal
from django_tools.models import UpdateInfoBaseModel
from django_tools.utils.messages import failsafe_message

from pylucid_project.apps.pylucid.tree_model import BaseTreeModel, TreeManager, TreeGenerator


class PyLucidAdminManager(TreeManager):
    def get_tree_for_user(self, user):
        filtered_items = self.get_for_user(user)
        tree = TreeGenerator(filtered_items)
        #tree.debug()

        # Hide categories, if they has no sub entry links
        # (e.g. user has no right to use any sub entry views)        
        for node in tree.iter_flat_list():
            if not node.data["absolute_url"] and not node.subnodes:
                node.visible = False

        return tree

    def get_for_user(self, user):
        """
        returns only the menu items, for which the user has the rights.
        """
        all_items = self.all().order_by("position", "name")
        filtered_items = []
        for item in all_items:
            access_permissions = item.get_permissions()
            superuser_only, permissions, must_staff = access_permissions

            if superuser_only == True and user.is_superuser != True:
                continue
            if must_staff == True and user.is_staff != True:
                continue
            if not user.has_perms(permissions):
                continue

            filtered_items.append({
                "id": item.id,
                "parent": getattr(item.parent, "id", None),
                "absolute_url": item.get_absolute_url(),
                "name": item.name,
                "title": item.title,
            })

        return filtered_items

class PyLucidAdminPage(BaseTreeModel, UpdateInfoBaseModel):
    """
    PyLucid Admin page tree
    
    inherited attributes from TreeBaseModel:
        parent
        position

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = PyLucidAdminManager()

    #TODO: check if url_name is unique. We can't set unique==True,
    #      because menu section has always url_name=None
    url_name = models.CharField(blank=True, null=True, max_length=256,
        help_text="Name of url, defined in plugin/admin_urls.py"
    )

    name = models.CharField(max_length=150, unique=True,
        help_text="Sort page name (for link text in e.g. menu)"
    )
    title = models.CharField(blank=True, null=False, max_length=256,
        help_text="A long page title (for e.g. page title or link title text)"
    )

    get_pagetree = models.BooleanField(default=False,
        verbose_name="get PageTree",
        help_text="Add current PageTree ID via GET Parameter to the url, if available"
    )
    get_pagemeta = models.BooleanField(default=False,
        verbose_name="get PageMeta",
        help_text="Add current PageMeta ID via GET Parameter to the url, if available"
    )
    get_page = models.BooleanField(default=False,
        verbose_name="get PageContent/PluginPage",
        help_text="Add current PageContent or current PluginPage ID via GET Parameter to the url, if available"
    )

    def clean_fields(self, exclude):
        # check if parent is the same entry: child <-> parent loop:
        super(PyLucidAdminPage, self).clean_fields(exclude)

        # check if url_name is unique. We can't set unique==True,
        # because menu section has always url_name=None
        if "url_name" not in exclude and self.url_name is not None:
            queryset = PyLucidAdminPage.objects.filter(url_name=self.url_name)

            # Exclude the current object from the query if we are editing an
            # instance (as opposed to creating a new one)
            if self.pk is not None:
                queryset = queryset.exclude(pk=self.pk)

            exists = queryset.count()
            if exists:
                msg = "url name %r exist!" % self.url_name
                message_dict = {"url_name": (msg,)}
                raise ValidationError(message_dict)

    def get_url(self):
        """
        reverse the url name.
        
        Create error message if NoReverseMatch and return None.
        e.g.: Plugin deleted in filesystem, but still exist in database.
        
        FIXME: Can we get it faster and not with resolve the url?
        """
        try:
            url = urlresolvers.reverse(self.url_name)
        except urlresolvers.NoReverseMatch, err:
            msg = (
                "Can't resolve url %r for plugin %r: %s"
                " - (To fix this: run 'install plugins' again.)"
            ) % (self.url_name, self.name, err)
            failsafe_message(msg)
        else:
            return url

    def get_permissions(self):
        """
        returns the access permissions for this menu entry.
        TODO: Should be cache this?
        """
        if not self.url_name: # a menu section
            # TODO: Check if at least one sub entry is accessible.
            return (False, (), False)

        url = self.get_url()
        if url is None: # can't resolve url, message was created.
            return (True, (), True) # view can only superusers use

        # Get the view function for this url_name
        view_func, func_args, func_kwargs = urlresolvers.resolve(url)

        # get the rights from pylucid_project.apps.pylucid.decorators.check_permissions
        try:
            access_permissions = view_func.access_permissions
        except AttributeError, err:
            # If no permissions available, fallback to superuser only
            request = ThreadLocal.get_current_request()
            if settings.DEBUG or request.user.is_staff:
                messages.error(request, (
                    "The view %s for url %r has no permissions attribute!"
                    " Please use pylucid_project.apps.pylucid.decorators.check_permissions!"
                    ) % (view_func.__name__, self.url_name)
                )
            access_permissions = (True, (), True)

        return access_permissions

#    def save(self, *args, **kwargs):
#        """
#        After change, deletes panel_extra from cache.
#        cache filled in pylucid_plugins.admin_menu.views.panel_extras()
#        """
#        for user_id in User.objects.values_list('id', flat=True):
#            cache_key = "panel_extras_%s" % user_id
#            cache.delete(cache_key)
#
#        return super(PyLucidAdminPage, self).save(*args, **kwargs)

    def __unicode__(self):
        return u"PyLucidAdminPage %r (%r)" % (self.name, self.get_absolute_url())

    def get_absolute_url(self):
        """
        absolute url (without domain/host part)
        TODO: Should be used a cache here?
        """
        if not self.url_name:
            return "" # menu section

        url = self.get_url()
        if url is None: # can't resolve url, message was created.
            return "#resolve-error" # XXX: return something else?

        request = ThreadLocal.get_current_request()
        get_data = {}
        if self.get_pagetree and hasattr(request.PYLUCID, "pagetree"):
            get_data["pagetree"] = request.PYLUCID.pagetree.pk
        if self.get_pagemeta and hasattr(request.PYLUCID, "pagemeta"):
            get_data["pagemeta"] = request.PYLUCID.pagemeta.pk
        if self.get_page:
            if hasattr(request.PYLUCID, "pagecontent"):
                get_data["pagecontent"] = request.PYLUCID.pagecontent.pk
            elif hasattr(request.PYLUCID, "pluginpage"):
                get_data["pluginpage"] = request.PYLUCID.pluginpage.pk

        if get_data:
            # FIXME: There must be a better was to to this.
            # TODO: escape it.
            url += "?" + "&".join(["%s=%s" % (key, value) for key, value in get_data.items()])

        return url

    class Meta:
        verbose_name = _('PyLucid admin page')
        verbose_name_plural = _('PyLucid admin pages')
        ordering = ("name", "url_name",)

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import sys

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.core.exceptions import ValidationError
from django.core.urlresolvers import reverse
from django.test.client import Client

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid_admin.models import PyLucidAdminPage


ADMIN_TEST_URL_NAME = "PageAdmin-new_content_page"


class PyLucidAdminTestCase(basetest.BaseUnittest):
    ADMIN_INDEX_URL = reverse("admin:index")

    def setUp(self):
        self.client = Client() # start a new session


class PyLucidAdminTest(PyLucidAdminTestCase):

    def test_unique_url_name(self):
        """ Check if url_name must be unique. """
        test_url_name = "unittest"
        first_entry = PyLucidAdminPage(name="foo", url_name=test_url_name)
        first_entry.save()
        second_entry = PyLucidAdminPage(name="bar", url_name=test_url_name)
        self.failUnlessRaises(ValidationError, second_entry.full_clean)

    def test_admin_login(self):
        """ request the normal django admin login page """
        response = self.client.get(self.ADMIN_INDEX_URL)
        self.assertAdminLoginPage(response)

    def test_admin_index(self):
        self.login(usertype="superuser")
        response = self.client.get("/admin/")
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Site administration</title>',
                '<a href="/pylucid_admin/install/pylucid/">install PyLucid</a>',
                '<a href="/pylucid_admin/install/plugins/">install plugins</a>',
            ),
            must_not_contain=("Traceback",
                # django
                'form action="/admin/" method="post"',
                # from pylucid:
                '$("form").submit',
                '$("form").find(":submit")'
            )
        )

    def test_install_plugins(self):
        self.login(usertype="superuser")
        response = self.client.get("/pylucid_admin/install/plugins/")
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - PyLucid - Plugin install</title>',
                '*** Install Plugins:',

                "PyLucidAdminPage &#39;new content page&#39;"
                " (&#39;/pylucid_admin/plugins/page_admin/new_content_page/&#39;)&gt; created.",
            ),
            must_not_contain=("Traceback",)
        )

    def test_summary_page(self):
        self.login(usertype="superuser")
        response = self.client.get(self.ADMIN_INDEX_URL)
        self.assertResponse(response,
            must_contain=("PyLucid", "PageTree", "PageContent", "PageMeta"),
            must_not_contain=("Log in", "Traceback",)#"error")
        )

    def test_anonymous_add(self):
        """ Try to create a PageTree entry as a anonymous user. """
        url = reverse("admin:pylucid_pagetree_add")
        response = self.client.get(url)
        self.assertAdminLoginPage(response)

    def test_lang_german(self):
        """ Check if we get the admin page in the right language. """
        self.login(usertype="superuser")
        response = self.client.get(self.ADMIN_INDEX_URL, HTTP_ACCEPT_LANGUAGE="de")
        self.assertResponse(response,
            must_contain=(
                "PyLucid", "PageTree", "PageContent", "PageMeta",
                "Website-Verwaltung", "Krzliche Aktionen"
            ),
            must_not_contain=("Log in", "Traceback",)
        )


class PyLucidPluginsTest(PyLucidAdminTestCase):
    """ Tests with installed plugins """
    def _pre_setup(self, *args, **kwargs):
        """ create some blog articles """
        super(PyLucidPluginsTest, self)._pre_setup(*args, **kwargs)

        # TODO: use managment command for this, if exist ;)
        self.login(usertype="superuser")
        response = self.client.get("/pylucid_admin/install/plugins/")
        self.failUnless(PyLucidAdminPage.objects.count() > 0, response.content + "\n\nno plugins installed?")
        self.assertResponse(response,
            must_contain=("Install Plugins:", "install plugin"),
            must_not_contain=("Log in", "Traceback")
        )

    def assertLoginRedirect(self, url):
        login_url = 'http://testserver/?auth=login&next_url=%s' % url
        response = self.client.get(url)
        self.assertRedirect(response, login_url, status_code=302)

    def assertIsAdminPage(self, url):
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                '<html', '<head>', '<title>', '<body',
                '<meta name="robots" content="NONE,NOARCHIVE" />',
                '<ul class="sf-menu">', 'PyLucid admin menu',
            ),
            must_not_contain=(
                '<input type="text" name="username"',
                '<input type="password" name="password"',
                '<input type="submit" value="Log in" />',
            )
        )
        self.assertStatusCode(response, 200)

    def assertPermissionDenied(self, url):
        response = self.client.get(url)
        self.assertPyLucidPermissionDenied(response)

    def test_access_admin_views(self):
        """ Test different user permission access of pylucid admin views. """
        # Remember all test cases
        superuser_only_tested = False
        must_staff_only_tested = False
        permissions_only_tested = False

        all_plugin_views = PyLucidAdminPage.objects.exclude(url_name=None)
        for item in all_plugin_views:
            url = item.get_absolute_url()
            superuser_only, permissions, must_staff = item.get_permissions()

            if superuser_only:
                # Test admin view for superusers only
                if superuser_only_tested: # Test only one time
                    continue
                superuser_only_tested = True

                # Anonymous user should have no access:
                self.client = Client() # start a new session
                self.assertLoginRedirect(url)

                self.login(usertype="normal")
                self.assertPermissionDenied(url)

                self.login(usertype="staff")
                self.assertPermissionDenied(url)

                self.login(usertype="superuser")
                self.assertIsAdminPage(url)

            elif must_staff and not permissions:
                # User must be staff member, but must not have any permissions
                if must_staff_only_tested: # Test only one time
                    continue
                must_staff_only_tested = True

                self.client = Client() # start a new session
                self.assertLoginRedirect(url) # Anonymous user

                self.login(usertype="normal")
                self.assertPermissionDenied(url)

                self.login(usertype="staff")
                self.assertIsAdminPage(url)

            elif permissions and not must_staff:
                # Normal users with the right permissions can use this view
                if permissions_only_tested: # Test only one time
                    continue
                permissions_only_tested = True

                self.client = Client() # start a new session
                self.assertLoginRedirect(url) # Anonymous user

                # Normal user, without any permissions
                self.login(usertype="normal")
                self.assertPermissionDenied(url)

                # Normal user with the right permissions
                self.login_with_permissions(usertype="staff", permissions=permissions)
                self.assertIsAdminPage(url)

            sys.stdout.write(".")

        # Check if every case was tested
        self.failUnless(superuser_only_tested == True)
        self.failUnless(must_staff_only_tested == True)
        self.failUnless(permissions_only_tested == True)





if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "apps.pylucid_admin.tests.PyLucidPluginsTest.test_access_admin_views"

    management.call_command('test', tests,
#        verbosity=0,
        verbosity=1,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""
from django.conf import settings
from django.conf.urls.defaults import patterns, url, include

from pylucid_project.apps.pylucid_admin import views
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS

from pylucid_project.apps.pylucid.decorators import superuser_only

plugin_admin_urls = PYLUCID_PLUGINS.get_admin_urls()

urlpatterns = patterns('',
    url(r'^menu/$', views.menu, name='PyLucidAdmin-menu'),

    url(r'^plugins/', include(plugin_admin_urls)),

    url(r'^install/pylucid/$', superuser_only(views.install_pylucid), name='PyLucidAdmin-install_pylucid'),
    url(r'^install/plugins/$', superuser_only(views.install_plugins), name='PyLucidAdmin-install_plugins'),
)

########NEW FILE########
__FILENAME__ = views
# coding:utf-8

"""
    PyLucid
    ~~~~~~~

    :copyleft: 2009-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

from django import http
from django.conf import settings
from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.models import User, Group
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from django.shortcuts import render_to_response
from django.template import RequestContext
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import PageTree, PageMeta, PageContent, PluginPage, Design
from pylucid_project.apps.pylucid.system import pylucid_plugin, pylucid_objects
from pylucid_project.apps.pylucid_admin.models import PyLucidAdminPage
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS



@login_required
@render_to("pylucid_admin/menu.html")
def menu(request):
    return {"title": "PyLucid admin menu"}


@check_permissions(superuser_only=True)
@render_to("pylucid_admin/install.html")
def install_pylucid(request):
    """
    FIXME: obsolete???
    """
    output = []
    output.append("*** PyLucid install:")

    sys_pref_form = request.PYLUCID.preferences_form

    # ------------------------------------------------------------------------
    pylucid_admin_group, created = Group.objects.get_or_create(name=settings.ADMIN.USER_GROUP)
    if created:
        output.append("User group '%s' created." % settings.ADMIN.USER_GROUP)
    else:
        output.append("User group '%s' exist." % settings.ADMIN.USER_GROUP)

    # ------------------------------------------------------------------------
    pylucid_admin_design, created = Design.objects.get_or_create(
        name=settings.ADMIN.DESIGN_NAME, defaults={"template": "pylucid_admin/menu.html"}
    )
    # TODO: Add to all sites?
    #design.site.add(site)
    if created:
        output.append("Design '%s' created." % settings.ADMIN.DESIGN_NAME)
    else:
        output.append("Design '%s' exist." % settings.ADMIN.DESIGN_NAME)

    # Add the Design id into the preferences
    sys_pref_form["pylucid_admin_design"] = pylucid_admin_design.id
#
#    # ------------------------------------------------------------------------    
#    pylucid_admin_pagetree, created = PageTree.objects.get_or_create(
#        slug="PyLucidAdmin", parent=None, site=Site.objects.get_current(),
#        defaults={
#            "design": pylucid_admin_design,
#            "type": PageTree.PAGE_TYPE,
#        }
#    )
#    pylucid_admin_pagetree.permitViewGroup = pylucid_admin_group
#
#    url = pylucid_admin_pagetree.get_absolute_url()
#    if created:
#        #tree_entry.save()
#        output.append("PageTree '%s' created." % url)
#    else:
#        output.append("PageTree '%s' exist." % url)
#
#    # Add the PageTree id into the preferences
#    sys_pref_form["pylucid_admin_pagetree"] = pylucid_admin_pagetree.id
#
#    # ------------------------------------------------------------------------
#    pylucid_admin_pagemeta, created = PageMeta.objects.get_or_create(
#        page=pylucid_admin_pagetree,
#        language=request.PYLUCID.current_language, # FIXME: Create in all existing languages?
#        defaults={"name": "PyLucid Admin", "robots":"noindex,nofollow"}
#    )
#    if created:
#        output.append("PageMeta %r created." % pylucid_admin_pagemeta)
#    else:
#        output.append("PageMeta %r exist." % pylucid_admin_pagemeta)
#
#    # ------------------------------------------------------------------------
#    pylucid_admin_pagecontent, created = PageContent.objects.get_or_create(
#        page=pylucid_admin_pagetree,
#        language=request.PYLUCID.current_language, # FIXME: Create in all existing languages?
#        pagemeta=pylucid_admin_pagemeta,
#        defaults={
#            "content":"PyLucid Admin section. Please seletect a menu item.",
#            "markup": MARKUP_CREOLE,
#        }
#    )
#    if created:
#        output.append("PageContent %r created." % pylucid_admin_pagecontent)
#    else:
#        output.append("PageContent %r exist." % pylucid_admin_pagecontent)

    # Save new preferences
    sys_pref_form.save()
    output.append("System preferences saved.")

    context = {
        "title": "PyLucid - install",
        "output": output,
    }
    return context


@check_permissions(superuser_only=True)
@render_to("pylucid_admin/install.html")
def install_plugins(request):
    """
    Simple call all plugin install view, if exist.
    
    TODO: create a "install plugins" managment command and call it here! (This is useful for unittests)
    """
    output = []

    # Delete all items
    PyLucidAdminPage.objects.all().delete()

    output.append("*** Install Plugins:")

    filename = settings.ADMIN.VIEW_FILENAME
    view_name = settings.ADMIN.PLUGIN_INSTALL_VIEW_NAME

    for plugin_name, plugin_instance in PYLUCID_PLUGINS.iteritems():
        try:
            response = plugin_instance.call_plugin_view(request, filename, view_name, method_kwargs={})
        except Exception, err:
            if str(err).endswith("No module named %s" % filename):
                # Plugin has no install API
                if settings.DEBUG:
                    output.append("Skip plugin %r, because it has no install view (%s)" % (plugin_name, err))
                continue

            messages.error(request, "failed call %s.%s: %s" % (plugin_name, view_name, err))
            continue

        output.append("_" * 79)
        output.append(" *** install plugin %r ***" % plugin_name)
        assert isinstance(response, basestring) == True, "Plugin install view must return a basestring!"
        output.append(response)

        output.append(" --- %s END ---" % plugin_name)
        output.append("")

    context = {
        "title": "PyLucid - Plugin install",
        "output": output,
    }
    return context

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    PyLucid.admin
    ~~~~~~~~~~~~~~

    Register all old PyLucid model in django admin interface,
    but only in DEBUG mode.

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2008 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib import admin

from pylucid_project.apps.pylucid_update.models import Page08, Style08, Template08, \
                                        JS_LoginData08, BlogComment08, BlogTag, BlogEntry

#------------------------------------------------------------------------------

if settings.DEBUG: # Add v0.8 tables only in DEBUG mode.

    class JS_LoginDataAdmin(admin.ModelAdmin):
        list_display = (
            'user', 'sha_checksum', 'salt', 'createtime', 'lastupdatetime'
        )

    admin.site.register(JS_LoginData08, JS_LoginDataAdmin)


    class PageAdmin(admin.ModelAdmin):
        list_display = (
            "id", "shortcut", "name", "title", "description",
            "lastupdatetime", "lastupdateby"
        )
        list_display_links = ("shortcut",)
        list_filter = (
            "createby", "lastupdateby", "permitViewPublic", "showlinks",
            "template", "style", "markup",
        )
        date_hierarchy = 'lastupdatetime'
        search_fields = ["content", "name", "title", "description", "keywords"]

    admin.site.register(Page08, PageAdmin)


    #class PluginAdmin(admin.ModelAdmin):
    #    list_display = (
    #        "active", "plugin_name", "description", "can_deinstall"
    #    )
    #    list_display_links = ("plugin_name",)
    #    ordering = ('package_name', 'plugin_name')
    #    list_filter = ("author","package_name", "can_deinstall")
    #
    #admin.site.register(Plugin, PluginAdmin)
    #
    #
    #class PageArchivAdmin(admin.ModelAdmin):
    #    list_display = (
    #        "id", "pagetree", "edit_comment",
    #        "shortcut", "name", "title",
    #        "description", "lastupdatetime", "lastupdateby"
    #    )
    #
    #admin.site.register(PageArchiv, PageArchivAdmin)

    #------------------------------------------------------------------------------

    #class PreferenceAdmin(admin.ModelAdmin):
    #    list_display = (
    #        "id", "plugin", "comment",
    #    )
    #    list_display_links = ("comment",)
    #    ordering = ("plugin", "id")
    #    list_filter = ("plugin",)
    #
    #admin.site.register(Preference, PreferenceAdmin)

    #------------------------------------------------------------------------------

    class StyleAdmin(admin.ModelAdmin):
        list_display = (
            "id", "name", "description", "createtime", "lastupdatetime"
        )
        list_display_links = ("name",)
        save_as = True

    admin.site.register(Style08, StyleAdmin)


    class TemplateAdmin(admin.ModelAdmin):
        list_display = ("id", "name", "description")
        list_display_links = ("name",)
        save_as = True

    admin.site.register(Template08, TemplateAdmin)


    #______________________________________________________________________________
    # Models from old Blog plugin

    class BlogComment08Admin(admin.ModelAdmin):
        pass
    admin.site.register(BlogComment08, BlogComment08Admin)

    class BlogTagAdmin(admin.ModelAdmin):
        pass
    admin.site.register(BlogTag, BlogTagAdmin)

    class BlogEntryAdmin(admin.ModelAdmin):
        pass
    admin.site.register(BlogEntry, BlogEntryAdmin)

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.models import Language

class UpdateForm(forms.Form):
    language = forms.ModelChoiceField(
        queryset=Language.on_site.all(),
        help_text=_("Select the language of your existing page data."),
    )


class ConfirmField(forms.Field):
    def clean(self, value):
        if value != "yes":
            raise forms.ValidationError("You must insert 'yes' to confirm!")
        return value # return the cleaned data.

class WipeSiteConfirm(forms.Form):
    confirm = ConfirmField(help_text=_("Please insert 'yes' to confirm."))

########NEW FILE########
__FILENAME__ = models
# coding: utf-8

"""
    pylucid.models.Page
    ~~~~~~~~~~~~~~~~~~~

    Old PyLucid v0.8 models, used for migrating data into the new v0.9 models.

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate: 2009-02-20 09:22:34 +0100 (Fr, 20 Feb 2009) $
    $Rev: 1831 $
    $Author: JensDiemer $

    :copyleft: 2007-2008 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.db import models
from django.utils.translation import ugettext as _
from django.contrib.auth.models import User, Group


class PageManager(models.Manager):
    """
    Manager for Page model.
    """
    pass

#______________________________________________________________________________

class Page08(models.Model):
    """
    A CMS Page Object

    TODO: We should refactor the "pre_save" behavior, use signals:
    http://code.djangoproject.com/wiki/Signals
    """

    # IDs used in other parts of PyLucid, too
    MARKUP_CREOLE = 6
    MARKUP_HTML = 0
    MARKUP_HTML_EDITOR = 1
    MARKUP_TINYTEXTILE = 2
    MARKUP_TEXTILE = 3
    MARKUP_MARKDOWN = 4
    MARKUP_REST = 5

    MARKUP_CHOICES = (
        (MARKUP_CREOLE      , u'Creole wiki markup'),
        (MARKUP_HTML        , u'html'),
        (MARKUP_HTML_EDITOR , u'html + JS-Editor'),
        (MARKUP_TINYTEXTILE , u'textile'),
        (MARKUP_TEXTILE     , u'Textile (original)'),
        (MARKUP_MARKDOWN    , u'Markdown'),
        (MARKUP_REST        , u'ReStructuredText'),
    )
    MARKUP_DICT = dict(MARKUP_CHOICES)
    #--------------------------------------------------------------------------

    objects = PageManager()

    # Explicite id field, so we can insert a help_text ;)
    id = models.AutoField(primary_key=True, help_text="The internal page ID.")

    content = models.TextField(blank=True, help_text="The CMS page content.")

    parent = models.ForeignKey(
        "self", null=True, blank=True,
        to_field="id", help_text="the higher-ranking father page",
    )
    position = models.IntegerField(
        default=0,
        help_text="ordering weight for sorting the pages in the menu."
    )

    name = models.CharField(
        blank=False, null=False,
        max_length=150, help_text="A short page name"
    )

    shortcut = models.CharField(
        unique=True, null=False, blank=False,
        max_length=150, help_text="shortcut to built the URLs",

    )
    title = models.CharField(
        blank=True, max_length=150, help_text="A long page title"
    )

    template = models.ForeignKey(
        "Template08", to_field="id", help_text="the used template for this page"
    )
    style = models.ForeignKey(
        "Style08", to_field="id", help_text="the used stylesheet for this page"
    )
    markup = models.IntegerField(
        db_column="markup_id", # Use the old column name.
        max_length=1, choices=MARKUP_CHOICES,
        help_text="the used markup language for this page",
    )

    keywords = models.CharField(
        blank=True, max_length=255,
        help_text="Keywords for the html header. (separated by commas)"
    )
    description = models.CharField(
        blank=True, max_length=255,
        help_text="Short description of the contents. (for the html header)"
    )

    createtime = models.DateTimeField(
        auto_now_add=True, help_text="Create time",
    )
    lastupdatetime = models.DateTimeField(
        auto_now=True, help_text="Time of the last change.",
    )
    createby = models.ForeignKey(
        User, editable=False, related_name="page_createby",
        help_text="User how create the current page.",
    )
    lastupdateby = models.ForeignKey(
        User, editable=False, related_name="page_lastupdateby",
        help_text="User as last edit the current page.",
    )

    showlinks = models.BooleanField(default=True,
        help_text="Put the Link to this page into Menu/Sitemap etc.?"
    )
    permitViewPublic = models.BooleanField(default=True,
        help_text="Can anonymous see this page?"
    )

    permitViewGroup = models.ForeignKey(
        Group, related_name="page_permitViewGroup", null=True, blank=True,
        help_text="Limit viewable to a group?"
    )

    permitEditGroup = models.ForeignKey(
        Group, related_name="page_permitEditGroup", null=True, blank=True,
        help_text="Usergroup how can edit this page."
    )

    class Meta:
        db_table = 'PyLucid_page'
        app_label = 'PyLucid_Update'

    _url_cache = {}
    def get_absolute_url(self):
        """ absolute url *without* language code (without domain/host part) """
        if self.pk in self._url_cache:
            #print "Page08 url cache len: %s, pk: %s" % (len(self._url_cache), self.pk)
            return self._url_cache[self.pk]

        if self.parent:
            parent_shortcut = self.parent.get_absolute_url()
            url = parent_shortcut + self.shortcut + "/"
        else:
            url = "/" + self.shortcut + "/"

        self._url_cache[self.pk] = url
        return url

    def __unicode__(self):
        return u"old page model %r" % self.shortcut



class Template08(models.Model):
    name = models.CharField(unique=True, max_length=150)

    createtime = models.DateTimeField(auto_now_add=True)
    lastupdatetime = models.DateTimeField(auto_now=True)

    createby = models.ForeignKey(User, related_name="template_createby",
        null=True, blank=True
    )
    lastupdateby = models.ForeignKey(User, related_name="template_lastupdateby",
        null=True, blank=True
    )

    description = models.TextField()
    content = models.TextField()

    def __unicode__(self):
        return u"old page template %r" % self.name

    class Meta:
        db_table = 'PyLucid_template'
        app_label = 'PyLucid_Update'




class Style08(models.Model):
    name = models.CharField(unique=True, max_length=150)

    createtime = models.DateTimeField(auto_now_add=True)
    lastupdatetime = models.DateTimeField(auto_now=True)

    createby = models.ForeignKey(User, related_name="style_createby",
        null=True, blank=True
    )
    lastupdateby = models.ForeignKey(User, related_name="style_lastupdateby",
        null=True, blank=True
    )

    description = models.TextField(null=True, blank=True)
    content = models.TextField()

    def __unicode__(self):
        return u"old page stylesheet %r" % self.name

    class Meta:
        db_table = 'PyLucid_style'
        app_label = 'PyLucid_Update'


class JS_LoginData08(models.Model):
    """
    SHA information for the PyLucid JS-SHA-Login.
    """
    user = models.ForeignKey(User)

    sha_checksum = models.CharField(max_length=192)
    salt = models.CharField(max_length=5)

    createtime = models.DateTimeField(auto_now_add=True)
    lastupdatetime = models.DateTimeField(auto_now=True)

    def __unicode__(self):
        return "old JS_LoginData for user '%s'" % self.user.username

    class Meta:
        verbose_name = verbose_name_plural = 'JS-LoginData'
        db_table = 'PyLucid_js_logindata'
        app_label = 'PyLucid_Update'



#______________________________________________________________________________
# Models from old Blog plugin


class BlogComment08(models.Model):
    """
    comment from non-registered users
    """
    blog_entry = models.ForeignKey("BlogEntry", related_name="%(class)s_blog_entry")

    ip_address = models.IPAddressField(_('ip address'),)
    person_name = models.CharField(
        _("person's name"), max_length=50,
        help_text=_("Your full name (will be published) (required)"),
    )
    email = models.EmailField(
        _('e-mail address'),
        help_text=_("Only for internal use. (will not be published) (required)"),
    )
    homepage = models.URLField(
        _("homepage"), help_text=_("Your homepage (optional)"),
        verify_exists=False, max_length=200,
        null=True, blank=True
    )

    content = models.TextField(_('content'), max_length=3000)

    is_public = models.BooleanField(_('is public'))

    createtime = models.DateTimeField(
        auto_now_add=True, help_text="Create time",
    )
    lastupdatetime = models.DateTimeField(
        auto_now=True, help_text="Time of the last change.",
    )
    createby = models.ForeignKey(
        User, editable=False,
        help_text="User how create the current comment.",
        null=True, blank=True,
        related_name="%(class)s_createby"
    )
    lastupdateby = models.ForeignKey(
        User, editable=False,
        help_text="User as last edit the current comment.",
        null=True, blank=True,
        related_name="%(class)s_lastupdateby"
    )

#    def html_content(self):
#        """
#        returns the content as html used a simple markup.
#        """
#        safe_content = strip_tags(self.content)
#        content = fallback_markup(safe_content)
#        return mark_safe(content)

    class Meta:
        db_table = 'PyLucidPlugins_blogcomment'
        app_label = 'PyLucid_Update'
        ordering = ('createtime', 'lastupdatetime')



BAD_TAG_SLUG_CHARS = (" ", "/", ";")
class BlogTagManager(models.Manager):
    """
    Manager for BlogTag model.
    """
    def safe_get(self, slug):
        """
        Get a tag entry by slug. Try to verify the slug before we access the
        database. Should be used, if the slug comes from the Client
        (e.g. via url)
        TODO: Exist there a better way to verify the tag slug?
        """
        slug = slug.strip("/") # If it comes from url args
        for char in BAD_TAG_SLUG_CHARS:
            if char in slug:
                raise self.model.DoesNotExist("Not allowed character in tag name!")

        return self.model.objects.get(slug=slug)

    def add_new_tags(self, tag_list, blog_obj):
        """
        Create new tag entries and add it to the given blog entry.
        Skip existing tags and returns only the new created tags.
        """
        new_tags = []
        for tag_name in tag_list:
            try:
                tag_obj = self.get(name=tag_name)
            except self.model.DoesNotExist:
                new_tags.append(tag_name)
                tag_obj = self.create(name=tag_name, slug=tag_name)

            # Add many-to-many
            blog_obj.tags.add(tag_obj)

        return new_tags

    def get_tag_info(self):
        """
        Returns all tags with the additional information:
         * tag.count     - How many blog entries used this tag?

        returns min_frequency and max_frequency, too: The min/max usage of all
        tags. Needed to build a tag cloud.
        """
        tags = self.model.objects.all()
        if not tags:
            # There exist no tags
            return [], 0, 0

        frequency = set()
        # get the counter information
        for tag in tags:
            count = tag.blogentry_set.count()
            tag.count = count
            frequency.add(count)

        min_frequency = float(min(frequency))
        max_frequency = float(max(frequency))

        return tags, min_frequency, max_frequency

#    def get_tag_choices(self):
#        """
#        returns >count< tags witch are the most used tags.
#        """
#        tags, min_frequency, max_frequency = self.get_tag_info()
#
#        tags = sorted(tags, key=lambda x: x.count, reverse=True)
#
#        choices = tuple([(t.id, t.name) for t in tags])
#        return choices


class BlogTag(models.Model):
    """
    A blog entry tag
    TODO: Add a usage counter! So we can easy sort from more to less usages and
          building a tag cloud is easier.
    """
    objects = BlogTagManager()

    name = models.CharField(max_length=255, unique=True)
    slug = models.SlugField(unique=True, max_length=120)

    def __unicode__(self):
        return self.name

    class Meta:
        db_table = 'PyLucidPlugins_blogtag'
        #db_table = 'PyLucidPlugins_blogentry_tags'
        app_label = 'PyLucid_Update'
        ordering = ('name',)


class BlogEntry(models.Model):
    """
    A blog entry
    """
    headline = models.CharField(_('Headline'),
        help_text=_("The blog entry headline"), max_length=255
    )
    content = models.TextField(_('Content'))
    markup = models.IntegerField(
        max_length=1, #choices=Page.MARKUP_CHOICES,
        help_text="the used markup language for this entry",
    )

    tags = models.ManyToManyField(BlogTag, blank=True,
        db_table="PyLucidPlugins_blogentry_tags", related_name="blogentry_tags",
    )

    is_public = models.BooleanField(
        default=True, help_text="Is post public viewable?"
    )

    createtime = models.DateTimeField(auto_now_add=True)
    lastupdatetime = models.DateTimeField(auto_now=True)
    createby = models.ForeignKey(User,
        editable=False,
        related_name="%(class)s_08_createby"
    )
    lastupdateby = models.ForeignKey(
        User,
        editable=False,
        null=True, blank=True,
        related_name="%(class)s_08_lastupdateby",
    )

    def get_tag_string(self):
        """
        Returns all tags as a joined string
        """
        tags = self.tags.all()
        tags_names = [i.name for i in tags]
        return " ".join(tags_names)

    def __unicode__(self):
        return self.headline

    class Meta:
        ordering = ('-createtime', '-lastupdatetime')
        db_table = 'PyLucidPlugins_blogentry'
        app_label = 'PyLucid_Update'

########NEW FILE########
__FILENAME__ = urls
# -*- coding: utf-8 -*-

"""
    urls for update section
"""

from django.conf.urls.defaults import patterns, url

from pylucid_project.apps.pylucid_update import views
from pylucid_project.apps.pylucid.decorators import superuser_only

urlpatterns = patterns('',
    url(r'^$', views.menu, name='PyLucidUpdate-menu'),
    url(r'^wipe_site/$', views.wipe_site, name='PyLucidUpdate-wipe_site'),
    url(r'^replace08URLs/$', views.replace08URLs, name='PyLucidUpdate-replace08URLs'),
    url(r'^update08migrate_stj/$', views.update08migrate_stj, name='PyLucidUpdate-update08migrate_stj'),
    url(r'^update08migrate_pages/$', views.update08migrate_pages, name='PyLucidUpdate-update08migrate_pages'),
    url(r'^update08pages/$', views.update08pages, name='PyLucidUpdate-update08pages'),
    url(r'^update08pagesRedirect/$', views.update08pagesRedirect, name='PyLucidUpdate-update08pagesRedirect'),
    url(r'^update08templates/$', views.update08templates, name='PyLucidUpdate-update08templates'),
    url(r'^update08styles/$', views.update08styles, name='PyLucidUpdate-update08styles'),
    url(r'^update08plugins/$', views.update08plugins, name='PyLucidUpdate-update08plugins'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid update views
    ~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import re
import posixpath
import traceback
from pprint import pformat

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.models import User
from django.contrib.redirects.models import Redirect
from django.contrib.sites.models import Site
from django.core.urlresolvers import reverse
from django.db import transaction
from django.http import HttpResponseRedirect
from django.template.defaultfilters import slugify
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

from dbpreferences.models import Preference

from dbtemplates.models import Template

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import PageTree, PageMeta, PageContent, PluginPage, ColorScheme, Design, \
                                                EditableHtmlHeadFile, UserProfile, LogEntry, Language
from pylucid_project.apps.pylucid_update.forms import UpdateForm, WipeSiteConfirm
from pylucid_project.apps.pylucid_update.models import Page08, Template08, Style08, JS_LoginData08
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS
from pylucid_project.utils.SimpleStringIO import SimpleStringIO


# suffix for design name
DESIGN_SUFFIX = "(v0.8 migration)"


def _get_output(request, out, title):
    """ prepare output, merge  and create a LogEntry. """

    storage = messages.get_messages(request)
    if storage:
        out.write("Page messages:")
    else:
        out.write("No page messages, ok.")

    for message in storage:
        out.write(str(message))

    output = out.getlines()

    if storage:
        messages.info(request, "Page messages merge into the output and a LogEntry created.")
    else:
        messages.info(request, "A LogEntry created.")

    LogEntry.objects.log_action(
        "pylucid_update", title, request, "successful", long_message="\n".join(output)
    )
    return output


def fix_old_user(out, obj, attrnames, alternative_user):
    """
    replace the old models.ForeignKey(User) with the current user, if the old user doesn't exist.
    """
    for attrname in attrnames:
        try:
            user_id = getattr(obj, attrname).id
        except User.DoesNotExist, err:
            out.write("Old %s user doesn't exist. Use current user %r." % (attrname, alternative_user))
            setattr(obj, attrname, alternative_user)



@check_permissions(superuser_only=True)
@render_to("pylucid_update/wipe_site.html")
def wipe_site(request):
    """ Delete all PageTree, PageMeta, PagePlugin for the current site. """
    current_site = Site.objects.get_current()
    title = _("Wipe all page data on '%s'." % current_site.name)
    context = {"title": title, "site": current_site}
    out = SimpleStringIO()

    if request.method == 'POST':
        form = WipeSiteConfirm(request.POST)
        if form.is_valid():

            sid = transaction.savepoint()
            try:
                Preference.objects.all().filter(site=current_site).delete()
                PageTree.on_site.all().delete()
            except Exception, err:
                transaction.savepoint_rollback(sid)
                LogEntry.objects.log_action("pylucid_update", title, request, "Error: %s" % err,
                    long_message=traceback.format_exc())
                raise
            else:
                transaction.savepoint_commit(sid)
                LogEntry.objects.log_action("pylucid_update", title, request, "successful")
                messages.info(request, "Wipe site data successful")

            return HttpResponseRedirect(reverse("PyLucidUpdate-menu"))
    else:
        form = WipeSiteConfirm()

    context["form"] = form
    return context


@check_permissions(superuser_only=True)
@render_to("pylucid_update/menu.html")
def menu(request):
    """ Display a menu with all update view links """
    context = {
        "title": "PyLucid v0.8 migation - menu",
        "site": Site.objects.get_current(),
        "old_permalink_prefix": settings.PYLUCID.OLD_PERMALINK_PREFIX,
    }
    return context

def _cleanup_filename(filename):
    filename = filename.replace(" ", "_")
    return filename

def _make_new_template_name(template_name, site):
    return _cleanup_filename(
        posixpath.join(settings.SITE_TEMPLATE_PREFIX, slugify(site.name), template_name + ".html")
    )

def _make_new_style_name(style_name, site):
    return _cleanup_filename(
        posixpath.join(settings.SITE_STYLE_PREFIX, slugify(site.name), style_name + ".css")
    )


@check_permissions(superuser_only=True)
@render_to("pylucid_update/update08result.html")
def update08migrate_stj(request):
    out = SimpleStringIO()
    site = Site.objects.get_current()
    title = "migrate v0.8 styles, templates, JS-SHA-Login data (on site: %s)" % site

    out.write("Move JS-SHA-Login data into new UserProfile\n")
    for old_entry in JS_LoginData08.objects.all():
        try:
            user = old_entry.user
        except User.DoesNotExist, err:
            out.write("Old JS_LoginData08 User doesn't exist. Skip updating UserProfile.")
            continue

        userprofile, created = UserProfile.objects.get_or_create(user=user)
        if created:
            out.write("UserProfile for user '%s' created." % user.username)
        else:
            out.write("UserProfile for user '%s' exist." % user.username)

        if not userprofile.sha_login_checksum:
            # Add old sha login data, only if not exist.
            sha_login_checksum = old_entry.sha_checksum
            userprofile.sha_login_checksum = sha_login_checksum

            sha_login_salt = old_entry.salt
            userprofile.sha_login_salt = sha_login_salt

            userprofile.save()
            out.write("Add old JS-SHA-Login data.")

    out.write("\n______________________________________________________________")
    out.write("Move template model\n")
    for template in Template08.objects.all():
        new_template_name = _make_new_template_name(template.name, site)
        new_template, created = Template.objects.get_or_create(
            name=new_template_name,
            defaults={
                "content": template.content,
                "creation_date": template.createtime,
                "last_changed": template.lastupdatetime,
            }
        )
        new_template.save()
        new_template.sites.add(site)
        if created:
            out.write("template %r transferted to dbtemplate: %r" % (template.name, new_template_name))
        else:
            out.write("dbtemplate '%s' exist." % new_template_name)

    out.write("\n______________________________________________________________")
    out.write("Move style model\n")
    for style in Style08.objects.all():
        new_style_name = _make_new_style_name(style.name, site)
        new_staticfile, created = EditableHtmlHeadFile.objects.get_or_create(
            filepath=new_style_name,
            defaults={
                "description": style.description,
                "content": style.content,
                "createtime": style.createtime,
                "lastupdatetime": style.lastupdatetime,
            }
        )
        if created:
            out.write("stylesheet %r transferted into EditableStaticFile: %r" % (style.name, new_style_name))
        else:
            out.write("EditableStaticFile %r exist." % new_style_name)

    output = _get_output(request, out, title) # merge  and log the complete output

    context = {
        "title": title,
        "site": site,
        "results": output,
    }
    return context


def _update08migrate_pages(request, language):
    """
    Mirgate page data from a old v0.8 installation into the new v0.9 tables.
    
    Originally, this migration can be callable multiple times. But we migrate the old tree not
    in hierarchical order. Thus, migration can only be called unique.
    """
    site = Site.objects.get_current()
    title = "migrate v0.8 pages (on site: %s)" % site
    out = SimpleStringIO()

    out.write("migrate old page model data")

    old_pages = Page08.objects.order_by('parent', 'id').all()

    designs = {}
    page_dict = {}
    parent_attach_data = {}
    new_page_id_data = {}
    for old_page in old_pages:
        out.write("\nmove '%s' page (old ID:%s)" % (old_page.name, old_page.id))

        fix_old_user(
            out, obj=old_page, attrnames=["createby", "lastupdateby"], alternative_user=request.user
        )

        #---------------------------------------------------------------------
        # create/get Design entry

        if old_page.template.name == old_page.style.name:
            design_key = "%s %s" % (old_page.template.name, DESIGN_SUFFIX)
        else:
            design_key = "%s + %s %s" % (old_page.template.name, old_page.style.name, DESIGN_SUFFIX)

        if design_key in designs:
            design = designs[design_key]
            out.write("Design: %r created in the past." % design)
        else:
            # The template/style combination was not created, yet.
            new_template_name = _make_new_template_name(old_page.template.name, site)
            design, created = Design.objects.get_or_create(
                name=design_key, defaults={"template": new_template_name}
            )
            if created:
                design.sites.add(site)
                out.write("New design %s created." % design_key)
            else:
                out.write("Use existing Design: %r" % design)

            # Add old page css file            
            new_style_name = _make_new_style_name(old_page.style.name, site)
            try:
                css_file = EditableHtmlHeadFile.objects.get(filepath=new_style_name)
            except EditableHtmlHeadFile.DoesNotExist:
                out.write("Error getting headfile %r. (Can't add it to design %r)" % (new_style_name, design))
            else:
                design.headfiles.add(css_file)

            colorscheme, created = ColorScheme.objects.get_or_create(name=old_page.style.name)
            if created:
                out.write("Use new color scheme: %s" % colorscheme.name)
                out.write("Colors can be extracted later.")
            else:
                out.write("Use color scheme: %s" % colorscheme.name)

            design.colorscheme = colorscheme
            design.save()
            designs[design_key] = design

        #---------------------------------------------------------------------
        # create PageTree entry

        page_parent_exist = True # Exist the parent page tree or was he not created, yet?
        if old_page.parent == None:
            parent = None
        else:
            old_parent_id = old_page.parent.id
            try:
                parent = page_dict[old_parent_id]
            except KeyError, err:
                page_parent_exist = False
                msg = (
                    " *** Error: parent id %r not found!"
                    " Attach as root page and try later."
                ) % old_parent_id
                out.write(msg)

        tree_entry = PageTree(
            site=site,
            slug=old_page.shortcut,
            parent=parent,
            position=old_page.position,
            page_type=PageTree.PAGE_TYPE, # FIXME: Find plugin entry in page content
            design=design,
            createtime=old_page.createtime,
            lastupdatetime=old_page.lastupdatetime,
            createby=old_page.createby,
            lastupdateby=old_page.lastupdateby,
        )
        tree_entry.save()
        out.write("PageTree entry '%s' created." % tree_entry.slug)

        # Collect the information old page ID <-> new PageTree ID
        new_page_id_data[old_page.id] = tree_entry.id

        page_dict[old_page.id] = tree_entry

        if old_page.id in parent_attach_data:
            # We have create a page tree witch was missing in the past.
            # Attach the right parent
            out.write(" +++ Attach the now created page tree %r as parent to:" % tree_entry)
            for created_page in parent_attach_data[old_page.id]:
                out.write("\t%r" % created_page)
                created_page.parent = tree_entry
                created_page.save()
            del(parent_attach_data[old_page.id]) # No longer needed

        if not page_parent_exist:
            # The parent page for the created tree_entry was not created yed.
            # Save this and attach the right parent page, after create.
            out.write("Remember page %r for later parent attach." % tree_entry)
            if old_parent_id not in parent_attach_data:
                parent_attach_data[old_parent_id] = [tree_entry]
            else:
                parent_attach_data[old_parent_id].append(tree_entry)

        #---------------------------------------------------------------------
        # create PageMeta entry

        pagemeta_entry = PageMeta(
            pagetree=tree_entry,
            language=language,
            name=old_page.name,
            title=old_page.title,
            keywords=old_page.keywords,
            description=old_page.description,

            # django-tagging can't handle case insensitive tags :(
            # So we get a duplicate entry IntegrityError an e.g.: "CGI, cgi"
            # work-a-round here: .lower() all tags :(
            # see: http://code.google.com/p/django-tagging/issues/detail?id=46
            tags=old_page.keywords.lower(),

            createtime=old_page.createtime,
            lastupdatetime=old_page.lastupdatetime,
            createby=old_page.createby,
            lastupdateby=old_page.lastupdateby,
        )
        pagemeta_entry.save()
        out.write("PageMeta entry '%s' - '%s' created." % (language, tree_entry.slug))

        #---------------------------------------------------------------------
        # create PageContent or PluginPage entry

        if old_page.content.strip() == "{% lucidTag blog %}":
            # Create a blog plugin page, but only if there is no additional content
            tree_entry.page_type = PageTree.PLUGIN_TYPE
            tree_entry.save()

            new_pluginpage = PluginPage(app_label="pylucid_project.pylucid_plugins.blog")
            new_pluginpage.pagetree = tree_entry
            new_pluginpage.save()
            out.write("PluginPage entry 'blog' created for: %r" % tree_entry)
        else:
            # create PageContent entry    
            content_entry = PageContent(
                pagemeta=pagemeta_entry,
                content=old_page.content,
                markup=old_page.markup,
                createtime=old_page.createtime,
                lastupdatetime=old_page.lastupdatetime,
                createby=old_page.createby,
                lastupdateby=old_page.lastupdateby,
            )
            content_entry.save()
            out.write("PageContent entry '%s' - '%s' created." % (language, tree_entry.slug))

    # Save the information old page ID <-> new PageTree ID, for later use in other views.
    LogEntry.objects.log_action(
        "pylucid_update", "v0.8 migation (site id: %s)" % site.id,
        request, "page id data", data=new_page_id_data)
    output = _get_output(request, out, title) # merge page_msg and log the complete output

    context = {
        "template_name": "pylucid_update/update08result.html",
        "title": title,
        "site": site,
        "results": output,
    }
    return context


@render_to("pylucid_update/select_language.html")
def _select_lang(request, context, call_func):
    """
    Select language before start updating.
    """
    if Language.on_site.count() == 0:
        messages.error(request, _("Error: On this site exist no language!"))
        return HttpResponseRedirect(reverse("PyLucidUpdate-menu"))

    if request.method == 'POST':
        form = UpdateForm(request.POST)
        if form.is_valid():
            language = form.cleaned_data["language"]
            sid = transaction.savepoint()
            try:
                response = call_func(request, language)
            except Exception, err:
                transaction.savepoint_rollback(sid)
                LogEntry.objects.log_action("pylucid_update", context["title"], request, "Error: %s" % err,
                    long_message=traceback.format_exc())
                raise
            else:
                transaction.savepoint_commit(sid)
                LogEntry.objects.log_action("pylucid_update", context["title"], request, "successful")
            return response
    else:
        form = UpdateForm()

    context.update({
        "site": Site.objects.get_current(),
        "form": form,
    })
    return context



@check_permissions(superuser_only=True)
def update08migrate_pages(request):
    """
    Update PyLucid v0.8 model data to v0.9 models
    Before start updating, select the language.
    """
    if PageTree.on_site.count() != 0:
        messages.info(request, _("Can't start migrating: There exist pages on this side!"))
        messages.info(request, _("Create a new site or wipe all page data."))
        return HttpResponseRedirect(reverse("PyLucidUpdate-menu"))

    context = {
        "title": "Update PyLucid v0.8 model data to v0.9 models",
        "url": reverse("PyLucidUpdate-update08migrate_pages"),
    }
    return _select_lang(request, context, call_func=_update08migrate_pages)



def _get_page_id_data(site):
    """
    returns the dict with the information old page ID <-> new PageTree ID
    """
    return LogEntry.objects.filter(
        app_label="pylucid_update",
        action="v0.8 migation (site id: %s)" % site.id,
        message="page id data"
    ).order_by('-createtime')[0].data


def _replace(content, out, old, new):
    if old in content:
        out.write("replace %r with %r" % (old, new))
        content = content.replace(old, new)
    return content


OLD_PREMALINK_RE = re.compile("/%s/(\d+)/" % settings.PYLUCID.OLD_PERMALINK_PREFIX)
def _update_permalink(content, old_to_new_id):
    """ update old permalinks in page content """
    def update_permalink(m):
        old_id = int(m.group(1))
        if old_id in old_to_new_id:
            new_pagetree_id = old_to_new_id[old_id]
            return "/%s/%i/" % (
                settings.PYLUCID.PERMALINK_URL_PREFIX, new_pagetree_id
            )
        return m.group(0)

    new_content = OLD_PREMALINK_RE.sub(update_permalink, content)
    return new_content


@check_permissions(superuser_only=True)
@render_to("pylucid_update/update08result.html")
def update08pages(request):
    site = Site.objects.get_current()
    title = "Update %s PageContent" % site.name
    out = SimpleStringIO()

    # get the dict with the information old page ID <-> new PageTree ID
    new_page_id_data = _get_page_id_data(site)

    # Update only the PageContent objects from the current site.
    pages = PageContent.objects.filter(pagemeta__pagetree__site=site)
    count = 0
    delete_ids = []
    for pagecontent in pages:
        content = pagecontent.content

        content = _update_permalink(content, new_page_id_data)
        if content != pagecontent.content:
            out.write("Permalink in page %r updated." % pagecontent.get_absolute_url())

        if "{% lucidTag blog %}" in content:
            # There exist additional content in this page -> don't delete it 
            msg = (
                "*** You must manually convert page %s into a real blog plugin page!"
            ) % pagecontent.get_absolute_url()
            out.write(msg)

        content = _replace(content, out,
            "{% lucidTag page_update_list %}", "{% lucidTag update_journal %}"
        )
        content = _replace(content, out,
            "{% lucidTag page_update_list count=", "{% lucidTag update_journal count="
        )
        content = _replace(content, out, "{% lucidTag RSS ", "{% lucidTag rss ")
        if content == pagecontent.content:
            # Nothing changed
            continue
        count += 1
        pagecontent.content = content
        pagecontent.save()
        out.write("PageContent updated: %r\n" % pagecontent)

    if delete_ids:
        out.write("Delete %s obsolete PageContent items: %r" % (len(delete_ids), delete_ids))
        PageContent.objects.filter(id__in=delete_ids).delete()

    out.write("\n%s PageContent items processed." % len(pages))
    out.write("%s items updated." % count)

    output = _get_output(request, out, title) # merge page_msg and log the complete output

    context = {
        "title": title,
        "site": site,
        "results": output,
    }
    return context



def _replace08URLs(request, language):
    """ replace old absolute page URLs with new permalink. """
    site = Site.objects.get_current()
    title = "Add %s permalink Redirect entries." % site.name
    out = SimpleStringIO()

    # get the dict with the information old page ID <-> new PageTree ID
    new_page_id_data = _get_page_id_data(site)

    old_pages = Page08.objects.only("id", "shortcut")
    old_absolute_urls = []
    url_to_new_id = {} # old absolute url <-> new PageTree ID
    too_short_urls = []
    for old_page in old_pages:
        old_absolute_url = old_page.get_absolute_url()
        if old_page.parent == None:
            too_short_urls.append(old_absolute_url)
        else:
            url_to_new_id[old_absolute_url] = new_page_id_data[old_page.id]
            old_absolute_urls.append(old_absolute_url)

    out.write("Skip too short urls: %r" % too_short_urls)

    # sort from longest to shortest
    old_absolute_urls.sort(cmp=lambda x, y: cmp(len(x), len(y)), reverse=True)

    # Update only the PageContent objects from the current site.
    pages = PageContent.objects.filter(pagemeta__pagetree__site=site)
    count = 0
    permalink_cache = {}
    replace_data = []
    for pagecontent in pages:
        content = pagecontent.content

        for old_absolute_url in old_absolute_urls:
            if old_absolute_url in content:
                if old_absolute_url in permalink_cache:
                    permalink = permalink_cache[old_absolute_url]
                else:
                    page_tree_id = url_to_new_id[old_absolute_url]
                    page_tree = PageTree.objects.get(id=page_tree_id)
                    page_meta = PageMeta.objects.get(pagetree=page_tree, language=language)
                    permalink = page_meta.get_permalink()
                    permalink_cache[old_absolute_url] = permalink

                page_absolute_url = pagecontent.get_absolute_url()

                content = content.replace(old_absolute_url, permalink)

                replace_data.append({
                    "old_absolute_url": old_absolute_url,
                    "permalink": permalink,
                    "page_absolute_url": page_absolute_url,
                })
                out.write("replace %r with %r in page %r" % (
                    old_absolute_url, permalink, page_absolute_url
                ))

        if content == pagecontent.content:
            # Nothing changed
            continue
        count += 1
        pagecontent.content = content
        pagecontent.save()
        out.write("PageContent updated: %r\n" % pagecontent)

    out.write("\n%s PageContent items processed." % len(pages))
    out.write("%s items updated." % count)

    output = _get_output(request, out, title) # merge page_msg and log the complete output

    context = {
        "template_name": "pylucid_update/replace08URLs.html",
        "title": title,
        "site": site,
        "too_short_urls": too_short_urls,
        "replace_data": replace_data,
        "items_count": len(pages),
        "update_count": count,
    }
    return context


@check_permissions(superuser_only=True)
def replace08URLs(request):
    """
    Update PyLucid v0.8 model data to v0.9 models
    Before start updating, select the language.
    """
    context = {
        "title": "Update old absolute urls in PageContent",
        "url": reverse("PyLucidUpdate-replace08URLs"),
    }
    return _select_lang(request, context, call_func=_replace08URLs)






@check_permissions(superuser_only=True)
@render_to("pylucid_update/update08result.html")
def update08pagesRedirect(request):
    site = Site.objects.get_current()
    title = "Add %s permalink Redirect entries." % site.name
    out = SimpleStringIO()

    new_page_id_data = _get_page_id_data(site)

    for (old_page_id, tree_entry_id) in new_page_id_data.iteritems():
        old_page = Page08.objects.only("id", "shortcut").get(id=old_page_id)

        old_path = "/%s/%i/%s/" % (settings.PYLUCID.OLD_PERMALINK_PREFIX, old_page.id, old_page.shortcut)
        new_path = "/%s/%i/%s/" % (settings.PYLUCID.PERMALINK_URL_PREFIX, tree_entry_id, old_page.shortcut)

        created = Redirect.objects.get_or_create(
            site=site, old_path=old_path,
            defaults={"new_path":new_path}
        )[1]
        if created:
            out.write("Add permalink redirect. ( %s -> %s )" % (old_path, new_path))
        else:
            out.write("Permalink redirect for this page exist. ( %s -> %s )" % (old_path, new_path))

    output = _get_output(request, out, title) # merge page_msg and log the complete output

    context = {
        "title": title,
        "site": site,
        "results": output,
    }
    return context


@check_permissions(superuser_only=True)
@render_to("pylucid_update/update08result.html")
def update08templates(request):
    site = Site.objects.get_current()
    title = "Update PyLucid v0.8 %s templates" % site.name
    out = SimpleStringIO()

    templates = Template.on_site.filter(name__istartswith=settings.SITE_TEMPLATE_PREFIX)

    count = 0
    for template in templates:
        out.write("\n______________________________________________________________")
        out.write("Update Template: '%s'\n" % template.name)

        content = template.content

        SCRIPT_TAG = (
            '<script src="%(url)s"'
            ' onerror="JavaScript:alert(\'Error loading file [%(url)s] !\');"'
            ' type="text/javascript" /></script>\n'
        )

        new_head_file_tag = ""
        new_head_file_tag += SCRIPT_TAG % {
            "url": posixpath.join(settings.STATIC_URL, settings.PYLUCID.PYLUCID_MEDIA_DIR, "jquery.js")
        }
        new_head_file_tag += SCRIPT_TAG % {
            "url": posixpath.join(
                settings.STATIC_URL, settings.PYLUCID.PYLUCID_MEDIA_DIR, "pylucid_js_tools.js"
            )
        }
        new_head_file_tag += '<!-- ContextMiddleware extrahead -->\n'

        content = _replace(content, out, "{% lucidTag page_style %}", new_head_file_tag)
        # temp in developer version:
        content = _replace(content, out, "{% lucidTag head_files %}", new_head_file_tag)
        content = _replace(content, out, "<!-- ContextMiddleware head_files -->", new_head_file_tag)

        content = _replace(content, out, "{{ login_link }}", "{% lucidTag auth %}")

        content = _replace(content, out, "{% lucidTag back_links %}", "<!-- ContextMiddleware breadcrumb -->")
        content = _replace(content, out,
            "{{ PAGE.content }}",
            '<div id="page_content">\n'
            '    {% block content %}{{ page_content }}{% endblock content %}\n'
            '</div>'
        )
        content = _replace(content, out, "{{ PAGE.get_permalink }}", "{{ page_permalink }}")
        content = _replace(content, out, "{{ page_get_permalink }}", "{{ page_permalink }}") # dev version only
        content = _replace(content, out,
            "{% if PAGE.title %}{{ PAGE.title|escape }}{% else %}{{ PAGE.name|escape }}{% endif %}",
            "{{ page_title }}"
        )
        content = _replace(content, out, "PAGE.title", "page_title")
        content = _replace(content, out, "{{ PAGE.keywords }}", "{{ page_keywords }}")
        content = _replace(content, out, "{{ PAGE.description }}", "{{ page_description }}")
        content = _replace(content, out, "{{ robots }}", "{{ page_robots }}")

        content = _replace(content, out, "{{ PAGE.datetime", "{{ page_createtime")

        for timestring in ("lastupdatetime", "createtime"):
            # Change time with filter:
            content = _replace(content, out,
                "{{ PAGE.%s" % timestring,
                "{{ page_%s" % timestring
            )
            # add i18n filter, if not exist:
            content = _replace(content, out,
                "{{ page_%s }}" % timestring,
                '{{ page_%s|date:_("DATETIME_FORMAT") }}' % timestring,
            )

        content = _replace(content, out, "{{ PAGE.", "{{ page_")

        content = _replace(content, out, "{% lucidTag RSS ", "{% lucidTag rss ")

        # http://www.pylucid.org/permalink/81/backwards-incompatible-changes#26-05-2010-own-jquery-js-file-removed
        content = _replace(content, out, "/media/PyLucid/jquery.js", "{{ STATIC_URL }}admin/js/jquery.min.js")
        content = _replace(content, out, "/media/PyLucid/pylucid_js_tools.js", "{{ STATIC_URL }}PyLucid/pylucid_js_tools.js")

        if "{% lucidTag language %}" not in content:
            # Add language plugin after breadcrumb, if not exist
            content = _replace(content, out,
                "<!-- ContextMiddleware breadcrumb -->",
                "<!-- ContextMiddleware breadcrumb -->\n"
                "<p>{% lucidTag language %}</p>\n"
            )

        # TODO: add somthing like: <meta http-equiv="Content-Language" content="en" />

        new_page_msg = '{% include "pylucid/includes/page_msg.html" %}'
        content = _replace(content, out, "<!-- page_messages -->", new_page_msg)

        if new_page_msg not in content:
            out.write(' *** IMPORTANT: You must insert %s in this template!' % new_page_msg)

        if template.content == content:
            out.write("Nothing changed")
        else:
            template.content = content
            template.save()
            count += 1
            out.write("Template updated.")

    out.write("\n\n%s Template items processed." % len(templates))
    out.write("%s items updated." % count)

    output = out.getlines()
    LogEntry.objects.log_action(
        "pylucid_update", title, request, "successful", long_message="\n".join(output)
    )

    context = {
        "title": title,
        "site": site,
        "results": output,
    }
    return context



@check_permissions(superuser_only=True)
@render_to("pylucid_update/update08result.html")
def update08styles(request):
    """
    Fill colorschemes with colors from headfiles.
    """
    site = Site.objects.get_current()
    title = "Update PyLucid v0.8 %s styles" % site.name
    out = SimpleStringIO()

    designs = Design.on_site.filter(name__endswith=DESIGN_SUFFIX)
    resaved_headfiles = []
    for design in designs:
        out.write("\n______________________________________________________________")
        out.write("\nUpdate color scheme for design: '%s'" % design.name)

        headfiles = design.headfiles.all()
        for headfile in headfiles:
            if headfile in resaved_headfiles:
                continue
            resaved_headfiles.append(headfile)
            headfile.render = True
            headfile.save()
            out.write("Headfile %s set to render and resaved" % headfile)

    output = out.getlines()
    LogEntry.objects.log_action(
        "pylucid_update", title, request, "successful", long_message="\n".join(output)
    )

    context = {
        "title": title,
        "site": site,
        "results": output,
    }
    return context


@check_permissions(superuser_only=True)
def update08plugins(request):
    """
    Update PyLucid v0.8 model data to v0.9 models
    Before start updating, select the language.
    """
    context = {
        "template_name": "pylucid_update/update08plugins.html",
        "title": "Update PyLucid v0.8 plugin data",
        "url": reverse("PyLucidUpdate-update08plugins"),
    }
    return _select_lang(request, context, call_func=_update08plugins)




def _update08plugins(request, language):
    site = Site.objects.get_current()
    title = "Update PyLucid v0.8 plugin data"
    out = SimpleStringIO()

    method_kwargs = {
        "out": out,
        "language": language,
    }

    filename = settings.PYLUCID.UPDATE08_PLUGIN_FILENAME
    view_name = settings.PYLUCID.UPDATE08_PLUGIN_VIEWNAME

    for plugin_name, plugin_instance in PYLUCID_PLUGINS.iteritems():
        try:
            plugin_instance.call_plugin_view(request, filename, view_name, method_kwargs)
        except Exception, err:
            if str(err).endswith("No module named %s" % filename):
                # Plugin has no update API
                continue
            if settings.DEBUG:
                raise
            messages.error(request, "failed updating %s." % plugin_name)
            messages.debug(request, mark_safe("<pre>%s</pre>" % traceback.format_exc()))
        else:
            out.write(" --- %s END ---" % plugin_name)

    output = out.getlines()
    LogEntry.objects.log_action(
        "pylucid_update", title, request, "successful", long_message="\n".join(output)
    )

    context = {
        "template_name": "pylucid_update/update08result.html",
        "title": title,
        "site": site,
        "results": output,
    }
    return context

########NEW FILE########
__FILENAME__ = base_markup_model
# coding: utf-8

"""
    PyLucid base models
    ~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.db import models
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools.template import render
from django_tools.middlewares.ThreadLocal import get_current_request

from pylucid_project.apps.pylucid.fields import MarkupModelField, \
    MarkupContentModelField
from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid.markup.django_tags import DjangoTagAssembler



class MarkupBaseModel(models.Model):
    """
    For models with content + markup field
    """
    content = MarkupContentModelField(
        _('Content'), blank=True, help_text=_("raw markup content.")
    )
    markup = MarkupModelField(
        _('Markup'), help_text=_("Specifiy the used content markup.")
    )

    def get_html(self, request=None, escape_django_tags=False, render_django_tags=False):
        """
        return self.content rendered as html:
            1. apply markup
            2. parse lucidTags/django template tags
        """
        if request is None:
            # e.g. called from template
            request = get_current_request()

        content1 = apply_markup(self.content, self.markup, request, escape_django_tags=escape_django_tags)

        if not render_django_tags:
            return content1
        else:
            context = request.PYLUCID.context
            content2 = render.render_string_template(content1, context)
            return content2

    def get_search_content(self, request):
        """
        Use this content for display search results:
        * render markup content to html without existing django tags
        """
        content = self.get_html(request)

        # remove django tags
        assembler = DjangoTagAssembler()
        content2, cut_data = assembler.cut_out(content)

        return content2

    class Meta:
        abstract = True

########NEW FILE########
__FILENAME__ = base_models
# coding: utf-8


"""
    PyLucid base models
    ~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.contrib import messages

from django.core.exceptions import ObjectDoesNotExist
from django.db import models
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools.middlewares import ThreadLocal

from pylucid_project.utils import form_utils


TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


class BaseModel(models.Model):
    def get_absolute_url(self):
        raise NotImplementedError
    get_absolute_url.short_description = _('absolute url')

    def get_site(self):
        raise NotImplementedError
    get_site.short_description = _('on site')

    def get_absolute_uri(self):
        """ returned the complete absolute URI (with the domain/host part) """
        request = ThreadLocal.get_current_request()
        is_secure = request.is_secure()
        if is_secure:
            protocol = "https://"
        else:
            protocol = "http://"
        site = self.get_site()
        domain = site.domain

        if "://" in domain:
            domain2 = domain.split("://", 1)[-1]
            msg = (
                "Wrong site domain %r: protocol should not inserted there!"
                " (Please change it to: %r)"
            ) % (domain, domain2)
            messages.error(request, msg)
            domain = domain2

        absolute_url = self.get_absolute_url()
        return protocol + domain + absolute_url
    get_absolute_uri.short_description = _('absolute uri')

    class Meta:
        abstract = True



class BaseModelManager(models.Manager):
    def easy_create(self, cleaned_form_data, extra={}):
        """
        Creating a new model instance with cleaned form data witch can hold more data than for
        this model needed.
        """
        keys = self.model._meta.get_all_field_names()
        model_kwargs = form_utils.make_kwargs(cleaned_form_data, keys)
        model_kwargs.update(extra)
        model_instance = self.model(**model_kwargs)
        model_instance.save()
        return model_instance

    def get_by_prefered_language(self, request, queryset, show_lang_errors=False):
        """
        return a item from queryset in this way:
        - try to get in language by client prefered order
        - if not exist: try to get in system default language
        - if not exist: use the first found item
        """
        item = None
        tried_languages = []
        languages = request.PYLUCID.languages # languages are in client prefered order
        for language in languages:
            try:
                item = queryset.get(language=language)
            except ObjectDoesNotExist:
                tried_languages.append(language)
            else:
                break

        if item is None:
            # Fallback and used the first found item
            try:
                item = queryset[0]
            except IndexError, err:
                raise self.model.DoesNotExist(err)

        if show_lang_errors:
            current_language = request.PYLUCID.current_language
            if item.language != current_language:
                try:
                    item2 = queryset.get(language=current_language)
                except ObjectDoesNotExist:
                    pass
                else:
                    msg = render_to_string("pylucid/includes/language_info_link.html",
                        {
                            "item": item2,
                            "language": current_language.description,
                        }
                    )
                    messages.info(request, msg)


        return item, tried_languages




########NEW FILE########
__FILENAME__ = many2many
# coding: utf-8


"""
    PyLucid base models
    ~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib.sites.managers import CurrentSiteManager
from django.contrib.sites.models import Site
from django.db import models
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools.utils.messages import failsafe_message


class SiteM2M(models.Model):
    """ Base model with sites M2M and CurrentSiteManager. """
    objects = models.Manager()
    sites = models.ManyToManyField(Site)
    on_site = CurrentSiteManager('sites')

    def __init__(self, *args, **kwargs):
        super(SiteM2M, self).__init__(*args, **kwargs)
        
        # default=[settings.SITE_ID] would be set at startup
        # This is not right if dynamic SITE_ID used
        sites_field = self._meta.get_field_by_name("sites")[0]
        sites_field.default = [settings.SITE_ID]

    def site_info(self):
        """ for admin.ModelAdmin list_display """
        sites = self.sites.all()
        return ", ".join([site.name for site in sites])
    site_info.short_description = _('Exists on site')
    site_info.allow_tags = False

    class Meta:
        abstract = True


class AutoSiteM2M(SiteM2M):
    """ Base model with sites M2M and CurrentSiteManager. """
    def save(self, *args, **kwargs):
        """
        Automatic current site, if not exist.
        
        I don't know why default=[settings.SITE_ID] is not enough, see also:
            http://www.python-forum.de/viewtopic.php?t=21022 (de)
        """
        if self.pk == None:
            # instance needs to have a primary key value before a many-to-many relationship can be used. 
            super(AutoSiteM2M, self).save(*args, **kwargs)
            if "force_insert" in kwargs:
                # we can't pass force insert to the real save method, because we
                # have save it yet.
                del kwargs["force_insert"]

        if self.sites.count() == 0:
            if settings.DEBUG:
                failsafe_message("Automatic add site id '%s' to %r" % (settings.SITE_ID, self))
            self.sites.add(settings.SITE_ID)

        super(AutoSiteM2M, self).save(*args, **kwargs)

    class Meta:
        abstract = True

########NEW FILE########
__FILENAME__ = permissions
# coding: utf-8


"""
    PyLucid base models
    ~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.contrib import messages
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools.middlewares import ThreadLocal


class PermissionsBase(object):
    """
    Shared model methods around view/edit permissions.
    Used in PageTree and PageMeta
    """
    def validate_permit_group(self, attribute, exclude, message_dict):
        """
        Prevents that a unprotected page created below a protected page.
        validate self.permitViewGroup and self.permitEditGroup
        """
        if attribute in exclude:
            return

        parent_page = self.recusive_attribute(attribute)
        if parent_page is None:
            # So parent page back to root has set a permission group
            return

        # we are below a protected page -> Check if permission group is the same.
        parent_page_group = getattr(parent_page, attribute)
        own_group = getattr(self, attribute)

        if parent_page_group == own_group:
            # permission is the same -> ok
            return

        # Add validation error message
        msg = _(
            "Error: Parent page <strong>%(parent_page)s</strong> used <strong>%(parent_page_group)s</strong>!"
            " You must used <strong>%(parent_page_group)s</strong> for this page, too."
        ) % {
            "parent_page": parent_page.get_absolute_url(),
            "parent_page_group": parent_page_group,
        }
        message_dict[attribute] = (mark_safe(msg),)

    def check_sub_page_permissions(self, attributes, exclude, message_dict, queryset):
        """
        Warn user if PageTree permissions mismatch with sub pages.
        
        self.check_sub_page_permissions(
            ("permitViewGroup", "permitEditGroup"),
            exclude, message_dict, queryset
        )
        
        """
        request = ThreadLocal.get_current_request()
        if request is None:
            # Check only if we are in a request
            return

        attributes2 = []
        for attribute in attributes:
            if attribute not in exclude and attribute not in message_dict:
                # ...and don't check if ValidationError exist for this field
                attributes2.append(attribute)

        if not attributes2:
            return

        sub_pages = queryset.only(*attributes2)

        for attribute in attributes2:
            own_permission = getattr(self, attribute)
            for sub_page in sub_pages:
                sub_page_permission = getattr(sub_page, attribute)
                if sub_page_permission != own_permission:
                    msg = _(
                        "Permission mismatch:"
                        " current %(attribute)s is set to '%(own_permission)s'"
                        " and sub page '%(slug)s' used '%(sub_permission)s'."
                        " This may be ok."
                    ) % {
                        "slug": sub_page.get_absolute_url(),
                        "attribute": attribute,
                        "own_permission": own_permission,
                        "sub_permission": sub_page_permission,
                    }
                    messages.warning(request, msg)

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid - manage.py
    ~~~~~~~~~~~~~~~~~~~
    
    http://docs.djangoproject.com/en/dev/ref/django-admin/
    
    borrowed from the pinax project.
"""

import os
import sys

def _error(msg, err):
    sys.stderr.write("%s: %s\n" % (msg, err))
    sys.stderr.write("-" * 79)
    sys.stderr.write("\n")
    import traceback
    traceback.print_exc()
    sys.stderr.write("-" * 79)
    sys.stderr.write("\n")
    sys.exit(1)

try:
    from django.core.management import setup_environ, execute_from_command_line
except ImportError, err:
    _error("Can't import stuff from django", err)

try:
    import pylucid_project
except ImportError, err:
    _error("Can't import PyLucid", err)

try:
    import settings as settings_mod # Assumed to be in the same directory.
except ImportError, err:
    _error("Can't import 'settings.py'", err)

try:
    # setup the environment before we start accessing things in the settings.
    setup_environ(settings_mod)
except Exception, err:
    _error("Can't setup the environment", err)

if __name__ == "__main__":
    try:
        execute_from_command_line()
    except Exception, err:
        _error("Error execute command", err)


########NEW FILE########
__FILENAME__ = management_command_settings
# coding: utf-8

"""
    local settings used in management commands
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    e.g. for create page instance
    
    :copyleft: 2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

print "Using %s, ok." % __file__

SECRET_KEY = "i'm not secret and only used for management commands!"

MEDIA_ROOT = ""
MEDIA_URL = ""

STATIC_ROOT = ""
STATIC_URL = ""

# django-compressor - ImproperlyConfigured: URL settings (e.g. COMPRESS_URL) must have a trailing slash
COMPRESS_URL = "/fake/"

########NEW FILE########
__FILENAME__ = context_middlewares
# coding: utf-8

"""
    PyLucid context middlewares
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    For PyLucid context middlewares API.
    see:
        http://www.pylucid.org/permalink/134/new-v09-plugin-api#context-middleware
    
    :copyleft: 2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import re

from django.conf import settings
from django.http import HttpResponse
from django.utils.encoding import smart_str

from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS
from django.contrib import messages


TAG_RE = re.compile("<!-- ContextMiddleware (.*?) -->", re.UNICODE)


class PyLucidContextMiddlewares(object):
    _MIDDLEWARES = {}

    def __init__(self):
        """
        Collect all context_middleware class objects from all existing pylucid plugins
        """
        for plugin_name, plugin_instance in PYLUCID_PLUGINS.items():
            try:
                middleware_class = plugin_instance.get_plugin_object("context_middleware", "ContextMiddleware")
            except plugin_instance.ObjectNotFound, err:
                pass
            else:
                self._MIDDLEWARES[plugin_name] = middleware_class
#        print "***", self._MIDDLEWARES

    def process_request(self, request):
        """ initialize all existing context middleware classes """
        request.PYLUCID.context_middlewares = {}

        for plugin_name, middleware_class in self._MIDDLEWARES.items():
            # make ContextMiddleware instance
            instance = middleware_class(request)
            # Make instance accessible via request object 
            request.PYLUCID.context_middlewares[plugin_name] = instance
            #messages.debug(request, "Init ContextMiddleware %r" % plugin_name)

    def process_response(self, request, response):
        """
        replace the context middleware tags in the response, with the plugin render output
        """
        if not "html" in response._headers["content-type"][1]:
            # No HTML Page -> do nothing
            return response

        # FIXME: A HttpResponse allways convert unicode into string. So we need to do that here:
        # Or we say, context render should not return a HttpResponse?
    #    from django.utils.encoding import smart_str
    #    complete_page = smart_str(complete_page)

        source_content = response.content

        self.request = request # used in sub function
        new_content = TAG_RE.sub(self._replace, source_content)
        response.content = new_content
        return response

    def _replace(self, match):
        """
        function for TAG_RE.sub: Replace the context middleware tags
        """
        request = self.request

        context_middlewares = request.PYLUCID.context_middlewares
        plugin_name = match.group(1)
        try:
            middleware_class_instance = context_middlewares[plugin_name]
        except KeyError, err:
            return "[Error: context middleware %r doesn't exist! Existing middlewares are: %r]" % (
                plugin_name, context_middlewares.keys()
            )

        # Add info for pylucid_project.apps.pylucid.context_processors.pylucid
        request.plugin_name = plugin_name
        request.method_name = "ContextMiddleware"

        middleware_response = middleware_class_instance.render()

        request.plugin_name = None
        request.method_name = None

        if middleware_response == None:
            return ""
        elif isinstance(middleware_response, unicode):
            return smart_str(middleware_response, encoding=settings.DEFAULT_CHARSET)
        elif isinstance(middleware_response, str):
            return middleware_response
        elif isinstance(middleware_response, HttpResponse):
            return middleware_response.content
        else:
            raise RuntimeError(
                "plugin context middleware render() must return"
                " http.HttpResponse instance or a basestring or None!"
            )

########NEW FILE########
__FILENAME__ = headline_anchor
# -*- coding: utf-8 -*-

"""
    PyLucid headline anchor
    ~~~~~~~~~~~~~~~~~~~~~~~

    A middleware to add a human readable, url safe anchor to all html headlines.
    Every anchor is a permalink to the page. So you can easy copy&paste the
    links for several use.
    
    If the TOC plugin used -> insert a table of contents
    
    Note: The view must activate this by:
        request.HeadlineAnchor = True
    
    more info: http://pylucid.org/_goto/147/Headline-anchor/    

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import re

from django.template.loader import render_to_string
from django.utils.encoding import force_unicode
from django.utils.safestring import mark_safe
from django.conf import settings
from django.template import RequestContext

from pylucid_project.utils.slug import makeUniqueSlug


class HeadlineAnchor(object):
    HEADLINE_RE = re.compile(r"<h(\d)>(.+?)</h(\d)>(?iusm)")

    def __init__(self, permalink):
        self.permalink = permalink
        self.toc_list = [] # Storage for self.build_toc()
        self._anchor_list = [] # For makeUniqueSlug

    def insert_links(self, content):
        assert isinstance(content, unicode), "content must be unicode!"

        # add the anchor with re.sub
        new_content = self.HEADLINE_RE.sub(self.add_anchor, content)
        return new_content

    def add_anchor(self, matchobj):
        """
        add a unique anchor to a html headline.
        """
        link_text = matchobj.group(2)
        link_text = mark_safe(link_text)

        # Strip all non-ASCII and make the anchor unique
        anchor = makeUniqueSlug(link_text, self._anchor_list)

        # Remember the current anchor.
        # So makeUnique can add a number on double anchors.
        self._anchor_list.append(anchor)

        anchor_link = self.permalink + "#" + anchor

        context = {
            "no": matchobj.group(1),
            "link_text": link_text,
            "anchor": anchor,
            "anchor_link": anchor_link,
        }

        self.toc_list.append(context) # Save for self.build_toc()

        result = render_to_string("pylucid/headline_anchor.html", context)
        return result

    def build_toc(self, request, toc_min_count):
        """
        Build the HTML code of the TOC
        """
        if len(self.toc_list) < toc_min_count:
            return u""

        context = {"toc_list": self.toc_list}

        # For adding css anchor information into context via pylucid context processor
        request.plugin_name = "TOC"
        request.method_name = "lucidTag"

        result = render_to_string("TOC/TOC.html", context, context_instance=RequestContext(request))
        return result


class HeadlineAnchorMiddleware(object):
    def process_response(self, request, response):
        """
        Add anchors to every html headlines.
        """
        if not getattr(request, "HeadlineAnchor", False):
            # insert headline anchor only if set request.HeadlineAnchor = True
            return response

        # Put only the statistic into HTML pages
        if not "html" in response._headers["content-type"][1]:
            # No HTML Page -> do nothing
            return response

        if response.status_code != 200:
            # do nothing on e.g. permission deny or not found or redirects etc.
            return response

        try:
            # Get the permalink to the current page
            permalink = request.PYLUCID.context["page_permalink"]
        except AttributeError, KeyError:
            # We are not on a cms page -> e.g.: in the admin pandel
            # No cms page request -> do nothing
            #print "*** No request.PYLUCID.pagemeta!", response._headers["content-type"]
            permalink = request.path

        # response is a HttpResponse object. Get the content via response.content will
        # encode it to byte string, but we need unicode.
        content = force_unicode(response.content, encoding=response._charset)

        # insert the Headline links
        headline_anchor = HeadlineAnchor(permalink)
        content = headline_anchor.insert_links(content)

        if settings.PYLUCID.TOC_PLACEHOLDER in content:
            # lucidTag TOC is in the content -> insert a table of contents
            toc_min_count = request.PYLUCID._toc_min_count # Added in lucidTag TOC
            toc_html = headline_anchor.build_toc(request, toc_min_count)
            content = content.replace(settings.PYLUCID.TOC_PLACEHOLDER, toc_html)

        response.content = content
        return response

########NEW FILE########
__FILENAME__ = ip_ban
# coding: utf-8

"""
    IPBanMiddleware
    ~~~~~~~~~~~~~~~
    
    Block banned IP addresses and delete old pylucid.models.BanEntry items:
    
    TODO: Move IP-Ban + Log stuff into a separate app
    
    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import time
import datetime

from django import http
from django.conf import settings


forbidden_response = http.HttpResponseForbidden(
"""<html><head><title>403 Forbidden</title></head><body>
<h1>403 Forbidden</h1><p>This resource is unavailable at this time from this computer.</p>
</body></html>""")


class IPBanMiddleware(object):
    def __init__(self):
        self.cleanup_ip_ban = settings.PYLUCID.CLEANUP_IP_BAN
        self.ban_release_timedelta = datetime.timedelta(minutes=settings.PYLUCID.BAN_RELEASE_TIME)
        self.next_check = 0 # Check the first call

    def process_request(self, request):
        from pylucid_project.apps.pylucid.models import BanEntry # FIXME: against import loops.

        remote_addr = request.META["REMOTE_ADDR"]
        should_ban = BanEntry.objects.filter(ip_address=remote_addr).count()
        if should_ban > 0:
#            raise PermissionDenied("This resource is unavailable at this time from this computer.")
#            raise http.Http404("This resource is unavailable at this time from this computer.")
            return forbidden_response

        if time.time() > self.next_check:
            # Delete all old BanEntry
            self.next_check = time.time() + self.cleanup_ip_ban # Save for next time
            BanEntry.objects.cleanup(request, self.ban_release_timedelta)



########NEW FILE########
__FILENAME__ = message_level
# coding: utf-8

"""
    PyLucid message level middleware
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Set the django message level dynamically
    
    http://docs.djangoproject.com/en/dev/ref/contrib/messages/#changing-the-minimum-recorded-level-per-request

    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.contrib.messages import constants as message_constants
from django.contrib import messages


class MessageLevelMiddleware(object):
    def process_request(self, request):
        """
        set the django message level by user type use system preferences.
        """
        # Get the system preferences
        system_preferences = request.PYLUCID.preferences

        # get the level by user type and system preferences
        if request.user.is_superuser:
            level = system_preferences["message_level_superuser"]
        elif request.user.is_staff:
            level = system_preferences["message_level_staff"]
        elif request.user.is_authenticated():
            level = system_preferences["message_level_normalusers"]
        else:
            level = system_preferences["message_level_anonymous"]

        # Set the current used message level
        messages.set_level(request, level)



########NEW FILE########
__FILENAME__ = pagestats
 # coding: utf-8

"""
    PyLucid page statistics
    ~~~~~~~~~~~~~~~~~~~~~~~

    A small page statistic middleware.
    -replace the >TAG< with some stats. But only in HTML pages.

    Based on http://code.djangoproject.com/wiki/PageStatsMiddleware
    
    database queries
    ~~~~~~~~~~~~~~~~
    We display only the the database queries count if debug is on. Otherwise
    the database cursor doesn't count the sql statements and we always get 0 ;)
    
    Some SQL print stuff from: 
        http://www.djangosnippets.org/snippets/817/
    
    TODO:
    ~~~~~
    Put settings for debug_sql_queries() into settings.py:
        http://trac.pylucid.net/ticket/230

    :copyleft: 2007-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import re
import time
import inspect
import collections

from django.conf import settings
from django.db import connection
from django.template.loader import render_to_string

# http://code.google.com/p/django-tools/
from django_tools.template.filters import human_duration

from pylucid_project.middlewares.utils import replace_content, cut_filename


# Save the start time of the current running python instance
start_overall = time.time()

TAG = u"<!-- script_duration -->"

# used if settings.DEBUG is off:
FMT = u"render time: %(total_time)s - overall: %(overall_time)s"
# used if settings.DEBUG is on:
FMT_DEBUG = FMT + u" - queries: %(query_count)d"

STACK_LIMIT = 5

FROM_REGEX = re.compile(
    r"(FROM|UPDATE|INTO)[\s`]+(.*?)[\s`]+",
    re.UNICODE | re.MULTILINE
)


class SqlLoggingList(list):
    """
    Append some infomation on every query in debug mode.
    TODO: Move this into django-tools as a seperate middleware!
    """
    def __init__(self, *args, **kwargs):
        self.type_count = collections.defaultdict(int)
        self.table_count = collections.defaultdict(int)
        super(SqlLoggingList, self).__init__(*args, **kwargs)

    def _pformat_sql(self, sql):
        sql = sql.replace('`', '')
        sql = sql.replace(' FROM ', '`FROM ')
        sql = sql.replace(' WHERE ', '`WHERE ')
        sql = sql.replace(' ORDER BY ', '`ORDER BY ')
        return sql.split('`')

    def append(self, query):
        sql = query["sql"].strip()
        sql_type = sql.split(" ", 1)[0]
        self.type_count[sql_type] += 1

        for table_info in FROM_REGEX.findall(sql):
            self.table_count[table_info[1]] += 1

        query["pformat"] = self._pformat_sql(sql)

        stack_list = inspect.stack()[1:]
        for no, stack_line in enumerate(stack_list):
            filename = stack_line[1]
            if "pylucid" in filename or "pylucid_project" in filename:
                break

        stack_list = stack_list[no:no + STACK_LIMIT] # limit the displayed stack info

        stack_info = []
        for stack_line in reversed(stack_list):
            stack_info.append({
                "filename": cut_filename(stack_line[1]),
                "lineno": stack_line[2],
                "func_name": stack_line[3],
                "code": stack_line[4]
            })

        query["stack_info"] = stack_info

        list.append(self, query)





class PageStatsMiddleware(object):
    def process_request(self, request):
        """
        save start time and database connections count.
        """
        self.start_time = time.time()
        if settings.DEBUG:
            # get number of db queries before we do anything
            self.old_queries = len(connection.queries)
            if settings.SQL_DEBUG:
                connection.queries = SqlLoggingList(connection.queries)

    def process_response(self, request, response):
        """
        calculate the statistic and replace it into the html page.
        """
        # Put only the statistic into HTML pages
        if not "html" in response._headers["content-type"][1]:
            # No HTML Page -> do nothing
            return response

        try:
            start_time = self.start_time
        except AttributeError:
            # FIXME: process_request() was not called?!?
            return response

        context = {
            'total_time' : human_duration(time.time() - start_time),
            'overall_time' : human_duration(time.time() - start_overall),
        }

        if settings.DEBUG:
            # compute the db time for the queries just run, this information is
            # only available if the debug cursor used
            context["query_count"] = len(connection.queries) - self.old_queries
            stat_info = FMT_DEBUG % context
        else:
            # Used the template without queries
            stat_info = FMT % context

        # insert the page statistic
        response = replace_content(response, TAG, stat_info)

        if settings.DEBUG and settings.SQL_DEBUG:
            # Insert all SQL queries into html page
            context["queries"] = connection.queries
            context["type_count"] = dict(connection.queries.type_count)
            context["table_count"] = dict(connection.queries.table_count)
            sql_info = render_to_string("pylucid/sql_debug.html", context)
            response = replace_content(response, "</body>", sql_info)

        return response


########NEW FILE########
__FILENAME__ = pylucid_objects
# coding: utf-8

"""
    PyLucid middleware
    ~~~~~~~~~~~~~~~~~~
    
    Create request.PYLUCID and log process_exception()
    
    TODO: Move IP-Ban + Log stuff into a separate app
    
    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import traceback

from django.conf import settings
from django.contrib.redirects.models import Redirect
from django.http import Http404
from django.utils.encoding import smart_str
from django.core.exceptions import SuspiciousOperation

from pylucid_project.apps.pylucid.models import LogEntry
from pylucid_project.apps.pylucid.system import pylucid_objects

class SuspiciousOperation404(SuspiciousOperation):
    """
    A SuspiciousOperation that will return a normal 404 back to the client.
    But this error would be logged and the IP would be ban if the client
    raised to much exceptions.
    The 404 would be returned in PyLucidMiddleware.process_exception()
    """
    # TODO: Move logging, ip ban and this into a seperate app
    status_code = 404


class PyLucidMiddleware(object):
    def process_request(self, request):
        """ Add PyLucid objects to the request object """
        request.PYLUCID = pylucid_objects.PyLucidRequestObjects(request)

    def process_exception(self, request, exception):
        # Get the system preferences
        sys_pref = request.PYLUCID.preferences
        sys_pref_form = request.PYLUCID.preferences_form

        if isinstance(exception, Http404):
            # Handle 404 page not found errors
            log404_verbosity = sys_pref.get("log404_verbosity", sys_pref_form.LOG404_NOREDIRECT)

            if log404_verbosity == sys_pref_form.LOG404_NOTHING:
                # Don't log 'Page not found' errors.
                return

            # Check if there exist a django.contrib.redirects entry for this url
            path = request.get_full_path()
            try:
                r = Redirect.objects.get(site__id__exact=settings.SITE_ID, old_path=path)
            except Redirect.DoesNotExist:
                LogEntry.objects.log_action(
                    app_label="pylucid", action="PyLucidMiddleware.process_exception()",
                    message="Redirect for %r doesn't exist." % path
                )
                return
            else:
                # Redirect entry exist
                if log404_verbosity == sys_pref_form.LOG404_NOREDIRECT:
                    # Log only 'Page not found' if no redirect for the url exists.
                    return

                LogEntry.objects.log_action(
                    app_label="pylucid", action="PyLucidMiddleware.process_exception()",
                    message="Redirect for %r exist." % path
                )
                return

        # cut exception message text to LogEntry.message max_length, to get no "Data truncated..." warning
        message = smart_str(exception, errors='replace')[:255]

        LogEntry.objects.log_action(
            app_label="pylucid", action="PyLucidMiddleware.process_exception()", message=message,
            long_message=traceback.format_exc()
        )

        ban_time = sys_pref["ban_time"] # Time period for count exceptions log messages from the same IP.
        ban_count = sys_pref["ban_count"] # Numbers of exceptions from one IP within 'ban_time' after the IP would be banned. 

        # Count the last requests for this app_label
        queryset = LogEntry.objects.last_remote_addr_actions(request, ban_time)
        queryset = queryset.filter(app_label="pylucid")
        queryset = queryset.filter(action="PyLucidMiddleware.process_exception()")
        last_actions = queryset.count()

        if last_actions >= ban_count:
            from pylucid_project.apps.pylucid.models import BanEntry
            BanEntry.objects.add(request) # raised 404 after adding the client IP!

        if isinstance(exception, SuspiciousOperation404):
            # raise a normal 404 after SuspiciousOperation was logged.
            raise Http404("SuspiciousOperation.")

########NEW FILE########
__FILENAME__ = utils
 # -*- coding: utf-8 -*-

"""
    PyLucid shared middleware utils
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2008-2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.utils.encoding import smart_str

MAX_FILEPATH_LEN = 50
FILEPATH_SPLIT = "src/pylucid" # try to cut the filepath or MAX_FILEPATH_LEN used


def replace_content(response, old, new):
    """
    -replace 'old' with 'new' in the response content.
    -returns the response object
    """
    old = smart_str(old, encoding=settings.DEFAULT_CHARSET)
    new = smart_str(new, encoding=settings.DEFAULT_CHARSET)

    # replace
    try:
        response.content = response.content.replace(old, new)
    except UnicodeError, err:
        pass

    return response


def cut_filename(filename):
    """ used in pagestats """
    if FILEPATH_SPLIT in filename:
        return "...%s" % filename.split(FILEPATH_SPLIT)[1]
    if len(filename) >= MAX_FILEPATH_LEN:
        filename = "...%s" % filename[-MAX_FILEPATH_LEN:]
    return filename

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"


from pylucid_project.tests.test_tools import basetest

class AdminMenuTest(basetest.BaseUnittest):
    def test_not_logged_in(self):
        """
        Admin menu must not in the page for anonymous users.
        """
        response = self.client.get("/en/welcome/")
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                'Log in</a>',
            ),
            must_not_contain=("Traceback",
                '<div class="PyLucidPlugins admin_menu" id="admin_menu_lucidTag">',
                '<a href="?auth=logout">Log out [superuser]</a>'
            )
        )

    def test_admin_menu(self):
        """
        Admin menu must be in the page, if the user is logged in.
        """
        self.login(usertype="superuser")
        response = self.client.get("/en/welcome/")
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '<div class="PyLucidPlugins admin_menu" id="admin_menu_lucidTag">',
                '<a href="?auth=logout">Log out [superuser]</a>'
            ),
            must_not_contain=("Traceback",)
        )

if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
    management.call_command('test', __file__, verbosity=0)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid admin menu
    ~~~~~~~~~~~~~~~~~~
    
    The PyLucid admin menu, build with superfish
    
    superfish homepage:
        http://users.tpg.com.au/j_birch/plugins/superfish/
    
    Last commit info:
    ~~~~~~~~~
    $LastChangedDate:$
    $Rev:$
    $Author: JensDiemer $
    
    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.contrib import messages
from django.conf import settings
from django.core import urlresolvers
from django.template import RequestContext
from django.core.urlresolvers import reverse
from django.shortcuts import render_to_response
from django.core.cache import cache
from django.utils.safestring import mark_safe

from pylucid_project.apps.pylucid.models import PageTree, PluginPage, Language
from pylucid_project.apps.pylucid.decorators import render_to

from pylucid_project.apps.pylucid_admin.models import PyLucidAdminPage


@render_to("admin_menu/admin_top_menu.html")#, debug=True)
def lucidTag(request):
    """
    Render the pylucid admin menu, if the user is authenticated.
    example: {% lucidTag admin_menu %}
    """
    if not request.user.is_authenticated():
        # Don't insert the admin top menu
        return

    lang_count = Language.objects.count()

    context = {
        "inline": True,
        "logout_link": "?auth=logout",
        "edit_page_link": "?page_admin=inline_edit",
        "new_page_link": reverse("admin:pylucid_pagecontent_add"),
        "add_translate": lang_count > 1,
    }
    return context


def panel_extras(request, template="admin_menu/admin_menu_items.html"):
    """
    returns all PyLucid admin menu items with can the current user use.
    Used in the inline admin menu and for the pylucid admin menu in the django admin panel.
    
    Usage in template with:
        {% lucidTag admin_menu.panel_extras %}
    """
    user = request.user

    tree = PyLucidAdminPage.objects.get_tree_for_user(user)
    #tree.debug()
    nodes = tree.get_first_nodes()

    # TODO: Add info if install was not made yet.
#    print "XX", len(nodes)
#    messages.debug(request, "nodes len: %s" % len(nodes))

    context = {"nodes":nodes}
    response = render_to_response(
        template, context, context_instance=RequestContext(request)
    )
    return response


########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

from django.contrib import admin

from pylucid_project.pylucid_plugins.auth.models import HonypotAuth,\
    HonypotUsername, HonypotPassword, HonypotIP


class HonypotAuthAdmin(admin.ModelAdmin):   
    list_display = ("id", "username", "password", "ip_address", "count", "lastupdatetime")
    list_display_links = ("username", "password", "ip_address")
    list_filter = ("ip_address",)
    date_hierarchy = 'lastupdatetime'
    search_fields = ("username", "password")
admin.site.register(HonypotAuth, HonypotAuthAdmin)


class HonypotUsernameAdmin(admin.ModelAdmin):   
    list_display = ("id", "username", "count")
    list_display_links = ("username",)
    search_fields = ("username",)
admin.site.register(HonypotUsername, HonypotUsernameAdmin)


class HonypotPasswordAdmin(admin.ModelAdmin):   
    list_display = ("id", "password", "count")
    list_display_links = ("password",)
    search_fields = ("password",)
admin.site.register(HonypotPassword, HonypotPasswordAdmin)


class HonypotIPAdmin(admin.ModelAdmin):   
    list_display = ("id", "ip_address", "count")
    list_display_links = ("ip_address",)
    search_fields = ("ip_address",)
admin.site.register(HonypotIP, HonypotIPAdmin)


########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    auth pylucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from pylucid_project.pylucid_plugins.auth.admin_views import profile_index, JS_password_change
from django.contrib.auth.views import password_change, password_change_done

urlpatterns = patterns('',
    url(r'^profile_index/$', profile_index, name='Auth-profile_index'),
    url(r'^JS_password_change/$', JS_password_change, name='Auth-JS_password_change'),

    # Fallback plaintext password change views from django:
    url(r'^plaintext_password_change/$', password_change, name='Auth-plaintext_password_change'),
    url(r'^plaintext_password_change_done/$', password_change_done, name='Auth-plaintext_password_change_done'),
)

########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8

"""
    auth pylucid admin views
    ~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

if __name__ == "__main__":
    # For doctest only
    import os
    os.environ["DJANGO_SETTINGS_MODULE"] = "django.conf.global_settings"
    from django.conf import global_settings
    global_settings.SITE_ID = 1

from django.conf import settings
from django.contrib import auth, messages
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect, Http404
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models.log import LogEntry
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu
from pylucid_project.pylucid_plugins.auth.forms import JSPasswordChangeForm
from pylucid_project.pylucid_plugins.auth.preference_forms import AuthPreferencesForm

from pylucid_project.utils import crypt

from pylucid_project.pylucid_plugins.auth.views import _get_challenge, \
    _get_loop_count



def install(request):
    """ install PyLucid admin views """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("tools")

    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="user profile", title="Your user profile (e.g. change your password)",
        url_name="Auth-profile_index"
    )

    return "\n".join(output)


#-----------------------------------------------------------------------------


@check_permissions(superuser_only=False, must_staff=False)
@render_to("auth/profile_index.html")
def profile_index(request):
    context = {
        "title": _("Your user profile"),
    }
    return context



def _wrong_old_password(request, debug_msg, user=None):
    """ username or password is wrong. """
    if settings.DEBUG:
        error_msg = debug_msg
    else:
        error_msg = _("Wrong old password. Try again.")

    messages.error(request, error_msg)

    # Protection against DOS attacks.
    pref_form = AuthPreferencesForm()
    preferences = pref_form.get_preferences()
    min_pause = preferences["min_pause"]
    ban_limit = preferences["ban_limit"]
    try:
        LogEntry.objects.request_limit(
            request, min_pause, ban_limit, app_label="pylucid_plugin.auth", action="old password error", no_page_msg=True
        )
    except LogEntry.RequestTooFast, err:
        # min_pause is not observed
        error_msg = unicode(err) # ugettext_lazy

    # Log this error (Important: must be logged after LogEntry.objects.request_limit() stuff!
    if user is not None:
        data = {"user_username": user.username}
    else:
        data = None
    LogEntry.objects.log_action(
        app_label="pylucid_plugin.auth", action="old password error", message=debug_msg, data=data
    )

    url = reverse("Auth-JS_password_change")
    return HttpResponseRedirect(url)


@render_to("auth/JS_password_change.html")
def JS_password_change(request):
    """
    set a new password with encryption directly in the browser

    Currently we only support the Django salted SHA1 password hasher
    implemented in hashers.SHA1PasswordHasher() witch is not recommended anymore.

    TODO:
    Use http://code.google.com/p/crypto-js/
    to support hashers.PBKDF2PasswordHasher() in JS Code
    """
    context = {
        "title": _("JavaScript password change"),
    }

    user = request.user
    user_profile = user.get_profile()

    loop_count = _get_loop_count() # get "loop_count" from AuthPreferencesForm

    if request.method == 'POST':
        form = JSPasswordChangeForm(request.POST)
        if not form.is_valid():
            debug_msg = "form error: %s" % ", ".join(form.errors)
            return _wrong_old_password(request, debug_msg, user)
        else:
            # old password "JS-SHA1" values for pre-verification:
            sha_a = form.cleaned_data["sha_a"]
            sha_b = form.cleaned_data["sha_b"]
            cnonce = form.cleaned_data["cnonce"]

            # new password as salted SHA1 hash:
            salt = form.cleaned_data["salt"]
            sha1hash = form.cleaned_data["sha1hash"]

            challenge = request.session.pop("challenge")
            sha_checksum = user_profile.sha_login_checksum
            try:
                # authenticate with:
                # pylucid.system.auth_backends.SiteSHALoginAuthBackend
                user2 = auth.authenticate(
                    user=user, challenge=challenge,
                    sha_a=sha_a, sha_b=sha_b,
                    sha_checksum=sha_checksum,
                    loop_count=loop_count, cnonce=cnonce
                )
            except Exception, err: # e.g. low level error from crypt
                debug_msg = "JS_password_change: auth.authenticate() failed: %s" % err
                return _wrong_old_password(request, debug_msg, user)

            if user2 is None:
                debug_msg = "JS_password_change: auth.authenticate() failed. (must be a wrong password)"
                return _wrong_old_password(request, debug_msg, user)

            # pre-verification success -> save new password

            django_salted_hash = "sha1$%s$%s" % (salt, sha1hash)
            sha_login_salt, sha_login_checksum = crypt.django_to_sha_checksum(django_salted_hash)

            # save new password in django.contrib.auth.model.User():
            user.password = django_salted_hash
            user.save()

            # save new password in PyLucid user profile:
            user_profile.sha_login_checksum = sha_login_checksum
            user_profile.sha_login_salt = sha_login_salt
            user_profile.save()

            messages.success(request, "TODO: New user password set.")

        url = reverse("Auth-JS_password_change")
        return HttpResponseRedirect(url)
    else:
        sha_login_salt = user_profile.sha_login_salt

        # create a new challenge and add it to session
        challenge = _get_challenge(request)

        context.update({
            "challenge": challenge,
            "sha_login_salt": sha_login_salt,
            "old_salt_len": crypt.OLD_SALT_LEN,
            "salt_len": crypt.SALT_LEN,
            "hash_len": crypt.HASH_LEN,
            "loop_count": loop_count,
            "get_salt_url": request.path + "?auth=get_salt",
            "sha_auth_url": request.path + "?auth=sha_auth",
        })
    return context


if __name__ == "__main__":
    import doctest
    print doctest.testmod(
#        verbose=True
        verbose=False
    )

########NEW FILE########
__FILENAME__ = auth_backends
# coding: utf-8

"""
    PyLucid auth backends
    ~~~~~~~~~~~~~~~~~~~~~
    
    Limit user access to sites via UserProfile

    SiteAuthBackend:
        for normal username/plaintext password
        
    SiteSHALoginAuthBackend:
        for JS-SHA1-Login
        
    TODO: move SiteAuthBackend to django-tools

    :copyleft: 2009-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib import messages
from django.contrib.auth.backends import ModelBackend
from django.contrib.auth.models import User
from django.contrib.sites.models import Site
from django.utils.translation import ugettext as _

from django_tools.utils.messages import failsafe_message

from pylucid_project.utils import crypt
from pylucid_project.apps.pylucid.models import LogEntry


#LOCAL_DEBUG = True
LOCAL_DEBUG = False

if LOCAL_DEBUG:
    failsafe_message("Debug mode in auth_backends is on!", UserWarning)


def can_access_site(user):
    """
    Check if the user can access the current site.
    Use the UserProfile <-> site relationship.
    Skip check for all superusers.
    """
    if user.is_superuser:
        if LOCAL_DEBUG:
            failsafe_message("Superuser can access all sites.")
        return True
    else:
        if LOCAL_DEBUG:
            failsafe_message("No superuser -> check UserProfile.")

    try:
        user_profile = user.get_profile()
    except Exception, err:
        msg = _("Error getting user profile: %s") % err
        LogEntry.objects.log_action(app_label="pylucid", action="auth_backends", message=msg)
        failsafe_message(msg)
        return

    current_site = Site.objects.get_current()
    sites = user_profile.sites.all()
    if current_site in sites:
        if LOCAL_DEBUG:
            failsafe_message("User can access these site.")
        return True
    else:
        msg = _("You can't access these site!")
        LogEntry.objects.log_action(
            app_label="pylucid", action="auth_backends", message=msg,
            data={
                "user_username": user.username,
                "site:": current_site.name,
            }
        )
        failsafe_message(msg)
        return


class SiteAuthBackend(ModelBackend):
    """
    Normal username/plaintext password authentication, but we limit user to sites.
    """
    def authenticate(self, username=None, password=None):
        try:
            user = User.objects.get(username=username)
            if not user.check_password(password):
                if settings.DEBUG or LOCAL_DEBUG:
                    failsafe_message("Wrong password!")
                return
        except User.DoesNotExist, err:
            msg = _("User %(username)s doesn't exist: %(err)s") % {"username": username, "err":err}
            LogEntry.objects.log_action(
                app_label="pylucid", action="auth_backends", message=msg,
            )
            if LOCAL_DEBUG:
                raise
            if settings.DEBUG:
                failsafe_message()
            return

        if LOCAL_DEBUG:
            failsafe_message("Username %s and password ok." % username)

        # Limit the access to UserProfile <-> site relationship
        if can_access_site(user) == True:
            return user



class SiteSHALoginAuthBackend(ModelBackend):
    """
    Used for PyLucid JS-SHA-Login.
    Check challenge and limit access to sites.
    """
    def authenticate(self, user=None, challenge=None, sha_a=None, sha_b=None, sha_checksum=None, loop_count=None, cnonce=None):
        if user == None: # Nothing to do: Normal auth?
            return

        try:
            check = crypt.check_js_sha_checksum(challenge, sha_a, sha_b, sha_checksum, loop_count, cnonce)
        except crypt.SaltHashError, err:
            # Wrong password
            LogEntry.objects.log_action(
                app_label="pylucid", action="auth_backends",
                message="User %r check_js_sha_checksum error: %s" % (user, err),
            )
            if LOCAL_DEBUG:
                raise
            if settings.DEBUG:
                failsafe_message(err, level=messages.ERROR)
            return None

        if check != True:
            # Wrong password
            LogEntry.objects.log_action(
                app_label="pylucid", action="auth_backends",
                message="User %r check_js_sha_checksum failed." % user,
            )
            return

        # Limit the access to UserProfile <-> site relationship
        if can_access_site(user) == True:
            return user

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

"""
    PyLucid JS-SHA-Login forms
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    A secure JavaScript SHA-1 AJAX Login.

    :copyleft: 2007-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django import forms
from django.contrib import auth
from django.contrib.auth.models import User
from django.utils.translation import ugettext as _
from django.forms.forms import NON_FIELD_ERRORS

from pylucid_project.utils import crypt
from pylucid_project.apps.pylucid.models import UserProfile
from django.forms.util import ErrorDict


class WrongUserError(Exception):
    pass


class HoneypotForm(forms.Form):
    username = forms.CharField(max_length=30, label=_('username'))
    password = forms.CharField(max_length=128, label=_('password'),
        widget=forms.PasswordInput
    )


class UsernameForm(forms.Form):
    username = forms.CharField(max_length=30, label=_('Username'),
        help_text=_('Required. 30 characters or fewer. Alphanumeric characters only (letters, digits and underscores).')
    )

    def get_user(self):
        username = self.cleaned_data["username"]
        try:
            user = User.objects.get(username=username)
        except User.DoesNotExist, e:
            raise WrongUserError("User %r doesn't exists!" % username)

        if not user.is_active:
            raise WrongUserError("User %r is not active!" % user)

        return user

    def get_user_profile(self, user=None):
        if user is None:
            user = self.get_user()
        try:
            return user.get_profile()
        except UserProfile.DoesNotExist, err:
            raise WrongUserError("Can't get user profile: %r" % err)

    def get_user_and_profile(self):
        user = self.get_user()
        user_profile = self.get_user_profile(user)
        return user, user_profile


class Sha1BaseForm(forms.Form):
    sha_a = forms.CharField(min_length=crypt.HASH_LEN, max_length=crypt.HASH_LEN)
    sha_b = forms.CharField(min_length=crypt.HASH_LEN / 2, max_length=crypt.HASH_LEN / 2)
    cnonce = forms.CharField(min_length=crypt.HASH_LEN, max_length=crypt.HASH_LEN)

    def _validate_sha1(self, sha_value, key):
        if crypt.validate_sha_value(sha_value) != True:
            raise forms.ValidationError(u"%s is not valid SHA value." % key)
        return sha_value

    def _validate_sha1_by_key(self, key):
        sha_value = self.cleaned_data[key]
        return self._validate_sha1(sha_value, key)

    def _validate_filled_sha1_by_key(self, key):
        value = self.cleaned_data[key]
        # Fill with null, to match the full SHA1 hexdigest length.
        temp_value = value.ljust(crypt.HASH_LEN, "0")
        self._validate_sha1(temp_value, key)
        return value

    def clean_sha_a(self):
        return self._validate_sha1_by_key("sha_a")
    def clean_cnonce(self):
        return self._validate_sha1_by_key("cnonce")

    def clean_sha_b(self):
        """
        The sha_b value is only a part of a SHA1 hexdigest. So we need to add
        some characers to use the crypt.validate_sha_value() method.
        """
        return self._validate_filled_sha1_by_key("sha_b")


class ShaLoginForm(Sha1BaseForm, UsernameForm):
    """
    Form for the SHA1-JavaScript-Login.

    inherited form Sha1BaseForm() this form fields:
        sha_a
        sha_b
        cnonce
    inherited form UsernameForm() this form fields:
        username
    """
    pass


class JSPasswordChangeForm(Sha1BaseForm):
    """
    Form for changing the password with Client side JS encryption.

    inherited form Sha1BaseForm() this form fields:
        sha_a
        sha_b
        cnonce
    for pre-verification with old password "JS-SHA1" values
    """
    # new password as salted SHA1 hash:
    salt = forms.CharField(min_length=crypt.SALT_LEN, max_length=crypt.SALT_LEN) # length see: hashers.SHA1PasswordHasher() and django.utils.crypto.get_random_string()
    sha1hash = forms.CharField(min_length=crypt.HASH_LEN, max_length=crypt.HASH_LEN)
    def clean_salt(self):
        return self._validate_filled_sha1_by_key("salt")
    def clean_sha1(self):
        return self._validate_sha1_by_key("sha1hash")


########NEW FILE########
__FILENAME__ = js_sha_login_pseudocode
#!/usr/bin/env python
# coding: utf-8

"""
    Pseudo code of the JS-SHA-Login.
    (output is in creole markup)
    more info:
    http://www.pylucid.org/permalink/42/secure-login-without-https
"""

import hashlib


def sha1(txt):
    return hashlib.sha1(txt).hexdigest()

def encrypt(txt, key): # Pseudo encrypt
    return "encrypted %s with %s" % (txt, key)

def decrypt(txt, key): # Pseudo decrypt
    txt, _, key2 = txt.split(" ", 3)[1:]
    assert key == key2
    return txt

LOOP_COUNT = 2


print "\n\n=== 1. Create a new User ===\n"
print "# Client get's new, random **user salt** from server:",
salt = "s_123"
print "'//%s//'" % salt

print "# Password input on the client:",
password = "client_password"
print "'//%s//'" % password

print "# sha1(password + salt):",
sha1sum = sha1(password + salt)
print "'//%s//'" % sha1sum

print "# Client send **sha1** hash to the server."



print "\n\n==== 2. Save user data ====\n"

print "# Server split sha1 values:",
sha1_a = sha1sum[:16]
sha1_b = sha1sum[16:]
print "**sha1_a**: '//%s//' **sha1_b**: '//%s//'" % (sha1_a, sha1_b)

print "# {{{encrypt(sha1_a, key=sha1_b)}}}:",
sha1checksum = encrypt(sha1_a, key=sha1_b)
print "'//%s//'" % sha1checksum

print "# Save only the **encrypted string** + **user salt**\n"



print "----"



print "\n\n=== 3. Login ===\n"

print "# Client request login and get's a random **challenge** from server:",
challenge = "c_123"
print "'//%s//'" % challenge

print "# User enters username and password: '//%s//'" % password

print "# Client send username and get's **user salt** from server via AJAX: '//%s//'" % salt

print "# on the client: {{{sha1(password + salt)}}}:",
sha1sum = sha1(password + salt)
print "'//%s//'" % sha1sum

print "# on the client: split sha1 in:",
sha1_a = sha1sum[:16]
sha1_b = sha1sum[16:]
print "**sha1_a**: '//%s//' **sha1_b**: '//%s//'" % (sha1_a, sha1_b)

print "# client generate a **cnonce** e.g.: {{{cnonce = sha_hexdigest(new Date().getTime() + Math.random() + ...)}}}"
cnonce = "client_SHA1_nonce"

print "# client generate **sha1_a** with e.g.: {{{sha1(sha_a, i, challenge, cnonce) x loop count}}}: \\\\",
for i in range(LOOP_COUNT):
    sha1_a = hashlib.sha1("%s%s%s%s" % (sha1_a, i, challenge, cnonce)).hexdigest()
print "'//%s//'" % sha1_a

print "# Client send **username**, **sha1_a2**, **sha1_b** and **cnonce** to the server."



print "\n\n==== 4. validation on the server ====\n"

print "# get encrypted **checksum** for user: '//%s//'" % sha1checksum

print "# {{{decrypt(sha1checksum, key=sha1_b)}}}:",
sha1checksum = decrypt(sha1checksum, key=sha1_b)
print "'//%s//'" % sha1checksum

print "# server-site {{{sha1(sha1checksum, i, challenge, cnonce) x loop count}}}:",
for i in range(LOOP_COUNT):
    sha1checksum = hashlib.sha1("%s%s%s%s" % (sha1checksum, i, challenge, cnonce)).hexdigest()
print "'//%s//'" % sha1checksum

print "# compare **client site generated** SHA1 with the **server site generated**: \\\\",
print "//%s// == //%s//" % (sha1checksum, sha1_a)

########NEW FILE########
__FILENAME__ = models
# coding: utf-8


from django.db import models
from django.utils.translation import ugettext_lazy as _

from django_tools.models import UpdateTimeBaseModel # New in django-tools v0.24.2


# used in auth views for simple check if client-nonce used in the past
# Exist here in models, because it's accessible in other modules, too.
# This doesn't work if its defined in views.py
CNONCE_CACHE = {}


class CountManager(models.Manager):
    def __init__(self, attr_name, *args, **kwargs):
        self.attr_name = attr_name
        super(CountManager, self).__init__(*args, **kwargs)

    def increase_or_add(self, value):
        kwargs = {
            "%s__exact" % self.attr_name: value,
            "defaults": {self.attr_name: value}
        }
        obj, created = self.get_or_create(**kwargs)
        if not created:
            obj.count += 1
            obj.save()
        return obj


class HonypotUsername(models.Model):
    username = models.CharField(db_index=True, max_length=30)
    count = models.PositiveIntegerField(default=1,
        help_text=_("Number of use of this username.")
    )
    objects = CountManager("username")
    def __unicode__(self):
        return u"%s (count: %i)" % (self.username, self.count)
    class Meta:
        ordering = ('-count',)


class HonypotPassword(models.Model):
    password = models.CharField(db_index=True, max_length=128)
    count = models.PositiveIntegerField(default=1,
        help_text=_("Number of use of this password.")
    )
    objects = CountManager("password")
    def __unicode__(self):
        return u"%s (count: %i)" % (self.password, self.count)
    class Meta:
        ordering = ('-count',)


class HonypotIP(models.Model):
    ip_address = models.IPAddressField(db_index=True)
    count = models.PositiveIntegerField(default=1,
        help_text=_("Number of logins from this remote IP address.")
    )
    objects = CountManager("ip_address")
    def __unicode__(self):
        return u"%s (count: %i)" % (self.ip_address, self.count)
    class Meta:
        ordering = ('-count',)


class HonypotAuthManager(models.Manager):
    def add(self, request, username, password):
        ip_address = request.META["REMOTE_ADDR"]
        ip_address_obj = HonypotIP.objects.increase_or_add(ip_address)
        username_obj = HonypotUsername.objects.increase_or_add(username)
        password_obj = HonypotPassword.objects.increase_or_add(password)

        obj, created = self.get_or_create(
            username__exact=username_obj,
            password__exact=password_obj,
            ip_address__exact=ip_address_obj,
            defaults={
                "username":username_obj,
                "password":password_obj,
                "ip_address":ip_address_obj,
            }
        )
        if not created:
            obj.count += 1
            obj.save()
        return obj


class HonypotAuth(UpdateTimeBaseModel):
    """
    inherited attributes from UpdateTimeBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
    """
    objects = HonypotAuthManager()

    username = models.ForeignKey(HonypotUsername)
    password = models.ForeignKey(HonypotPassword)
    ip_address = models.ForeignKey(HonypotIP)
    count = models.PositiveIntegerField(default=1,
        help_text=_("Number of usage this username/password from the same remote IP address.")
    )

    def __unicode__(self):
        return u"honypot login from %s [%s/%s] (count: %i)" % (
            self.ip_address, self.username, self.password, self.count
        )

    class Meta:
        ordering = ('-lastupdatetime',)

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8


from django import forms
from django.utils.translation import ugettext as _

from dbpreferences.forms import DBPreferencesBaseForm


class AuthPreferencesForm(DBPreferencesBaseForm):
    ban_limit = forms.IntegerField(
        help_text=_("Numbers login log messages after IP would be banned."),
        initial=6, min_value=1, max_value=20
    )
    min_pause = forms.IntegerField(
        help_text=_("Minimum pause in seconds between two login log messages from the same user. (Used 'REMOTE_ADDR')"),
        initial=5, min_value=1, max_value=600
    )

    use_honypot = forms.BooleanField(
        help_text=_("Enable login honypot? (A PluginPage must be created!)"),
        initial=False, required=False
    )

    loop_count = forms.IntegerField(
        help_text=_(
            "Number of loops in the JS-SHA1-Process for repeatedly apply"
            " the client-nonce for hash based key stretching."
            " (Note: Higher count increase the security, but causes more CPU load on client and server.)"
        ),
        initial=15, min_value=1, max_value=600
    )

    https_urls = forms.BooleanField(
        help_text=_("Use https (secure http) for login forms?"),
        initial=False, required=False
    )

    class Meta:
        app_label = 'auth'

########NEW FILE########
__FILENAME__ = tests
# coding: utf-8


"""
    PyLucid JS-SHA-Login tests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    A secure JavaScript SHA-1 Login and a plaintext fallback login.
    
    TODO: Add tests for honypot, too.
    
    :copyleft: 2010-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


import os
import sys
import hashlib

if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#     tests = "pylucid_plugins.auth.tests.LoginTest.test_login_ajax_form"
#    tests = "pylucid_plugins.auth.tests.LoginTest.test_get_salt_csrf"
#    tests = "pylucid_plugins.auth.tests.LoginTest.test_get_salt_with_wrong_csrf_token"
#    tests = "pylucid_plugins.auth.tests.LoginTest.test_complete_login"
#    tests = "pylucid_plugins.auth.tests.LoginTest.test_without_get_challenge"

    from pylucid_project.tests import run_test_directly
    run_test_directly(tests,
        verbosity=2,
#        failfast=True,
        failfast=False,
    )
    sys.exit()

from django.core.cache import cache
from django.conf import settings
from django.test.client import Client

from pylucid_project.tests.test_tools import basetest
from pylucid_project.utils import crypt

from pylucid_project.pylucid_plugins.auth.models import CNONCE_CACHE
from preference_forms import AuthPreferencesForm


LOGIN_URL = "/en/welcome/?auth=login"



class LoginTest(basetest.BaseUnittest):
    def setUp(self):
        settings.DEBUG = False
        cache.clear()
        CNONCE_CACHE.clear() # delete all used client-nonce values 
        self.client = Client() # start a new session

    def test_login_link(self):
        response = self.client.get("/en/welcome/")
        self.assertDOM(response,
            must_contain=(
                '''<a href="#top" id="login_link" rel="nofollow" onclick="return get_pylucid_ajax_view('?auth=login');">Log in</a>''',
            )
        )

    def test_https_login_link(self):
        pref_form = AuthPreferencesForm()
        pref_form["https_urls"] = True
        pref_form.save()

        pref_form = AuthPreferencesForm()
        preferences = pref_form.get_preferences()
        self.assertTrue(preferences["https_urls"])

        response = self.client.get("/en/welcome/")
        self.assertDOM(response,
            must_contain=(
                '''<a href="#top" id="login_link" rel="nofollow" onclick="window.location.href = 'https://testserver/en/welcome/?auth=login'; return false;">Log in</a>''',
            )
        )

    def test_admin_login_page(self):
        """ Simple check if login link exist. """
        response = self.client.get("/admin/", HTTP_ACCEPT_LANGUAGE="en")
        self.assertAdminLoginPage(response)

    def test_login_redirect(self):
        """
        Check login redirect
        http://github.com/jedie/PyLucid/issues#issue/6
        """
        response = self.client.get("/pylucid_admin/menu/", HTTP_ACCEPT_LANGUAGE="en")
        self.assertRedirect(response, "http://testserver/admin/?next=/pylucid_admin/menu/")

    def test_non_ajax_request(self):
        response = self.client.get(LOGIN_URL)
        self.assertResponse(response,
            must_contain=(
                "<!DOCTYPE", "<title>PyLucid CMS", "<body", "<head>", # <- a complete page
                "JS-SHA-LogIn", "username", "var challenge=",
            ),
            must_not_contain=("Traceback", 'Permission denied')
        )

    def test_login_ajax_form(self):
        """ Check if we get the login form via AJAX
        FIXME: We get no ajax response, if unittests runs all tests, but it works
        if only this test runs, why?
        """
        response = self.client.get(LOGIN_URL, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertStatusCode(response, 200)
        self.assertDOM(response,
            must_contain=(
                '<input id="submit_button" type="submit" value="Log in" />',
            )
        )
        self.assertResponse(response,
            must_contain=(
                '<div class="PyLucidPlugins auth" id="auth_http_get_view">',
                "JS-SHA-LogIn", "username",
                # outside from django-compressor section:
                "var challenge=", "var next_url=",
            ),
            must_not_contain=(
                "<!DOCTYPE", "<title>PyLucid CMS", "<body", "<head>", # <- not a complete page
                "Traceback", 'Permission denied'
            ),
        )

    def test_wrong_form(self):
        settings.DEBUG = True

        response = self.client.post(
            "/en/welcome/?auth=sha_auth",
            {
                "username": "a",
                "sha_a": "not a SHA1 value 1",
                "sha_b": "not a SHA1 value 2",
                "cnonce": "not a SHA1 value 3",
            },
            HTTP_X_REQUESTED_WITH='XMLHttpRequest'
        )
        self.assertResponse(response,
            must_contain=('ShaLoginForm is not valid:',),
            must_not_contain=("Traceback", "<!DOCTYPE", "<body", "</html>")
        )

    def test_without_get_challenge(self):
        settings.DEBUG = True

        userdata = self._get_userdata("normal")
        username = userdata["username"]

        # start a session
        self.client.get("/en/welcome/")

        # send a login, before a challenge put into session,
        # because the login form was not requested in the past
        response = self.client.post(
            "/en/welcome/?auth=sha_auth",
            {
                "username": username,
                "sha_a": "0123456789abcdef0123456789abcdef01234567",
                "sha_b": "0123456789abcdef0123",
                "cnonce": "0123456789abcdef0123456789abcdef01234567",
            },
            HTTP_X_REQUESTED_WITH='XMLHttpRequest'
        )
        self.assertResponse(response,
            must_contain=("Can't get 'challenge' from session:",),
            must_not_contain=("Traceback", "<!DOCTYPE", "<body", "</html>")
        )

    def test_double_use_cnounce(self):
        settings.DEBUG = True

        userdata = self._get_userdata("normal")
        username = userdata["username"]

        for no in xrange(2):
            # Get the login form: The challenge value would be stored into session
            self.client.get("/en/welcome/?auth=login", HTTP_X_REQUESTED_WITH='XMLHttpRequest')
            self.failUnless("challenge" in self.client.session)

            # get the salt
            response = self.client.post(
                "/en/welcome/?auth=get_salt", {"username": username}, HTTP_X_REQUESTED_WITH='XMLHttpRequest'
            )
            self.assertStatusCode(response, 200)

            response = self.client.post(
                "/en/welcome/?auth=sha_auth",
                {
                    "username": username,
                    "sha_a": "0123456789abcdef0123456789abcdef01234567",
                    "sha_b": "0123456789abcdef0123",
                    "cnonce": "0123456789abcdef0123456789abcdef01234567",
                },
                HTTP_X_REQUESTED_WITH='XMLHttpRequest'
            )
            if no == 0:
                self.assertResponse(response,
                    must_contain=(
                        'auth.authenticate() failed.',
                        'must be a wrong password',
                    ),
                    must_not_contain=("Traceback", "<!DOCTYPE", "<body", "</html>")
                )
            elif no == 1:
                self.assertResponse(response,
                    must_contain=("Client-nonce '0123456789abcdef0123456789abcdef01234567' used in the past!",),
                    must_not_contain=("Traceback", "<!DOCTYPE", "<body", "</html>")
                )

    def test_DOS_attack(self):
        settings.DEBUG = True

        client = self.client
        userdata = self._get_userdata("normal")
        username = userdata["username"]
#        self.login("normal")
#        client.logout()

        # Get the login form: The challenge value would be stored into session
        client.get("/en/welcome/?auth=login", HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.failUnless("challenge" in client.session)

        pref_form = AuthPreferencesForm()
        preferences = pref_form.get_preferences()
        ban_limit = preferences["ban_limit"]

        # Hold if all events would been received.
        tested_first_login = False
        tested_under_limit = False
        tested_limit_reached = False
        tested_banned = False

        for no in xrange(1, ban_limit + 3):
            # get the salt
            response1 = client.post(
                "/en/welcome/?auth=get_salt", {"username": username}, HTTP_X_REQUESTED_WITH='XMLHttpRequest'
            )

            # every request must have a unique client-nonce
            cnonce = "%s0123456789abcdef0123456789abcdef01234567" % no
            cnonce = cnonce[:40]

            response2 = client.post(
                "/en/welcome/?auth=sha_auth",
                {
                    "username": username,
                    "sha_a": "0123456789abcdef0123456789abcdef01234567",
                    "sha_b": "0123456789abcdef0123",
                    "cnonce": cnonce,
                },
                HTTP_X_REQUESTED_WITH='XMLHttpRequest'
            )

            if no == 1:
                # first request, normal failed
                self.assertStatusCode(response1, 200)
                self.assertResponse(response2,
                    must_contain=(
                        'auth.authenticate() failed.',
                        'must be a wrong password)',
                    ),
                    must_not_contain=(
                        "Traceback", "Form errors", "field is required",
                        "<!DOCTYPE", "<body", "</html>",
                    )
                )
                self.assertStatusCode(response2, 200)
                tested_first_login = True
                self.failUnless(len(response1.content) == 12) # the salt

            elif no == ban_limit + 1:
                # The limit has been reached
                tested_banned = True
                self.assertResponse(response2, must_contain=('You are now banned.',))
                self.assertStatusCode(response2, 404)
                self.failUnless(len(response1.content) == 12) # the salt
            elif no > ban_limit:
                # IP is on the ban list
                tested_limit_reached = True
                self.assertStatusCode(response1, 403) # get forbidden page
                self.assertStatusCode(response2, 403) # get forbidden page
            else:
                # under ban limit: comment was saved, page should be reloaded
                tested_under_limit = True
                self.assertStatusCode(response1, 200)
                self.assertStatusCode(response2, 200)
                self.failUnless(len(response1.content) == 12) # the salt
                self.assertResponse(response2,
                    must_contain=(
                        'Request too fast!',
                        'IP is blocked by',
                    ),
                    must_not_contain=(
                        "Traceback", "Form errors", "field is required",
                        "<!DOCTYPE", "<body", "</html>",
                    )
                )

        # Check if all events have been received.
        self.failUnless(tested_first_login == True)
        self.failUnless(tested_limit_reached == True)
        self.failUnless(tested_under_limit == True)
        self.failUnless(tested_banned == True)

    def test_get_salt_with_wrong_csrf_token(self):
        settings.DEBUG = True
        user = self._get_user("normal")
        username = user.username
        user_profile = user.get_profile()
        salt = user_profile.sha_login_salt

        csrf_client = Client(enforce_csrf_checks=True)

        # Create session
        response = csrf_client.get(LOGIN_URL,
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
        )
        self.assertStatusCode(response, 200)
        sessionid = response.cookies["sessionid"]

        # send POST with sessionid but with wrong csrf token
        response = csrf_client.post(
            "/en/welcome/?auth=get_salt",
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
            HTTP_COOKIE=(
                "%s=1234567890abcdef1234567890abcdef;"
                "sessionid=%s"
            ) % (settings.CSRF_COOKIE_NAME, sessionid),
            data={
                "username": username,
            }
        )
        self.assertResponse(response,
            must_contain=(
                'Forbidden', 'CSRF verification failed.',
                'CSRF token missing or incorrect.',
            ),
            must_not_contain=(
                salt,
                "Traceback", "Form errors", "field is required",
            )
        )

    def test_get_salt_csrf(self):
        """
        https://github.com/jedie/PyLucid/issues/61
        """
        settings.DEBUG = True

        user = self._get_user("normal")
        username = user.username
        user_profile = user.get_profile()
        salt = user_profile.sha_login_salt

        csrf_client = Client(enforce_csrf_checks=True)

        response = csrf_client.get("/en/welcome/") # Put page into cache
        self.assertStatusCode(response, 200)

        # Get the CSRF token
        response = csrf_client.get(LOGIN_URL,
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
        )
        self.assertStatusCode(response, 200)
        csrf_cookie = response.cookies[settings.CSRF_COOKIE_NAME]
        csrf_token = csrf_cookie.value

        self.assertResponse(response,
            must_contain=(
                '<p id="load_info">loading...</p>',
            ),
            must_not_contain=(
                "Traceback", "Form errors", "field is required",
                csrf_token,
                "<!DOCTYPE", "<title>PyLucid CMS", "<body", "<head>", # <- not a complete page
            )
        )

        # Check if we get the salt, instead of a CSRF error
        response = csrf_client.post(
            "/en/welcome/?auth=get_salt",
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
            HTTP_X_CSRFTOKEN=csrf_token,
            data={
                "username": username,
            }
        )
        if response.content != salt:
            self.raise_browser_traceback(response,
                "Response content is not salt %r - content: %r" % (salt, response.content)
            )

        # remove client cookie and check if csrf protection works
        del(csrf_client.cookies[settings.CSRF_COOKIE_NAME])
        response = csrf_client.post(
            "/en/welcome/?auth=get_salt",
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
            data={
                "username": username,
            }
        )
        self.assertResponse(response,
            must_contain=(
                'Forbidden', 'CSRF verification failed.',
                'CSRF cookie not set.',
            ),
            must_not_contain=(
                salt, csrf_token,
                "Traceback", "Form errors", "field is required",
            )
        )

    def test_complete_login(self):
        cache.clear()

        test_userdata = self._get_userdata("normal")
        userpass = test_userdata["password"]

        user = self._get_user("normal")
        username = user.username

        csrf_client = Client(enforce_csrf_checks=True)

        response = csrf_client.get("/en/welcome/") # Put page into cache
        self.assertStatusCode(response, 200)

        # Get the CSRF token
        response = csrf_client.get(LOGIN_URL, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        csrf_cookie = response.cookies[settings.CSRF_COOKIE_NAME]
        csrf_token = csrf_cookie.value

        challenge = csrf_client.session["challenge"]
        self.assertResponse(response,
            must_contain=('var challenge="%s";' % challenge),
            must_not_contain=("Traceback", 'Permission denied'),
        )
        self.assertEqual(len(challenge), crypt.HASH_LEN)

        # Get the salt via AJAX
        response = csrf_client.post("/en/welcome/?auth=get_salt",
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
            HTTP_X_CSRFTOKEN=csrf_token,
            data={"username": username}
        )
        salt = response.content
        self.assertEqual(len(salt), crypt.SALT_LEN)

        # Build the response:
        shapass = hashlib.sha1(salt + userpass).hexdigest()
        sha_a = shapass[:20]
        sha_b = shapass[20:]

        pref_form = AuthPreferencesForm()
        preferences = pref_form.get_preferences()
        loop_count = preferences["loop_count"]
        cnonce = "0123456789abcdef0123456789abcdef01234567"

        for i in range(loop_count):
            sha_a = hashlib.sha1(
                "%s%s%s%s" % (sha_a, i, challenge, cnonce)
            ).hexdigest()

        # Login with calculated sha pass
        response = csrf_client.post("/en/welcome/?auth=sha_auth",
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
            HTTP_X_CSRFTOKEN=csrf_token,
            data={
                "username": username,
                "sha_a": sha_a,
                "sha_b": sha_b,
                "cnonce": cnonce,
            }
        )
        self.assertStatusCode(response, 200)
        self.assertEqual(response.content, "OK")

        # Check if we are really login:
        response = csrf_client.get("/en/welcome/")
        self.assertResponse(response,
            must_contain=(
                "You are logged in. Last login was:",
                '<a href="?auth=logout">Log out [%s]</a>' % username
            ),
            must_not_contain=(
                'Forbidden', 'CSRF verification failed.',
                'CSRF cookie not set.',
                "Traceback", "Form errors", "field is required",
            )
        )



########NEW FILE########
__FILENAME__ = test_settings

from pylucid_project.settings import *

DEBUG = True

# Database connection info.
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ':memory:'
    }
}

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8


from django.conf.urls.defaults import patterns, url

from pylucid_project.pylucid_plugins.auth import views


urlpatterns = patterns('',
    url(r'^', views.login_honeypot, name='Auth-login_honeypot'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8


"""
    PyLucid JS-SHA-Login
    ~~~~~~~~~~~~~~~~~~~~

    secure JavaScript SHA-1 AJAX Login
    more info:
        http://www.pylucid.org/permalink/42/secure-login-without-https

    :copyleft: 2007-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django.conf import settings
from django.contrib import auth, messages
from django.http import HttpResponse, HttpResponseRedirect
from django.template import RequestContext
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _
from django.shortcuts import render_to_response
from django.core import urlresolvers
from django.views.decorators.csrf import csrf_protect, csrf_exempt

from pylucid_project.apps.pylucid.decorators import check_request
from pylucid_project.apps.pylucid.models import LogEntry
from pylucid_project.apps.pylucid.models.pluginpage import PluginPage
from pylucid_project.apps.pylucid.shortcuts import bad_request, ajax_response
from pylucid_project.pylucid_plugins.auth.forms import HoneypotForm
from pylucid_project.pylucid_plugins.auth.models import HonypotAuth, \
    CNONCE_CACHE
from pylucid_project.utils import crypt

# auth own stuff
from forms import WrongUserError, UsernameForm, ShaLoginForm
from preference_forms import AuthPreferencesForm


APP_LABEL = "pylucid_plugin.auth" # used for creating LogEntry entries


# DEBUG is usefull for debugging. It send always the same challenge "12345"
# DEBUG = True
DEBUG = False
# IMPORTANT: Should really only use for debugging!!!
if DEBUG:
    import warnings
    warnings.warn("Debug mode in auth plugin is on! print statements would be used!")


def _get_challenge(request):
    """ create a new challenge, add it to session and return it"""
    if DEBUG:
        challenge = "12345"
        print("use DEBUG challenge: %r" % challenge)
    else:
        # Create a new random salt value for the password challenge:
        challenge = crypt.get_new_seed()

    # For later comparing with form data
    request.session["challenge"] = challenge

    return challenge

def _get_loop_count():
    pref_form = AuthPreferencesForm()
    preferences = pref_form.get_preferences()
    loop_count = preferences["loop_count"]
    return loop_count


@csrf_exempt
def login_honeypot(request):
    """
    A login honypot.
    """
    faked_login_error = False
    if request.method == 'POST':
        form = HoneypotForm(request.POST)
        if form.is_valid():
            username = form.cleaned_data["username"]
            password = form.cleaned_data["password"]
            HonypotAuth.objects.add(request, username, password)
            messages.error(request, _("username/password wrong."))
            form = HoneypotForm(initial={"username": username})
            faked_login_error = True
    else:
        form = HoneypotForm()
    context = {
        "form": form,
        "form_url": request.path,
        "page_robots": "noindex,nofollow",
    }

    response = render_to_response("auth/login_honeypot.html", context, context_instance=RequestContext(request))
    if faked_login_error:
        response.status_code = 401
    return response


def lucidTag(request):
    """
    Create login/logout link
    example: {% lucidTag auth %}
    """
    context = {
        "honypot_url": "#top" # Don't use honypot
    }
    if request.user.is_authenticated():
        template_name = "auth/logout_link.html"
        if hasattr(request.PYLUCID, "pagetree"):
            # We are on a normal cms page -> Dont's change the url
            url = ""
        else:
            # We are in the django admin panel -> Go to root page
            url = "/"
        url += "?auth=logout"
    else:
        pref_form = AuthPreferencesForm()
        preferences = pref_form.get_preferences()
        use_honypot = preferences["use_honypot"]
        if use_honypot:
            try: # Use the first PluginPage instance
                honypot_url = PluginPage.objects.reverse("auth", 'Auth-login_honeypot')
            except urlresolvers.NoReverseMatch, err:
                if settings.RUN_WITH_DEV_SERVER:
                    print "*** Can't get 'Auth-login_honeypot' url: %s" % err
            else:
                context["honypot_url"] = honypot_url

        https_urls = preferences["https_urls"]
        if not https_urls:
            template_name = "auth/login_link.html"
            url = ""
        else:
            # Use https for login
            template_name = "auth/login_link_https.html"
            url = "https://%s%s" % (request.get_host(), request.path)

        url += "?auth=login"

    context["url"] = url

    return render_to_string(template_name, context, context_instance=RequestContext(request))


def _wrong_login(request, debug_msg, user=None):
    """ username or password is wrong. """
    if settings.DEBUG:
        error_msg = debug_msg
    else:
        error_msg = _("Wrong username/password.")

    # Protection against DOS attacks.
    pref_form = AuthPreferencesForm()
    preferences = pref_form.get_preferences()
    min_pause = preferences["min_pause"]
    ban_limit = preferences["ban_limit"]
    try:
        LogEntry.objects.request_limit(
            request, min_pause, ban_limit, app_label="pylucid_plugin.auth", action="login error", no_page_msg=True
        )
    except LogEntry.RequestTooFast, err:
        # min_pause is not observed
        error_msg = unicode(err) # ugettext_lazy

    # Log this error (Important: must be logged after LogEntry.objects.request_limit() stuff!
    if user is not None:
        data = {"user_username": user.username}
    else:
        data = None
    LogEntry.objects.log_action(
        app_label="pylucid_plugin.auth", action="login error", message=debug_msg, data=data
    )

    # create a new challenge and add it to session
    challenge = _get_challenge(request)

    response = "%s;%s" % (challenge, error_msg)
    return HttpResponse(response, content_type="text/plain")



@check_request(app_label="pylucid_plugin.auth", action="_sha_auth() error", must_post=True, must_ajax=True)
@csrf_protect
def _sha_auth(request):
    """
    login the user with username and sha values.
    """
    _NORMAL_ERROR_MSG = "_sha_auth() error"

    form = ShaLoginForm(request.POST)
    if not form.is_valid():
        debug_msg = "ShaLoginForm is not valid: %s" % repr(form.errors)
        return bad_request(APP_LABEL, _NORMAL_ERROR_MSG, debug_msg)

    try:
        challenge = request.session.pop("challenge")
    except KeyError, err:
        debug_msg = "Can't get 'challenge' from session: %s" % err
        return bad_request(APP_LABEL, _NORMAL_ERROR_MSG, debug_msg)

    try:
        user1, user_profile = form.get_user_and_profile()
    except WrongUserError, err:
        debug_msg = "Can't get user and user profile: %s" % err
        return _wrong_login(request, debug_msg)

    loop_count = _get_loop_count() # get "loop_count" from AuthPreferencesForm

    sha_checksum = user_profile.sha_login_checksum
    sha_a = form.cleaned_data["sha_a"]
    sha_b = form.cleaned_data["sha_b"]
    cnonce = form.cleaned_data["cnonce"]

    # Simple check if 'nonce' from client used in the past.
    # Limitations:
    #  - Works only when run in a long-term server process, so not in CGI ;)
    #  - dict vary if more than one server process runs (one dict in one process)
    if cnonce in CNONCE_CACHE:
        debug_msg = "Client-nonce '%s' used in the past!" % cnonce
        return bad_request(APP_LABEL, _NORMAL_ERROR_MSG, debug_msg)
    CNONCE_CACHE[cnonce] = None

    if DEBUG:
        print(
            "authenticate %r with: challenge: %r, sha_checksum: %r, sha_a: %r, sha_b: %r, cnonce: %r" % (
                user1, challenge, sha_checksum, sha_a, sha_b, cnonce
            )
        )

    try:
        # authenticate with:
        # pylucid.system.auth_backends.SiteSHALoginAuthBackend
        user2 = auth.authenticate(
            user=user1, challenge=challenge,
            sha_a=sha_a, sha_b=sha_b,
            sha_checksum=sha_checksum,
            loop_count=loop_count, cnonce=cnonce
        )
    except Exception, err: # e.g. low level error from crypt
        debug_msg = "auth.authenticate() failed: %s" % err
        return _wrong_login(request, debug_msg, user1)

    if user2 is None:
        debug_msg = "auth.authenticate() failed. (must be a wrong password)"
        return _wrong_login(request, debug_msg, user1)
    else:
        # everything is ok -> log the user in and display "last login" page message
        last_login = user2.last_login
        auth.login(request, user2)
        message = render_to_string('auth/login_info.html', {"last_login":last_login})
        messages.success(request, message)
        return HttpResponse("OK", content_type="text/plain")


@check_request(app_label="pylucid_plugin.auth", action="_get_salt() error", must_post=True, must_ajax=True)
@csrf_protect
def _get_salt(request):
    """
    return the user password salt.
    If the user doesn't exist or is not active, return a pseudo salt.
    """
    user_profile = None
    form = UsernameForm(request.POST)
    if form.is_valid():
        try:
            user_profile = form.get_user_profile()
        except WrongUserError, err:
            msg = "can't get userprofile: %s" % err
            if DEBUG:
                print(msg)
            if settings.DEBUG:
                messages.error(request, msg)

    if user_profile is None: # Wrong user?
        username = request.POST["username"]
        msg = "Username %r is wrong: %r" % (username, form.errors)
        if DEBUG:
            print(msg)
        if settings.DEBUG:
            messages.error(request, msg)
        salt = crypt.get_pseudo_salt(username)
    else:
        salt = user_profile.sha_login_salt
        if len(salt) not in (crypt.SALT_LEN, crypt.OLD_SALT_LEN):
            # Old profile, e.g. after PyLucid v0.8 update?
            username = request.POST["username"]
            msg = "Salt for user %r has wrong length: %r" % (username, salt)
            if DEBUG:
                print(msg)
            if settings.DEBUG:
                messages.error(request, msg)
            salt = crypt.get_pseudo_salt(username)

    if DEBUG:
        print("send salt %r to client." % salt)

    return HttpResponse(salt, content_type="text/plain")


@csrf_protect
def _login_view(request):
    """
    For better JavaScript debugging: Enable settings.DEBUG and request the page
    via GET with: "...?auth=login"
    """
    if DEBUG:
        print("auth debug mode is on!")

    if request.method != 'GET':
        debug_msg = "request method %r wrong, only GET allowed" % request.method
        return bad_request(APP_LABEL, "_login_view() error", debug_msg) # Return HttpResponseBadRequest

    next_url = request.GET.get("next_url", request.path)

    if "//" in next_url: # FIXME: How to validate this better?
        # Don't redirect to other pages.
        debug_msg = "next url %r seems to be wrong!" % next_url
        return bad_request(APP_LABEL, "_login_view() error", debug_msg) # Return HttpResponseBadRequest

    form = ShaLoginForm()

    # create a new challenge and add it to session
    challenge = _get_challenge(request)

    try:
        # url from django-authopenid, only available if the urls.py are included
        reset_link = urlresolvers.reverse("auth_password_reset")
    except urlresolvers.NoReverseMatch:
        try:
            # DjangoBB glue plugin adds the urls from django-authopenid
            reset_link = PluginPage.objects.reverse("djangobb_plugin", "auth_password_reset")
        except KeyError:
            # plugin is not installed
            reset_link = None
        except urlresolvers.NoReverseMatch:
            # plugin is installed, but not in used (no PluginPage created)
            reset_link = None

    loop_count = _get_loop_count() # get "loop_count" from AuthPreferencesForm

    context = {
        "challenge": challenge,
        "old_salt_len": crypt.OLD_SALT_LEN,
        "salt_len": crypt.SALT_LEN,
        "hash_len": crypt.HASH_LEN,
        "loop_count": loop_count,
        "get_salt_url": request.path + "?auth=get_salt",
        "sha_auth_url": request.path + "?auth=sha_auth",
        "next_url": next_url,
        "form": form,
        "pass_reset_link": reset_link,
    }

    # IMPORTANT: We must do the following, so that the
    # CsrfViewMiddleware.process_response() would set the CSRF_COOKIE
    # see also # https://github.com/jedie/PyLucid/issues/61
    # XXX in Django => 1.4 we can use @ensure_csrf_cookie
    # https://docs.djangoproject.com/en/dev/ref/contrib/csrf/#django.views.decorators.csrf.ensure_csrf_cookie
    request.META["CSRF_COOKIE_USED"] = True

    # return a string for replacing the normal cms page content
    if not request.is_ajax():
        response = render_to_response('auth/sha_form_debug.html', context, context_instance=RequestContext(request))
    else:
        response = ajax_response(request, 'auth/sha_form.html', context, context_instance=RequestContext(request))

    return response


def _logout_view(request):
    """ Logout the current user. """
    auth.logout(request)
    messages.success(request, _("You are logged out!"))
    next_url = request.path
    return HttpResponseRedirect(next_url)


def http_get_view(request):
    """
    Login+Logout view via GET parameters
    """
    action = request.GET["auth"]

    if action == "login":
        return _login_view(request)
    elif action == "get_salt":
        return _get_salt(request)
    elif action == "sha_auth":
        return _sha_auth(request)
    elif action == "logout":
        return _logout_view(request)
    else:
        debug_msg = "Wrong get view parameter!"
        return bad_request(APP_LABEL, "http_get_view() error", debug_msg) # Return HttpResponseBadRequest



########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    PyLucid.admin
    ~~~~~~~~~~~~~~

    Register all PyLucid model in django admin interface.

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.contrib import admin
from django.contrib.admin.templatetags.admin_list import _boolean_icon
from django.contrib.sites.models import Site
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _

from django_tools.middlewares import ThreadLocal

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from pylucid_project.apps.pylucid.base_admin import BaseAdmin
from pylucid_project.apps.pylucid.markup.admin import MarkupPreview
from pylucid_project.apps.pylucid.models.pluginpage import PluginPage
from pylucid_project.pylucid_plugins.blog.models import BlogEntry, \
    BlogEntryContent


class BlogBaseAdmin(BaseAdmin, CompareVersionAdmin):

    change_list_template = "reversion/blog/change_list.html"

    def __init__(self, *args, **kwargs):
        self.plugin_pages = PluginPage.objects.filter(app_label__endswith="blog")
        super(BlogBaseAdmin, self).__init__(*args, **kwargs)

    def changelist_view(self, request, extra_context=None):
        extra_context = {"plugin_pages":self.plugin_pages}
        return super(BlogBaseAdmin, self).changelist_view(request, extra_context=extra_context)


class BlogEntryAdmin(BlogBaseAdmin):
    """
    Language independend Blog entry.
    
    inherited attributes from BaseAdmin:
        view_on_site_link -> html link with the absolute uri.
    """
    def contents(self, obj):
        contents = BlogEntryContent.objects.filter(entry=obj)
        for entry in contents:
            entry.is_public_html = _boolean_icon(entry.is_public)
        context = {
            "contents": contents
        }
        return render_to_string("admin/blog/entry_contents.html", context)
    contents.short_description = _("Edit existing content entries")
    contents.allow_tags = True

    def permalink(self, obj):
        """ view on site link in admin changelist, try to use complete uri with site info. """
        current_site = Site.objects.get_current()

        count = obj.sites.filter(id=current_site.id).count()
        if count == 0:
            # TODO: Create a link with the domain of the first site
            return u"<i>[not on current site]</i>"

        request = ThreadLocal.get_current_request()
        permalink = obj.get_permalink(request)
        if permalink is None:
            return u"<i>[no permalink available]</i>"

        context = {"permalink": permalink}
        html = render_to_string('admin/blog/permalink.html', context)
        return html
    permalink.allow_tags = True

    list_display = ("id", "is_public", "site_info", "contents", "permalink")
    list_filter = ("sites",)
admin.site.register(BlogEntry, BlogEntryAdmin)


class BlogEntryContentAdmin(BlogBaseAdmin, MarkupPreview):
    """
    Language depend blog entry content.
    
    inherited attributes from BaseAdmin:
        view_on_site_link -> html link with the absolute uri.
        
    inherited from MarkupPreview:
        ajax_markup_preview() -> the markup content ajax preview view
        get_urls()            -> add ajax view to admin urls 
    """
    list_display = ("id", "headline", "is_public", "view_on_site_link", "lastupdatetime", "lastupdateby", "createtime")
    list_display_links = ("headline",)
    list_filter = ("is_public", "createby", "lastupdateby",)
    date_hierarchy = 'lastupdatetime'
    search_fields = ("headline", "content")
    ordering = ('-lastupdatetime',)

admin.site.register(BlogEntryContent, BlogEntryContentAdmin)

########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from pylucid_project.apps.pylucid.markup.views import markup_preview

from blog import admin_views


urlpatterns = patterns('',
    url(r'^new_blog_entry/$', admin_views.new_blog_entry, name='Blog-new_blog_entry'),
    url(r'^new_blog_entry/preview/$', markup_preview, name='Blog-markup_preview'),

    url(r'^edit/(?P<id>\d+?)/$', admin_views.edit_blog_entry, name='Blog-edit_blog_entry'),
    url(r'^edit/\d+?/preview/$', markup_preview, name='Blog-edit_markup_preview'),

    url(r'^translate/(?P<id>\d+?)/$', admin_views.translate_blog_entry, name='Blog-translate'),
    url(r'^translate/\d+?/preview/$', markup_preview, name='Blog-translate_markup_preview'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding: utf-8

"""
    PyLucid blog plugin
    ~~~~~~~~~~~~~~~~~~~

    :copyleft: 2008-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django import http, forms
from django.contrib import messages
from django.contrib.sites.models import Site
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu
from pylucid_project.utils.site_utils import get_site_preselection

from pylucid_project.pylucid_plugins.blog.models import BlogEntry, \
    BlogEntryContent
from pylucid_project.pylucid_plugins.blog.forms import BlogForm, BlogContentForm
from pylucid_project.pylucid_plugins.blog.preference_forms import BlogPrefForm
from pylucid_project.apps.pylucid.models.language import Language
from pylucid_project.apps.i18n.views import select_language
from pylucid_project.apps.i18n.utils.translate import prefill
from pylucid_project.apps.pylucid.models.pluginpage import PluginPage




def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("create content")

    admin_menu.add_menu_entry(
        parent=menu_section_entry, url_name="Blog-new_blog_entry",
        name="new blog entry", title="Create a new blog entry.",
    )

    return "\n".join(output)


@check_permissions(superuser_only=False, permissions=("blog.add_blogentry",))
@render_to("blog/new_blog_entry.html")
def new_blog_entry(request):
    """
    TODO: Use Ajax in preview
    """
#    user_profile = request.user.get_profile()
    # All accessible sites from the current user:
#    user_site_ids = user_profile.sites.values_list("id", "name")
#    m2m_limit = {"sites": user_site_ids} # Limit the site choice field with LimitManyToManyFields

    try:
        plugin_page = PluginPage.objects.filter(app_label__endswith="blog")[0]
    except IndexError:
        messages.error(request, _("There exist no blog plugin page, yet. Please create one, first."))
        return http.HttpResponseRedirect("/")

    context = {
        "title": _("Create a new blog entry"),
        "form_url": request.path,
        "tag_cloud": BlogEntryContent.objects.get_tag_cloud(request),
        "add_tag_filter_link": False, # Don't add filters in tag cloud
    }

    if request.method == "POST":
        if "cancel" in request.POST:
            messages.info(request, _("Create new blog entry aborted, ok."))
            url = plugin_page.get_absolute_url()
            return http.HttpResponseRedirect(url)

        form = BlogForm(request.POST)
        if form.is_valid():
            new_entry = BlogEntry.objects.create()
            new_entry.sites = form.cleaned_data["sites"]
            new_entry.save()

            blog_content = form.save(commit=False)
            blog_content.entry = new_entry
            blog_content.save()

            messages.success(request, _("New blog entry '%s' saved.") % blog_content.headline)
            return http.HttpResponseRedirect(blog_content.get_absolute_url())
    else:
        # Get preferences
        pref_form = BlogPrefForm()

        initial = {
            "sites": get_site_preselection(pref_form, request), # preselect sites field
            "language": request.PYLUCID.current_language.pk, # preselect current language
        }
        form = BlogForm(initial=initial)

    context["form"] = form
    return context


@check_permissions(superuser_only=False, permissions=("blog.change_blogentry",))
@render_to("blog/edit_blog_entry.html")
def edit_blog_entry(request, id=None):
    if id is None:
        raise

    entry = BlogEntryContent.objects.get(pk=id)
    if request.method == "POST":
        if "cancel" in request.POST:
            messages.info(request, _("Edit blog entry aborted, ok."))
            url = entry.get_absolute_url()
            return http.HttpResponseRedirect(url)

        form = BlogContentForm(request.POST, instance=entry)
        if form.is_valid():
            instance = form.save()
            messages.success(request, "%r updated." % instance)
            return http.HttpResponseRedirect(instance.get_absolute_url())
    else:
        form = BlogContentForm(instance=entry)

    return {
        "title": _("Edit a blog entry"),
        "form": form,
    }


@check_permissions(superuser_only=False, permissions=("blog.change_blogentry",))
@render_to()
def translate_blog_entry(request, id=None):
    if id is None:
        raise

    source_entry = BlogEntryContent.objects.get(pk=id)
    absolute_url = source_entry.get_absolute_url()

    # select the destination language
    result = select_language(request, absolute_url, source_entry.language, source_entry.headline)
    if isinstance(result, Language):
        # Language was selected or they exit only one other language
        dest_language = result
    elif isinstance(result, dict):
        # template context returned -> render language select form
        return result
    elif isinstance(result, http.HttpResponse):
        # e.g. error
        return result
    else:
        raise RuntimeError() # Should never happen


    context = {
        "title": _("Translate a blog entry"),
        "template_name": "blog/translate_blog_entry.html",
        "abort_url": absolute_url,
    }

    try:
        dest_entry = BlogEntryContent.objects.get(entry=source_entry.entry, language=dest_language)
    except BlogEntryContent.DoesNotExist:
        dest_entry = None
        dest_initial = {
            "entry": source_entry.entry,
            "language":dest_language,
            "markup": source_entry.markup,
            "is_public": source_entry.is_public,
        }

    if request.method == "POST":
        source_form = BlogContentForm(request.POST, prefix="source", instance=source_entry)

        if dest_entry is None:
            dest_form = BlogContentForm(request.POST, prefix="dest", initial=dest_initial)
        else:
            dest_form = BlogContentForm(request.POST, prefix="dest", instance=dest_entry)

        if "autotranslate" in request.POST:
            if source_form.is_valid():
                dest_form, filled_fields, errors = prefill(
                    source_form, dest_form,
                    source_entry.language, dest_language,
                    only_fields=("headline", "content"),
                    #debug=True,
                )
                if filled_fields:
                    messages.success(request, "These fields are translated with google: %s" % ", ".join(filled_fields))
                else:
                    messages.info(request, "No fields translated with google, because all fields have been a translation.")
                if errors:
                    for error in errors:
                        messages.error(request, error)
        else:
            if source_form.is_valid() and dest_form.is_valid():
                # All forms are valid -> Save all.
                source_form.save()
                dest_entry2 = dest_form.save(commit=False)
                dest_entry2.entry = source_entry.entry
                dest_entry2.save()
                if dest_entry is None:
                    messages.success(request, "All saved. New entry %r created." % dest_entry2)
                else:
                    messages.success(request, "All saved.")
                return http.HttpResponseRedirect(dest_entry2.get_absolute_url())
    else:
        source_form = BlogContentForm(prefix="source", instance=source_entry)
        if dest_entry is None:
            dest_form = BlogContentForm(prefix="dest", initial=dest_initial)
        else:
            dest_form = BlogContentForm(prefix="dest", instance=dest_entry)

    source_fields = []
    dest_fields = []
    line_fields = []
    for source_field, dest_field in zip(source_form, dest_form):
        assert source_field.name == dest_field.name
        if source_field.name in ("content", "language", "markup"):
            # Fields witch displayed side by side.
            source_fields.append(source_field)
            dest_fields.append(dest_field)
        else:
            # Fields witch renders alternating one below the other.
            source_field.language = source_entry.language
            line_fields.append(source_field)
            dest_field.language = dest_language
            line_fields.append(dest_field)

    if source_form.errors or dest_form.errors:
        has_errors = True
    else:
        has_errors = False

    context.update({
        "source_entry": source_entry,
        "dest_language": dest_language,
        "source_form": source_form,
        "dest_form": dest_form,
        "all_forms": [source_form, dest_form],
        "has_errors": has_errors,
        "source_fields": source_fields,
        "dest_fields": dest_fields,
        "line_fields": line_fields,
    })
    return context

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

"""
    PyLucid blog forms
    ~~~~~~~~~~~~~~~~~~

    Forms for the blog.

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django import forms
from django.conf import settings
from django.contrib.sites.models import Site
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.forms.utils import TagLanguageSitesFilter

from pylucid_project.pylucid_plugins.blog.models import BlogEntryContent


class BlogContentForm(TagLanguageSitesFilter, forms.ModelForm):
    """
    Like a normal model form. But it protects against overwriting newer content:
    * Save the last update time in a hidden field
    * Check if the current last update time is newer
    * Add a checkbox for overwrite newer changes

    Example:
    Last edit was at 12:00
    User A starts editing (hidden field == 12:00)
    User B starts editing (hidden field == 12:00)
    User B saves at 12:02 -> new last edit time is now 12:02
    User A saves later than User B:
        * In his form was save the last edit at 12:00, but now the instance
          has the last edit time 12:02
        * User A get the form back with a form error in a new checkbox field
    User A must activate the checkbox and saves the form again, to overwrite.
    """
    sites_filter = "entry__sites__id__in" # for TagLanguageSitesFilter
    
    last_update = forms.DateTimeField(
        widget = forms.widgets.HiddenInput
    )
    overwrite = forms.BooleanField(required=False,
        help_text="Activate this for overwrite the current blog entry.",
        widget = forms.widgets.HiddenInput
    )

    def clean(self):
        cleaned_data = super(BlogContentForm, self).clean()
        old_last_update = cleaned_data["last_update"]
        last_save_datetime = self.instance.lastupdatetime
        last_save_datetime = last_save_datetime.replace(microsecond=0) # strip microseconds
        if last_save_datetime > old_last_update and not cleaned_data.get("overwrite", False):
            # The entry was save before from a other user and overwrite was not checked, yet.
            msg = (
                "This blog entry was changed by user '%s' since you edit it!"
                " Activate this checkbox to save anyway."
            ) % self.instance.lastupdateby
            if settings.DEBUG:
                msg += " (current: %s - your old: %s)" % (last_save_datetime, old_last_update)

            self._errors["overwrite"] = self.error_class([msg])

            # Add the overwrite checkbox to the form by make it visible:
            self.fields["overwrite"].widget = forms.widgets.CheckboxInput()

        return cleaned_data

    def __init__(self, *args, **kwargs):
        super(BlogContentForm, self).__init__(*args, **kwargs)
        # Saves the current last update time as the *initial* value:
        self.fields["last_update"].initial = self.instance.lastupdatetime

    class Meta:
        model = BlogEntryContent
        exclude = ("entry",)

class BlogForm(TagLanguageSitesFilter, forms.ModelForm):
    """
    Form for create/edit a blog entry.
    """
    sites_filter = "entry__sites__id__in" # for TagLanguageSitesFilter
    sites = forms.MultipleChoiceField(
        # choices= Set in __init__, so the Queryset would not execute at startup
        help_text=_("On which site should this entry exists?")
    )

    def __init__(self, *args, **kwargs):
        super(BlogForm, self).__init__(*args, **kwargs)
        self.fields["sites"].choices = Site.objects.all().values_list("id", "name")
        self.fields["sites"].initial = settings.SITE_ID

    class Meta:
        model = BlogEntryContent
        exclude = ("entry",)

########NEW FILE########
__FILENAME__ = 0001_initial
# encoding: utf-8
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        
        # Adding model 'BlogEntry'
        db.create_table('blog_blogentry', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='blogentry_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='blogentry_lastupdateby', null=True, to=orm['auth.User'])),
            ('headline', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('content', self.gf('pylucid_project.apps.pylucid.fields.MarkupContentModelField')()),
            ('markup', self.gf('pylucid_project.apps.pylucid.fields.MarkupModelField')()),
            ('language', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.Language'])),
            ('tags', self.gf('django_tools.tagging_addon.fields.jQueryTagModelField')()),
            ('is_public', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal('blog', ['BlogEntry'])

        # Adding M2M table for field sites on 'BlogEntry'
        db.create_table('blog_blogentry_sites', (
            ('id', models.AutoField(verbose_name='ID', primary_key=True, auto_created=True)),
            ('blogentry', models.ForeignKey(orm['blog.blogentry'], null=False)),
            ('site', models.ForeignKey(orm['sites.site'], null=False))
        ))
        db.create_unique('blog_blogentry_sites', ['blogentry_id', 'site_id'])


    def backwards(self, orm):
        
        # Deleting model 'BlogEntry'
        db.delete_table('blog_blogentry')

        # Removing M2M table for field sites on 'BlogEntry'
        db.delete_table('blog_blogentry_sites')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'blog.blogentry': {
            'Meta': {'ordering': "('-createtime', '-lastupdatetime')", 'object_name': 'BlogEntry'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentry_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'headline': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentry_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'pylucid.language': {
            'Meta': {'ordering': "('code',)", 'object_name': 'Language'},
            'code': ('django_tools.fields.language_code.LanguageCodeModelField', [], {'unique': 'True', 'max_length': '10'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['blog']

########NEW FILE########
__FILENAME__ = 0002_split_by_language_1_data_migration
# encoding: utf-8

"""
    Split the blog model into two models with
    language depend and independent informations.

    see also:
    
    https://github.com/jedie/PyLucid/issues/28
    https://github.com/jedie/PyLucid/issues/64
    
    First we create the new table and do a data migration.
    In second step we remove all unused columns from BlogEntry model.
"""

import datetime

from south.db import db
from south.v2 import SchemaMigration

from django.conf import settings
from django.db import models
from django.template.defaultfilters import slugify


class Migration(SchemaMigration):

    no_dry_run = True # Data migrations shouldn't be dry-run

    def forwards(self, orm):
        # Adding model 'BlogEntryContent'
        db.create_table('blog_blogentrycontent', (
            ('id', self.gf('django.db.models.fields.AutoField')(primary_key=True)),
            ('createtime', self.gf('django.db.models.fields.DateTimeField')(auto_now_add=True, blank=True)),
            ('lastupdatetime', self.gf('django.db.models.fields.DateTimeField')(auto_now=True, blank=True)),
            ('createby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='blogentrycontent_createby', null=True, to=orm['auth.User'])),
            ('lastupdateby', self.gf('django.db.models.fields.related.ForeignKey')(blank=True, related_name='blogentrycontent_lastupdateby', null=True, to=orm['auth.User'])),
            ('entry', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['blog.BlogEntry'])),
            ('headline', self.gf('django.db.models.fields.CharField')(max_length=255)),
            ('slug', self.gf('django.db.models.fields.SlugField')(db_index=True, max_length=255, blank=True)),
            ('content', self.gf('pylucid_project.apps.pylucid.fields.MarkupContentModelField')()),
            ('markup', self.gf('pylucid_project.apps.pylucid.fields.MarkupModelField')()),
            ('language', self.gf('django.db.models.fields.related.ForeignKey')(to=orm['pylucid.Language'])),
            ('tags', self.gf('django_tools.tagging_addon.fields.jQueryTagModelField')()),
            ('is_public', self.gf('django.db.models.fields.BooleanField')(default=True)),
        ))
        db.send_create_signal('blog', ['BlogEntryContent'])

        print "\tDo datamigration of blog entries:",
        for entry in orm.BlogEntry.objects.all():
            print entry.pk,
            new_entry = orm.BlogEntryContent.objects.create(
                entry=entry,
                createby=entry.createby,
                lastupdateby=entry.lastupdateby,
                headline=entry.headline,
                slug=slugify(entry.headline),
                content=entry.content,
                markup=entry.markup,
                language=entry.language,
                tags=entry.tags,
                is_public=entry.is_public,
            )

            # Temorary disable auto new function
            # see: http://stackoverflow.com/questions/7499767/temporarily-disable-auto-now-auto-now-add
            for field in new_entry._meta.local_fields:
                if field.name == "lastupdatetime":
                    field.auto_now = False
                elif field.name == "createtime":
                    field.auto_now_add = False

            new_entry.createtime = entry.createtime
            new_entry.lastupdatetime = entry.lastupdatetime
            new_entry.save()

            for field in new_entry._meta.local_fields:
                if field.name == "lastupdatetime":
                    field.auto_now = True
                elif field.name == "createtime":
                    field.auto_now_add = True
        print "done."


    def backwards(self, orm):
        raise RuntimeError("Cannot reverse this migration.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'blog.blogentry': {
            'Meta': {'ordering': "('-createtime', '-lastupdatetime')", 'object_name': 'BlogEntry'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentry_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'headline': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentry_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': [settings.SITE_ID], 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {})
        },
        'blog.blogentrycontent': {
            'Meta': {'ordering': "('-createtime', '-lastupdatetime')", 'object_name': 'BlogEntryContent'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentrycontent_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'entry': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['blog.BlogEntry']"}),
            'headline': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentrycontent_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {}),
            'slug': ('django.db.models.fields.SlugField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'pylucid.language': {
            'Meta': {'ordering': "('code',)", 'object_name': 'Language'},
            'code': ('django_tools.fields.language_code.LanguageCodeModelField', [], {'unique': 'True', 'max_length': '10'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': [settings.SITE_ID], 'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['blog']

########NEW FILE########
__FILENAME__ = 0003_split_by_language_2_cleanup
# encoding: utf-8

"""
    Second step: Delete obsolete column in BlogEntry model
"""

import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models

class Migration(SchemaMigration):

    def forwards(self, orm):
        # Deleting field 'BlogEntry.createby'
        db.delete_column('blog_blogentry', 'createby_id')

        # Deleting field 'BlogEntry.lastupdatetime'
        db.delete_column('blog_blogentry', 'lastupdatetime')

        # Deleting field 'BlogEntry.tags'
        db.delete_column('blog_blogentry', 'tags')

        # Deleting field 'BlogEntry.lastupdateby'
        db.delete_column('blog_blogentry', 'lastupdateby_id')

        # Deleting field 'BlogEntry.language'
        db.delete_column('blog_blogentry', 'language_id')

        # Deleting field 'BlogEntry.headline'
        db.delete_column('blog_blogentry', 'headline')

        # Deleting field 'BlogEntry.markup'
        db.delete_column('blog_blogentry', 'markup')

        # Deleting field 'BlogEntry.content'
        db.delete_column('blog_blogentry', 'content')

        # Deleting field 'BlogEntry.createtime'
        db.delete_column('blog_blogentry', 'createtime')


    def backwards(self, orm):
        raise RuntimeError("Cannot reverse this migration.")

    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'blog.blogentry': {
            'Meta': {'object_name': 'BlogEntry'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'})
        },
        'blog.blogentrycontent': {
            'Meta': {'ordering': "('-createtime', '-lastupdatetime')", 'object_name': 'BlogEntryContent'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentrycontent_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'entry': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['blog.BlogEntry']"}),
            'headline': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentrycontent_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {}),
            'slug': ('django.db.models.fields.SlugField', [], {'db_index': 'True', 'max_length': '255', 'blank': 'True'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'pylucid.language': {
            'Meta': {'ordering': "('code',)", 'object_name': 'Language'},
            'code': ('django_tools.fields.language_code.LanguageCodeModelField', [], {'unique': 'True', 'max_length': '10'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'auto_now_add': 'True', 'blank': 'True'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'auto_now': 'True', 'blank': 'True'}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['blog']

########NEW FILE########
__FILENAME__ = 0004_unique_on_date
# -*- coding: utf-8 -*-
import datetime
from south.db import db
from south.v2 import SchemaMigration
from django.db import models


class Migration(SchemaMigration):

    no_dry_run = True # Data migrations shouldn't be dry-run

    def forwards(self, orm):
        # Adding field 'BlogEntryContent.date'
        db.add_column('blog_blogentrycontent', 'url_date',
                      self.gf('django.db.models.fields.DateField')(default=datetime.datetime.now),
                      keep_default=False)

        print "\tDo datamigration of blog entries:",
        for instance in orm.BlogEntryContent.objects.all():
            print instance.pk,
            instance.url_date = instance.createtime
            instance.save()
        print

        print "\tMake all blog entries unique:"
        pks = orm.BlogEntryContent.objects.all().order_by('createtime', 'lastupdatetime').values_list("pk", flat=True)
        for pk in pks:
            instance = orm.BlogEntryContent.objects.get(pk=pk)
            # Test only if slug is unique and change slug + headline if not
            queryset = orm.BlogEntryContent.objects.all().order_by('createtime', 'lastupdatetime').filter(
                language = instance.language,
                url_date = instance.url_date,
                slug = instance.slug,
            )
            queryset = queryset.exclude(pk=instance.pk)
            for no, instance2 in enumerate(queryset, 2):
                print "\t old:", instance2.pk, instance2.slug, instance2.headline
                suffix = "%s" % no
                instance2.slug += suffix
                instance2.headline += suffix
                instance2.save()
                print "\t new:", instance2.pk, instance2.slug, instance2.headline
        print

        # Adding unique constraint on 'BlogEntryContent', fields ['url_date', 'headline', 'language']
        db.create_unique('blog_blogentrycontent', ['url_date', 'slug', 'language_id'])

        # Adding unique constraint on 'BlogEntryContent', fields ['url_date', 'headline', 'language']
        db.create_unique('blog_blogentrycontent', ['url_date', 'headline', 'language_id'])  


    def backwards(self, orm):
        # Removing unique constraint on 'BlogEntryContent', fields ['url_date', 'headline', 'language']
        db.delete_unique('blog_blogentrycontent', ['url_date', 'slug', 'language_id'])

        # Removing unique constraint on 'BlogEntryContent', fields ['url_date', 'headline', 'language']
        db.delete_unique('blog_blogentrycontent', ['url_date', 'headline', 'language_id'])

        # Deleting field 'BlogEntryContent.date'
        db.delete_column('blog_blogentrycontent', 'url_date')


    models = {
        'auth.group': {
            'Meta': {'object_name': 'Group'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '80'}),
            'permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'})
        },
        'auth.permission': {
            'Meta': {'ordering': "('content_type__app_label', 'content_type__model', 'codename')", 'unique_together': "(('content_type', 'codename'),)", 'object_name': 'Permission'},
            'codename': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'content_type': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['contenttypes.ContentType']"}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        },
        'auth.user': {
            'Meta': {'object_name': 'User'},
            'date_joined': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'email': ('django.db.models.fields.EmailField', [], {'max_length': '75', 'blank': 'True'}),
            'first_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'groups': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Group']", 'symmetrical': 'False', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_active': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'is_staff': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'is_superuser': ('django.db.models.fields.BooleanField', [], {'default': 'False'}),
            'last_login': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'last_name': ('django.db.models.fields.CharField', [], {'max_length': '30', 'blank': 'True'}),
            'password': ('django.db.models.fields.CharField', [], {'max_length': '128'}),
            'user_permissions': ('django.db.models.fields.related.ManyToManyField', [], {'to': "orm['auth.Permission']", 'symmetrical': 'False', 'blank': 'True'}),
            'username': ('django.db.models.fields.CharField', [], {'unique': 'True', 'max_length': '30'})
        },
        'blog.blogentry': {
            'Meta': {'object_name': 'BlogEntry'},
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'blog.blogentrycontent': {
            'Meta': {'ordering': "('-createtime', '-lastupdatetime')", 'unique_together': "(('language', 'url_date', 'headline'), ('language', 'url_date', 'headline'))", 'object_name': 'BlogEntryContent'},
            'content': ('pylucid_project.apps.pylucid.fields.MarkupContentModelField', [], {'blank': 'True'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentrycontent_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'url_date': ('django.db.models.fields.DateField', [], {'default': 'datetime.datetime.now'}),
            'entry': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['blog.BlogEntry']"}),
            'headline': ('django.db.models.fields.CharField', [], {'max_length': '255'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'is_public': ('django.db.models.fields.BooleanField', [], {'default': 'True'}),
            'language': ('django.db.models.fields.related.ForeignKey', [], {'to': "orm['pylucid.Language']"}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'blogentrycontent_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'markup': ('pylucid_project.apps.pylucid.fields.MarkupModelField', [], {}),
            'slug': ('django.db.models.fields.SlugField', [], {'max_length': '255', 'blank': 'True'}),
            'tags': ('django_tools.tagging_addon.fields.jQueryTagModelField', [], {})
        },
        'contenttypes.contenttype': {
            'Meta': {'ordering': "('name',)", 'unique_together': "(('app_label', 'model'),)", 'object_name': 'ContentType', 'db_table': "'django_content_type'"},
            'app_label': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'model': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '100'})
        },
        'pylucid.language': {
            'Meta': {'ordering': "('code',)", 'object_name': 'Language'},
            'code': ('django_tools.fields.language_code.LanguageCodeModelField', [], {'unique': 'True', 'max_length': '10'}),
            'createby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_createby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'createtime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'description': ('django.db.models.fields.CharField', [], {'max_length': '150', 'blank': 'True'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'lastupdateby': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_lastupdateby'", 'null': 'True', 'to': "orm['auth.User']"}),
            'lastupdatetime': ('django.db.models.fields.DateTimeField', [], {'default': 'datetime.datetime.now'}),
            'permitViewGroup': ('django.db.models.fields.related.ForeignKey', [], {'blank': 'True', 'related_name': "'language_permitViewGroup'", 'null': 'True', 'to': "orm['auth.Group']"}),
            'sites': ('django.db.models.fields.related.ManyToManyField', [], {'default': '[1]', 'to': "orm['sites.Site']", 'symmetrical': 'False'})
        },
        'sites.site': {
            'Meta': {'ordering': "('domain',)", 'object_name': 'Site', 'db_table': "'django_site'"},
            'domain': ('django.db.models.fields.CharField', [], {'max_length': '100'}),
            'id': ('django.db.models.fields.AutoField', [], {'primary_key': 'True'}),
            'name': ('django.db.models.fields.CharField', [], {'max_length': '50'})
        }
    }

    complete_apps = ['blog']
########NEW FILE########
__FILENAME__ = models
# coding: utf-8

"""
    PyLucid blog models
    ~~~~~~~~~~~~~~~~~~~

    Database models for the blog.

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.contrib import messages
from django.core import urlresolvers
from django.core.cache import cache
from django.core.paginator import Paginator, InvalidPage, EmptyPage
from django.db import models
from django.db.models import signals
from django.template.defaultfilters import slugify
from django.utils.translation import ugettext_lazy as _
try:
    from django.utils.timezone import now
except ImportError:
    from datetime import datetime
    now = datetime.now

# http://code.google.com/p/django-tagging/
from tagging.models import Tag, TaggedItem
from tagging.utils import calculate_cloud, LOGARITHMIC

# http://code.google.com/p/django-tools/
from django_tools.models import UpdateInfoBaseModel
from django_tools.tagging_addon.fields import jQueryTagModelField

from pylucid_project.apps.pylucid.models import Language, PluginPage
from pylucid_project.apps.pylucid.system.i18n import change_url_language
from pylucid_project.apps.pylucid.system.permalink import plugin_permalink
from pylucid_project.base_models.base_markup_model import MarkupBaseModel
from pylucid_project.base_models.base_models import BaseModelManager
from pylucid_project.base_models.many2many import SiteM2M
from pylucid_project.pylucid_plugins import update_journal
from pylucid_project.pylucid_plugins.blog.preference_forms import BlogPrefForm, get_preferences
from pylucid_project.utils.i18n_utils import filter_by_language




TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


#DEBUG_LANG_FILTER = True
DEBUG_LANG_FILTER = False


class BlogEntry(SiteM2M):
    """
    Language independend Blog entry.
    
    inherited attributes from AutoSiteM2M:
        sites     -> ManyToManyField to Site
        on_site   -> sites.managers.CurrentSiteManager instance
        site_info -> a string with all site names, for admin.ModelAdmin list_display
    """
    is_public = models.BooleanField(
        default=True, help_text=_(
            "Is this entry is public viewable?"
            " (If not checked: Every language is non-public,"
            "  otherwise: Public only in the language, if there even set 'is public'.)"
        )
    )

    def save(self, *args, **kwargs):
        """
        Clean the complete cache.
        
        FIXME: clean only the blog summary and detail page:
            http://www.python-forum.de/topic-22739.html (de)
        """
        super(BlogEntry, self).save(*args, **kwargs)

        try:
            cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
        except AttributeError:
            # No SmoothCacheBackend used -> clean the complete cache
            cache.clear()

    def get_permalink(self, request, slug=None):
        """
        permalink to this entry (language indepent)
        """
        if slug is None:
            # Add language depend slug, but we didn't use it in permalink_view()
            prefered_languages = request.PYLUCID.languages
            queryset = BlogEntryContent.objects.filter(entry=self).only("slug")
            try:
                slug = queryset.filter(language__in=prefered_languages)[0].slug
            except IndexError:# BlogEntryContent.DoesNotExist
                # no content exist
                return

        reverse_kwargs = {"id": self.id, "slug": slug}
        viewname = "Blog-permalink_view"
        try:
            # This only worked inner lucidTag
            url = urlresolvers.reverse(viewname, kwargs=reverse_kwargs)
        except urlresolvers.NoReverseMatch, err:
            if settings.RUN_WITH_DEV_SERVER:
                print "*** Blog entry url reverse error 1: %s" % err
            # Use the first PluginPage instance
            try:
                url = PluginPage.objects.reverse("blog", viewname, kwargs=reverse_kwargs)
            except urlresolvers.NoReverseMatch, err:
                if settings.RUN_WITH_DEV_SERVER:
                    print "*** Blog entry url reverse error 2: %s" % err
                return "#No-Blog-PagePlugin-exists"

        if hasattr(request.PYLUCID, "pagemeta"):
            # we on the cms pages and not in admin
            permalink = plugin_permalink(request, url)
        else:
            # we are e.g. in admin page
            permalink = url

        return permalink

    def __unicode__(self):
        return "Blog entry %i" % self.pk


class BlogEntryContentManager(BaseModelManager):
    """
    inherited from BaseModelManager:
        get_by_prefered_language() method:
            return a item from queryset in this way:
             - try to get in current language
             - if not exist: try to get in system default language
             - if not exist: use the first found item
    """
    def all_accessible(self, request, filter_language=False):
        """ returns a queryset of all blog entries that the current user can access. """
        filters = self.get_filters(request, filter_language=filter_language)
        return self.model.objects.filter(**filters)

    def get_filters(self, request, filter_language=True):
        """
        Construct queryset filter kwargs, to limit the queryset for the current user
        """
        filters = {"entry__sites__id__exact": settings.SITE_ID}

        if filter_language:
            # Filter by language
            preferences = get_preferences()
            language_filter = preferences["language_filter"]
            if DEBUG_LANG_FILTER:
                messages.debug(request, "language filter: %s" % language_filter)

            if language_filter == BlogPrefForm.CURRENT_LANGUAGE:
                # Display only blog entries in current language (select on the page)             
                filters["language"] = request.PYLUCID.current_language
            elif language_filter == BlogPrefForm.PREFERED_LANGUAGES:
                # Filter by client prefered languages (set in browser and send by HTTP_ACCEPT_LANGUAGE header)
                filters["language__in"] = request.PYLUCID.languages

        if not request.user.has_perm("blog.change_blogentry") or not request.user.has_perm("blog.change_blogentrycontent"):
            filters["entry__is_public"] = True
            filters["is_public"] = True

        if DEBUG_LANG_FILTER:
            messages.debug(request, "queryset filter: %s" % repr(filters))

        return filters

    def get_prefiltered_queryset(self, request, tags=None, filter_language=True):
        if tags is not None:
            # filter by tags
            queryset = TaggedItem.objects.get_by_model(self.model, tags)
        else:
            queryset = self.model.objects.all()

        filters = self.get_filters(request, filter_language=True)
        queryset = queryset.filter(**filters)
        return queryset

    def get_tag_cloud(self, request, filter_language=True):
        filters = self.get_filters(request, filter_language=filter_language)
        tag_cloud = Tag.objects.cloud_for_model(self.model, steps=2, filters=filters)
        return tag_cloud

    def cloud_for_queryset(self, queryset, steps=2, distribution=LOGARITHMIC, min_count=None):
        """
        returns the tag cloud for the given queryset
        See: https://code.google.com/p/django-tagging/issues/detail?id=137
        """
        tags = list(
            Tag.objects.usage_for_queryset(queryset, counts=True, min_count=min_count)
        )
        return calculate_cloud(tags, steps, distribution)

    def paginate(self, request, queryset, max_count):
        """ Limit the queryset with django Paginator and returns the Paginator instance """
        # Show max_count entries per page
        paginator = Paginator(queryset, max_count)

        # Make sure page request is an int. If not, deliver first page.
        try:
            page = int(request.GET.get('page', '1'))
        except ValueError:
            page = 1

        # If page request (9999) is out of range, deliver last page of results.
        try:
            return paginator.page(page)
        except (EmptyPage, InvalidPage):
            return paginator.page(paginator.num_pages)

    def paginator_by_queryset(self, request, queryset, max_count):
        # To get allways the same paginate count, we create first a list of all BlogEntry ids
        all_entry_ids = tuple(queryset.values_list("entry", flat=True))
        # print "all_entry_ids:", all_entry_ids

        paginator = self.paginate(request, all_entry_ids, max_count)
        entry_ids = paginator.object_list
        # print "entry_ids:", entry_ids

        # Create a new QuerySet with all content entries on current paginator page        
        queryset = self.model.objects.filter(entry__in=entry_ids)

        # filter by client prefered languages (set in browser and send by HTTP_ACCEPT_LANGUAGE header)
        prefered_languages_pk = tuple([lang.pk for lang in request.PYLUCID.languages])
        # print "prefered_languages_pk:", prefered_languages_pk
        queryset = queryset.filter(language__in=prefered_languages_pk)

        # Create a list of content id's which the best language match
        values_list = queryset.values_list("pk", "entry", "language")
        # print "values_list:", values_list
        used_ids = filter_by_language(values_list, prefered_languages_pk)
        # print "used_ids:", used_ids

        # Get the current blog content we display on the current paginator page
        used_content = self.model.objects.filter(pk__in=used_ids)
        paginator.object_list = used_content

        return paginator

    def get_filtered_queryset(self, request, tags=None, filter_language=True):
        """
        returns paginator with all blog entries
        e.g. for summary
        """
        queryset = self.get_prefiltered_queryset(request, tags=tags, filter_language=filter_language)

        # Get number of entries allowed by the users see on a page. 
        preferences = get_preferences()
        if request.user.is_anonymous():
            max_count = preferences.get("max_anonym_count", 10)
        else:
            max_count = preferences.get("max_user_count", 30)

        paginator = self.paginator_by_queryset(request, queryset, max_count)
        return paginator

    def test(self):
        from django.views.generic.date_based import archive_year


class BlogEntryContent(MarkupBaseModel, UpdateInfoBaseModel):
    """
    Language depend blog entry content.

    inherited attributes from MarkupBaseModel:
        content field
        markup field
        get_html() method

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = BlogEntryContentManager()

    entry = models.ForeignKey(BlogEntry)

    language = models.ForeignKey(Language)
    headline = models.CharField(_('Headline'), max_length=255,
        help_text=_("The blog entry headline")
    )
    slug = models.SlugField(max_length=255, blank=True,
        help_text=_(
            "for url (would be set automatically from headline, if emtpy.)"
        ),
    )
    url_date = models.DateField(_('URL Date'), default=now,
        help_text=_("Date used for building the url.")
    )

    tags = jQueryTagModelField() # a django-tagging model field modified by django-tools
    is_public = models.BooleanField(
        default=True, help_text=_("Is entry in this language is public viewable?")
    )

    def clean_fields(self, exclude=None):
        if not self.slug:
            self.slug = slugify(self.headline)

        super(BlogEntryContent, self).clean_fields(exclude)

    def save(self, *args, **kwargs):
        """
        Clean the complete cache.
        
        FIXME: clean only the blog summary and detail page:
            http://www.python-forum.de/topic-22739.html (de)
        """
        self.clean_fields() # for slug field

        super(BlogEntryContent, self).save(*args, **kwargs)

        try:
            cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
        except AttributeError:
            # No SmoothCacheBackend used -> clean the complete cache
            cache.clear()

    def get_name(self):
        return self.headline

    def get_update_info(self):
        """ update info for update_journal.models.UpdateJournal used by update_journal.save_receiver """
        if not self.is_public: # Don't list non public articles
            return

        return {
            "lastupdatetime": self.lastupdatetime,
            "user_name": self.lastupdateby,
            "language": self.language,
            "object_url": self.get_absolute_url(),
            "title": self.headline,
        }

    def get_absolute_url(self):
        viewname = "Blog-detail_view"

        reverse_kwargs = {
            "year": self.url_date.year,
            "month": "%02i" % self.url_date.month,
            "day": "%02i" % self.url_date.day,
            "slug": self.slug
        }
        try:
            # This only worked inner lucidTag
            url = urlresolvers.reverse(viewname, kwargs=reverse_kwargs)
        except urlresolvers.NoReverseMatch, err:
            if settings.RUN_WITH_DEV_SERVER:
                print "*** Blog url reverse error 1: %s" % err
            # Use the first PluginPage instance
            try:
                url = PluginPage.objects.reverse("blog", viewname, kwargs=reverse_kwargs)
            except urlresolvers.NoReverseMatch, err:
                if settings.RUN_WITH_DEV_SERVER:
                    print "*** Blog url reverse error 2: %s" % err
                return "#No-Blog-PagePlugin-exists"

        if not url.startswith("/%s/" % self.language.code):
            # Replace the language code
            # We get the url with the language code from the current session
            # But the entry is written in a other language.
            url = change_url_language(url, self.language.code)

        return url

    def get_permalink(self, request):
        """ permalink to this entry language indepent """
        permalink = self.entry.get_permalink(request, self.slug)
        return permalink

    def __unicode__(self):
        return self.headline

    class Meta:
        # https://docs.djangoproject.com/en/1.4/ref/models/options/#unique-together
        unique_together = (
            ("language", "url_date", "slug"),
            ("language", "url_date", "headline"),
        )
        ordering = ('-createtime', '-lastupdatetime')


# Add a entry into update journal
signals.post_save.connect(receiver=update_journal.save_receiver, sender=BlogEntryContent)



# Bug in django tagging?
# http://code.google.com/p/django-tagging/issues/detail?id=151#c2
#try:
#    tagging.register(BlogEntry)
#except tagging.AlreadyRegistered: # FIXME
#    pass

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext_lazy as _

from pylucid_project.utils.site_utils import SitePreselectPreference

from dbpreferences.forms import DBPreferencesBaseForm


class BlogPrefForm(SitePreselectPreference, DBPreferencesBaseForm):
    ALL_LANGUAGES = "a"
    PREFERED_LANGUAGES = "p"
    CURRENT_LANGUAGE = "c"
    LANGUAGE_CHOICES = (
        (ALL_LANGUAGES, _("Don't filter by languages. Allways display all blog entries.")),
        (PREFERED_LANGUAGES, _("Filter by client prefered languages (set in browser and send by HTTP_ACCEPT_LANGUAGE header)")),
        (CURRENT_LANGUAGE, _("Display only blog entries in current language (select on the page)")),
    )
    language_filter = forms.ChoiceField(initial=ALL_LANGUAGES, choices=LANGUAGE_CHOICES,
        help_text=_("How to filter blog entries by language?")
    )

    max_anonym_count = forms.IntegerField(
        initial=10, min_value=1,
        help_text=_(
            "The maximal numbers of blog entries, displayed together"
            " for anonymous users"
        ),
    )
    max_user_count = forms.IntegerField(
        initial=30, min_value=1,
        help_text=_(
            "The maximal numbers of blog entries, displayed together"
            " for logged in PyLucid users."
        ),
    )

    initial_feed_count = forms.IntegerField(
        initial=5, min_value=1,
        help_text=_("Default numbers of blog articles in RSS/Atom feed."),
    )
    max_feed_count = forms.IntegerField(
        initial=30, min_value=1,
        help_text=_("The maximal numbers of blog articles in RSS/Atom feed."),
    )

    max_tag_count = forms.IntegerField(
        initial=5, min_value=1,
        help_text=_("The maximal numbers of tags to filter articles."),
    )
    class Meta:
        app_label = 'blog'


def get_preferences():
    pref_form = BlogPrefForm()
    preferences = pref_form.get_preferences()
    return preferences

########NEW FILE########
__FILENAME__ = search
# coding:utf-8

"""
    search Blog entries
    ~~~~~~~~~~~~~~~~~~~

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django.db.models import Q

from pylucid_project.pylucid_plugins.blog.models import BlogEntryContent
from pylucid_project.apps.pylucid.models.pluginpage import PluginPage
from pylucid_project.system.pylucid_plugins import PluginNotOnSite


class Search(object):
    def __init__(self):
        queryset = PluginPage.objects.queryset_by_plugin_name("blog")
        if not queryset.exists():
            raise PluginNotOnSite("blog not used on current site!")

    def get_queryset(self, request, search_languages, search_strings):
        queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, tags=None, filter_language=False)

        # Only items in the selected search language
        queryset = queryset.filter(language__in=search_languages)

        queryset = queryset.select_related()

        for term in search_strings:
            queryset = queryset.filter(
                Q(content__icontains=term) | Q(tags__icontains=term) | Q(headline__icontains=term)
            )

        return queryset

    def add_search_results(self, request, queryset, search_results):
    #    plugin_url_resolver = PluginPage.objects.get_url_resolver("blog")

        for item in queryset:
            meta_content = item.tags
            #print "meta: %r" % meta_content

    #        reverse_kwargs = {
    #            "year": item.url_date.year,
    #            "month": "%02i" % item.url_date.month,
    #            "day": "%02i" % item.url_date.day,
    #            "slug": item.slug
    #        }
    #
    #        url = plugin_url_resolver.reverse("Blog-detail_view", kwargs=reverse_kwargs)

            search_results.add(
                model_instance=item,

                # displayed headline of the result hit
                headline=item.headline,

                # displayed in the result list
                language=item.language,

                # Link to the hit
                url=item.get_absolute_url(),
    #            url=url,

                # the main content -> result lines would be cut out from hits in this content
                content=item.get_search_content(request),

                # hits in meta content has a higher score, but the content would not displayed 
                meta_content=meta_content,
            )

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - There exist only "PyLucid CMS" blog entry in english and german
    
    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


import os
import sys
import datetime


if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#    tests = "pylucid_plugins.blog.tests.BlogPluginCsrfTest"
#    tests = "pylucid_plugins.blog.tests.BlogPluginAnonymousTest"
#    tests = "pylucid_plugins.blog.tests.BlogPluginTagsTest"
#    tests = "pylucid_plugins.blog.tests.BlogLanguageFilterTest"
#    tests = "pylucid_plugins.blog.tests.BlogPluginTest"
#    tests = "pylucid_plugins.blog.tests.BlogPluginTest.test_cancel_edit_entry"
#    tests = "pylucid_plugins.blog.tests.BlogPluginTest.test_url_date"
#    tests = "pylucid_plugins.blog.tests.BlogPluginTest.test_create_csrf_check"
#    tests = "pylucid_plugins.blog.tests.BlogPluginTest.test_creole_markup"
#    tests = "pylucid_plugins.blog.tests.BlogPluginArticleTest"

    from pylucid_project.tests import run_test_directly
    run_test_directly(tests,
        verbosity=2,
#        failfast=True,
        failfast=False,
    )
    sys.exit()


from django.conf import settings
from django.contrib.messages import constants as message_constants
from django.core.cache import cache
from django.core.exceptions import SuspiciousOperation
from django.core.urlresolvers import reverse
from django.test.client import Client

from django_tools.unittest_utils.BrowserDebug import debug_response

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.markup import MARKUP_CREOLE

from blog.models import DEBUG_LANG_FILTER, BlogEntry
from blog.preference_forms import BlogPrefForm


SUMMARY_URL = "/%s/blog/"
TAG_URL = "/%s/blog/tags/%s/"
CREATE_URL = "/pylucid_admin/plugins/blog/new_blog_entry/"
EDIT_URL = "/pylucid_admin/plugins/blog/edit/%i/"
TRANSLATE_URL = "/pylucid_admin/plugins/blog/translate/%i/"
ENTRY_URL = "/%s/blog/detail/PyLucid CMS/"
ADD_PERMISSION = "blog.add_blogentry"
BLOG_UNITTEST_FIXTURES = os.path.join(settings.PYLUCID_BASE_PATH, "pylucid_plugins", "blog", "test_fixtures.json")

TODAY_URL_PART = datetime.date.today().strftime("%Y/%m/%d")
TEST_DATE = "2000/01/24" # Date in test fixtures


class BlogPluginTestCase(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - assertPyLucidPermissionDenied()
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.other_lang_code - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def _pre_setup(self, *args, **kwargs):
        self.fixtures.append(BLOG_UNITTEST_FIXTURES)
        super(BlogPluginTestCase, self)._pre_setup(*args, **kwargs)
        settings.DEBUG = False

    # existing english entries from test fixtures:
    FIRST_ENTRY = (
        "First entry in english",
        "/en/blog/%s/first-entry-in-english/" % TEST_DATE,
        "<p>1. <strong>blog article</strong> in <i>english</i>!</p>",
    )
    SECOND_ENTRY = (
        "Second entry only in english",
        "/en/blog/%s/second-entry-only-in-english/" % TEST_DATE,
        "<p>2. <strong>blog article</strong> only in <i>english</i>!</p>",
    )

    # existing german entries from test fixtures:
    ERSTER_EINTRAG = (
        "Erster Eintrag in deutsch",
        "/de/blog/%s/erster-eintrag-in-deutsch/" % TEST_DATE,
        "<p>1. <strong>Blog Artikel</strong> in <i>deutsch</i>!</p>"
    )
    DRITTER_EINTRAG = (
        "Dritter Eintrag nur in deutsch",
        "/de/blog/%s/dritter-eintrag-nur-in-deutsch/" % TEST_DATE,
        "<p>3. <strong>Blog Artikel</strong> nur in <i>deutsch</i>!</p>"
    )

    SUMMARY_EN_CONTAINS = (
        '<a href="/en/blog/" title="Your personal weblog.">blog</a>',
        '<a href="/en/blog/">All articles.</a>',
        "comments for 'blog':", "Leave a comment</a>", # from pylucid comments

    )
    SUMMARY_DE_CONTAINS = (
        '<a href="/de/blog/" title="Dein eigener Weblog.">blog</a>',
        '<a href="/de/blog/">Alle Artikel.</a>',
        "Kommentare fr 'blog':", "Kommentar hinterlassen</a>", # from pylucid comments
    )

    ENTRY_MUST_CONTAIN_EN = (
        '<a href="/en/blog/detail/PyLucid CMS/" title="PyLucid CMS', # breadcrumbs
        '<dd>PyLucid CMS</dd>',
        '<dt>Short definition:</dt>',
        '<p>This pages are created by PyLucid ;)</p>',
        'Leave a comment</a>', # from pylucid comments
    )
    ENTRY_MUST_CONTAIN_DE = (
        '<a href="/de/blog/detail/PyLucid CMS/" title="PyLucid CMS', # breadcrumbs
        '<dd>PyLucid CMS</dd>',
        '<dt>Kurzdefinition:</dt>',
        '<p>Diese Seiten werden mit PyLucid CMS generiert ;)</p>',
        'Leave a comment</a>', # from pylucid comments
    )

    def assertBlogPage(self, response, language, must_contain, must_not_contain):
        self.failUnlessEqual(response.status_code, 200)
        self.assertResponse(response, must_contain=must_contain,
            must_not_contain=must_not_contain + ("Traceback", "XXX INVALID TEMPLATE STRING")
        )
        self.assertContentLanguage(response, language)

#    def assertSummaryEN(self, response):
#        self.assertBlogPage(response,
#            must_contain=self.SUMMARY_MUST_CONTAIN_EN,
#            must_not_contain=self.SUMMARY_MUST_NOT_CONTAIN_EN,
#        )
#
#    def assertSummaryDE(self, response):
#        self.assertBlogPage(response,
#            must_contain=self.SUMMARY_MUST_CONTAIN_DE,
#            must_not_contain=self.SUMMARY_MUST_NOT_CONTAIN_DE,
#        )

    def assertEntryEN(self, response):
        self.assertBlogPage(response, must_contain=self.ENTRY_MUST_CONTAIN_EN)

    def assertEntryDE(self, response):
        self.assertBlogPage(response, must_contain=self.ENTRY_MUST_CONTAIN_DE)

    def login_with_blog_add_permissions(self):
        """ login as normal user and add 'blog add permissions' """
        return self.login_with_permissions(usertype="normal", permissions=(ADD_PERMISSION,))


class BlogPluginAnonymousTestCase(BlogPluginTestCase):
    def setUp(self):
        cache.clear()

        from pylucid_project.apps.pylucid.preference_forms import SystemPreferencesForm
        self.system_pref_form = SystemPreferencesForm()
        self.system_preferences = self.system_pref_form.get_preferences()
        self.system_preferences["message_level_anonymous"] = message_constants.DEBUG
        self.system_pref_form.save()

        DEBUG_LANG_FILTER = True
        settings.PYLUCID.I18N_DEBUG = True

        self.pref_form = BlogPrefForm()

    def _set_language_filter(self, language_filter):
        self.pref_form["language_filter"] = language_filter
        self.pref_form.save()


class BlogPluginAnonymousTest(BlogPluginAnonymousTestCase):
    """
    ALL_LANGUAGES - "Don't filter by languages. Allways display all blog entries."
    PREFERED_LANGUAGES - "Filter by client prefered languages (set in browser and send by HTTP_ACCEPT_LANGUAGE header)"
    CURRENT_LANGUAGE - "Display only blog entries in current language (select on the page)"
    """
    def test_summary_en_all_languages(self):
        self._set_language_filter(BlogPrefForm.ALL_LANGUAGES)

        response = self.client.get(
            SUMMARY_URL % self.default_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertBlogPage(response, self.default_language,
            must_contain=self.SUMMARY_EN_CONTAINS + self.FIRST_ENTRY + self.SECOND_ENTRY + self.DRITTER_EINTRAG,
            must_not_contain=self.SUMMARY_DE_CONTAINS + self.ERSTER_EINTRAG,
        )

    def test_summary_en_current_languages(self):
        self._set_language_filter(BlogPrefForm.CURRENT_LANGUAGE)

        response = self.client.get(
            SUMMARY_URL % self.default_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertBlogPage(response, self.default_language,
            must_contain=self.SUMMARY_EN_CONTAINS + self.FIRST_ENTRY + self.SECOND_ENTRY,
            must_not_contain=self.SUMMARY_DE_CONTAINS + self.ERSTER_EINTRAG + self.DRITTER_EINTRAG,
        )

    def test_summary_robots(self):
        self._set_language_filter(BlogPrefForm.ALL_LANGUAGES)

        response = self.client.get(
            SUMMARY_URL % self.default_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertBlogPage(response, self.default_language,
            must_contain=('<meta name="robots" content="noindex,follow" />',),
            must_not_contain=(
                '<meta name="robots" content="index,follow" />',
                '<meta name="robots" content="noindex,nofollow" />',
            )
        )

    def test_tag_view_robots(self):
        self._set_language_filter(BlogPrefForm.ALL_LANGUAGES)

        url = TAG_URL = "/%s/blog/tags/%s/" % (self.default_language.code, "deutsch-tag")
        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertBlogPage(response, self.default_language,
            must_contain=('<meta name="robots" content="noindex,nofollow" />',),
            must_not_contain=('<meta name="robots" content="index,follow" />',)
        )

    def test_same_slug_en(self):
        self._set_language_filter(BlogPrefForm.ALL_LANGUAGES)

        lang_code = self.default_language.code
        url = "%s%s/same-slug/" % (SUMMARY_URL % lang_code, TEST_DATE)

        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertBlogPage(response, self.default_language,
            must_contain=(
                '<html lang="en">',
                "Same headline in german and english",
                "<p>4. <strong>blog article</strong> in <i>english</i>!</p>",
            ),
            must_not_contain=("Traceback",),
        )

    def test_same_slug_de(self):
        self._set_language_filter(BlogPrefForm.ALL_LANGUAGES)

        lang_code = self.other_language.code
        url = "%s%s/same-slug/" % (SUMMARY_URL % lang_code, TEST_DATE)

        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.other_language.code,
        )
        self.assertBlogPage(response, self.other_language,
            must_contain=(
                '<html lang="de">',
                "Same headline in german and english",
                "<p>4. <strong>Blog Artikel</strong> in <i>deutsch</i>!</p>",
            ),
            must_not_contain=("Traceback",),
        )

    def test_login_before_edit(self):
        """ Anonymous user must login, to edit a existing blog article """
        url = EDIT_URL % 1
        response = self.client.get(url)
        self.assertRedirect(response,
            url="http://testserver/?auth=login&next_url=%s" % url,
            status_code=302
        )

#    def test_summary_en_prefered_languages(self):
#        self._set_language_filter(BlogPrefForm.PREFERED_LANGUAGES)
#
#        response = self.client.get(
#            SUMMARY_URL % self.default_language.code,
#            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
#        )
#        self.assertBlogPage(response, self.default_language,
#            must_contain=self.SUMMARY_EN_CONTAINS + self.FIRST_ENTRY + self.SECOND_ENTRY,
#            must_not_contain=self.SUMMARY_DE_CONTAINS + self.ERSTER_EINTRAG + self.DRITTER_EINTRAG,
#        )
#
#        response = self.client.get(
#            SUMMARY_URL % self.default_language.code,
#            HTTP_ACCEPT_LANGUAGE=";".join([self.default_language.code, self.other_language]),
#        )
#        self.assertBlogPage(response, self.default_language,
#            must_contain=self.SUMMARY_EN_CONTAINS + self.FIRST_ENTRY + self.SECOND_ENTRY + self.DRITTER_EINTRAG,
#            must_not_contain=self.SUMMARY_DE_CONTAINS + self.ERSTER_EINTRAG,
#        )

'''
    def test_summary_de(self):
        response = self.client.get(
            SUMMARY_URL % self.other_language.code,
            HTTP_ACCEPT_LANGUAGE=self.other_language.code,
        )
        self.assertSummaryDE(response)
        self.assertContentLanguage(response, self.other_language)

    def test_login_before_create(self):
        """ Anonymous user must login, to create new blog articles """
        response = self.client.get(CREATE_URL)
        self.assertRedirect(response,
            url="http://testserver/?auth=login&next_url=%s" % CREATE_URL,
            status_code=302
        )

    def test_login_before_translate(self):
        """ Anonymous user must login, to translate a blog article """
        url = TRANSLATE_URL % 1
        response = self.client.get(url)
        self.assertRedirect(response,
            url="http://testserver/?auth=login&next_url=%s" % url,
            status_code=302
        )

    def _test_atom_feed(self, language):
        language_code = language.code
        response = self.client.get(
            "/%s/blog/feed/feed.atom" % language_code,
            HTTP_ACCEPT_LANGUAGE=language_code,
        )
        self.assertAtomFeed(response, language_code)

    def test_atom_feed_default_language(self):
        self._test_atom_feed(self.default_language)

    def test_atom_feed_other_language(self):
        self._test_atom_feed(self.other_language)

    def _test_rss_feed(self, language):
        language_code = language.code
        response = self.client.get(
            "/%s/blog/feed/feed.rss" % language_code,
            HTTP_ACCEPT_LANGUAGE=language_code,
        )
        self.assertRssFeed(response, language_code)

    def test_rss_feed_default_language(self):
        self._test_rss_feed(self.default_language)

    def test_rss_feed_other_language(self):
        self._test_rss_feed(self.other_language)
'''

class BlogPluginTagsTest(BlogPluginAnonymousTestCase):
    """
    ALL_LANGUAGES - "Don't filter by languages. Allways display all blog entries."
    PREFERED_LANGUAGES - "Filter by client prefered languages (set in browser and send by HTTP_ACCEPT_LANGUAGE header)"
    CURRENT_LANGUAGE - "Display only blog entries in current language (select on the page)"
    """

    def setUp(self):
        super(BlogPluginTagsTest, self).setUp()

        self.pref_form["max_tag_count"] = 2 # Allow only two tag filters
        self.pref_form.save()
        self._set_language_filter(BlogPrefForm.ALL_LANGUAGES)

    def test_canonical_url(self):
        url = TAG_URL = "/%s/blog/tags/%s/" % (self.default_language.code,
            "/".join(["sharedtag", "second_tag"])
        )
        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertRedirect(response,
            # and not ...estserver/en/blog/tags/sharedtag/second_tag/ ;)
            url="http://testserver/en/blog/tags/second_tag/sharedtag/",
            status_code=301 # permanent redirect
        )

    def test_one_tag_filter(self):
        # With one tag filter, other tags has "add-link"
        url = TAG_URL = "/%s/blog/tags/%s/" % (self.default_language.code, "sharedtag")
        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertBlogPage(response, self.default_language,
            must_contain=('Your personal weblog.',
                '<strong style="font-size:2em;">sharedtag</strong>', # current tag filter
                'rel="nofollow">[+]</a>', # link to add tag filter
                'rel="nofollow">second_tag</a>', # Other tag filter
            ),
            must_not_contain=('Traceback',)
        )

    def test_reached_tag_filters(self):
        # With two tags, the max number of filters is reached -> No "add-link"
        url = TAG_URL = "/%s/blog/tags/%s/" % (self.default_language.code,
            "/".join(["second_tag", "sharedtag"])
        )
        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertBlogPage(response, self.default_language,
            must_contain=('Your personal weblog.',
                '<strong style="font-size:1em;">second_tag</strong>', # current tag filter 1
                '<strong style="font-size:1em;">sharedtag</strong>', # current tag filter 2
                'rel="nofollow">english-tag</a>', # Other tag filter
            ),
            must_not_contain=('Traceback',
                'rel="nofollow">[+]</a>', # link to add tag filter
            )
        )

    def test_too_mush_tags_filters(self):
        # With three tags are one to murch -> raise 404
        url = TAG_URL = "/%s/blog/tags/%s/" % (self.default_language.code,
            "/".join(["second_tag", "sharedtag", "english-tag"])
        )
        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.failUnlessEqual(response.status_code, 404)

    def _request_with_too_much_tags(self):
        url = TAG_URL = "/%s/blog/tags/%s/" % (self.default_language.code,
            "/".join(["second_tag", "sharedtag", "english-tag", "too_mutch"])
        )
        response = self.client.get(url,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        return response

    def test_too_mush_tags_filters_and_ban(self):
        ban_count = int(self.system_preferences["ban_count"])

        for i in xrange(ban_count):
            # With four tags are two to murch -> raise SuspiciousOperation and log this
            response = self._request_with_too_much_tags()
            self.failUnlessEqual(response.status_code, 404)

        # We are banned after 'ban_count' bad requests -> Get 403 Forbidden
        response = self._request_with_too_much_tags()
        self.failUnlessEqual(response.status_code, 403)

        # Important: We must remove "us" from ban list, otherwise other unittests
        # will failed ;)
        from pylucid_project.apps.pylucid.models import BanEntry
        BanEntry.objects.all().delete()

        # Test if we are not banned anymore:
        self.test_one_tag_filter()


class BlogPluginTest(BlogPluginTestCase):
    """
    Test with a user witch are logged in and has ADD_PERMISSION
    """
    def setUp(self):
        self.client = Client() # start a new session

    def test_normal_user_without_permissions(self):
        """ test with insufficient permissions: normal, non-stuff user """
        self.login("normal")
        response = self.client.get(CREATE_URL)
        self.assertPyLucidPermissionDenied(response)

    def test_staff_user_without_permissions(self):
        """ test with insufficient permissions: staff user without any permissions """
        self.login("staff")
        response = self.client.get(CREATE_URL)
        self.assertPyLucidPermissionDenied(response)

    def test_create_page(self):
        """
        get the create page, with normal user witch has the add permission
        """
        self.login_with_blog_add_permissions()
        response = self.client.get(CREATE_URL)
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Create a new blog entry</title>',
                'form action="%s"' % CREATE_URL,
                "<input type='hidden' name='csrfmiddlewaretoken' value='",
                'input type="submit" name="save" value="Save"',
                'input type="submit" name="cancel"',
                '<textarea id="id_content" rows="10" cols="40" name="content"></textarea>',
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_create_csrf_error(self):
        self.login_with_blog_add_permissions()
        csrf_client = Client(enforce_csrf_checks=True)
        response = csrf_client.post(CREATE_URL)
        self.assertResponse(response,
            must_contain=(
                "CSRF verification failed."
            ),
            must_not_contain=("Traceback", "Form errors", "field is required",

            )
        )

    def test_cancel_create_entry(self):
        self.login_with_blog_add_permissions()
        response = self.client.post(CREATE_URL, data={"cancel": "Cancel"}, follow=True)
        self.assertResponse(response,
            must_contain=(
                "Create new blog entry aborted, ok.",
                '<h2 id="page_title">Your personal weblog.</h2>',
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_cancel_edit_entry(self):
        self.login("superuser")
        response = self.client.post(EDIT_URL % 1, data={"cancel": "Cancel"}, follow=True)
        self.assertResponse(response,
            must_contain=(
                "Edit blog entry aborted, ok.",
                '<h2 id="page_title">First entry in english</h2>'
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_create_entry(self):
        self.login_with_blog_add_permissions()
        response = self.client.post(CREATE_URL,
            data={
            "headline": "The blog headline",
            "content": "The **blog article content** in //creole// markup!",
            "markup": MARKUP_CREOLE,
            "is_public": "on",
            "language": self.default_language.id,
            "url_date": datetime.date.today(),
            "sites": settings.SITE_ID,
            "tags": "django-tagging, tag1, tag2",
        })
        blog_article_url = "http://testserver/en/blog/%s/the-blog-headline/" % TODAY_URL_PART
        self.assertRedirect(response, url=blog_article_url, status_code=302)

    def test_url_date(self):
        self.login_with_blog_add_permissions()
        response = self.client.post(CREATE_URL,
            data={
            "headline": "Tag der Deutschen Einheit...",
            "content": "...war am **03. Oktober 1990**.",
            "markup": MARKUP_CREOLE,
            "is_public": "on",
            "language": self.default_language.id,
            "url_date": "1990-10-03",
            "sites": settings.SITE_ID,
            "tags": "django-tagging, tag1, tag2",
        })
        blog_article_url = "http://testserver/en/blog/1990/10/03/tag-der-deutschen-einheit/"
        self.assertRedirect(response, url=blog_article_url, status_code=302)
        response = self.client.get(blog_article_url)
        self.assertDOM(response,
            must_contain=(
                '<li class="success">New blog entry &#39;Tag der Deutschen Einheit...&#39; saved.</li>',
                '<p>...war am <strong>03. Oktober 1990</strong>.</p>',
            ),
            must_not_contain=("Traceback", "field is required")
        )
        self.assertResponse(response,
            must_contain=(
                # Archive links (complete link doesn't match with assertHTML):
                '<a href="/en/blog/1990/"',
                '<a href="/en/blog/1990/10/"',
                '<a href="/en/blog/1990/10/03/"',
            ),
            must_not_contain=("Traceback", "field is required")
        )

    def test_unique_together_slug(self):
        self.login_with_blog_add_permissions()
        create_data = {
            "content": "The **blog article content** in //creole// markup!",
            "markup": MARKUP_CREOLE,
            "is_public": "on",
            "sites": settings.SITE_ID,

            # Same language + url_date and slug for both entries:
            "language": self.default_language.id,
            "url_date": datetime.date.today(),
            "slug": "foobar",
        }
        # Create first entry:
        create_data["headline"] = "unique headline one"
        response = self.client.post(CREATE_URL, data=create_data)
        blog_article_url = "http://testserver/en/blog/%s/foobar/" % TODAY_URL_PART
        self.assertRedirect(response, url=blog_article_url, status_code=302)

        # Try to create the same entry, again:
        create_data["headline"] = "unique headline two"
        response = self.client.post(CREATE_URL, data=create_data)
        self.assertResponse(response,
            must_contain=(
                "Create a new blog entry",
                "Form errors",
                "Blog entry content with this Language, URL Date and Slug already exists.",
            ),
            must_not_contain=("Traceback", "field is required")
        )
        # Stay at create page:
        self.assertEqual(response.request["PATH_INFO"], CREATE_URL)

    def test_unique_together_headline(self):
        self.login_with_blog_add_permissions()
        create_data = {
            "content": "The **blog article content** in //creole// markup!",
            "markup": MARKUP_CREOLE,
            "is_public": "on",
            "sites": settings.SITE_ID,

            # Same language + url_date and headline for both entries:
            "language": self.default_language.id,
            "url_date": datetime.date.today(),
            "headline": "always the same",
        }
        # Create first entry:
        create_data["slug"] = "unique_slug_one"
        response = self.client.post(CREATE_URL, data=create_data)
        blog_article_url = "http://testserver/en/blog/%s/unique_slug_one/" % TODAY_URL_PART
        self.assertRedirect(response, url=blog_article_url, status_code=302)

        # Try to create the same entry, again:
        create_data["slug"] = "unique_slug_two"
        response = self.client.post(CREATE_URL, data=create_data)
        self.assertResponse(response,
            must_contain=(
                "Create a new blog entry",
                "Form errors",
                "Blog entry content with this Language, URL Date and Headline already exists.",
            ),
            must_not_contain=("Traceback", "field is required")
        )
        # Stay at create page:
        self.assertEqual(response.request["PATH_INFO"], CREATE_URL)

    def test_creole_markup(self):
        self.login_with_blog_add_permissions()
        response = self.client.post(CREATE_URL, data={
            "headline": "The blog headline",
            "content": "A **//creole// markup** and a {{/image/url/pic.PNG|1 2}} nice?",
            "markup": MARKUP_CREOLE,
            "is_public": "on",
            "language": self.default_language.id,
            "url_date": datetime.date.today(),
            "sites": settings.SITE_ID,
            "tags": "django-tagging, tag1, tag2",
        })
        blog_article_url = "http://testserver/en/blog/%s/the-blog-headline/" % TODAY_URL_PART
        self.assertRedirect(response, url=blog_article_url, status_code=302)

        response = self.client.get(blog_article_url)
        #self.raise_browser_traceback(response, "TEST")
        self.assertResponse(response,
            must_contain=(
                '<p>A <strong><i>creole</i> markup</strong> and a <img src="/image/url/pic.PNG" title="1 2" alt="1 2" /> nice?</p>',
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_markup_preview_ids(self):
        self.login_with_blog_add_permissions()
        response = self.client.get(CREATE_URL)
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '<fieldset id="preview_id_content">',
                '$("#preview_id_content div")',

                '<select name="markup" id="id_markup">',
                'var markup_selector = "#id_markup";'
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_markup_preview(self):
        self.login("superuser")
        url = reverse("Blog-markup_preview")
        response = self.client.post(url, data={
            'content': '**foo** //bar//',
            'markup': 6,
            },
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
            follow=True,
        )
        self.assertResponse(response,
            must_contain=(
                '<p><strong>foo</strong> <i>bar</i></p>',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING", "<body", "<html")
        )



'''
TODO:

class BlogPluginArticleTest(BlogPluginTestCase):
    """
    Test blog plugin with existing blog articles in different languages
    """
    def _pre_setup(self, *args, **kwargs):
        """ create some blog articles """
        super(BlogPluginArticleTest, self)._pre_setup(*args, **kwargs)



    def assertSecondArticle(self, response):
        self.assertContentLanguage(response, self.default_language)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - Second entry in english</title>',

                '<a href="/en/blog/2/second-entry-in-english/" class="blog_headline" hreflang="en">',
                'Second entry in english</a>',

                '<a href="/en/blog/2/second-entry-in-english/" title="Article &#39;Second entry in english&#39;">',
                'Second entry in english</a>',

                # english tag cloud:
                'tag cloud', '<a href="/en/blog/tags/english-tag/" style="font-size:2em;">english-tag</a>',

                'class="content" lang="en"><p>2. <strong>blog article</strong> in <i>english</i>!</p>',

                "entry in english", "first_tag", "english-tag",

                'Leave a comment</a>', # from pylucid comments
            ),
            must_not_contain=("Traceback",
                # Not the summary page:
                "All articles", "Alle Artikel",

                # not the german tag cloud:
                'Tag Cloud', '<a href="/en/blog/tags/deutsch-tag/" style="font-size:2em;">', 'deutsch-tag</a>',
            )
        )

    def test_absolute_url(self):
        self.failUnlessEqual(self.entry_en1.get_absolute_url(), "/en/blog/1/first-entry-in-english/")
        self.failUnlessEqual(self.entry_de1.get_absolute_url(), "/de/blog/3/erster-eintrag-in-deutsch/")

    def test_summary_en(self):
        """ test the summary page in english """
        response = self.client.get(
            SUMMARY_URL % self.default_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertSummaryEN(response)
        self.assertContentLanguage(response, self.default_language)
        self.assertResponse(response,
            must_contain=(
                'All articles in English.',
                '<a href="/en/blog/1/first-entry-in-english/"',
                'First entry in english',
                '<a href="/en/blog/2/second-entry-in-english/"',
                'Second entry in english',
                '<p>1. <strong>blog article</strong> in <i>english</i>!</p>',
                '<p>2. <strong>blog article</strong> in <i>english</i>!</p>',

                # from django-tagging:
                'tag cloud',
                '<a href="/en/blog/tags/english-tag/" style="font-size:2em;">english-tag</a>',
                '<a href="/en/blog/tags/first_tag/" style="font-size:1em;">first_tag</a>',
                '<a href="/en/blog/tags/second_tag/" style="font-size:1em;">second_tag</a>',
                '<a href="/en/blog/tags/sharedtag/" style="font-size:2em;">sharedtag</a>',
            ),
            must_not_contain=("Traceback",
                "Eintrag in deutsch",
                "erster_tag", "deutsch-tag"
                'Leave a comment</a>', # from pylucid comments
            )
        )

    def test_summary_de(self):
        """ test the summary page in deutsch """
        response = self.client.get(
            SUMMARY_URL % self.other_language.code,
            HTTP_ACCEPT_LANGUAGE=self.other_language.code,
        )
        self.assertSummaryDE(response)
        self.assertContentLanguage(response, self.other_language)
        self.assertResponse(response,
            must_contain=(
                'Alle Artikel in Deutsch.',
                '<a href="/de/blog/3/erster-eintrag-in-deutsch/"',
                'Erster Eintrag in deutsch',
                '<a href="/de/blog/4/zweiter-eintrag-in-deutsch/"',
                'Zweiter Eintrag in deutsch',
                '<p>1. <strong>Blog Artikel</strong> in <i>deutsch</i>!</p>',
                '<p>2. <strong>Blog Artikel</strong> in <i>deutsch</i>!</p>',

                # from django-tagging:
                'Tag Cloud',
                '<a href="/de/blog/tags/deutsch-tag/" style="font-size:2em;">deutsch-tag</a>',
                '<a href="/de/blog/tags/erster_tag/" style="font-size:1em;">erster_tag</a>',
                '<a href="/de/blog/tags/sharedtag/" style="font-size:2em;">sharedtag</a>',
                '<a href="/de/blog/tags/zweiter_tag/" style="font-size:1em;">zweiter_tag</a>',
            ),
            must_not_contain=("Traceback",
                "entry in english",
                "first_tag", "english-tag"
                'Leave a comment</a>', # from pylucid comments
            )
        )

    def test_update_journal_de(self):
        # Check if listed in update journal
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE="de")
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '(blog entry)',
                '<a href="/de/blog/4/zweiter-eintrag-in-deutsch/">', 'Zweiter Eintrag in deutsch</a>',
                '<a href="/de/blog/3/erster-eintrag-in-deutsch/">', 'Erster Eintrag in deutsch</a>',
            ),
            must_not_contain=("Traceback", "First entry", "Second entry")
        )

    def test_update_journal_en(self):
        # Check if listed in update journal
        response = self.client.get("/", HTTP_ACCEPT_LANGUAGE="en")
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '(blog entry)',
                '<a href="/en/blog/2/second-entry-in-english/">', 'Second entry in english</a>',
                '<a href="/en/blog/1/first-entry-in-english/">', 'First entry in english</a>',
            ),
            must_not_contain=("Traceback", "Erster Eintrag", "Zweiter Eintrag")
        )

    def test_second_entry(self):
        """ request the second, english entry. """
        response = self.client.get(
            "/en/blog/2/second-entry-in-english/",
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertSecondArticle(response)

    def test_second_entry_as_german(self):
        """
        request the second, english entry, with http accept in german.
        The blog plugin switches to english.
        """
        # The first request activae german language from http accept
        # But the blog article is written in english. PyLucid changed
        # the language in url and cookie and redirect
        response = self.client.get(
            "/de/blog/2/second-entry-in-english/",
            HTTP_ACCEPT_LANGUAGE=self.other_language.code,
        )
        self.assertRedirect(
            response, url="http://testserver/en/blog/2/second-entry-in-english/", status_code=301
        )

        # 'Follow' the redirection and get the page and article in english
        response = self.client.get(
            "/en/blog/2/second-entry-in-english/",
            HTTP_ACCEPT_LANGUAGE=self.other_language.code,
        )
        self.assertSecondArticle(response)

    def test_all_languages(self):
        self.pref_form = BlogPrefForm()
        self.pref_form["language_filter"] = BlogPrefForm.ALL_LANGUAGES
        self.pref_form.save()

        response = self.client.get("/%s/blog/" % self.default_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertResponse(response,
            must_contain=(
                'Zweiter Eintrag in deutsch',
                'Zweiter Eintrag in deutsch',
                'Second entry in english',
                'First entry in english',
            ),
            must_not_contain=("Traceback",)
        )
'''


class BlogPluginCsrfTest(BlogPluginTestCase):
    """
    Test the Cross Site Request Forgery protection in PyLucid with the Blog Plugin
    """
    def setUp(self):
        super(BlogPluginCsrfTest, self).setUp()
        settings.DEBUG = True

    def tearDown(self):
        super(BlogPluginCsrfTest, self).tearDown()
        settings.DEBUG = False

    def _get_loggedin_client(self):
        csrf_client = Client(enforce_csrf_checks=True)

        test_user = self._get_userdata("superuser")
        ok = csrf_client.login(username=test_user["username"],
                               password=test_user["password"])
        return csrf_client

    def test_create_entry_without_token(self):
        csrf_client = self._get_loggedin_client()

        response = csrf_client.post(CREATE_URL,
            data={
            "headline": "The blog headline",
            "content": "The **blog article content** in //creole// markup!",
            "markup": MARKUP_CREOLE,
            "is_public": "on",
            "language": self.default_language.id,
            "url_date": datetime.date.today(),
            "sites": settings.SITE_ID,
            "tags": "django-tagging, tag1, tag2",
        })
#        debug_response(response)
        self.assertResponse(response,
            must_contain=("Forbidden", "CSRF cookie not set."),
            must_not_contain=()
        )

    def test_create_entry_with_token(self):
        csrf_client = self._get_loggedin_client()

        # get the current csrf token
        response = csrf_client.get(CREATE_URL)
        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = response.content.replace(
            """.html('<h2 class="noanchor">loading...</h2>');""",
            """.html('loading...');"""
        )
        self.assertDOM(response,
            must_contain=(
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
            ),
        )

        # create blog entry with csrf token
        response = csrf_client.post(CREATE_URL,
            data={
            "headline": "The blog headline",
            "content": "The **blog article content** in //creole// markup!",
            "markup": MARKUP_CREOLE,
            "is_public": "on",
            "language": self.default_language.id,
            "url_date": datetime.date.today(),
            "sites": settings.SITE_ID,
            "tags": "django-tagging, tag1, tag2",
            "csrfmiddlewaretoken": csrf_token
        })
#        debug_response(response)
        blog_article_url = "http://testserver/en/blog/%s/the-blog-headline/" % TODAY_URL_PART
        self.assertRedirect(response, url=blog_article_url, status_code=302)






########NEW FILE########
__FILENAME__ = update
# coding: utf-8

"""
    PyLucid plugin update API
"""

from django.contrib.auth.models import User
from django.contrib.sites.models import Site
from django.contrib.contenttypes.models import ContentType

# old models
from pylucid_project.apps.pylucid_update.models import BlogTag, BlogComment08
from pylucid_project.apps.pylucid_update.models import BlogEntry as BlogEntry08

# new model
from blog.models import BlogEntry
from pylucid_comments.models import PyLucidComment


def update08(request, out, language):
    out.write("_" * 79)
    out.write("Update blog data from PyLucid v0.8 to v0.9")
    out.write("")

    # XXX: For dev. only!!!
#    BlogEntry.objects.all().delete()
#    PyLucidComment.objects.all().delete()

    content_type = ContentType.objects.get_for_model(BlogEntry)

    old_blog_entries = BlogEntry08.objects.all()
    for old_blog_entry in old_blog_entries:
        out.write(" convert blog entry: %r" % old_blog_entry.headline)

        old_tags = ",".join(old_blog_entry.tags.values_list('name', flat=True))
        out.write("tags: %r" % old_tags)

        new_entry, created = BlogEntry.on_site.get_or_create(
            headline=old_blog_entry.headline,
            defaults={
                "content": old_blog_entry.content,
                "language": language,
                "markup": old_blog_entry.markup,
                "tags": old_tags,
                "is_public": old_blog_entry.is_public,

                "createby": old_blog_entry.createby,
                "lastupdateby": old_blog_entry.lastupdateby,
            }
        )
        # Set old datetime
        new_entry.createtime = old_blog_entry.createtime
        new_entry.lastupdatetime = old_blog_entry.lastupdatetime,

        new_entry.save()
        if created:
            out.write(" * New blog entry: %r created." % new_entry)
        else:
            out.write(" * blog entry: %r exist." % new_entry)

        old_pylucid_comments = BlogComment08.objects.all().filter(blog_entry=old_blog_entry)
        #old_pylucid_comments = old_blog_entry.blogcomment_set.all()
        out.write("pylucid_comments: %r" % old_pylucid_comments)

        for old_comment in old_pylucid_comments:
            try:
                user = User.objects.get(username=old_comment.person_name)
            except (User.DoesNotExist, User.MultipleObjectsReturned):
                try:
                    user = User.objects.get(email=old_comment.email)
                except (User.DoesNotExist, User.MultipleObjectsReturned):
                    user = None

            new_comment, created = PyLucidComment.objects.get_or_create(
                content_type=content_type,
                object_pk=new_entry.pk,
                submit_date=old_comment.createtime,

                defaults={
                    "site": Site.objects.get_current(),

                    "user": user,

                    "user_name": old_comment.person_name,
                    "user_email": old_comment.email,
                    "user_url": old_comment.homepage,

                    "comment": old_comment.content,

                    "ip_address": old_comment.ip_address,
                    "is_public": old_comment.is_public,
                }
            )
            if created:
                out.write(" + New blog comment: %r created." % new_comment)
            else:
                out.write(" + blog comment: %r exist." % new_comment)

        out.write(" -"*49)

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8


from django.conf.urls.defaults import patterns, url

from pylucid_project.pylucid_plugins.blog import views


urlpatterns = patterns('',
    url(r'^tags/(?P<tags>.+?)/$', views.tag_view, name='Blog-tag_view'),

    url(r'^(?P<year>\d{4})/$',
        views.year_archive, name='Blog-year_archive'
    ),
    url(r'^(?P<year>\d{4})/(?P<month>\d{1,2})/$',
        views.month_archive, name='Blog-month_archive'
    ),
    url(r'^(?P<year>\d{4})/(?P<month>\d{1,2})/(?P<day>\d{1,2})/$',
        views.day_archive, name='Blog-day_archive'
    ),

    url(r'^(?P<year>\d{4})/(?P<month>\d{1,2})/(?P<day>\d{1,2})/(?P<slug>[-\w]+)/$',
        views.detail_view, name='Blog-detail_view'
    ),

    url(r'^(?P<id>\d+?)/(?P<slug>.*)/$', views.permalink_view, name='Blog-permalink_view'),
    url(r'^(?P<id>\d+?)/(?P<title>.*)/$', views.redirect_old_urls),

    url(r'^feed/(?P<tags>.+)/(?P<filename>.+?)$', views.feed, name='Blog-tag_feed'),
    url(r'^feed/(?P<filename>.+?)$', views.feed, name='Blog-feed'),
    url(r'^feed/', views.select_feed, name='Blog-select_feed'),

    url(r'^', views.summary, name='Blog-summary'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid blog plugin
    ~~~~~~~~~~~~~~~~~~~

    A simple blog system.

    http://feedvalidator.org/
    
    TODO:
        * Detail view, use BlogEntry.get_absolute_url()

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

import datetime

from django.conf import settings
from django.contrib import messages
from django.contrib.syndication.views import Feed
from django.core import urlresolvers
from django.http import HttpResponsePermanentRedirect, HttpResponseRedirect, \
    Http404
from django.utils.feedgenerator import Rss201rev2Feed, Atom1Feed
from django.utils.translation import ugettext as _
from django.views.decorators.csrf import csrf_protect
from django.views.generic.date_based import archive_year, archive_month, \
    archive_day

from pylucid_project.apps.pylucid.decorators import render_to
from pylucid_project.apps.pylucid.system import i18n
from pylucid_project.middlewares.pylucid_objects import SuspiciousOperation404
from pylucid_project.utils.safe_obtain import safe_pref_get_integer

from blog.preference_forms import get_preferences
from blog.models import BlogEntry, BlogEntryContent
from blog.preference_forms import BlogPrefForm

# from django-tagging
from tagging.models import Tag, TaggedItem
from django.core.urlresolvers import reverse


def _add_breadcrumb(request, *args, **kwargs):
    """ shortcut for add breadcrumb link """
    try:
        breadcrumb_context_middlewares = request.PYLUCID.context_middlewares["breadcrumb"]
    except KeyError:
        # No breadcrumbs plugin installed?
        return
    breadcrumb_context_middlewares.add_link(*args, **kwargs)


def _get_max_tag_count():
    preferences = get_preferences()
    max_count = preferences.get("max_tag_count", 5)
    return max_count


def _split_tags(raw_tags):
    "simple split tags from url"
    tag_list = raw_tags.strip("/").split("/")

    max_count = _get_max_tag_count()
    tag_count = len(tag_list) - 1
    if tag_count == max_count:
        raise Http404(_("Too much tags given"))
    elif tag_count > max_count:
        # The maximum number of tag filters is exceeded.
        # This can't not happen by accident, because we didn't insert
        # more tag filter links than allowed.
        raise SuspiciousOperation404(_("Too much tags given"))

    tag_list.sort()
    canonical = "/".join(tag_list)

    return tag_list, canonical


class RssFeed(Feed):
    feed_type = Rss201rev2Feed
    filename = "feed.rss"
    title = _("Blog - RSS feed")
    link = "/"
    description_template = "blog/feed_description.html"

    def __init__(self, request, tags=None):
        self.request = request
        # client favored Language instance:
        lang_entry = request.PYLUCID.current_language
        self.language = lang_entry.code

        if tags is None:
            self.tags = None
        else:
            tags_list, canonical = _split_tags(tags)
            if tags != canonical:
                raise Http404("No canonical url.") # Should we redirect? How?
            self.tags = tags_list

        # Get max number of feed entries from request.GET["count"]
        # Validate/Limit it with information from DBPreferences 
        self.count, error = safe_pref_get_integer(
            request, "count", BlogPrefForm,
            default_key="initial_feed_count", default_fallback=5,
            min_key="initial_feed_count", min_fallback=5,
            max_key="max_feed_count", max_fallback=30
        )

    def description(self):
        if self.tags is None:
            return _("Last %s blog articles") % self.count
        else:
            return _(
                 "Last %(count)s blog articles tagged with: %(tags)s"
            ) % {"count":self.count, "tags": ",".join(self.tags)}

    def items(self):
        queryset = BlogEntryContent.objects.get_prefiltered_queryset(self.request, tags=self.tags, filter_language=True)
        return queryset[:self.count]

    def item_title(self, item):
        return item.headline

    def item_author_name(self, item):
        return item.createby

    def item_link(self, item):
        return item.get_absolute_url()


class AtomFeed(RssFeed):
    """
    http://docs.djangoproject.com/en/dev/ref/contrib/syndication/#publishing-atom-and-rss-feeds-in-tandem
    """
    feed_type = Atom1Feed
    filename = "feed.atom"
    title = _("Blog - Atom feed")
    subtitle = RssFeed.description


FEEDS = (AtomFeed, RssFeed)
FEED_FILENAMES = (AtomFeed.filename, RssFeed.filename)



@render_to("blog/summary.html")
def summary(request):
    """
    Display summary list with all blog entries.
    """
    url = urlresolvers.reverse("Blog-summary")
    if url != request.path:
        # e.g.: request with wrong permalink: /en/blog/XXX/foobar-slug/
        return HttpResponseRedirect(url)

    # Get all blog entries, that the current user can see
    paginator = BlogEntryContent.objects.get_filtered_queryset(request, filter_language=True)

    # Calculate the tag cloud from all existing entries
    tag_cloud = BlogEntryContent.objects.get_tag_cloud(request)

    _add_breadcrumb(request, _("All articles."))

    # For adding page update information into context by pylucid context processor
    try:
        # Use the newest blog entry for date info
        request.PYLUCID.updateinfo_object = paginator.object_list[0]
    except IndexError:
        # No blog entries created, yet.
        pass

    context = {
        "entries": paginator,
        "tag_cloud": tag_cloud,
        "CSS_PLUGIN_CLASS_NAME": settings.PYLUCID.CSS_PLUGIN_CLASS_NAME,
        "filenames": FEED_FILENAMES,
        "page_robots": "noindex,follow",
    }
    return context


@render_to("blog/summary.html")
def tag_view(request, tags):
    """
    Display summary list with blog entries filtered by the given tags.
    """
    tag_list, canonical = _split_tags(tags)

    if tags != canonical:
        # Redirect to a canonical url
        # FIXME: The template should create links in a canonical way and not just +tag
        url = reverse('Blog-tag_view', kwargs={"tags":canonical})
        return HttpResponsePermanentRedirect(url)

    # Get all blog entries, that the current user can see
    paginator = BlogEntryContent.objects.get_filtered_queryset(request, tags=tag_list, filter_language=True)

    queryset = paginator.object_list
    if len(queryset) == 0:
        # There exist no blog entries for the given tags.
        # This can't happen by accident, because we didn't insert
        # tag filters without existing articles.
        raise Http404("No articles for the given tag filters")

    # Calculate the tag cloud from the current used queryset
    tag_cloud = BlogEntryContent.objects.cloud_for_queryset(queryset)

    # Add link to the breadcrumbs ;)
    text = _("All items tagged with: %s") % ", ".join(["'%s'" % tag for tag in tag_list])
    _add_breadcrumb(request, text)

    # For adding page update information into context by pylucid context processor
    try:
        # Use the newest blog entry for date info
        request.PYLUCID.updateinfo_object = paginator.object_list[0]
    except IndexError:
        # No blog entries created, yet.
        pass

    # Don't add links to tags, if the maximum tag filter count is reached:
    max_count = _get_max_tag_count()
    if len(tag_list) < max_count:
        add_tag_filter_link = True
    else:
        add_tag_filter_link = False

    context = {
        "entries": paginator,
        "tag_cloud": tag_cloud,
        "add_tag_filter_link": add_tag_filter_link,
        "CSS_PLUGIN_CLASS_NAME": settings.PYLUCID.CSS_PLUGIN_CLASS_NAME,
        "used_tags": tag_list,
        "tags": tags,
        "filenames": FEED_FILENAMES,
        "page_robots": "noindex,nofollow",
    }
    return context


@csrf_protect
@render_to("blog/detail_view.html")
def detail_view(request, year, month, day, slug):
    """
    Display one blog entry with a comment form.
    """
    # Get all blog entries, that the current user can see
    queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)

    filter_kwargs = {
        "url_date__year":year,
        "url_date__month":month,
        "url_date__day":day,
        "slug":slug,
    }
    current_language = request.PYLUCID.current_language
    try:
        queryset = queryset.filter(**filter_kwargs)
        content_entry, tried_languages = BlogEntryContent.objects.get_by_prefered_language(
            request, queryset, show_lang_errors=False
        )
    except BlogEntryContent.DoesNotExist, err:
        # entry not found -> Display day archive with error messages as a 404 page
        
        # Create error message:
        error_msg = _("Entry for this url doesn't exist.")
        if settings.DEBUG or request.user.is_superuser:
            error_msg += " Filter kwargs: %r - Error: %s" % (repr(filter_kwargs), err)
        messages.error(request, error_msg)
        
        # response day archive
        response = day_archive(request, year, month, day)
        response.status_code = 404 # Send as 404 page, so that search engines doesn't index this.
        return response

    if tried_languages and (settings.DEBUG or request.user.is_superuser):
        messages.debug(request,
            "Blog entry not found in these languages: %s" % ",".join([l.code for l in tried_languages])
        )

    # Add link to the breadcrumbs ;)
    _add_breadcrumb(request, content_entry.headline, _("Article '%s'") % content_entry.headline)

    # Calculate the tag cloud from all existing entries
    tag_cloud = BlogEntryContent.objects.get_tag_cloud(request)

    # Change permalink from the blog root page to this entry detail view
    permalink = content_entry.get_permalink(request)
    request.PYLUCID.context["page_permalink"] = permalink # for e.g. the HeadlineAnchor

    # Add comments in this view to the current blog entry and not to PageMeta
    request.PYLUCID.object2comment = content_entry

    # For adding page update information into context by pylucid context processor
    request.PYLUCID.updateinfo_object = content_entry

    context = {
        "page_title": content_entry.headline, # Change the global title with blog headline
        "entry": content_entry,
        "tag_cloud": tag_cloud,
        "CSS_PLUGIN_CLASS_NAME": settings.PYLUCID.CSS_PLUGIN_CLASS_NAME,
        "page_permalink": permalink, # Change the permalink in the global page template
    }
    return context

#------------------------------------------------------------------------------

def permalink_view(request, id, slug=None):
    """ redirect to language depent blog entry """
    prefiltered_queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)

    preferred_languages = request.PYLUCID.languages

    prefiltered_queryset = prefiltered_queryset.filter(entry__id__exact=id)
    try:
        entry = prefiltered_queryset.filter(language__in=preferred_languages)[0]
    except (BlogEntry.DoesNotExist, IndexError):
        # wrong permalink -> display summary
        msg = "Blog entry doesn't exist."
        if settings.DEBUG or request.user.is_staff:
            msg += " (ID %r wrong.)" % id
        messages.error(request, msg)
        return summary(request)

    url = entry.get_absolute_url()
    return HttpResponsePermanentRedirect(url)

#------------------------------------------------------------------------------

def redirect_old_urls(request, id, title):
    """ permanent redirect old url's to new url scheme """
    prefiltered_queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)

    try:
        entry = prefiltered_queryset.get(pk=id)
    except BlogEntry.DoesNotExist:
        # It's possible that the user comes from a external link.
        msg = "Blog entry doesn't exist."
        if settings.DEBUG or request.user.is_staff:
            msg += " (ID %r wrong.)" % id
        messages.error(request, msg)
        return summary(request)

    url = entry.get_absolute_url()
    return HttpResponsePermanentRedirect(url)


#------------------------------------------------------------------------------

# FIXME: Disallow empty archive pages in all archive views:

def year_archive(request, year):
    """
    Display year archive
    """
    year = int(year)

    # Add link to the breadcrumbs ;)
    _add_breadcrumb(request, _("%s archive") % year, _("All article from year %s") % year)

    context = {
        "CSS_PLUGIN_CLASS_NAME": settings.PYLUCID.CSS_PLUGIN_CLASS_NAME,
        "page_robots": "noindex,nofollow",
    }

    # Get next year
    now = datetime.datetime.now()
    if year < now.year:
        queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)
        next_year = datetime.datetime(year=year, month=12, day=31)
        try:
            entry_in_next_year = queryset.filter(url_date__gte=next_year).only("url_date").order_by("-url_date")[0]
        except IndexError:
            # no entries in next year
            pass
        else:
            context["next_year"] = entry_in_next_year.url_date.year

    # Get previous year
    queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)
    previous_year = datetime.datetime(year=year, month=1, day=1)
    try:
        entry_in_previous_year = queryset.filter(url_date__lte=previous_year).only("url_date").order_by("-url_date")[0]
    except IndexError:
        # no entries in previous year
        pass
    else:
        context["previous_year"] = entry_in_previous_year.url_date.year

    queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)
    return archive_year(
        request, year, queryset, date_field="url_date", extra_context=context,
        make_object_list=True,
        allow_empty=True
    )


def month_archive(request, year, month):
    """
    TODO: Set previous-/next-month by filtering
    """
    queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)

    # Add link to the breadcrumbs ;)
    _add_breadcrumb(request,
        _("%(month)s-%(year)s archive") % {"year":year, "month":month},
        _("All article from %(month)s.%(year)s") % {"year":year, "month":month}
    )

    context = {
        "CSS_PLUGIN_CLASS_NAME": settings.PYLUCID.CSS_PLUGIN_CLASS_NAME,
        "page_robots": "noindex,nofollow",
    }
    return archive_month(
        request, year, month, queryset, date_field="url_date", extra_context=context,
        month_format="%m", allow_empty=True
    )


def day_archive(request, year, month, day):
    """
    TODO: Set previous-/next-day by filtering
    """
    queryset = BlogEntryContent.objects.get_prefiltered_queryset(request, filter_language=False)

    # Add link to the breadcrumbs ;)
    _add_breadcrumb(request,
        _("%(day)s-%(month)s-%(year)s archive") % {"year":year, "month":month, "day":day},
        _("All article from %(day)s-%(month)s-%(year)s") % {"year":year, "month":month, "day":day}
    )

    context = {
        "CSS_PLUGIN_CLASS_NAME": settings.PYLUCID.CSS_PLUGIN_CLASS_NAME,
        "page_robots": "noindex,nofollow",
    }
    return archive_day(
        request, year, month, day, queryset, date_field="url_date", extra_context=context,
        month_format="%m", allow_empty=True
    )


#------------------------------------------------------------------------------


@render_to("blog/select_feed.html")
def select_feed(request):
    """
    Display a list with existing feed filenames.
    TODO: Set http robots ==> "noindex,follow"
    """
    context = {"filenames": FEED_FILENAMES}
    return context


def feed(request, filename, tags=None):
    """
    return RSS/Atom feed for all blog entries and filtered by tags. 
    Feed format is selected by filename.
    """
    for feed_class in FEEDS:
        if filename == feed_class.filename:
            break

    # client favoured Language instance:
    lang_entry = request.PYLUCID.current_language

    # Work-a-round for http://code.djangoproject.com/ticket/13896
    old_lang_code = settings.LANGUAGE_CODE
    settings.LANGUAGE_CODE = lang_entry.code

    feed = feed_class(request, tags)
    response = feed(request)

    settings.LANGUAGE_CODE = old_lang_code

    return response


########NEW FILE########
__FILENAME__ = context_middleware
# -*- coding: utf-8 -*-

"""
    PyLucid breadcrumb plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Generates a horizontal backlink bar.

    Last commit info:
    ~~~~~~~~~
    $LastChangedDate: $
    $Rev: $
    $Author: JensDiemer $

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

__version__ = "$Rev:$"

from django.template import RequestContext
from django.shortcuts import render_to_response

from pylucid_project.apps.pylucid.models import PageTree

from breadcrumb.preference_forms import BreadcumbPrefForm


class ContextMiddleware(object):
    def __init__(self, request):
        self.request = request

        self.linklist = []

    def add_link(self, name, title="", url=None):
        """
        Can be called from plugins, to insert own virtual sub pages.
        if url==None: use full current request path
        """
        url = url or self.request.get_full_path()
        self.linklist.append({"name": name, "title": title, "url": url})

    def render(self):
        # Get preferences
        pref_form = BreadcumbPrefForm()
        pref_data = pref_form.get_preferences()

        # Get all pages back to the root page as a list
        linklist = PageTree.objects.get_backlist(self.request)
        linklist += self.linklist

        context = {
            "preferences": pref_data,
            "linklist": linklist,
        }
        return render_to_response('breadcrumb/breadcrumb.html', context,
            context_instance=RequestContext(self.request)
        )

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext as _

from dbpreferences.forms import DBPreferencesBaseForm


class BreadcumbPrefForm(DBPreferencesBaseForm):
    separator = forms.CharField(
        initial = _(u" \u00BB "),
        help_text = _('Seperator between every breadcrumb link'),
    )
    print_last_page = forms.BooleanField(
        initial = True, required=False,
        help_text = _(
            "If checked the actual page will be the last page in the bar."
            " Otherwise the parentpage."
        ),
    )
    print_index = forms.BooleanField(
        initial = True, required=False,
        help_text = _('If checked every back link bar starts with a link to "index_url"'),
    )
    index_url = forms.CharField(
        initial = "/",
        help_text = _("The url used for print_index. Note: not verify if the url exists."),
    )
    index = forms.CharField(
        initial = _("Index"),
        help_text = _('the name that is printed for the indexpage'),
    )

    class Meta:
        app_label = 'breadcrumb'
########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin views url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from design import admin_views

urlpatterns = patterns('',
    url(r'^switch/$', admin_views.switch, name='Design-switch'),
    url(r'^clone/$', admin_views.clone, name='Design-clone'),
    url(r'^rename_colors/(?P<colorscheme_id>\d+)?/$', admin_views.rename_colors, name='Design-rename_colors'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding: utf-8

"""
    PyLucid admin views
    ~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import posixpath

from django import http
from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.template.base import TemplateDoesNotExist
from django.template.loader import find_template_loader
from django.utils.translation import ugettext as _

from dbtemplates.models import Template as DBTemplateModel

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import Design, Color, ColorScheme
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu
from pylucid_project.utils.css_color_utils import unique_color_name

from .forms import SwitchDesignForm, CloneDesignForm


def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("edit look")
    admin_menu.add_menu_entry(
        parent=menu_section_entry, url_name="Design-switch",
        name="switch design", title="Switch the page design, temporary.",
    )
    admin_menu.add_menu_entry(
        parent=menu_section_entry, url_name="Design-clone",
        name="clone design",
        title="Clone a existing page design with all associated components.",
    )

    return "\n".join(output)


@check_permissions(superuser_only=False, permissions=("pylucid.change_design",))
@render_to("design/switch.html")
def switch(request):
    """
    'switch' the design.
    Save design ID in request.session["design_switch_pk"]
    This value would be used in design.signal_reveiver
    """
    context = {
        "title": _("Switch a PyLucid page design"),
        "form_url": request.path,
    }

    if "design_switch_pk" in request.session:
        design_id = request.session["design_switch_pk"]
        try:
            context["design_switch"] = Design.on_site.get(id=design_id)
        except Design.DoesNotExist, err:
            messages.error(request, _(
                    "Error: Design with ID %(id)r doesn't exist: %(err)s"
                ) % {"id":design_id, "err": err}
                )
            del request.session["design_switch_pk"]
            design_id = 0
    else:
        design_id = 0

    if request.method == "POST":
        form = SwitchDesignForm(request.POST)
        if form.is_valid():
            design_id = int(form.cleaned_data["design"])
            if design_id == 0:
                # reset to automatic selection by pagetree association
                if "design_switch_pk" in request.session:
                    del request.session["design_switch_pk"]
                messages.info(request,
                    _("delete 'design switch', turn to automatic mode.")
                )
            else:
                messages.info(request, _("Save design ID %r") % design_id)
                request.session["design_switch_pk"] = design_id
            return http.HttpResponseRedirect(request.path)
    else:
        form = SwitchDesignForm(initial={"design": design_id})

    context["form"] = form
    return context


#------------------------------------------------------------------------------
# clone design


def get_template_source(template_name):
    """
    Return the source code of a template (not a compiled version)
    FIXME: Is there no django API for this?
    """
    for loader_name in settings.TEMPLATE_LOADERS:
        loader = find_template_loader(loader_name)
        if loader is None:
            continue
        try:
            template_source = loader.load_template_source(template_name)[0]
        except TemplateDoesNotExist:
            continue
        else:
            return template_source
    raise TemplateDoesNotExist(template_name)


def _clone_template(design, new_template_name, sites):
    """
    create a new DB-Template entry with the content from
    the design template
    """
    template_path = design.template
    source = get_template_source(template_path)
    new_template = DBTemplateModel(name=new_template_name, content=source)
    new_template.save(force_insert=True)
    new_template.sites = sites
    new_template.save(force_update=True)
    return new_template


def _clone_headfiles(design, new_name, sites):
    """ Clone all headfiles from the given source design. """
    new_headfiles = []
    old_headfiles = design.headfiles.all()
    for headfile in old_headfiles:
        old_filepath = headfile.filepath
        basename = posixpath.basename(old_filepath)
        new_filepath = posixpath.join(new_name, basename)

        headfile.pk = None # make the object "new" ;)
        headfile.filepath = new_filepath
        headfile.description += "\n(cloned from '%s')" % old_filepath
        headfile.save(force_insert=True)
        headfile.sites = sites
        headfile.save(force_update=True)

        new_headfiles.append(headfile)

    return new_headfiles


def _clone_colorscheme(design, new_name, sites):
    """
    Clone the colorscheme and all colors.
    """
    colorscheme = design.colorscheme
    if colorscheme is None:
        # design used no colorscheme
        return

    colors = Color.objects.filter(colorscheme=colorscheme)

    colorscheme.pk = None # make the object "new" ;)
    colorscheme.name = new_name
    colorscheme.save(force_insert=True)
    colorscheme.sites = sites
    colorscheme.save(force_update=True)

    for color in colors:
        color.pk = None # make the object "new" ;)
        color.colorscheme = colorscheme
        color.save(force_insert=True)
        color.sites = sites
        color.save(force_update=True)

    return colorscheme


@check_permissions(superuser_only=False, permissions=(
    "pylucid.add_design",
    "pylucid.add_editablehtmlheadfile",
    "pylucid.add_color",
    "pylucid.add_colorscheme",
    "dbtemplates.add_template",
    )
)
@render_to("design/clone.html")
def clone(request):
    context = {
        "title": _("Clone a existing page design with all associated components."),
        "form_url": request.path,
    }

    if request.method == "POST":
        form = CloneDesignForm(request.POST)
        if form.is_valid():
            messages.info(request, form.cleaned_data)

            new_name = form.cleaned_data["new_name"]
            sites = form.cleaned_data["sites"]

            design_id = int(form.cleaned_data["design"])
            design = Design.objects.get(id=design_id)

            new_template_name = form.get_new_template_name()
            new_template = _clone_template(design, new_template_name, sites)

            new_headfiles = _clone_headfiles(design, new_name, sites)

            new_colorscheme = _clone_colorscheme(design, new_name, sites)

            design.pk = None # make the object "new" ;)
            design.name = new_name
            design.template = new_template.name
            design.colorscheme = new_colorscheme
            design.save(force_insert=True)
            design.sites = sites
            design.headfiles = new_headfiles
            design.save(force_update=True)

            messages.success(request, _("New design '%s' created.") % new_name)
            return http.HttpResponseRedirect(request.path)
    else:
        form = CloneDesignForm()

    context["form"] = form
    return context


@check_permissions(superuser_only=False, permissions=(
    "pylucid.change_editablehtmlheadfile",
    "pylucid.change_color",
    )
)
def rename_colors(request, colorscheme_id):
    """
    TODO: display the changed colors in a form, so that the user
    can choose witch colors should really be renamed.
    """
    colorschmeme = ColorScheme.objects.get(id=colorscheme_id)
    colors = Color.objects.filter(colorscheme=colorschmeme)

    changed_colors = 0
    existing_colors = []
    for color in colors:
        hex_string = color.value
        old_color_name = color.name
        new_color_name = unique_color_name(existing_colors, hex_string)
        existing_colors.append(new_color_name) # needed to make names unique
        if new_color_name == old_color_name:
            # nothing to do
            continue
        color.name = new_color_name
        color.save()
        changed_colors += 1

    messages.info(request, "%s colors exist. %s changed" % (len(existing_colors), changed_colors))

    url = reverse("admin:pylucid_colorscheme_change", args=(colorscheme_id,))
    return http.HttpResponseRedirect(url)

########NEW FILE########
__FILENAME__ = forms
# coding:utf-8

from django import forms
from django.contrib.sites.models import Site
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.models import Design, EditableHtmlHeadFile, \
                                                        ColorScheme
from django.template.loader import find_template
from django.template import TemplateDoesNotExist
from django.core.urlresolvers import reverse, NoReverseMatch




class SelectDesignBaseForm(forms.Form):
    """
    Select a exsiting design. Used in "switch design" and "clone design"
    """
    design = forms.ChoiceField(
        # choices= Set in __init__, so the Queryset would not execute at startup
        required=False, initial=None,
        help_text=_("Select the PyLucid page design")
    )

    def __init__(self, *args, **kwargs):
        super(SelectDesignBaseForm, self).__init__(*args, **kwargs)

        designs = Design.on_site.all().values_list("id", "name")
        self.fields["design"].choices = list(designs)


class SwitchDesignForm(SelectDesignBaseForm):
    def __init__(self, *args, **kwargs):
        super(SwitchDesignForm, self).__init__(*args, **kwargs)
        self.fields["design"].choices.insert(0, (0, "<automatic>"))



class CloneDesignForm(SelectDesignBaseForm):
    new_name = forms.CharField(
        help_text=_("Name of the cloned design. (used for all design components, too)")
    )
    sites = forms.MultipleChoiceField(
        # choices= Set in __init__, so the Queryset would not execute at startup
        help_text=_("Site set to all design components")
    )

    def __init__(self, *args, **kwargs):
        super(CloneDesignForm, self).__init__(*args, **kwargs)
        self.fields["sites"].choices = Site.objects.all().values_list("id", "name")
        self.fields["sites"].initial = [Site.objects.get_current().id]

    def get_new_template_name(self):
        new_name = self.cleaned_data["new_name"]
        return "%s.html" % new_name

    def clean_new_name(self):
        new_name = self.cleaned_data["new_name"]
        new_name = new_name.strip()

        try: # "validate" with the url re FIXME: Do it better ;) 
            reverse('PyLucid-send_head_file', kwargs={"filepath": new_name})
        except NoReverseMatch, err:
            raise forms.ValidationError(_(
                "new name contains invalid characters!"
                " (Original error: %s)" % err,
            ))

        if Design.objects.filter(name__iexact=new_name).count() != 0:
            raise forms.ValidationError(_("A design with this name exist already."))

        if ColorScheme.objects.filter(name__iexact=new_name).count() != 0:
            raise forms.ValidationError(_("A ColorScheme with this name exist already."))

        if EditableHtmlHeadFile.objects.filter(filepath__istartswith=new_name).count() != 0:
            raise forms.ValidationError(_("A editable headfile filepath startswith with this new name."))

        template_name = self.get_new_template_name()
        try:
            find_template(template_name)
        except TemplateDoesNotExist, err:
            pass
        else:
            raise forms.ValidationError(_("A template named '%s' exist already") % template_name)

        return new_name



########NEW FILE########
__FILENAME__ = signal_receiver
# coding: utf-8

"""
    PyLucid design plugin
    ~~~~~~~~~~~~~~~~~~~~~

    signal receiver, connected in design.__init__.py

    switch design, if "design_switch_pk" in request.session

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _
from django.template.loader import render_to_string


def pre_render_global_template_handler(**kwargs):
    """
    Handle the 'pre_render_global_template' signal.
    """
    request = kwargs["request"]
    if "design_switch_pk" not in request.session:
        # The user has not switch the design
        return

    from pylucid_project.apps.pylucid.models import Design # import here, agains import loops

    pagetree = request.PYLUCID.pagetree

    design_id = request.session["design_switch_pk"]
    pagetree.design = Design.on_site.get(id=design_id)

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8


"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - There exist only "PyLucid CMS" blog entry in english and german
        
    TODO:
        * Rewrite tests if we use django-compressor
        * Test clone colorscheme in admin
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os

if __name__ == "__main__":
    # run all unittest directly
    from django.core import management
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase

from dbtemplates.models import Template as DBTemplateModel

from django_tools.unittest_utils.unittest_base import BaseTestCase

from pylucid_project.apps.pylucid.models import Design, EditableHtmlHeadFile, ColorScheme, Color
from pylucid_project.tests.test_tools import basetest


DESIGN_UNITTEST_FIXTURES = os.path.join(settings.PYLUCID_BASE_PATH, "pylucid_plugins", "design", "test_fixtures.json")


class SwitchDesignTest(basetest.BaseUnittest):
    def _pre_setup(self, *args, **kwargs):
        super(SwitchDesignTest, self)._pre_setup(*args, **kwargs)

        self.url = reverse("Design-switch")
        self.login("superuser")

    def test_request_form(self):
        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=(
                "Switch a PyLucid page design",
                '<option value="0" selected="selected">&lt;automatic&gt;</option>',
                self.url,
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

    def test_switch(self):
        # request root page before switch design
        response = self.client.get("/en/welcome/")
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - Welcome to your PyLucid CMS =;-)</title>'
                'initial_site_style/main.css" rel="stylesheet"'
                '<div id="the_menu">'
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

        # switch design
        response = self.client.post(self.url, data={"design":4}, follow=True)
        self.assertResponse(response,
            must_contain=(
                "Switch a PyLucid page design",
                'Save design ID 4',
                'current page design is switched to: <strong>Page design &#39;elementary&#39;',
                '<option value="4" selected="selected">elementary</option>',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

        # request root page after design switch
        response = self.client.get("/en/welcome/")
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - Welcome to your PyLucid CMS =;-)</title>'
                'initial_site_style/elementary.css" rel="stylesheet"'
            ),
            must_not_contain=('<div id="the_menu">', "Traceback", "XXX INVALID TEMPLATE STRING")
        )

        # Delete design and test request
        Design.objects.get(id=4).delete()

        # Should switch back to main design and give a page messages
        response = self.client.get("/en/welcome/")
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - Welcome to your PyLucid CMS =;-)</title>',
                'initial_site_style/main.css" rel="stylesheet"',
                'Can&#39;t switch to design with ID 4: Design matching query does not exist.',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )


class CloneDesignTest(basetest.BaseUnittest, TestCase):
    def _pre_setup(self, *args, **kwargs):
        super(CloneDesignTest, self)._pre_setup(*args, **kwargs)

        self.url = reverse("Design-clone")
        self.login("superuser")

    def test_request_form(self):
        response = self.client.get(self.url)
        self.assertDOM(response,
            must_contain=(
                '<input id="id_new_name" name="new_name" type="text" />',
            )
        )
        self.assertResponse(response,
            must_contain=(
                "Clone a existing page design",
                '<select', 'id="id_design"', 'name="design"',
                "clone design",
            ),
            must_not_contain=("Traceback",)
        )

    def test_clone(self):
        new_name = "new_test_design"

        response = self.client.post(self.url, data={
            'design': Design.on_site.all()[0].pk,
            'new_name': new_name,
            'save': 'clone design',
            'sites': 1}
        )

        new_url = "http://testserver/pylucid_admin/plugins/design/clone/"
        self.assertRedirect(response, url=new_url, status_code=302)

        response = self.client.get(new_url)
        self.assertDOM(response,
            must_contain=(
                '<input id="id_new_name" name="new_name" type="text" />',
            )
        )
        self.assertResponse(response,
            must_contain=(
                "Clone a existing page design",
                '<select', 'id="id_design"', 'name="design"',
                "clone design",
                "New design &#39;%s&#39; created." % new_name,
            ),
            must_not_contain=("Traceback",)
        )

        self.assertTrue(
            Design.objects.filter(name__exact=new_name).count() == 1
        )
        self.assertTrue(
            ColorScheme.objects.filter(name__exact=new_name).count() == 1
        )
        self.assertTrue(
            EditableHtmlHeadFile.objects.filter(filepath__startswith="%s/" % new_name).count() > 0
        )
        self.assertTrue(
            DBTemplateModel.objects.filter(name__exact="%s.html" % new_name).count() == 1
        )

#------------------------------------------------------------------------------





class FixtureDataDesignTest(BaseTestCase, TestCase):
    fixtures = [
        # Special test users:
        os.path.join(settings.PYLUCID_BASE_PATH, "tests/fixtures/test_users.json"),
        DESIGN_UNITTEST_FIXTURES
    ]

    # normal: "* { color: {{ foreground }}; }\r\nbody { background: {{ background }}; }"
    # invert: "body { background: {{ foreground }}; }\r\n* { color: {{ background }}; }"
    # colorscheme1 (yellow):
    #    background: #222200;
    #    foreground: #aaaa00;
    # colorscheme2 (blue):
    #    background: #000040;
    #    foreground: #0000ff;

    YELLOW_STYLES = "* { color: #aaaa00; }\r\nbody { background: #222200; }"
    BLUE_STYLES = "* { color: #0000ff; }\r\nbody { background: #000040; }"
    INVERTED_BLUE_STYLES = "body { background: #0000ff; }\r\n* { color: #000040; }"
    INVERTED_YELLOW_STYLES = "body { background: #aaaa00; }\r\n* { color: #222200; }"

    def _pre_setup(self, *args, **kwargs):
        """
        Prepare
        """
        super(FixtureDataDesignTest, self)._pre_setup(*args, **kwargs)

        self.login("superuser")

        self.colorscheme1 = ColorScheme.objects.get(name="yellow")
        self.colorscheme2 = ColorScheme.objects.get(name="blue")

        #print EditableHtmlHeadFile.objects.all()
        self.headfile1 = EditableHtmlHeadFile.objects.get(filepath="test_styles.css")
        self.headfile2 = EditableHtmlHeadFile.objects.get(filepath="inverted_test_styles.css")

        self.url_edit_headfile = reverse("admin:pylucid_editablehtmlheadfile_change", args=(self.headfile1.id,))
        self.url_edit_colorscheme1 = reverse("admin:pylucid_colorscheme_change", args=(self.colorscheme1.pk,))
        self.url_edit_colorscheme2 = reverse("admin:pylucid_colorscheme_change", args=(self.colorscheme2.pk,))

        self.design1 = Design.objects.get(name="yellow")
        self.design2 = Design.objects.get(name="blue")
        self.design3 = Design.objects.get(name="inverted blue")
        self.design4 = Design.objects.get(name="inverted yellow")

        self.test_css_url1 = "/static/PyLucid_cache/ColorScheme_1/test_styles.css"
        self.test_css_url2 = "/static/PyLucid_cache/ColorScheme_2/test_styles.css"

    def setUp(self):
        removed_items = EditableHtmlHeadFile.objects.clean_headfile_cache()
        #print removed_items
        self.assertEqual(Color.objects.all().filter(colorscheme=self.colorscheme1).count(), 2)
        self.assertEqual(Color.objects.all().filter(colorscheme=self.colorscheme2).count(), 2)

        self._old_debug = settings.DEBUG
        settings.DEBUG = True # Needed to serve static files

    def tearDown(self):
        settings.DEBUG = self._old_debug

    def request_style(self, design):
        headfile = design.headfiles.all()[0]
        colorscheme = design.colorscheme
        url = headfile.get_absolute_url(colorscheme)
        self.assertTrue("/PyLucid_cache/" in url)
        response = self.client.get(url)
        self.assertResponse(response,
            must_not_contain=("<head>", "<title>", "</body>", "</html>")
        )
        return response

    def check_styles(self):
        response = self.request_style(self.design1)
        self.assertEqual(response.content, self.YELLOW_STYLES)
        response = self.request_style(self.design2)
        self.assertEqual(response.content, self.BLUE_STYLES)
        response = self.request_style(self.design3)
        self.assertEqual(response.content, self.INVERTED_BLUE_STYLES)
        response = self.request_style(self.design4)
        self.assertEqual(response.content, self.INVERTED_YELLOW_STYLES)

    def test_clean_cache_for_non_render(self):
        """
        headfiles without render a colorscheme, should also cleanup cache file ;)
        """
        self.headfile1.render = False
        self.headfile1.content = "one"
        self.headfile1.save()
        url = self.headfile1.get_absolute_url()
        self.assertTrue("/PyLucid_cache/" in url)
        response = self.client.get(url)
        self.assertEqual(response.content, "one")

        self.headfile1.content = "two"
        self.headfile1.save()
        url = self.headfile1.get_absolute_url()
        self.assertTrue("/PyLucid_cache/" in url)
        response = self.client.get(url)
        self.assertEqual(response.content, "two")

    def test_past_existing_colors(self):
        old_content = self.headfile1.content
        response = self.client.post(self.url_edit_headfile,
            data={
                "filepath": self.headfile1.filepath,
                "_continue": "",
                "render": 1,
                'sites': 1,
                "content": self.YELLOW_STYLES,
            }
        )
        self.assertRedirect(response, status_code=302,
            url="http://testserver" + self.url_edit_headfile
        )
        response = self.client.get(self.url_edit_headfile)
        self.assertResponse(response,
            must_contain=(
                "Merge colors with colorscheme &quot;yellow&quot; (score: 2, tested 2 colorschemes)",
                old_content,
                "was changed successfully. You may edit it again below.",
            ),
            must_not_contain=("Traceback", "created in colorscheme")
        )

        # Check if colors created
        self.assertEqual(Color.objects.all().filter(colorscheme=self.colorscheme1).count(), 2)
        self.assertEqual(Color.objects.all().filter(colorscheme=self.colorscheme2).count(), 2)

        # The headfile content should not changed
        self.headfile1 = EditableHtmlHeadFile.objects.get(pk=self.headfile1.pk)
        self.assertEqual(self.headfile1.content, old_content)

        # The rendered styles should not changed
        self.check_styles()

    def test_yellow_page(self):
        response = self.client.get("/en/yellow/")
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - yellow</title>',
                '<link href="%s" rel="stylesheet" type="text/css" />' % self.test_css_url1,
                'yellow design test page content',
            ),
            must_not_contain=("Traceback",)
        )

    def test_blue_page(self):
        response = self.client.get("/en/blue/")
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - blue</title>',
                '<link href="%s" rel="stylesheet" type="text/css" />' % self.test_css_url2,
                'blue design test page content',
            ),
            must_not_contain=("Traceback",)
        )

    def test_design_admin_page(self):
        url = reverse("admin:pylucid_design_changelist")
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Select design to change</title>',

                # Color previews        
                '<span style="background-color:#222200;">',
                '<span style="background-color:#aaaa00;">',
                '<span style="background-color:#000040;">',
                '<span style="background-color:#0000ff;">',

                # edit template                
                '<a href="/admin/dbtemplates/template/1/"',
                'test_template.html</a>',

                # edit stylesheet
                '<a href="/admin/pylucid/editablehtmlheadfile/1/"',
                'test_styles.css',

                self.test_css_url1, self.test_css_url2,


            ),
            must_not_contain=("Traceback",)
        )

    def test_colorscheme_change(self):
        response = self.client.get(self.url_edit_colorscheme1)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Change color scheme</title>',
                'colorpicker.css', 'colorpicker.js',
                'Change color scheme',

                # colorscheme name:
                'name="name" type="text" value="yellow" />',

                # colors:
                'name="color_set-0-name" type="text" value="background" />',
                'name="color_set-0-value" style="background-ColorValue:#222200;" type="text" value="222200" />',
                'name="color_set-1-name" type="text" value="foreground" />',
                'name="color_set-1-value" style="background-ColorValue:#aaaa00;" type="text" value="aaaa00" />',
            ),
            must_not_contain=("Traceback",)
        )

    def test_merge_colors(self):
        Color.objects.create(name="existing_red", value="ff0000", colorscheme=self.colorscheme1)
        Color.objects.create(name="existing_green", value="00ff00", colorscheme=self.colorscheme2)
        self.headfile1.content += "old: #0000Ff; existing_red: #F00; existing_green: #0f0; new: #f0f;"
        self.headfile1.save()

        self.assertEqual(self.headfile1.content,
            "* { color: {{ foreground }}; }\r\nbody { background: {{ background }}; }"
            "old: {{ foreground }}; existing_red: {{ existing_red }}; existing_green: {{ existing_green }}; new: {{ fuchsia }};"
        )

        response = self.request_style(self.design1)
        self.assertEqual(response.content,
            self.YELLOW_STYLES + "old: #aaaa00; existing_red: #ff0000; existing_green: #00ff00; new: #ff00ff;"
        )
        response = self.request_style(self.design2)
        self.assertEqual(response.content,
            self.BLUE_STYLES + "old: #0000ff; existing_red: #ff0000; existing_green: #00ff00; new: #ff00ff;"
        )
        response = self.request_style(self.design3)
        self.assertEqual(response.content, self.INVERTED_BLUE_STYLES)
        response = self.request_style(self.design4)
        self.assertEqual(response.content, self.INVERTED_YELLOW_STYLES)

    def test_create_new_colors(self):
        new_content1 = self.headfile1.content + (
            "\r\n"
            "ul { color: #f00; }"
            "\r\n"
            "a { color: #ff0000; }"
        )
        new_content2 = self.headfile1.content + (
            "\r\n"
            "ul { color: {{ red }}; }"
            "\r\n"
            "a { color: {{ red }}; }"
        )


        response = self.client.post(self.url_edit_headfile,
            data={
                "filepath": self.headfile1.filepath,
                "_continue": "",
                "render": 1,
                'sites': 1,
                "content": new_content1,
            }
        )
        self.assertRedirect(response, status_code=302,
            url="http://testserver" + self.url_edit_headfile
        )
        response = self.client.get(self.url_edit_headfile)
        self.assertResponse(response,
            must_contain=(
                "Merge colors with colorscheme &quot;yellow&quot; (score: -1, tested 2 colorschemes)",
                "Colors &quot;red:ff0000&quot; created in colorscheme &quot;yellow&quot;",
                "Colors &quot;red:ff0000&quot; created in colorscheme &quot;blue&quot;",

                new_content2,
                "was changed successfully. You may edit it again below.",
            ),
            must_not_contain=("Traceback",)
        )

        # Check if colors created
        self.assertEqual(Color.objects.all().filter(colorscheme=self.colorscheme1).count(), 3)
        self.assertEqual(Color.objects.all().filter(colorscheme=self.colorscheme2).count(), 3)

        # Check if headfile content really changed:
        self.headfile1 = EditableHtmlHeadFile.objects.get(pk=self.headfile1.pk)
        self.assertEqual(self.headfile1.content, new_content2)

        # Check the rendered styles
        added_styles = (
            "\r\n"
            "ul { color: #ff0000; }"
            "\r\n"
            "a { color: #ff0000; }"
        )
        response = self.request_style(self.design1)
        self.assertEqual(response.content, self.YELLOW_STYLES + added_styles)
        response = self.request_style(self.design2)
        self.assertEqual(response.content, self.BLUE_STYLES + added_styles)

        # The inverted design, should not changed
        response = self.request_style(self.design3)
        self.assertEqual(response.content, self.INVERTED_BLUE_STYLES)
        response = self.request_style(self.design4)
        self.assertEqual(response.content, self.INVERTED_YELLOW_STYLES)

    def test_change_colors(self):
        response = self.client.post(
            self.url_edit_colorscheme1,
            data={'_continue': 'Save and continue editing',
                'color_set-0-colorscheme': '1',
                'color_set-0-id': '1',
                'color_set-0-name': 'background',
                'color_set-0-sites': '1',
                'color_set-0-value': '222200',
                'color_set-1-colorscheme': '1',
                'color_set-1-id': '2',
                'color_set-1-name': 'foreground',
                'color_set-1-sites': '1',
                'color_set-1-value': '0000ff',
                'color_set-INITIAL_FORMS': '2',
                'color_set-TOTAL_FORMS': '2',
                'color_set-__prefix__-colorscheme': '1',
                'color_set-__prefix__-sites': '1',
                'name': 'yellow',
                'sites': '1'}
        )
        self.assertRedirect(response, status_code=302,
            url="http://testserver" + self.url_edit_colorscheme1
        )
        response = self.client.get(self.url_edit_colorscheme1)
        self.assertDOM(response,
            must_contain=(
                # colorscheme name:
                '<input name="name" value="yellow" class="vTextField" maxlength="255" type="text" id="id_name" />',
                #colors:
                '<input name="color_set-0-name" value="background" class="vTextField" maxlength="128" type="text" id="id_color_set-0-name" />',
                '<input style="background-ColorValue:#222200;" name="color_set-0-value" value="222200" maxlength="6" type="text" id="id_color_set-0-value" />',
                '<input name="color_set-0-name" value="background" class="vTextField" maxlength="128" type="text" id="id_color_set-0-name" />',
                '<input style="background-ColorValue:#0000ff;" name="color_set-1-value" value="0000ff" maxlength="6" type="text" id="id_color_set-1-value" />',
            )
        )
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Change color scheme</title>',
                'colorpicker.css', 'colorpicker.js',
                'Change color scheme',
            ),
            must_not_contain=("Traceback", "This field is required.")
        )
        # Changed yellow styles:
        response = self.request_style(self.design1)
        self.assertEqual(response.content, "* { color: #0000ff; }\r\nbody { background: #222200; }")
        response = self.request_style(self.design4)
        self.assertEqual(response.content, "body { background: #0000ff; }\r\n* { color: #222200; }")

        # Blue styles should not be changed:
        response = self.request_style(self.design2)
        self.assertEqual(response.content, self.BLUE_STYLES)
        response = self.request_style(self.design3)
        self.assertEqual(response.content, self.INVERTED_BLUE_STYLES)

    def test_rename_color(self):
        response = self.client.post(
            self.url_edit_colorscheme1,
            data={'_continue': 'Save and continue editing',
                'color_set-0-colorscheme': '1',
                'color_set-0-id': '1',
                'color_set-0-name': 'hintergrund',
                'color_set-0-sites': '1',
                'color_set-0-value': '222200',
                'color_set-1-colorscheme': '1',
                'color_set-1-id': '2',
                'color_set-1-name': 'vordergrund',
                'color_set-1-sites': '1',
                'color_set-1-value': 'aaaa00',
                'color_set-INITIAL_FORMS': '2',
                'color_set-TOTAL_FORMS': '2',
                'color_set-__prefix__-colorscheme': '1',
                'color_set-__prefix__-sites': '1',
                'name': 'yellow',
                'sites': '1'}
        )
        self.assertRedirect(response, status_code=302,
            url="http://testserver" + self.url_edit_colorscheme1
        )
        response = self.client.get(self.url_edit_colorscheme1)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Change color scheme</title>',
                'colorpicker.css', 'colorpicker.js',
                'Change color scheme',

                # page message:                
                'Color &quot;background&quot; renamed to &quot;hintergrund&quot;:Headfiles &quot;test_styles.css&quot;, &quot;inverted_test_styles.css&quot; and colorschemes &quot;yellow&quot;, &quot;blue&quot; updated.',
                'Color &quot;foreground&quot; renamed to &quot;vordergrund&quot;:Headfiles &quot;test_styles.css&quot;, &quot;inverted_test_styles.css&quot; and colorschemes &quot;yellow&quot;, &quot;blue&quot; updated.',

                # colorscheme name:
                'name="name" type="text" value="yellow" />',

                # colors:
                'name="color_set-0-name" type="text" value="hintergrund" />',
                'name="color_set-0-value" style="background-ColorValue:#222200;" type="text" value="222200" />',
                'name="color_set-1-name" type="text" value="vordergrund" />',
                'name="color_set-1-value" style="background-ColorValue:#aaaa00;" type="text" value="aaaa00" />',
            ),
            must_not_contain=("Traceback", "This field is required.")
        )

        # Check sended styles, they must be the same
        self.check_styles()

    def test_remove_unused_colors(self):
        c = Color.objects.create(name="unused1", value="ffffff", colorscheme=self.colorscheme1)

#        cleanup_url = reverse("admin:pylucid_colorscheme_change", args=(self.colorscheme1.pk,))
        response = self.client.get(self.url_edit_colorscheme1 + "cleanup/")
        self.assertRedirect(response, status_code=302,
            url="http://testserver" + self.url_edit_colorscheme1
        )
        response = self.client.get(self.url_edit_colorscheme1)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Change color scheme</title>',
                'colorpicker.css', 'colorpicker.js',
                'Change color scheme',

                # page message:                
                'existing colors: &quot;foreground&quot;, &quot;background&quot;',
                'remove 1 colors: &quot;unused1&quot;',

                # colorscheme name:
                'name="name" type="text" value="yellow" />',

                # colors:
                'name="color_set-0-name" type="text" value="background" />',
                'name="color_set-0-value" style="background-ColorValue:#222200;" type="text" value="222200" />',
                'name="color_set-1-name" type="text" value="foreground" />',
                'name="color_set-1-value" style="background-ColorValue:#aaaa00;" type="text" value="aaaa00" />',
            ),
            must_not_contain=("Traceback", "This field is required.")
        )

        self.check_styles()

    def test_new_render_headfile(self):
        url = reverse("admin:pylucid_editablehtmlheadfile_add")
        response = self.client.post(url,
            data={
                '_continue': 'Save and continue editing',
                 'content': '#00ff00;',
                 'filepath': 'new_without_design.css',
                 'render': 'on'
            },
            follow=True,
        )
        self.assertResponse(response,
            must_contain=(
                "This headfile can't be rendered, because it's not used in a design witch has a colorscheme!"
            ),
            must_not_contain=(
                "Traceback",
                "was added successfully"
            )
        )

    def test_new_headfile(self):
        """
        Two tests: Create a non-render headfile and assign it to a colorscheme design
        """
        url = reverse("admin:pylucid_editablehtmlheadfile_add")
        response = self.client.post(url,
            data={
                '_continue': 'Save and continue editing',
                 'content': '#00ff00;',
                 'filepath': 'new_headfile.css',
            },
            follow=True,
        )
        self.assertResponse(response,
            must_contain=(
                "The editable html head file &quot;new_headfile.css&quot; was added successfully. You may edit it again below.",
                '<input id="id_render" name="render" type="checkbox" />',
                "#00ff00;</textarea>",
            ),
            must_not_contain=("Traceback",)
        )

        headfile = EditableHtmlHeadFile.objects.get(filepath="new_headfile.css")
        headfile_url = headfile.get_absolute_url()
        response = self.client.get(headfile_url)
        self.assertEqual(response.content, "#00ff00;")

        # Add the new headfile to a design with colorscheme and change the color value:

        self.design1.headfiles.add(headfile)

        url = reverse("admin:pylucid_editablehtmlheadfile_change", args=(headfile.id,))
        response = self.client.post(url,
            data={
                '_continue': 'Save and continue editing',
                 'content': '#00ffff;',
                 'filepath': 'new_headfile.css',
                 'render': 'on'
            },
            follow=True,
        )
        # The color value must be replace with a named color:
        self.assertResponse(response,
            must_contain=(
                "Colors &quot;cyan:00ffff&quot; created in colorscheme &quot;yellow&quot;",
                "The editable html head file &quot;new_headfile.css&quot; was changed successfully. You may edit it again below.",
                '<input checked="checked" id="id_render" name="render" type="checkbox" />',
                "{{ cyan }};</textarea>",
            ),
            must_not_contain=("Traceback",)
        )
        headfile = EditableHtmlHeadFile.objects.get(filepath="new_headfile.css") # renew object
        headfile_url = headfile.get_absolute_url(self.colorscheme1)

        response = self.client.get(headfile_url)
        # The cache file should be updated:
        self.assertEqual(response.content, "#00ffff;")



if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#    tests = "pylucid_plugins.design.tests.SwitchDesignTest"

    management.call_command('test', tests,
        verbosity=2,
#        failfast=True
    )

########NEW FILE########
__FILENAME__ = context_middleware
# coding: utf-8


"""
    PyLucid extrahead context middleware
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    replace <!-- ContextMiddleware extrahead --> in the global page template with
    all extra head html code, stored in request.PYLUCID.extrahead (pylucid.system.extrahead)
    
    Add all headfile links from pagetree.design.headfiles m2m.
    
    PyLucid plugins should use {% extrahead %} block tag (pylucid.defaulttags.extraheadBlock)
    in plugin template for insert e.g. CSS/JS file links into html head.

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django.template.loader import render_to_string


class ContextMiddleware(object):
    """ replace <!-- ContextMiddleware extrahead --> in the global page template """
    def __init__(self, request):
        self.request = request
        self.extrahead = request.PYLUCID.extrahead # pylucid.system.extrahead

    def _add_pagetree_headfiles(self):
        """ add all headfile links used in the current design. """
        pagetree = self.request.PYLUCID.pagetree
        design = pagetree.design
        self.extrahead.append(design.get_headfile_data())

    def render(self):
        """ return all extra head content with all headfiles from current used design """
        self._add_pagetree_headfiles()

#        for entry in self.extrahead:
#            print "***", entry

        return "\n".join(self.extrahead)


########NEW FILE########
__FILENAME__ = views
# coding: utf-8


"""
    PyLucid extrahead plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.contrib import messages

from pylucid_project.apps.pylucid.models import EditableHtmlHeadFile


def lucidTag(request, filepath):
    """
    Add a headfile inline into the page.
    example:
        {% lucidTag extrahead filepath="/path/to/the/file" %}
    """
    try:
        headfile = EditableHtmlHeadFile.objects.get(filepath=filepath)
    except EditableHtmlHeadFile.DoesNotExist, e:
        msg = u"Wrong headfile path."
        if request.user.is_staff:
            msg += u" (filepath: %r)" % filepath
            messages.error(request, "Headfile with filepath %r doesn't exist: %s" % (filepath, e))
        return "[%s]" % msg


    if not headfile.render:
        colorscheme = None
    else:
        try:
            pagetree = request.PYLUCID.pagetree
            design = pagetree.design
            colorscheme = design.colorscheme
        except AttributeError, e:
            msg = (
                "The headfile %r should be rendered with a colorscheme,"
                " but i can't get one: %s"
            ) % (headfile, e)
            raise AttributeError(msg)

    html = headfile.get_inline_html(colorscheme)

    return html

########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from pylucid_project.pylucid_plugins.filemanager import admin_views

urlpatterns = patterns('',
    url(r'^filemanager/$', admin_views.index, name='Filemanager-index'),
    url(r'^filemanager/(?P<no>\d)/(?P<rest_url>.*?)$', admin_views.filemanager, name='Filemanager-filemanager'),
)

########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8

"""
    filemanager admin views
    ~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os
import posixpath
import pwd

if __name__ == "__main__":
    # For doctest only
    os.environ["DJANGO_SETTINGS_MODULE"] = "django.conf.global_settings"
    from django.conf import global_settings
    global_settings.SITE_ID = 1

from django.contrib import messages
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect, Http404

from django_tools.filemanager.filemanager import BaseFilemanager

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu

from pylucid_project.pylucid_plugins.filemanager.preference_forms import FilemanagerPrefForm
from pylucid_project.pylucid_plugins.filemanager.forms import BasePathSelect, \
    UploadFileForm




def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("tools")

    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="filemanager", title="Filemanager for static/media files",
        url_name="Filemanager-index"
    )

    return "\n".join(output)

#-----------------------------------------------------------------------------

class Filemanager(BaseFilemanager):
    def __init__(self, url_prefix, request, absolute_path, base_url, rest_url, allow_upload):
        self.url_prefix = url_prefix # For building links to the files

        super(Filemanager, self).__init__(request, absolute_path, base_url, rest_url, allow_upload)

        pref_form = FilemanagerPrefForm()
        self.preferences = pref_form.get_preferences()

    def get_filesystem_item_instance(self, *args, **kwargs):
        """
        Add url to this filesystem item, if url_prefix was set in base path config
        """
        instance = super(Filemanager, self).get_filesystem_item_instance(*args, **kwargs)

        if self.url_prefix:
            instance.url = posixpath.join(self.url_prefix, self.rel_url, instance.name)
            if instance.is_dir:
                instance.url += "/"

        return instance

#-----------------------------------------------------------------------------

def _reverse_filemanager_url(base_path_no):
    url = reverse('Filemanager-filemanager',
        kwargs={"no": base_path_no, "rest_url":""}
    )
    return url

def _redirect2filemanager(base_path_no):
    url = _reverse_filemanager_url(base_path_no)
    return HttpResponseRedirect(url)


@check_permissions(superuser_only=True)
def index(request):
    form = BasePathSelect()
    initial_base_path = form.fields["base_path"].initial
    base_path_no = initial_base_path[0]
    return _redirect2filemanager(base_path_no)


@check_permissions(superuser_only=True)
@render_to("filemanager/default.html")
def filemanager(request, no, rest_url=""):
    no = int(no)

    if request.method == "POST" and "base_path" in request.POST:
        path_form = BasePathSelect(request.POST)
        if path_form.is_valid():
            base_path_no = int(path_form.cleaned_data["base_path"])
            if not base_path_no == no:
                new_path = BasePathSelect.PATH_DICT[base_path_no]["abs_base_path"]
                messages.success(request, "Change base path to: '%s', ok." % new_path)
                return _redirect2filemanager(base_path_no)
    else:
        path_form = BasePathSelect({"base_path": no})
        if not path_form.is_valid():
            raise Http404("Wrong page path no: %r!" % no)

    path_config = BasePathSelect.PATH_DICT[no]
    base_url = _reverse_filemanager_url(no)

    absolute_path = path_config["abs_base_path"]
    url_prefix = path_config["url_prefix"]
    allow_upload = path_config["allow_upload"]

    fm = Filemanager(url_prefix, request, absolute_path, base_url, rest_url, allow_upload)

    if allow_upload:
        if request.method == "POST" and "file" in request.FILES:
            upload_form = UploadFileForm(request.POST, request.FILES)
            if upload_form.is_valid():
                fm.handle_uploaded_file(request.FILES['file'])
                return HttpResponseRedirect(request.path)
        else:
            upload_form = UploadFileForm()

    dir_items = fm.dir_items
    breadcrumbs = fm.breadcrumbs

    uid = os.geteuid()
    gid = os.getegid()
    username = pwd.getpwuid(uid).pw_name
    groupname = pwd.getpwuid(gid).pw_name

    context = {
        "title": "Filemanager",
        "dir_items": dir_items,
        "breadcrumbs": breadcrumbs,
        "path_form": path_form,

        "uid": uid,
        "gid": gid,
        "username": username,
        "groupname": groupname,

    }
    if allow_upload:
        context["upload_form"] = upload_form

    return context


if __name__ == "__main__":
    import doctest
    print doctest.testmod(
#        verbose=True
        verbose=False
    )

########NEW FILE########
__FILENAME__ = forms
# coding:utf-8

"""
    filemanager forms
    ~~~~~~~~~~~~~~~~~

    :copyleft: 2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import sys

from django import forms
from django.conf import settings
from django.utils.translation import ugettext_lazy as _


# The base path for the filemanager. Every path is like:
BASE_PATHS = getattr(settings, "FILEMANAGER_BASE_PATHS",
    (
        {
            # The absolute filesystem root direcotry:
            "abs_base_path": settings.STATIC_ROOT,
            # The url prefix for the files, if exists:
            "url_prefix": settings.STATIC_URL,
            # File upload to every sub path are allowed:
            "allow_upload": True,
        },
        {
            "abs_base_path": settings.MEDIA_ROOT,
            "url_prefix": settings.MEDIA_URL,
            "allow_upload": True,
        },
    )
)
if settings.DEBUG:
    BASE_PATHS += (
        {
            "abs_base_path": sys.prefix, # root directory of virtualenv
            "url_prefix": None,
            "allow_upload": False,
        },

    )


class BasePathSelect(forms.Form):
    PATH_CHOICES = tuple([(no, path["abs_base_path"]) for no, path in enumerate(BASE_PATHS)])
    PATH_DICT = dict(tuple([(no, path) for no, path in enumerate(BASE_PATHS)]))

    base_path = forms.ChoiceField(choices=PATH_CHOICES,
        help_text=_("The base path for the filemanager root directory."),
        initial=PATH_CHOICES[0],
    )

class UploadFileForm(forms.Form):
    file = forms.FileField()

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from dbpreferences.forms import DBPreferencesBaseForm

from pylucid_project.utils.site_utils import SitePreselectPreference


class FilemanagerPrefForm(SitePreselectPreference, DBPreferencesBaseForm):
    """
    Don't know what we can setup here, yet
    """
    class Meta:
        app_label = 'filemanager'

########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from find_and_replace import admin_views

urlpatterns = patterns('',
    url(r'^find_and_replace/$', admin_views.find_and_replace, name='FindAndReplace-find_and_replace'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding: utf-8

"""
    PyLucid find&replace
    ~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

"""
    PyLucid find&replace plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    
    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import time

from django.contrib import messages
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.markup import hightlighter
from pylucid_project.apps.pylucid.models.language import Language
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu

from find_and_replace.forms import FindReplaceForm, CONTENT_TYPES_DICT, CONTENT_TYPES


def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("change content")

    admin_menu.add_menu_entry(
        parent=menu_section_entry, url_name="FindAndReplace-find_and_replace",
        name="find and replace", title="Find and replace in all existing page content",
    )

    return "\n".join(output)


def _do_find_and_replace(request, context, find_string, replace_string, content_type, simulate, languages, sites):
    content_type_no = int(content_type)
    model_name = CONTENT_TYPES[content_type_no][0]
    model = CONTENT_TYPES_DICT[content_type_no]

    search_languages = Language.objects.filter(code__in=languages)

    queryset = model.objects.all()
    messages.info(request,
        _("%(count)s %(model_name)s entries total exist.") % {
            "count": queryset.count(),
            "model_name": model_name,
    })

    if model_name == u"PageContent":
        queryset = queryset.filter(pagemeta__language__in=search_languages)
        queryset = queryset.filter(pagemeta__pagetree__site__in=sites)
    elif model_name == u"BlogEntryContent":
        queryset = queryset.filter(entry__sites__in=sites)
    elif model_name == u"EditableHtmlHeadFile":
        context["no_link"] = True
    else:
        queryset = queryset.filter(sites__in=sites)

    if model_name not in (u"PageContent", u"EditableHtmlHeadFile", u"DBTemplate"):
        queryset = queryset.filter(language__in=search_languages)

    filtered_count = queryset.count()
    messages.info(request,
        _("%(count)s %(model_name)s filtered entries found.") % {
            "count": filtered_count,
            "model_name": model_name,
    })
    if filtered_count == 0:
        return

    queryset = queryset.filter(content__contains=find_string)
    messages.info(request,
        _("%(count)s %(model_name)s entries contains 'find string'.") % {
            "count": queryset.count(),
            "model_name": model_name,
    })

    total_changes = 0
    changed_entry_count = 0
    results = []
    changed_entrys = []
    for entry in queryset:
        old_content = entry.content

        changes = old_content.count(find_string)
        if changes == 0:
            continue

        changed_entry_count += 1
        total_changes += changes

        new_content = old_content.replace(find_string, replace_string)
        if not simulate:
            # Save the find/replace result
            entry.content = new_content
            entry.save()
            changed_entrys.append(entry)

        diff_html = hightlighter.get_pygmentize_diff(old_content, new_content)

        results.append({
            "entry": entry,
            "changes": changes,
            "diff_html": diff_html,
        })

    if total_changes > 0:
        messages.info(request,
            _("%(changes)s changes in %(count)s %(model_name)s entries.") % {
                "changes": total_changes,
                "count": changed_entry_count,
                "model_name": model_name,
        })
        if simulate:
            messages.info(request, "Simulate only, no entry changed.")

    context["results"] = results
    context["changed_entry_count"] = changed_entry_count
    context["total_changes"] = total_changes


@check_permissions(superuser_only=False, permissions=("pylucid.change_pagecontent",))
@render_to("find_and_replace/find_and_replace.html")
def find_and_replace(request):
    """ find and replace a string in all page content. """
    context = {
        "title": _("Find and replace"),
        "form_url": request.path,
    }

    if request.method == "POST":
        form = FindReplaceForm(request.POST)
        if form.is_valid():
            start_time = time.time()
            _do_find_and_replace(request, context, **form.cleaned_data)
            context["duration"] = time.time() - start_time
    else:
        form = FindReplaceForm()

    context["form"] = form
    return context


########NEW FILE########
__FILENAME__ = forms
# coding:utf-8

from django import forms
from django.contrib.sites.models import Site
from django.utils.translation import ugettext as _

from dbtemplates.models import Template as DBTemplate

from pylucid_project.apps.pylucid.models import Language, PageContent, EditableHtmlHeadFile

from blog.models import BlogEntryContent
from lexicon.models import LexiconEntry


from find_and_replace.preference_forms import get_preferences


CONTENT_TYPES = (
    (u"PageContent", PageContent),
    (u"BlogEntryContent", BlogEntryContent),
    (u"LexiconEntry", LexiconEntry),
    (u"EditableHtmlHeadFile", EditableHtmlHeadFile),
    (u"DBTemplate", DBTemplate),
)
CONTENT_TYPES_CHOICES = [(no, data[0]) for no, data in enumerate(CONTENT_TYPES)]
CONTENT_TYPES_DICT = dict([(no, data[1]) for no, data in enumerate(CONTENT_TYPES)])


class FindReplaceForm(forms.Form):
    find_string = forms.CharField()
    replace_string = forms.CharField()

    content_type = forms.ChoiceField(
        choices=CONTENT_TYPES_CHOICES,
        help_text=_("Please select the content type for the operation.")
    )
    languages = forms.MultipleChoiceField(
        help_text=_("Limit the language. (Would not be used for any content type.)")
    )
    sites = forms.MultipleChoiceField(
        # choices= Set in __init__, so the Queryset would not execute at startup
        help_text=_("Limit to these sites")
    )

    simulate = forms.BooleanField(
        initial=True, required=False,
        help_text=_("Don't replace anything.")

    )

    def __init__(self, *args, **kwargs):
        super(FindReplaceForm, self).__init__(*args, **kwargs)

        preferences = get_preferences()
        self.fields["find_string"].min_length = preferences["min_term_len"]
        self.fields["find_string"].max_length = preferences["max_term_len"]

        self.fields["replace_string"].max_length = preferences["max_term_len"]

        self.fields["languages"].choices = Language.objects.get_choices()
        self.fields["languages"].initial = [Language.objects.get_current().code]

        self.fields["sites"].choices = Site.objects.all().values_list("id", "name")
        self.fields["sites"].initial = [Site.objects.get_current().id]

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8


from django import forms
from django.utils.translation import ugettext as _

from dbpreferences.forms import DBPreferencesBaseForm

class FindReplacePreferencesForm(DBPreferencesBaseForm):
    min_term_len = forms.IntegerField(
        help_text=_("Min length of a search term"),
        initial=3, min_value=1
    )
    max_term_len = forms.IntegerField(
        help_text=_("Max length of a search term"),
        initial=254, min_value=1, max_value=2000
    )
    text_cutout_len = forms.IntegerField(
        help_text=_("The length of the text-hit-cutouts"),
        initial=50, min_value=1, max_value=200
    )
    text_cutout_lines = forms.IntegerField(
        help_text=_("Max. cutout lines for every search term"),
        initial=5, min_value=1, max_value=20
    )

    class Meta:
        app_label = 'find_and_replace'


def get_preferences():
    pref_form = FindReplacePreferencesForm()
    preferences = pref_form.get_preferences()
    return preferences

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8


"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.test.client import Client
from django.core.urlresolvers import reverse

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PluginPage, PageContent



class FindReplaceTest(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - assertPyLucidPermissionDenied()
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.other_lang_code - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """

    def assertInputFields(self, response, find_string, replace_string):
        self.assertDOM(response,
            must_contain=(
                '<input id="id_find_string" name="find_string" type="text" value="%s" />' % find_string,
                '<input id="id_replace_string" name="replace_string" type="text" value="%s" />' % replace_string,
            )
        )

    def test_replace_form(self):
        """ Simply test if we get the find&replace form as a superuser. """
        self.login("superuser")
        url = reverse("FindAndReplace-find_and_replace")
        response = self.client.get(url)
        self.assertDOM(response,
            must_contain=(
                '<input id="id_find_string" name="find_string" type="text" />',
                '<input id="id_replace_string" name="replace_string" type="text" />',
            )
        )
        self.assertResponse(response,
            must_contain=(
                '<form action="%s" method="post" id="find_and_replace' % url,
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

    def test_pagecontent_replace_simulate(self):
        self.login("superuser")
        url = reverse("FindAndReplace-find_and_replace")

        find_string = "the"
        replace_string = "XXX"

        response = self.client.post(url, data={
            'find_string': find_string,
            'replace_string': replace_string,
            'content_type': 0, # PageContent
            'languages': ['de', 'en'],
            'save': 'find and replace',
            'sites': ['1'],
            'simulate': 'on'
        })
        self.assertInputFields(response, find_string, replace_string)
        self.assertResponse(response,
            must_contain=(
                '<link rel="stylesheet" type="text/css" href="/static/PyLucid_cache/pygments.css"',
                '<form action="%s" method="post" id="find_and_replace' % url,
                'Simulate only, no entry changed.',
                '<legend class="pygments_code">Diff</legend>',
                '<span class="gd">-',
                '<span class="gi">+',
                '?  ', ' ^^^ ',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

    def test_pagecontent_replace(self):
        self.login("superuser")
        url = reverse("FindAndReplace-find_and_replace")

        find_string = "Welcome to your fesh PyLucid CMS installation"
        replace_string = "XXX replaced XXX"

        response = self.client.post(url, data={
            'find_string': find_string,
            'replace_string': replace_string,
            'content_type': 0, # PageContent
            'languages': ['de', 'en'],
            'sites': ['1'],
            'save': 'find and replace',
        })
        self.assertInputFields(response, find_string, replace_string)
        self.assertResponse(response,
            must_contain=(
                '<link rel="stylesheet" type="text/css" href="/static/PyLucid_cache/pygments.css"',
                '<form action="%s" method="post" id="find_and_replace' % url,
                '<legend class="pygments_code">Diff</legend>',
                '<span class="gd">- Welcome to your fesh PyLucid CMS installation ;)</span>',
                '<span class="gi">+ XXX replaced XXX ;)</span>',
            ),
            must_not_contain=(
                "Traceback", 'Simulate only, no entry changed.',
                "XXX INVALID TEMPLATE STRING"
            )
        )
        response = self.client.get("/en/welcome/")
        self.assertResponse(response,
            must_contain=('XXX replaced XXX',),
            must_not_contain=(
                "Traceback", 'Welcome to your fesh PyLucid CMS installation',
                "XXX INVALID TEMPLATE STRING"
            )
        )

    def test_Headfiles_replace(self):
        self.login("superuser")
        url = reverse("FindAndReplace-find_and_replace")

        find_string = "page messages"
        replace_string = "XXX replaced XXX"

        response = self.client.post(url, data={
            'find_string': find_string,
            'replace_string': replace_string,
            'content_type': 3, # EditableHtmlHeadFile
            'languages': ['de', 'en'],
            'sites': ['1'],
            'save': 'find and replace',
        })
        self.assertInputFields(response, find_string, replace_string)
        self.assertResponse(response,
            must_contain=(
                '<link rel="stylesheet" type="text/css" href="/static/PyLucid_cache/pygments.css"',
                '<form action="%s" method="post" id="find_and_replace' % url,
                '<legend class="pygments_code">Diff</legend>',
                '<span class="gd">-    page messages</span>',
                '<span class="gi">+    XXX replaced XXX</span>',
            ),
            must_not_contain=(
                "Traceback", 'Simulate only, no entry changed.',
                "XXX INVALID TEMPLATE STRING"
            )
        )


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "pylucid_plugins.find_and_replace.tests.FindReplaceTest.test_Headfiles_replace"

    management.call_command('test', tests,
        verbosity=2,
#        failfast=True
    )

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    Gallery PyLucid Plugin - admin 
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Register model in django admin interface.

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.http import HttpResponseRedirect
from django.contrib import admin
from django import forms

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from pylucid_project.apps.pylucid.models import PageTree, PluginPage
from pylucid_project.apps.pylucid.base_admin import BaseAdmin, RedirectToPageAdmin

from gallery.models import GalleryModel



class GalleryAdminForm(forms.ModelForm):
    """
    Filter pagetree selection.
    Add only pagetree items witch are a gallery plugin page.
    """
    class Meta:
        model = GalleryModel

    def __init__(self, *args, **kwargs):
        super(GalleryAdminForm, self).__init__(*args, **kwargs)

        plugin_pages = PluginPage.objects.filter(app_label="pylucid_project.pylucid_plugins.gallery")
        # TODO: Filter pagetree's witch has already a Gallery PluginPage
        choices = [
            (page.pagetree.id, page.pagetree.get_absolute_url())
            for page in plugin_pages
        ]
        self.fields["pagetree"].choices = choices


class GalleryModelAdmin(RedirectToPageAdmin, BaseAdmin, CompareVersionAdmin):
    form = GalleryAdminForm
    list_display = (
        "view_on_site_link", "path", "template",
        "lastupdatetime", "lastupdateby"
    )
    list_display_links = ("path",)
    list_filter = ("template", "createby", "lastupdateby",)
    date_hierarchy = 'lastupdatetime'
    #search_fields = ("path", "template",)

admin.site.register(GalleryModel, GalleryModelAdmin)

########NEW FILE########
__FILENAME__ = models
# coding: utf-8

"""
    Gallery plugin
    ~~~~~~~~~~~~~~

    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django.conf import settings
from django.db import models
from django.utils.translation import ugettext_lazy as _

from django_tools.fields.static_path import StaticPathModelField
from django_tools.fields.sign_separated import SignSeparatedModelField
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.apps.pylucid.models import PageTree
from pylucid_project.apps.pylucid.models import Language # import here against import loops


class GalleryModel(UpdateInfoBaseModel):
    """   
    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    pagetree = models.ForeignKey(PageTree, unique=True)

    path = StaticPathModelField(max_length=256,
        help_text=_("Base path after STATIC_ROOT '%s'") % settings.STATIC_ROOT
    )

    template = models.CharField(max_length=256,
        default="gallery/default.html",
        help_text=_("Used template for this gallery")
    )

    filename_whitelist = SignSeparatedModelField(max_length=256,
        default="*.jpg, *.jpeg, *.png",
        help_text=_("fnmatch rules with filename whitelist (comma separated, case insensitive).")
    )
    diritem_blacklist = SignSeparatedModelField(max_length=256,
        default="", null=True, blank=True,
        help_text=_("fnmatch rules for skip directory/files (comma separated, case insensitive).")
    )

    filename_suffix_filter = SignSeparatedModelField(max_length=256,
        default="_WEB, _web",
        help_text=_("suffix to cut from filename (e.g.: my_pic_web.jpg -> my_pic - comma separated).")
    )
    thumb_suffix_marker = SignSeparatedModelField(max_length=256,
        default="_thumb, _tmb",
        help_text=_("suffix in filename to detect the thumbnail picture (comma separated).")
    )

    default_thumb_width = models.PositiveIntegerField(default=100,
        help_text=_("Fallback thumbnail width size, used, if no thumbnail found.")
    )
    default_thumb_height = models.PositiveIntegerField(default=100,
        help_text=_("Fallback thumbnail height size, used, if no thumbnail found.")
    )

    def get_absolute_url(self):
        pagetree_url = self.pagetree.get_absolute_url()
        language_entry = Language.objects.get_current()
        url = "/" + language_entry.code + pagetree_url
        return url

    def __unicode__(self):
        return "GalleryModel for %s" % self.pagetree.get_absolute_url()

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext_lazy as _

from django_tools.fields.sign_separated import SignSeparatedFormField

from dbpreferences.forms import DBPreferencesBaseForm

from pylucid_project.utils.site_utils import SitePreselectPreference


class GalleryPrefForm(SitePreselectPreference, DBPreferencesBaseForm):
    unauthorized_signs = SignSeparatedFormField(
        separator=" ", initial=".. // \\",
        help_text=_(
            "raise 500 if one of the signs in the path (separated by spaces!)"
        ),
    )
    class Meta:
        app_label = 'gallery'

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - There exist only "PyLucid CMS" blog entry in english and german
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.test.client import Client
from django.core.urlresolvers import reverse

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PluginPage, PageContent, PageTree




class GalleryPluginTest1(basetest.BaseUnittest):
    """
    inherited from BaseUnittest:
        - assertPyLucidPermissionDenied()
        - initial data fixtures with default test users
        - self.login()

    """
    def _pre_setup(self, *args, **kwargs):
        """ create some language related attributes """
        super(GalleryPluginTest1, self)._pre_setup(*args, **kwargs)

        self.test_slug = "gallery_test"
        self.new_plugin_page_url = reverse("PageAdmin-new_plugin_page")
        self.gallerymodel_add_url = reverse("admin:gallery_gallerymodel_add")

        self.login("superuser")

        self._create_gallery()

    def _create_gallery(self):
        response = self.client.post(self.new_plugin_page_url,
            data={'app_label': 'pylucid_project.pylucid_plugins.gallery',
            'design': 1,
            'position': 0,
            'slug': self.test_slug,
            'urls_filename': 'urls.py'
            }
        )
        # redirect from the save response to the new created plugin page
        self.page_url = "http://testserver/en/%s/" % self.test_slug
        self.assertRedirect(response, self.page_url, status_code=302)

        pagetree_id = PageTree.objects.get(slug=self.test_slug).id

        # redirect from plugin view to create the model data page
        response = self.client.get(self.page_url)
        self.assertRedirect(response,
            "http://testserver" + self.gallerymodel_add_url,
            status_code=302
        )

        self.base_path = "PyLucid"
        response = self.client.post(self.gallerymodel_add_url,
            data={
                'default_thumb_height': '100',
                'default_thumb_width': '100',
                'filename_suffix_filter': '_WEB,_web',
                'filename_whitelist': '*.jpg,*.jpeg,*.png',
                'pagetree': pagetree_id,
                'path': self.base_path,
                'template': 'gallery/default.html',
                'thumb_suffix_marker': '_thumb,_tmb'
            }
        )
        # After add the gallery model, it's going back to the gallery page
        self.assertRedirect(response, self.page_url, status_code=302)

        response = self.client.get(self.page_url)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - gallery_test</title>',
                'The gallery model &quot;GalleryModel for /gallery_test/&quot; was added successfully.',
                'Directory',
                '<li><a href="/en/gallery_test/superfish/">/superfish/</a> <small>(2 pictures)</small></li>',
                'Pictures',
                'Path',
                '''/<a href="/en/gallery_test/" title="goto 'index'">index</a>/''',
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_gallery_summary_non_ajax(self):
        """
        get the create page, with normal user witch has the add permission
        """
        response = self.client.get(self.page_url)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - gallery_test</title>',
                'Directory',
                '<li><a href="/en/gallery_test/superfish/">/superfish/</a> <small>(2 pictures)</small></li>',
                'Pictures',
                'Path',
                '''/<a href="/en/gallery_test/" title="goto 'index'">index</a>/''',
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_gallery_summary_ajax(self):
        """
        get the create page, with normal user witch has the add permission
        """
        response = self.client.get(self.page_url, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertResponse(response,
            must_contain=(
                'Directory',
                '<li><a href="/en/gallery_test/superfish/">/superfish/</a> <small>(2 pictures)</small></li>',
                'Pictures',
                'Path',
                # XXX: Why are ' escaped in ajax view and not in non-ajax view?
                '''/<a href="/en/gallery_test/" title="goto &#39;index&#39;">index</a>/''',
            ),
            must_not_contain=(
                "<!DOCTYPE", "<title>PyLucid CMS", "<body", "<head>", # <- not a complete page
                "Traceback", "Form errors", "field is required",
            )
        )

    def test_gallery_sub_directory_non_ajax(self):
        sub_dir = "markup_help"
        response = self.client.get(self.page_url + sub_dir + "/")
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - gallery_test</title>',
                'jquery.colorbox-min.js',
                '<img src="%s/markup_help/creole_cheat_sheet.png" alt="creole cheat sheet" width="100" height="100">' % (
                    settings.STATIC_URL + self.base_path
                ),
                'Directory',
                'Pictures',
                'Path',
                '''/<a href="/en/gallery_test/" title="goto 'index'">index</a>/''',
                '''<a href="/en/gallery_test/%(dir)s/" title="goto '%(dir)s/'">markup_help</a>''' % {
                    "dir": sub_dir
                }
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_gallery_sub_directory_ajax(self):
        sub_dir = "markup_help"
        response = self.client.get(self.page_url + sub_dir + "/", HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertResponse(response,
            must_contain=(
                'jquery.colorbox-min.js',
                '<img src="%s/markup_help/creole_cheat_sheet.png" alt="creole cheat sheet" width="100" height="100">' % (
                    settings.STATIC_URL + self.base_path
                ),
                'Directory',
                'Pictures',
                'Path',
                # XXX: Why are ' escaped in ajax view and not in non-ajax view?
                '''/<a href="/en/gallery_test/" title="goto &#39;index&#39;">index</a>/''',
                '''<a href="/en/gallery_test/%(dir)s/" title="goto &#39;%(dir)s/&#39;">markup_help</a>''' % {
                    "dir": sub_dir
                }
            ),
            must_not_contain=(
                "<!DOCTYPE", "<title>PyLucid CMS", "<body", "<head>", # <- not a complete page
                "Traceback", "Form errors", "field is required"
            )
        )




if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "pylucid_plugins.blog.tests.GalleryPluginArticleTest"

    management.call_command('test', tests ,
        verbosity=2,
#        verbosity=0,
#        failfast=True
    )

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

from django.conf.urls.defaults import patterns, url

from gallery import views

urlpatterns = patterns('',
    url(r'^(?P<rest_url>.*?)$', views.gallery, name='PluginGallery'),
)



########NEW FILE########
__FILENAME__ = views
# coding: utf-8


"""
    PyLucid gallery
    ~~~~~~~~~~~~~~~

    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from fnmatch import fnmatch
from glob import glob
import os
import posixpath

if __name__ == "__main__":
    # For doctest only
    from pylucid_project.tests import init_test_env
    init_test_env()

from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.http import Http404, HttpResponseRedirect, HttpResponseBadRequest
from django.template.context import RequestContext
from django.utils.translation import ugettext as _

# TODO: Should be moved to django-tools!
from django_tools.filemanager.filemanager import FilemanagerError
from django_tools.filemanager.utils import add_slash
from django_tools.filemanager.filesystem_browser import BaseFilesystemBrowser

from pylucid_project.apps.pylucid.models import LogEntry
from pylucid_project.apps.pylucid.shortcuts import render_pylucid_response

from gallery.models import GalleryModel
from gallery.preference_forms import GalleryPrefForm


#------------------------------------------------------------------------------


def _fnmatch_list(item, filter_list):
    """
    case insensitive fnmatch with a list.
    
    >>> _fnmatch_list("foo.jpg", ["*.bar", "*.jpg"])
    True
    
    >>> _fnmatch_list("foo.PNG", ["*.png"])
    True

    >>> _fnmatch_list("foo.jpg", ["*.bar"])
    False
    """
    for filter in filter_list:
        if fnmatch(item.lower(), filter.lower()):
            return True
    return False


def _split_suffix(filename, suffix_list):
    """
    >>> _split_suffix("picture_no.jpg", ["_foo","_bar"])
    False

    >>> _split_suffix("picture_web.jpg", ["_web"])
    'picture'
    """
    name = os.path.splitext(filename)[0]
    for suffix in suffix_list:
        if name.endswith(suffix):
            cut_pos = len(suffix)
            cut_filename = name[:-cut_pos]
            return cut_filename
    return False


#------------------------------------------------------------------------------


class Gallery(BaseFilesystemBrowser):
    def __init__(self, config, *args, **kwargs):
#        # use unauthorized signs from preferences
#        pref_form = GalleryPrefForm()
#        preferences = pref_form.get_preferences()
#        unauthorized_signs = preferences["unauthorized_signs"]
#        kwargs["unauthorized_signs"] = unauthorized_signs

        super(Gallery, self).__init__(*args, **kwargs)

        # Galleries are only allowed in STATIC_ROOT
        static_root = add_slash(settings.STATIC_ROOT)
        self.check_path(static_root, self.abs_path)

        self.config = config
        self.static_base_url = posixpath.normpath(posixpath.join(settings.STATIC_URL, config.path, self.rel_url))

        dirs, pictures, thumbs = self.read_dir(self.abs_path)

        self.dir_info = self.build_dir_info(dirs)
        self.picture_info = self.build_picture_info(pictures, thumbs)

    def read_dir(self, path):
        pictures = []
        thumbs = {}
        dirs = []
        for item in os.listdir(path):
            if _fnmatch_list(item, self.config.diritem_blacklist):
                # Skip file/direcotry
                continue

            abs_item_path = os.path.join(path, item)
            if os.path.isdir(abs_item_path):
                dirs.append(item)
            elif os.path.isfile(abs_item_path):
                if not _fnmatch_list(item, self.config.filename_whitelist):
                    # Skip files witch are not in whitelist
                    continue

                cut_filename = _split_suffix(item, self.config.thumb_suffix_marker)
                if cut_filename:
                    thumbs[cut_filename] = item
                else:
                    pictures.append(item)

        pictures.sort()
        dirs.sort()

        return dirs, pictures, thumbs

    def build_dir_info(self, dirs):
        if self.rel_url not in ("", "/"):
            dirs.insert(0, "..")

        dir_info = []
        for dir in dirs:
            abs_sub_dir = os.path.join(self.abs_path, dir)
            sub_pictures = self.read_dir(abs_sub_dir)[1]

            dir_info.append({
                "verbose_name": dir.replace("_", " "),
                "href": "%s/" % posixpath.join(self.request.path, dir),
                "pic_count": len(sub_pictures),
            })

        return dir_info

    def make_url(self, part):
        return posixpath.normpath(posixpath.join(self.static_base_url, part))

    def build_picture_info(self, pictures, thumbs):
        picture_info = []
        for picture in pictures:
            cut_filename = _split_suffix(picture, self.config.filename_suffix_filter)
            if not cut_filename:
                cut_filename = os.path.splitext(picture)[0]

            info = {
                "href": self.make_url(picture),
                "verbose_name": cut_filename.replace("_", " "),
            }

            if cut_filename in thumbs:
                info["thumb_href"] = self.make_url(thumbs[cut_filename])
            else:
                info["thumb_href"] = self.make_url(picture)
                info["thumb_width"] = self.config.default_thumb_width
                info["thumb_height"] = self.config.default_thumb_height

            picture_info.append(info)
        return picture_info

    def render(self):
        context = {
            "a_rel_info": self.breadcrumbs[-1]["name"],
            "rel_path": self.rel_path,
            "dir_info": self.dir_info,
            "picture_info": self.picture_info,
            "breadcrumbs": self.breadcrumbs,
        }

        # ajax and non ajax response
        return render_pylucid_response(self.request, self.config.template, context,
            context_instance=RequestContext(self.request)
        )


def gallery(request, rest_url=""):
    pagetree = request.PYLUCID.pagetree
    try:
        config = GalleryModel.objects.get(pagetree=pagetree)
    except GalleryModel.DoesNotExist, err:
        if request.user.has_perm("gallery.change_gallerymodel"):
            messages.info(request,
                _("Gallery entry for page: %s doesn't exist, please create it.") % pagetree.get_absolute_url()
            )
            return HttpResponseRedirect(reverse("admin:gallery_gallerymodel_add"))
        else:
            messages.warning(request, _("Gallery is deactivated, yet. Come back later."))
            if not pagetree.parent:
                parent_url = "/"
            else:
                parent_url = pagetree.parent.get_absolute_url()
            return HttpResponseRedirect(parent_url)

    rel_base_path = config.path
    base_url = request.PYLUCID.pagemeta.get_absolute_url()
    absolute_path = os.path.normpath(os.path.join(settings.STATIC_ROOT, rel_base_path))

    try:
        gallery = Gallery(config, request, absolute_path, base_url, rest_url)
    except FilemanagerError, err:
        has_change_perm = request.user.has_perm("gallery.change_gallerymodel")
        if settings.DEBUG or has_change_perm:
            raise

        LogEntry.objects.log_action(
            app_label="pylucid_plugin.gallery", action="build gallery", message="%s" % err
        )
        raise Http404("Gallery error.")


    if not request.is_ajax():
        # FIXME: In Ajax request, only the page_content would be replaced, not the
        # breadcrumb links :(
        context = request.PYLUCID.context
        try:
            breadcrumb_context_middlewares = request.PYLUCID.context_middlewares["breadcrumb"]
        except KeyError:
            # e.g.: no breadcrumbs in template
            pass
        else:
            for breadcrumb_info in gallery.breadcrumbs[1:]:
                breadcrumb_context_middlewares.add_link(**breadcrumb_info)

        if gallery.rel_url:
            # Add sub path to permalink
            request.PYLUCID.context["page_permalink"] += "/%s/" % gallery.rel_url

    return gallery.render()





if __name__ == "__main__":
    import doctest
    print doctest.testmod(
#        verbose=True
        verbose=False
    )

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.contrib.auth.models import AnonymousUser

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageTree, PageContent
from pylucid_project.apps.pylucid.markup import MARKUP_HTML


class GenericTest(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.default_language - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def _pre_setup(self, *args, **kwargs):
        super(GenericTest, self)._pre_setup(*args, **kwargs)

        pagetree = PageTree.objects.get_root_page(user=AnonymousUser())
        self.pagecontent = PageContent.objects.get(
            pagemeta__pagetree=pagetree, pagemeta__language=self.default_language
        )
        self.pagecontent.markup = MARKUP_HTML
        self.url = self.pagecontent.get_absolute_url()

    def setUp(self):
        self.old_DEBUG = settings.DEBUG
        settings.DEBUG = True

    def tearDown(self):
        settings.DEBUG = self.old_DEBUG

    def _set_content(self, text):
        self.pagecontent.content = (
            "<p>%(pre)s</p>\n"
            "%(text)s\n"
            "<p>%(post)s</p>"
        ) % {
            "pre": "*" * 80,
            "text": text,
            "post": "^" * 80,
        }
        self.pagecontent.save()

    def _test(self, lucidtag, must_contain):
        self._set_content(lucidtag)
        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=must_contain,
            must_not_contain=(
                "Traceback", "XXX INVALID TEMPLATE STRING",
                "Form errors", "field is required",
            )
        )

    def test_youtube_basic(self):
        self._test(
            '{% lucidTag generic.youtube id="-VideoID-" %}',
            must_contain=(
                '<object width="640" height="505">',
                '<param name="movie" value="http://www.youtube.com/v/-VideoID-?fs=1&amp;hd=1&amp;rel=0&amp;hl=en"></param>',
                '<embed src="http://www.youtube.com/v/-VideoID-?fs=1&amp;hd=1&amp;rel=0&amp;hl=en" type="application/x-shockwave-flash"',
            )
        )

    def test_youtube_change_resolution(self):
        self._test(
            '{% lucidTag generic.youtube id="-FooBarID-" width=960 height=745 %}',
            must_contain=(
                '<object width="960" height="745">',
                '<param name="movie" value="http://www.youtube.com/v/-FooBarID-?fs=1&amp;hd=1&amp;rel=0&amp;hl=en"></param>',
                '<embed src="http://www.youtube.com/v/-FooBarID-?fs=1&amp;hd=1&amp;rel=0&amp;hl=en" type="application/x-shockwave-flash"',
            )
        )

    def test_ohloh_basic(self):
        self._test(
            '{% lucidTag generic.ohloh project="pylucid" %}',
            must_contain=(
                '<script type="text/javascript" src="http://www.ohloh.net/p/pylucid/widgets/project_thin_badge.js"></script>'
            )
        )

    def test_ohloh_change_js_file(self):
        self._test(
            '{% lucidTag generic.ohloh project="python" js_file="project_users.js?style=rainbow" %}',
            must_contain=(
                '<script type="text/javascript" src="http://www.ohloh.net/p/pylucid/widgets/project_users.js?style=rainbow"></script>'
            )
        )


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
#    management.call_command('test', "pylucid_plugins.page_admin.tests.ConvertMarkupTest",
##        verbosity=0,
#        verbosity=1,
#        failfast=True
#    )
    management.call_command('test', __file__,
        verbosity=2,
#        failfast=True
    )

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    Generic plugin
    ~~~~~~~~~~~~~~
    
    Simple rendering templates with some variables.

    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

import datetime
import sys
import time
import traceback

from django.conf import settings
from django.contrib import messages
from django.core.cache import cache
from django.utils import simplejson as json
from django.utils.safestring import mark_safe

from pylucid_project.apps.pylucid.decorators import render_to
from pylucid_project import VERSION_STRING
from pylucid_project.utils.escape import escape

from django_tools.utils.http import HttpRequest



def _error(request, msg, staff_msg):
    etype, value, tb = sys.exc_info()
    if tb is not None:
#        if settings.DEBUG and settings.RUN_WITH_DEV_SERVER:
#            raise
        if request.user.is_superuser:
            # put the full traceback into page_msg, but only for superusers
            messages.debug(request,
                mark_safe(
                    "%s:<pre>%s</pre>" % (escape(staff_msg), escape(traceback.format_exc()))
                )
            )
        return "[%s]" % msg

    if request.user.is_staff:
        messages.error(request, staff_msg)

    return "[%s]" % msg


def get_json_remote(request, url, cache_time, timeout, encoding=None):
    """
    include a remote file into a page.
    Arguments, see DocString of lucidTag()
    """
    cache_key = "get_json_remote_%s" % url
    context = cache.get(cache_key)
    if context:
        from_cache = True
    else:
        from_cache = False

        # Get the current page url, for referer
        context = request.PYLUCID.context
        page_absolute_url = context["page_absolute_url"]
        current_language = request.PYLUCID.current_language
        current_language_code = current_language.code

        user_agent = "PyLucid CMS v%s" % VERSION_STRING

        start_time = time.time()
        try:
            # Request the url content in unicode
            r = HttpRequest(url, timeout=timeout, threadunsafe_workaround=True)
            r.request.add_header("User-agent", user_agent)
            r.request.add_header("Referer", page_absolute_url)
            r.request.add_header("Accept-Language", current_language_code)

            response = r.get_response()
            raw_content = r.get_unicode()
        except Exception, err:
            return _error(request, "Remote error.", "Can't get %r: %s" % (url, err))

        duration = time.time() - start_time

        # get request/response information
        request_header = response.request_header
        response_info = response.info()

        raw_json = raw_content[len("jsonFlickrFeed("):-1]
        try:
            data = json.loads(raw_json)
        except Exception, err:
            _error(request, "Remote error.", "Can't load json %r: %s" % (url, err))
            data = None
        else:
            # Insert alternate picture sizes
            for pic in data["items"]:
                url = pic["media"][u"m"]
                for char in (u"s", u"q", u"t", u"n", u"z", u"c", u"b"):
                    if not char in pic["media"]:
                        pic["media"][char] = url.replace(u"_m.jpg", u"_%s.jpg" % char)

            # separate description text
            for pic in data["items"]:
                raw_desc = pic["description"]
                desc = raw_desc.rsplit(u"</a></p>", 1)[1].strip()
                # Cleanup:
                desc = "<br />".join([txt.strip() for txt in desc.split("<br />") if txt.strip()])
                pic["desc_text"] = desc

            # Parse the 'date_taken' time without local information
            for pic in data["items"]:
                raw_date = pic["date_taken"]
                dt = raw_date.rsplit("-", 1)[0]
                dt = datetime.datetime.strptime(dt, "%Y-%m-%dT%H:%M:%S")
                pic["datetime"] = dt

        context = {
            "url": url,
            "raw_content": raw_content,
            "data":data,
            "request_header": request_header,
            "response_info": response_info,
            "duration": duration,
            "cache_time":cache_time,
            "timeout": timeout,
        }
        cache.set(cache_key, context, cache_time)

    context["from_cache"] = from_cache
    return context


@render_to()
def flickr_rss(request, id=None, template_name="generic/flickr_colorbox.html", max=None, cache_time=60, timeout=5, debug=False, **kwargs):
    url = "https://secure.flickr.com/services/feeds/photos_public.gne?format=json"
    if id:
        url += "&id=%s" % id

    current_language = request.PYLUCID.current_language
    current_language_code = current_language.code
    url += "&lang=%(l)s-%(l)s" % {"l":current_language_code}

    context = get_json_remote(request, url, cache_time, timeout)
    if isinstance(context, basestring):
        # Error message
        return context

    if max and context["data"]:
        context["data"]["items"] = context["data"]["items"][:max]

    context.update({
        "template_name":template_name,
        "max": max,
        "debug": debug,
    })
    context.update(kwargs)
    return context


@render_to()
def youtube(request, id, width=640, height=505, template_name="generic/YouTube.html", **kwargs):
    context = {
        "id": id,
        "width": width,
        "height": height,
        "template_name":template_name,
    }
    context.update(kwargs)
    return context


@render_to()
def ohloh(request, project, js_file="project_thin_badge.js", template_name="generic/ohloh.html", **kwargs):
    context = {
        "project": project,
        "js_file": js_file,
        "template_name":template_name,
    }
    context.update(kwargs)
    return context


@render_to()
def lucidTag(request, **context):
    """
    Generic plugin for inserting external widgets.
    
    Available boilerplate:
    * YouTube
    * ohloh
    * flickr
    
    more info:
    http://www.pylucid.org/permalink/360/generic-plugin
    
    example:
        {% lucidTag generic.youtube id="XL1UNmLDLKc" %}
        {% lucidTag generic.youtube id="XL1UNmLDLKc" width=960 height=745 %}
        {% lucidTag generic.ohloh project="pylucid" %}
        {% lucidTag generic.ohloh project="python" js_file="project_users.js?style=rainbow" %}
        {% lucidTag generic.flickr_rss %}
        {% lucidTag generic.flickr_rss id="12345678@N90" max=5 %}
        {% lucidTag generic template_name="myowntemplate.html" %}
    """
    if "template_name" not in context and (request.user.is_staff or settings.DEBUG):
        messages.info(request, _("At least you must add template_name argument to {% lucidTag generic %} !"))
    else:
        return context

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

import sys

from django import forms
from django.utils.translation import ugettext as _

from pylucid_project import VERSION_STRING
from pylucid_project.apps.pylucid.system.pylucid_plugin import PyLucidDBPreferencesBaseForm


class PreferencesForm(PyLucidDBPreferencesBaseForm):
    remote_template = forms.CharField(
        initial="include/remote_default.html",
        help_text=_("The default template filename for include remote.")
    )
    socket_timeout = forms.IntegerField(
        initial=3,
        min_value=1,
        max_value=60,
        help_text=_("Default socket timeout in seconds for getting remote data.")
    )
    cache_timeout = forms.IntegerField(
        initial=15,
        min_value=1,
        max_value=1 * 60 * 60 * 24 * 7,
        help_text=_("Default number of seconds to cache remote data.")
    )

    user_agent = forms.CharField(
        initial="Mozilla/5.0 (compatible; Python/%s; PyLucid/%s)" % (
            sys.version[:3], VERSION_STRING
        ),
        help_text=_("Use User-Agent when requesting the include remote data.")
    )

    class Meta:
        app_label = 'include'

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.contrib.auth.models import AnonymousUser

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageTree, PageContent
from pylucid_project.apps.pylucid.markup import MARKUP_HTML


class IncludeTest(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.default_language - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def _pre_setup(self, *args, **kwargs):
        super(IncludeTest, self)._pre_setup(*args, **kwargs)

        pagetree = PageTree.objects.get_root_page(user=AnonymousUser())
        self.pagecontent = PageContent.objects.get(
            pagemeta__pagetree=pagetree, pagemeta__language=self.default_language
        )
        self.pagecontent.markup = MARKUP_HTML
        self.url = self.pagecontent.get_absolute_url()

        self.pylucid_js_tools_filepath = os.path.join(settings.STATIC_ROOT, "PyLucid", "pylucid_js_tools.js")

    def setUp(self):
        self.old_DEBUG = settings.DEBUG
        settings.DEBUG = True

    def tearDown(self):
        settings.DEBUG = self.old_DEBUG

    def _set_content(self, text):
        self.pagecontent.content = (
            "<p>%(pre)s</p>\n"
            "%(text)s\n"
            "<p>%(post)s</p>"
        ) % {
            "pre": "*" * 80,
            "text": text,
            "post": "^" * 80,
        }
        self.pagecontent.save()

    def _test(self, lucidtag, must_contain, must_not_contain=()):
        must_not_contain = (
            "Traceback", "XXX INVALID TEMPLATE STRING",
            "Form errors", "field is required",
        ) + must_not_contain

        self._set_content(lucidtag)
        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=must_contain,
            must_not_contain=must_not_contain,
        )

    def test_local_file_basic(self):
#        self.login("superuser") # For seeing verbose error messages
        self._test(
            '{%% lucidTag include.local_file filepath="%s" %%}' % self.pylucid_js_tools_filepath,
            must_contain=(
                '// helper function for console logging',
            ),
            must_not_contain=(
                "Traceback", "XXX INVALID TEMPLATE STRING",
                "Form errors", "field is required",
                "pygments_code", '<span class="c1">'
            )
        )

    def test_local_file_highlight(self):
#        self.login("superuser") # For seeing verbose error messages
        self._test(
            '{%% lucidTag include.local_file filepath="%s" highlight="js" %%}' % self.pylucid_js_tools_filepath,
            must_contain=(
                '<fieldset class="pygments_code">',
                '<legend class="pygments_code">JavaScript</legend>',
                '<span class="c1">// helper function for console logging</span>'
            )
        )

    def test_local_file_highlight_autodetection(self):
#        self.login("superuser") # For seeing verbose error messages
        self._test(
            '{%% lucidTag include.local_file filepath="%s" highlight=True %%}' % self.pylucid_js_tools_filepath,
            must_contain=(
                '<fieldset class="pygments_code">',
                '<legend class="pygments_code">JavaScript</legend>',
                '<span class="c1">// helper function for console logging</span>'
            )
        )

    def test_local_file_base_path(self):
        self.login("superuser") # For seeing verbose error messages
        self._test(
            '{% lucidTag include.local_file filepath="/etc/passwd" %}',
            must_contain=(
                'Filepath doesn&#39;t start with',
                '[Include error.]',
            )
        )

    def test_local_file_base_path_error(self):
        """ Normal users should not see the verbose error """
        self._test(
            '{% lucidTag include.local_file filepath="/etc/passwd" %}',
            must_contain=('[Include error.]',),
            must_not_contain=('Filepath doesn&#39;t start with',)
        )

    def test_local_file_markup(self):
        self.login("superuser") # For seeing verbose error messages

        base_path = os.path.normpath(os.path.join(settings.PYLUCID_BASE_PATH, ".."))

        old_basepath = settings.PYLUCID_INCLUDE_BASEPATH
        settings.PYLUCID_INCLUDE_BASEPATH = base_path

        filepath = os.path.join(base_path, "README.creole")

        self._test(
            '{%% lucidTag include.local_file filepath="%s" markup="creole" %%}' % filepath,
            must_contain=(
                '''<a href="?lexicon=PyLucid CMS" title="lexicon entry 'PyLucid CMS' - PyLucid is the CMS thats built this page." class="PyLucidPlugins lexicon openinwindow">PyLucid</a> is an Open Source web content management system written in Python using <a href="http://www.pylucid.org/permalink/41/dependencies-and-copyrights">Django, jQuery and many more external software...</a></p>''',
                '<li>Open Source (GPL v3 or later)</li>',
                '<li>Multi site support (Allows a single installation to serve multiple websites.)</li>'
            ),
            must_not_contain=(
                '[Include error.]',
                'Filepath doesn&#39;t start with',
                'Can&#39;t read file',
            )
        )
        settings.PYLUCID_INCLUDE_BASEPATH = old_basepath

    def test_local_file_markup_and_highlight(self):
        self.login("superuser") # For seeing verbose error messages

        base_path = os.path.normpath(os.path.join(settings.PYLUCID_BASE_PATH, ".."))

        old_basepath = settings.PYLUCID_INCLUDE_BASEPATH
        settings.PYLUCID_INCLUDE_BASEPATH = base_path

        filepath = os.path.join(base_path, "README.creole")

        self._test(
            '{%% lucidTag include.local_file filepath="%s" markup="creole" highlight="html" %%}' % filepath,
            must_contain=(
                '<fieldset class="pygments_code">',
                '<legend class="pygments_code">HTML</legend>',
                '<span class="nt">&lt;h1&gt;</span>about PyLucid<span class="nt">&lt;/h1&gt;</span>',
            ),
            must_not_contain=(
                '[Include error.]',
                'Filepath doesn&#39;t start with',
                'Can&#39;t read file',
            )
        )
        settings.PYLUCID_INCLUDE_BASEPATH = old_basepath

    def test_remote_file_basic(self):
        #self.login("superuser") # For seeing verbose error messages
        self._test(
            '{% lucidTag include.remote url="http://www.pylucid.org/permalink/45/a-simple-unicode-test-page" %}',
            must_contain=(
                '&amp;darr;&amp;nbsp;Basic Latin-1 (0x0021-0x007E):',
                'This page would be used for some unittests, too ;)',
                'Latin-1 Supplement (0x0080-0x00FF):',
                'German Umlaute:       ',
            ),
        )

    def test_remote_file_highlight(self):
        #self.login("superuser") # For seeing verbose error messages
        self._test(
            '{% lucidTag include.remote url="http://www.pylucid.org/permalink/45/a-simple-unicode-test-page" highlight="html" %}',
            must_contain=(
                '<fieldset class="pygments_code">',
                '<legend class="pygments_code">HTML</legend>',

                '<span class="ni">&amp;darr;&amp;nbsp;</span>Basic Latin-1 (0x0021-0x007E):',
                'This page would be used for some unittests, too ;)<span class="nt">&lt;/p&gt;</span>',
                '<span class="s">&quot;Latin-1-Supplement-0x0080-0x00FF&quot;</span>',
                '<span class="nt">&lt;p&gt;</span>German Umlaute:       <span class="nt">&lt;/p&gt;</span>',
            ),
        )


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "pylucid_plugins.page_admin.tests.ConvertMarkupTest"

    management.call_command('test', tests,
#        verbosity=0,
        verbosity=1,
#        failfast=True
    )


########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid include plugin
    ~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import sys
import time
import traceback

from django.conf import settings
from django.contrib import messages
from django.core.cache import cache
from django.utils.html import strip_tags
from django.utils.safestring import mark_safe

from django_tools.utils.http import HttpRequest

from pylucid_project.apps.pylucid.decorators import render_to
from pylucid_project.apps.pylucid.markup import MARKUP_DATA
from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid.markup.hightlighter import make_html
from pylucid_project.pylucid_plugins.include.preference_forms import PreferencesForm
from pylucid_project.utils.escape import escape




MARKUPS = dict(tuple([(data[1], data[0]) for data in MARKUP_DATA]))



def _error(request, msg, staff_msg):
    etype, value, tb = sys.exc_info()
    if tb is not None:
#        if settings.DEBUG and settings.RUN_WITH_DEV_SERVER:
#            raise
        if request.user.is_superuser:
            # put the full traceback into page_msg, but only for superusers
            messages.debug(request,
                mark_safe(
                    "%s:<pre>%s</pre>" % (escape(staff_msg), escape(traceback.format_exc()))
                )
            )
            return

    if request.user.is_staff:
        messages.error(request, staff_msg)

    return "[%s]" % msg


def _render(request, content, path_or_url, markup, highlight, strip_html):
    markup_no = None
    if markup:
        if markup not in MARKUPS:
            return _error(request, "Include error.",
                "Can't include: Unknown markup %r (Available: %s)" % (markup, ", ".join(MARKUPS.keys()))
            )
        markup_no = MARKUPS[markup]

    if markup_no:
        content = apply_markup(content, markup_no, request, escape_django_tags=False) # xxx: escape_django_tags
        if highlight == True:
            highlight = "html"

    if highlight == True:
        highlight = os.path.splitext(path_or_url)[1]

    if highlight is not None:
        content = make_html(content, highlight)

    if not (markup_no or highlight):
        if strip_html:
            content = strip_tags(content)
        content = escape(content)

    return content


def local_file(request, filepath, encoding="utf-8", markup=None, highlight=None, strip_html=True):
    """
    include a local files from filesystem into a page.
    Arguments, see DocString of lucidTag()
    """
    filepath = os.path.normpath(os.path.abspath(filepath))

    # include local files only, if it stored under this path:
    basepath = getattr(settings, "PYLUCID_INCLUDE_BASEPATH", None)
    if not basepath:
        return _error(request, "Include error.", "settings.PYLUCID_INCLUDE_BASEPATH not set!")
    
    basepath = os.path.normpath(basepath)
    if not filepath.startswith(basepath):
        return _error(request, "Include error.", "Filepath doesn't start with %r" % basepath)

    try:
        f = file(filepath, "r")
        content = f.read()
        f.close()

        content = unicode(content, encoding)
    except Exception, err:
        return _error(request, "Include error.", "Can't read file %r: %s" % (filepath, err))

    return _render(request, content, filepath, markup, highlight, strip_html)


@render_to()#, debug=True)
def remote(request, url, encoding=None, markup=None, highlight=None, strip_html=True, **kwargs):
    """
    include a remote file into a page.
    Arguments, see DocString of lucidTag()
    """
    # Get preferences from DB and overwrite them
    pref_form = PreferencesForm()
    preferences = pref_form.get_preferences(request, lucidtag_kwargs=kwargs)

    cache_key = "include_remote_%s" % url
    context = cache.get(cache_key)
    if context:
        from_cache = True
    else:
        from_cache = False

        # Get the current page url, for referer
        context = request.PYLUCID.context
        page_absolute_url = context["page_absolute_url"]
        current_language = request.PYLUCID.current_language
        current_language_code = current_language.code

        socket_timeout = preferences["socket_timeout"]
        user_agent = preferences["user_agent"]

        start_time = time.time()
        try:
            # Request the url content in unicode
            r = HttpRequest(url, timeout=socket_timeout, threadunsafe_workaround=True)
            r.request.add_header("User-agent", user_agent)
            r.request.add_header("Referer", page_absolute_url)
            r.request.add_header("Accept-Language", current_language_code)

            response = r.get_response()
            raw_content = r.get_unicode()
        except Exception, err:
            return _error(request, "Include error.", "Can't get %r: %s" % (url, err))

        duration = time.time() - start_time

        # get request/response information
        request_header = response.request_header
        response_info = response.info()

        context = {
            "raw_content": raw_content,
            "request_header": request_header,
            "response_info": response_info,
            "duration": duration,
        }
        cache.set(cache_key, context , preferences["cache_timeout"])

    content = context["raw_content"]
    content = _render(request, content, url, markup, highlight, strip_html)

    context.update({
        "template_name": preferences["remote_template"],
        "url": url,
        "content": content,
        "from_cache": from_cache,
        "preferences": preferences,
    })
    return context


def lucidTag(request, **kwargs):
    """
    include a local file or a remote page into CMS page.
    
    Shared arguments for include.local_file and include.remote:
    |= parameter |= default |= description
    | encoding   | "utf-8"  | content charset
    | markup     | None     | Name of the Markup to apply (e.g.: "creole", "rest")
    | highlight  | None     | File extensions for pygments or True for autodetection (e.g.: "py", "html+django")
    | strip_html | True     | Cut html tags out from content?
    
    You can combine markup and highlight. Result is pygmentised html code ;)
    if not markup and not highlight, the result would be strip_html (optional) and then escaped.
    
    Optional arguments for include.remote to overwrite preferences:
    |= parameter      |= description
    | remote_template | template filename for render the result
    | socket_timeout  | socket timeout in seconds for getting remote data
    | cache_timeout   | number of seconds to cache remote data
    
    example:
    
    {% lucidTag include.local_file filepath="README.creole" markup="creole" %}
    {% lucidTag include.remote url="http://domain.tld/foobar.py" highlight="py" %}
    """
    return _error(request, "Include error.",
        "Wrong lucidTag Syntax:"
        " You must use {% lucidTag include.local_file ... %} or {% lucidTag include.remote ... %} !"
    )

########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from django.conf.urls.defaults import patterns, url

from internals import admin_views

urlpatterns = patterns('',
    url(r'^show_internals/$', admin_views.show_internals, name='Internal-show_internals'),
    url(r'^model_graph/$', admin_views.model_graph, name='Internal-model_graph'),
    url(r'^form_generator/$', admin_views.form_generator, name='Internal-form_generator'),
    url(r'^form_generator/(?P<model_no>\d+?)/$', admin_views.form_generator, name='Internal-form_generator'),
)

########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8

"""
    internals admin views
    ~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from pprint import pformat
import os
import posixpath
import re
import sys

from django.conf import settings
from django.contrib import messages
from django.contrib.admindocs.views import simplify_regex
from django.contrib.auth.models import Permission
from django.contrib.contenttypes import generic
from django.core import urlresolvers
from django.core.cache import cache
from django.core.exceptions import ViewDoesNotExist
from django.core.urlresolvers import RegexURLPattern, RegexURLResolver
from django.db import connection, backend
from django.db import models
from django.db.models import get_apps, get_models
from django.template.context import RequestContext
from django.utils.translation import ugettext_lazy as _
from django.views.debug import get_safe_settings

from django_tools.local_sync_cache.local_sync_cache import LocalSyncCache
from django_tools.cache.site_cache_middleware import LOCAL_CACHE_INFO, \
    CACHE_REQUESTS, CACHE_REQUEST_HITS, CACHE_RESPONSES, CACHE_RESPONSE_HITS

from pylucid_project.apps.pylucid.markup import hightlighter
from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu
from pylucid_project.pylucid_plugins.auth.models import CNONCE_CACHE




def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("internals")

    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="form generator", title="Form generator from existing models.",
        url_name="Internal-form_generator"
    )
    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="show internals", title="Display some internal information.",
        url_name="Internal-show_internals"
    )
    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="model_graph", title="Display a model UML graph.",
        url_name="Internal-model_graph"
    )

    return "\n".join(output)

#-----------------------------------------------------------------------------

class UrlPatternInfo(object):
    """
    most parts borrowed from django-extensions:
    https://github.com/django-extensions/django-extensions/blob/master/django_extensions/management/commands/show_urls.py
    """
    def get_url_info(self):
        """
        return a dict-list of the current used url patterns 
        """
        urlconf = __import__(settings.ROOT_URLCONF, {}, {}, [''])

        view_functions = self._extract_views_from_urlpatterns(urlconf.urlpatterns)

        url_info = []
        for (func, regex, url_name) in view_functions:
            if hasattr(func, '__name__'):
                func_name = func.__name__
            elif hasattr(func, '__class__'):
                func_name = '%s()' % func.__class__.__name__
            else:
                func_name = re.sub(r' at 0x[0-9a-f]+', '', repr(func))
            url = simplify_regex(regex)

            url_info.append({
                'func_name': func_name,
                'module': func.__module__,
                'url_name': url_name,
                'regex': regex,
                'url': url
            })
        return url_info

    def _extract_views_from_urlpatterns(self, urlpatterns, base=''):
        """
        Return a list of views from a list of urlpatterns.
        
        Each object in the returned list is a two-tuple: (view_func, regex)
        """
        views = []
        for p in urlpatterns:
            if isinstance(p, RegexURLPattern):
                try:
                    views.append((p.callback, base + p.regex.pattern, p.name))
                except ViewDoesNotExist:
                    continue
            elif isinstance(p, RegexURLResolver):
                try:
                    patterns = p.url_patterns
                except ImportError:
                    continue
                views.extend(self._extract_views_from_urlpatterns(patterns, base + p.regex.pattern))
            elif hasattr(p, '_get_callback'):
                try:
                    views.append((p._get_callback(), base + p.regex.pattern, p.name))
                except ViewDoesNotExist:
                    continue
            elif hasattr(p, 'url_patterns') or hasattr(p, '_get_url_patterns'):
                try:
                    patterns = p.url_patterns
                except ImportError:
                    continue
                views.extend(self._extract_views_from_urlpatterns(patterns, base + p.regex.pattern))
            else:
                raise TypeError, _("%s does not appear to be a urlpattern object") % p
        return views

#-----------------------------------------------------------------------------

def hightlighted_pformat(obj):
    return hightlighter.make_html(
        pformat(obj, indent=4, width=120), source_type="py", django_escape=True
    )

#-----------------------------------------------------------------------------

@check_permissions(superuser_only=True)
@render_to("internals/show_internals.html")
def show_internals(request):
    apps_info = []
    for app in get_apps():
        model_info = []
        for model in get_models(app):
            model_info.append({
                "name":model._meta.object_name,
            })
        apps_info.append({
            "app_name": app.__name__,
            "app_models": model_info,
        })


    # Information about the current used url patterns
    urlpatterns = UrlPatternInfo().get_url_info()

    # Create a dict from RequestContext
    request_context = RequestContext(request)
    keys = set()
    for context_dict in request_context.dicts:
        keys = keys.union(set(context_dict.keys()))
    request_context_info = {}
    for key in keys:
        request_context_info[key] = request_context[key]

    try:
        cnonce_size = sys.getsizeof(CNONCE_CACHE) # New in version 2.6
    except (AttributeError, TypeError): # PyPy raised a TypeError
        cnonce_size = None

    context = {
        "title": "Show internals",

        "pid": os.getpid(),
        "cache_information": LocalSyncCache.get_cache_information(),

        "permissions": Permission.objects.all(),

        "urlpatterns": urlpatterns,
        "request_context":hightlighted_pformat(request_context_info),
        "settings": hightlighted_pformat(get_safe_settings()),

        "db_backend_name": backend.Database.__name__,
        "db_backend_module": backend.Database.__file__,
        "db_backend_version": getattr(backend.Database, "version", "?"),

        "apps_info": apps_info,

        "db_table_names": sorted(connection.introspection.table_names()),
        "django_tables": sorted(connection.introspection.django_table_names()),

        "request_meta": hightlighter.make_html(
            pformat(request.META), source_type="py", django_escape=True
        ),

        "request_session": hightlighter.make_html(
            pformat(dict(request.session)), source_type="py", django_escape=True
        ),

        "sys_path": sys.path,
        "os_environ": os.environ,

        # Information of the cache usage
        # from FetchFromCacheMiddleware (if settings.COUNT_FETCH_FROM_CACHE != True: all values are None):
        "local_cache_requests": LOCAL_CACHE_INFO["requests"],
        "local_cache_request_hits": LOCAL_CACHE_INFO["request hits"],
        "global_cache_requests": cache.get(CACHE_REQUESTS),
        "global_cache_request_hits":  cache.get(CACHE_REQUEST_HITS),

        # from UpdateCacheMiddleware (if settings.COUNT_UPDATE_CACHE != True: all values are None):
        "local_cache_responses": LOCAL_CACHE_INFO["responses"],
        "local_cache_response_hits": LOCAL_CACHE_INFO["response hits"],
        "global_cache_responses": cache.get(CACHE_RESPONSES),
        "global_cache_response_hits":  cache.get(CACHE_RESPONSE_HITS),

        # Information about auth cnonce usage:
        "cnonce_count": len(CNONCE_CACHE),
        "cnonce_size": cnonce_size,
        "used_cnonces": tuple(sorted(CNONCE_CACHE.keys())),
    }
    return context


#-----------------------------------------------------------------------------

def _textform_for_model(model, request, debug=False):
    """
    based on http://www.djangosnippets.org/snippets/458/
    """
    defaults = {"required": True, "initial": None, "min_length": None}

    opts = model._meta
    field_list = []
    for f in opts.fields + opts.many_to_many:
        if not f.editable:
            continue
        formfield = f.formfield()
        if formfield:
            kw = []
            if debug:
                messages.info(request, dir(formfield))
            for a in ('queryset', 'max_length', 'min_length', 'label', 'initial', 'help_text', 'required'):
                if hasattr(formfield, a):
                    attr = getattr(formfield, a)

                    if a in defaults and attr == defaults[a]:
                        # Don't add default key/value combinations into form
                        continue

                    if a in ("label", "help_text"): # "translate" lazy text
                        attr = unicode(attr)

                    if a == 'queryset':
                        kw.append("%s=%s" % (a, "%s.objects.all()" % attr.model.__name__))
                    elif attr in [True, False, None]:
                        kw.append("%s=%s" % (a, attr))
                    elif attr:
                        kw.append("%s=_('%s')" % (a, attr))

            f_text = "    %s = forms.%s(%s)" % (f.name, formfield.__class__.__name__ , ', '.join(kw))
            field_list.append(f_text)
    return "class %sForm(forms.Form):\n" % model.__name__ + '\n'.join(field_list)




@check_permissions(superuser_only=True)
@render_to("internals/form_generator.html")
def form_generator(request, model_no=None):
    apps = models.get_apps()
    app_models = []
    for app in apps:
        app_models += models.get_models(app)

    models_dict = {}
    for no, model in enumerate(app_models):
        models_dict[no] = model

    if model_no:
        model = models_dict[int(model_no)]
        sourcecode = _textform_for_model(model, request)#, debug=True)

        output = hightlighter.make_html(sourcecode, source_type="py")
    else:
        output = None

    context = {
        "title": "Form generator",
        "models_dict": models_dict,
        "output": output,
    }
    return context




@check_permissions(superuser_only=True)
@render_to("internals/model_graph.html")
def model_graph(request):
    try:
        import pygraphviz as P
    except ImportError, err:
        msg = (
            "Error: PyGraphviz can't import!"
            " (Original Error was: %s "
            "- Please note, you need graphviz-dev or graphviz-devel, too.)"
        ) % err
        messages.error(request, msg)
        return {"error": msg}

    A = P.AGraph() # init empty graph

    collapse_relation = ("lastupdateby", "createby")

    apps = models.get_apps()
    for app in apps:
        for appmodel in models.get_models(app):
            model_name = appmodel.__module__
            if "pylucid" in model_name:
                color = "green"
            else:
                color = "grey"

            A.add_node(model_name, color=color, shape='box', fontsize="12")

            def add_relation(field):
                if field.name in collapse_relation:
                    return

                target_app = field.rel.to.__module__
                target = field.rel.to.__name__
                field_type = type(field).__name__
                field_name = field.name
                A.add_edge(model_name, target_app,
                    key=field.name, label="%s(%s)" % (field_type, field.name), color=color,
                    fontsize="10",
                )

            for field in appmodel._meta.fields:
                if isinstance(field, (models.ForeignKey, models.OneToOneField)):
                    add_relation(field)

            if appmodel._meta.many_to_many:
                for field in appmodel._meta.many_to_many:
                    if isinstance(field, (models.ManyToManyField, generic.GenericRelation)):
                        add_relation(field)

    A.layout(prog='dot') # layout with default (neato)

    filename = "models_graph.png"
    f = file(os.path.join(settings.STATIC_ROOT, filename), "wb")
    f.write(A.draw(format='png')) # draw png
    f.close()

    context = {
        "url": posixpath.join(settings.STATIC_URL, filename),
    }
    return context


########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.test.client import Client
from django.core.urlresolvers import reverse

from pylucid_project.tests.test_tools.basetest import BaseUnittest


class ShowInternalsTest(BaseUnittest):
    """
    inherited from BaseUnittest:
        - assertPyLucidPermissionDenied()
        - initial data fixtures with default test users
        - self.login()
    """
    def _pre_setup(self, *args, **kwargs):
        super(ShowInternalsTest, self)._pre_setup(*args, **kwargs)
        self.url = reverse("Internal-show_internals")

    def test_anonymous(self):
        response = self.client.get(self.url)
        self.assertRedirect(response, status_code=302,
            url="http://testserver/?auth=login&next_url=%s" % self.url
        )

    def test_summary(self):
        self.login("superuser")
        response = self.client.get(self.url)
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid - Show internals</title>',
                'Cache status',
                'urlpatterns',
                'database backend information',
                "Internal-show_internals",
            ),
        )



if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
#    management.call_command('test', "pylucid_plugins.page_admin.tests.ConvertMarkupTest",
##        verbosity=0,
#        verbosity=1,
#        failfast=True
#    )
    management.call_command('test', __file__,
        verbosity=1,
#        verbosity=0,
#        failfast=True
    )

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext as _

from dbpreferences.forms import DBPreferencesBaseForm


class LanguagePrefForm(DBPreferencesBaseForm):
    add_reset_link = forms.BooleanField(
        initial = False, required = False,
        help_text = _('If checked add a reset link to the language list.'),
    )

    class Meta:
        app_label = 'language'
########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - related test in pylucid/tests/test_i18n.py
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"


from pylucid_project.tests.test_tools import basetest


class LanguagePluginTest(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.default_language - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def test_language_switch(self):
        """
        request root page without any HTTP_ACCEPT_LANGUAGE
        the default language should be returned
        """
        # first request must return default language
        response = self.client.get("/en/")
        self.assertContentLanguage(response, self.default_language)
        self.assertStatusCode(response, 200)

        # Switch language must rediret to new url with new language code
        response = self.client.get("/en/?language=" + self.other_lang_code)
        self.assertRedirect(response, url="http://testserver/de/", status_code=302)

        # After language switch, we must get the switched language
        response = self.client.get("http://testserver/de/")
        self.assertContentLanguage(response, self.other_language)
        self.assertStatusCode(response, 200)

    def test_not_existing(self):
        """
        request a not existing language
        Note: "not-exist" is a valid language, see: django_tools.validators.validate_language_code
        """
        response = self.client.get("/en/?language=not-exist") # lang code is valid
        self.assertStatusCode(response, 200)
        self.assertContentLanguage(response, self.default_language)

        # No debug info should be present
        self.assertResponse(response,
            must_not_contain=("Traceback", "Wrong lang code")
        )

    def test_wrong_format(self):
        """
        request a not existing language
        """
        response = self.client.get("/en/?language=wrong format!") # lang code is not valid
        self.assertStatusCode(response, 200)
        self.assertContentLanguage(response, self.default_language)

        # No debug info should be present
        self.assertResponse(response,
            must_not_contain=("Traceback", "Wrong language code", "Enter a valid language code")
        )


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "pylucid_plugins.language.tests.LanguagePluginTest"
#    tests = "pylucid_plugins.language.tests.LanguagePluginTest.test_wrong_format"

    management.call_command('test', tests,
        verbosity=2,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid language plugin
    ~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p

"""

__version__ = "$Rev:$"

from django.conf import settings
from django.contrib import messages
from django.core.exceptions import ValidationError
from django.http import HttpResponseRedirect

from django_tools.validators import validate_language_code

from pylucid_project.apps.pylucid.system import i18n
from pylucid_project.apps.pylucid.models import PageMeta, Language
from pylucid_project.apps.pylucid.decorators import render_to

from language.preference_forms import LanguagePrefForm


RESET_KEY = "reset"


def _can_reset():
    # Get preferences
    pref_form = LanguagePrefForm()
    pref_data = pref_form.get_preferences()
    return pref_data["add_reset_link"] or settings.DEBUG or settings.PYLUCID.I18N_DEBUG


@render_to("language/language_selector.html")
def lucidTag(request):
    """ insert language selector list into page """
    existing_languages = request.PYLUCID.languages[:]
    existing_languages.sort()

    if len(existing_languages) < 2:
        # Don't insert the language selector, if there only exist one language ;)
        if request.user.is_superuser:
            # Display a superuser a information (only one time per session)
            key = "useless_language_plugin"
            if key not in request.session:
                messages.info(request,
                    "It's useless to insert lucidtag language into this site!"
                    "For better performance you can remove this tag."
                )
                request.session[key] = True
        return

    current_language = request.PYLUCID.current_language
    current_pagetree = request.PYLUCID.pagetree
    absolute_url = current_pagetree.get_absolute_url()
    current_url = absolute_url.strip("/") # For {% url ... %}

    context = {
        "current_language": current_language,
        "current_url": current_url,
        "existing_languages": existing_languages,
        "add_reset_link": _can_reset(),
        "reset_key": RESET_KEY,
    }
    return context


def http_get_view(request):
    """
    Switch the client favored language and save it for every later requests.
    """
    user = request.user
    debug = settings.DEBUG or settings.PYLUCID.I18N_DEBUG

    raw_lang_code = request.GET.get("language", False)
    if not raw_lang_code:
        if settings.DEBUG or settings.PYLUCID.I18N_DEBUG:
            messages.error(request, "No language code!")
        return

    if raw_lang_code == RESET_KEY:
        # We should reset the current saved language data
        if not _can_reset():
            if debug:
                messages.error(request, "Error: i18n reset is off!")
            return
        return i18n.reset_language_settings(request)

    try:
        validate_language_code(raw_lang_code)
    except ValidationError, err:
        if debug:
            messages.error(request, "Wrong language code in url: %s" % err)
        return

    if raw_lang_code == request.PYLUCID.current_language.code:
        # Use the current lang entry and save it
        lang_entry = request.PYLUCID.current_language
        if debug:
            messages.info(request, "Save current lang entry.")
    else:
        existing_languages = Language.objects.all_accessible(user)
        try:
            lang_entry = existing_languages.get(code=raw_lang_code)
        except Language.DoesNotExist, err:
            if debug:
                messages.error(request, "Wrong lang code in get parameter: %s" % err)
            return

    i18n.activate_language(request, lang_entry, save=True)

    current_pagemeta = request.PYLUCID.pagemeta
    if current_pagemeta.language == lang_entry:
        if debug:
            messages.info(request, "Current page is in right language. No redirect needed.")
        return

    pagetree = request.PYLUCID.pagetree
    try:
        pagemeta = PageMeta.objects.get(pagetree=pagetree, language=lang_entry)
    except PageMeta.DoesNotExist, err:
        if debug:
            messages.info(request, "PageMeta doesn't exist in lang %r. So no redirect needed." % lang_entry)
        return

    # change only the lang code in the url:
    new_url = i18n.change_url(request, new_lang_code=pagemeta.language.code, save_get_parameter=False)

    # redirect, so the new selected language would be used
    return HttpResponseRedirect(new_url)

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    PyLucid.admin
    ~~~~~~~~~~~~~~

    Register models in django admin interface.

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.contrib import admin

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from pylucid_project.apps.pylucid.base_admin import BaseAdmin
from pylucid_project.apps.pylucid.markup.admin import MarkupPreview

from lexicon.models import LexiconEntry


class LexiconEntryAdmin(BaseAdmin, MarkupPreview, CompareVersionAdmin):
    """
    inherited attributes from BaseAdmin:
        view_on_site_link -> html link with the absolute uri.
        
    inherited from MarkupPreview:
        ajax_markup_preview() -> the markup content ajax preview view
        get_urls()            -> add ajax view to admin urls 
    """
    list_display = (
        "id", "term", "language", "tags", "is_public",
        "view_on_site_link", "site_info",
        "lastupdatetime", "lastupdateby"
    )
    list_display_links = ("term", "tags",)
    list_filter = ("is_public", "language", "sites", "createby", "lastupdateby",)
    date_hierarchy = 'lastupdatetime'
    ordering = ('-lastupdatetime',)
    search_fields = ("term", "tags", "content")

admin.site.register(LexiconEntry, LexiconEntryAdmin)

########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django.conf.urls.defaults import patterns, url

from pylucid_project.apps.pylucid.markup.views import markup_preview

from lexicon import admin_views

urlpatterns = patterns('',
    url(r'^new_lexicon_entry/$', admin_views.new_entry, name='Lexicon-new_entry'),
    url(r'^new_lexicon_entry/preview/$', markup_preview, name='Lexicon-markup_preview'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8


"""
    Lexicon admin views
    ~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django import http
from django.conf import settings
from django.contrib import messages
from django.core import urlresolvers
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import PageMeta
from pylucid_project.apps.pylucid.models.pluginpage import PluginPage
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu
from pylucid_project.utils.site_utils import get_site_preselection

from lexicon.forms import LexiconEntryForm
from lexicon.preference_forms import LexiconPrefForm



def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("create content")

    admin_menu.add_menu_entry(
        parent=menu_section_entry, url_name="Lexicon-new_entry",
        name="new lexicon entry", title="Create a new lexicon entry.",
        get_pagemeta=True,
    )

    return "\n".join(output)


def _extend_form_url(request, context):
    """
    setup form_url and abort_url
    TODO: Use this in new_content, new_blog, too!
    """
    if "pagemeta" not in request.GET:
        return context

    try:
        pagemeta_id = int(request.GET["pagemeta"])
    except ValueError, err:
        if settings.DEBUG:
            messages.error(request, "Wrong pagemeta ID: %s" % err)
        return context

    try:
        pagemeta = PageMeta.objects.get(id=pagemeta_id)
    except PageMeta.DoesNotExist, err:
        if settings.DEBUG:
            messages.error(request, "Can't get PageMeta: %s" % err)
    else:
        source_url = pagemeta.get_absolute_url()
        context["abort_url"] = source_url
        context["form_url"] += "?pagemeta=%i" % pagemeta_id

    return context


@check_permissions(superuser_only=False, permissions=("lexicon.add_lexiconentry",))# "lexicon.add_links"))
@render_to("lexicon/new_entry.html")
def new_entry(request):
    """ create a new lexicon entry """
    context = {
        "title": _("Create a new lexicon entry"),
        "form_url": request.path,
    }

    context = _extend_form_url(request, context)

    if request.method == "POST":
        if "cancel" in request.POST:
            messages.info(request, _("Create new lexicon entry aborted, ok."))
            try:
                url = PluginPage.objects.reverse("lexicon", viewname="Lexicon-summary")
            except urlresolvers.NoReverseMatch:
                messages.warning(request, _("Lexicon plugin page doesn't exists, yet. Please create."))
                url = "/"
            return http.HttpResponseRedirect(url)

        form = LexiconEntryForm(request.POST)
        if form.is_valid():
            instance = form.save()
            messages.info(request, _("Lexicon entry '%s' saved.") % instance.term)
            return http.HttpResponseRedirect(instance.get_absolute_url())
    else:
        # Get preferences
        pref_form = LexiconPrefForm()

        initial = {
            "sites": get_site_preselection(pref_form, request), # preselect sites field
            "language": request.PYLUCID.current_language.pk, # preselect current language
        }
        form = LexiconEntryForm(initial=initial)

    context["form"] = form
    return context


########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

"""
    PyLucid lexicon forms
    ~~~~~~~~~~~~~~~~~~~~~

    Forms for the lexicon.

    :copyleft: 2008-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django import forms

from pylucid_project.apps.pylucid.forms.utils import TagLanguageSitesFilter

from lexicon.models import LexiconEntry


class LexiconEntryForm(TagLanguageSitesFilter, forms.ModelForm):
    """
    Form for create/edit a lexicon entry.
    The ManyToMany field "sites" from Model would be limited with LimitManyToManyFields
    """
    class Meta:
        model = LexiconEntry

########NEW FILE########
__FILENAME__ = models
# coding: utf-8

"""
    PyLucid lexicon models
    ~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.contrib import messages
from django.core import urlresolvers
from django.core.cache import cache
from django.db import models
from django.db.models import signals
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tagging/
from tagging.fields import TagField

# http://code.google.com/p/django-tools/
from django_tools.middlewares.ThreadLocal import get_current_request
from django_tools.tagging_addon.fields import jQueryTagModelField
from django_tools.template import render
from django_tools.utils.messages import failsafe_message
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid.models import Language
from pylucid_project.base_models.base_markup_model import MarkupBaseModel
from pylucid_project.base_models.base_models import BaseModelManager
from pylucid_project.base_models.many2many import AutoSiteM2M
from pylucid_project.apps.pylucid.system.permalink import plugin_permalink
from pylucid_project.pylucid_plugins import update_journal



TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"


#class Links(UpdateInfoBaseModel):
#    url = models.URLField(verify_exists=True, max_length=255)
#    title = models.CharField(_('Title'), help_text=_("Url title"), max_length=255)
#    entrie = models.ForeignKey("LexiconEntry")


class LexiconEntryManager(BaseModelManager):
    """
    inherited from BaseModelManager:
        - easy_create()
        - get_lang_item()
    """
    def get_filtered_queryset(self, request, filter_language=True):
        queryset = self.model.on_site.filter(is_public=True)
        if filter_language:
            current_lang = request.PYLUCID.current_language
            queryset = queryset.filter(language=current_lang)
        return queryset

    def get_entry(self, request, term, filter_language=True):
        """
        try to return the proper LexiconEntry instance.
        create page_msg error messages and return None it term not found.
        """
        error_msg = _("Unknown lexicon term.")

        if term in ("", None): # e.g.: term not in url or GET parameter 'empty'
            if request.user.is_staff:
                error_msg += " (No term given.)"
            messages.error(request, error_msg)
            return

        queryset = self.get_filtered_queryset(request, filter_language=filter_language)

        try:
            entry = queryset.get(term=term)
        except self.model.DoesNotExist, err:
            if settings.DEBUG or request.user.is_staff:
                error_msg += " (term: %r, original error: %s)" % (term, err)
            messages.error(request, error_msg)
        else:
            return entry


class LexiconEntry(AutoSiteM2M, MarkupBaseModel, UpdateInfoBaseModel):
    """
    A lexicon entry.

    inherited attributes from AutoSiteM2M:
        sites     -> ManyToManyField to Site
        on_site   -> sites.managers.CurrentSiteManager instance
        site_info -> a string with all site names, for admin.ModelAdmin list_display

    inherited attributes from MarkupBaseModel:
        content field
        markup field
        get_html() method

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    objects = LexiconEntryManager()

    term = models.CharField(_('Term'), help_text=_("Term in primitive form"), max_length=255)
    language = models.ForeignKey(Language)
    alias = TagField(# from django-tagging
        help_text=mark_safe(
            _('alias for this entry. <a href="%s" class="openinwindow"'
            ' title="Information about tag splitting.">tag format help</a>') % TAG_INPUT_HELP_URL
        )
    )
    tags = jQueryTagModelField() # a django-tagging model field modified by django-tools
    short_definition = models.CharField(_('Short definition'),
        help_text=_("A short explain."), max_length=255
    )

    is_public = models.BooleanField(
        default=True, help_text="Is post public viewable?"
    )

    def __init__(self, *args, **kwargs):
        super(LexiconEntry, self).__init__(*args, **kwargs)

        # Change field meta data in a DRY way
        content_field = self._meta.get_field_by_name("content")[0]
        content_field.help_text = _("Explain the term")

    def save(self, *args, **kwargs):
        """
        Save and update the cache
        """
        super(LexiconEntry, self).save(*args, **kwargs)

        try:
            cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
        except AttributeError:
            # No SmoothCacheBackend used -> clean the complete cache
            cache.clear()

    def get_name(self):
        """ e.g. for pylucid comment """
        return self.term

    def get_update_info(self):
        """ update info for update_journal.models.UpdateJournal used by update_journal.save_receiver """
        if not self.is_public: # Don't list non public articles
            return

        return {
            "lastupdatetime": self.lastupdatetime,
            "user_name": self.lastupdateby,
            "language": self.language,
            "object_url": self.get_absolute_url(),
            "title": _("New lexicon entry '%s'.") % self.term,
        }

    def get_absolute_url(self):
        viewname = "Lexicon-detail_view"
        reverse_kwargs = {"term":self.term} #slugify(self.term)
        try:
            # This only worked inner lucidTag
            return urlresolvers.reverse(viewname, kwargs=reverse_kwargs)
        except urlresolvers.NoReverseMatch:
            # Use the first PluginPage instance
            from pylucid_project.apps.pylucid.models import PluginPage # import here, against import loops
            try:
                return PluginPage.objects.reverse("lexicon", viewname, kwargs=reverse_kwargs)
            except urlresolvers.NoReverseMatch:
                return "/?lexicon=%s" % self.term

    def get_permalink(self, request):
        """ permalink to this entry detail view """
        absolute_url = self.get_absolute_url() # Absolute url to this entry
        permalink = plugin_permalink(request, absolute_url)
        return permalink

    def __unicode__(self):
        return self.term

    class Meta:
        unique_together = (("language", "term"),)
        ordering = ('term',)


signals.post_save.connect(receiver=update_journal.save_receiver, sender=LexiconEntry)

# Bug in django tagging?
# http://code.google.com/p/django-tagging/issues/detail?id=151#c2
#try:
#    tagging.register(BlogEntry)
#except tagging.AlreadyRegistered: # FIXME
#    pass

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

# http://code.google.com/p/django-tagging/
from tagging.utils import parse_tag_input

from pylucid_project.utils.site_utils import SitePreselectPreference

from dbpreferences.forms import DBPreferencesBaseForm

TAG_INPUT_HELP_URL = \
"http://google.com/search?q=cache:django-tagging.googlecode.com/files/tagging-0.2-overview.html#tag-input"

SKIP_TAGS_CACHE = None

DEFAULT_SKIP_TAGS = "script pre textarea fieldset a input h1 h2 h3 h4 h5 h6"

class LexiconPrefForm(SitePreselectPreference, DBPreferencesBaseForm):
    skip_tags = forms.CharField(
        required=False,
        initial=DEFAULT_SKIP_TAGS,
        help_text=mark_safe(
            _('Don\'t replace a word if it exist in the given html tags.'
            ' (tagging field <a href="%s" class="openinwindow"'
            ' title="Information about splitting.">format help</a>)') % TAG_INPUT_HELP_URL
        )
    )

    def clean(self, *args, **kwargs):
        """ hook into admin change validation for cleaning SKIP_TAGS_CACHE """
        global SKIP_TAGS_CACHE
        SKIP_TAGS_CACHE = None
#        print "*** Clean skip tags cache"
        return super(LexiconPrefForm, self).clean(*args, **kwargs)

    def get_skip_tags(self):
        global SKIP_TAGS_CACHE
        if SKIP_TAGS_CACHE is None:
#            print "*** Fill skip tags cache"
            self.get_preferences()
            skip_tag_string = self.data.get("skip_tags", DEFAULT_SKIP_TAGS)
            SKIP_TAGS_CACHE = parse_tag_input(skip_tag_string)

#        print "*** skip tags: %r" % SKIP_TAGS_CACHE

        return SKIP_TAGS_CACHE

    class Meta:
        app_label = 'lexicon'

########NEW FILE########
__FILENAME__ = search
# coding:utf-8

"""
    search in lexicon entries
    ~~~~~~~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django.db.models import Q

# http://code.google.com/p/django-tagging/
from tagging.utils import parse_tag_input

from pylucid_project.pylucid_plugins.lexicon.models import LexiconEntry


class Search(object):
    def get_queryset(self, request, search_languages, search_strings):
        queryset = LexiconEntry.on_site.select_related()

        # Only public lexicon items:
        queryset = queryset.filter(is_public=True)

        # Only items in the selected search language
        queryset = queryset.filter(language__in=search_languages)

        for term in search_strings:
            queryset = queryset.filter(
                Q(term__icontains=term) | Q(tags__icontains=term) | Q(alias__icontains=term) |
                Q(content__icontains=term) | Q(short_definition__icontains=term)
            )
        return queryset

    def add_search_results(self, request, queryset, search_results):
        for item in queryset:
            meta_content = parse_tag_input(item.tags)
            meta_content += parse_tag_input(item.alias)
            meta_content += [item.term, item.short_definition]
            meta_content = " ".join(meta_content)
            #print "meta: %r" % meta_content

            search_results.add(
                model_instance=item,

                # displayed short_definition of the result hit
                headline="%s: %s" % (item.term, item.short_definition),

                # displayed in the result list
                language=item.language,

                # Link to the hit
                url=item.get_absolute_url(),

                # the main content -> result lines would be cut out from hits in this content
                content=item.get_search_content(request),

                # hits in meta content has a higher score, but the content would not displayed 
                meta_content=meta_content,
            )

########NEW FILE########
__FILENAME__ = signal_receiver
# coding: utf-8

"""
    PyLucid lexicon plugin
    ~~~~~~~~~~~~~~~~~~~~~~

    signal receiver, connected in lexicon.__init__.py
    Search in the page_content for all lexicon terms and
    replace them with a link.

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


import sys
import traceback
import HTMLParser
from xml.sax.saxutils import escape

from django.conf import settings
from django.contrib import messages
from django.template.loader import render_to_string
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _

# http://code.google.com/p/django-tagging/
from tagging.utils import parse_tag_input

from lexicon.sub_html import SubHtml


WORD_TAG = u"<!-- word -->"


class LexiconData(dict):
    """
    Hold the lexicon data for replacing a lexicon word with a link.
    """
    def __init__(self, *args, **kwargs):
        self._cache = {}
        super(LexiconData, self).__init__(*args, **kwargs)

    def __call__(self, matchobject):
        """
        called from lexicon.sub_html.SubHtml
        
        We render a lexicon link in two steps, because the actual replaced word
        for a term can be vary in spelling. So in the first step, we render
        everything except the original word and cached this. In the second we
        replaced the placeholder with the real word.
        """
        word = matchobject.group(0) # The original word
        data = self[word.lower()] # get the lexicon data for this word
        term = data["term"] # The lexicon term for this word
        if term not in self._cache:
            context = {
                "term": term,
                "short_definition": data["short_definition"],
            }
            # Render the lexicon link without the original word.
            definition_link = render_to_string("lexicon/definition_link.html", context)
            self._cache[term] = definition_link
        else:
            definition_link = self._cache[term]

        # Replace the placeholder with the original word.
        html = definition_link.replace(WORD_TAG, word)
        return html


def pre_render_global_template_handler(**kwargs):
    """
    Handle the 'pre_render_global_template' signal.
    Replace lexicon words in the page_content with a link (with short_definition title)
    to the lexicon.
    """
    request = kwargs["request"]

    current_lang = request.PYLUCID.current_language
    page_content = request.PYLUCID.context["page_content"]

    from lexicon.models import LexiconEntry # import loops
    queryset = LexiconEntry.on_site.filter(is_public=True).filter(language=current_lang)
    entries = queryset.values_list("term", "alias", "short_definition")

    lexicon_data = LexiconData()
    for term, alias, short_definition in entries:
        aliases = parse_tag_input(alias) # Split django-tagging field value into a Python list
        all_words = [term] + aliases
        words_lower = set([word.lower() for word in all_words])

        for word in words_lower:
            lexicon_data[word] = {"term": term, "short_definition": short_definition}

    if not lexicon_data:
        # No lexicon entries -> nothing to do
        return

    from lexicon.preference_forms import LexiconPrefForm # import here, against import loops
    pref_form = LexiconPrefForm()
    skip_tags = pref_form.get_skip_tags()

    s = SubHtml(lexicon_data, skip_tags)

    try:
        s.feed(page_content)
    except HTMLParser.HTMLParseError, err:
        # HTMLParser can only parse valid HTML code.

        msg = _("Wrong HTML code")
        if request.user.is_staff: # add more info for staff members
            lines = page_content.splitlines(True)
            line = lines[err.lineno - 1].rstrip()
            marker = "-" * err.offset + "^"

            msg += (
                u" (%(err)s)\n"
                "<pre>%(line)s\n%(marker)s</pre>"
            ) % {
                "err": escape(str(err)),
                "line": escape(line),
                "marker": marker,
            }
            messages.info(request, mark_safe(msg))

        if settings.DEBUG:
            # insert more information into the traceback and re-raise the original error
            etype, evalue, etb = sys.exc_info()
            evalue = etype('%s: %s' % (msg, err))
            raise etype, evalue, etb

        if request.user.is_superuser:
            # put the full traceback into page_msg, but only for superusers
            messages.debug(request, mark_safe("<pre>%s</pre>" % traceback.format_exc()))

    else:
        page_content = s.html # Get the html code with the lexicon links
        # Update the page content:
        request.PYLUCID.context["page_content"] = mark_safe(page_content)



########NEW FILE########
__FILENAME__ = sub_html
# coding: utf-8

"""
    PyLucid lexicon plugin
    ~~~~~~~~~~~~~~~~~~~~~~

    Related threads in german python forum:
        http://www.python-forum.de/topic-19964.html
        http://www.python-forum.de/topic-22102.html    
   
    Last commit info:
    ~~~~~~~~~
    $LastChangedDate: $
    $Rev: $
    $Author: JensDiemer $

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

import os
import re
import HTMLParser
from xml.sax.saxutils import quoteattr


if __name__ == "__main__":
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"
    virtualenv_file = "../../../../../bin/activate_this.py"
    execfile(virtualenv_file, dict(__file__=virtualenv_file))



class NoneHTMLParser(object, HTMLParser.HTMLParser):
    """
    Parse the html code with HTMLParser and rebuilt it in self.html
    FIXME: Changes from original html to regenerated:
        - entityref lile umlaute would be replace with the real character, e.g.: &auml; -> 
        - spaces can be changed, e.g:
            old: <a  href="foo"  >bar</a>
            new: <a href="foo">bar</a>
            old: <br/>
            new: <br />
        - empty attributes are made xhtml conform, e.g:
            old: <td nowrap>
            new: <td nowarp="nowarp">
        - add quote sign to attributes without quote sign, e.g:
            old: <table border=1>
            new: <table border="1">
        - newlines in tags are removes:
            old: <link\nrel="...
            new: <link rel="...
        - attribute quoting can be changed:
            old: title="foo &quot;bar&quot;"
            new: title='foo "bar"'
    """
    def __init__(self):
        # Note: HTMLPaser is a oldstyle class!
        self.reset() # Initialize and reset this HTMLParser instance.

        self.html = ""

    def _add_attrs(self, attrs):
        if attrs:
            attr_list = []
            for attr, value in attrs:
                if value is None:
                    # convert empty attrs to xhtml conform attributes
                    # e.g.: <td nowrap>  ->>  <td nowarp="nowarp">
                    value = attr
                # FIXME: original quoting can be changed
                # e.g: title="foo &quot;bar&quot;" -> title='foo "bar"'
                value = quoteattr(value)
                attr_list.append('%s=%s' % (attr, value))

            self.html += " " + " ".join(attr_list)

    def handle_startendtag(self, tag, attrs):
#        print "handle start+end tag: %r attrs: %r" % (tag, attrs)
        self.html += "<" + tag
        self._add_attrs(attrs)
        self.html += " />"

    def handle_starttag(self, tag, attrs):
#        print "handle start tag: %r attrs: %r" % (tag, attrs)
        self.html += "<" + tag
        self._add_attrs(attrs)
        self.html += ">"

    def handle_endtag(self, tag):
#        print "handle end tag: %r" % tag
        self.html += "</%s>" % tag

    def handle_charref(self, name):
#        print "handle character reference: %r" % name
        self.html += "&#%s;" % name

    def handle_entityref(self, name):
#        print "handle entity reference: %r" % name
        self.html += "&%s;" % name

    def handle_data(self, data):
#        print "handle data: %r" % data
        self.html += data

    def handle_comment(self, data):
#        print "handle comment: %r" % data
        self.html += "<!--%s-->" % data

    def handle_decl(self, decl):
#        print "handle declaration: %r" % decl
        self.html += "<!%s>" % decl

    def handle_pi(self, data):
        print "handle processing instruction:", data

    def unknown_decl(self, data):
        self.error("unknown declaration: %r" % (data,))



class SubHtml(NoneHTMLParser):
    """
    replace all lexicon words in handle_data()
    """
    def __init__(self, lexicon_data, skip_tags):
        super(SubHtml, self).__init__()

        # forming a dict from the skip_tags list, for faster lookup
        self.skip_tags = dict([(tag.lower(), None) for tag in skip_tags])

        self.lexicon_data = lexicon_data

        self.regex = self._build_regex() # Build the regexp to find all lexicon words

        self.in_skip_tag = None # Storage if we are in a skip_tags

    def _build_regex(self):
        keys = self.lexicon_data.keys()

        # Sort longest to shortest
        keys.sort(cmp=lambda x, y: cmp(len(y), len(x)))

        # match on all existing keys with ignorecase
        regex = re.compile(
            "(?<=[\s\>])(%s)(?=[\s\<\.,:])" % "|".join(keys),
            re.IGNORECASE | re.UNICODE | re.MULTILINE
        )
        return regex

    def handle_starttag(self, tag, attrs):
        super(SubHtml, self).handle_starttag(tag, attrs)
#        print "handle start tag: %r attrs: %r" % (tag, attrs)
        if tag in self.skip_tags:
            self.in_skip_tag = tag

    def handle_endtag(self, tag):
        super(SubHtml, self).handle_endtag(tag)
#        print "handle end tag: %r" % tag
        if tag == self.in_skip_tag:
            self.in_skip_tag = None

    def handle_data(self, data):
#        print "handle data: %r" % data
        if data and data.strip(" \n\t") and self.in_skip_tag is None:
            # data is not empty and we are not in a skip_tag area -> replace lexicon entries
            # call lexicon_data with the match object
            data = " %s " % data # work-a-round: http://www.python-forum.de/viewtopic.php?p=162915#162915 
            data = self.regex.sub(self.lexicon_data, data)
            data = data[1:-1] # work-a-round

        self.html += data



if __name__ == "__main__":
    import urllib2, time
    from pylucid_project.utils.diff import diff_lines

#    import doctest
#    doctest.testmod(verbose=False)
#    print "DocTest end."

    skip_tags = ('a', 'input', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'textarea', 'fieldset')

    class LexiconData(dict):
        def __call__(self, matchobject):
            word = matchobject.group(0)
            print "LexiconData.__call__: %r" % word
            term = self[word.lower()]
            return term + word + term

    lexicon_data = LexiconData({"foo bar": "1", "foo": "2", "bar": "3"})
#    lexicon_data = LexiconData({"match on nothing!": None})

#    url = "http://www.pylucid.org"
#    url = "http://www.google.com"
#    url = "http://www.python.org"
#    url = "http://www.heise.de"
#    url = "http://www.facebook.com"
#
#    print "request %r..." % url,
#    f = urllib2.urlopen(url)
#    html = f.read()
#    f.close()
#    print "OK"

#    html = '<a href="foo" title="here &quot;is a problem&quot; fuck">bar</a>'
    html = '''
<html><p><a href="Foo Bar"><strong>Foo Bar</strong> Bar</a>
one Foo Bar two FOO three BaR four
Here not: Fooo or XbarX
</p></html>
'''

    start_time = time.time()
    s = SubHtml(lexicon_data, skip_tags=["a"])
    s.feed(html)
    s.close()
    print "+++ duration: %.3fsec" % (time.time() - start_time)
    print diff_lines(html, s.html)

#    print "-" * 79
#    print html
#    print "-" * 79
#    print p.html
#    print "-" * 79



########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8


"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - There exist only "PyLucid CMS" lexicon entry in english and german
    
    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import sys


if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#    tests = "pylucid_plugins.lexicon.tests.LexiconPluginTest1.test_cancel_create_new_entry"
#    tests = "pylucid_plugins.lexicon.tests.LexiconPluginTest1.test_error_handling"

    from pylucid_project.tests import run_test_directly
    run_test_directly(tests,
        verbosity=2,
#        failfast=True
    )
    sys.exit()


from django.conf import settings
from django.core.urlresolvers import reverse
from django.test.client import Client

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageContent
from pylucid_project.apps.pylucid.markup import MARKUP_CREOLE, MARKUP_HTML

from pylucid_project.pylucid_plugins.lexicon.models import LexiconEntry


SUMMARY_URL = "/%s/lexicon/"
ENTRY_URL = "/%s/lexicon/detail/PyLucid%%20CMS/"


class LexiconPluginTestCase(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.other_lang_code - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    SUMMARY_MUST_CONTAIN_EN = (
        '<a href="/en/lexicon/detail/PyLucid%20CMS/">PyLucid CMS</a>',
        '<dd>PyLucid is the CMS thats built this page.</dd>',
    )
    SUMMARY_MUST_CONTAIN_DE = (
        '<a href="/de/lexicon/detail/PyLucid%20CMS/">PyLucid CMS</a>',
        '<dd>PyLucid ist ein flexibles, Open Source Webseiten Content Management System.</dd>',
    )
    ENTRY_MUST_CONTAIN_EN = (
        '<a href="/en/lexicon/detail/PyLucid CMS/" title="PyLucid CMS', # breadcrumbs
        '<dd>PyLucid CMS</dd>',
        '<dt>Short definition:</dt>',
        '<p>This pages are created by PyLucid ;)</p>',
        'Leave a comment</a>', # comments
    )
    ENTRY_MUST_CONTAIN_DE = (
        '<a href="/de/lexicon/detail/PyLucid CMS/" title="PyLucid CMS', # breadcrumbs
        '<dd>PyLucid CMS</dd>',
        '<dt>Kurzdefinition:</dt>',
        '<p>Diese Seiten werden mit PyLucid CMS generiert ;)</p>',
        'Kommentar hinterlassen</a>', # comments
    )
    ENTRY_MUST_CONTAIN_ES = (
        '<a href="/es/lexicon/detail/Spanish/" title="Spanish: Spanish is a language ;)"', # breadcrumbs
        '<dd>Spanish</dd>',
        '<p>Spanish or Castilian (espaol or castellano) is a Romance language...</p>',
        'Leave a comment</a>', # comments
    )

    def assertLexiconPage(self, response, must_contain):
        self.assertStatusCode(response, 200)
        self.assertResponse(response, must_contain=must_contain,
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

    def assertSummaryEN(self, response):
        self.assertLexiconPage(response, must_contain=self.SUMMARY_MUST_CONTAIN_EN)

    def assertSummaryDE(self, response):
        self.assertLexiconPage(response, must_contain=self.SUMMARY_MUST_CONTAIN_DE)

    def assertEntryEN(self, response):
        self.assertLexiconPage(response, must_contain=self.ENTRY_MUST_CONTAIN_EN)

    def assertEntryDE(self, response):
        self.assertLexiconPage(response, must_contain=self.ENTRY_MUST_CONTAIN_DE)

    def assertEntryES(self, response):
        self.assertLexiconPage(response, must_contain=self.ENTRY_MUST_CONTAIN_ES)


class LexiconPluginTest1(LexiconPluginTestCase):
    """
    Tests with existing lexicon entries
    """
    def test_summary_en(self):
        response = self.client.get(
            SUMMARY_URL % self.default_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertSummaryEN(response)
        self.assertContentLanguage(response, self.default_language)

    def test_summary_de(self):
        response = self.client.get(
            SUMMARY_URL % self.other_language.code,
            HTTP_ACCEPT_LANGUAGE=self.other_language.code,
        )
        self.assertSummaryDE(response)
        self.assertContentLanguage(response, self.other_language)

    def test_lexicon_entry_en(self):
        response = self.client.get(
            ENTRY_URL % self.default_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertEntryEN(response)
        self.assertContentLanguage(response, self.default_language)

    def test_lexicon_entry_de(self):
        response = self.client.get(
            ENTRY_URL % self.other_language.code,
            HTTP_ACCEPT_LANGUAGE=self.other_language.code,
        )
        self.assertEntryDE(response)
        self.assertContentLanguage(response, self.other_language)

    def test_switch_url_language(self):
        """
        TODO!
        Request german language entry, but english is current language
        -> redirect to english url
        """
        response = self.client.get(
            ENTRY_URL % self.other_language.code,
            HTTP_ACCEPT_LANGUAGE=self.default_language.code,
        )
        self.assertRedirect(
            response, url="http://testserver" + ENTRY_URL % self.default_language.code, status_code=302
        )

    def test_get_view(self):
        response = self.client.get("/en/welcome/?lexicon=PyLucid CMS")
        self.assertResponse(response,
            must_contain=(
                'PyLucid CMS',
                'lang="en"',
                '<a href="/en/lexicon/">&lt;&lt; goto lexicon summary page</a>',
                '<dt>Short definition:</dt>',
                '<p>This pages are created by PyLucid ;)</p>',
                'Leave a comment</a>',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

    def test_create_csrf_error(self):
        self.login("superuser")
        csrf_client = Client(enforce_csrf_checks=True)
        url = reverse("Lexicon-new_entry")
        response = csrf_client.post(url)
        self.assertResponse(response,
            must_contain=(
                "CSRF verification failed."
            ),
            must_not_contain=("Traceback", "Form errors", "field is required")
        )

    def test_create_form(self):
        self.login("superuser")
        url = reverse("Lexicon-new_entry")
        response = self.client.get(url)

        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = response.content.replace(
            """.html('<h2 class="noanchor">loading...</h2>');""",
            """.html('loading...');"""
        )
        self.assertDOM(response,
            must_contain=(
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
                '<input id="id_term" maxlength="255" name="term" type="text" />',
                '<textarea cols="40" id="id_content" name="content" rows="10"></textarea>',
                '<input type="submit" name="save" value="Save" />',
            ),
        )
        self.assertResponse(response,
            must_contain=(
                "<title>PyLucid - Create a new lexicon entry</title>",
                '<form', 'action="%s"' % url,
            ),
            must_not_contain=("Traceback", "Form errors", "field is required",
                "XXX INVALID TEMPLATE STRING"
            )
        )

    def test_create_new_entry(self):
        self.login("superuser")
        url = reverse("Lexicon-new_entry")
        response = self.client.post(url, data={
            'content': '**foo** //bar//',
            'is_public': 'on',
            'language': 1,
            'markup': 6,
            'short_definition': 'jojo',
            'sites': 1,
            'term': 'test'},
            follow=True,
        )
        self.assertResponse(response,
            must_contain=(
                "<title>PyLucid CMS - The &#39;lexicon&#39; plugin page.</title>",
                '<dt>Term:</dt>', '<dd>test</dd>',
                '<dt>Short definition:</dt>', '<dd>jojo</dd>',
                '<dt>Content:</dt>', '<p><strong>foo</strong> <i>bar</i></p>',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

    def test_cancel_create_new_entry(self):
        self.login("superuser")
        url = reverse("Lexicon-new_entry")
        response = self.client.post(url, data={"cancel": "Cancel"}, follow=True)
        self.assertResponse(response,
            must_contain=(
                "Create new lexicon entry aborted, ok.",
                "<title>PyLucid CMS - The &#39;lexicon&#39; plugin page.</title>",
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

    def test_create_new_entry_preview(self):
        self.login("superuser")
        url = reverse("Lexicon-markup_preview")
        response = self.client.post(url, data={
            'content': '**foo** //bar//',
            'markup': 6,
            },
            HTTP_X_REQUESTED_WITH='XMLHttpRequest',
            follow=True,
        )
        self.assertResponse(response,
            must_contain=(
                '<p><strong>foo</strong> <i>bar</i></p>',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING", "<body", "<html")
        )

    def test_error_handling(self):
        self.login("staff")

        pagecontent = PageContent.objects.all().filter(markup=MARKUP_HTML)[0]

        url = pagecontent.get_absolute_url()

        pagecontent.content = "<p>\nDoes PyLucid rocks?\n</p>"
        pagecontent.save()

        # Check unmodified page
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS',
                '''<a href="?lexicon=PyLucid CMS" title="lexicon entry 'PyLucid CMS' - PyLucid is the CMS thats built this page." class="PyLucidPlugins lexicon openinwindow">PyLucid</a> rocks?''',

            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )

        pagecontent.content += "\n<p>This is not <a error 0=0> html, isn't it?</p>\n"
        pagecontent.save()

        settings.DEBUG = False # don't raise traceback

        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS',
                'Wrong HTML code (malformed start tag, at line 4, column 25)',
                '''<pre>&lt;p&gt;This is not &lt;a error 0=0&gt; html, isn't it?&lt;/p&gt;''',
                '------------------------^</pre>',
                'Does PyLucid rocks?',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )



class LexiconPluginTest2(LexiconPluginTestCase, basetest.BaseMoreLanguagesTestCase):
    """
    Tests with some new lexicon entries
        
    inherited from BaseMoreLanguagesTestCase:
        - created languages: "es", "es-ar", "pt", "hr"
        - self.languages - A dict with language code as keys and language instance as values   
    """
    def _pre_setup(self, *args, **kwargs):
        """ create some blog articles """
        super(LexiconPluginTest2, self)._pre_setup(*args, **kwargs)

        defaults = {
            "markup": MARKUP_CREOLE,
            "is_public": True,
        }

        self.entry_es = self.easy_create(LexiconEntry, defaults,
            term="Spanish",
            language=self.languages["es"],
            tags="shared, Spain, other",
            short_definition="Spanish is a language ;)",
            content="Spanish or Castilian (espaol or castellano) is a Romance language...",
        )

    def test_es_entry(self):
        response = self.client.get("/es/lexicon/detail/Spanish/", HTTP_ACCEPT_LANGUAGE="es")
        self.assertEntryES(response)

    def test_es_redirect(self):
        """
        the activated language is German, but we want a Spain lexicon entry -> Redirect to it 
        """
        response = self.client.get(
            "/es/lexicon/detail/Spanish/",
            HTTP_ACCEPT_LANGUAGE="not-exist;q=0.9,de;q=0.8,pt-br;q=0.7,es;q=0.5"
        )
        self.assertRedirect(
            response, url="http://testserver/es/lexicon/detail/Spanish/", status_code=302
        )



########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

from django.conf.urls.defaults import patterns, url

from lexicon.views import summary, detail_view

urlpatterns = patterns('',
    url(r'^detail/(?P<term>.*?)/$', detail_view, name='Lexicon-detail_view'),
    url(r'^', summary, name='Lexicon-summary'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid lexicon plugin
    ~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2008-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django import http
from django.conf import settings
from django.contrib import messages
from django.utils.translation import ugettext as _
from django.views.decorators.csrf import csrf_protect

from pylucid_project.apps.pylucid.decorators import render_to
from pylucid_project.apps.pylucid.models import PluginPage
from pylucid_project.apps.pylucid.system import i18n

from lexicon.models import LexiconEntry


def _add_breadcrumb(request, title, url):
    """ shortcut for add breadcrumb link """
    context = request.PYLUCID.context
    breadcrumb_context_middlewares = request.PYLUCID.context_middlewares["breadcrumb"]
    # Blog entries have only a headline, use it for name and title
    breadcrumb_context_middlewares.add_link(title, title, url)


@render_to("lexicon/summary.html")
def summary(request):
    _add_breadcrumb(request, title="Lexicon summary", url=request.path)

    queryset = LexiconEntry.objects.get_filtered_queryset(request)

    # For adding page update information into context by pylucid context processor
    try:
        # Use the newest lexicon entry
        request.PYLUCID.updateinfo_object = queryset.latest("lastupdatetime")
    except LexiconEntry.DoesNotExist:
        # No blog entries created, yet.
        pass

    context = {
        "entries": queryset
    }
    return context


@csrf_protect
@render_to("lexicon/detail_view.html")
def detail_view(request, term=None):

    error_msg = _("Unknown lexicon term.")

    if term in ("", None): # e.g.: term not in url or GET parameter 'empty'
        if settings.DEBUG or request.user.is_staff:
            error_msg += " (No term given.)"
        messages.error(request, error_msg)
        return

    entry = None
    tried_languages = []
    try:
        queryset = LexiconEntry.on_site.filter(is_public=True)
        queryset = queryset.filter(term=term)
        entry, tried_languages = LexiconEntry.objects.get_by_prefered_language(request, queryset)
    except LexiconEntry.DoesNotExist, err:
        pass

    """
    FIXME: This current solution is boring.
    LexiconEntry.objects.get_by_prefered_language() with i18n.assert_language()
    doesn't do a good job here.
    e.g:
        en + de exists as languages
        user prefered de and called /en/foobar
        foobar does only exist in en not in de
    """

    if entry is None:
        # Entry not found -> Display summary with error message as 404 page
        if settings.DEBUG or request.user.is_staff or settings.PYLUCID.I18N_DEBUG:
            error_msg += " (term: %r, tried languages: %s)" % (term, ", ".join([l.code for l in tried_languages]))
        messages.error(request, error_msg)
        response = summary(request)
        response.status_code = 404 # Send as 404 page, so that search engines doesn't index this. 
        return response

    new_url = i18n.assert_language(request, entry.language, check_url_language=True)
    if new_url:
        # the current language is not the same as entry language -> redirect to right url
        # e.g. someone followed a external link to this article, but his preferred language
        # is a other language as this article. Activate the article language and "reload"
        return http.HttpResponseRedirect(new_url)

#    if entry.language != request.PYLUCID.current_language:
#        # The item exist in a other language than the client preferred language
#        msg = _(
#            "Info: This lexicon entry is written in %(article_lang)s."
#            " However you prefer %(client_lang)s."
#        ) % {
#            "article_lang": entry.language.description,
#            "client_lang": request.PYLUCID.current_language.description,
#        }
#        if settings.DEBUG or request.user.is_staff or settings.PYLUCID.I18N_DEBUG:
#            msg += "(tried languages: %s)" % ", ".join([l.code for l in tried_languages])
#        messages.info(request, msg)


    _add_breadcrumb(request, title="%s: %s" % (entry.term, entry.short_definition), url=request.path)

    # Change permalink from the blog root page to this entry detail view
    permalink = entry.get_permalink(request)
    request.PYLUCID.context["page_permalink"] = permalink # for e.g. the HeadlineAnchor

    # Add comments in this view to the current lexicon entry and not to PageMeta
    request.PYLUCID.object2comment = entry

    # For adding page update information into context by pylucid context processor
    request.PYLUCID.updateinfo_object = entry

    context = {
        "entry": entry,
        "page_permalink": permalink, # Change the permalink in the global page template
    }
    return context


@render_to("lexicon/detail_popup.html")
def http_get_view(request):
    term = request.GET["lexicon"]

    entry = LexiconEntry.objects.get_entry(request, term)
    if entry is None:
        # term not exist. page_msg was created.
        return summary(request)

    try:
        summary_url = PluginPage.objects.reverse("lexicon", "Lexicon-summary")
    except Exception, err:
        if settings.DEBUG:
            messages.error(request, "Can't get summary url: %s" % err)
        summary_url = None

    # Add comments in this view to the current lexicon entry and not to PageMeta
    request.PYLUCID.object2comment = entry

    # For adding page update information into context by pylucid context processor
    request.PYLUCID.updateinfo_object = entry

    context = {
        "entry": entry,
        "summary_url": summary_url,
    }
    return context

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

"""
    PyLucid main_menu plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Generates a tree menu.

    :copyleft: 2005-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.contrib import messages

from pylucid_project.apps.pylucid.models import PageTree
from pylucid_project.apps.pylucid.decorators import render_to


def _debug(request, tree):
    messages.debug(request, "tree nodes: %r" % tree.nodes)
    messages.debug(request, "All PageTree:", PageTree.objects.all())
    messages.debug(request, "Current user:", request.user)
    messages.debug(request, "all accessible PageTree:", PageTree.objects.all_accessible(request.user).all())


@render_to("main_menu/main_menu.html")
def lucidTag(request, min=1, max=0):
    """
    You can split the menu with the optional min and max arguments:
    * min - The starting level (first level is 1)
    * max - The end level (without end, use 0)
    
    more info:
    http://www.pylucid.org/permalink/132/the-main-menu-plugin
    
    example:
        {% lucidTag main_menu %}
        {% lucidTag main_menu min=1 max=1 %}
        {% lucidTag main_menu min=2 max=0 %}
    """
    current_pagetree = request.PYLUCID.pagetree
    user = request.user

    # Get a pylucid.tree_model.TreeGenerator instance with all accessible PageTree for the current user
    tree = PageTree.objects.get_tree(user, filter_showlinks=True)

    # activate the current pagetree node (for main menu template)
    def get_first_showlink(pagetree):
        """ returns the first pagetree witch has showlinks==True, go recursive up to next parent """
        if pagetree.showlinks == False:
            if pagetree.parent == None:
                # not parent page available -> activate root node
                return None
            else:
                # go recursive up to next parent
                return get_first_showlink(pagetree.parent)
        return pagetree.id

    first_showlink_id = get_first_showlink(current_pagetree)
    try:
        tree.set_current_node(first_showlink_id)
    except KeyError, err:
        tree.set_current_node(None) # Root node
        if settings.DEBUG:
            messages.error(request, "Can't activate menu item %r KeyError: %s" % (current_pagetree, err))
            _debug(request, tree)

    tree.slice_menu(min, max)

    # add all PageMeta objects into tree
    tree.add_pagemeta(request)

#    _debug(request, tree)

    return {"nodes": tree.get_first_nodes()}












########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""
from django.conf import settings
from django.utils.translation import ugettext_lazy as _
from django.conf.urls.defaults import patterns, url

from package_info import admin_views

urlpatterns = patterns('',
    url(r'^used_packages/$', admin_views.used_packages, name='package_info-used_packages'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8

from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu


def install(request):
    """ insert PyLucid admin views into AdminMenu """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("system")

    admin_menu.add_menu_entry(
        parent=menu_section_entry, url_name="package_info-used_packages",
        name="package info", title="Liste all used python packages",
    )

    return "\n".join(output)



@check_permissions(superuser_only=False, must_staff=True)
@render_to("package_info/admin_package_info.html")
def used_packages(request):
    return {"title": _("package information")}



########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid packages information plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p

"""

import os
import subprocess
import sys
import traceback
import time

if __name__ == "__main__":
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"
    virtualenv_file = "../../../../../bin/activate_this.py"
    execfile(virtualenv_file, dict(__file__=virtualenv_file))

import pkg_resources

from django.conf import settings
from django.contrib import messages
from django.utils.safestring import mark_safe
from django.utils.version import get_svn_revision
import django

from pylucid_project import VERSION_STRING, get_commit_timestamp
from pylucid_project.apps.pylucid.decorators import render_to

# print (!) some debug info. Values can be: False, 1, 2
DEBUG = False

# Collect only information about these packages:
PACKAGES = (
    'django',
    'django-dbpreferences',
    'django-dbtemplates',
    'django-reversion',
    'django-tagging',
    'django-tools',
    'django-processinfo',
    'feedparser',
    'pip',
    'pygments',
    'south',
    'pylucid',
    'python-creole'
)

# Default packages information
# Importand:
#       Information stored in STATIC_PKG_INFO would not be overwritten!
STATIC_PKG_INFO = dict.fromkeys(PACKAGES, {})

STATIC_PKG_INFO["django"] = {
    "license": "BSD",
    "license_url": "http://code.djangoproject.com/browser/django/trunk/LICENSE",
    "version": django.get_version(),
}
STATIC_PKG_INFO["django-dbtemplates"] = {
    "license": "BSD",
    "license_url": "https://github.com/jezdez/django-dbtemplates/blob/develop/LICENSE",
}
STATIC_PKG_INFO["django-reversion"] = {
    "license": "New BSD",
    "license_url": "https://github.com/etianen/django-reversion/blob/master/LICENSE",
}
STATIC_PKG_INFO["pylucid"] = {
    "license": "GNU GPL v3 or above",
    "license_url": "http://www.pylucid.org/permalink/37/License/",
    "version": VERSION_STRING,
}
STATIC_PKG_INFO["pip"] = {
    "license_url": "https://github.com/pypa/pip/blob/develop/LICENSE.txt",
}
STATIC_PKG_INFO["pygments"] = {
    "license_url": "https://bitbucket.org/birkenfeld/pygments-main/src/tip/LICENSE",
}
STATIC_PKG_INFO["python-creole"] = {
    "license": "GNU GPL v3 or above",
    "license_url": "https://github.com/jedie/python-creole/blob/master/LICENSE",
}
STATIC_PKG_INFO["django-processinfo"] = {
    "license": "GNU GPL v3 or above",
    "license_url": "https://github.com/jedie/django-processinfo/blob/master/LICENSE",
}


# Attribute names witch are transfered from
# Distribute package object into the package info dict
PKG_DIST_ATTRS = (
    "version", "project_name", "location",
)

# keys witched are used from PKG-INFO file
PKG_INFO_KEYS = (
    "Summary",
    "Home-page",
    "Author",
    "Author-email",
    "License",
    "Download-URL"
)



class PackageInfo(dict):
    " Holds all package information for *one* package "
    def __init__(self, pkg_dist, defaults):
        self.pkg_dist = pkg_dist
        dict.__init__(self, defaults)

        self._fill_with_dist_attr()
        self._fill_with_pkg_info()
        self._add_vcs_reversion()

    def _fill_with_dist_attr(self):
        """
        Add package informations from package distribution object attributes
        But only if:
            -Attribute name exist in PKG_DIST_ATTRS
            -not exist
        """
        for attr_name in PKG_DIST_ATTRS:
            dist_value = getattr(self.pkg_dist, attr_name)
            dist_value = unicode(dist_value, encoding="utf-8", errors="replace")
            existing_value = dict.get(self, attr_name, None)
            if not existing_value:
                dict.__setitem__(self, attr_name, dist_value)
            elif DEBUG:
                print "*** Do not overwrite PKG_DIST_ATTRS %r:" % attr_name
                print "static: %r" % existing_value
                print "dist. value: %r" % dist_value

    def _fill_with_pkg_info(self):
        """
        Add package informations from PKG-INFO
        but only if:
            -key is in PKG_INFO_KEYS
            -not exist

        FIXME: How can we get PKG-INFO as a dict and not via get_metadata_lines?
        """
        try:
            metadata_lines = self.pkg_dist.get_metadata_lines("PKG-INFO")
        except IOError, err:
            if DEBUG:
                print "Can't get PKG-INFO:", err
            return

        for line in metadata_lines:
            if ":" not in line:
                continue

            line = unicode(line, encoding="utf-8", errors="replace")
            key, pkg_info_value = line.split(":", 1)

            if key not in PKG_INFO_KEYS:
                if DEBUG > 1:
                    print "Skip PKG-INFO %r (not in PKG_INFO_KEYS)" % key
                continue

            dict_key = key.lower().replace("-", "_")
            if DEBUG > 1 and key != dict_key:
                print "convert %r to %r" % (key, dict_key)

            pkg_info_value = pkg_info_value.strip()

            if dict.__contains__(self, dict_key):
                if DEBUG:
                    print "*** Do not overwrite PKG-INFO %r:" % dict_key
                    print "static: %r" % dict.__getitem__(self, dict_key)
                    print "PKG-INFO: %r" % pkg_info_value
                continue

            dict.__setitem__(self, dict_key, pkg_info_value)

    def _add_vcs_reversion(self):
        """ Add subversion/git reversion number to version string, if exist """

        if "SVN" in self["version"] or "git" in self["version"]:
            return

        location = dict.get(self, "location")

        svn_dir = os.path.join(location, ".svn")
        if os.path.isdir(svn_dir):
            svn_revision = get_svn_revision(location)
            if svn_revision != "SVN-unknown":
                self["version"] += " - SVN revision: %s" % svn_revision
            return

        git_dir = os.path.join(location, ".git")
        if os.path.isdir(git_dir):
            commit_info = self.get_commit_info(location)
            if commit_info:
                self["version"] += " - Last git commit: %s" % commit_info

    def get_commit_info(self, path):
        # %ct: committer date, UNIX timestamp
        cmd = ["/usr/bin/git", "log", "--pretty=format:%ct", "-1", "HEAD"]
        try:
            process = subprocess.Popen(cmd, shell=False, cwd=path,
                stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            )
        except Exception:
            if settings.DEBUG:
                # insert more information into the traceback and re-raise the original error
                etype, evalue, etb = sys.exc_info()
                evalue = etype(
                    'subprocess error, running %r: %s)' % (
                        " ".join(cmd), evalue
                    )
                )
                raise etype, evalue, etb
            return

        process.wait()
        returncode = process.returncode
        output = process.stdout.read().strip()
        error = process.stderr.read().strip()
        if returncode != 0:
            if settings.DEBUG:
                raise RuntimeError(
                    "Can't get git hash, returncode was: %r"
                    " - git stdout: %r"
                    " - git stderr: %r"
                    % (returncode, output, error)
                )
            return

        try:
            timestamp = int(output)
        except Exception:
            if settings.DEBUG:
                # insert more information into the traceback and re-raise the original error
                etype, evalue, etb = sys.exc_info()
                evalue = etype(
                    'git stdout: %r - git stderr: %r - (Original error: %s)' % (
                        output, error, evalue
                    )
                )
                raise etype, evalue, etb
            return

        try:
            return time.strftime("%d.%m.%Y", time.gmtime(timestamp))
        except Exception:
            if settings.DEBUG:
                # insert more information into the traceback and re-raise the original error
                etype, evalue, etb = sys.exc_info()
                evalue = etype(
                    "Can't convert %s: %s" % (
                        repr(timestamp), evalue
                    )
                )
                raise etype, evalue, etb
            return


class EnvironmetInfo(dict):
    " dict with all packages information "
    def __init__(self, static_pkg_info):
        pkg_env = pkg_resources.Environment()

        # fill all informations for all packages
        for pkg_key in pkg_env:
            pkg_dist = pkg_env[pkg_key][0]

            defaults = static_pkg_info.get(pkg_key, None)
            if defaults is None:
                defaults = {"is_relevant": False}
            else:
                defaults["is_relevant"] = True

            dict.__setitem__(self, pkg_key, PackageInfo(pkg_dist, defaults))

    def existing_keys(self):
        """ returns a list of all existing package info keys """
        existing_keys = set()
        for pkg_info_dict in package_info.values():
            keys = pkg_info_dict.keys()
            existing_keys = existing_keys.union(set(keys))
        return list(existing_keys)


package_info = EnvironmetInfo(STATIC_PKG_INFO)


@render_to("package_info/packages_table.html")
def lucidTag(request, all_packages=False, display_version=False, display_location=False, debug=False):
    """
    List all used Python modules with there version number.

    all_packages: True, False (default)
        Display all existing packages in the current environment?
        Normally, only the relevant packets are displayed.

    display_version: True, False (default)
        Add the version string to every packages?

    display_location: True, False (default)
        Display the absolute filesystem location of the package.

    debug: True, False (default)
        -List all existing package template keys: Needfull if you overwrite the template.

    Note: Display version and location is not good for security.

    example:
        {% lucidTag package_info %}
        {% lucidTag package_info all_packages=True %}
        {% lucidTag package_info display_version=True %}
        {% lucidTag package_info display_location=True %}
        {% lucidTag package_info debug=True %}
    """
    package_info_list = package_info.values()
    package_info_list.sort(
        cmp=lambda x, y: cmp(x["project_name"].lower(), y["project_name"].lower())
    )

    context = {
        "package_info_list": package_info_list,
        "all_packages": all_packages,
        "display_version": display_version,
        "display_location": display_location,
    }

    if debug and (settings.DEBUG or request.user.is_staff):
        messages.info(request, "Debug existing package template keys:")
        existing_keys = package_info.existing_keys()
        for key in sorted(existing_keys):
            messages.info(request, mark_safe(
                "<i>entry</i><strong>.%s</strong>" % key
            ))


    return context


if __name__ == "__main__":
    from pprint import pprint

    print package_info.existing_keys()
    pprint(package_info)


########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from pylucid_project.apps.pylucid.markup.views import markup_preview

from admin_views.bulk_editor import bulk_editor
from admin_views.edit_page import edit_page
from admin_views.convert_markup import convert_markup
from admin_views.new_content_page import new_content_page
from admin_views.new_plugin_page import new_plugin_page
from admin_views.page_order import page_order
from admin_views.tag_list import tag_list
from admin_views.page_list import page_list
from admin_views.markup_help import markup_help
from admin_views.translate_page import translate_page


urlpatterns = patterns('',
    url(r'^new_content_page/$', new_content_page, name='PageAdmin-new_content_page'),
    url(r'^new_content_page/preview/$', markup_preview, name='PageAdmin-markup_preview'),

    url(r'^edit_page/(?P<pagetree_id>\d+?)/$', edit_page, name='PageAdmin-edit_page'),
    url(r'^edit_page/\d+?/preview/$', markup_preview, name='PageAdmin-edit_page_markup_preview'),

    url(r'^translate/(?P<pagemeta_id>\d+?)/$', translate_page, name='PageAdmin-translate'),
    url(r'^translate/\d+?/preview/$', markup_preview, name='PageAdmin-translate_markup_preview'),

    url(r'^new_plugin_page/$', new_plugin_page, name='PageAdmin-new_plugin_page'),
    url(r'^convert_markup/(?P<pagecontent_id>\d+?)/$', convert_markup, name='PageAdmin-convert_markup'),
    url(r'^page_order/(?P<pagetree_id>\d+?)/$', page_order, name='PageAdmin-page_order'),
    url(r'^tag_list/$', tag_list, name='PageAdmin-tag_list'),
    url(r'^page_list/$', page_list, name='PageAdmin-page_list'),
    url(r'^markup_help/$', markup_help, name='PageAdmin-markup_help'),
    url(r'^bulk_editor/$', bulk_editor, name='PageAdmin-bulk_editor'),
)

########NEW FILE########
__FILENAME__ = bulk_editor
# coding: utf-8

from django import http
from django.conf import settings
from django.contrib import messages
from django.db import transaction
from django.forms.models import modelformset_factory
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to

from page_admin.forms import MassesEditorSelectForm


@render_to("page_admin/bulk_editor.html")
@check_permissions(superuser_only=True)
def bulk_editor(request):
    """ Edit one attribute for all model items at once. """
    title = "Bulk Editor"
    context = {
        "form_url": request.path,
        "abort_url": request.path,
    }
    if request.method == 'POST': # Stage 1: MassesEditorSelectForm was send
        #messages.info(request, request.POST)
        form = MassesEditorSelectForm(request.POST)
        if form.is_valid():
            #messages.info(request, form.cleaned_data)
            model_attr = form.cleaned_data["model_attr"]
            model, filter_lang, attr = model_attr
            language = form.cleaned_data["language"]

            queryset = model.on_site.all()

            # We can't use .only() here. Otherwise a tagging TagField() would not updated correctly
            # See also: http://www.python-forum.de/post-154432.html#154432 (de)
            #queryset = queryset.only(attr)

            if filter_lang:
                queryset = queryset.filter(language=language)

            ModelFormset = modelformset_factory(model=model, extra=0, fields=(attr,))

            if "form-TOTAL_FORMS" in request.POST: # Stage 2: The ModelFormset POST data exist
                formset = ModelFormset(request.POST, queryset=queryset)
                if formset.is_valid():
                    sid = transaction.savepoint()
                    try:
                        instances = formset.save(commit=False)
                        formset.save_m2m()
                        formset.save()
                    except:
                        transaction.savepoint_rollback(sid)
                        raise
                    else:
                        transaction.savepoint_commit(sid)

                    if not instances:
                        messages.info(request, _("No items changed."))
                    else:
                        try:
                            id_list = ", ".join([str(int(item.pk)) for item in instances])
                        except ValueError: # No number as primary key?
                            id_list = ", ".join([repr(item.pk) for item in instances])

                        messages.info(request, _("%(count)s items saved (IDs: %(ids)s)") % {
                            "count": len(instances), "ids": id_list
                        })
                        if settings.DEBUG:
                            messages.info(request, "Debug saved items:")
                            for instance in instances:
                                messages.info(request, instance.get_absolute_url(), instance)
                                #messages.info(request, "saved value: %r" % getattr(instance, attr))

                    return http.HttpResponseRedirect(request.path)
            else:
                formset = ModelFormset(queryset=queryset)

            context["formset"] = formset
            context["model_name"] = model.__name__
            context["attr"] = attr
            context["filter_lang"] = filter_lang
            context["language"] = language
            title += " - %s.%s (%s)" % (model.__name__, attr, language)

            # Change all field label to the absolute url
            for formset_form in formset.forms:
                instance = formset_form.instance
                absolute_url = instance.get_absolute_url()
                for field_name, field in formset_form.fields.iteritems():
                    field.label = absolute_url

            # Sort by absolute_url, used the label value from the first field 
            formset.forms.sort(
                cmp=lambda x, y: cmp(x.fields.values()[0].label.lower(), y.fields.values()[0].label.lower())
            )

            # Hide the MassesEditorSelectForm fields. They should not changed, yet.
            form.hide_all_fields()
    else:
        form = MassesEditorSelectForm()

    context["form"] = form
    context["title"] = title
    return context

########NEW FILE########
__FILENAME__ = convert_markup
# coding: utf-8

"""
    Convert PageContent markup.
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


from django import http
from django.conf import settings
from django.contrib import messages
from django.db import transaction
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.markup import converter, MARKUP_DICT
from pylucid_project.apps.pylucid.markup import hightlighter
from pylucid_project.apps.pylucid.models import PageContent

from page_admin.forms import ConvertMarkupForm


@check_permissions(superuser_only=False, permissions=("pylucid.change_pagecontent",))
@render_to("page_admin/convert_markup.html")
def convert_markup(request, pagecontent_id=None):
    """
    convert a PageContent markup
    """
    if not pagecontent_id:
        raise

    def _error(pagecontent_id, err):
        err_msg = _("Wrong PageContent ID.")
        if settings.DEBUG:
            err_msg += " (ID: %r, original error was: %r)" % (pagecontent_id, err)
        messages.error(request, err_msg)

    try:
        pagecontent_id = int(pagecontent_id)
    except Exception, err:
        return _error(pagecontent_id, err)

    try:
        pagecontent = PageContent.objects.get(id=pagecontent_id)
    except PageContent.DoesNotExist, err:
        return _error(pagecontent_id, err)

    absolute_url = pagecontent.get_absolute_url()
    context = {
        "title": _("Convert '%s' markup") % pagecontent.get_name(),
        "form_url": request.path,
        "abort_url": absolute_url,
        "current_markup": MARKUP_DICT[pagecontent.markup],
        "pagecontent": pagecontent,
    }

    if request.method != "POST":
        form = ConvertMarkupForm(instance=pagecontent)
    else:
        form = ConvertMarkupForm(request.POST, instance=pagecontent)
        #messages.info(request, request.POST)
        if form.is_valid():
            cleaned_data = form.cleaned_data
            dest_markup_no = int(cleaned_data["dest_markup"])
            original_markup = cleaned_data["content"]
            try:
                new_markup = converter.convert_markup(
                    original_markup,
                    source_markup_no=pagecontent.markup,
                    dest_markup_no=dest_markup_no,
                    request=request
                )
            except Exception, err:
                messages.error(request, "Convert error: %s" % err)
            else:
                if "preview" not in request.POST:
                    # Save converted markup and redirect to the updated page
                    sid = transaction.savepoint()
                    try:
                        pagecontent.content = new_markup
                        pagecontent.markup = dest_markup_no
                        pagecontent.save()
                    except:
                        transaction.savepoint_rollback(sid)
                        raise
                    else:
                        transaction.savepoint_commit(sid)
                        messages.info(request, _("Content page %r updated.") % pagecontent)
                        return http.HttpResponseRedirect(pagecontent.get_absolute_url())

                # preview markup convert:

                context["new_markup"] = new_markup

                converted_html = converter.apply_markup(
                    new_markup, dest_markup_no, request, escape_django_tags=True
                )
                context["converted_html"] = converted_html

                if cleaned_data["verbose"]:
                    context["original_markup"] = original_markup

                    orig_html = converter.apply_markup(
                        original_markup, pagecontent.markup, request, escape_django_tags=True
                    )
                    context["orig_html"] = orig_html

                    def strip_whitespace(html):
                        return "\n".join([line.strip() for line in html.splitlines() if line.strip()])

                    # Remove whitespace from html code.
                    orig_html2 = strip_whitespace(orig_html)
                    converted_html2 = strip_whitespace(converted_html)

                    if orig_html2 == converted_html2:
                        context["diff_is_the_same"] = True
                    else:
                        context["pygmentize_diff"] = hightlighter.get_pygmentize_diff(orig_html2, converted_html2)

    context.update({
        "form": form,
    })
    return context

########NEW FILE########
__FILENAME__ = edit_page
# coding:utf-8

"""
    edit a content/plugin page
    ~~~~~~~~~~~~~~~~~~~
    
    Edit a content page:
        form with: PageTree, PageMeta and PageContent at once.
        
    Edit a plugin page:
        form with: PageTree, PageMeta and PluginPage at once.    
    
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django import http
from django.conf import settings
from django.contrib import messages
from django.db import transaction
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import PageTree, PageMeta, PageContent, Language, PluginPage

from page_admin.forms import PageTreeForm, PageMetaForm, PageContentForm, PluginPageForm
from django.shortcuts import get_object_or_404


@check_permissions(superuser_only=False, permissions=("pylucid.change_pagecontent",))
def _edit_content_page(request, context, pagetree):
    """ edit a PageContent """
    default_lang_entry = Language.objects.get_or_create_default(request)
    pagemeta = PageTree.objects.get_pagemeta(request, pagetree, show_lang_errors=True)
    pagecontent = PageContent.objects.get(pagemeta=pagemeta)

    if request.method != "POST":
        pagetree_form = PageTreeForm(instance=pagetree)
        pagemeta_form = PageMetaForm(instance=pagemeta, prefix=default_lang_entry.code)
        pagecontent_form = PageContentForm(instance=pagecontent)
    else:
        if "cancel" in request.POST:
            url = pagecontent.get_absolute_url()
            messages.info(request, _("Edit content page (%s) aborted, ok.") % url)
            return http.HttpResponseRedirect(url)

        pagetree_form = PageTreeForm(request.POST, instance=pagetree)
        pagemeta_form = PageMetaForm(request.POST, instance=pagemeta, prefix=default_lang_entry.code)
        pagecontent_form = PageContentForm(request.POST, instance=pagecontent)
        if not (pagetree_form.is_valid() and pagemeta_form.is_valid() and pagecontent_form.is_valid()):
            context["has_errors"] = True
        else:
            # All forms are valid -> Save all.
            sid = transaction.savepoint()
            try:
                pagetree_form.save()
                pagemeta_form.save()
                pagecontent_form.save()
            except:
                transaction.savepoint_rollback(sid)
                raise
            else:
                transaction.savepoint_commit(sid)
                messages.info(request, _("Content page %r updated.") % pagecontent)
                return http.HttpResponseRedirect(pagecontent.get_absolute_url())

    # A list of all existing forms -> for form errorlist
    all_forms = [pagecontent_form, pagemeta_form, pagetree_form]

    context.update({
        "title": _("Edit a content page"),
        "template_name": "page_admin/edit_content_page.html",
        "default_lang_entry": default_lang_entry,
        "pagecontent": pagecontent,

        "markup_id_str": str(pagecontent.markup),

        "all_forms": all_forms, # For display the form error list from all existing forms.

        "pagetree_form": pagetree_form,
        "pagemeta_form":pagemeta_form,
        "pagecontent_form": pagecontent_form,
    })
    return context


@check_permissions(superuser_only=False, permissions=("pylucid.change_pluginpage",))
def _edit_plugin_page(request, context, pagetree):
    """ edit a PluginPage entry with PageMeta in all Languages """

    pagemetas = PageMeta.objects.filter(pagetree=pagetree)
    pluginpage = PluginPage.objects.get(pagetree=pagetree)

    if request.method == "POST" and "cancel" in request.POST:
        url = pluginpage.get_absolute_url()
        messages.info(request, _("Edit plugin page (%s) aborted, ok.") % url)
        return http.HttpResponseRedirect(url)

    # Create for every language a own PageMeta model form.
    pagemeta_formset = []
    pagemeta_is_valid = True # Needed for check if all forms are valid.
    for pagemeta in pagemetas:
        if request.method == "POST":
            form = PageMetaForm(request.POST, prefix=pagemeta.language.code, instance=pagemeta)
            if not form.is_valid():
                pagemeta_is_valid = False
        else:
            form = PageMetaForm(prefix=pagemeta.language.code, instance=pagemeta)
        form.language = pagemeta.language # for language info in fieldset legend
        pagemeta_formset.append(form)

    if request.method == "POST":
        pagetree_form = PageTreeForm(request.POST, instance=pagetree)
        pluginpage_form = PluginPageForm(request.POST, instance=pluginpage)
        if pagemeta_is_valid and pagetree_form.is_valid() and pluginpage_form.is_valid():
            sid = transaction.savepoint()
            try:
                pagetree_form.save()
                pluginpage_form.save()

                # Save all PageMeta entries and attach them to PluginPage
                new_pluginpage_instance = []
                for pagemeta_form in pagemeta_formset:
                    pagemeta_form.save()
            except:
                transaction.savepoint_rollback(sid)
                raise
            else:
                transaction.savepoint_commit(sid)
                messages.info(request, _("Plugin page %r updated.") % pluginpage)
                return http.HttpResponseRedirect(pluginpage.get_absolute_url())
    else:
        pagetree_form = PageTreeForm(instance=pagetree)
        pluginpage_form = PluginPageForm(instance=pluginpage)

    # A list of all existing forms -> for form errorlist
    all_forms = pagemeta_formset[:] + [pluginpage_form, pagetree_form]

    context = {
        "title": _("Edit a plugin page"),
        "template_name": "page_admin/edit_plugin_page.html",

        "all_forms": all_forms, # For display the form error list from all existing forms.
        "has_errors": request.method == "POST", # At least one form has errors.
        # The forms:
        "pluginpage_form": pluginpage_form,
        "pagetree_form": pagetree_form,
        "pagemeta_formset": pagemeta_formset,
    }
    return context


@check_permissions(superuser_only=False, permissions=("pylucid.change_pagetree", "pylucid.change_pagemeta"))
@render_to()
def edit_page(request, pagetree_id=None):
    """
    edit a PageContent or a PluginPage.
    """
    pagetree = get_object_or_404(PageTree, id=pagetree_id)
    context = {"form_url": request.path}

    is_pluginpage = pagetree.page_type == PageTree.PLUGIN_TYPE
    if is_pluginpage:
        return _edit_plugin_page(request, context, pagetree)
    else:
        return _edit_content_page(request, context, pagetree)

########NEW FILE########
__FILENAME__ = markup_help
# coding:utf-8

"""
    PyLucid tag list
    ~~~~~~~~~~~~~~~~

    List all available lucidTag
    
    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to

from pylucid_project.apps.pylucid.markup import MARKUP_SHORT_DICT

from page_admin.forms import SelectMarkupForm


@render_to()
@check_permissions(superuser_only=False, permissions=('pylucid.change_pagecontent',))
def markup_help(request):
    """ Display a help page for a markup given via GET parameter """

    # Fallback: Use 'markup_help_base.html' template, if markup_id is wrong
    short_markup_name = "base"

    if request.method == 'GET':
        form = SelectMarkupForm(request.GET)
        if form.is_valid():
            markup_id = form.cleaned_data["markup_id"]
            short_markup_name = MARKUP_SHORT_DICT[markup_id]
    else:
        form = SelectMarkupForm()

    template_name = "page_admin/markup_help_%s.html" % short_markup_name

    context = {
        "template_name": template_name,
        "form_url": request.path,
        "form": form,
        "title": "%s markup help" % short_markup_name,
    }
    return context



########NEW FILE########
__FILENAME__ = new_content_page
# coding: utf-8

"""
    Create a new content page.
"""

from django import http
from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.db import transaction
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.models import PageTree, Language
from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.markup.converter import apply_markup

from page_admin.admin_views import _get_pagetree, _build_form_initial
from page_admin.forms import PageTreeForm, PageMetaForm, PageContentForm


@check_permissions(superuser_only=False,
    permissions=("pylucid.add_pagecontent", "pylucid.add_pagemeta", "pylucid.add_pagetree")
)
@render_to("page_admin/edit_content_page.html")#, debug=True)
def new_content_page(request):
    """
    Create a new content page.
    
    TODO:
        * setup design via ajax, if not set and a parent page tree was selected
        * Auto generate slug from page name with javascript
    
    can use django.forms.models.inlineformset_factory:
        PageFormSet = inlineformset_factory(PageTree, PageContent, PageMeta)
    get:
        metaclass conflict: the metaclass of a derived class must be a (non-strict) subclass of
        the metaclasses of all its bases
    see also: http://code.djangoproject.com/ticket/7837
    """
    default_lang_entry = Language.objects.get_or_create_default(request)
    context = {
        "title": _("Create a new page"),
        "default_lang_entry": default_lang_entry,
        "form_url": request.path,
        "abort_url": reverse("admin:index"),
        "has_errors": request.method == "POST", # At least one form has errors.
    }

    if request.method == "POST":
        pagetree_form = PageTreeForm(request.POST)
        pagemeta_form = PageMetaForm(request.POST, prefix=default_lang_entry.code)
        pagecontent_form = PageContentForm(request.POST)
        if pagetree_form.is_valid() and pagemeta_form.is_valid() and pagecontent_form.is_valid():
            sid = transaction.savepoint()
            try:
                # Create new PageTree entry
                new_pagetree = pagetree_form.save(commit=False)
                new_pagetree.page_type = PageTree.PAGE_TYPE
                new_pagetree.save()

                # Create new PageMeta entry
                new_pagemeta = pagemeta_form.save(commit=False)
                new_pagemeta.pagetree = new_pagetree
                new_pagemeta.language = default_lang_entry
                new_pagemeta.save()

                # Create new PageContent entry
                new_pagecontent = pagecontent_form.save(commit=False)
                new_pagecontent.pagemeta = new_pagemeta
                new_pagecontent.save()
            except:
                transaction.savepoint_rollback(sid)
                raise
            else:
                transaction.savepoint_commit(sid)
                url = new_pagecontent.get_absolute_url()
                messages.info(request, _("New content page %r created.") % url)
                return http.HttpResponseRedirect(url)
    else:
        parent_pagetree = _get_pagetree(request)
        if parent_pagetree:
            context["abort_url"] = parent_pagetree.get_absolute_url() # Go back to the cms page
            initial_data = _build_form_initial(request, parent_pagetree)
        else:
            initial_data = {}
        pagetree_form = PageTreeForm(initial=initial_data)
        pagemeta_form = PageMetaForm(prefix=default_lang_entry.code)
        pagecontent_form = PageContentForm()

    # A list of all existing forms -> for form errorlist
    all_forms = [pagecontent_form, pagemeta_form, pagetree_form]

    context.update({
        "all_forms": all_forms, # For display the form error list from all existing forms.

        "pagetree_form": pagetree_form,
        "pagemeta_form":pagemeta_form,
        "pagecontent_form": pagecontent_form,

        "pagelinklist_url": "#TODO",
    })
    return context


########NEW FILE########
__FILENAME__ = new_plugin_page
# coding:utf-8

from django import http
from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.db import transaction
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.models import PageTree, Language
from pylucid_project.apps.pylucid.decorators import check_permissions, render_to

from page_admin.admin_views import _get_pagetree, _build_form_initial
from page_admin.forms import PageTreeForm, PageMetaForm, PluginPageForm


@check_permissions(superuser_only=False,
    permissions=("pylucid.add_pluginpage", "pylucid.add_pagemeta", "pylucid.add_pagetree")
)
@render_to("page_admin/edit_plugin_page.html")
def new_plugin_page(request):
    """
    Create a new plugin page.
    Create PageMeta in all existing languages.
    """
    context = {
        "title": _("Create a new plugin page"),
        "form_url": request.path,
        "abort_url": reverse("admin:index"),
    }

    languages = Language.objects.all()

    # Create for every language a own PageMeta model form.
    pagemeta_formset = []
    pagemeta_is_valid = True # Needed for check if all forms are valid.
    for lang in languages:
        if request.method == "POST":
            form = PageMetaForm(request.POST, prefix=lang.code)
            if not form.is_valid():
                pagemeta_is_valid = False
        else:
            form = PageMetaForm(prefix=lang.code)
        form.language = lang # for language info in fieldset legend
        pagemeta_formset.append(form)

    if request.method == "POST":
        pagetree_form = PageTreeForm(request.POST)
        pluginpage_form = PluginPageForm(request.POST)
        if pagemeta_is_valid and pagetree_form.is_valid() and pluginpage_form.is_valid():
            sid = transaction.savepoint()
            try:
                # Create new PageTree entry
                new_pagetree = pagetree_form.save(commit=False)
                new_pagetree.page_type = PageTree.PLUGIN_TYPE
                new_pagetree.save()

                # Create new PluginPage entry
                new_pluginpage = pluginpage_form.save(commit=False)
                new_pluginpage.pagetree = new_pagetree
                new_pluginpage.save() # needs primary key before a many-to-many relationship can be used.

                # Create all PageMeta entries and attach them to PluginPage
                new_pluginpage_instance = []
                for language, pagemeta_form in zip(languages, pagemeta_formset):
                    new_pagemeta = pagemeta_form.save(commit=False)
                    new_pagemeta.pagetree = new_pagetree
                    new_pagemeta.language = language
                    new_pagemeta.save()

            except:
                transaction.savepoint_rollback(sid)
                raise
            else:
                transaction.savepoint_commit(sid)
                messages.info(request, _("New plugin page %r created.") % new_pluginpage)
                return http.HttpResponseRedirect(new_pluginpage.get_absolute_url())
    else:
        parent_pagetree = _get_pagetree(request)
        if parent_pagetree:
            context["abort_url"] = parent_pagetree.get_absolute_url() # Go back to the cms page
            initial_data = _build_form_initial(request, parent_pagetree)
        else:
            initial_data = {}
        pagetree_form = PageTreeForm(initial=initial_data)
        pluginpage_form = PluginPageForm()

    # A list of all existing forms -> for form errorlist
    all_forms = pagemeta_formset[:] + [pluginpage_form, pagetree_form]

    context.update({
        "all_forms": all_forms, # For display the form error list from all existing forms.
        "has_errors": request.method == "POST", # At least one form has errors.
        # The forms:
        "pluginpage_form": pluginpage_form,
        "pagetree_form": pagetree_form,
        "pagemeta_formset": pagemeta_formset,
    })
    return context

########NEW FILE########
__FILENAME__ = page_list
# coding:utf-8

"""
    PyLucid tag list
    ~~~~~~~~~~~~~~~~

    List all available lucidTag
"""

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import PageTree

from page_admin.forms import SelectMarkupForm




@render_to("page_admin/page_list_popup.html")
@check_permissions(superuser_only=False, permissions=('pylucid.change_pagecontent',))
def page_list(request):
    """ Create a list of all existing lucidTag plugin views. """

    user = request.user
    tree = PageTree.objects.get_tree(user,
        filter_showlinks=False, exclude_plugin_pages=False)

    # add all PageMeta objects into tree
    tree.add_pagemeta(request)

    markup_id = None

    if request.method == 'GET':
        form = SelectMarkupForm(request.GET)
        if form.is_valid():
            markup_id = form.cleaned_data["markup_id"]
    else:
        form = SelectMarkupForm()

    context = {
        "title": "page list",
        "form": form,
        "form_url": request.path,
        "markup_id": markup_id,
        "tree": tree,
    }
    return context



########NEW FILE########
__FILENAME__ = page_order
# coding: utf-8

from django import http
from django.conf import settings
from django.contrib import messages
from django.db import transaction
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.models import PageTree
from pylucid_project.apps.pylucid.decorators import check_permissions, render_to

from page_admin.forms import PageOrderFormSet



@check_permissions(superuser_only=False, permissions=("pylucid.change_pagetree",))
@render_to("page_admin/page_order.html")
def page_order(request, pagetree_id=None):
    """
    Change PageTree 'position', the ordering weight for sorting the pages in the menu.
    """
    try:
        pagetree = PageTree.on_site.get(id=pagetree_id)
    except PageTree.DoesNotExist, err:
        raise PageTree.DoesNotExist(
            "PageTree with ID %r doesn't exist. (Original error: %s)" % (pagetree_id, err)
        )
    parent = pagetree.parent

    queryset = PageTree.on_site.all().order_by("position")
    queryset = queryset.filter(parent=parent)

    if request.method == 'POST':
        formset = PageOrderFormSet(request.POST, queryset=queryset)
        if formset.is_valid():
            sid = transaction.savepoint()
            try:
                formset.save()
            except:
                transaction.savepoint_rollback(sid)
                raise
            transaction.savepoint_commit(sid)
            messages.info(request, "New position saved.")
            return http.HttpResponseRedirect(request.path)
    else:
        formset = PageOrderFormSet(queryset=queryset)

    # Change field label ("position") to PageTree.slug
    for form in formset.forms:
        for field_name, field in form.fields.iteritems():
            field.label = form.instance.slug
            field.help_text = form.instance.get_absolute_url()

    context = {
        "title": "Change the page order.",
        "pagetree": pagetree,
        "abort_url": pagetree.get_absolute_url(),
        "form_url": request.path,
        "formset": formset,
    }
    if parent is not None:
        context["previous_level"] = parent

    try:
        context["next_level"] = PageTree.on_site.order_by("position").filter(parent=pagetree)[0]
    except IndexError:
        pass

    return context


########NEW FILE########
__FILENAME__ = tag_list
# coding:utf-8

"""
    PyLucid tag list
    ~~~~~~~~~~~~~~~~
    
    List all available lucidTag
    
    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import inspect

from django.conf import settings
from django.contrib import messages
from django.template import RequestContext
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.markup.django_tags import DjangoTagAssembler
from pylucid_project.apps.pylucid.models import PageTree
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS
from pylucid_project.utils.escape import escape
from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid.markup import MARKUP_CREOLE


@render_to("page_admin/tag_list_popup.html")
@check_permissions(superuser_only=False,
    permissions=('pylucid.change_pagecontent', 'pylucid.change_pagemeta')
)
def tag_list(request):
    """ Create a list of all existing lucidTag plugin views. """
    lucid_tags = []
    for plugin_name, plugin_instance in PYLUCID_PLUGINS.iteritems():
        try:
            lucidtag_view = plugin_instance.get_plugin_object(
                mod_name="views", obj_name="lucidTag"
            )
        except plugin_instance.ObjectNotFound, err:
            continue
        except Exception, err:
            if settings.DEBUG:
                raise
            messages.error(request, "Can't get plugin view: %s" % err)
            continue

        doc = None
        examples = None
        fallback_example = None

        if lucidtag_view.__name__ == "wrapper":
            messages.info(request,
                _("Info: lucidTag %s used a decorator without functools.wraps!") % plugin_name
            )
        else:
            lucidtag_doc = inspect.getdoc(lucidtag_view)
            if lucidtag_doc: # Cutout lucidTag examples from DocString
                assembler = DjangoTagAssembler()
                cut_data = assembler.cut_out(lucidtag_doc)[1]
                examples = cut_data

                for example in examples:
                    if not (
                        example.startswith("{%% lucidTag %s " % plugin_name) or \
                        example.startswith("{%% lucidTag %s." % plugin_name)
                        ):
                        messages.info(request,
                            _("Info: lucidTag %(plugin_name)s has wrong tag example: %(example)r") % {
                                "plugin_name": plugin_name, "example": example
                            }
                        )

                examples = [escape(example) for example in examples]

                lucidtag_doc = lucidtag_doc.split("example:", 1)[0].strip()

            lucidtag_doc = unicode(lucidtag_doc)
            doc = apply_markup(lucidtag_doc,
                markup_no=MARKUP_CREOLE, request=request,
                escape_django_tags=True
            )

        if not examples:
            # No DocString or it contains no examples -> generate a example
            fallback_example = escape("{%% lucidTag %s %%}" % plugin_name)

        lucid_tags.append({
            "plugin_name": plugin_name.replace("_", " "),
            "fallback_example": fallback_example,
            "examples": examples,
            "doc": doc,
        })

    # Sort by plugin name case-insensitive
    lucid_tags.sort(cmp=lambda x, y: cmp(x["plugin_name"].lower(), y["plugin_name"].lower()))


    # Add PageTree and PageMeta instance to request.PYLUCID for get
    # context keys witch are related to these objects.
    # see pylucid_project.apps.pylucid.context_processors
    old_pylucid_obj = request.PYLUCID

    pagetree = PageTree.objects.get_root_page(request.user)
    pagemeta = PageTree.objects.get_pagemeta(request, pagetree, show_lang_errors=False)
    request.PYLUCID.pagetree = pagetree
    request.PYLUCID.pagemeta = pagemeta

    request_context = RequestContext(request)

    request.PYLUCID = old_pylucid_obj

    # Collect all existing tags from all context dicts
    request_context_dicts = request_context.dicts
    context_keys = set()
    for d in request_context_dicts:
        context_keys.update(set(d.keys()))

    context_keys = list(context_keys)
    context_keys.sort(cmp=lambda x, y: cmp(x.lower(), y.lower()))

    context = {
        "title": "lucidTag list",
        "context_keys": context_keys,
        "lucid_tags": lucid_tags
    }
    return context



########NEW FILE########
__FILENAME__ = translate_page
# coding:utf-8

"""
    translate a PageContent
    ~~~~~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django import http
from django.conf import settings
from django.contrib import messages
from django.db import transaction
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.i18n.utils.translate import translate, prefill
from pylucid_project.apps.i18n.views import select_language
from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import PageTree, PageMeta, PageContent, Language

from page_admin.forms import PageMetaForm, PageContentForm


@check_permissions(superuser_only=False, permissions=(
    "pylucid.add_pagecontent", "pylucid.add_pagemeta",
    "pylucid.change_pagecontent", "pylucid.change_pagemeta",
))
@render_to()
def translate_page(request, pagemeta_id=None):
    if not pagemeta_id:
        raise

    source_pagemeta = PageMeta.objects.get(id=pagemeta_id)
    pagetree = source_pagemeta.pagetree
    source_language = source_pagemeta.language
    cancel_url = source_pagemeta.get_absolute_url()

    if request.method == "POST" and "cancel" in request.POST:
        messages.info(request, _("Translate page (%s) aborted, ok.") % cancel_url)
        return http.HttpResponseRedirect(cancel_url)

    is_pluginpage = pagetree.page_type == PageTree.PLUGIN_TYPE
    if is_pluginpage:
        messages.error(request, "TODO: Translate a plugin page!")
        return http.HttpResponseRedirect(source_pagemeta.get_absolute_url())
    else:
        source_pagecontent = PageContent.objects.get(pagemeta=source_pagemeta)


    # select the destination language
    result = select_language(request, cancel_url, source_pagemeta.language, source_pagemeta.name)
    if isinstance(result, Language):
        # Language was selected or they exit only one other language
        dest_language = result
    elif isinstance(result, dict):
        # template context returned -> render language select form
        return result
    elif isinstance(result, http.HttpResponse):
        # e.g. error
        return result
    else:
        raise RuntimeError() # Should never happen


    context = {
        "title": _("Translate page '%(name)s' (%(source_lang)s) into %(dest_lang)s.") % {
            "name": source_pagemeta.name,
            "source_lang": source_pagemeta.language.description,
            "dest_lang": dest_language.description,
        },
        "template_name": "page_admin/translate_page.html",
    }

    try:
        dest_pagemeta = PageMeta.objects.get(pagetree=pagetree, language=dest_language)
    except PageMeta.DoesNotExist:
        dest_pagemeta = None
    else:
        dest_pagecontent = PageContent.objects.get(pagemeta=dest_pagemeta)

    if request.method == "POST":
        source_pagemeta_form = PageMetaForm(
            request.POST, prefix="source", instance=source_pagemeta
        )
        source_pagecontent_form = PageContentForm(
            request.POST, prefix="source", instance=source_pagecontent
        )
        if dest_pagemeta is None:
            dest_pagemeta_form = PageMetaForm(request.POST, prefix="dest")
            dest_pagecontent_form = PageContentForm(request.POST, prefix="dest")
        else:
            dest_pagemeta_form = PageMetaForm(
                request.POST, prefix=dest_language.code, instance=dest_pagemeta
            )
            dest_pagecontent_form = PageContentForm(
                request.POST, prefix=dest_language.code, instance=dest_pagecontent
            )

        if "autotranslate" in request.POST:
            if source_pagemeta_form.is_valid() and source_pagecontent_form.is_valid():
                all_filled_fields = []
                all_errors = []

                # Translate PageContent
                dest_pagecontent_form, filled_fields, errors = prefill(
                    source_pagecontent_form, dest_pagecontent_form,
                    source_pagemeta.language, dest_language,
                    only_fields=("content",),
                    #debug=True,
                )
                all_filled_fields += filled_fields
                all_errors += errors

                # Translate fields from PageMeta
                dest_pagemeta_form, filled_fields, errors = prefill(
                    source_pagemeta_form, dest_pagemeta_form,
                    source_pagemeta.language, dest_language,
                    only_fields=("name", "title", "description"),
                    #debug=True,
                )
                all_filled_fields += filled_fields
                all_errors += errors


                if all_filled_fields:
                    messages.success(request, "These fields are translated with google: %s" % ", ".join(all_filled_fields))
                else:
                    messages.info(request, "No fields translated with google, because all fields have been a translation.")
                if all_errors:
                    for error in all_errors:
                        messages.error(request, error)
        else:
            # don't translate -> save if valid
            if (source_pagemeta_form.is_valid() and source_pagecontent_form.is_valid() and
                                dest_pagemeta_form.is_valid() and dest_pagecontent_form.is_valid()):
                # All forms are valid -> Save all.
                sid = transaction.savepoint()
                try:
                    source_pagecontent_form.save()
                    source_pagemeta_form.save()

                    # Create new PageMeta entry
                    new_pagemeta = dest_pagemeta_form.save(commit=False)
                    new_pagemeta.pagetree = pagetree
                    new_pagemeta.language = dest_language
                    new_pagemeta.save()

                    # Create new PageContent entry
                    new_pagecontent = dest_pagecontent_form.save(commit=False)
                    new_pagecontent.pagemeta = new_pagemeta
                    new_pagecontent.save()
                except:
                    transaction.savepoint_rollback(sid)
                    raise
                else:
                    transaction.savepoint_commit(sid)
                    if dest_pagemeta is None:
                        messages.success(request, "New content %r created." % new_pagecontent)
                    else:
                        messages.success(request, "All updated.")
                    return http.HttpResponseRedirect(new_pagemeta.get_absolute_url())
    else:
        source_pagemeta_form = PageMetaForm(
            prefix="source", instance=source_pagemeta
        )
        source_pagecontent_form = PageContentForm(
            prefix="source", instance=source_pagecontent
        )
        if dest_pagemeta is None:
            dest_pagemeta_form = PageMetaForm(
                prefix="dest", initial={
                    "robots": source_pagemeta.robots,
                    "permitViewGroup": source_pagemeta.permitViewGroup, # FIXME: Doesn't work
                }
            )
            dest_pagecontent_form = PageContentForm(
                prefix="dest", initial={
                    "markup": source_pagecontent.markup,
                }
            )
        else:
            dest_pagemeta_form = PageMetaForm(
                prefix=dest_language.code, instance=dest_pagemeta
            )
            dest_pagecontent_form = PageContentForm(
                prefix=dest_language.code, instance=dest_pagecontent
            )


    source_pagecontent_form.language = source_language
    dest_pagecontent_form.language = dest_language

    pagemeta_fields = []
    for source_field, dest_field in zip(source_pagemeta_form, dest_pagemeta_form):
        source_field.language = source_language
        pagemeta_fields.append(source_field)
        dest_field.language = dest_language
        pagemeta_fields.append(dest_field)

    all_forms = [
        source_pagemeta_form, source_pagecontent_form,
        dest_pagemeta_form, dest_pagecontent_form
    ]
    has_errors = False
    for form in all_forms:
        if form.errors:
            has_errors = True
            break

    context.update({
        "abort_url": source_pagemeta.get_absolute_url(),
        "all_forms": all_forms,
        "has_errors": has_errors,
        "source_pagemeta_form": source_pagemeta_form,
        "source_pagecontent_form": source_pagecontent_form,
        "dest_pagemeta_form": dest_pagemeta_form,
        "dest_pagecontent_form": dest_pagecontent_form,

        "pagemeta_fields": pagemeta_fields,
    })
    return context



########NEW FILE########
__FILENAME__ = forms
# coding:utf-8

from django import forms
from django.forms.models import modelformset_factory
from django.utils.translation import ugettext as _

from blog.models import BlogEntry
from lexicon.models import LexiconEntry
from update_journal.models import UpdateJournal
from pylucid_comments.models import PyLucidComment

from pylucid_project.apps.pylucid.markup import MARKUP_CHOICES, MARKUP_CREOLE, \
    MARKUP_HTML, MARKUP_HTML_EDITOR
from pylucid_project.apps.pylucid.models import PageTree, PageMeta, PageContent, PluginPage, \
                                                                            Design, Language
from pylucid_project.utils.escape import escape


class PageContentTextarea(forms.Textarea):
    def __init__(self):
        # The 'rows' and 'cols' attributes are required for HTML correctness.
        self.attrs = {'cols': '40', 'rows': '15'}

    def render(self, name, value, attrs=None):
        if value:
            value = escape(value)
        return super(PageContentTextarea, self).render(name, value, attrs)


class EditPageForm(forms.Form):
    """ Form for "quick inline" edit. """
    content = forms.CharField(widget=PageContentTextarea())


class PageTreeForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        """ Change form field data in a DRY way """
        super(PageTreeForm, self).__init__(*args, **kwargs)
        designs = Design.on_site.values_list("id", "name")
        self.fields['design'].choices = [("", "---------")] + list(designs)

        if self.instance:
            # Filter the own entry from parent choices list -> prevent parent-child loops
            exclude_extras = {"pk": self.instance.pk}
        else:
            exclude_extras = None

        self.fields["parent"].widget = forms.widgets.Select(
            choices=PageTree.objects.get_choices(exclude_extras=exclude_extras)
        )

    class Meta:
        model = PageTree
        exclude = ("page_type", "site")


class PageMetaForm(forms.ModelForm):
    class Meta:
        model = PageMeta
        exclude = ("pagetree", "language")


class PageContentForm(forms.ModelForm):
    class Meta:
        model = PageContent
        exclude = ("pagemeta",)

def _markup_choices(*id_filter):
    choices = [entry for entry in MARKUP_CHOICES if entry[0] in id_filter]
    return choices


class ConvertMarkupForm(forms.ModelForm):
    # Use only supported markups for converting choice field
    MARKUP_CHOICES2 = _markup_choices(
        MARKUP_CREOLE, MARKUP_HTML, MARKUP_HTML_EDITOR
    )
    dest_markup = forms.ChoiceField(
        choices=MARKUP_CHOICES2,
        help_text=_("convert the current page content to this new markup"),
    )
    verbose = forms.BooleanField(required=False,
        help_text=_("Display original html and a html diff."),
    )
    def clean_markup(self):
        return int(self.cleaned_data['markup'])
    class Meta:
        model = PageContent
        fields = ('content',)


class SelectMarkupForm(forms.Form):
    """ for page list admin view """
    markup_id = forms.ChoiceField(
        choices=MARKUP_CHOICES,
        help_text=_("switch to other markup format"),
    )
    def clean_markup_id(self):
        return int(self.cleaned_data['markup_id'])


class PluginPageForm(forms.ModelForm):
#    app_label = forms.TypedChoiceField(
#        choices=PluginPage.objects.get_app_choices(), label=_('App label'),
#        help_text=_('The app lable witch is in settings.INSTALLED_APPS')
#    )
    def __init__(self, *args, **kwargs):
        """ Change form field data in a DRY way """
        super(PluginPageForm, self).__init__(*args, **kwargs)
        self.fields["app_label"].widget = forms.widgets.Select(choices=PluginPage.objects.get_app_choices())

    class Meta:
        model = PluginPage
        exclude = ("pagetree")


class PageOderForm(forms.ModelForm):
    def __init__(self, *args, **kwargs):
        """ Change form field data in a DRY way """
        super(PageOderForm, self).__init__(*args, **kwargs)
        choices = [(i, i) for i in range(-10, 10)]
        for field_name, field in self.fields.iteritems():
            field.widget = forms.widgets.Select(choices=choices)

    class Meta:
        model = PageTree

PageOrderFormSet = modelformset_factory(
    model=PageTree, form=PageOderForm, extra=0, fields=('position',)
)


class MassesEditorSelectForm(forms.Form):
    """
    TODO: implement a API for generating _DATA. So that other plugins can easy add some items.
    """
    _DATA = (
        (PageTree, False, "slug", "parent", "design", "showlinks", "permitViewGroup", "permitEditGroup"),
        (PageMeta, True, "name", "title", "tags", "keywords", "robots", "permitViewGroup"),
        (BlogEntry, True, "tags", "is_public"),
        (LexiconEntry, True, "tags", "alias", "short_definition", "is_public"),
        (UpdateJournal, True, "staff_only"),
        (PyLucidComment, False, "notify", "is_public", "is_removed"),
    )
    CHOICES = [] # Used by the model_attr field
    _CHOICES_DICT = {} # Used in self.clean_model_attr()
    id = 0
    for model_data in _DATA:
        for attr in model_data[2:]:
            id += 1
            CHOICES.append((id, "%s.%s" % (model_data[0].__name__, attr)))
            _CHOICES_DICT[id] = (model_data[0], model_data[1], attr)

    model_attr = forms.ChoiceField(choices=CHOICES,
        label="model attribute", help_text=_("The model and attribute for bulk edit.")
    )
    language = forms.ModelChoiceField(queryset=Language.on_site.all(), empty_label=None,
        help_text=_("Filter queryset in this language (if possible)")
    )

    def hide_all_fields(self):
        """ hide all fields (assign HiddenInput widget """
        for field_name, field in self.fields.iteritems():
            field.widget = forms.widgets.HiddenInput()

    def clean_model_attr(self):
        """ Don't return only the internal ID -> return (model, filter_lang, attr) """
        id = int(self.cleaned_data['model_attr'])
        return self._CHOICES_DICT[id]


########NEW FILE########
__FILENAME__ = search
# coding:utf-8

"""
    search PageContent
    ~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django.contrib.sites.models import Site

from pylucid_project.apps.pylucid.models import PageContent


class Search(object):
    def get_queryset(self, request, search_languages, search_strings):
        queryset = PageContent.objects.select_related()

        # search only all pages from this site
        queryset = queryset.filter(pagemeta__pagetree__site=Site.objects.get_current())

        # Filter view permissions:
        # TODO: Check this in unittests!
        if request.user.is_anonymous(): # Anonymous user are in no user group
            queryset = queryset.filter(pagemeta__permitViewGroup=None)
            queryset = queryset.filter(pagemeta__pagetree__permitViewGroup=None)
        elif not request.user.is_superuser: # Superuser can see everything ;)
            user_groups = request.user.groups.all()
            queryset = queryset.filter(pagemeta__permitViewGroup__in=user_groups)
            queryset = queryset.filter(pagemeta__pagetree__permitViewGroup__in=user_groups)

        # Only pages in the selected search language
        queryset = queryset.filter(pagemeta__language__in=search_languages)

        for term in search_strings:
            queryset = queryset.filter(content__icontains=term)
        return queryset

    def add_search_results(self, request, queryset, search_results):
        for page in queryset:
            search_results.add(
                model_instance=page,

                # displayed headline of the result hit
                headline=page.get_title(),

                # displayed in the result list
                language=page.pagemeta.language,

                # Link to the hit
                url=page.get_absolute_url(),

                # the main content -> result lines would be cut out from hits in this content
                content=page.get_search_content(request),

                # hits in meta content has a higher score, but the content would not displayed 
                meta_content=page.pagemeta.keywords + " " + page.pagemeta.description,
            )

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import sys

if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#    tests = "pylucid_plugins.page_admin.tests.BulkEditorCsrfTest"
#    tests = "pylucid_plugins.page_admin.tests.PageAdminTest.test_translate_form"

    from pylucid_project.tests import run_test_directly
    run_test_directly(tests,
        verbosity=2,
#        failfast=True,
        failfast=False,
    )
    sys.exit()

from django.conf import settings
from django.test.client import Client
from django.core.urlresolvers import reverse

from pylucid_project.apps.pylucid.markup import MARKUP_CREOLE, \
    MARKUP_TINYTEXTILE
from pylucid_project.apps.pylucid.models import PageContent, PageTree
from pylucid_project.tests.test_tools import basetest


CREATE_CONTENT_PAGE_URL = reverse("PageAdmin-new_content_page")
CREATE_PLUGIN_PAGE_URL = reverse("PageAdmin-new_plugin_page")

INLINE_EDIT_PAGE_URL = "/?page_admin=inline_edit"
INLINE_PREVIEW_URL = "/?page_admin=preview"

ADD_CONTENT_PERMISSIONS = (
    "pylucid.add_pagecontent", "pylucid.add_pagemeta", "pylucid.add_pagetree"
)
CHANGE_CONTENT_PERMISSIONS = (
    "pylucid.change_pagecontent", "pylucid.change_pagemeta", "pylucid.change_pagetree"
)


class PageAdminTestCase(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - assertPyLucidPermissionDenied()
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.other_lang_code - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def get_page_content_post_data(self, **kwargs):
        data = {
            'save': 'save',
            'content': 'The **creole** //content//.',
            'design': 1,
            'en-robots': 'index,follow',
            'markup': MARKUP_CREOLE,
            'position': 0,
            'showlinks': 'on',
            'slug': 'page_slug'
        }
        data.update(kwargs)
        return data

    def login_with_permissions(self, permissions):
        """ login as normal user with PageAdmin add permissions """
        user = self.login("normal")
        self.add_user_permissions(user, permissions=permissions)


class PageAdminAnonymousTest(PageAdminTestCase):
    def test_login_before_create_content_page(self):
        """ Anonymous user must login, to use the create view """
        response = self.client.get(CREATE_CONTENT_PAGE_URL)
        self.assertRedirect(response, status_code=302,
            url="http://testserver/?auth=login&next_url=%s" % CREATE_CONTENT_PAGE_URL
        )

    def test_login_before_create_plugin_page(self):
        """ Anonymous user must login, to use the create view """
        response = self.client.get(CREATE_PLUGIN_PAGE_URL)
        self.assertRedirect(response, status_code=302,
            url="http://testserver/?auth=login&next_url=%s" % CREATE_PLUGIN_PAGE_URL
        )

    def test_login_before_edit_all(self):
        """ Anonymous user must login, to use the edit all view """
        url = reverse("PageAdmin-edit_page", kwargs={"pagetree_id":1}) # edit the page with ID==1
        response = self.client.get(url)
        self.assertRedirect(response, status_code=302,
            url="http://testserver/?auth=login&next_url=%s" % url
        )


class PageAdminTest(PageAdminTestCase):
    """
    Test with a user witch are logged in and has ADD_PERMISSION
    """
    def setUp(self):
        self.client = Client() # start a new session
#
    def test__normal_user_without_permissions(self):
        """ test with insufficient permissions: normal, non-stuff user """
        self.login("normal")
        response = self.client.get(CREATE_CONTENT_PAGE_URL)
        self.assertPyLucidPermissionDenied(response)

    def test_staff_user_without_permissions(self):
        """ test with insufficient permissions: staff user without any permissions """
        self.login("staff")
        response = self.client.get(CREATE_CONTENT_PAGE_URL)
        self.assertPyLucidPermissionDenied(response)

    def test_create_page_form(self):
        """
        get the create page, with normal user witch has the add permission
        """
        self.login_with_permissions(ADD_CONTENT_PERMISSIONS)
        response = self.client.get(CREATE_CONTENT_PAGE_URL)
        self.assertStatusCode(response, 200)

        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = response.content.replace(
            """.before('<h2 class="ajax_msg">submit...</h2>');""",
            """.before('submit...');""",
        )
        response.content = response.content.replace(
            """.html('<h2 class="noanchor">loading...</h2>');""",
            """.html('loading...');"""
        )
        self.assertDOM(response,
            must_contain=(
                '<title>PyLucid - Create a new page</title>',
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
                '<input type="submit" name="save" value="Save" />',
                '<textarea id="id_content" rows="10" cols="40" name="content"></textarea>',
                '<input type="button" id="preview_submit_id_content" name="preview" value="markup preview" />',
                '<legend>Markup preview</legend>',
            )
        )
        self.assertResponse(response,
            must_contain=(
                'form action="%s"' % CREATE_CONTENT_PAGE_URL,
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback", "Form errors", "field is required")
        )

    def test_create_entry(self):
        self.login_with_permissions(ADD_CONTENT_PERMISSIONS)
        response = self.client.post(CREATE_CONTENT_PAGE_URL,
            data=self.get_page_content_post_data()
        )
        new_page_url = "http://testserver/en/page_slug/"
        self.assertRedirect(response, url=new_page_url, status_code=302)

        # Check the created page
        response = self.client.get(new_page_url)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - page_slug</title>',
                'New content page u&#39;/en/page_slug/&#39; created.',
                '<p>The <strong>creole</strong> <i>content</i>.</p>',
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback", "Form errors", "field is required")
        )

    def test_markup_preview(self):
        self.login_with_permissions(ADD_CONTENT_PERMISSIONS)
        response = self.client.post(
            CREATE_CONTENT_PAGE_URL + "preview/",
            data=self.get_page_content_post_data(preview="markup preview"),
            HTTP_X_REQUESTED_WITH='XMLHttpRequest'
        )
        self.assertResponse(response,
            must_contain=(
                '<p>The <strong>creole</strong> <i>content</i>.</p>',
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback", "error", "field is required")
        )

    def test_no_self_parent_choose(self):
        """
        Check if parent select doesn't conain the own entry.
        So the user can't select it and make a child <-> parent loop.
        """
        self.login_with_permissions(CHANGE_CONTENT_PERMISSIONS)
        url = reverse("PageAdmin-edit_page", kwargs={"pagetree_id":1}) # edit the page with ID==1
        response = self.client.get(url)

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = response.content.replace(
            """.before('<h2 class="ajax_msg">submit...</h2>');""",
            """.before('submit...');""",
        )
        response.content = response.content.replace(
            """.html('<h2 class="noanchor">loading...</h2>');""",
            """.html('loading...');"""
        )

        self.assertDOM(response,
            must_contain=(
                '<option value="" selected="selected">---------</option>',
                '<option value="3">/designs/</option>',
            ),
            must_not_contain=(
                '<option value="1">/welcome/</option>',
            )
        )
        self.assertResponse(response,
            must_contain=(
                '<select', 'id="id_parent"', 'name="parent"',
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING",
                "Traceback", "Form errors", "field is required"
            )
        )

    def test_child_parent_loop_error(self):
        """
        do a child <-> parent loop: parent ID == current PageTree ID
        """
        self.login_with_permissions(CHANGE_CONTENT_PERMISSIONS)
        url = reverse("PageAdmin-edit_page", kwargs={"pagetree_id":1}) # edit the page with ID==1
        response = self.client.post(url,
            data=self.get_page_content_post_data(parent=1)
        )
        self.assertResponse(response,
            must_contain=(
                "Form errors",
                """<ul class="errorlist" id="parent_errors" title="Errors for field 'parent'">""",
                '<li>child-parent loop error!</li>',
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback", "field is required")
        )

    def test_slug_exists_error(self):
        """
        use a slug that exist in the same sub tree.
        """
        # get two 'root' pages.
        first_test_page, second_test_page = PageTree.on_site.all().filter(parent=None)[:2]

        self.login_with_permissions(CHANGE_CONTENT_PERMISSIONS)
        url = reverse("PageAdmin-edit_page", kwargs={"pagetree_id":first_test_page.id}) # edit the first test page
        response = self.client.post(url,
            data=self.get_page_content_post_data(slug=second_test_page.slug)
        )
        self.assertResponse(response,
            must_contain=(
                "Form errors",
                """<ul class="errorlist" id="slug_errors" title="Errors for field 'slug'">""",
                "<li>Page '/<strong>%s</strong>/' exists already.</li>" % second_test_page.slug,
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback", "field is required")
        )

    def test_plugin_page_parent_error(self):
        """
        A PageContent can't have a PluginPage as parent page.
        """
        # get any PluginPage
        a_plugin_page_id = PageTree.on_site.all().filter(page_type=PageTree.PLUGIN_TYPE)[0].id

        self.login_with_permissions(CHANGE_CONTENT_PERMISSIONS)
        url = reverse("PageAdmin-edit_page", kwargs={"pagetree_id":1}) # edit the page with ID==1
        response = self.client.post(url,
            data=self.get_page_content_post_data(parent=a_plugin_page_id)
        )
        self.assertResponse(response,
            must_contain=(
                "Form errors",
                """<ul class="errorlist" id="parent_errors" title="Errors for field 'parent'">""",
                "<li>Can't use the <strong>plugin</strong> page '/blog/' as parent page! Please choose a <strong>content</strong> page.</li>",
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback", "field is required")
        )

    def test_tag_list(self):
        self.login_with_permissions(CHANGE_CONTENT_PERMISSIONS)
        url = reverse("PageAdmin-tag_list")
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                "<title>PyLucid - lucidTag list</title>",

                "<caption>list of all existing lucidTags</caption>",
                "value='&#x7B;% lucidTag auth %&#x7D;'",
                "value='&#x7B;% lucidTag language %&#x7D;'",

                "context keys",
                "<li>&#x7B;&#x7B; current_site &#x7D;&#x7D;</li>",
                "<li>&#x7B;&#x7B; page_title &#x7D;&#x7D;</li>",
                "<li>&#x7B;&#x7B; user &#x7D;&#x7D;</li>",
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING", "Traceback",
                "wrong tag example"
            )
        )

    def test_translate_form(self):
        self.login("superuser")
        url = reverse("PageAdmin-translate", kwargs={"pagemeta_id":1})
        response = self.client.get(url)

        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = response.content.replace(
            """.before('<h2 class="ajax_msg">submit...</h2>');""",
            """.before('submit...');""",
        )
        response.content = response.content.replace(
            """.html('<h2 class="noanchor">loading...</h2>');""",
            """.html('loading...');"""
        )
        self.assertDOM(response,
            must_contain=(
                "<title>PyLucid - Translate page &#39;welcome&#39; (English) into Deutsch.</title>",
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
                '<input type="submit" name="save" value="Save" />',
                '<input type="submit" name="cancel" value="Cancel" />'
            )
        )
        self.assertResponse(response,
            must_contain=(
                "Translate page &#39;welcome&#39; (English) into Deutsch.",
                '<a href="/pylucid_admin/plugins/page_admin/markup_help/"',
                '<a href="/pylucid_admin/plugins/page_admin/page_list/"',
                '<a href="/pylucid_admin/plugins/page_admin/tag_list/"',

                '>Welcome to your fesh PyLucid CMS installation ;)',
                '>Willkommen auf deiner frisch installierem PyLucid CMS Seiten ;)',
                '{% lucidTag update_journal %}</textarea>',
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback", "Form errors", "field is required")
        )

    def test_rename_slug(self):
        pagetree = PageTree.objects.get(slug="example-pages")
        response = self.client.get("/en/SiteMap/")
        self.assertResponse(response,
            must_contain=(
                "/en/example-pages/",
            ),
            must_not_contain=("XXX INVALID TEMPLATE STRING", "Traceback")
        )
        pagetree.slug = "new-slug"
        pagetree.save()
        response = self.client.get("/en/SiteMap/")
        self.assertResponse(response,
            must_contain=(
                "/en/new-slug/",
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING", "Traceback",
                "/en/example-pages/"
            )
        )


class PageAdminHelperViewsTest(PageAdminTestCase):

    def test_markup_help(self):
        self.login("superuser")
        url = reverse("PageAdmin-markup_help")
        url += "?markup_id=%s" % MARKUP_CREOLE
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                "<title>PyLucid - creole markup help</title>",
                '<option value="6" selected="selected">Creole wiki markup</option>',
                "creole_cheat_sheet.png",
                "creole macros",
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING", "Traceback",
                "errorlist", "This field is required.",
            )
        )

    def test_page_list(self):
        self.login("superuser")
        url = reverse("PageAdmin-page_list")
        url += "?markup_id=%s" % MARKUP_CREOLE
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                "<title>PyLucid - page list</title>",
                '<option value="6" selected="selected">Creole wiki markup</option>',
                "list of all accessable pages",
                "value='[[/permalink/1/welcome-to-your-pylucid-cms-|Welcome to your PyLucid CMS =;-)]]'",
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING", "Traceback",
                "errorlist", "This field is required.",
            )
        )

class PageAdminInlineEditTest(PageAdminTestCase):
    """
    Test with a user witch are logged in and has ADD_PERMISSION
    """
    def setUp(self):
        self.client = Client() # start a new session

    def test_ajax_form(self):
        """ Test AJAX request of the edit page form """
        self.login_with_permissions(CHANGE_CONTENT_PERMISSIONS)

        response = self.client.get(INLINE_EDIT_PAGE_URL, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertStatusCode(response, 200)

        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = response.content.replace(
            """.before('<h2 class="ajax_msg">submit...</h2>');""",
            """.before('submit...');""",
        )
        response.content = response.content.replace(
            """.html('<h2 class="ajax_msg">loading...</h2>');""",
            """.html('loading...');"""
        )

        self.assertDOM(response,
            must_contain=(
                '<div id="edit_page_preview"></div>',
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
                '<input type="submit" name="save" value="Save" />',
                '<input type="submit" id="submit_preview" name="preview" value="markup preview" />',
                '<button type="button" id="ajax_preview" title="markup preview">markup preview</button>',
                '<label for="id_content"><strong>Content</strong>:</label>',
            )
        )
        self.assertResponse(response,
            must_contain=(
                "Edit the CMS page '<strong>Welcome to your PyLucid CMS =;-)</strong>'",
                '&#x7B;% lucidTag update_journal %&#x7D;</textarea>', # PageContent
                # CSS:
                '#ajax_preview {',
                # JavaScript:
                '$("#ajax_preview").show();',
                # Some form strings:
                'form action="/?page_admin=inline_edit"',
                '&#x7B;% lucidTag update_journal %&#x7D;</textarea>',
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING",
                '<title>', "<body", "<head>", # <- not a complete page
                "Traceback", 'Permission denied',
            ),
        )

    def test_ajax_preview(self):
        """ Test ajax edit page preview """
        self.login_with_permissions(CHANGE_CONTENT_PERMISSIONS)
        response = self.client.post(INLINE_PREVIEW_URL,
            {"content": "A **creole** //preview//!", "preview": True},
            HTTP_X_REQUESTED_WITH='XMLHttpRequest'
        )
        self.assertStatusCode(response, 200)
        self.failUnlessEqual(
            response.content,
            '<p>A <strong>creole</strong> <i>preview</i>!</p>'
        )


class ConvertMarkupTest(basetest.BaseLanguageTestCase):

    def _pre_setup(self, *args, **kwargs):
        """ create some language related attributes """
        super(ConvertMarkupTest, self)._pre_setup(*args, **kwargs)

        self.pagecontent = PageContent.objects.all().filter(markup=MARKUP_TINYTEXTILE)[0]
        self.pagetree = PageTree.on_site.get(pagemeta=self.pagecontent.pagemeta)
        self.url = reverse("PageAdmin-convert_markup", kwargs={"pagecontent_id":self.pagecontent.id})

        self.login("superuser")

    def setUp(self):
        super(ConvertMarkupTest, self).setUp()
        self._OLD_COMPRESS = settings.COMPRESS_ENABLED
        settings.COMPRESS_ENABLED = False

    def tearDown(self):
        super(ConvertMarkupTest, self).tearDown()
        settings.COMPRESS_ENABLED = self._OLD_COMPRESS

    def test_get_convert_form(self):
        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=(
                "<title>PyLucid - Convert &#39;tinyTextile&#39; markup</title>",
                "<input type='hidden' name='csrfmiddlewaretoken' value='",
                'The original markup is: <strong>tinytextile</strong>',
                'h1. headlines',
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING", "Traceback", 'Permission denied',
            ),
        )

    def test_convert_verbose_preview(self):
        response = self.client.post(self.url, data={
            'content': '* 1.\n** 1.1.',
            'dest_markup': MARKUP_CREOLE,
            'preview': 'Vorschau',
            'verbose': 'on'
        })
        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = response.content.replace(
            """.html('<h2 class="noanchor">loading...</h2>');""",
            """.html('loading...');"""
        )

        self.assertDOM(response,
            must_contain=(
                "<title>PyLucid - Convert &#39;tinyTextile&#39; markup</title>",
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
                '<legend class="pygments_code">Diff</legend>',
                '<span class="gd">- &lt;li&gt;1.&lt;/li&gt;</span>',
                '<span class="gi">+ &lt;li&gt;1.</span>',
                '<legend>new markup</legend>',
                '<pre>* 1.\n** 1.1.</pre>',
                '<textarea cols="40" id="id_content" name="content" rows="10">* 1.\n** 1.1.</textarea>',
            )
        )
        self.assertResponse(response,
            must_contain=(
                # Real pygments CSS content is removed in unittests!
                # more info in pylucid_project/tests/test_tools/basetest.py 
                'Pygments CSS Content',

                'The original markup is: <strong>tinytextile</strong>',
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING", "Traceback", 'Permission denied',
            ),
        )

    def test_convert(self):
        response = self.client.post(self.url, data={
            'content': '* 1.\n** 1.1.',
            'dest_markup': MARKUP_CREOLE,
        })
        new_url = "http://testserver%s" % self.pagecontent.get_absolute_url()
        self.assertRedirect(response,
            url=new_url,
            status_code=302
        )
        response = self.client.get(new_url)
        self.assertResponse(response,
            must_contain=(
                '<li>1.',
                '<li>1.1.</li>',
            ),
            must_not_contain=(
                "XXX INVALID TEMPLATE STRING", "Traceback", 'Permission denied',
            ),
        )


class BulkEditorCsrfTest(PageAdminTestCase):
    """ Test the Cross Site Request Forgery protection """
    def _get_loggedin_client(self):
        csrf_client = Client(enforce_csrf_checks=True)

        test_user = self._get_userdata("superuser")
        ok = csrf_client.login(username=test_user["username"],
                               password=test_user["password"])
        return csrf_client

    def test_csrf_token(self):
        csrf_client = self._get_loggedin_client()

        url = reverse("PageAdmin-bulk_editor")
        response = csrf_client.get(url)

        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        self.assertIsNot(csrf_cookie, False)
        csrf_token = csrf_cookie.value

        self.assertDOM(response,
            must_contain=(
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
            ),
        )





########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid page admin
    ~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf import settings
from django.contrib import messages
from django.http import HttpResponse, HttpResponseRedirect
from django.template import RequestContext
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.shortcuts import render_pylucid_response
from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.apps.pylucid.decorators import check_permissions
from pylucid_project.apps.pylucid.models import PageTree, PageContent

from page_admin.forms import EditPageForm


def _get_pageobjects(request):
    """
    returns current PageContent instance.
    Note: In get views, the page content doesn't exist on PyLucid objects.
    """
    pagemeta = request.PYLUCID.pagemeta
    pagecontent = PageContent.objects.get(pagemeta=pagemeta)
    return pagemeta, pagecontent


def _edit_page(request, form_url):
    pagetree = request.PYLUCID.pagetree
    if pagetree.page_type != PageTree.PAGE_TYPE:
        messages.info(request, "Current page is not a content page.")
        return

    pagemeta, pagecontent = _get_pageobjects(request)
    preview_html = ""

    if request.method == 'POST':
        edit_page_form = EditPageForm(request.POST)
        if edit_page_form.is_valid():
            if "preview" in request.POST:
                raw_content = edit_page_form.cleaned_data["content"]
                preview_html = apply_markup(
                    raw_content, pagecontent.markup, request, escape_django_tags=True
                )
            else:
                new_content = edit_page_form.cleaned_data["content"]
                pagecontent.content = new_content
                pagecontent.save()
                messages.success(request, _("Page content updated."))
                return HttpResponseRedirect(request.path)
    else:
        edit_page_form = EditPageForm(initial={"content":pagecontent.content})

    context = {
        "form_url": form_url,
        "abort_url": request.path,
        "preview_url": "%s?page_admin=preview" % request.path,

        "preview_html": preview_html,

        "edit_page_form": edit_page_form,
        "pagecontent": pagecontent,
        "pagemeta": pagemeta,
    }
    return render_pylucid_response(request, 'page_admin/edit_inline_form.html', context,
        context_instance=RequestContext(request)
    )


def _edit_page_preview(request):
    """ AJAX preview """
    if request.method != 'POST':
        return HttpResponse("ERROR: Wrong request")
    edit_page_form = EditPageForm(request.POST)
    if not edit_page_form.is_valid():
        return HttpResponse("ERROR: Form not valid: %r" % edit_page_form.errors)
    content = edit_page_form.cleaned_data["content"]

    pagemeta, pagecontent = _get_pageobjects(request)

    raw_content = edit_page_form.cleaned_data["content"]
    html_content = apply_markup(raw_content, pagecontent.markup, request, escape_django_tags=True)

    return HttpResponse(html_content)


@check_permissions(superuser_only=False,
    permissions=('pylucid.change_pagecontent', 'pylucid.change_pagemeta')
)
def http_get_view(request):
    action = request.GET["page_admin"]
    if action == "inline_edit":
        # replace the page content with the edit page form
        form_url = "%s?page_admin=inline_edit" % request.path
        return _edit_page(request, form_url)
    elif action == "preview":
        # preview via jQuery
        return _edit_page_preview(request)

    if settings.DEBUG:
        messages.info(request, _("Wrong get view parameter!"))

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    A simple poll plugin
    ~~~~~~~~~~~~~~~~~~~~
    
    Based on django poll tutorial

    :copyleft: 2011-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.contrib import admin
from django.utils.translation import ugettext_lazy as _

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from poll.models import Poll, Choice, UserVotes, IPVotes


class ChoiceInline(admin.TabularInline):
    model = Choice
    extra = 3

class PollAdmin(CompareVersionAdmin):
    list_display = ("question", "active", "lucidTag_example", "lastupdatetime", "lastupdateby")
    list_display_links = ("question",)
    list_editable = ("active",)
    list_filter = ("active",)
#    fieldsets = [
#        (None, {"fields": ["question"]}),
#        ("permissions", {
#            "fields": ["limit_to_group", "allow_anonymous"],
#        }),
#        ("site information", {"fields": ["sites"]}),
#    ]
    inlines = [ChoiceInline]

    def lucidTag_example(self, obj):
        return '{%% lucidTag poll id=%i %%}' % obj.id
    lucidTag_example.short_description = _("lucidTag example")

admin.site.register(Poll, PollAdmin)

class UserVotesAdmin(admin.ModelAdmin):
    list_display = ("user", "poll")

admin.site.register(UserVotes, UserVotesAdmin)

class IPVotesAdmin(admin.ModelAdmin):
    list_display = ("ip", "count", "poll")

admin.site.register(IPVotes, IPVotesAdmin)

########NEW FILE########
__FILENAME__ = models
# coding: utf-8

"""
    A simple poll plugin
    ~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.contrib.auth.models import User
from django.db import models
from django.db.models import aggregates
from django.utils.translation import ugettext_lazy as _

from django_tools import limit_to_usergroups
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.base_models.many2many import AutoSiteM2M



class Poll(AutoSiteM2M, UpdateInfoBaseModel):
    """   
    inherited attributes from AutoSiteM2M:
        sites     -> ManyToManyField to Site
        on_site   -> sites.managers.CurrentSiteManager instance
        site_info -> a string with all site names, for admin.ModelAdmin list_display

    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    question = models.CharField(max_length=200)
    active = models.BooleanField(default=True,
        help_text=_("Can users vote to this poll or just see the result?"),
    )

    permit_vote = limit_to_usergroups.UsergroupsModelField(help_text=_("Limit vote to user-types/user-groups."))
    permit_view = limit_to_usergroups.UsergroupsModelField(help_text=_("Limit result view to user-types/user-groups."))

    limit_ip = models.IntegerField(
        default=10,
        help_text=_("Limit votes from the same IP - 0 == unlimited"),
    )

    def __unicode__(self):
        return self.question

    class Meta:
        ordering = ('-createtime', '-lastupdatetime')


class Choice(models.Model):
    poll = models.ForeignKey(Poll)
    choice = models.CharField(max_length=200)
    votes = models.IntegerField(default=0, editable=False)

    def percent(self):
        result = Choice.objects.filter(poll=self.poll).aggregate(aggregates.Sum("votes"))
        votes_sum = result["votes__sum"]
        return float(self.votes) / votes_sum * 100

    def __unicode__(self):
        return self.choice


class UserVotes(models.Model):
    """ Save witch user has vote to the poll """
    poll = models.ForeignKey(Poll)
    user = models.ForeignKey(User)
    def __unicode__(self):
        return u"%s - %s" % (self.user.username, self.poll.question)


class IPVotes(models.Model):
    poll = models.ForeignKey(Poll)
    ip = models.IPAddressField()
    count = models.IntegerField(default=1)
    def __unicode__(self):
        return u"%s - %s" % (self.ip, self.poll.question)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    A simple poll plugin
    ~~~~~~~~~~~~~~~~~~~~
    
    Features:
        * insert a specific poll into cms page
        * insert all/all active/all voteable polls into cms page
        * activate/deactivate polls
        * limit view and/or vote to a poll to usertype/usergroup
        * Save
        
    See also:
        http://www.pylucid.org/permalink/375/poll

    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.contrib import messages
from django.http import HttpResponseRedirect, Http404
from django.shortcuts import render_to_response
from django.template.context import RequestContext
from django.utils.translation import ugettext as _

from django_tools.decorators import render_to
from django_tools import limit_to_usergroups

from pylucid_project.apps.pylucid.shortcuts import bad_request

from poll.models import Poll, Choice, UserVotes, IPVotes



#CHECK_SESSION = False
CHECK_SESSION = True

#CHECK_COOKIES = False
CHECK_COOKIES = True


def _get_poll_or_404(id):
    id = int(id)
    try:
        poll = Poll.on_site.get(id=id)
    except Poll.DoesNotExist:
        raise Http404(_("Poll with ID %s doesn't exist" % id))
    return poll


def _get_cookie_name(poll):
    return "pylucid_poll_%i" % poll.id


def _ip_limit_reached(request, poll):
    """
    Return True if IP limit reached for this poll.
    """
    if poll.limit_ip == 0:
        # No limit set
        return False

    # Check if IP Address has too many votes
    ip = request.META['REMOTE_ADDR']
    try:
        queryset = IPVotes.objects.only("count").get(poll=poll, ip=ip)
    except IPVotes.DoesNotExist:
        return False
    else:
        count = queryset.count

    if count >= poll.limit_ip:
        if settings.DEBUG:
            messages.debug(request, "We get %i votes from %s and only %i are allowed" % (count, ip, poll.limit_ip))
        return True
    else:
        return False


def _why_cant_vote(request, poll):
    """
    return a message why the user can't vote or return False if he can vote.
    Reasons are:
        * poll is not active
        * user has no permission
        * user has vote in the past
        * To many votes from this IP
    """
    if not poll.active:
        return _("This poll is not active.")

    if not limit_to_usergroups.has_permission(poll, permit_vote=request.user):
        msg = _("You have no permission to vote this poll.")
        if settings.DEBUG:
            verbose_limit_name = limit_to_usergroups.get_verbose_limit_name(poll.permit_vote)
            msg += " (Limited to: %s)" % verbose_limit_name
        return msg

    if CHECK_COOKIES and _get_cookie_name(poll) in request.COOKIES:
        # Save that this user hase vote to this poll
        msg = _("You have vote for this in the past.")
        if settings.DEBUG:
            msg += " (Info from cookie)"
        return msg

    if CHECK_SESSION and poll.id in request.session.get("has_vote_polls", []):
        msg = _("You have vote for this in the past.")
        if settings.DEBUG:
            msg += " (Info from session)"
        return msg

    if request.user.is_authenticated():
        # Save that this user hase vote to this poll
        if UserVotes.objects.filter(poll=poll, user=request.user).count() > 0:
            msg = _("You have vote for this in the past.")
            if settings.DEBUG:
                msg += " (Info from UserVotes model)"
            return msg

    if _ip_limit_reached(request, poll):
        msg = _("No more votes allowed.")
        if settings.DEBUG:
            ip = request.META['REMOTE_ADDR']
            msg += " (Limit of %i votes from %s reached.)" % (poll.limit_ip, ip)
        return msg

    return False # user can vote



@render_to()
def _get_poll_content(request, poll):
    context = {
        "poll": poll,
    }
    why_cant_vote = _why_cant_vote(request, poll)
    if why_cant_vote == False:
        # Use can vote -> display vote form
        context["template_name"] = "poll/vote_form.html"
    else:
        # Use can't vote -> display poll results with a message, why he can't vote
        context.update({
            "poll_message": why_cant_vote,
            "template_name": "poll/results.html",
        })

    return context



def lucidTag(request, id=None):
    """
    Add a poll to the page content.
    
    {% lucidTag poll %}
        Display the newest, voteable poll.
        
    {% lucidTag poll id=X %}
        Display a specific poll.
        (Look into admin changelist to the the right ID)
        
    {% lucidTag poll.all_polls %}
        Display all existing polls.
        Filter with 'hide_deactivated' and/or 'not_voteable'
    
    example:
        {% lucidTag poll id=23 %}
        {% lucidTag poll.all_polls hide_deactivated=True %}
        {% lucidTag poll.all_polls not_voteable=True %}
        {% lucidTag poll.all_polls hide_deactivated=True not_voteable=True %}
    """
    if id is None:
        # Display the newest, voteable poll
        queryset = Poll.on_site.filter(active=True).order_by("createtime")
        polls = limit_to_usergroups.filter_permission(queryset, permit_vote=request.user)
        if not polls:
            return render_to_response(
                "poll/no_active_poll.html", context_instance=RequestContext(request)
            )
        poll = polls[0]
    else:
        # Display a definite poll
        poll = _get_poll_or_404(id)

    if not limit_to_usergroups.has_permission(poll, permit_view=request.user):
        if settings.DEBUG:
            return "[No permissions to see this poll]"
        return ""

    response = _get_poll_content(request, poll)

    return response


def all_polls(request, hide_deactivated=False, not_voteable=False):
    """
    Display all active polls.
    """
    queryset = Poll.on_site.all()
    if hide_deactivated:
        queryset = queryset.filter(active=True)

    queryset = limit_to_usergroups.filter_permission(queryset, permit_view=request.user)

    if not_voteable:
        queryset = limit_to_usergroups.filter_permission(queryset, permit_vote=request.user)

    output = []
    for poll in queryset:
        response = _get_poll_content(request, poll)
        output.append(response.content)

    return "\n".join(output)


def _vote(request):
    id = request.GET["id"]
    poll = _get_poll_or_404(id)

    if not poll.active:
        messages.error(request, _("This poll is not active!"))
        return HttpResponseRedirect(request.path)

    if not limit_to_usergroups.has_permission(poll, permit_vote=request.user):
        msg = _("You have no permission to vote this poll.")
        if settings.DEBUG:
            verbose_limit_name = limit_to_usergroups.get_verbose_limit_name(poll.permit_vote)
            msg += " (Vote limited to: %s)" % verbose_limit_name
        messages.error(request, msg)
        return HttpResponseRedirect(request.path)

    if not limit_to_usergroups.has_permission(poll, permit_view=request.user):
        msg = _("You have no permission to vote this poll.")
        if settings.DEBUG:
            verbose_limit_name = limit_to_usergroups.get_verbose_limit_name(poll.permit_vote)
            msg += " (View limited to: %s)" % verbose_limit_name
        messages.error(request, msg)
        return HttpResponseRedirect(request.path)

    if _ip_limit_reached(request, poll): # debug message are created
        messages.error(request, _("No more votes allowed."))
        return HttpResponseRedirect(request.path)

    try:
        choice = request.POST["choice"]
    except KeyError:
        messages.error(request, _("You didn't select a choice."))
        return HttpResponseRedirect(request.path)

    try:
        selected_choice = poll.choice_set.get(pk=choice)
    except Choice.DoesNotExist:
        messages.error(request, _("Choice is not valid."))
        return HttpResponseRedirect(request.path)

    selected_choice.votes += 1
    selected_choice.save()
    messages.success(request, _("You choice was saved"))

    if "has_vote_polls" in request.session:
        request.session["has_vote_polls"].append(poll.id)
    else:
        request.session["has_vote_polls"] = [poll.id]

    if request.user.is_authenticated():
        # Save that this user hase vote to this poll
        UserVotes.objects.create(poll=poll, user=request.user)

    if poll.limit_ip > 0:
        # Save that this IP has vote to this poll.
        ip = request.META['REMOTE_ADDR']
        ipvotes, created = IPVotes.objects.get_or_create(poll=poll, ip=ip)
        if not created:
            ipvotes.count += 1
            ipvotes.save()

    response = HttpResponseRedirect(request.path)
    # Save that this user hase vote to this poll
    response.set_cookie(_get_cookie_name(poll), value="1")
    return response


def http_get_view(request):
    """
    Login+Logout view via GET parameters
    """
    action = request.GET["poll"]

    if action == "vote":
        return _vote(request)
    else:
        debug_msg = "Wrong get view parameter!"
        return bad_request("pylucid_plugin.poll", "error", debug_msg) # Returns a HttpResponseBadRequest





########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms

from dbpreferences.forms import DBPreferencesBaseForm


class TestForm(DBPreferencesBaseForm):
    """ test preferences form """
    subject = forms.CharField(initial="foobar", help_text="Some foo text")   
    foo_bool = forms.BooleanField(initial=True, required=False, help_text="Yes or No?")
    count = forms.IntegerField(initial=10, min_value=1, help_text="A max number")
    font_size = forms.FloatField(initial=0.7, min_value=0.1, help_text="font size")

    class Meta:
        app_label = 'pref_test'
########NEW FILE########
__FILENAME__ = views

import pprint

from django.http import HttpResponse

from dbpreferences.models import Preference

from pref_test.preference_forms import TestForm


def lucidTag(request):
    form = TestForm()
    pref_data = form.get_preferences()
    
    return HttpResponse("<pre>%s</pre>" % pprint.pformat(pref_data))
########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

from django.contrib import admin

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from pylucid_project.apps.pylucid.base_admin import BaseAdmin

from pylucid_comments.models import PyLucidComment

class PyLucidCommentAdmin(BaseAdmin, CompareVersionAdmin):
    """
    TODO:
        -Add action "set to non public"
        -cut comment text or include it via html "title" tag.
    """
    list_display = (
        'name', "comment",
        #'content_type', 'object_pk',
        "view_on_site_link",
        'ip_address', 'submit_date',
        'is_public', 'is_removed', 'url',
    )
    list_filter = ('submit_date', 'site', 'is_public', 'is_removed', 'content_type')
    date_hierarchy = 'submit_date'
    ordering = ('-submit_date',)
    search_fields = ('comment', 'user__username', 'user_name', 'user_email', 'user_url', 'ip_address')

admin.site.register(PyLucidComment, PyLucidCommentAdmin)

########NEW FILE########
__FILENAME__ = forms
# coding:utf-8

from django import forms
from django.contrib.comments.forms import CommentForm
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.models import Language

from pylucid_comments.models import PyLucidComment
from django_tools.middlewares import ThreadLocal

class PyLucidCommentForm(CommentForm):
    email = forms.EmailField(label=_("Email address"), required=False,
        help_text=_("not published, only used for notification"),
    )
    notify = forms.BooleanField(required=False, initial=True,
        help_text=_("Send me a mail if someone replay on my comment. (Needs a email address ;)")
    )
    def __init__(self, target_object, data=None, initial=None):
        """ prefill some user info """       
        if initial is None:
            initial = {}

        current_user = ThreadLocal.get_current_user()
        if current_user.is_authenticated():
            initial["name"] = current_user.get_full_name() or current_user.username
            initial["email"] = current_user.email

        super(PyLucidCommentForm, self).__init__(target_object, data, initial)

    def get_comment_model(self):
        # Use our custom comment model instead of the built-in one.
        return PyLucidComment

    def get_comment_create_data(self):
        # Use the data of the superclass, and add the notify field
        data = super(PyLucidCommentForm, self).get_comment_create_data()
        if self.cleaned_data['notify'] == True and self.cleaned_data['email']:
            data['notify'] = True
        else:
            data['notify'] = False
        return data



########NEW FILE########
__FILENAME__ = models
# coding: utf-8

from django.db import models
from django.db.models import signals
from django.contrib.comments.models import Comment
from django.utils.translation import ugettext_lazy as _
from django.contrib.comments.signals import comment_was_posted
from django.contrib.sites.managers import CurrentSiteManager

from pylucid_project.pylucid_plugins import update_journal


class PyLucidComment(Comment):
    notify = models.BooleanField(
        help_text="Send me a mail if someone replay on my comment. (Needs a email address ;)"
    )

    on_site = CurrentSiteManager()

    def get_absolute_url(self):
        return self.content_object.get_absolute_url()

    def get_update_info(self):
        """ update info for update_journal.models.UpdateJournal used by update_journal.save_receiver """
        if self.is_public == False or self.is_removed == True: # Don't list non public articles
            return

        return {
            "lastupdatetime": self.submit_date,
            "user_name": self.userinfo["name"],
            "language": self.content_object.language,
            "object_url": self.get_absolute_url(),
            "title": "New comment for '%s'" % self.content_object.get_name(),
        }

    class Meta:
        verbose_name = _('PyLucid comment')
        verbose_name_plural = _('PyLucid pylucid_comments')

signals.post_save.connect(receiver=update_journal.save_receiver, sender=PyLucidComment)

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext_lazy as _

from django_tools.fields.sign_separated import SignSeparatedFormField

from dbpreferences.forms import DBPreferencesBaseForm


class PyLucidCommentsPrefForm(DBPreferencesBaseForm):
    ban_limit = forms.IntegerField(
        help_text=_("Number of pause errors after IP would be banned."),
        initial=3, min_value=1, max_value=100
    )
    min_pause = forms.IntegerField(
        help_text=_("Minimum pause in seconds between two comments (Used 'REMOTE_ADDR' + username)"),
        initial=60, min_value=1, max_value=600
    )
    spam_keywords = SignSeparatedFormField(
        separator=",", strip_items=True, skip_empty=True,
        initial=[
            "www.", "://", "<", ">",
            "pr0n", "fuck", "blow", "pharmacy", "pills", "enlarge", "buy",
            "casino",
        ],
        help_text=_("Keywords for auto hide a new comment, for later moderation. (Comma seperated)"),
    )
    admins_notification = forms.BooleanField(
        initial=True,
        help_text=_("Email every settings.ADMINS after a new comment submitted."),
    )
    class Meta:
        app_label = 'pylucid_comments'

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - There exist only "PyLucid CMS" blog entry in english and german
    
    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.contrib.comments.forms import CommentForm
from django.contrib.comments.models import Comment
from django.core import mail, signing
from django.test.client import Client

from django_tools.unittest_utils.BrowserDebug import debug_response

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageMeta
from pylucid_comments.views import _get_preferences

class PyLucidCommentsTestCase(basetest.BaseUnittest):
    def getValidData(self, obj, **kwargs):
        """ work-a-round for comment form security fields """
        f = CommentForm(obj)
        d = {
            'name'      : 'John Doe',
            'email'     : 'john.doe@example.tld',
            'url'       : '',
            'comment'   : 'This is my comment',
        }
        d.update(f.initial)
        d.update(kwargs)
        return d


class PyLucidCommentsPageMetaTestCase(PyLucidCommentsTestCase):
    """
    Base for all PageMeta tests.
    """
    def _pre_setup(self, *args, **kwargs):
        super(PyLucidCommentsTestCase, self)._pre_setup(*args, **kwargs)
        self.pagemeta = PageMeta.on_site.all()[0]
        self.absolute_url = self.pagemeta.get_absolute_url()
        self.get_form_url = self.absolute_url + "?pylucid_comments=get_form"
        self.submit_url = self.absolute_url + "?pylucid_comments=submit"

    def setUp(self):
        Comment.objects.all().delete()
        self._old_ADMINS = settings.ADMINS
        settings.ADMINS = (('John', 'john@example.com'), ('Mary', 'mary@example.com'))
        super(PyLucidCommentsTestCase, self).setUp()

    def tearDown(self):
        super(PyLucidCommentsTestCase, self).tearDown()
        settings.ADMINS = self._old_ADMINS

    def _get_form(self):
        data = self.getValidData(self.pagemeta)
        url = self.get_form_url
        url += "&content_type=%s" % data["content_type"]
        url += "&object_pk=%s" % data["object_pk"]
        response = self.client.get(url, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        return response


class PyLucidCommentsPageMetaTest(PyLucidCommentsPageMetaTestCase):
    def test_get_form(self):
        """ get the comment form via AJAX """
        response = self._get_form()
        self.assertDOM(response,
            must_contain=(
                '<input id="id_content_type" name="content_type" type="hidden" value="pylucid.pagemeta" />',
                '<input id="id_object_pk" name="object_pk" type="hidden" value="%i" />' % self.pagemeta.pk,
                '<input checked="checked" id="id_notify" name="notify" type="checkbox" />'
            )
        )
        self.assertResponse(response,
            must_contain=(
                '<form action="JavaScript:void(0)" method="post" id="comment_form">',
            ),
            must_not_contain=(
                "Traceback", "Form errors", "field is required",
                "<body", "</html>"
            )
        )

    def test_submit_comment(self):
        settings.DEBUG = True # Display a comment error page
        self.failUnless(Comment.objects.count() == 0)
        self.failUnless(len(mail.outbox) == 0, len(mail.outbox))

        # submit a valid comments form
        data = self.getValidData(self.pagemeta, comment="from test_submit_comment()")
        response = self.client.post(self.submit_url, data, HTTP_X_REQUESTED_WITH='XMLHttpRequest')

        # Check if comment created
        self.failUnless(Comment.objects.count() == 1)

        # Check if page should reload (JavaScript do this)
        self.failUnlessEqual(response.content, 'reload')

        # Check if ADMINS get's a email.
        #for email in mail.outbox:print email.message()

        self.assertEqual(len(mail.outbox), len(settings.ADMINS))

        email_text = mail.outbox[0].message()
        #print email_text
        self.failUnless("The comment is public." not in email_text)
        self.failUnless(data["name"] not in email_text)
        self.failUnless(data["comment"] not in email_text)
        self.failUnless("http://testserver%s" % self.absolute_url not in email_text)

        # Check if anonymous data saved in a cookie, for later usage
        self.failUnless("comments_data" in response.cookies)
        signed_comments_data = response.cookies["comments_data"].value
        comments_data = signing.loads(signed_comments_data)
        self.failUnlessEqual(
            comments_data,
            {u'url': u'', u'name': u'John Doe', u'email': u'john.doe@example.tld'}
        )

        # Check if anonymous data stored in cookie would be used:
        response = self._get_form()
        self.assertDOM(response,
            must_contain=(
                '<input id="id_name" maxlength="50" name="name" type="text" value="John Doe" />',
                '<input id="id_email" name="email" type="text" value="john.doe@example.tld" />',
            )
        )

    def test_submit_preview(self):
        settings.DEBUG = True # Display a comment error page
        self.failUnless(Comment.objects.count() == 0)
        url = self.absolute_url + "?pylucid_comments=submit"
        data = self.getValidData(self.pagemeta, preview="On", comment="comment from test_submit_preview()")
        response = self.client.post(url, data, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertDOM(response,
            must_contain=(
                '<blockquote><p>comment from test_submit_preview()</p></blockquote>',
                '<input id="id_content_type" name="content_type" type="hidden" value="pylucid.pagemeta" />',
                '<input id="id_object_pk" name="object_pk" type="hidden" value="%i" />' % self.pagemeta.pk,
                '<input id="id_notify" name="notify" type="checkbox" />'
            )
        )
        self.assertResponse(response,
            must_contain=(
                'Preview your comment',
                '<form action="JavaScript:void(0)" method="post" id="comment_form">',
            ),
            must_not_contain=(
                "Traceback", "Form errors", "field is required",
                "<body", "</html>"
            )
        )

    def test_submit_no_comment(self):
        settings.DEBUG = True # Display a comment error page
        self.failUnless(Comment.objects.count() == 0)
        url = self.absolute_url + "?pylucid_comments=submit"
        data = self.getValidData(self.pagemeta, comment="", notify="on")
        response = self.client.post(url, data, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.failUnless(Comment.objects.count() == 0)
        self.assertDOM(response,
            must_contain=(
                '<input id="id_content_type" name="content_type" type="hidden" value="pylucid.pagemeta" />',
                '<input id="id_object_pk" name="object_pk" type="hidden" value="%i" />' % self.pagemeta.pk,
                '<input checked="checked" id="id_notify" name="notify" type="checkbox" value="on" />'
            )
        )
        self.assertResponse(response,
            must_contain=(
                'Please correct the error below',
                'This field is required.',
                '<form action="JavaScript:void(0)" method="post" id="comment_form">',
            ),
            must_not_contain=("Traceback", "<body", "</html>")
        )

    def test_submit_spam(self):
        settings.DEBUG = True # Display a comment error page
        self.failUnless(Comment.objects.count() == 0)
        data = self.getValidData(self.pagemeta,
            comment="Penis enlargement pills: http://en.wikipedia.org/wiki/Penis_enlargement ;)"
        )
        response = self.client.post(self.submit_url, data, HTTP_X_REQUESTED_WITH='XMLHttpRequest')

        # Check if page should reload (JavaScript do this)
        self.failUnlessEqual(response.content, 'reload')

        # Check if ADMINS get's a email.
        #for email in mail.outbox:print email.message()
        self.assertEqual(len(mail.outbox), len(settings.ADMINS))

        email_text = mail.outbox[0].message()
        #print email_text
        self.failUnless("The comment is public." not in email_text)
        self.failUnless(data["name"] not in email_text)
        self.failUnless(data["comment"] not in email_text)
        self.failUnless("http://testserver%s" % self.absolute_url not in email_text)

        # Check if comment created
        self.failUnless(Comment.objects.count() == 1)
        comment = Comment.objects.all()[0]
        self.failUnless(comment.is_public == False)

        # 'Reload' and check page message
        response = self.client.get(self.absolute_url)
        self.assertResponse(response,
            must_contain=(
                'Your comment waits for moderation.',
            ),
            must_not_contain=(
                "Traceback", "Form errors", "field is required",
                "Penis", "enlargement", "pills",
            )
        )

    def test_DOS_attack(self):
        settings.DEBUG = True # Display a comment error page
        self.failUnless(Comment.objects.count() == 0)
        url = self.absolute_url + "?pylucid_comments=submit"

        preferences = _get_preferences()
        ban_limit = preferences["ban_limit"]

        # Hold if all three events would been received. 
        tested_under_limit = False
        tested_limit_reached = False
        tested_banned = False

        for no in xrange(1, ban_limit + 2):
            # submit a valid comments form
            data = self.getValidData(self.pagemeta, comment="test_DOS_attack() comment no %i" % no)
            response = self.client.post(url, data, HTTP_X_REQUESTED_WITH='XMLHttpRequest')

            if no > ban_limit:
                # IP is on the ban list
                tested_banned = True
                self.assertStatusCode(response, 403) # get forbidden page
                comment_count = Comment.objects.count()
                self.failUnless(comment_count == ban_limit - 1)
            elif no == ban_limit:
                # The limit has been reached
                tested_limit_reached = True
                self.assertResponse(response, must_contain=('You are now banned.',))
                comment_count = Comment.objects.count()
                self.failUnless(comment_count == ban_limit - 1)
            else:
                # under ban limit: comment was saved, page should be reloaded
                tested_under_limit = True
                self.assertResponse(response,
                    must_contain=('reload',),
                    must_not_contain=(
                        "Traceback", "Form errors", "field is required",
                        "<!DOCTYPE", "<body", "</html>",
                    )
                )
                comment_count = Comment.objects.count()
                self.failUnless(comment_count == no)

        # Check if all three events have been received.
        self.failUnless(tested_limit_reached == True)
        self.failUnless(tested_under_limit == True)
        self.failUnless(tested_banned == True)


class PyLucidCommentsCsrfPageMetaTest(PyLucidCommentsPageMetaTestCase):
    """
    Test the Cross Site Request Forgery protection in comments.
    """
    def setUp(self):
        super(PyLucidCommentsPageMetaTestCase, self).setUp()
        settings.DEBUG = True
        self.client = Client(enforce_csrf_checks=True)

    def tearDown(self):
        super(PyLucidCommentsPageMetaTestCase, self).tearDown()
        settings.DEBUG = False

    def test_submit_form_without_token(self):
        # submit a valid comments form, but without csrf token 
        data = self.getValidData(self.pagemeta, comment="from test_submit_comment()")
        response = self.client.post(self.submit_url, data, HTTP_X_REQUESTED_WITH='XMLHttpRequest')
        self.assertResponse(response, must_contain=("Forbidden", "CSRF cookie not set."))

    def test_submit_form_with_token(self):
        # get the current csrf token
        response = self._get_form()
        self.assertIn(settings.CSRF_COOKIE_NAME, response.cookies)
        csrf_token = response.cookies[settings.CSRF_COOKIE_NAME].value

        self.failUnless(Comment.objects.count() == 0)

        data = self.getValidData(self.pagemeta, comment="from test_submit_comment()")
        data["csrfmiddlewaretoken"] = csrf_token
        response = self.client.post(self.submit_url, data, HTTP_X_REQUESTED_WITH='XMLHttpRequest')

        # Check if comment created
        self.failUnless(Comment.objects.count() == 1)

        # Check if page should reload (JavaScript do this)
        self.failUnlessEqual(response.content, 'reload')


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "pylucid_plugins.pylucid_comments.tests.PyLucidCommentsCsrfPageMetaTest"

    management.call_command('test', tests,
        verbosity=1,
#        verbosity=0,
#        failfast=True
    )

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid page comments plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    TODO:
     * Update existing unittest (e.g. blog, lexicon)

    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p

"""

import datetime

from django.conf import settings
from django.contrib import comments
from django.contrib import messages
from django.contrib.comments.signals import comment_will_be_posted, comment_was_posted
from django.contrib.comments.views.comments import post_comment
from django.contrib.sites.models import Site
from django.core.cache import cache
from django.core.mail import mail_admins
from django.db import models
from django.http import HttpResponse, HttpResponseRedirect
from django.shortcuts import render_to_response
from django.template.context import RequestContext
from django.template.loader import render_to_string
from django.utils.translation import ugettext as _
from django.views.decorators.csrf import csrf_protect, ensure_csrf_cookie

from django_tools.cache.site_cache_middleware import delete_cache_item
from django_tools.decorators import render_to
from django_tools.utils.client_storage import ClientCookieStorageError, ClientCookieStorage

from pylucid_project.apps.pylucid.models import LogEntry
from pylucid_project.apps.pylucid.shortcuts import bad_request
from pylucid_project.apps.pylucid.decorators import check_request

from pylucid_comments.preference_forms import PyLucidCommentsPrefForm



APP_LABEL = "pylucid_plugin.pylucid_comments"

COOKIE_KEY = "comments_data" # Used to store anonymous user information

# Important: The sign may not occur in a email address or in a homepage url!
# But it can occur in the username ;)
COOKIE_DELIMITER = ";"


def _get_preferences():
    """ return the comments preferences dict back """
    pref_form = PyLucidCommentsPrefForm()
    preferences = pref_form.get_preferences()
    return preferences


def _contains_spam_keyword(comment, preferences):
    """ contains the comment content a spam keywords defined in preferences? """
    spam_keywords = preferences["spam_keywords"]
    content = comment.comment
    for keyword in spam_keywords:
        if keyword in content:
            return True
    return False


def comment_will_be_posted_handler(sender, **kwargs):
    """ check comment before save """
    request = kwargs["request"]
    comment = kwargs["comment"]

    preferences = _get_preferences()
    if _contains_spam_keyword(comment, preferences):
        comment.is_public = False

    # Protection against DOS attacks.
    min_pause = preferences["min_pause"]
    ban_limit = preferences["ban_limit"]
    try:
        LogEntry.objects.request_limit(request, min_pause, ban_limit, app_label=APP_LABEL, action="post")
    except LogEntry.RequestTooFast, err:
        # min_pause is not observed
        error_msg = unicode(err) # ugettext_lazy
        messages.error(request, error_msg)


def comment_was_posted_handler(sender, **kwargs):
    """
    actions after a new comment saved
    """
#    print "comment_was_posted_handler", kwargs.keys()
    request = kwargs["request"]
    comment = kwargs["comment"]
    content_object = comment.content_object

    try:
        site = content_object.site
    except AttributeError:
        site = Site.objects.get_current()

    absolute_url = content_object.get_absolute_url()

    # Gives the user a feedback
    if comment.is_public:
        messages.success(request, _("Your comment has been saved."))
    else:
        messages.info(request, _("Your comment waits for moderation."))

    # Used to filter DOS attacks, see: comment_will_be_posted_handler()
    LogEntry.objects.log_action(app_label=APP_LABEL, action="post", message="comment created")

    preferences = _get_preferences()
    admins_notification = preferences["admins_notification"]
    if admins_notification:
        email_context = {
            "comment": comment,
            "content_object": content_object,
            "remote_addr": request.META["REMOTE_ADDR"],
            "now": datetime.datetime.utcnow(),
            "uri_prefix": request.build_absolute_uri("/").rstrip("/"), # FIXME
        }
        emailtext = render_to_string("pylucid_comments/admins_notification_email.txt", email_context)

        site_name = site.name
        subject = '[%s] New comment posted on "%s"' % (site_name, absolute_url)

        try:
            mail_admins(subject, emailtext, fail_silently=False)
        except Exception, err:
            LogEntry.objects.log_action(
                app_label=APP_LABEL, action="mail error", message="Admin mail, can't send: %s" % err,
            )

    # delete the item from cache
    absolute_url = content_object.get_absolute_url()
    language_code = content_object.language.code
    delete_cache_item(absolute_url, language_code, site.id)

    # FIXME: We must only update the cache for the current SITE not for all sites.
    try:
        cache.smooth_update() # Save "last change" timestamp in django-tools SmoothCacheBackend
    except AttributeError:
        # No SmoothCacheBackend used -> clean the complete cache
        cache.clear()


comment_will_be_posted.connect(comment_will_be_posted_handler)
comment_was_posted.connect(comment_was_posted_handler)


@ensure_csrf_cookie
@check_request(APP_LABEL, "_get_form() error", must_post=False, must_ajax=True)
@render_to("pylucid_comments/comment_form.html")
def _get_form(request):
    """ Send the comment form to via AJAX request """
    try:
        ctype = request.GET["content_type"].split(".", 1)
        model = models.get_model(*ctype)
    except Exception, err:
        return bad_request(APP_LABEL, "error", "Wrong content type: %s" % err)

    try:
        object_pk = request.GET["object_pk"]
        target = model._default_manager.using(None).get(pk=object_pk)
    except Exception, err:
        return bad_request(APP_LABEL, "error", "Wrong object_pk: %s" % err)

    data = {}
    if not request.user.is_authenticated() and COOKIE_KEY in request.COOKIES:
        # Get user data from secure cookie, set in the past, see _form_submission()
        c = ClientCookieStorage(cookie_key=COOKIE_KEY)
        try:
            data = c.get_data(request)
        except ClientCookieStorageError, err:
            LogEntry.objects.log_action(
                app_label=APP_LABEL, action="wrong cookie data", message="%s" % err,
            )
            if settings.DEBUG:
                return bad_request(APP_LABEL, "error", "Wrong cookie data: %s" % err)

    form = comments.get_form()(target, initial=data)
    return {"form":form}


@csrf_protect
@check_request(APP_LABEL, "_form_submission() error", must_ajax=True)
def _form_submission(request):
    """ Handle a AJAX comment form submission """
    # Use django.contrib.comments.views.comments.post_comment to handle a comment post.
    response = post_comment(request)
    if isinstance(response, HttpResponseRedirect):
        # reload the page after comment saved via JavaScript
        response = HttpResponse("reload")

        if not request.user.is_authenticated():
            # Store user data for anonymous users in a secure cookie, used in _get_form() to pre fill the form
            comments_data = {
                "name": request.POST["name"],
                "email": request.POST.get("email", ""),
                "url": request.POST.get("url", ""),
            }
            # Store the user data with a security hash
            c = ClientCookieStorage(cookie_key=COOKIE_KEY)
            response = c.save_data(comments_data, response)

    return response




def http_get_view(request):
    """
    Login+Logout view via GET parameters
    """
    action = request.GET["pylucid_comments"]

    if action == "get_form":
        return _get_form(request)
    elif action == "submit":
        return _form_submission(request)
    else:
        debug_msg = "Wrong get view parameter!"
        return bad_request(APP_LABEL, "error", debug_msg) # Return HttpResponseBadRequest


def lucidTag(request):
    if (settings.DEBUG or request.user.is_superuser) and not settings.ADMINS:
        messages.info(request, "Please fill out settings.ADMINS!")

    object2comment = request.PYLUCID.object2comment

    if object2comment == False:
        # Don't display pylucid comments on this page
        # e.g. search get view display search results
        return ""

    form = comments.get_form()(object2comment)
    context = {
        "form":form,
        "object2comment": object2comment,
    }
    return render_to_response("pylucid_comments/comments.html",
        context, context_instance=RequestContext(request)
    )

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    Redirect PyLucid Plugin - admin 
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Register model in django admin interface.

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.contrib import admin
from django import forms

from pylucid_project.apps.pylucid.models import PluginPage
from pylucid_project.apps.pylucid.base_admin import BaseAdmin

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from redirect.models import RedirectModel


class RedirectAdminForm(forms.ModelForm):
    """
    Filter pagetree selection.
    Add only pagetree items witch are a redirect plugin page.
    """
    class Meta:
        model = RedirectModel

    def __init__(self, *args, **kwargs):
        super(RedirectAdminForm, self).__init__(*args, **kwargs)

        plugin_pages = PluginPage.objects.filter(app_label="pylucid_project.pylucid_plugins.redirect")

        choices = [
            (page.pagetree.id, page.pagetree.get_absolute_url())
            for page in plugin_pages
        ]
        self.fields["pagetree"].choices = choices


class RedirectModelAdmin(BaseAdmin, CompareVersionAdmin):
    form = RedirectAdminForm

    list_display = (
        "view_on_site_link", "destination_url", "response_type", "full_url", "append_query_string",
        "lastupdatetime", "lastupdateby"
    )
    list_display_links = ("destination_url", "response_type")
    list_filter = ("response_type", "full_url", "append_query_string", "createby", "lastupdateby",)
    date_hierarchy = 'lastupdatetime'
    search_fields = ("destination_url",)

admin.site.register(RedirectModel, RedirectModelAdmin)

########NEW FILE########
__FILENAME__ = models
# coding:utf-8

from django import http
from django.db import models
from django.utils.translation import ugettext_lazy as _

from django_tools.models import UpdateInfoBaseModel

from pylucid_project.apps.pylucid.models import PageTree


class RedirectModel(UpdateInfoBaseModel):
    """   
    inherited attributes from UpdateInfoBaseModel:
        createtime     -> datetime of creation
        lastupdatetime -> datetime of the last change
        createby       -> ForeignKey to user who creaded this entry
        lastupdateby   -> ForeignKey to user who has edited this entry
    """
    TYPE_DICT = {
        u"301": {"title": u"301 - PermanentRedirect", "class": http.HttpResponsePermanentRedirect},
        u"302": {"title": u"302 - Redirect", "class": http.HttpResponseRedirect},
    }
    TYPE_CHOICES = [(key, data["title"]) for key, data in TYPE_DICT.iteritems()]
    #--------------------------------------------------------------------------

    pagetree = models.ForeignKey(PageTree)

    destination_url = models.CharField(max_length=256,
        help_text=_("The destination url for the redirect")
    )
    response_type = models.CharField(max_length=3, choices=TYPE_CHOICES,
        help_text=_("Response type")
    )
    full_url = models.BooleanField(
        help_text=_("redirect the full url or raise 404 if url has additional parts.")
    )
    append_query_string = models.BooleanField(
        help_text=_("Append a GET query string, if exist?")
    )
    debug = models.BooleanField(
        help_text=_("Don't redirect, just display some info. (Only for staff members!)")
    )

    def get_response_data(self):
        return self.TYPE_DICT[self.response_type]

    def get_absolute_url(self):
        return self.pagetree.get_absolute_url()

    def __unicode__(self):
        return u"%s to %s" % (self.get_response_data()["title"], self.destination_url)

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - There exist only "PyLucid CMS" lexicon entry in english and german
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os


if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"


from django.conf import settings
from django.core.urlresolvers import reverse

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageTree


class RedirectPluginTest(basetest.BaseLanguageTestCase):
    def _pre_setup(self, *args, **kwargs):
        """ create some language related attributes """
        super(RedirectPluginTest, self)._pre_setup(*args, **kwargs)

        self.new_plugin_page_url = reverse("PageAdmin-new_plugin_page")
        self.redirectmodel_add_url = reverse("admin:redirect_redirectmodel_add")

        self.login("superuser")

    def test_add_form(self):
        response = self.client.get(self.new_plugin_page_url)
        self.assertResponse(response,
            must_contain=(
                'Create a new plugin page',
                '<option value="pylucid_project.pylucid_plugins.redirect">pylucid_plugins.redirect</option>',
            ),
            must_not_contain=("Traceback",)
        )

    def test_create_plugin_page(self):
        """
        Create a 'redirect' plugin page and check the redirection after this.
        """
        test_slug = "test_redirect"
        destination_url = "http://github.com/jedie/PyLucid"

        response = self.client.post(self.new_plugin_page_url,
            data={'app_label': 'pylucid_project.pylucid_plugins.redirect',
            'design': 1,
            'position': 0,
            'slug': test_slug,
            'urls_filename': 'urls.py'
            }
        )
        url = "http://testserver/en/%s/" % test_slug
        self.assertRedirect(response, url, status_code=302)

        response = self.client.get(url)
        self.assertRedirect(response, "http://testserver" + self.redirectmodel_add_url, status_code=302)

        response = self.client.get(self.redirectmodel_add_url)
        self.assertResponse(response,
            must_contain=(
                "Redirect entry for page: /%s/ doesn&#39;t exist, please create." % test_slug,
                'Add redirect model',
            ),
            must_not_contain=("Traceback",)
        )

        page_tree_id = PageTree.on_site.get(slug=test_slug).id
        response = self.client.post(self.redirectmodel_add_url,
            data={
            "pagetree": page_tree_id,
            "destination_url": destination_url,
            "response_type": 302,
            }
        )
        self.assertRedirect(response,
            "http://testserver" + reverse("admin:redirect_redirectmodel_changelist"),
            status_code=302
        )

        response = self.client.get(url)
        self.assertRedirect(response, destination_url, status_code=302)



if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
#    management.call_command('test', "pylucid_plugins.lexicon.tests.RedirectPluginTest", verbosity=0)
    management.call_command('test', __file__, verbosity=1)

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

from django.conf.urls.defaults import patterns, url

from redirect import views

urlpatterns = patterns('',
    url(r'^(?P<rest_url>.*?)$', views.redirect, name='PluginRedirect-redirect'),
)



########NEW FILE########
__FILENAME__ = views
# coding:utf-8

from django import http
from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.utils.translation import ugettext as _

from redirect.models import RedirectModel


def setup_view(request):
    """
    called to setup a page entry
    TODO: This must be implemented in PyLucid, see also:
    http://pylucid.org/phpBB2/viewtopic.php?p=1551&highlight=setup+view#1551 (de)
    """
    pass


def redirect(request, rest_url=""):
    pagetree = request.PYLUCID.pagetree
    #lang_entry = request.PYLUCID.current_language

    try:
        redirect_info = RedirectModel.objects.get(pagetree=pagetree)#, language=lang_entry)
    except RedirectModel.DoesNotExist, err:
        # TODO: Don't redirect to admin panel -> Display a own create view!
        messages.info(request,
             _("Redirect entry for page: %s doesn't exist, please create.") % pagetree.get_absolute_url()
        )
        return HttpResponseRedirect(reverse("admin:redirect_redirectmodel_add"))

    destination_url = redirect_info.destination_url

    #print "rest_url: %r" % rest_url
    rest_url = rest_url.lstrip("/")
    if rest_url: # Handel the additional url part
        if not redirect_info.full_url:
            # raise 404, because we should not match on the full url.
            msg = ""
            if settings.DEBUG or request.user.is_staff:
                msg += " URL has additional parts %r, but 'full_url' is not allowed." % rest_url
            raise http.Http404(msg)
        destination_url += rest_url

    if request.GET and redirect_info.append_query_string:
        # Add GET query string
        # We don't use request.GET.urlencode() here, because it can change the key positions
        full_path = request.get_full_path()
        get_string = full_path.split("?", 1)[1]
        destination_url += "?" + get_string

    response_data = redirect_info.get_response_data()

    # get HttpResponsePermanentRedirect or HttpResponseRedirect class
    response_class = response_data["class"]
    response = response_class(destination_url)

    if settings.DEBUG or request.user.is_staff:
        msg = "You redirected from %r to %r (%s)" % (
            request.path, destination_url, response_data["title"]
        )
        if redirect_info.debug:
            return "Debug: %s" % msg
        else:
            messages.info(request, msg)

    return response


########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.system.pylucid_plugin import PyLucidDBPreferencesBaseForm

class PreferencesForm(PyLucidDBPreferencesBaseForm):
    template_name = forms.CharField(
        initial="rss/default.html",
        help_text=_("The default template filename.")
    )
    socket_timeout = forms.IntegerField(
        initial=1,
        min_value=1,
        max_value=60,
        help_text=_("Default socket timeout in seconds for getting the RSS feed.")
    )
    cache_timeout = forms.IntegerField(
        initial=15,
        min_value=1,
        max_value=1 * 60 * 60 * 24 * 7,
        help_text=_("Default number of seconds to cache a feed.")
    )

    class Meta:
        app_label = 'rss'

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

"""
    PyLucid RSS plugin
    ~~~~~~~~~~~~~~~~~~

    :copyleft: 2007-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import time
import socket
import traceback
from pprint import pformat

try:
    import feedparser
except ImportError, err:
    feedparser_available = False
    feedparser_err = err
else:
    feedparser_available = True

from django.contrib import messages
from django.core.cache import cache
from django.utils.safestring import mark_safe

from pylucid_project.apps.pylucid.markup import hightlighter
from pylucid_project.apps.pylucid.decorators import render_to
from pylucid_project.utils.escape import escape

from rss.preference_forms import PreferencesForm

@render_to()#, debug=True)
def lucidTag(request, url, max_entries=None, debug=False, **kwargs):
    """
    Include external RSS Feeds directly into a CMS page.
    
    optional keyword arguments are every db preferences form attribute.
    
    To create a custom template, used the debug mode: Add debug=True in tag.
    Debug mode only works for stuff users.
    
    Used feedparser by Mark Pilgrim: http://feedparser.org
    http://feedparser.googlecode.com/svn/trunk/LICENSE
    
    example:
        {% lucidTag rss url="http url" %}
        {% lucidTag rss url="http url" template_name="rss/MyOwnTemplate.html" %}
        {% lucidTag rss url="http url" max_entries=5 %}
        {% lucidTag rss url="http url" socket_timeout=3 %}
        {% lucidTag rss url="http url" debug=True %}
    """
    if feedparser_available == False:
        if request.user.is_staff:
            messages.error(request, "External 'feedparser' module not available: %s" % err)
            messages.info(request, "PyPi url: http://pypi.python.org/pypi/FeedParser/")
        return "[RSS feed error.]"

    # Get preferences from DB and update them with given kwargs.
    pref_form = PreferencesForm()
    preferences = pref_form.get_preferences(request, lucidtag_kwargs=kwargs)

    cache_key = "rss_feed_%s" % url
    feed_dict = cache.get(cache_key)
    if feed_dict:
        from_cache = True
    else:
        from_cache = False

        old_timeout = socket.getdefaulttimeout()
        socket.setdefaulttimeout(preferences["socket_timeout"])

        start_time = time.time()
        try:
            feed = feedparser.parse(url)
            if "bozo_exception" in feed:
                if isinstance(feed["bozo_exception"], feedparser.ThingsNobodyCaresAboutButMe):
                    if request.user.is_staff:
                        messages.info(request, "RSS feed info:", feed["bozo_exception"])
                else:
                    raise AssertionError("Feed error: %r" % feed["bozo_exception"])
        except Exception, e:
            if request.user.is_staff:
                messages.debug(request, mark_safe("Feed error:<pre>%s</pre>" % traceback.format_exc()))
                return "[feedparser.parse(%r) error: %s]" % (url, e)
            else:
                return "[Can't get RSS feed.]"

        duration = time.time() - start_time

        socket.setdefaulttimeout(old_timeout)

        feed_dict = {
            "feed": feed,
            "duration": duration,
        }
        cache.set(cache_key, feed_dict, preferences["cache_timeout"])

    if debug and request.user.is_staff:
        messages.info(request, "RSS debug is on, see page content.")
        feed_code = pformat(feed_dict["feed"])
        feed_html = hightlighter.make_html(
            feed_code, source_type="py", django_escape=True
        )
        return "<h1>RSS debug</h1><h2>Feed %r</h2>\n%s" % (url, feed_html)

    if max_entries:
        feed_dict["feed"].entries = feed_dict["feed"].entries[:max_entries]

    context = {
        "template_name": preferences["template_name"],
        "url": url,
        "max_entries": max_entries,
        "feed": feed_dict["feed"],
        "duration": feed_dict["duration"],
        "from_cache": from_cache,
        "preferences": preferences,
    }
    return context

########NEW FILE########
__FILENAME__ = forms
# coding:utf-8

from django import forms

from pylucid_project.pylucid_plugins.search.preference_forms import get_preferences
from pylucid_project.apps.pylucid.models.language import Language

class SearchForm(forms.Form):
    search = forms.CharField(widget=forms.TextInput(
        attrs={
            "required":"required",
            "autofocus":"autofocus",

        }
    ))
    def __init__(self, *args, **kwargs):
        super(SearchForm, self).__init__(*args, **kwargs)

        preferences = get_preferences()
        self.fields['search'].min_length = preferences["min_term_len"]
        self.fields['search'].max_length = preferences["max_term_len"]


class AdvancedSearchForm(SearchForm):
    language = forms.MultipleChoiceField(
        choices=Language.objects.get_choices(),
        widget=forms.CheckboxSelectMultiple,
    )

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8

"""
    PyLucid search preferences
    ~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v2 or above, see LICENSE for more details
"""


from django import forms
from django.utils.translation import ugettext as _

from dbpreferences.forms import DBPreferencesBaseForm

class SearchPreferencesForm(DBPreferencesBaseForm):
    min_term_len = forms.IntegerField(
        help_text=_("Min length of a search term"),
        initial=3, min_value=1
    )
    max_term_len = forms.IntegerField(
        help_text=_("Max length of a search term"),
        initial=50, min_value=1, max_value=200
    )
    max_hits = forms.IntegerField(
        help_text=_("Number of hits from one plugin to skip the search for them."),
        initial=100, min_value=1, max_value=500
    )
    text_cutout_len = forms.IntegerField(
        help_text=_("The length of the text-hit-cutouts"),
        initial=50, min_value=1, max_value=200
    )
    text_cutout_lines = forms.IntegerField(
        help_text=_("Max. cutout lines for every search term"),
        initial=5, min_value=1, max_value=20
    )

    ban_limit = forms.IntegerField(
        help_text=_("Numbers of limit overstepping after IP would be banned."),
        initial=5, min_value=1, max_value=20
    )
    min_pause = forms.IntegerField(
        help_text=_("Minimum pause in seconds between two search from the same user. (Used 'REMOTE_ADDR')"),
        initial=3, min_value=1, max_value=60
    )

    all_languages = forms.BooleanField(
        help_text=_("Use all languages (checked) or only the user prefered langes (unchecked) as default search language?"),
        initial=True, required=False,
    )

    class Meta:
        app_label = 'search'

def get_preferences():
    pref_form = SearchPreferencesForm()
    preferences = pref_form.get_preferences()
    return preferences

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
    
    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import os
import sys


if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#    tests = "pylucid_plugins.search.tests.SearchTest.test_prefered_language"

    from pylucid_project.tests import run_test_directly
    run_test_directly(tests,
        verbosity=2,
#        failfast=True,
        failfast=False,
    )
    sys.exit()


from django.conf import settings

from pylucid_project.tests.test_tools.basetest import BaseUnittest

from pylucid_project.pylucid_plugins.search.preference_forms import SearchPreferencesForm


class SearchTest(BaseUnittest):

    def _test_search(self):
        response = self.client.post("/en/welcome/?search=", data={"search": "PyLucid"})
        self.assertStatusCode(response, 200)
        self.assertResponse(response,
            must_contain=(
                '<title>PyLucid CMS - Advanced search</title>',
                "<input type='hidden' name='csrfmiddlewaretoken' value='",
                '<input type="hidden" name="search_page" value="true" >',
                'value="PyLucid"', 'id="id_search"',
                '<input type="submit" value="search" />',
                'Search Form',
                'Search results',
                "Search in ", " plugins",
                "duration: ", "sec.",
                "hits: ",
                '<strong>PyLucid</strong>',
            ),
            must_not_contain=(
                "Traceback", "XXX INVALID TEMPLATE STRING",
                "Form errors", "field is required",
                "comments",
            )
        )
        return response

    def test_search_anonymous(self):
        self._test_search()

    def test_search_normal_user(self):
        self.login("normal")
        self._test_search()

    def test_search_staff_user(self):
        self.login("staff")
        self._test_search()

    def test_search_superuser_user(self):
        self.login("superuser")
        self._test_search()

    def test_short_terms(self):
        response = self.client.post("/en/welcome/?search=", data={"search": "py foo bar"})
        self.assertStatusCode(response, 200)

        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value
        self.assertDOM(response,
            must_contain=(
                '<title>PyLucid CMS - Advanced search</title>',
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
                '<input type="hidden" name="search_page" value="true" >',
                '<input autofocus="autofocus" id="id_search" name="search" required="required" type="text" value="py foo bar" />',
                '<input type="submit" value="search" />',
            )
        )
        self.assertResponse(response,
            must_contain=(
                "Ignore &#39;py&#39; (too small)",
                'Search Form',
                'Search results',
                "Search in ", " plugins",
                "duration: ", "sec.",
                "hits: ",
            ),
            must_not_contain=(
                "Traceback", "XXX INVALID TEMPLATE STRING",
                "Form errors", "field is required"
            )
        )

    def test_no_search_term_left(self):
        response = self.client.post("/en/welcome/?search=", data={"search": "py xy z"})
        self.assertStatusCode(response, 200)

        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value
        self.assertDOM(response,
            must_contain=(
                '<title>PyLucid CMS - Advanced search</title>',
                "<input type='hidden' name='csrfmiddlewaretoken' value='%s' />" % csrf_token,
                '<input type="hidden" name="search_page" value="true" >',
                '<input autofocus="autofocus" id="id_search" name="search" required="required" type="text" value="py xy z" />',
                '<input type="submit" value="search" />',
            )
        )
        self.assertResponse(response,
            must_contain=(
                "Ignore &#39;py&#39; (too small)",
                "Ignore &#39;xy&#39; (too small)",
                "Ignore &#39;z&#39; (too small)",
                "Error: no search term left, can&#39;t search",
                'Search Form',
            ),
            must_not_contain=(
                "Traceback", "XXX INVALID TEMPLATE STRING",
                "Form errors", "field is required"
                'Search results',
                "Search in ", " plugins",
                "duration: ", "sec.",
                "hits: ",
            )
        )


########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid search plugin
    ~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v2 or above, see LICENSE for more details
"""

import time
import traceback


from django.conf import settings
from django.contrib import messages
from django.contrib.contenttypes.models import ContentType
from django.utils.html import strip_tags
from django.utils.safestring import mark_safe
from django.views.decorators.csrf import csrf_exempt

# http://code.google.com/p/django-tagging/
from tagging.utils import parse_tag_input

from django_tools.template.filters import human_duration

from pylucid_project.apps.pylucid.context_processors import NowUpdateInfo
from pylucid_project.apps.pylucid.decorators import render_to
from pylucid_project.apps.pylucid.models import Language, LogEntry
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS, \
    PluginNotOnSite
from pylucid_project.utils.python_tools import cutout

from pylucid_project.pylucid_plugins.search.preference_forms import get_preferences
from pylucid_project.pylucid_plugins.search.forms import AdvancedSearchForm, \
    SearchForm


def _filter_search_terms(request, search_string):
    """
    Split and filter the search terms.
    """
    preferences = get_preferences()

    raw_search_strings = parse_tag_input(search_string) # split with django-tagging
    search_strings = []
    for term in raw_search_strings:
        if len(term) < preferences["min_term_len"]:
            messages.warning(request, "Ignore '%s' (too small)" % term)
        else:
            search_strings.append(term)

    return search_strings


#-----------------------------------------------------------------------------


class SearchHit(object):
    """ one hit entry in the result page """
    def __init__(self, model_instance, search_strings, score, headline, language, url, content, preferences):
        self.model_instance = model_instance
        self.search_strings = search_strings
        self.score = score
        self.headline = headline
        self.language = language
        self.url = url
        self.content = strip_tags(content)

        self.text_cutout_len = preferences["text_cutout_len"]
        self.text_cutout_lines = preferences["text_cutout_lines"]

    def content_type(self):
        content_type = ContentType.objects.get_for_model(self.model_instance)
        return content_type

    def cutouts(self):
        """
        display the hits in the result page.
        cut the hits in the page content out. So the template can display
        the lines.
        """
        cutout_lines = []

        cutouts = cutout(
            content=self.content,
            terms=self.search_strings,
            max_lines=self.text_cutout_lines,
            cutout_len=self.text_cutout_len,
        )
        for pre_txt, hit_txt, post_txt in cutouts:
            yield (pre_txt, hit_txt, post_txt)


#-----------------------------------------------------------------------------


class SearchResults(object):
    """
    holds the search result data
    """
    def __init__(self, request, search_strings):
        self.request = request
        self.search_strings = search_strings
        self.search_strings_lower = tuple([i.lower() for i in search_strings])
        self.hits = []

        self.duration = None # set in self.done()
        self.plugin_count = None # set in self.done()
        self.start_time = time.time()

        self.preferences = get_preferences()

    def _calc_score(self, txt, multiplier):
        score = 0
        for term in self.search_strings_lower:
            score += txt.count(term) * multiplier
        return score

    def add(self, model_instance, headline, language, url, content, meta_content):
        """
        Add a search hit.
        
        headline - title for the hit in the result list
        language - language of the hit item, displayed in the result list
        url - absolute url for building a link to the hit item
        content - the main content -> result lines would be cut out from hits in this content
        meta_content - hits in meta content has a higher score, but the content would not displayed 
        """
        score = self._calc_score(content, 1)
        score += self._calc_score(headline, 10)
        score += self._calc_score(meta_content, 5)

        if language == self.request.PYLUCID.current_language:
            # Multiply the score if the content language
            # is the same as client prefered language 
            score *= 2

        search_hit = SearchHit(
            model_instance=model_instance,
            search_strings=self.search_strings,
            score=score,
            headline=headline,
            language=language,
            url=url,
            content=content,
            preferences=self.preferences,
        )

        self.hits.append((score, search_hit))

    def done(self, plugin_count, use_plugin, too_much_hits):
        self.plugin_count = plugin_count
        self.use_plugin = use_plugin
        self.too_much_hits = too_much_hits

        self.duration = time.time() - self.start_time

    def __iter__(self):
        for score, hit in sorted(self.hits, reverse=True):
            yield hit


class Search(object):
    def __init__(self, request, preferences):
        self.request = request
        self.preferences = preferences

    def search(self, search_lang_codes, search_strings):
        """ collect all plugin searches and return the results """
        search_results = SearchResults(self.request, search_strings)
        search_languages = Language.objects.filter(code__in=search_lang_codes)
#        search_languages = Language.objects.all_accessible().filter(code__in=search_lang_codes)

        # Call every plugin. The plugin adds all results into SearchResults object.
        plugin_count, use_plugin, too_much_hits = self.call_searchs(search_languages, search_strings, search_results)

        search_results.done(plugin_count, use_plugin, too_much_hits)

        return search_results

    def call_searchs(self, search_languages, search_strings, search_results):
        """ Call every plugin, witch has the search API. """
        filename = settings.PYLUCID.SEARCH_FILENAME
        class_name = settings.PYLUCID.SEARCH_CLASSNAME

        max_hits = self.preferences["max_hits"]

        plugin_count = 0
        too_much_hits = 0
        use_plugin = 0
        for plugin_name, plugin_instance in PYLUCID_PLUGINS.iteritems():
            try:
                SearchClass = plugin_instance.get_plugin_object(filename, class_name)
#                plugin_instance.call_plugin_view(self.request, filename, view_name, method_kwargs)
            except plugin_instance.ObjectNotFound:
                # Plugin has no search API
                continue
            except Exception:
                if self.request.debug or self.request.user.is_staff:
                    messages.error(self.request, "Can't collect search results from %s." % plugin_name)
                    messages.debug(self.request, mark_safe("<pre>%s</pre>" % traceback.format_exc()))
                continue

            try:
                search_instance = SearchClass()
            except PluginNotOnSite, err:
                # Plugin is not used on this SITE
                if self.request.debug or self.request.user.is_staff:
                    messages.debug(self.request, "Skip %s: %s" % (plugin_name, err))
                continue
            else:
                plugin_count += 1

            queryset = search_instance.get_queryset(self.request, search_languages, search_strings)
            count = queryset.count()
            if self.request.user.is_staff:
                messages.info(self.request, "%s hits in %s" % (count, plugin_name))

            if count >= max_hits:
                too_much_hits += 1
                messages.info(self.request, "Skip too many results from %s" % plugin_name)
                LogEntry.objects.log_action(
                    app_label="search", action="too mutch hits",
                    message="Skip %s hits in %s for %s" % (count, plugin_name, repr(search_strings)),
                    data={
                        "search_strings": search_strings,
                        "hits": count,
                    }
                )
                continue

            use_plugin += 1

            if count > 0:
                search_instance.add_search_results(self.request, queryset, search_results)

        return plugin_count, use_plugin, too_much_hits


def _search(request, cleaned_data):
    search_strings = _filter_search_terms(request, cleaned_data["search"])
    if len(search_strings) == 0:
        messages.error(request, "Error: no search term left, can't search.")
        return

    preferences = get_preferences()
    min_pause = preferences["min_pause"]
    ban_limit = preferences["ban_limit"]

    try:
        LogEntry.objects.request_limit(request, min_pause, ban_limit, app_label="search")
    except LogEntry.RequestTooFast:
        # min_pause is not observed, page_msg has been created -> don't search
        return

    search_lang_codes = cleaned_data["language"]
    search_results = Search(request, preferences).search(search_lang_codes, search_strings)
    hits_count = len(search_results.hits)
    duration = human_duration(search_results.duration)
    msg = "done in %s, %s hits for: %r" % (duration, hits_count, search_strings)
    LogEntry.objects.log_action(
        app_label="search", action="search done", message=msg,
        data={
            "search_strings": search_strings,
            "duration": search_results.duration,
            "hits": hits_count,
        }
    )
    return search_results


@csrf_exempt # FIXME: Use AJAX?
@render_to("search/search.html")#, debug=True)
def http_get_view(request):

    # XXX: Should we support GET search ?

    if "search_page" in request.POST:
        # Form send by search page
        querydict = request.POST
    else:
        # Form was send by lucidTag -> set default search language

        querydict = request.POST.copy() # make POST QueryDict mutable

        preferences = get_preferences()
        use_all_languages = preferences["all_languages"]

        if use_all_languages:
            # use all accessible languages
            accessible_languages = Language.objects.all_accessible(request.user)
            codes = accessible_languages.values_list('code', flat=True)
            querydict.setlist("language", codes)
        else:
            # preselect only the client preferred language
            querydict["language"] = request.PYLUCID.current_language.code

    form = AdvancedSearchForm(querydict)

    if form.is_valid():
        search_results = _search(request, form.cleaned_data)
    else:
        search_results = None

    # For adding page update information into context by pylucid context processor
    request.PYLUCID.updateinfo_object = NowUpdateInfo(request)

    context = {
        "page_title": "Advanced search", # Change the global title with blog headline
        "form": form,
        "form_url": request.path + "?search=",
        "search_results": search_results,
    }
    return context


@render_to("search/lucidTag.html")#, debug=True)
def lucidTag(request):
    """
    Display only a small search form. Can be inserted into the globale page template.
    The form is a GET form, so http_get_view() handle it.
    """
    return {"form": SearchForm()}


########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

"""
    PyLucid superfish main menu
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""


from django.conf import settings
from django.contrib import messages

from pylucid_project.apps.pylucid.models import PageTree
from pylucid_project.apps.pylucid.decorators import render_to


@render_to("sf_main_menu/sf_main_menu.html")
def lucidTag(request, min=1, max=0):
    """ Create the superfish main menu """
    user = request.user
    current_pagetree = request.PYLUCID.pagetree

    # Get a pylucid.tree_model.TreeGenerator instance with all accessible PageTree for the current user
    tree = PageTree.objects.get_tree(user, filter_showlinks=True)

    # activate the current pagetree node (for main menu template)
    def get_first_showlink(pagetree):
        """ returns the first pagetree witch has showlinks==True, go recursive up to next parent """
        if pagetree.showlinks == False and pagetree.parent != None:
            return get_first_showlink(pagetree.parent)
        return pagetree

    first_showlink = get_first_showlink(current_pagetree)
    try:
        # mark the current url tree
        tree.set_current_node(first_showlink.id, delete_hidden=False)
    except KeyError, err:
        tree.set_current_node(None, delete_hidden=False) # Root node
        if settings.DEBUG:
            messages.error(request, "Can't activate menu item %r KeyError: %s" % (current_pagetree, err))
            messages.info(request, "tree nodes: %r" % tree.nodes)
            messages.info(request, "All PageTree:", PageTree.objects.all())
            messages.info(request, "Current user:", request.user)
            messages.info(request, "all accessible PageTree:", PageTree.objects.all_accessible(request.user).all())

    # make all nodes visible
    tree.activate_all()

    tree.slice_menu(min, max)

    # add all PageMeta objects into tree
    tree.add_pagemeta(request)

    #tree.debug()

    return {"nodes": tree.get_first_nodes()}

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

"""
    PyLucid sitemap
    ~~~~~~~~~~~~~~~

    ToDo: Use the Template to generate the Sitemap tree.
    But there is no recuse-Tag in the django template engine :(
    - http://www.python-forum.de/topic-9655.html
    - http://groups.google.com/group/django-users/browse_thread/thread/3bd2812a3d0f7700/14f61279e0e9fd90

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2007 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v2 or above, see LICENSE for more details
"""

__version__ = "$Rev$"


from pylucid_project.apps.pylucid.models import PageTree, PageMeta, PageContent, Language
from pylucid_project.apps.pylucid.decorators import render_to


@render_to("SiteMap/SiteMap.html")
def lucidTag(request):
    """ Create the sitemap tree """
    user = request.user
    current_lang = request.PYLUCID.current_language

    # Get a pylucid.tree_model.TreeGenerator instance with all accessible PageTree for the current user
    tree = PageTree.objects.get_tree(user, filter_showlinks=True)

    # add all PageMeta objects into tree
    tree.add_pagemeta(request)

#    # add all related PageMeta objects into tree
#    queryset = PageMeta.objects.filter(language=current_lang)
#    tree.add_related(queryset, field="pagetree", attrname="pagemeta")

    #tree.debug()

    return {"nodes": tree.get_first_nodes()}

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    PyLucid StreetMap plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~


    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.contrib import admin
from django.template.loader import render_to_string
from django.utils.translation import ugettext_lazy as _

# https://github.com/jedie/django-reversion-compare
from reversion_compare.admin import CompareVersionAdmin

from StreetMap.models import MapEntry



class MapEntryAdmin(CompareVersionAdmin):
    def lucidTag_example(self, obj):
        return '{%% lucidTag StreetMap name="%s" %%}' % obj.name
    lucidTag_example.short_description = _("lucidTag example")
    
    def preview(self, obj):
        map_type = obj.map_type
        template_name = MapEntry.LINK_TEMPLATE[map_type]
        return render_to_string(template_name, {"map":obj})
    preview.short_description = _("preview")
    preview.allow_tags = True

    list_display = ("name", "lucidTag_example", "preview", "lon", "lat", "marker_text")
    list_display_links = ("name",)
    list_filter = ("createby", "lastupdateby",)
    date_hierarchy = 'lastupdatetime'
    search_fields = ("name", "marker_text")

admin.site.register(MapEntry, MapEntryAdmin)

########NEW FILE########
__FILENAME__ = models
# coding: utf-8

"""
    PyLucid OpenStreetMap plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.contrib import messages
from django.core import urlresolvers
from django.core.exceptions import ValidationError
from django.db import models
from django.db.models import signals
from django.template import TemplateDoesNotExist
from django.template.defaultfilters import slugify
from django.template.loader import find_template
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext_lazy as _

# http://code.google.com/p/django-tools/
from django_tools.middlewares import ThreadLocal
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.apps.pylucid.fields import MarkupModelField
from pylucid_project.apps.pylucid.markup.converter import apply_markup
from pylucid_project.base_models.many2many import AutoSiteM2M

from StreetMap.preference_forms import PreferencesForm


class MapEntry(AutoSiteM2M, UpdateInfoBaseModel):
    TYPE_OSM = "O"
    TYPE_GOOGLE = "G"
    TYPE_CHOICES = (# for self.map_type field
        (TYPE_OSM, 'OpenStreetMap'),
        (TYPE_GOOGLE, 'Google Maps'),
    )
    TEMPLATES = { # Used in views.py
        TYPE_OSM: "StreetMap/OpenStreetMap.html",
        TYPE_GOOGLE: "StreetMap/GoogleMaps.html",
    }
    LINK_TEMPLATE = { # Used in admin.py
        TYPE_OSM: "StreetMap/includes/OpenStreetMap_link.html",
        TYPE_GOOGLE: "StreetMap/includes/GoogleMaps_link.html",
    }

    name = models.SlugField(unique=True,
        help_text=_("Short name for lucidTag")
    )

    map_type = models.CharField(max_length=1, choices=TYPE_CHOICES, default=TYPE_OSM)
    template_name = models.CharField(max_length=128, null=True, blank=True,
        help_text=_(
            "Template path for this map."
            " (Optional, leave empty for default!"
        )
    )

    width = models.CharField(max_length=8,
        default="100%",
        help_text=_("Map width size")
    )
    height = models.CharField(max_length=8,
        default="400px",
        help_text=_("Map height size")
    )

    lon = models.FloatField(
        help_text=_("map geographic longitude (vertically) coordinate"),
    )
    lat = models.FloatField(
        help_text=_("map geographic latitude (horizontally) coordinate"),
    )
    zoom = models.PositiveSmallIntegerField(
        default=12,
        help_text=_("Map zoom factor"),
    )

    marker_lon = models.FloatField(null=True, blank=True,
        help_text=_(
            "Text marker longitude (vertically) coordinate."
            " (Optional, leave empty to use the map centre.)"
        )
    )
    marker_lat = models.FloatField(null=True, blank=True,
        help_text=_(
            "Text marker latitude (horizontally) coordinate"
            " (Optional, leave empty to use the map centre.)"
        )
    )
    marker_width = models.PositiveIntegerField(
        default=180,
        help_text=_("Text marker width size")
    )
    marker_height = models.PositiveIntegerField(
        default=125,
        help_text=_("Text marker height size")
    )

    # TODO: Use MarkupBaseModel
    marker_text = models.TextField(null=True, blank=True,
        help_text=_(
            "Marker text."
            " (Optional, leave empty if no popup marker should be displayed.)"
        )
    )
    markup = MarkupModelField()

    kmlurl = models.CharField(max_length=1024, null=True, blank=True,
        help_text=_("url to kml file to show on the map")
    )

    def get_template_name(self):
        """ return default or user set template name """
        if self.template_name:
            return self.template_name
        else:
            map_type = self.map_type
            return self.TEMPLATES[map_type]

    def clean_fields(self, exclude):
        message_dict = {}

        if "template_name" not in exclude and self.template_name:
            try:
                find_template(self.template_name)
            except TemplateDoesNotExist, err:
                message_dict["template_name"] = [_("Template doesn't exist.")]

        if message_dict:
            raise ValidationError(message_dict)

    def get_html(self):
        """ return the marker_text as html """
        request = ThreadLocal.get_current_request()
        html = apply_markup(
            raw_content=self.marker_text,
            markup_no=self.markup,
            request=request
        )
        # Needed for JavaScript:
        html = html.strip().replace("\n", "").replace('"', '\"')
        return mark_safe(html)

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8


from django import forms
from django.utils.translation import ugettext as _

from dbpreferences.forms import DBPreferencesBaseForm

class PreferencesForm(DBPreferencesBaseForm):
    google_maps_api_key = forms.CharField(
        initial="",required=False,
        help_text=_("Google Maps API Key (Leave empty if you only use OpenStreetMaps.)")
    )

    class Meta:
        app_label = 'StreetMap'

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid StreetMap plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.contrib import messages
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import render_to

from StreetMap.models import MapEntry
from StreetMap.preference_forms import PreferencesForm

@render_to()
def lucidTag(request, name=None):
    """
    Display a map inline.
    First create a map entry in django admin panel.
    Then use the name for the lucidTag parameter.
    
    example:
        {% lucidTag StreetMap name="MyMapName" %}
    """
    if name is None:
        if settings.DEBUG or request.user.is_staff:
            messages.error(request, _("lucidTag StreetMap error: You must add the 'name' parameter!"))
        return "[StreetMap Error]"

    try:
        map_entry = MapEntry.objects.get(name=name)
    except MapEntry.DoesNotExist:
        if settings.DEBUG or request.user.is_staff:
            messages.error(request,
                _("lucidTag StreetMap error:"
                  " There exist no map entry with the name: %r") % name
            )
            existing_names = MapEntry.objects.values_list('name', flat=True)
            messages.info(request, _("Existing maps are: %r") % existing_names)
        context = {
            "name": name,
            "template_name": "StreetMap/create_map.html",
        }
        return context

    # Get preferences from DB
    pref_form = PreferencesForm()
    preferences = pref_form.get_preferences()

    context = {
        "map":map_entry,
        "marker_lon": map_entry.marker_lon or 100000,
        "marker_lat": map_entry.marker_lat or 100000,
        "marker_html": map_entry.get_html(),
        "kmlurl": map_entry.kmlurl,
        "template_name": map_entry.get_template_name(),
        "lang_code": request.PYLUCID.current_language.code,
    }
    return context

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.contrib.auth.models import AnonymousUser

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageTree, PageContent
from pylucid_project.apps.pylucid.markup import MARKUP_HTML


class SubMenuTest(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.default_language - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def _pre_setup(self, *args, **kwargs):
        super(SubMenuTest, self)._pre_setup(*args, **kwargs)

        pagetree = PageTree.objects.get(slug="example-pages")
        self.pagecontent = PageContent.objects.get(
            pagemeta__pagetree=pagetree, pagemeta__language=self.default_language
        )
        self.pagecontent.markup = MARKUP_HTML
        self.url = self.pagecontent.get_absolute_url()

    def setUp(self):
        self.old_DEBUG = settings.DEBUG
        settings.DEBUG = True

    def tearDown(self):
        settings.DEBUG = self.old_DEBUG

    def _set_content(self, text):
        self.pagecontent.content = (
            "<p>%(pre)s</p>\n"
            "%(text)s\n"
            "<p>%(post)s</p>"
        ) % {
            "pre": "*" * 80,
            "text": text,
            "post": "^" * 80,
        }
        self.pagecontent.save()

    def _test(self, lucidtag, must_contain):
        self._set_content(lucidtag)
        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=must_contain,
            must_not_contain=(
                "Traceback", "XXX INVALID TEMPLATE STRING",
                "Form errors", "field is required",
            )
        )

    def test_default_example_page_content(self):
        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=(
                '<div class="PyLucidPlugins sub_menu" id="sub_menu_lucidTag">',
                '<dl>', '<dt>',
                '<a href="/en/example-pages/RSS/" hreflang="en">RSS feed test.</a>',
                '<dd>Integrade RSS news feeds into your CMS page.</dd>',
            ),
            must_not_contain=(
                "Traceback", "XXX INVALID TEMPLATE STRING",
                "Form errors", "field is required",
            )
        )

    def test_basic(self):
        self._test(
            '{% lucidTag sub_menu %}',
            must_contain=(
                '<p>********************************************************************************</p>',
                '<div class="PyLucidPlugins sub_menu" id="sub_menu_lucidTag">',
                '<li><a href="/en/example-pages/RSS/" hreflang="en" title="RSS feed test.">RSS</a></li>',
                '<li><a href="/en/example-pages/SourceCode/" hreflang="en" title="SourceCode">sourcecode</a></li>',
                '<p>^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</p>',
            )
        )

    def test_use_title(self):
        self._test(
            '{% lucidTag sub_menu use_title=True %}',
            must_contain=(
                '<li><a href="/en/example-pages/RSS/" hreflang="en">RSS feed test.</a></li>',
                '<li><a href="/en/example-pages/SourceCode/" hreflang="en">SourceCode</a></li>',
            )
        )



if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    management.call_command('test', __file__,
        verbosity=2,
#        failfast=True
    )

########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

"""
    PyLucid sub_menu plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Generates a link list of all sub pages.

    :copyleft: 2005-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""



from pylucid_project.apps.pylucid.models import PageTree, PageMeta, Language
from pylucid_project.apps.pylucid.decorators import render_to


@render_to()
def lucidTag(request, use_title=False, template_name="sub_menu/sub_menu.html"):
    """
    build the sub menu with all existing sub pages.
    
    Used the page name as link text as default.
    Set **use_title=True** to use the page title.
    
    Set with **template_name** a own template.
    There exist a second template: **sub_menu/verbose_sub_menu.html**
    
    example:
        {% lucidTag sub_menu %}
        {% lucidTag sub_menu use_title=True %}
        {% lucidTag sub_menu template_name="sub_menu/verbose_sub_menu.html" %}
    """
    pagetree = request.PYLUCID.pagetree # current models.PageContent instance
    current_lang = request.PYLUCID.current_language # Client prefered language
    default_lang = Language.objects.get_or_create_default(request) # System default language

    # Build a PageTree ID list of all accessible subpages
    queryset = PageTree.objects.all_accessible(request.user, filter_showlinks=True)
    queryset = queryset.filter(parent=pagetree)
    sub_pagetree_ids = queryset.values_list("id", flat=True)

    # Get PageMeta in client prefered language
    queryset = PageMeta.objects.filter(language=current_lang)
    pagemeta1 = queryset.filter(pagetree__in=sub_pagetree_ids).select_related()
    existing_pagetree1 = [pagemeta.pagetree.id for pagemeta in pagemeta1]

    # Build a list of all PageTree IDs witch haven't a PageMeta
    missing_pagetree1 = [id for id in sub_pagetree_ids if id not in existing_pagetree1]
    if not missing_pagetree1:
        # No missing languages -> Use the source queryset
        sub_pages = list(pagemeta1)
    else: # Some pages didn't exist in current language -> use system default language
        queryset = PageMeta.objects.filter(language=default_lang)
        pagemeta2 = queryset.filter(pagetree__in=missing_pagetree1).select_related()

        # PageMeta in current language + PageMeta in system default language
        sub_pages = list(pagemeta1) + list(pagemeta2)

        # Build a list of existing PageMeta
        existing_pagetree2 = [pagemeta.pagetree.id for pagemeta in sub_pages]
        # Exist there pages not in Client prefered language and not in System default language?
        missing_pagetree2 = [id for id in sub_pagetree_ids if id not in existing_pagetree2]
        if missing_pagetree2: # There are still missing PageMeta.
            queryset = PageMeta.objects.exclude(language=current_lang).exclude(language=default_lang)
            sub_pages3 = queryset.filter(pagetree__in=missing_pagetree2).select_related()

            # merge sub pages
            sub_pages += list(sub_pages3)

    # sort by PageTree positions 
    sub_pages.sort(cmp=lambda x, y: cmp(x.pagetree.position, y.pagetree.position))

    context = {
        "sub_pages": sub_pages,
        "use_title": use_title,
        "template_name": template_name,
    }
    return context












########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

# XXX: why doesn't this work: from system.admin_views import base_check, timezone
from admin_views import base_check, timezone

urlpatterns = patterns('',
    url(r'^base_check/$', base_check, name='System-base_check'),
    url(r'^timezone/$', timezone, name='System-timezone'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8

from datetime import datetime, timedelta
from smtplib import SMTPException
from tempfile import gettempdir
import os

from django.conf import settings
from django.core.cache import cache
from django.core.mail import send_mail, mail_admins
from django.db import connection
from django.utils.safestring import mark_safe
from django.utils.translation import ugettext as _
from django.utils.tzinfo import FixedOffset

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.models import Language, PageTree, PageMeta, LogEntry, EditableHtmlHeadFile
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu
from pylucid_project.utils.SimpleStringIO import SimpleStringIO
from pylucid_project.utils.timezone import utc_offset
import pprint
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS



MYSQL_ENCODING_VARS = (
    "character_set_server", "character_set_connection", "character_set_results", "collation_connection",
)


def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("system")

    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="base check", title="A basic system setup check.",
        url_name="System-base_check"
    )
    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="timezone info", title="Information about timezone settings.",
        url_name="System-timezone"
    )

    return "\n".join(output)

#-----------------------------------------------------------------------------

def _cache_backend_test(request, out):

    only_dummy_cache = None

    if hasattr(settings, "CACHE_BACKEND"):
        out.write(_("\tsettings.CACHE_BACKEND is '%s'") % settings.CACHE_BACKEND)
        if settings.CACHE_BACKEND.startswith("dummy") or settings.CACHE_BACKEND.startswith("locmem"):
            out.write(_("\tPlease setup CACHE_BACKEND in you local_settings.py!"))
            tempdir = gettempdir()
            out.write(_("\te.g.: CACHE_BACKEND='file://%s'") % os.path.join(tempdir, "PyLucid_cache"))
            only_dummy_cache = True
        else:
            only_dummy_cache = False
    else:
        out.write(_("\tsettings.CACHES is:"))
        out.write(pprint.pformat(settings.CACHES))

        if settings.CACHES['default']['BACKEND'] == 'django.core.cache.backends.locmem.LocMemCache':
            out.write(_("\tPlease setup CACHES in you local_settings.py!"))
            only_dummy_cache = True
        else:
            only_dummy_cache = False

    out.write("")

    if not only_dummy_cache:
        cache_key = "cache_test"
        content = "A cache test content..."
        cache_timeout = 50
        cache.set(cache_key, content, cache_timeout)
        cached_content = cache.get(cache_key)
        if cached_content == content:
            out.write(_("\t* OK, cache works fine ;)"))
        else:
            out.write(_("\t* ERROR: Cache didn't work! (Get %r back.)" % cached_content))

        cache.delete(cache_key)
        cached_content = cache.get(cache_key)
        if cached_content != None:
            out.write(_("\t* Error: entry not deleted!"))

    if getattr(settings, "COMPRESS", False) != True:
        out.write(_("\n\tYou should activate django-compressor with COMPRESS=True in you local_settings.py!"))

    out.write("\n" + _("more info:"))
    out.write(mark_safe('\t<a href="http://www.pylucid.org/permalink/139/advanced-steps">PyLucid advanced install steps</a>'))
    out.write(mark_safe(_('\t<a href="http://docs.djangoproject.com/en/dev/topics/cache/#setting-up-the-cache">django cache documentation</a>')))

#-----------------------------------------------------------------------------


def _database_encoding_test(request, out):
    """
    Simple database encoding test:
        insert a test string into the database and check if 
        it is the same if we get the same entry back
    Use the PyLucid log table
    """
    out.write("Info: Not all database engines passed all tests!")

    def _test(range_txt, chr_range):
        out.write("\t%s test:" % range_txt)
        TEST_STRING = u"".join([unichr(i) for i in chr_range])
        try:
            log_entry1 = LogEntry.objects.log_action(
                "pylucid_plugin.system", "Database encoding test", request,
                message="%s test" % range_txt, long_message=TEST_STRING
            )
        except Warning, err:
            out.write("\t\tError: get a warning: %s" % err)
            return

        log_entry_id = log_entry1.id
        log_entry2 = LogEntry.objects.get(id=log_entry_id)
        if TEST_STRING == log_entry2.long_message:
            log_entry2.message += " - passed"
            out.write("\t\ttest passed")
        else:
            out.write("\t\ttest *NOT* passed")
            log_entry2.message += " - failed"
        log_entry2.save()

    _test("ASCII (32-126)", xrange(32, 126))
    _test("latin-1 (128-254)", xrange(128, 254))
    _test("ASCII control characters (0-31)", xrange(0, 31))
    _test("unicode plane 1-3 (0-12286 in 16 steps)", xrange(0, 12286, 16))
    _test("all unicode planes (0-65534 in 256 steps)", xrange(0, 65534, 256))



#-----------------------------------------------------------------------------

class PluginTest(object):
    PLUGIN_MODULE_CHECK = ("urls", "models", "views", "admin_urls", "admin_views")
    PLUGIN_OBJECT_CHECK = (
            ("admin_urls", "urlpatterns"),
    )
    def __init__(self, request, out):
        self.request = request
        self.out = out

        for plugin_name, plugin_instance in PYLUCID_PLUGINS.iteritems():
            if plugin_name == "pylucid":
                continue
            out.write("\tplugin: %r" % plugin_name)
            out.write("\t\tpath: %r" % plugin_instance.fs_path)
            self.test_objects(plugin_instance)
            self.test_modules(plugin_instance)

    def test_module(self, plugin_instance, mod_name):
        try:
            plugin_instance.get_plugin_module(mod_name)
        except plugin_instance.ObjectNotFound, err:
            if settings.DEBUG:
                self.out.write("\t\tDebug: Has no %r, ok." % mod_name)
            return False
        except Exception, err:
            self.out.write("\t\t*** Error importing %r:\n\t\t*** %s" % (mod_name, err))
            return False
        else:
            return True

    def test_modules(self, plugin_instance):
        for mod_name in self.PLUGIN_MODULE_CHECK:
            self.test_module(plugin_instance, mod_name)

    def test_objects(self, plugin_instance):
        for mod_name, obj_name in self.PLUGIN_OBJECT_CHECK:
            if not self.test_module(plugin_instance, mod_name):
                # skip to get the object, if module doesn't exists
                continue

            try:
                plugin_instance.get_plugin_object(mod_name, obj_name)
            except plugin_instance.ObjectNotFound, err:
                if settings.DEBUG:
                    self.out.write("\t\tDebug: Has no %r, ok." % obj_name)
            except Exception, err:
                self.out.write("Error importing %r from %r: %s" % (obj_name, mod_name, err))

#-----------------------------------------------------------------------------

@check_permissions(superuser_only=True)
@render_to("system/base_check.html")
def base_check(request):
    out = SimpleStringIO()

    if settings.DEBUG:
        out.write(
            "*** Error: settings.DEBUG in on!"
            " (Should be off in productive environments!)"
        )
        out.write("\n" + _("more info:"))
        out.write(mark_safe('\t<a href="http://docs.djangoproject.com/en/dev/ref/settings/#debug">django documentation</a>'))
    else:
        out.write("settings.DEBUG, ok")
    out.write("\n" + "- " * 40)


    if settings.PYLUCID.I18N_DEBUG:
        out.write(
            "\n*** Error: pylucid app_settings.I18N_DEBUG is on!"
            " (Should be off in productive environments!)"
        )
    else:
        out.write("\npylucid app_settings.I18N_DEBUG, ok.")
    out.write("\n" + "- " * 40)


    if settings.SECRET_KEY == "":
        out.write(
            "\n*** Error: settings.SECRET_KEY not set!"
            " (You should add it into local-settings.py!)"
        )
        out.write("\n" + _("more info:"))
        out.write(mark_safe('\t<a href="http://docs.djangoproject.com/en/dev/ref/settings/#secret-key">django documentation</a>'))
    else:
        out.write("\nsettings.SECRET_KEY, ok.")
    out.write("\n" + "- " * 40)

    if "mysql" in settings.DATABASES['default']['ENGINE']:
        try:
            import MySQLdb
            out.write("MySQLdb.__version__  : %s" % repr(MySQLdb.__version__))
            out.write("MySQLdb.version_info : %s" % repr(MySQLdb.version_info))
        except Exception, err:
            out.write("MySQLdb info error: %s" % err)

        cursor = connection.cursor()
        out.write("\nSome MySQL encoding related variables:")

        for var_name in MYSQL_ENCODING_VARS:
            cursor.execute("SHOW VARIABLES LIKE %s;", (var_name,))
            raw_result = cursor.fetchall()
            try:
                result = raw_result[0][1]
            except IndexError, err:
                out.write("%30s: Error: %s (raw result: %r)" % (var_name, err, raw_result))
            else:
                out.write("%30s: %s" % (var_name, result))
        out.write("- "*40)


    out.write("\nDatabase unicode test:\n")
    _database_encoding_test(request, out)
    out.write("\n" + "- " * 40)

    out.write("\nTest cache backend:\n")
    _cache_backend_test(request, out)
    out.write("\n" + "- " * 40)

    out.write("\nTest plugins:\n")
    PluginTest(request, out)
    out.write("\n" + "- " * 40)

    try:
        lang_entry = Language.objects.get(code=settings.LANGUAGE_CODE)
    except Language.DoesNotExist, err:
        out.write("\n*** Error: LANGUAGE_CODE %r doesn't exist!" % settings.LANGUAGE_CODE)
        languages = Language.objects.values_list("code", flat=True)
        out.write("\tExisting languages are: %r" % languages)
        out.write("\tset/change LANGUAGE_CODE in local-settings.py or create language %r." % settings.LANGUAGE_CODE)
    else:
        out.write("\nsettings.LANGUAGE_CODE, ok.")
    out.write("\n" + "- " * 40)

    out.write("\nCheck if all PageTree has at lease a PageMeta instance in the default system language:")
    default_lang_entry = Language.objects.get_or_create_default(request)
    exist_all = True
    # TODO: Can we but this into a big QuerySet?
    for pagetree in PageTree.on_site.all():
        exist = PageMeta.objects.filter(pagetree=pagetree, language=default_lang_entry)
        if not exist:
            exist_all = False
            out.write(
                "*** Error: PageTree entry %r has no PageMeta in default language (%r)!!!" % (
                    pagetree, default_lang_entry
                )
            )
    if exist_all:
        out.write("ok.")
    out.write("\n" + "- " * 40 + "\n")

    out.write(
        "\nSent this base check output to settings.ADMINS: %r\n" %
            ", ".join(["%s <%s>" % i for i in settings.ADMINS])
    )

    output = "\n".join(out.getlines())

    try:
        mail_admins("Base check.", output, fail_silently=True, connection=None, html_message=None)
    except SMTPException, err:
        output += "\nMail send error: %s" % err
    else:
        output += "\nMail send to all admins, ok"

    output += "\n\n- END -"

    context = {
        "title": "Basic system setup check",
        "results": output,
    }
    return context




@check_permissions(superuser_only=True)
@render_to("system/timezone.html")
def timezone(request):
    """
    Display some informations about timezone
    """
    # get a timestamp from Django ORM datetime with 'auto_now_add'
    temp_log_entry = LogEntry.objects.log_action("pylucid_plugin.system", "timezone test", request)
    auto_now_add = temp_log_entry.createtime
    temp_log_entry.delete()

    context = {
        "datetime_now": datetime.now(),
        "datetime_utcnow": datetime.utcnow(),
        "auto_now_add": auto_now_add,
        "settings_TIME_ZONE": settings.TIME_ZONE,
        "environ_TZ": os.environ.get("TZ", "----"),
        "utc_offset": utc_offset(),
    }
    return context


########NEW FILE########
__FILENAME__ = views
# -*- coding: utf-8 -*-

"""
    PyLucid tag navigation
    ~~~~~~~~~~~~~~~~~~~~~~
    
    A tag based navigation.

    :copyleft: 2008-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v2 or above, see LICENSE for more details
"""

from django.utils.translation import ugettext as _

# http://code.google.com/p/django-tagging/
from tagging.models import Tag, TaggedItem

from pylucid_project.apps.pylucid.models import PageMeta
from pylucid_project.apps.pylucid.decorators import render_to



@render_to("tag_navi/tag_list.html")#, debug=True)
def http_get_view(request):
    tags = request.GET["tag_navi"]
    entries = TaggedItem.objects.get_by_model(PageMeta, tags)

    # add breadcrumb link
    context = request.PYLUCID.context
    breadcrumb_context_middlewares = request.PYLUCID.context_middlewares["breadcrumb"]
    title = _("All '%s' tagged items" % tags)
    breadcrumb_context_middlewares.add_link(title, title, url=request.get_full_path())

    context = {
        "page_robots": "noindex,nofollow",
        "entries": entries,
        "tags": tags,
    }
    return context

@render_to("tag_navi/tag_link_list.html")#, debug=True)
def lucidTag(request):
    current_pagemeta = request.PYLUCID.pagemeta
    tags = current_pagemeta.tags
    context = {
        "pagemeta": current_pagemeta,
    }
    return context

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    from django.core import management
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.core.urlresolvers import reverse
from django.test import TestCase

from pylucid_project.apps.pylucid.models import PageMeta
from pylucid_project.tests.test_tools import basetest



class TOC_Test(basetest.BaseUnittest):
    def test_toc(self):
        pagemeta = PageMeta.objects.get(name="creole")
        url = pagemeta.get_absolute_url()
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                '<div class="PyLucidPlugins TOC" id="TOC_lucidTag">',

                '<ol><h3 class="toc_headline">table of contents</h3>',
                '<li><a href="#Top-level-heading-1" title="go down to this section">&darr;&nbsp;Top-level heading (1)</a></li>',

                '<h1 id="Top-level-heading-1" class="headline_anchor">',
                '<a href="#top" title="go top" class="top_link"><span class="uarr">&uarr;&nbsp;</span>Top-level heading (1)</a>',
                '<a title="Permalink to this section" href="/permalink/17/the-buildin-creole-markup#Top-level-heading-1" class="section_anchor">&nbsp;#</a>',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )


if __name__ == "__main__":
    # Run all unittest directly
#    management.call_command('test', "pylucid_plugins.design.tests.SwitchDesignTest",
#        verbosity=2,
#        failfast=True
#    )
    management.call_command('test', __file__,
        verbosity=2,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid 'table of contents' plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

from django.conf import settings
from django.contrib import messages
from django.utils.translation import ugettext as _


def lucidTag(request, min=3):
    """
    Table of contents
    Build a list of all headlines.
    
    Can be inserted into PageContent or into global template.
    
    TOC is displayed only if there exists at least the
    specified number of headings. (lucidTag parameter 'min')
    
    example:
        {% lucidTag TOC %}
        {% lucidTag TOC min=4 %}
    """
    try:
        min = int(min)
    except Exception, err:
        if settings.DEBUG or request.user.is_staff:
            messages.debug(request,
                _("'min' parameter in lucidTag TOC must be a integer! Error: %s") % err
            )
        min = 3
#
#CSS_PLUGIN_CLASS_NAME
#css_plugin_class
#css_plugin_id

    # Just save the toc_min_count and return the placeholder
    # The real work would be done in:
    # pylucid_project.middlewares.headline_anchor.HeadlineAnchorMiddleware
    request.PYLUCID._toc_min_count = min

    # Activate HeadlineAnchorMiddleware
    request.HeadlineAnchor = True

    return settings.PYLUCID.TOC_PLACEHOLDER


########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from tools import admin_views

urlpatterns = patterns('',
    url(r'^highlight_code/$', admin_views.highlight_code, name='Tools-highlight_code'),
    url(r'^cleanup_log/$', admin_views.cleanup_log, name='Tools-cleanup_log'),
    url(r'^cleanup_session/$', admin_views.cleanup_session, name='Tools-cleanup_session'),
    url(r'^cleanup_cache/$', admin_views.cleanup_cache, name='Tools-cleanup_cache'),
    url(r'^override_template/$', admin_views.override_template, name='Tools-override_template'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8

import os
import time
from datetime import datetime, timedelta


if __name__ == "__main__":
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"
    virtualenv_file = "../../../../../bin/activate_this.py"
    execfile(virtualenv_file, dict(__file__=virtualenv_file))


from django import http
from django.conf import settings
from django.contrib import messages
from django.contrib.sessions.models import Session
from django.contrib.sites.models import Site
from django.core.cache import cache
from django.core.urlresolvers import reverse
from django.http import HttpResponseRedirect
from django.utils.translation import ugettext as _

from dbtemplates.models import Template

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid.markup.hightlighter import make_html
from pylucid_project.apps.pylucid.models import LogEntry
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu

from .forms import HighlightCodeForm, CleanupLogForm, SelectTemplateForm, CleanCacheForm


MYSQL_ENCODING_VARS = (
    "character_set_server", "character_set_connection", "character_set_results", "collation_connection",
)


def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)

    menu_section_entry = admin_menu.get_or_create_section("tools")
    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="highlight code", title="highlight sourcecode with pygments",
        url_name="Tools-highlight_code"
    )

    menu_section_entry = admin_menu.get_or_create_section("edit look")
    admin_menu.add_menu_entry(
        parent=menu_section_entry, name="override template",
        title="Overwrite a filesystem template with a new database headfile entry",
        url_name="Tools-override_template"
    )

    menu_section_entry = admin_menu.get_or_create_section("cleanup")
    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="cleanup log table", title="Cleanup the log table",
        url_name="Tools-cleanup_log"
    )
    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="cleanup session table", title="Cleanup the session table",
        url_name="Tools-cleanup_session"
    )
    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="cleanup cache", title="Remove everything from the Django's cache framework.",
        url_name="Tools-cleanup_cache"
    )

    return "\n".join(output)

#-----------------------------------------------------------------------------

@check_permissions(superuser_only=False, permissions=(u'pylucid.change_pagecontent',))
@render_to("tools/highlight_code.html")
def highlight_code(request):
    """ hightlight sourcecode for copy&paste """
    context = {
        "title": _("hightlight sourcecode"),
        "form_url": request.path,
    }
    if request.method == "POST":
        form = HighlightCodeForm(request.POST)
        if form.is_valid():
            sourcecode = form.cleaned_data["sourcecode"]
            source_type = form.cleaned_data["source_type"]

            highlighted = make_html(sourcecode, source_type, django_escape=True)
            context["highlighted"] = highlighted

            html_code = make_html(highlighted, "html", django_escape=True)
            context["html_code"] = html_code
    else:
        form = HighlightCodeForm()

    context["form"] = form
    return context



@check_permissions(superuser_only=True)
@render_to("tools/cleanup_log.html")
def cleanup_log(request):
    """ Delete old log entries """
    context = {
        "title": _("Delete old log entries"),
        "form_url": request.path,
        "count_on_site": LogEntry.on_site.count(),
        "count_total": LogEntry.objects.count(),
        "oldest_on_site_entry": LogEntry.on_site.all().only("createtime").order_by('createtime')[0],
        "oldest_total_entry": LogEntry.objects.all().only("createtime").order_by('createtime')[0],
    }
    if request.method == "POST":
        form = CleanupLogForm(request.POST)
        if form.is_valid():
            start_time = time.time()
            number = form.cleaned_data["number"]
            delete_type = form.cleaned_data["delete_type"]
            limit_site = form.cleaned_data["limit_site"]

            if limit_site:
                queryset = LogEntry.on_site
            else:
                queryset = LogEntry.objects

            queryset = queryset.order_by('-createtime')

            if delete_type == CleanupLogForm.LAST_NUMBERS:
                ids = tuple(queryset[number:].values_list('id', flat=True))
                queryset = queryset.filter(id__in=ids)
            else:
                if delete_type == CleanupLogForm.LAST_DAYS:
                    delta = timedelta(days=number)
                elif delete_type == CleanupLogForm.LAST_HOURS:
                    delta = timedelta(hours=number)
                else:
                    raise AssertionError("Wrong delete_type") # should never happen

                now = datetime.now()
                datetime_filter = now - delta
                queryset = queryset.exclude(createtime__gte=datetime_filter)

            delete_count = queryset.count()
            queryset.delete()
            duration_time = time.time() - start_time
            messages.info(request, _("Delete %(count)s entries in %(duration).2fsec") % {
                "count": delete_count, "duration":duration_time
            })
            return HttpResponseRedirect(request.path)
    else:
        form = CleanupLogForm()

    context["form"] = form
    return context


@check_permissions(superuser_only=True)
@render_to("tools/cleanup_session.html")
def cleanup_session(request):
    """ Delete old session entries """

    count_before = Session.objects.count()
    start_time = time.time()
    Session.objects.filter(expire_date__lt=datetime.now()).delete()
    duration_time = time.time() - start_time
    count_after = Session.objects.count()

    delete_count = count_before - count_after
    messages.info(request, _("Delete %(count)s entries in %(duration).2fsec") % {
        "count": delete_count, "duration":duration_time
    })

    context = {
        "title": _("Delete old session entries"),
        "count_before": count_before,
        "count_after": count_after,
        "count_deleted": delete_count,
    }
    return context


@check_permissions(superuser_only=True)
@render_to("tools/cleanup_cache.html")
def cleanup_cache(request):
    """ remove everything from the cache """
    if request.method != "POST":
        form = CleanCacheForm()
    else:
        form = CleanCacheForm(request.POST)
        if form.is_valid():
            update_type = form.cleaned_data["update_type"]
            start_time = time.time()
            if update_type == CleanCacheForm.SMOOTH:
                try:
                    cache.smooth_update()
                except AttributeError, err:
                    messages.error(request, _("Error: %s (django-tools SmoothCacheBackend not used?") % err)
                    return HttpResponseRedirect(request.path)
            elif update_type == CleanCacheForm.CLEAR:
                cache.clear()
            else:
                raise # Should never happen
            duration_time = time.time() - start_time
            messages.success(request, _("Everything from the Django's cache framework was deleted in %(duration).2fsec") % {
                "duration":duration_time
            })
            return HttpResponseRedirect(request.path)

    context = {
        "title": _("Remove everything from the Django's cache framework."),
        "form": form,
    }
    return context


#-----------------------------------------------------------------------------------------------------------
# override template


class TemplateFile(object):
    def __init__(self, request, fs_path):
        self.request = request
        self.fs_path = fs_path

        self.name = fs_path.rsplit("templates", 1)[1].lstrip("/")

    def _get_fs_content(self):
        try:
            f = file(self.fs_path, "r")
            content = f.read()
            f.close()
        except Exception, err:
            messages.error(request, "Can't read file: %s" % err)
        else:
            return content

    def get_or_create_dbtemplate(self):
        """
        create a dbtemplate entry with the content form filesystem.
        return the dbtemplate instance if success, otherwise: create a page_msg and return None
        """
        content = self._get_fs_content()
        if not content:
            # Content can't readed.
            return

        template, created = Template.objects.get_or_create(name=self.name,
            defaults={"content": content}
        )
        if created:
            template.save()
            current_site = Site.objects.get_current()
            template.sites.add(current_site)
            template.save()
        return template, created

    def get_content_preview(self):
        content = self._get_fs_content()
        if not content:
            # Can't read the template content, page_msg was created.
            return

        ext = os.path.splitext(self.fs_path)[1]
        html = make_html(content, ext, django_escape=True)
        return html



@check_permissions(
    superuser_only=False,
    permissions=(u'dbtemplates.add_template', u'dbtemplates.change_template')
)
@render_to("tools/override_template.html")
def override_template(request):
    """
    Overwrite a template:
    1. The user can choose between all existing template in filesystem.
    2. Read the content from filesystem and create a new dbtemplate entry.
    3. redirect to edit the nre dbtemplate entry
    """
    context = {
        "title": _("override template"),
        "form_url": request.path,
    }

    if request.method != "POST":
        form = SelectTemplateForm()
    else:
        form = SelectTemplateForm(request.POST)
        if form.is_valid():
            fs_path = form.cleaned_data["template"]
            template = TemplateFile(request, fs_path)

            if "preview" in request.POST:
                # Display only the template content
                preview_html = template.get_content_preview()
                if preview_html:
                    context["template"] = template
            else:
                # A new dbtemplate should be created
                instance, created = template.get_or_create_dbtemplate()
                if instance:
                    if created:
                        # New dbtemplate instance created -> edit it
                        # if instance == None: e.g.: error reading file -> page_msg was created
                        msg = _("New dbtemplate entry %s created.") % instance
                        LogEntry.objects.log_action(
                            app_label="pylucid_plugin.extrahead",
                            action="override template %s" % template.name,
                            request=request,
                            message=msg
                        )
                    else:
                        msg = _("dbtemplate entry %s already exists!") % instance

                    msg += _(" You can edit it now.")

                    messages.info(request, msg)

                    # redirect to edit the new dbtemplate entry
                    url = reverse("admin:dbtemplates_template_change", args=(instance.id,))
                    return http.HttpResponseRedirect(url)

    context["form"] = form
    return context


if __name__ == "__main__":
    templates = [TemplateDir(dir) for dir in settings.TEMPLATE_DIRS]

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

import os
import posixpath

if __name__ == "__main__":
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"
    virtualenv_file = "../../../../../bin/activate_this.py"
    execfile(virtualenv_file, dict(__file__=virtualenv_file))

from django import forms
from django.conf import settings
from django.utils.translation import ugettext_lazy as _

from pygments.lexers._mapping import LEXERS


SOURCE_CHOICES = []
for lexer in LEXERS.itervalues():
    name = lexer[1]
    aliases = lexer[2]
    try:
        alias = aliases[0]
    except IndexError:
        # Bug in Pygments v1.6rc1
        # Fixed in https://bitbucket.org/birkenfeld/pygments-main/issue/837/windows-registry-lexer-does-not-include
        # XXX remove if new bugfixed version on Pygments was released!
        continue
    SOURCE_CHOICES.append((alias, name))
SOURCE_CHOICES.sort()


class HighlightCodeForm(forms.Form):
    sourcecode = forms.CharField(widget=forms.Textarea)
    source_type = forms.ChoiceField(choices=SOURCE_CHOICES)


class CleanupLogForm(forms.Form):
    LAST_NUMBERS = "n"
    LAST_DAYS = "d"
    LAST_HOURS = "h"

    TYPE_CHOICES = (
        (LAST_NUMBERS, _("keep the last X entries")),
        (LAST_DAYS, _("keep entries from the last X days")),
        (LAST_HOURS, _("keep entries from the last X hours")),
    )
    number = forms.IntegerField(initial=7, min_value=0, help_text=_("Number of entries to be retained."))
    delete_type = forms.ChoiceField(initial=LAST_DAYS, choices=TYPE_CHOICES,
        help_text=_("Witch 'retained' type is the given number?")
    )
    limit_site = forms.BooleanField(initial=True, required=False,
        help_text=_("Limit the query to the current site?")
    )


#-----------------------------------------------------------------------------------------------------------


class CleanCacheForm(forms.Form):
    SMOOTH = "smooth"
    CLEAR = "clear"
    update_type = forms.ChoiceField(choices=(
        (SMOOTH, "cache.smooth_update() from django-tools"),
        (CLEAR, "cache.clear()")
    ))

#-----------------------------------------------------------------------------------------------------------
# override template


class Template(object):
    """ one template file """
    def __init__(self, path, filename, abs_path):
        self.path = path
        self.filename = filename
        self.abs_path = abs_path

    def get_choices(self):
        if "templates" in self.abs_path:
            path = self.abs_path.split("templates", 1)[1]
        else:
            path = self.abs_path
        path = posixpath.normpath(path)
        path = path.lstrip("/")
        return (self.abs_path, path)


class TemplateDir(object):
    """ all template in a settings.TEMPLATE_DIRS """
    def __init__(self, fs_path):
        self.fs_path = fs_path

        self.short_path = self._build_short_path()

        if not os.path.isdir(self.fs_path):
            print "Error: %r doesn't exist!!!" % self.fs_path

        self.templates = []
        self._get_all_files(self.fs_path)

    def _build_short_path(self):
        if self.fs_path.startswith(settings.PYLUCID_BASE_PATH):
            short_path = self.fs_path[len(settings.PYLUCID_BASE_PATH):]
        else:
            short_path = self.fs_path

        short_path = posixpath.normpath(short_path)
        short_path = short_path.strip("/")
        short_path = short_path.rsplit("templates", 1)[0]
        if "/src/" in short_path:
            short_path = short_path.split("/src/")[1]

        return short_path

    def _get_all_files(self, path):
        dir_items = os.listdir(path)
        for dir_item in dir_items:
            if dir_item.startswith("."): # Skip hidden items, e.g.: .svn
                continue

            abs_path = os.path.join(path, dir_item)
            if os.path.isfile(abs_path):
                self.templates.append(Template(path, dir_item, abs_path))
            elif os.path.isdir(abs_path):
                self._get_all_files(abs_path) # go recusive deeper
            else:
                raise AssertionError("item %r not file or dir" % abs_path)


class Templates(object):
    """ all templates """
    def __init__(self, template_dirs):
        self.template_dirs = template_dirs
        self.templates = {}
        for dir in template_dirs:
            self.templates[dir] = TemplateDir(dir)

    def get_choices(self):
        choices = []
        for dir in self.template_dirs:
            templates = self.templates[dir]
            dir_items = []
            for template in templates.templates:
                dir_items.append(template.get_choices())
            dir_items.sort()
            choices.append((templates.short_path, dir_items))

        choices.sort()
        return choices


class ChoiceTemplateField(forms.ChoiceField):
    def __init__(self, *args, **kwargs):
        super(ChoiceTemplateField, self).__init__(*args, **kwargs)

        templates = Templates(settings.TEMPLATE_DIRS)
        self.choices = [("", "---------")]
        self.choices += templates.get_choices()


class SelectTemplateForm(forms.Form):
    template = ChoiceTemplateField(
        initial="",
        help_text=_("Select the template you would like to overwrite in dbtemplate.")
    )


if __name__ == "__main__":
    from pprint import pprint

    form = SelectTemplateForm()
    pprint(form.fields["template"].choices)


########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin views url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from update_env import admin_views

urlpatterns = patterns('',
    url(r'^status/$', admin_views.status, name='Update-status'),
    url(r'^update/(?P<src_name>.*?)/$', admin_views.update, name='Update-update'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding: utf-8

"""
    PyLucid admin views
    ~~~~~~~~~~~~~~~~~~~

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import sys
import subprocess

from django import http
from django.conf import settings
from django.contrib import messages
from django.core import management
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.utils.SimpleStringIO import SimpleStringIO
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu




def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("tools")
    admin_menu.add_menu_entry(
        parent=menu_section_entry, url_name="Update-status",
        name="update virtualenv", title="Update virtual environment source packages",
    )

    return "\n".join(output)


def _get_env_path(request):
    env_path = request.META.get("VIRTUAL_ENV")
    if env_path is None:
        base_path = settings.PYLUCID_BASE_PATH
        messages.info(request,
            "Environment Variable 'VIRTUAL_ENV' not set."
            " Try to use %r" % base_path
        )
        try: # FIXME: do this better ;)
            env_path, rest = base_path.split(os.sep + "src" + os.sep)
        except ValueError:
            messages.error(request, "Can't split %r" % base_path)
            return

    if not os.path.isdir(env_path):
        messages.error(request,
            "Error: Env.path %r doesn't exist."
            " (used from Environment Variable 'VIRTUAL_ENV')" % env_path
        )
        return

    return env_path


class Package(object):
    SVN = 1
    GIT = 2
    STATUS_CMD = {
        SVN: ["svn", "info"],
        GIT: ["git", "log", "-1", "HEAD"],
    }
    UPDATE_CMD = {
        SVN: ["svn", "update"],
        GIT: ["git", "pull", "origin"]
    }

    def __init__(self, path):
        self.path = path
        self.name = os.path.basename(path)
        self.output = u"Not collected yet."

        if os.path.isdir(os.path.join(path, ".svn")):
            self.type = self.SVN
        elif os.path.isdir(os.path.join(path, ".git")):
            self.type = self.GIT
        else:
            self.type = None

    def _cmd(self, cmd_dict):
        """ subprocess the VCS command and store ouput in self.output """
        assert self.type is not None
        cmd = cmd_dict[self.type]

        process = subprocess.Popen(
            cmd, cwd=self.path,
            stdout=subprocess.PIPE, stderr=subprocess.PIPE
        )
        self.output = process.stdout.read()
        self.output += process.stderr.read()

    def collect_status(self):
        """ call STATUS_CMD and save the output in self.output """
        self._cmd(self.STATUS_CMD)

    def update(self):
        """ call UPDATE_CMD and save the output in self.output """
        self._cmd(self.UPDATE_CMD)


class VCS_info(object):
    def __init__(self, env_path):
        self.env_path = env_path

        self.package_info = {}

        self.read_src()
        self.read_external_plugins()

    def _add_path(self, abs_path):
        package = Package(abs_path)
        if package.type is not None:
            self.package_info[package.name] = package

    def read_src(self):
        """
        init packages from PyLucid_env/src/
        """
        base_path = os.path.join(self.env_path, "src")
        for dir in os.listdir(base_path):
            abs_path = os.path.join(base_path, dir)
            self._add_path(abs_path)

    def read_external_plugins(self):
        """
        init packages from PyLucid_env/src/pylucid/pylucid_project/external_plugins/
        """
        base_path = os.path.join(self.env_path, "src", "pylucid", "pylucid_project", "external_plugins")
        for dir in os.listdir(base_path):
            abs_path = os.path.join(base_path, dir)
            if not os.path.islink(abs_path):
                self._add_path(abs_path)
            else:
                # dissolving symlinks
                real_path = os.path.realpath(abs_path)
                plugin_base_path = os.path.split(real_path)[0] # PyLucid plugins used a subdirectory
                self._add_path(plugin_base_path)

    def collect_all_status(self):
        """
        Collect 'SVN info' or 'git log' for all packages.
        """
        for package in self.package_info.values():
            package.collect_status()




@check_permissions(superuser_only=True)
@render_to("update_env/status.html")
def status(request):
    """
    Update virtual environment source packages
    """
    context = {
        "title": _("virtual environment source package status"),
        "form_url": request.path,
    }
    env_path = _get_env_path(request)
    if env_path is None:
        return context # virtualenv path unknown, page_mags was created

    vcs_info = VCS_info(env_path)
    vcs_info.collect_all_status()

    context.update({
        "env_path": env_path,
        "vcs_info": vcs_info,
    })
    return context


@check_permissions(superuser_only=True)
@render_to("update_env/update.html")
def update(request, src_name):
    context = {
        "title": _("Update source package '%s'" % src_name),
        "form_url": request.path,
    }
    env_path = _get_env_path(request)
    if env_path is None:
        return context # virtualenv path unknown, page_mags was created

    vcs_info = VCS_info(env_path)
    if src_name not in vcs_info.package_info:
        messages.error(request, "Wrong package!")
        return context

    package = vcs_info.package_info[src_name]
    package.update()

    context.update({
        "env_path": env_path,
        "package": package
    })
    return context

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    from django.core import management
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.core.urlresolvers import reverse

from pylucid_project.tests.test_tools import basetest



class UpdateEnvTest(basetest.BaseUnittest):

    def _pre_setup(self, *args, **kwargs):
        """ create some blog articles """
        super(UpdateEnvTest, self)._pre_setup(*args, **kwargs)
        self.status_url = reverse("Update-status")

    def test_anonymous(self):
        response = self.client.get(self.status_url)
        self.assertRedirect(response, url="http://testserver/?auth=login&next_url=" + self.status_url)

    def test_status_page(self):
        self.login("superuser")
        response = self.client.get(self.status_url)
        self.assertResponse(response,
            must_contain=(
                "<title>PyLucid - virtual environment source package status</title>",
                "<pre>commit", "Author:",
                '<a href="/pylucid_admin/plugins/update_env/update/django-tools/">',
                '<a href="/pylucid_admin/plugins/update_env/update/django/">',
                '<a href="/pylucid_admin/plugins/update_env/update/pylucid/">',
            ),
            must_not_contain=("Traceback", "XXX INVALID TEMPLATE STRING")
        )


if __name__ == "__main__":
    # Run all unittest directly
#    management.call_command('test', "pylucid_plugins.design.tests.SwitchDesignTest",
#        verbosity=2,
#        failfast=True
#    )
    management.call_command('test', __file__,
        verbosity=2,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = admin
# coding: utf-8

"""
    PyLucid.admin
    ~~~~~~~~~~~~~~

    Register all PyLucid model in django admin interface.

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2008 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.contrib import admin
from django.conf import settings
from django.contrib.auth.models import User, Permission
from django.contrib.auth.admin import UserAdmin

from update_journal.models import UpdateJournal, PageUpdateListObjects


class UpdateJournalAdmin(admin.ModelAdmin):
    list_display = ("id", "lastupdatetime", "user_name", "content_type", "object_url", "language", "title", "staff_only")
    list_display_links = ("object_url",)
    list_filter = ("user_name", "content_type", "staff_only")
#    date_hierarchy = 'lastupdatetime'
#    search_fields = ("headline", "content")

admin.site.register(UpdateJournal, UpdateJournalAdmin)

#class PageUpdateListObjectsAdmin(admin.ModelAdmin):
#    list_display = ("id", "content_type", "staff_only")
#    list_display_links = ("content_type",)
#    list_filter = ("content_type", "staff_only")
#
#admin.site.register(PageUpdateListObjects, PageUpdateListObjectsAdmin)

########NEW FILE########
__FILENAME__ = admin_urls
# coding: utf-8

"""
    PyLucid admin url patterns
    ~~~~~~~~~~~~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author:$

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django.conf.urls.defaults import patterns, url

from update_journal.admin_views import cleanup

urlpatterns = patterns('',
    url(r'^cleanup/$', cleanup, name='UpdateJournal-cleanup'),
)


########NEW FILE########
__FILENAME__ = admin_views
# coding:utf-8

from datetime import datetime, timedelta
import time

from django.conf import settings
from django.contrib import messages
from django.core.urlresolvers import resolve
from django.http import HttpResponseRedirect
from django.utils.translation import ugettext as _

from pylucid_project.apps.pylucid.decorators import check_permissions, render_to
from pylucid_project.apps.pylucid_admin.admin_menu import AdminMenu

from update_journal.models import UpdateJournal
from update_journal.forms import CleanupUpdateJournalForm


def install(request):
    """ insert PyLucid admin views into PageTree """
    output = []

    admin_menu = AdminMenu(request, output)
    menu_section_entry = admin_menu.get_or_create_section("cleanup")

    admin_menu.add_menu_entry(
        parent=menu_section_entry,
        name="cleanup update journal", title="Delete dead links from update journal",
        url_name="UpdateJournal-cleanup"
    )

    return "\n".join(output)

#-----------------------------------------------------------------------------


@check_permissions(superuser_only=False,
    permissions=(u'update_journal.delete_updatejournal', u'update_journal.delete_pageupdatelistobjects')
)
@render_to("update_journal/cleanup.html")
def cleanup(request):
    """ Remove dead links and delete old entries from update journal """
    context = {
        "title": _("Remove dead links and delete old entries from update journal"),
        "form_url": request.path,
    }
    if request.method == "POST":
        form = CleanupUpdateJournalForm(request.POST)
        if "dead_entries" in request.POST:
            # remove only dead entries
            entries = UpdateJournal.on_site.all()
            bad_links_count = 0
            good_links_count = 0
            start_time = time.time()
            for entry in entries:
                url = entry.get_absolute_url()

                if "?" in url:
                    url = url.split("?", 1)[0] # remove GET parameters

                try:
                    resolve(url)
                except Exception, err:
                    entry.delete() #
                    bad_links_count += 1
                else:
                    good_links_count += 1

            duration_time = time.time() - start_time
            messages.info(request,
                "Checked links in %.2fsec.: %s bad links delete and %s good links found." % (
                    duration_time, bad_links_count, good_links_count
                )
            )
            return HttpResponseRedirect(request.path)

        elif form.is_valid():
            start_time = time.time()
            number = form.cleaned_data["number"]
            delete_type = form.cleaned_data["delete_type"]
            limit_site = form.cleaned_data["limit_site"]

            if limit_site:
                queryset = UpdateJournal.on_site
            else:
                queryset = UpdateJournal.objects

            queryset = queryset.order_by('-lastupdatetime')

            if delete_type == CleanupUpdateJournalForm.LAST_NUMBERS:
                ids = tuple(queryset[number:].values_list('id', flat=True))
                queryset = queryset.filter(id__in=ids)
            else:
                if delete_type == CleanupUpdateJournalForm.LAST_DAYS:
                    delta = timedelta(days=number)
                elif delete_type == CleanupUpdateJournalForm.LAST_HOURS:
                    delta = timedelta(hours=number)
                else:
                    raise AssertionError("Wrong delete_type") # should never happen

                now = datetime.now()
                datetime_filter = now - delta
                queryset = queryset.exclude(lastupdatetime__gte=datetime_filter)

            delete_count = queryset.count()
            queryset.delete()
            duration_time = time.time() - start_time
            messages.info(request, "Delete %s entries in %.2fsec" % (delete_count, duration_time))
            return HttpResponseRedirect(request.path)
    else:
        form = CleanupUpdateJournalForm()

    context["count_on_site"] = UpdateJournal.on_site.count()
    context["count_total"] = UpdateJournal.objects.count()
    context["form"] = form
    return context

########NEW FILE########
__FILENAME__ = forms
# coding: utf-8

from django import forms
from django.utils.translation import ugettext_lazy as _


class CleanupUpdateJournalForm(forms.Form):
    LAST_NUMBERS = "n"
    LAST_DAYS = "d"
    LAST_HOURS = "h"

    TYPE_CHOICES = (
        (LAST_NUMBERS, _("keep the last X entries")),
        (LAST_DAYS, _("keep entries from the last X days")),
        (LAST_HOURS, _("keep entries from the last X hours")),
    )
    number = forms.IntegerField(initial=7, min_value=0, help_text=_("Number of entries to be retained."))
    delete_type = forms.ChoiceField(initial=LAST_DAYS, choices=TYPE_CHOICES,
        help_text=_("Witch 'retained' type is the given number?")
    )
    limit_site = forms.BooleanField(initial=True, required=False,
        help_text=_("Limit the query to the current site?")
    )

########NEW FILE########
__FILENAME__ = models
# coding:utf-8

from django.db import models
from django.contrib.auth.models import User
from django.contrib.sites.models import Site
from django.utils.translation import ugettext_lazy as _
from django.contrib.contenttypes.models import ContentType
from django.contrib.sites.managers import CurrentSiteManager

from django_tools.fields.url import URLModelField2
from django_tools.models import UpdateInfoBaseModel

from pylucid_project.apps.pylucid.models import Language
from pylucid_project.base_models.base_models import BaseModel


class UpdateJournal(BaseModel):
    """
    List of all last update data, used for creating the last update table.
    
    inherited attributes from UpdateInfoBaseModel:
        get_absolute_uri()
    """
    lastupdatetime = models.DateTimeField(auto_now=True, help_text="Time of the last change.",)
    user_name = models.CharField(_("user's name"), max_length=50, blank=True)

    objects = models.Manager()

    site = models.ForeignKey(Site, default=Site.objects.get_current)
    on_site = CurrentSiteManager()

    # Content-object field
    content_type = models.ForeignKey(
        ContentType, verbose_name=_('content type'), related_name="content_type_set_for_%(class)s"
    )
    object_url = URLModelField2(verbose_name=_('object url'),
        help_text="absolute url to the item. (without protocol/domain!)",
        verify_exists=False, allow_schemes=None, allow_netloc=False,
    )

    language = models.ForeignKey(Language)

    title = models.CharField(blank=True, max_length=256,
        help_text="A long page title (for e.g. page title or link title text)"
    )
    staff_only = models.BooleanField(help_text="Viewable only by staff users?")

    def get_site(self):
        return self.site

    def get_absolute_url(self):
        return self.object_url

    def __unicode__(self):
        return u"Update Journal entry %r (id: %i, site: %s)" % (
            self.object_url, self.id, self.site.domain
        )

    class Meta:
        verbose_name = 'Update Journal entry'
        verbose_name_plural = 'Update Journal entries'
        ordering = ("-lastupdatetime",)


class PageUpdateListObjectsManager(models.Manager):
    def add_entry(self, model_instance):
        """
        Add a new update journal entry.
        Called by signal handler in update_journal/__init__.py
        """
        update_info = model_instance.get_update_info()
        if update_info == None:
            # This entry should not be inserted in the update journal
            return

        # delete same entries
        object_url = update_info["object_url"]
        UpdateJournal.on_site.all().filter(object_url=object_url).delete()

        if isinstance(update_info["user_name"], User):
            user = update_info["user_name"]
            user_name = user.get_full_name() or user.username
            update_info["user_name"] = user_name

        if update_info["user_name"] == None:
            update_info["user_name"] = ""

        content_type = ContentType.objects.get_for_model(model_instance)
        instance, created = PageUpdateListObjects.on_site.get_or_create(content_type=content_type)
        update_info.update({
            "staff_only": instance.staff_only,
            "content_type": content_type,
        })
        UpdateJournal(**update_info).save()


class PageUpdateListObjects(UpdateInfoBaseModel):
    """ Witch objects should be listed in the last update table? """
    objects = PageUpdateListObjectsManager()

    site = models.ForeignKey(Site, default=Site.objects.get_current)
    on_site = CurrentSiteManager()

    content_type = models.ForeignKey(
        ContentType, verbose_name=_('content type'), related_name="content_type_set_for_%(class)s"
    )
    staff_only = models.BooleanField(default=False, help_text="Viewable only by staff users?")

########NEW FILE########
__FILENAME__ = preference_forms
# coding: utf-8


"""
    PyLucid update journal preferences
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p
"""


from django import forms
from django.utils.translation import ugettext_lazy as _

from dbpreferences.forms import DBPreferencesBaseForm


class UpdateJournalPrefForm(DBPreferencesBaseForm):
    initial_feed_count = forms.IntegerField(
        initial=5, min_value=1,
        help_text=_("Default numbers of UpdateJournal entries in RSS/Atom feed."),
    )
    max_feed_count = forms.IntegerField(
        initial=30, min_value=1,
        help_text=_("The maximal numbers of UpdateJournal entries in RSS/Atom feed."),
    )
    current_language_only = forms.BooleanField(
        initial=True, required=False,
        help_text=_("Display only updates in current language (checked) or in every languages (unchecked).")
    )
    class Meta:
        app_label = 'update_journal'

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os

if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django.conf import settings
from django.test.client import Client
from django.core.urlresolvers import reverse

from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PluginPage, PageContent



class UpdateJournalTest(basetest.BaseLanguageTestCase):
    """
    inherited from BaseUnittest:
        - assertPyLucidPermissionDenied()
        - initial data fixtures with default test users
        - self.login()
    
    inherited from BaseLanguageTest:
        - self.default_language - system default Language model instance (default: en instance)
        - self.other_lang_code - alternative language code than system default (default: 'de')
        - self.other_language - alternative Language mode instance (default: de instance)
        - assertContentLanguage() - Check if response is in right language
    """
    def _pre_setup(self, *args, **kwargs):
        super(UpdateJournalTest, self)._pre_setup(*args, **kwargs)

        plugin_page = PluginPage.objects.get(app_label="pylucid_project.pylucid_plugins.update_journal")
        self.feed_base_url = plugin_page.pagetree.get_absolute_url()

    def test_select_page(self):
        """ Simply test if we get the find&replace form as a superuser. """
        language_code = self.default_language.code
        url = "/%s%s" % (language_code, self.feed_base_url)
        response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language_code)
        self.assertResponse(response,
            must_contain=(
                "Please select syndication feed format:",
                "feed.atom", "Atom Syndication Format",
                "feed.rss", "Really Simple Syndication",
            ),
            must_not_contain=("Traceback",)
        )

    def _test_atom_feed(self, language):
        language_code = language.code
        url = "/%s%sfeed.atom" % (language_code, self.feed_base_url)
        response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language_code)
        self.assertAtomFeed(response, language_code)

    def test_atom_feed_default_language(self):
        self._test_atom_feed(self.default_language)

    def test_atom_feed_other_language(self):
        self._test_atom_feed(self.other_language)

    def _test_rss_feed(self, language):
        language_code = language.code
        url = "/%s%sfeed.rss" % (language_code, self.feed_base_url)
        response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language_code)
        self.assertRssFeed(response, language_code)

    def test_rss_feed_default_language(self):
        self._test_rss_feed(self.default_language)

    def test_rss_feed_other_language(self):
        self._test_rss_feed(self.other_language)



if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management
    management.call_command('test', __file__,
        verbosity=1,
#        verbosity=0,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

from django.conf.urls.defaults import patterns, url

from update_journal import views

urlpatterns = patterns('',
    url(r'^(?P<filename>.+?)$', views.feed, name='UpdateJournal-feed'),
    url(r'^', views.select_feed, name='UpdateJournal-select_feed'),
)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8


"""
    PyLucid update journal plugin
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    Generate a list of the latest page updates.

    :copyleft: 2007-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p
"""


from django.conf import settings
from django.contrib import messages
from django.contrib.syndication.views import Feed
from django.core.urlresolvers import NoReverseMatch
from django.utils.feedgenerator import Rss201rev2Feed, Atom1Feed
from django.utils.translation import ugettext_lazy as _

from pylucid_project.apps.pylucid.decorators import render_to
from pylucid_project.utils.safe_obtain import safe_pref_get_integer
from pylucid_project.apps.pylucid.models import Language, PluginPage

from update_journal.models import UpdateJournal
from update_journal.preference_forms import UpdateJournalPrefForm


def _get_queryset(request, count):
    """ TODO: Move to UpdateJournal.objects ? """

    # get preferences
    pref_form = UpdateJournalPrefForm()
    pref_data = pref_form.get_preferences()

    queryset = UpdateJournal.on_site.all()

    if pref_data["current_language_only"]:
        lang_entry = request.PYLUCID.current_language
        language = lang_entry.pk
        queryset = queryset.filter(language=language)
    else:
        languages = request.PYLUCID.languages
        queryset = queryset.filter(language__in=languages)

    if not request.user.is_staff:
        queryset = queryset.filter(staff_only=False)

    return queryset[:count]


@render_to("update_journal/update_journal_table.html")
def lucidTag(request, count=10):
    try:
        count = int(count)
    except Exception, e:
        if request.user.is_staff:
            messages.error(request, "page_update_list error: count must be a integer (%s)" % e)
        count = 10

    queryset = _get_queryset(request, count)

    try:
        select_feed_url = PluginPage.objects.reverse("update_journal", "UpdateJournal-select_feed")
    except NoReverseMatch, err:
        select_feed_url = None
        if not settings.DEBUG and request.user.is_staff:
            # PluginPage.objects.reverse creates a page_msg only in DEBUG mode.
            messages.error(request, err)

    context = {
        "update_list": queryset,
        "select_feed_url": select_feed_url
    }
    return context


class RssFeed(Feed):
    feed_type = Rss201rev2Feed
    filename = "feed.rss"

    title = _("Update Journal - RSS feed")
    link = "/"
    description_template = "update_journal/feed_description.html"

    def __init__(self, request):
        self.request = request

        # Get max number of feed entries from request.GET["count"]
        # Validate/Limit it with information from DBPreferences 
        self.count, error = safe_pref_get_integer(
            request, "count", UpdateJournalPrefForm,
            default_key="initial_feed_count", default_fallback=5,
            min_key="initial_feed_count", min_fallback=5,
            max_key="max_feed_count", max_fallback=30
        )

    def description(self):
        return _("Last %s updates and changes") % self.count

    def items(self):
        return _get_queryset(self.request, self.count)

    def item_title(self, item):
        return item.title

    def item_link(self, item):
        return item.object_url


class AtomFeed(RssFeed):
    """
    http://docs.djangoproject.com/en/dev/ref/contrib/syndication/#publishing-atom-and-rss-feeds-in-tandem
    """
    feed_type = Atom1Feed
    filename = "feed.atom"
    title = _("Update Journal - Atom feed")
    subtitle = RssFeed.description


FEEDS = (AtomFeed, RssFeed)
FEED_FILENAMES = (AtomFeed.filename, RssFeed.filename)


@render_to("update_journal/select_feed.html")
def select_feed(request):
    """
    Display a list with existing feed filenames.
    """
    context = {"filenames": FEED_FILENAMES}
    return context


def feed(request, filename):
    """
    return RSS/Atom feed selected by filename.
    """
    #print filename
    for feed_class in FEEDS:
        if filename == feed_class.filename:
            break

    # client favoured Language instance:
    lang_entry = request.PYLUCID.current_language

    # Work-a-round for http://code.djangoproject.com/ticket/13896
    old_lang_code = settings.LANGUAGE_CODE
    settings.LANGUAGE_CODE = lang_entry.code

    feed = feed_class(request)
    response = feed(request)

    settings.LANGUAGE_CODE = old_lang_code

    return response

########NEW FILE########
__FILENAME__ = settings
# coding: utf-8

"""
    PyLucid.settings
    ~~~~~~~~~~~~~~~~

    Django settings for the PyLucid project.

    IMPORTANT:
        You should not edit this file!
        Owerwrite settings with a local settings file:
            local_settings.py

    Here are not all settings predifined you can use. Please look at the
    django documentation for a full list of all items:
        http://www.djangoproject.com/documentation/settings/

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import sys


try:
    #from django_tools.utils import info_print;info_print.redirect_stdout()
    import django
    import dbpreferences # http://code.google.com/p/django-dbpreferences/
    import django_tools # http://code.google.com/p/django-tools/
    import django_processinfo # https://github.com/jedie/django-processinfo
    import pylucid_project
    from pylucid_project.system.plugin_setup_info import PyLucidPluginSetupInfo
except Exception, e:
    import traceback
    sys.stderr.write(traceback.format_exc())
    raise


# include app settings from ./django_processinfo/app_settings.py
from django_processinfo import app_settings as PROCESSINFO


# Used by a few dynamic settings:
RUN_WITH_DEV_SERVER = "runserver" in sys.argv

def _pkg_path(obj):
    return os.path.abspath(os.path.dirname(obj.__file__))

#PYLUCID_BASE_PATH = os.path.abspath(os.path.dirname(pylucid_project.__file__))
PYLUCID_BASE_PATH = _pkg_path(pylucid_project)
DJANGO_BASE_PATH = _pkg_path(django)
#print "PYLUCID_BASE_PATH:", PYLUCID_BASE_PATH
#print "DJANGO_BASE_PATH:", DJANGO_BASE_PATH
#PYLUCID_PLUGINS_ROOT = os.path.abspath(os.path.dirname(pylucid_plugins.__file__))

#______________________________________________________________________________
# SYS PATH SETUP

_path_list = (
#    PYLUCID_PLUGINS_ROOT,
    PYLUCID_BASE_PATH,
    os.path.join(PYLUCID_BASE_PATH, "apps")
)
for path in _path_list:
    if path not in sys.path:
        sys.path.insert(0, path)

#______________________________________________________________________________
# DEBUGGING

DEBUG = False

# Append all SQL queries into the html page. (Works only if DEBUG==True)
# Should allways be False. It's only for developing! 
SQL_DEBUG = False

# See if request.PYLUCID attributes attached or changes (Works only if DEBUG==True)
# See also: http://www.pylucid.org/permalink/133/pylucid-objects#DEBUG
# Should allways be False. It's only for developing! 
PYLUCID_OBJECTS_DEBUG = False

# We must set a default DB settings here, otherwise management commands doesn't work.
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': 'PleaseOverwrite_DATABASES_settings',
    }
}

SITE_ID = 1 # Can be changed in local_settings


ROOT_URLCONF = 'pylucid_project.urls'


# activate django-tools DynamicSiteMiddleware:
USE_DYNAMIC_SITE_MIDDLEWARE = True

MIDDLEWARE_CLASSES = (
    # Save process informations. More info: https://github.com/jedie/django-processinfo
    'django_processinfo.middlewares.django_processinfo.ProcessInfoMiddleware',

    # Set request.debug bool value:
    'django_tools.debug.middlewares.SetRequestDebugMiddleware',

    # Block banned IP addresses and delete old pylucid.models.BanEntry items:
    'pylucid_project.middlewares.ip_ban.IPBanMiddleware',

    # Insert a statistic line into the generated page:
    'pylucid_project.middlewares.pagestats.PageStatsMiddleware',

    # Calls check_state() for every "Local sync cache" to reset out-dated caches
    'django_tools.local_sync_cache.LocalSyncCacheMiddleware.LocalSyncCacheMiddleware',

    # make the request object everywhere available with a thread local storage:
    'django_tools.middlewares.ThreadLocal.ThreadLocalMiddleware',

    # Set SITE_ID dynamically base on the current domain name:
    'django_tools.dynamic_site.middleware.DynamicSiteMiddleware',

    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.middleware.locale.LocaleMiddleware',

    # https://github.com/jedie/django-tools/blob/master/django_tools/cache/README.creole
    'django_tools.cache.site_cache_middleware.UpdateCacheMiddleware',
    'django_tools.cache.site_cache_middleware.FetchFromCacheMiddleware',

    'django.middleware.csrf.CsrfViewMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',

    # Create request.user_settings at process_request() and save it on process_response():
    'dbpreferences.middleware.DBPreferencesMiddleware',

    # Create request.PYLUCID and log process_exception(): 
    'pylucid_project.middlewares.pylucid_objects.PyLucidMiddleware',

    # slow down the django developer server
    # From http://code.google.com/p/django-tools/
#    'django_tools.middlewares.SlowerDevServer.SlowerDevServerMiddleware',

    'django.contrib.redirects.middleware.RedirectFallbackMiddleware',

    'django.middleware.transaction.TransactionMiddleware',
    'reversion.middleware.RevisionMiddleware',

    # Insert a html link anchor to all headlines:
    'pylucid_project.middlewares.headline_anchor.HeadlineAnchorMiddleware',

    # Set django message level by user type and system preferences:
    'pylucid_project.middlewares.message_level.MessageLevelMiddleware',

    # For PyLucid context middlewares API, see: http://www.pylucid.org/permalink/134/new-v09-plugin-api#context-middleware
    "pylucid_project.middlewares.context_middlewares.PyLucidContextMiddlewares",
)

# For django_tools.cache.site_cache_middleware
# https://github.com/jedie/django-tools/blob/master/django_tools/cache/README.creole
CACHE_MIDDLEWARE_ANONYMOUS_ONLY = True # Don't use cache for authenticated users

# Add stack information to every messages, but only if..
#     ...settings.DEBUG == True
# or
#     ...settings.MESSAGE_DEBUG == True
MESSAGE_STORAGE = "django_tools.utils.messages.StackInfoStorage"


# initialized all pylucid plugins
PYLUCID_PLUGIN_SETUP_INFO = PyLucidPluginSetupInfo(
    plugin_package_list=(
        (PYLUCID_BASE_PATH, "pylucid_project", "apps"), # base apps
        (PYLUCID_BASE_PATH, "pylucid_project", "pylucid_plugins"),
        (PYLUCID_BASE_PATH, "pylucid_project", "external_plugins"),
    ),
#    verbose=True
    verbose=False
)


# Add all templates subdirs from all existing PyLucid apps + plugins
TEMPLATE_DIRS = PYLUCID_PLUGIN_SETUP_INFO.template_dirs

# Append "static" template directories:
TEMPLATE_DIRS += (
    os.path.join(_pkg_path(django_tools), "templates/"),
    os.path.join(_pkg_path(dbpreferences), "templates/"),
    os.path.join(_pkg_path(django_processinfo), "templates/"),

    os.path.join(_pkg_path(django), "contrib/admin/templates"),
)
#print "settings.TEMPLATE_DIRS:\n", "\n".join(TEMPLATE_DIRS)


TEMPLATE_LOADERS = (
    'dbtemplates.loader.Loader',
    'django.template.loaders.filesystem.Loader',
    'django.template.loaders.app_directories.Loader',
)

# A tuple of callables that are used to populate the context in RequestContext.
# These callables take a request object as their argument and return a
# dictionary of items to be merged into the context.
TEMPLATE_CONTEXT_PROCESSORS = (
    "django.contrib.auth.context_processors.auth",
    "django.core.context_processors.i18n",
    "django.core.context_processors.request", # Add request object to context
    "django.core.context_processors.static", # Add STATIC_URL to context
    "django.core.context_processors.media", # Add MEDIA_URL to context
    "django.contrib.messages.context_processors.messages",
    "pylucid_project.apps.pylucid.context_processors.pylucid",
)

# Template debug should be off, because you didn't see a good debug page, if the error
# is in a lucidTag plugin view!
# Note that Django only displays fancy error pages if DEBUG is True!
TEMPLATE_DEBUG = False
#TEMPLATE_DEBUG = True

if DEBUG:
    # Display invalid (e.g. misspelled, unused) template variables
    # http://www.djangoproject.com/documentation/templates_python/#how-invalid-variables-are-handled
    # http://www.djangoproject.com/documentation/settings/#template-string-if-invalid
    # But note: Some django admin stuff is broken if TEMPLATE_STRING_IF_INVALID != ""
    # see also: http://code.djangoproject.com/ticket/3579
    # A work-a-round for this lives in ./pylucid_project/apps/pylucid_admin/admin.py 
    TEMPLATE_STRING_IF_INVALID = "XXX INVALID TEMPLATE STRING '%s' XXX"
#    from django_tools.template import warn_invalid_template_vars
#    warn_invalid_template_vars.add_warning()



INSTALLED_APPS = (
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.sites',
    'django.contrib.admin',
    'django.contrib.comments',
    'django.contrib.redirects',
    'django.contrib.staticfiles',

    # PyLucid own apps:
    'pylucid_project.apps.pylucid',
    'pylucid_project.apps.pylucid_admin',
    'pylucid_project.apps.pylucid_update', # Only needed for v0.8 users

    # external apps shipped and used with PyLucid:
	'django_tools.dynamic_site', # https://github.com/jedie/django-tools/blob/master/django_tools/dynamic_site/README.creole
    'dbpreferences', # http://code.google.com/p/django-dbpreferences/
    'dbtemplates', # http://code.google.com/p/django-dbtemplates/
    'reversion', # http://code.google.com/p/django-reversion/
    'reversion_compare', # https://github.com/jedie/django-reversion-compare
    'tagging', # http://code.google.com/p/django-tagging/
    'compressor', # https://github.com/jezdez/django_compressor
    'south', # http://south.aeracode.org/
    'django_processinfo', # https://github.com/jedie/django-processinfo
)

# Temp. work-a-round for https://github.com/jezdez/django-dbtemplates/pull/31
# TODO: remove until new django-dbtemplates release exist with the bugfix.
DATABASE_ENGINE = "XXX"

# Add all existing PyLucid apps + plugins
INSTALLED_APPS += PYLUCID_PLUGIN_SETUP_INFO.installed_plugins
#print "settings.INSTALLED_APPS:", "\n".join(INSTALLED_APPS)

COMMENTS_APP = "pylucid_project.pylucid_plugins.pylucid_comments"

#http://docs.djangoproject.com/en/dev/ref/settings/#setting-TEST_RUNNER
#Default: 'django.test.simple.run_tests'
TEST_RUNNER = 'pylucid_project.tests.test_tools.test_runner.PyLucidTestRunner'

if RUN_WITH_DEV_SERVER:
    # print mails to console if dev server used.
    EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
    ADMINS = (
        ("test", "dev_server_test@example_domain.tld"),
    )

#_____________________________________________________________________________
# PyLucid own settings

# Add app settings
try:
    from pylucid_project.apps.pylucid import app_settings as PYLUCID
    from pylucid_project.apps.pylucid_admin import app_settings as ADMIN
except Exception, e:
    import traceback
    sys.stderr.write(traceback.format_exc())
    raise


# http://www.djangoproject.com/documentation/authentication/#other-authentication-sources
AUTHENTICATION_BACKENDS = (
    "pylucid_project.pylucid_plugins.auth.auth_backends.SiteAuthBackend",
    "pylucid_project.pylucid_plugins.auth.auth_backends.SiteSHALoginAuthBackend",
#    "django.contrib.auth.backends.ModelBackend",
)
# http://docs.djangoproject.com/en/dev/topics/auth/#storing-additional-information-about-users
AUTH_PROFILE_MODULE = "pylucid.UserProfile"

#_____________________________________________________________________________
# STATIC FILES
#
# must be set in local_settings.py
# would be checked at the end of this file
#
STATIC_ROOT = None
STATIC_URL = None
MEDIA_ROOT = None
MEDIA_URL = None

# https://docs.djangoproject.com/en/1.4/ref/contrib/staticfiles/#std:setting-STATICFILES_DIRS
STATICFILES_DIRS = ()

# Set base path for include plugin: 
# http://www.pylucid.org/permalink/381/about-the-include-plugin
PYLUCID_INCLUDE_BASEPATH = None

STATICFILES_FINDERS = (
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
    # django-compressor:
    'compressor.finders.CompressorFinder',
)

# Enable django-compressor even if DEBUG is on:
COMPRESS_ENABLED = True


ADMIN_URL_PREFIX = 'admin'
PYLUCID_ADMIN_URL_PREFIX = 'pylucid_admin'

LOGIN_REDIRECT_URL = "/%s/" % ADMIN_URL_PREFIX
LOGIN_URL = "/%s/" % ADMIN_URL_PREFIX
LOGOUT_URL = "/?%s" % PYLUCID.AUTH_LOGOUT_GET_VIEW

# Blacklist of PageTree slugs that are not useable.
# Would be extendet at the end of this file!
SLUG_BLACKLIST = (
    ADMIN_URL_PREFIX, PYLUCID_ADMIN_URL_PREFIX, PYLUCID.HEAD_FILES_URL_PREFIX,
)

# Prefix in filename, used for page templates
SITE_TEMPLATE_PREFIX = 'site_template'

# Prefix in filename, used for page stylesheet
SITE_STYLE_PREFIX = 'site_stylesheet'


# Django can't handling time zone very good.
# The Django default TIME_ZONE is 'America/Chicago' (Central Standard Time Zone, (CST), UTC-6)
# but this is not the best choice.
# We set it to "UTC" (same as Greenwich Mean Time, GMT-0, without daylight-saving time)
# All datetime (e.g. model createtime) would be stored in UTC.
# See also: http://groups.google.com/group/django-developers/browse_thread/thread/4ca560ef33c88bf3
TIME_ZONE = "UTC"

# Default system language.
# (Default from django is en-us, but this doesn't exist in PyLucid installed data)
LANGUAGE_CODE = "en"

# https://docs.djangoproject.com/en/1.3/ref/settings/#std:setting-LOCALE_PATHS
LOCALE_PATHS = (
    os.path.join(PYLUCID_BASE_PATH, "apps", "pylucid", "locale"),
)
USE_I18N = True

#_______________________________________________________________________________
# dbtemplates settings
# http://packages.python.org/django-dbtemplates/overview.html#settings

# dbtemplate should used django-reversion
DBTEMPLATES_USE_REVERSION = True

#_______________________________________________________________________________
# settings for local_sync_cache from django-tools

if DEBUG and RUN_WITH_DEV_SERVER:
    LOCAL_SYNC_CACHE_DEBUG = True
else:
    LOCAL_SYNC_CACHE_DEBUG = False

LOCAL_SYNC_CACHE_BACKEND = "local_sync_cache"

#_______________________________________________________________________________
# Set the Django cache system.

CACHE_MIDDLEWARE_SECONDS = 3600 # 1h

# The LocMemCache isn't memory-efficient. Should be changed in local_settings.py !
_BACKEND = "django_tools.cache.smooth_cache_backends.SmoothLocMemCache"
CACHES = {
    'default': {
        'BACKEND': _BACKEND,
        'LOCATION': 'PyLucid-default-cache',
        'TIMEOUT': CACHE_MIDDLEWARE_SECONDS,
    },
    'dbtemplates': { # http://django-dbtemplates.readthedocs.org/en/latest/advanced/#caching
        'BACKEND': _BACKEND,
        'LOCATION': 'PyLucid-dbtemplates-cache',
        'TIMEOUT': CACHE_MIDDLEWARE_SECONDS,
    },
    LOCAL_SYNC_CACHE_BACKEND: { # https://github.com/jedie/django-tools/blob/master/django_tools/local_sync_cache/local_sync_cache.py
        'BACKEND': _BACKEND,
        'LOCATION': 'PyLucid-local_sync-cache',
        'TIMEOUT': CACHE_MIDDLEWARE_SECONDS,
    },
}

#_______________________________________________________________________________

# unittest running?
_IN_UNITTESTS = "PYLUCID_UNITTESTS" in os.environ or "test" in sys.argv

if _IN_UNITTESTS:
    # For running unittests with sqlite and south:
    # http://south.aeracode.org/wiki/Settings#SOUTH_TESTS_MIGRATE
    SOUTH_TESTS_MIGRATE = False


# Must be set in local settings
SECRET_KEY = None

#_______________________________________________________________________________
# include additional_settings from plugins

PYLUCID_PLUGIN_SETUP_INFO.get_additional_settings(locals())

#_______________________________________________________________________________
# overwrite values from the local settings

def _error(msg):
    from django.core.exceptions import ImproperlyConfigured
    raise ImproperlyConfigured(msg)

LOCAL_SETTINGS_MODULE = os.environ.get("LOCAL_SETTINGS_MODULE", "local_settings")

try:
    # from local_settings import *    
    _local_settings = __import__(LOCAL_SETTINGS_MODULE, globals(), locals(), ["*"])
except ImportError, err:
    if str(err).startswith("No module named"):
        msg = (
            "There is no %s.py file in '%s' !"
            " (Original error was: %s)\n"
        ) % (LOCAL_SETTINGS_MODULE, os.getcwd(), err)
        _error(msg)
    else:
        raise

# Only for information:
LOCAL_SETTINGS_MODULE_PATH = _local_settings.__file__

# assimilate all local settings from modul, see: http://stackoverflow.com/a/2916810/746522
for key in dir(_local_settings):
    if not key.startswith("_"):
        locals()[key] = getattr(_local_settings, key)

del(_local_settings)


#_______________________________________________________________________________
# check some settings

if not "create_instance" in sys.argv:
    if SECRET_KEY in (None, ""):
        _error("You must set a SECRET_KEY in your local_settings.py!")

    if DEBUG or RUN_WITH_DEV_SERVER:
        # Check all STATICFILES_DIRS
        for dir in STATICFILES_DIRS:
            if not os.path.isdir(dir):
                _error("Directory in STATICFILES_DIRS doesn't exist: %r" % dir)

    #__________________________________________________________________________
    # Check STATIC_* and MEDIA_*

    def _check_if_set(info, value):
        if not value:
            _error("%s must be set in local_settings.py !" % info)

    def _check_path(info, path):
        _check_if_set(info, path)
        if not os.path.exists(path):
            _error("%s %r doesn't exists!" % (info, path))

    _check_path("STATIC_ROOT", STATIC_ROOT)
    _check_path("MEDIA_ROOT", MEDIA_ROOT)

    _check_if_set("STATIC_URL", STATIC_URL)
    _check_if_set("MEDIA_URL", MEDIA_URL)

    del(_check_path)
    del(_check_if_set)

    #__________________________________________________________________________
    # expand SLUG_BLACKLIST

    SLUG_BLACKLIST = list(SLUG_BLACKLIST)

    if "." not in STATIC_URL:
        # URL is not a other domain / sub domain
        SLUG_BLACKLIST.append(STATIC_URL.strip("/").split("/", 1)[0])

    if "." not in MEDIA_URL:
        SLUG_BLACKLIST.append(MEDIA_URL.strip("/").split("/", 1)[0])

    SLUG_BLACKLIST = tuple([item.lower() for item in SLUG_BLACKLIST])

del(_error)

########NEW FILE########
__FILENAME__ = pylucid_plugins
# coding: utf-8

"""
    PyLucid plugins
    ~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.p

"""


import logging
import os
import pprint
import sys

from django.conf import settings
from django.conf.urls.defaults import patterns, include
from django.core import urlresolvers
from django.http import HttpResponse
from django.utils.importlib import import_module
from django.utils.log import getLogger
from django.views.decorators.csrf import csrf_protect

from pylucid_project.utils.python_tools import has_init_file


logger = getLogger("pylucid.pylucid_plugins")
#logger.setLevel(logging.DEBUG)
#logger.addHandler(logging.StreamHandler())


#PYLUCID_PLUGINS = None

_PLUGIN_OBJ_CACHE = {} # cache for PyLucidPlugin.get_plugin_object()
_PLUGIN_URL_CACHE = {} # cache for PyLucidPlugin.get_prefix_urlpatterns()


class PluginNotOnSite(Exception):
    """ PluginPage doesn't exist on current page. """
    pass


class PyLucidPlugin(object):
    """ represents one PyLucid plugins """

    class ObjectNotFound(Exception):
        """ Can't import a plugin module or a module Attribute doesn't exist. """
        pass

    def __init__(self, pkg_path, section, pkg_dir, plugin_name):
        # e.g.: "PYLUCID_BASE_PATH/pylucid_project/pylucid_plugins", "pylucid_project", "pylucid_plugins", "PluginName"
        self.name = plugin_name

        self.fs_path = os.path.join(pkg_path, plugin_name)
        assert os.path.isdir(self.fs_path), "path %r is not a directory or doesn't exist." % self.fs_path
        assert has_init_file(self.fs_path), "%r contains no __init__.py file!" % self.fs_path

        self.pkg_string = ".".join([pkg_dir, plugin_name])
        self.installed_apps_string = ".".join([section, self.pkg_string])

        template_dir = os.path.join(self.fs_path, "templates")
        if os.path.isdir(template_dir):
            self.template_dir = template_dir
        else:
            self.template_dir = None

    def __unicode__(self):
        return u"PyLucid plugin %r (%r)" % (self.name, self.installed_apps_string)

    def __repr__(self):
        return "<%s>" % self.__unicode__()

    def get_plugin_module(self, mod_name):
        """
        Get a module from this plugin.
        argument e.g.:
            mod_name="urls"
        """
#        print "get_plugin_module(%r)" % mod_name
        mod_pkg = ".".join([self.pkg_string, mod_name])
        if mod_pkg in _PLUGIN_OBJ_CACHE:
#            print "use _PLUGIN_OBJ_CACHE[%r]" % mod_pkg
            return _PLUGIN_OBJ_CACHE[mod_pkg]

        try:
            mod = import_module(mod_pkg)
        except Exception, err:
            msg = u"Error importing %r from plugin %r" % (mod_pkg, self.name)

            if str(err).startswith("No module named "):
                raise self.ObjectNotFound("%s: %s" % (msg, err))

            # insert more information into the traceback
            etype, evalue, etb = sys.exc_info()
#            msg += " (Syspath: %s)" % (repr(sys.path))
            evalue = etype('%s: %s' % (msg, evalue))
            raise etype, evalue, etb

#        print "put in _PLUGIN_OBJ_CACHE[%r]" % mod_pkg
        _PLUGIN_OBJ_CACHE[mod_pkg] = mod
        return mod

    def get_plugin_object(self, mod_name, obj_name):
        """
        return a object from this plugin
        argument e.g.: ("admin_urls", "urlpatterns")
        """
        cache_key = ".".join([self.pkg_string, mod_name, obj_name])
        if cache_key in _PLUGIN_OBJ_CACHE:
#            print "use _PLUGIN_OBJ_CACHE[%r]" % cache_key
            return _PLUGIN_OBJ_CACHE[cache_key]

        mod = self.get_plugin_module(mod_name)

        try:
            object = getattr(mod, obj_name)
        except AttributeError, err:
            raise self.ObjectNotFound(err)

#        print "put in _PLUGIN_OBJ_CACHE[%r]" % cache_key
        _PLUGIN_OBJ_CACHE[cache_key] = object

        return object

    def get_callable(self, mod_name, func_name):
        """ returns the callable function. """
        callable = self.get_plugin_object(mod_name, obj_name=func_name)
        return callable

    def call_plugin_view(self, request, mod_name, func_name, method_kwargs):
        """
        Call a plugin view
        used for pylucid-get-views and lucidTag calls 
        """
        callable = self.get_callable(mod_name, func_name)

        # Add info for pylucid_project.apps.pylucid.context_processors.pylucid
        request.plugin_name = self.name
        request.method_name = func_name

        csrf_exempt = getattr(callable, 'csrf_exempt', False)
        if func_name == "http_get_view" and not csrf_exempt:
            # Use csrf_protect only in pylucid get views and not fr lucidTag calls
            callable = csrf_protect(callable)

        # call the plugin view method
        response = callable(request, **method_kwargs)

        if csrf_exempt and isinstance(response, HttpResponse):
            response.csrf_exempt = True

        request.plugin_name = None
        request.method_name = None
#        del(request.plugin_name)
#        del(request.method_name)

        return response

    def get_urlpatterns(self, urls_filename):
        """ returns the plugin urlpatterns """
        if "." in urls_filename:
            urls_filename = os.path.splitext(urls_filename)[0]

        raw_plugin_urlpatterns = self.get_plugin_object(mod_name=urls_filename, obj_name="urlpatterns")
        return raw_plugin_urlpatterns


    def get_prefix_urlpatterns(self, url_prefix, urls_filename):
        """ include the plugin urlpatterns with the url prefix """
        url_prefix = url_prefix.rstrip("/") + "/"

        cache_key = self.pkg_string + url_prefix
        if cache_key in _PLUGIN_URL_CACHE:
            logger.debug("use _PLUGIN_URL_CACHE[%r]" % cache_key)
            return _PLUGIN_URL_CACHE[cache_key]

        raw_plugin_urlpatterns = self.get_urlpatterns(urls_filename)

        plugin_urlpatterns = patterns('',
            (url_prefix, include(raw_plugin_urlpatterns)),
        )

        logger.debug("url prefix: %r" % url_prefix)
        logger.debug("raw_plugin_urlpatterns: %r" % raw_plugin_urlpatterns)
        logger.debug("put in _PLUGIN_URL_CACHE[%r]" % cache_key)

        _PLUGIN_URL_CACHE[cache_key] = plugin_urlpatterns

        return plugin_urlpatterns


    def get_plugin_url_resolver(self, url_prefix, urls_filename="urls"):
        prefix_urlpatterns = self.get_prefix_urlpatterns(url_prefix, urls_filename)

        logger.debug("prefix_urlpatterns: %r" % prefix_urlpatterns)

        plugin_url_resolver = urlresolvers.RegexURLResolver(r'^/', prefix_urlpatterns)

        logger.debug("reverse_dict: %s" % pprint.pformat(plugin_url_resolver.reverse_dict))

        return plugin_url_resolver

    def get_merged_url_resolver(self, url_prefix, urls_filename="urls"):
        """ Merge the globale url patterns with the plugin one, so the plugin can reverse all urls """
        prefix_urlpatterns = self.get_prefix_urlpatterns(url_prefix, urls_filename)

        ROOT_URLCONF_PATTERNS = import_module(settings.ROOT_URLCONF).urlpatterns
        merged_urlpatterns = ROOT_URLCONF_PATTERNS + prefix_urlpatterns

        # Make a own url resolver
#        merged_url_resolver = urlresolvers.RegexURLResolver(r'^/', merged_urlpatterns)
        merged_url_resolver = urlresolvers.RegexURLResolver(r'^/', merged_urlpatterns)
        return merged_url_resolver




class PyLucidPlugins(dict):
    """
    Storage for all existing PyLucid plugins
    FIXME: How can we make this lazy?
    or how can we initializied after settings?
    """

    def __init__(self):
        super(PyLucidPlugins, self).__init__()
        self.__initialized = False

    def __getattr__(self, name):
        if not self.__initialized:
            self._setup()
        assert name != "ObjectNotFound", "Don't use PYLUCID_PLUGINS.ObjectNotFound, use plugin_instance.ObjectNotFound!"
        return getattr(self, name)

    def __getitem__(self, key):
        if not self.__initialized:
            self._setup()
        return dict.__getitem__(self, key)

    def items(self, *args, **kwargs):
        if not self.__initialized:
            self._setup()
        return dict.items(self, *args, **kwargs)

    def _setup(self):
#        print " *** init PyLucidPlugins():", settings.PYLUCID_PLUGIN_SETUP_INFO.keys()
        for plugin_name, data in settings.PYLUCID_PLUGIN_SETUP_INFO.iteritems():
            pkg_path, section, pkg_dir = data
            self[plugin_name] = PyLucidPlugin(pkg_path, section, pkg_dir, plugin_name)
        self.__initialized = True

    def get_admin_urls(self):
        """
        return all existing plugin.admin_urls prefixed with the plugin name.
        Used in apps/pylucid_admin/urls.py
        """
        if not self.__initialized:
            self._setup()
        urls = []
        for plugin_name, plugin_instance in self.iteritems():
            try:
                admin_urls = plugin_instance.get_plugin_object(
                    mod_name="admin_urls", obj_name="urlpatterns"
                )
            except plugin_instance.ObjectNotFound, err:
                continue

            urls += patterns('',
                (r"^%s/" % plugin_name, include(admin_urls)),
            )

        return urls

    def call_get_views(self, request):
        """ call a pylucid plugin "html get view" and return the response. """
        if not self.__initialized:
            self._setup()
        method_name = settings.PYLUCID.HTTP_GET_VIEW_NAME
        for plugin_name in request.GET.keys():
            if plugin_name not in self:
                # get parameter is not a plugin or unknown plugin
                continue

            plugin_instance = self[plugin_name]

            # Don't display pylucid comments"
            request.PYLUCID.object2comment = False

            try:
                response = plugin_instance.call_plugin_view(
                    request, mod_name="views", func_name=method_name, method_kwargs={}
                )
            except plugin_instance.ObjectNotFound, err:
                # plugin or view doesn't exist
                if settings.DEBUG:
                    raise # Give a developer the full traceback page ;)
                else:
                    # ignore the get parameter
                    continue
            except:
                # insert more information into the traceback
                etype, evalue, etb = sys.exc_info()
                evalue = etype('Error rendering plugin view "%s.%s": %s' % (plugin_name, method_name, evalue))
                raise etype, evalue, etb

            return response



PYLUCID_PLUGINS = PyLucidPlugins()







########NEW FILE########
__FILENAME__ = tests_local_settings
# coding: utf-8

"""
    local settings used in unittests
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    :copyleft: 2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

print "Using %s, ok." % __file__

import os
import tempfile


DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': ":memory:",
    }
}


SECRET_KEY = "i'm not secret"


_tempdir = tempfile.gettempdir()

MEDIA_ROOT = os.path.join(_tempdir, "pylucid_unittest_media")
if not os.path.isdir(MEDIA_ROOT):
    os.mkdir(MEDIA_ROOT)
MEDIA_URL = '/media/'

STATIC_ROOT = os.path.join(_tempdir, "pylucid_unittest_static")
if not os.path.isdir(STATIC_ROOT):
    os.mkdir(STATIC_ROOT)
STATIC_URL = '/static/'

print "use MEDIA_ROOT: %s" % MEDIA_ROOT
print "use STATIC_ROOT: %s" % STATIC_ROOT
########NEW FILE########
__FILENAME__ = test_PluginAPI
# coding: utf-8

"""
    PyLucid plugin API unittest
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    Test the plugin API with the unittest plugin. This plugin would be
    symlinked into "./pylucid_project/pylucid_plugins/" before the test
    starts. This would be done in pylucid_project.tests.test_tools.test_runner.

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate:$
    $Rev:$
    $Author: JensDiemer $

    :copyleft: 2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import test_tools # before django imports!

from django.conf import settings

from django_tools.unittest_utils import unittest_base, BrowserDebug

from pylucid_project.tests.test_tools import basetest
from pylucid_project.tests import unittest_plugin

#from django_tools.utils import info_print
#info_print.redirect_stdout()

UNITTEST_GET_PREFIX = "?%s=" % unittest_plugin.views.GET_KEY

# Should we open a bwoser traceback?
BROWSER_TRACEBACK = True


class PluginGetViewTest(basetest.BaseUnittest):
    # Should we open a bwoser traceback?
    browser_traceback = BROWSER_TRACEBACK

    def test_existing(self):
        from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS
        self.failUnless("unittest_plugin" in PYLUCID_PLUGINS, "unittest plugin is not in plugin dict!")

    def test_get_view_none_response(self):
        """ http_get_view() returns None, the normal PageContent would be used. """
        url = UNITTEST_GET_PREFIX + unittest_plugin.views.ACTION_NONE_RESPONSE
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                '1-rootpage content', # PageContent
                '<title>1-rootpage title',
            ),
            must_not_contain=(
                "Traceback",
                unittest_plugin.views.STRING_RESPONSE,
            ),
        )

    def test_get_view_string_response(self):
        """ http_get_view() returns a string, witch replace the PageContent. """
        url = UNITTEST_GET_PREFIX + unittest_plugin.views.ACTION_STRING_RESPONSE
        response = self.client.get(url)
        self.assertResponse(response,
            must_contain=(
                unittest_plugin.views.STRING_RESPONSE,
                '<title>1-rootpage title',
            ),
            must_not_contain=(
                "Traceback",
                '1-rootpage content', # normal page content
            ),
        )

    def test_get_view_HttpResponse(self):
        """ http_get_view() returns a django.http.HttpResponse object. """
        url = UNITTEST_GET_PREFIX + unittest_plugin.views.ACTION_HTTP_RESPONSE
        response = self.client.get(url)
        self.assertStatusCode(response, 200)
        self.failUnlessEqual(response.content, unittest_plugin.views.HTTP_RESPONSE)

    def test_get_view_Redirect(self):
        """ http_get_view() returns a django.http.HttpResponseRedirect object. """
        url = UNITTEST_GET_PREFIX + unittest_plugin.views.ACTION_REDIRECT
        response = self.client.get(url)
        self.assertRedirects(response, expected_url=unittest_plugin.views.REDIRECT_URL, status_code=302)


class PluginPageTest(basetest.BaseUnittest):
    # Should we open a bwoser traceback?
    browser_traceback = BROWSER_TRACEBACK

    def test_root_page(self):
        """
        Test the root view on all sites and in all test languages.
        """
        for site in TestSites():
            for language in TestLanguages():
                url = "/%s/%s/" % (language.code, unittest_plugin.PLUGIN_PAGE_URL)
                response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language.code)
                self.assertContentLanguage(response, language)
                self.assertResponse(response,
                    must_contain=(
                        unittest_plugin.views.PLUGINPAGE_ROOT_STRING_RESPONSE,
                        '3-pluginpage title (lang:%(language)s, site:%(site_name)s)' % {
                            "language": language.code,
                            "site_name": site.name,
                        },
                    ),
                    must_not_contain=(
                        "Traceback",
                        '1-rootpage content', # normal page content
                    ),
                )

    def test_urls_args(self):
        """ Test arguments in urls. """
        test_no = 0
        for site in TestSites():
            for language in TestLanguages():
                url = "/%s/%s/args_test/" % (language.code, unittest_plugin.PLUGIN_PAGE_URL)
                response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language.code)
                self.assertStatusCode(response, 200)
                should_be = "%s [u'url_arg_%s'] [u'%s']" % (
                    unittest_plugin.views.PLUGINPAGE_URL_ARGS_PREFIX, test_no, site_name
                )
                self.failUnlessEqual(response.content, should_be)

                test_no += 1
                site_name = site.name.replace(" ", "-")
                url = "/%s/%s/args_test/url_arg_%s/%s/" % (
                    language.code, unittest_plugin.PLUGIN_PAGE_URL, test_no, site_name
                )
                response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language.code)
                self.assertStatusCode(response, 200)
                should_be = "%s [u'url_arg_%s'] [u'%s']" % (
                    unittest_plugin.views.PLUGINPAGE_URL_ARGS_PREFIX, test_no, site_name
                )
                self.failUnlessEqual(response.content, should_be)

    def test_HttpResponse(self):
        """
        Test a "url sub view" unittest_plugin.test_HttpResponse().
        The view returns a HttpResponse object.
        """
        url = "/%s/%s/test_HttpResponse/" % (self.default_lang_entry.code, unittest_plugin.PLUGIN_PAGE_URL)
        response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=self.default_lang_entry.code)
        self.assertStatusCode(response, 200)
        self.failUnlessEqual(response.content, unittest_plugin.views.PLUGINPAGE_HTTP_RESPONSE)

    def test_plugin_template(self):
        """ Test the render_to_response() with own template witch use {% extends template_name %} """
        for site in TestSites():
            for language in TestLanguages():
                url = "/%s/%s/test_plugin_template/" % (language.code, unittest_plugin.PLUGIN_PAGE_URL)
                response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language.code)
                self.assertResponse(response,
                    must_contain=(
                        unittest_plugin.views.PLUGINPAGE_TEMPLATE_RESPONSE,
                        '3-pluginpage title (lang:%(language)s, site:%(site_name)s)' % {
                            "language": language.code,
                            "site_name": site.name,
                        },
                    ),
                    must_not_contain=(
                        "Traceback",
                        '1-rootpage content', # normal page content
                    ),
                )

    def test_return_none(self):
        """ Test if a PagePlugin returns None -> This must raise a error. """
        url = "/%s/%s/test_return_none/" % (self.default_lang_entry.code, unittest_plugin.PLUGIN_PAGE_URL)
        self.assertRaises(RuntimeError, self.client.get, url, HTTP_ACCEPT_LANGUAGE=self.default_lang_entry.code)

    def test_url_reverse(self):
        """ Test the django url reverse function in a PagePlugin. """
        for language in TestLanguages():
            url_prefix = "/%s/%s" % (language.code, unittest_plugin.PLUGIN_PAGE_URL)
            url_data = {
                "UnittestPlugin-view_root": "%s/" % url_prefix,
                "UnittestPlugin-test_HttpResponse": "%s/test_HttpResponse/" % url_prefix,
            }

            for url_name, sould_url in url_data.iteritems():
                url = "%s/test_url_reverse/%s/" % (url_prefix, url_name)
                response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language.code)
                self.assertStatusCode(response, 200)
                should_be = "%s ['%s']" % (unittest_plugin.views.PLUGINPAGE_URL_REVERSE_PREFIX, sould_url)
                self.failUnlessEqual(response.content, should_be)

    def test_PyLucid_api(self):
        """ Test the PyLucid API """
        for site in TestSites():
            for language in TestLanguages():
                url = "/%s/%s/test_PyLucid_api/" % (language.code, unittest_plugin.PLUGIN_PAGE_URL)
                response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language.code)
                self.assertResponse(response,
                    must_contain=(
                        unittest_plugin.views.PLUGINPAGE_API_TEST_PAGE_MSG,
                        unittest_plugin.views.PLUGINPAGE_API_TEST_CONTENT,
                        '3-pluginpage title (lang:%(language)s, site:%(site_name)s)' % {
                            "language": language.code,
                            "site_name": site.name,
                        },
                        "context_middlewares: [u&#39;extrahead&#39;, u&#39;breadcrumb&#39;]",
                        "lang_entry: &lt;Language: Language %s" % language.code,
                        (
                            "page_template: u&#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;"
                            "{{ page_title }}&lt;/title&gt;"
                        ),
                        "pagetree: &lt;PageTree: PageTree u&#39;3-pluginpage&#39;",
                        ", site: %s, type: PluginPage)&gt;" % site.domain,
                        (
                            "pagemeta: &lt;PageMeta: PageMeta for page: u&#39;3-pluginpage&#39;"
                            " (lang: %s, site: %s)&gt;"
                        ) % (language.code, site.domain),

                        "default_lang_code: %s" % self.default_lang_entry.code,
                        "default_lang_entry: &lt;Language: Language %s" % self.default_lang_entry.code,
                    ),
                    must_not_contain=(
                        "Traceback",
                        '1-rootpage content', # normal page content
                    ),
                )

    def test_add_headfiles(self):
        """
        Add content into html head with {% extrahead %} block tag in plugin template.
        """
        for site in TestSites():
            for language in TestLanguages():
                url = "/%s/%s/test_add_headfiles/" % (language.code, unittest_plugin.PLUGIN_PAGE_URL)
                response = self.client.get(url, HTTP_ACCEPT_LANGUAGE=language.code)
                self.assertResponse(response,
                    must_contain=(
                        "Here ist the unittest plugin extra head content ;)",
                        "The unittest plugin content...",
                        '3-pluginpage title (lang:%(language)s, site:%(site_name)s)' % {
                            "language": language.code,
                            "site_name": site.name,
                        },
                    ),
                    must_not_contain=(
                        "Traceback",
                    )
                )


if __name__ == "__main__":
    # Run this unitest directly
    unittest_base.direct_run(__file__) # Run all tests in this file

########NEW FILE########
__FILENAME__ = basetest
# coding: utf-8

"""
    PyLucid unittest base class
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import re


if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

from django import forms
from django.conf import settings
from django.contrib.messages import constants as message_constants
from django.contrib.sites.models import Site
from django.core.cache import cache
from django.test import TestCase
from django.utils.html import conditional_escape

from django_tools.unittest_utils.unittest_base import BaseTestCase

from pylucid_project.apps.pylucid.models import PageTree, Language, EditableHtmlHeadFile


supported_languages = dict(settings.LANGUAGES)


class BaseUnittest(BaseTestCase, TestCase):
    fixtures = [
        # Special test users:
        os.path.join(settings.PYLUCID_BASE_PATH, "tests/fixtures/test_users.json"),
        # The normal base install fixtures:
        os.path.join(settings.PYLUCID_BASE_PATH, "apps/pylucid_admin/fixtures/pylucid.json"),
    ]

    def _pre_setup(self, *args, **kwargs):
        super(BaseUnittest, self)._pre_setup(*args, **kwargs)

        # fixtures loaded?
        for fixture in self.fixtures:
            self.failUnless(os.path.isfile(fixture), "Test fixture file %r not found!" % fixture)

        if Language.objects.count() < 2:
            raise SystemExit("Languages not exist! test_users.json fixtures not loaded?")

        if PageTree.objects.count() == 0:
            raise SystemExit("PyLucid initial data fixtures not loaded!")

        # Remove the real Pygments CSS content, because it contains the
        # String "Traceback" which used in many tests.
        # If django-compressor not work or disabled, the CSS content would be insert inline. 
        pygments_css = EditableHtmlHeadFile.objects.get(filepath="pygments.css")
        pygments_css.content = "Pygments CSS Content (removed by %s)" % __file__
        pygments_css.save()

        # Fill PyLucid own UserProfile with SHA password data
        for usertype, data in self.TEST_USERS.iteritems():
            user = self._get_user(usertype)
            user.set_password(data["password"])

    def easy_create(self, ModelClass, defaults, **kwargs):
        """
        Create new model instances with defaults.
        used e.g. in blog/lexicon plugin tests
        """
        create_data = defaults
        create_data.update(kwargs)
        instance = ModelClass(**create_data)
        instance.save()
        return instance

    def assertPyLucidPermissionDenied(self, response):
        """ Test if response is a PyLucid permission deny page """
        self.assertStatusCode(response, excepted_code=403)
        self.assertResponse(response,
            must_contain=("<h1>403 Forbidden</h1>",),
            must_not_contain=("Traceback",)
        )

    def assertAdminLoginPage(self, response):
        """
        Check if the response is the django login page
        with PyLucid modifications
        """
        url = response.request["PATH_INFO"]

        # XXX: work-a-round for: https://github.com/gregmuellegger/django/issues/1
        response.content = re.sub(
            "js_sha_link(\+*)='(.*?)'",
            "js_sha_link\g<1>='XXX'",
            response.content
        )
        self.assertDOM(response,
            must_contain=(
                '<input id="id_username" maxlength="30" name="username" type="text" />',
                '<input id="id_password" name="password" type="password" />',
                '<input type="submit" value="Log in" />',
            )
        )

        self.assertResponse(response,
            must_contain=(
                # django
                '<form action="%s" method="post" id="login-form">' % url,

                # from pylucid:
                'JS-SHA-Login',
                "Do really want to send your password in plain text?",
            ),
            must_not_contain=("Traceback",)
        )
        self.assertStatusCode(response, 200)

    def assertAtomFeed(self, response, language_code):
        # application/atom+xml; charset=utf8 -> application/atom+xml
        content_type = response["content-type"].split(";", 1)[0]
        self.failUnlessEqual(content_type, "application/atom+xml")

        self.failUnlessEqual(response["content-language"], language_code)
        self.assertResponse(response,
            must_contain=(
                '<?xml version="1.0" encoding="utf-8"?>',
                '<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="%s">' % language_code,
                "</feed>",
            ),
            must_not_contain=(
                "Traceback",
                "<rss", "<body>", "<html>"
            )
        )

    def assertRssFeed(self, response, language_code):
        # application/rss+xml; charset=utf8 -> application/rss+xml
        content_type = response["content-type"].split(";", 1)[0]
        self.failUnlessEqual(content_type, "application/rss+xml")

        self.failUnlessEqual(response["content-language"], language_code)
        self.assertResponse(response,
            must_contain=(
                '<?xml version="1.0" encoding="utf-8"?>',
                '<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">',
                '<language>%s</language>' % language_code,
                "</rss>",
            ),
            must_not_contain=(
                "Traceback",
                "<feed", "<body>", "<html>"
            )
        )

    def login(self, usertype):
        """
        Login test user and add him to the current site.
        """
        user = super(BaseUnittest, self).login(usertype)

        site = Site.objects.get_current()

        from pylucid_project.apps.pylucid.models import UserProfile
        try:
            userprofile = user.get_profile()
        except UserProfile.DoesNotExist:
            # FIXME: Why does in some case user.get_profile() not work???
            userprofile = UserProfile.objects.get(user=user)

        if not site in userprofile.sites.all():
            print "Info: Add user to site %s" % site
            userprofile.sites.add(site)

        return user

    def login_with_permissions(self, usertype, permissions):
        """ login user and add given permissions """
        user = self.login(usertype)
        self.add_user_permissions(user, permissions=permissions)
        return user


class BaseLanguageTestCase(BaseUnittest):
    """
    Contains some language helper stuff.    
    """
    def tearDown(self):
        super(BaseLanguageTestCase, self).tearDown()
        if self._system_preferences is not None:
            # revert changes from self.enable_i18n_debug()
            self._system_preferences["message_level_anonymous"] = self.old_message_level
            self._system_preferences.save()
        settings.DEBUG = False
        settings.PYLUCID.I18N_DEBUG = False

    def enable_i18n_debug(self):
        """
        enable DEBUG, PYLUCID.I18N_DEBUG and set message_level_anonymous to DEBUG.
        """
        cache.clear()
        from pylucid_project.apps.pylucid.preference_forms import SystemPreferencesForm
        self._system_preferences = SystemPreferencesForm()
        self.old_message_level = self._system_preferences["message_level_anonymous"]
        self._system_preferences["message_level_anonymous"] = message_constants.DEBUG
        self._system_preferences.save()
        settings.DEBUG = True
        settings.PYLUCID.I18N_DEBUG = True

    def _pre_setup(self, *args, **kwargs):
        """ create some language related attributes """
        super(BaseLanguageTestCase, self)._pre_setup(*args, **kwargs)

        self._system_preferences = None # used in enable_i18n_debug() and tearDown()

        # default language is defined with settings.LANGUAGE_CODE
        self.default_language = Language.objects._get_default_language()
        self.failUnlessEqual(self.default_language.code, settings.LANGUAGE_CODE)

        self.other_lang_code = "de"
        assert self.other_lang_code != self.default_language.code
        self.other_language = Language.objects.get(code=self.other_lang_code)

    def assertContentLanguage(self, response, lang):
        """ Check if response is in right language """
        assert isinstance(lang, Language)
        is_lang = response["content-language"]
        if is_lang != lang.code:
            self.raise_browser_traceback(response,
                msg="Header 'Content-Language' is not %r it's: %r" % (lang.code, is_lang)
            )
        self.assertResponse(response,
            must_contain=(
                '<body lang="%s">' % lang.code,
                '<html lang="%(code)s">' % {
                    "code": lang.code
                },
            )
        )


class BaseMoreLanguagesTestCase(BaseLanguageTestCase):
    """
    For tests with more existing languages
    """
    def _pre_setup(self, *args, **kwargs):
        super(BaseMoreLanguagesTestCase, self)._pre_setup(*args, **kwargs)

        self.codes = ("es", "es-ar", "pt", "hr")
        self.languages = {}
        for code in self.codes:
            new_language = Language(
                code=code, description=supported_languages[code]
            )
#            print "test language %r created." % new_language
            new_language.save()
            self.languages[code] = new_language


class MarkupTestHelper(object):
    def _prepare_text(self, txt):
        """
        prepare the multiline, indentation text.
        from https://github.com/jedie/python-creole/blob/master/tests/utils/utils.py
        """
        txt = unicode(txt)
        txt = txt.splitlines()
        assert txt[0] == "", "First must be empty!"
        txt = txt[1:] # Skip the first line

        # get the indentation level from the first line
        count = False
        for count, char in enumerate(txt[0]):
            if char != " ":
                break

        assert count != False, "second line is empty!"

        # remove indentation from all lines
        txt = [i[count:].rstrip(" ") for i in txt]

        #~ txt = re.sub("\n {2,}", "\n", txt)
        txt = "\n".join(txt)

        # strip *one* newline at the begining...
        if txt.startswith("\n"): txt = txt[1:]
        # and strip *one* newline at the end of the text
        if txt.endswith("\n"): txt = txt[:-1]
        #~ print repr(txt)
        #~ print "-"*79

        return txt


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "pylucid_plugins.page_admin.tests.PageAdminTest.test_translate_form"

    management.call_command('test', tests,
        verbosity=2,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = scrapping
#!/usr/bin/env python
# coding: utf-8


import HTMLParser

class HTMLscrapper(HTMLParser.HTMLParser):
    """
    Simple html scrapping.
    
    >>> HTMLscrapper().grab('<link href="foo"></link><a href="bar"></a>', tags=("link","a"), attrs=("href",))
    {'href': ['foo', 'bar']}
    """
    def grab(self, content, tags, attrs):
        self.reset() # Initialize and reset this HTMLParser instance.
        self.tags = tags
        self.attrs = attrs
        self.result = {}

        self.feed(content)
        return self.result

    def handle_starttag(self, tag, attrs):
        if tag not in self.tags:
            return

        attr_dict = dict(attrs)
        for attr, value in attr_dict.iteritems():
            if attr not in self.attrs:
                continue

            if attr not in self.result:
                self.result[attr] = []

            self.result[attr].append(value)




if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = test_runner
# coding: utf-8

"""
    PyLucid project unittest runner
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import pprint
import sys
import unittest


if __name__ == "__main__":
    # Run all unittest directly
    from pylucid_project.tests import run_test_directly
    run_test_directly(
        verbosity=2,
#        failfast=True,
        failfast=False,
    )
    sys.exit()


from django.conf import settings
from django.test.simple import DjangoTestSuiteRunner

import pylucid_project
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS, PyLucidPlugin

#-----------------------------------------------------------------------------

# Disable dynamic site, if used:
if getattr(settings, "USE_DYNAMIC_SITE_MIDDLEWARE", False):
    settings.USE_DYNAMIC_SITE_MIDDLEWARE = False
    settings.SITE_ID = 1

PYLUCID_PROJECT_ROOT = os.path.abspath(os.path.dirname(pylucid_project.__file__))
UNITTEST_PLUGIN_SRC_PATH = os.path.join(PYLUCID_PROJECT_ROOT, "tests", "unittest_plugin")
UNITTEST_PLUGIN_DST_PATH = os.path.join(PYLUCID_PROJECT_ROOT, "pylucid_plugins", "unittest_plugin")

#-----------------------------------------------------------------------------


class PyLucidTestRunner(DjangoTestSuiteRunner):
    def _get_all_test_names(self):
        """  """
        test_names = ["pylucid_project.tests", ]
        for app_name in settings.INSTALLED_APPS:
            test_names.append("%s.tests" % app_name)

    def is_in_test_labels(self, app_name, test_labels):
        for test_label in test_labels:
            if test_label in app_name:
                return True
        return False

    def print_test_names(self, tests):
        if hasattr(tests, "_tests"):
            for test in tests:
                self.print_test_names(test)
        else:
            module_name = tests.__class__.__module__
            file_name = module_name.split(".")[-1]
            print "\t%s.%s.%s" % (file_name, tests.__class__.__name__, tests._testMethodName)

    def print_verbose_info(self, tests, test_name):
        if self.verbosity:
            print "Add %s tests from %r" % (tests.countTestCases(), test_name)
        if self.verbosity >= 2:
            self.print_test_names(tests)

    def _setup_unittest_plugin(self):
        if os.path.exists(UNITTEST_PLUGIN_DST_PATH):
            print "unitest plugin already exist in: %r" % UNITTEST_PLUGIN_DST_PATH
        else:
            print "insert unittest plugin via symlink:"
            print "%s -> %s" % (UNITTEST_PLUGIN_SRC_PATH, UNITTEST_PLUGIN_DST_PATH)
            os.symlink(UNITTEST_PLUGIN_SRC_PATH, UNITTEST_PLUGIN_DST_PATH)

        template_dir = os.path.join(UNITTEST_PLUGIN_DST_PATH, "templates")
        if not template_dir in settings.TEMPLATE_DIRS:
            print "unittest_plugin added to settings.TEMPLATE_DIRS"
            settings.TEMPLATE_DIRS += (template_dir,)

        plugin_name = "pylucid_project.pylucid_plugins.unittest_plugin"
        if not plugin_name in settings.INSTALLED_APPS:
            print "unittest_plugin added to settings.INSTALLED_APPS"
            settings.INSTALLED_APPS += (plugin_name,)

        if not "unittest_plugin" in PYLUCID_PLUGINS:
            pkg_path = os.path.join(PYLUCID_PROJECT_ROOT, "pylucid_plugins")
            PYLUCID_PLUGINS["unittest_plugin"] = PyLucidPlugin(
                pkg_path, section="pylucid_project",
                pkg_dir="pylucid_plugins", plugin_name="unittest_plugin"
            )
            print "unittest_plugin added to PYLUCID_PLUGINS"
            print PYLUCID_PLUGINS.keys()

    def build_suite(self, test_labels, extra_tests=None, **kwargs):
        """
        Contruct a test suite from all available tests. Returns an instantiated test suite.
        
        The django test suite runner used django.db.models.loading.get_app() to get all tests.
        The problem is get_app() is a list of all apps witch have a models.py
        
        We want run tests from pylucid plugin witch have no models.py, too.
        
        test_labels can contain the absolute path to a app. This is needful,
        because we can add this into a test file:
            management.call_command('test', __file__)
        """
        test_suite = unittest.TestSuite()

        if test_labels:
            # add only test labels
            for test_label in test_labels:
                if "pylucid" not in test_label:
                    print "Skip test label %r: it's not a pylucid part!" % test_label
                    print " Use default settings.TEST_RUNNER to run this test!"
                    continue

                if os.path.isfile(test_label):
                    # run test directly and use __file__ to insert the current test label
                    raw_test_label = os.path.splitext(test_label)[0]
                    test_dir_splitted = raw_test_label.rsplit(os.sep, 3)
                    test_label = ".".join(test_dir_splitted[1:4])
                    if self.verbosity:
                        print "cut __file__ path to %r" % test_label

                try:
                    tests = unittest.defaultTestLoader.loadTestsFromName(test_label)
                except Exception, err:
                    etype, evalue, etb = sys.exc_info()
                    evalue = etype("Can't get test label %r: %s" % (test_label, evalue))
                    raise etype, evalue, etb

                self.print_verbose_info(tests, test_label)
                test_suite.addTest(tests)
        else:
            # Add all pylucid related apps
            if self.verbosity >= 2:
                print "INSTALLED_APPS:"
                pprint.pprint(settings.INSTALLED_APPS)
            for app_name in settings.INSTALLED_APPS:
                if "pylucid" not in app_name:
                    # use only PyLucid stuff
                    continue

                test_name = "%s.tests" % app_name

                try:
                    tests = unittest.defaultTestLoader.loadTestsFromName(test_name)
                except AttributeError, err:
                    if str(err) != "'module' object has no attribute 'tests'":
                        # Other error than "no tests available"
                        raise
                    if self.verbosity >= 2:
                        print "Skip %r, ok. (%s)" % (test_name, err)
                except Exception, err:
                    print "*** Error in %r: %s" % (test_name, err)
                else:
                    self.print_verbose_info(tests, test_name)
                    test_suite.addTest(tests)

        return test_suite

    def setup_test_environment(self, *args, **kwargs):
        self._setup_unittest_plugin()
        super(PyLucidTestRunner, self).setup_test_environment(*args, **kwargs)

    def teardown_test_environment(self, *args, **kwargs):
        print "remove unittest plugin symlink"
        os.remove(UNITTEST_PLUGIN_DST_PATH)
        super(PyLucidTestRunner, self).teardown_test_environment(*args, **kwargs)


########NEW FILE########
__FILENAME__ = test_user
# coding:utf-8

from django.contrib.auth.models import User

TEST_USERS = {
    "superuser": {
        "username": "superuser",
        "email": "superuser@example.org",
        "password": "superuser_password",
        "is_staff": True,
        "is_superuser": True,
    },
    "staff": {
        "username": "staff test user",
        "email": "staff_test_user@example.org",
        "password": "staff_test_user_password",
        "is_staff": True,
        "is_superuser": False,
    },
    "normal": {
        "username": "normal test user",
        "email": "normal_test_user@example.org",
        "password": "normal_test_user_password",
        "is_staff": False,
        "is_superuser": False,
    },
}

def get_user(usertype):
    return User.objects.get(username=TEST_USERS[usertype]["username"])

def create_user(verbosity, username, password, email, is_staff, is_superuser):
    """
    Create a user and return the instance.
    """
    defaults = {'password':password, 'email':email}
    user, created = User.objects.get_or_create(
        username=username, defaults=defaults
    )
    if not created:
        user.email = email
    user.set_password(password)
    user.is_staff = is_staff
    user.is_superuser = is_superuser
    user.save()
    if verbosity >= 2:
        print "Test user %r created." % user
    return user

def create_testusers(verbosity):
    """
    Create all available testusers and UserProfiles
    """
    for usertype, userdata in TEST_USERS.iteritems():
        user = create_user(verbosity, **userdata)

########NEW FILE########
__FILENAME__ = test_TreeModel
# coding:utf-8

from pprint import pprint

import test_tools # before django imports!

from django.conf import settings

from django.contrib.auth.models import Group, AnonymousUser
from django.contrib.sites.models import Site

from django_tools.unittest_utils import unittest_base

from pylucid_project.tests.test_tools.pylucid_test_data import TestSites
from pylucid_project.tests.test_tools import basetest
from pylucid_project.apps.pylucid.models import PageTree, PageMeta

#settings.PYLUCID.I18N_DEBUG = True

class TreeModelTest(basetest.BaseUnittest):
    """
    Low level test for pylucid.models.PageTree + pylucid.tree_model.TreeGenerator
    """
    def _flat_tree_generator(self, tree):
        for node in tree.iter_flat_list():
            indent = "*" * (node.level + 1)
            yield "%-3s %s" % (indent, node.get_absolute_url())

    def _print_flat_tree(self, tree):
        flat_tree = self._flat_tree_generator(tree)
        pprint(list(flat_tree))

    def assertTree(self, tree, should_data):
        for no, is_item in enumerate(self._flat_tree_generator(tree)):
            self.failUnlessEqual(is_item, should_data[no])

    def test_all(self):
        user = AnonymousUser()
        # returns a TreeGenerator instance with all accessable page tree instance
        tree = PageTree.objects.get_tree(user)
        #tree.debug()
        #self._print_flat_tree(tree)

        self.assertTree(tree, should_data=
            [u'*   /1-rootpage/',
             u'**  /1-rootpage/1-1-subpage/',
             u'**  /1-rootpage/1-2-subpage/',
             u'*   /2-rootpage/',
             u'**  /2-rootpage/2-1-subpage/',
             u'**  /2-rootpage/2-2-subpage/',
             u'*** /2-rootpage/2-2-subpage/2-2-1-subpage/',
             u'*** /2-rootpage/2-2-subpage/2-2-2-subpage/',
             u'*   /3-pluginpage/']
        )

    def test_permitViewGroup1(self):
        """
        Test filtering permitViewGroup.
        """
        test_group1 = Group(name="test group1")
        test_group1.save()

        page = PageTree.on_site.get(slug="2-2-subpage")
        page.permitViewGroup = test_group1
        page.save()

        test_group2 = Group(name="test group2")
        test_group2.save()

        page = PageTree.on_site.get(slug="2-2-1-subpage")
        page.permitViewGroup = test_group2
        page.save()

        # --------------------------------------------------------------------
        # Test as AnonymousUser:
        # He can see only pages with permitViewGroup==None

        user = AnonymousUser()
        tree = PageTree.objects.get_tree(user)
        #tree.debug()
        #self._print_flat_tree(tree)
        self.assertTree(tree, should_data=
            [u'*   /1-rootpage/',
             u'**  /1-rootpage/1-1-subpage/',
             u'**  /1-rootpage/1-2-subpage/',
             u'*   /2-rootpage/',
             u'**  /2-rootpage/2-1-subpage/',
             #u'**  /2-rootpage/2-2-subpage/', # permitViewGroup == test_group1
             #u'*** /2-rootpage/2-2-subpage/2-2-1-subpage/', # permitViewGroup == test_group2 
             #u'*** /2-rootpage/2-2-subpage/2-2-2-subpage/',
             u'*   /3-pluginpage/']
        )

        # --------------------------------------------------------------------
        # Test as Superuser:
        # He can see all pages

        user = self._get_user(usertype="superuser")
        tree = PageTree.objects.get_tree(user)
        #tree.debug()
        #self._print_flat_tree(tree)
        self.assertTree(tree, should_data=
            [u'*   /1-rootpage/',
             u'**  /1-rootpage/1-1-subpage/',
             u'**  /1-rootpage/1-2-subpage/',
             u'*   /2-rootpage/',
             u'**  /2-rootpage/2-1-subpage/',
             u'**  /2-rootpage/2-2-subpage/', # permitViewGroup == test_group1
             u'*** /2-rootpage/2-2-subpage/2-2-1-subpage/', # permitViewGroup == test_group2 
             u'*** /2-rootpage/2-2-subpage/2-2-2-subpage/',
             u'*   /3-pluginpage/']
        )

        # --------------------------------------------------------------------
        # Test as normal user:
        # He can see all pages 

        # Test without any groups -> He can see only pages with permitViewGroup==None
        user = self._get_user(usertype="normal")
        tree = PageTree.objects.get_tree(user)
        #tree.debug()
        #self._print_flat_tree(tree)
        self.assertTree(tree, should_data=
            [u'*   /1-rootpage/',
             u'**  /1-rootpage/1-1-subpage/',
             u'**  /1-rootpage/1-2-subpage/',
             u'*   /2-rootpage/',
             u'**  /2-rootpage/2-1-subpage/',
             #u'**  /2-rootpage/2-2-subpage/', # permitViewGroup == test_group1
             #u'*** /2-rootpage/2-2-subpage/2-2-1-subpage/', # permitViewGroup == test_group2 
             #u'*** /2-rootpage/2-2-subpage/2-2-2-subpage/',
             u'*   /3-pluginpage/']
        )

        # Add user to "test group1"
        user.groups.add(test_group1)
        tree = PageTree.objects.get_tree(user)
        #tree.debug()
        #self._print_flat_tree(tree)
        self.assertTree(tree, should_data=
            [u'*   /1-rootpage/',
             u'**  /1-rootpage/1-1-subpage/',
             u'**  /1-rootpage/1-2-subpage/',
             u'*   /2-rootpage/',
             u'**  /2-rootpage/2-1-subpage/',
             u'**  /2-rootpage/2-2-subpage/', # permitViewGroup == test_group1
             #u'*** /2-rootpage/2-2-subpage/2-2-1-subpage/', # permitViewGroup == test_group2 
             u'*** /2-rootpage/2-2-subpage/2-2-2-subpage/',
             u'*   /3-pluginpage/']
        )

        # Add user to "test group2", too.
        user.groups.add(test_group2)
        tree = PageTree.objects.get_tree(user)
        #tree.debug()
        #self._print_flat_tree(tree)
        self.assertTree(tree, should_data=
            [u'*   /1-rootpage/',
             u'**  /1-rootpage/1-1-subpage/',
             u'**  /1-rootpage/1-2-subpage/',
             u'*   /2-rootpage/',
             u'**  /2-rootpage/2-1-subpage/',
             u'**  /2-rootpage/2-2-subpage/', # permitViewGroup == test_group1
             u'*** /2-rootpage/2-2-subpage/2-2-1-subpage/', # permitViewGroup == test_group2 
             u'*** /2-rootpage/2-2-subpage/2-2-2-subpage/',
             u'*   /3-pluginpage/']
        )

        # Put user *only* in "test group2"
        user.groups.remove(test_group1)
        tree = PageTree.objects.get_tree(user)
        #tree.debug()
        #self._print_flat_tree(tree)
        self.assertTree(tree, should_data=
            [u'*   /1-rootpage/',
             u'**  /1-rootpage/1-1-subpage/',
             u'**  /1-rootpage/1-2-subpage/',
             u'*   /2-rootpage/',
             u'**  /2-rootpage/2-1-subpage/',
             #u'**  /2-rootpage/2-2-subpage/', # permitViewGroup == test_group1
             #u'*** /2-rootpage/2-2-subpage/2-2-1-subpage/', # permitViewGroup == test_group2 
             #u'*** /2-rootpage/2-2-subpage/2-2-2-subpage/',
             u'*   /3-pluginpage/']
        )


if __name__ == "__main__":
    # Run this unitest directly
    unittest_base.direct_run(__file__)

########NEW FILE########
__FILENAME__ = test_Unittest
# coding:utf-8

import os


if __name__ == "__main__":
    # run all unittest directly
    os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"


from django import forms
from django.forms.util import flatatt

from pylucid_project.tests.test_tools import basetest


class TestForm(forms.Form):
    foo = forms.CharField(max_length=100)


class FlatattPatchTest(basetest.BaseUnittest):
    """
    Test flatatt Monkey-patch (done in pylucid test.test_tools.test_runner)
    """
    TEST_ATTRS = {"m":5, "a":1, "b":2, "c":3, "z":8, 1:1, 2:2}

    def test_function(self):
        output = flatatt(self.TEST_ATTRS)
        self.failUnlessEqual(u' 1="1" 2="2" a="1" b="2" c="3" m="5" z="8"', output)

    def test_widget_patch(self):
        test_widget = forms.TextInput()
        self.failUnlessEqual(
            test_widget.render("foo", "bar", attrs=self.TEST_ATTRS),
            '<input 1="1" 2="2" a="1" b="2" c="3" m="5" name="foo" type="text" value="bar" z="8" />'
        )

    def test_forms_patch(self):
        form = TestForm()
        foo_field = form["foo"]
        self.failUnlessEqual(
            foo_field.label_tag(attrs=self.TEST_ATTRS),
            '<label for="id_foo" 1="1" 2="2" a="1" b="2" c="3" m="5" z="8">Foo</label>'
        )


if __name__ == "__main__":
    # Run all unittest directly
    from django.core import management

    tests = __file__
#    tests = "apps.pylucid_admin.tests.PyLucidPluginsTest.test_access_admin_views"

    management.call_command('test', tests,
#        verbosity=0,
        verbosity=1,
        failfast=True
    )

########NEW FILE########
__FILENAME__ = models

########NEW FILE########
__FILENAME__ = tests
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid unittests
    ~~~~~~~~~~~~~~~~~
    
    Info:
        - PyLucid initial data contains english and german pages.
        - There exist only "PyLucid CMS" blog entry in english and german
    
    :copyleft: 2010-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

import os
import logging
import sys

if __name__ == "__main__":
    # Run all unittest directly

    tests = __file__
#    tests = "pylucid_project.pylucid_plugins.unittest_plugin.tests"
#    tests = "pylucid_project.pylucid_plugins.unittest_plugin.tests.UnittestPluginCsrfTests"
#    tests = "pylucid_project.pylucid_plugins.unittest_plugin.tests.TestUnitestPlugin.test_if_plugin_exists"
#    tests = "pylucid_project.pylucid_plugins.unittest_plugin.tests.TestUnitestPluginPage"

    from pylucid_project.tests import run_test_directly
    run_test_directly(tests,
        verbosity=2,
#        failfast=True,
        failfast=False,
    )
    sys.exit()

from django.conf import settings
from django.contrib.messages import constants as message_constants
from django.core.cache import cache
from django.core.urlresolvers import reverse
from django.test.client import Client
from django.utils.log import getLogger

from pylucid_project.apps.pylucid.preference_forms import SystemPreferencesForm
from pylucid_project.system.pylucid_plugins import PYLUCID_PLUGINS
from pylucid_project.tests.test_tools import basetest

#logger = getLogger("pylucid.unittest_plugin")
#logger.setLevel(logging.DEBUG)
#logger.addHandler(logging.StreamHandler())

class TestUnitestPlugin(basetest.BaseUnittest):
    """
    inherited from BaseUnittest:
        - initial data fixtures with default test users
        - self.login()
    """
    def test_if_exist_in_pylucid_plugins_data(self):
        self.failUnless("unittest_plugin" in PYLUCID_PLUGINS)

    def test_if_plugin_exists(self):
        self.login("superuser")
        response = self.client.get("/pylucid_admin/plugins/internals/show_internals/")
        self.assertResponse(response,
            must_contain=(
                "pylucid_project.pylucid_plugins.unittest_plugin", #INSTALLED_APPS
                "/PyLucid_env/src/pylucid/pylucid_project/tests/unittest_plugin", # sys.path 
            ),
            must_not_contain=("Traceback",)
        )

    def test_anonymous(self):
        cache.clear() # page message can be only see, if cache not used!
        response = self.client.get("/en/welcome/?unittest_plugin=MSG_ERROR")
#        response = self.client.get("/pylucid_admin/plugins/internals/show_internals/")
        self.assertResponse(response,
            must_contain=("<html", "A error messages"),
            must_not_contain=("Traceback",)
        )

class TestUnitestPluginPage(basetest.BaseUnittest):

    def _pre_setup(self, *args, **kwargs):
        super(TestUnitestPluginPage, self)._pre_setup(*args, **kwargs)

        self.login("superuser")

        new_plugin_page_url = reverse("PageAdmin-new_plugin_page")
        test_slug = "ut_plugin"
        response = self.client.post(new_plugin_page_url,
            data={'app_label': 'pylucid_project.pylucid_plugins.unittest_plugin',
            'design': 1,
            'position': 0,
            'slug': test_slug,
            'urls_filename': 'urls.py'
            }
        )
        self.url = "http://testserver/en/%s/" % test_slug
        self.assertRedirect(response, self.url, status_code=302)

        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=("New plugin page", "unittest_plugin", "created."),
            must_not_contain=("Traceback",)
        )

    def tearDown(self):
        super(TestUnitestPluginPage, self).tearDown()
        settings.DEBUG = False

    def test_plugin_page(self):
        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=("String response from pylucid_plugins.unittest_plugin.view_root()",),
            must_not_contain=("Traceback",)
        )

    def test_messages(self):
        response = self.client.get(self.url + "test_messages/")
        self.assertResponse(response,
            must_contain=(
                "Response from unittest_plugin.test_messages()",
                "A &#39;debug&#39; message",
                "A &#39;info&#39; message",
                "A &#39;success&#39; message",
                "A &#39;warning&#39; message",
                "A &#39;error&#39; message",
            ),
            must_not_contain=("Traceback",)
        )

    def test_cache(self):
        url = self.url + "test_cache/"
        client = Client()

        # put page to cache with [one]
        client.cookies["test_messages"] = "one"
        response = client.get(url)
        self.assertResponse(response,
            must_contain=(
                "Response from unittest_plugin.test_cache() [one]",
            ),
            must_not_contain=("Traceback",)
        )
        self.assertFalse(response._from_cache)

        # request page from cache, so not [two] -> old content with [one]
        client.cookies["test_messages"] = "two"
        response = client.get(url)
        self.assertResponse(response,
            must_contain=(
                "Response from unittest_plugin.test_cache() [one]",
            ),
            must_not_contain=("Traceback",)
        )
        self.assertTrue(response._from_cache)

    def test_non_caching_pages_with_messages(self):
        system_preferences = SystemPreferencesForm()
        system_preferences["message_level_anonymous"] = message_constants.DEBUG
        system_preferences.save()

        url = self.url + "test_messages/"
        client = Client()

        # Put page into cache?
        client.cookies["test_messages"] = "one"
        response = client.get(url)
        self.assertResponse(response,
            must_contain=(
                "Response from unittest_plugin.test_messages() [one]",
                "A &#39;debug&#39; message",
                "A &#39;info&#39; message",
                "A &#39;success&#39; message",
                "A &#39;warning&#39; message",
                "A &#39;error&#39; message",
            ),
            must_not_contain=("Traceback",)
        )
        self.assertFalse(response._from_cache)

        # Request from cache?
        client.cookies["test_messages"] = "two"
        response = client.get(url)
        self.assertResponse(response,
            must_contain=(
                "Response from unittest_plugin.test_messages() [two]",
                "A &#39;debug&#39; message",
                "A &#39;info&#39; message",
                "A &#39;success&#39; message",
                "A &#39;warning&#39; message",
                "A &#39;error&#39; message",

            ),
            must_not_contain=("Traceback",)
        )
        self.assertFalse(response._from_cache)

    def test_MessageLevelMiddleware(self):
        url = self.url + "test_messages/"
        client = Client()
        system_preferences = SystemPreferencesForm()

        def get_response(level):
            system_preferences["message_level_anonymous"] = level
            system_preferences.save()
            return client.get(url)

        self.assertResponse(get_response(message_constants.DEBUG),
            must_contain=(
                "Response from unittest_plugin.test_messages()",
                "A &#39;debug&#39; message",
                "A &#39;info&#39; message",
                "A &#39;success&#39; message",
                "A &#39;warning&#39; message",
                "A &#39;error&#39; message",
            ),
            must_not_contain=("Traceback",)
        )

        self.assertResponse(get_response(message_constants.INFO),
            must_contain=(
                "Response from unittest_plugin.test_messages()",
                "A &#39;info&#39; message",
                "A &#39;success&#39; message",
                "A &#39;warning&#39; message",
                "A &#39;error&#39; message",
            ),
            must_not_contain=("Traceback",
                "A &#39;debug&#39; message",
            )
        )

        self.assertResponse(get_response(message_constants.SUCCESS),
            must_contain=(
                "Response from unittest_plugin.test_messages()",
                "A &#39;success&#39; message",
                "A &#39;warning&#39; message",
                "A &#39;error&#39; message",
            ),
            must_not_contain=("Traceback",
                "A &#39;info&#39; message",
                "A &#39;debug&#39; message",
            )
        )

        self.assertResponse(get_response(message_constants.WARNING),
            must_contain=(
                "Response from unittest_plugin.test_messages()",
                "A &#39;warning&#39; message",
                "A &#39;error&#39; message",
            ),
            must_not_contain=("Traceback",
                "A &#39;success&#39; message",
                "A &#39;info&#39; message",
                "A &#39;debug&#39; message",
            )
        )

        self.assertResponse(get_response(message_constants.ERROR),
            must_contain=(
                "Response from unittest_plugin.test_messages()",
                "A &#39;error&#39; message",
            ),
            must_not_contain=("Traceback",
                "A &#39;warning&#39; message",
                "A &#39;success&#39; message",
                "A &#39;info&#39; message",
                "A &#39;debug&#39; message",
            )
        )


class UnittestPluginCsrfTests(basetest.BaseUnittest):
    def _pre_setup(self, *args, **kwargs):
        super(UnittestPluginCsrfTests, self)._pre_setup(*args, **kwargs)

        self.login("superuser")

        new_plugin_page_url = reverse("PageAdmin-new_plugin_page")
        test_slug = "ut_plugin"
        response = self.client.post(new_plugin_page_url,
            data={'app_label': 'pylucid_project.pylucid_plugins.unittest_plugin',
            'design': 1,
            'position': 0,
            'slug': test_slug,
            'urls_filename': 'urls.py'
            }
        )
        self.url = "http://testserver/en/%s/" % test_slug
        self.assertRedirect(response, self.url, status_code=302)

        response = self.client.get(self.url)
        self.assertResponse(response,
            must_contain=("New plugin page", "unittest_plugin", "created."),
            must_not_contain=("Traceback",)
        )

        self.csrf_client = Client(enforce_csrf_checks=True)
        test_user = self._get_userdata("superuser")
        self.csrf_client.login(
            username=test_user["username"], password=test_user["password"]
        )

    def request_csrf_token(self, url):
        response = self.csrf_client.get(url)
        self.assertResponse(response,
            must_contain=("<input type='hidden' name='csrfmiddlewaretoken' value='",),
            must_not_contain=()
        )
        csrf_cookie = response.cookies.get(settings.CSRF_COOKIE_NAME, False)
        csrf_token = csrf_cookie.value
        return csrf_token

    #--------------------------------------------------------------------------

    def test_get_csrf_exempt_view(self):
        response = self.csrf_client.get(self.url + "csrf_exempt_view/")
        self.assertResponse(response,
            must_contain=("<dt>view name</dt><dd>csrf_exempt_view()</dd>",),
            must_not_contain=("Traceback",)
        )

    def test_post_csrf_exempt_view(self):
        response = self.csrf_client.post(self.url + "csrf_exempt_view/")
        self.assertResponse(response,
            must_contain=("<dt>view name</dt><dd>csrf_exempt_view()</dd>",),
            must_not_contain=("Traceback",)
        )

    #--------------------------------------------------------------------------

    def test_get_csrf_no_decorator_view(self):
        response = self.csrf_client.get(self.url + "csrf_no_decorator_view/")
        self.assertResponse(response,
            must_contain=("<dt>view name</dt><dd>csrf_no_decorator_view()</dd>",),
            must_not_contain=("Traceback",)
        )

    def test_post_csrf_no_decorator_view_without_token(self):
        response = self.csrf_client.post(self.url + "csrf_no_decorator_view/")
        self.assertResponse(response,
            must_contain=("CSRF verification failed. Request aborted.",),
            must_not_contain=("Traceback",)
        )
        self.assertStatusCode(response, 403)

    def test_post_csrf_no_decorator_view_with_token(self):
        # get the current csrf token
        csrf_token = self.request_csrf_token(self.url + "csrf_no_decorator_view/")

        response = self.csrf_client.post(
            self.url + "csrf_no_decorator_view/",
            data={"csrfmiddlewaretoken": csrf_token}
        )
        self.assertResponse(response,
            must_contain=(
                "<dt>view name</dt><dd>csrf_no_decorator_view()</dd>",
                '<dt>request.POST["csrfmiddlewaretoken"]</dt><dd>%s</dd>' % csrf_token,
            ),
            must_not_contain=("Traceback",)
        )

    #--------------------------------------------------------------------------

    def test_get_csrf_in_get_view(self):
        response = self.csrf_client.get("/en/welcome/?unittest_plugin=csrf_test")
        self.assertResponse(response,
            must_contain=("<dt>view name</dt><dd>csrf get view</dd>",),
            must_not_contain=("Traceback",)
        )

    def test_post_csrf_in_get_view_without_token(self):
        response = self.csrf_client.post("/en/welcome/?unittest_plugin=csrf_test")
        self.assertResponse(response,
            must_contain=("CSRF verification failed. Request aborted.",),
            must_not_contain=("Traceback",)
        )
        self.assertStatusCode(response, 403)

    def test_post_csrf_in_get_view_with_token(self):
        # get the current csrf token
        csrf_token = self.request_csrf_token("/en/welcome/?unittest_plugin=csrf_test")

        # send a POST with csrf token
        response = self.csrf_client.post(
            "/en/welcome/?unittest_plugin=csrf_test",
            data={"csrfmiddlewaretoken": csrf_token}
        )
        self.assertResponse(response,
            must_contain=(
                "<dt>view name</dt><dd>csrf get view</dd>",
                '<dt>request.POST["csrfmiddlewaretoken"]</dt><dd>%s</dd>' % csrf_token,
            ),
            must_not_contain=("Traceback",)
        )



########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

from django.conf.urls.defaults import patterns, url

import views

urlpatterns = patterns('',
    url(
        r'^$',
        views.view_root, name='UnittestPlugin-view_root'
    ),

    #--------------------------------------------------------------------------    
    url(
        r'^csrf_exempt_view/$',
        views.csrf_exempt_view, name='UnittestPlugin-csrf_exempt_view'
    ),
    url(
        r'^csrf_no_decorator_view/$',
        views.csrf_no_decorator_view, name='UnittestPlugin-csrf_no_decorator_view'
    ),
    #--------------------------------------------------------------------------
    url(
        r'^test_HttpResponse/$',
        views.test_HttpResponse, name='UnittestPlugin-test_HttpResponse'
    ),
    url(
        r'^test_plugin_template/$',
        views.test_plugin_template, name='UnittestPlugin-test_plugin_template'
    ),
    url(
        r'^args_test/(?P<arg1>.*?)/(?P<arg2>.*?)/$',
        views.test_url_args, name='UnittestPlugin-test_url_args'
    ),
    url(
        r'^test_return_none/$',
        views.test_return_none, name='UnittestPlugin-test_return_none'
    ),
    url(
        r'^test_url_reverse/(?P<url_name>.*?)/$',
        views.test_url_reverse, name='UnittestPlugin-test_url_reverse'
    ),
    url(
        r'^test_PyLucid_api/$',
        views.test_PyLucid_api, name='UnittestPlugin-test_PyLucid_api'
    ),
    url(
        r'^test_BreadcrumbPlugin/$',
        views.test_BreadcrumbPlugin, name='UnittestPlugin-test_BreadcrumbPlugin'
    ),

    url(
        r'^test_add_headfiles/$',
        views.test_add_headfiles, name='UnittestPlugin-test_add_headfiles'
    ),

    url(
        r'^test_cache/$',
        views.test_cache, name='UnittestPlugin-test_cache'
    ),
    url(
        r'^test_messages/$',
        views.test_messages, name='UnittestPlugin-test_messages'
    ),

)

########NEW FILE########
__FILENAME__ = views
# coding: utf-8

"""
    PyLucid unittest plugin
    ~~~~~~~~~~~~~~~~~~~~~~~
    
    For plugin API unittest. 
    
    This plugin would be symlinked into "./pylucid_project/pylucid_plugins/" before 
    unittests starts. This would be done in pylucid_project.tests.test_tools.test_runner.
    
    note:
        You can also use the unittest_plugin in "normal" way:
            * symlink it by hand into pylucid_plugins
            * create a test PluginPage
            * request the following urls:
                .../csrf_no_decorator_view/
                .../csrf_exempt_view/
                /?unittest_plugin=csrf_test

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

from django import http
from django.contrib import messages
from django.core.urlresolvers import reverse
from django.shortcuts import render_to_response
from django.utils.log import getLogger
from django.views.decorators.csrf import csrf_exempt

from pylucid_project.apps.pylucid.models import Language
from pylucid_project.apps.pylucid.decorators import render_to


logger = getLogger("pylucid.unittest_plugin")

#_____________________________________________________________________________
# http_get_view()

GET_KEY = "unittest_plugin" # plugin name

ACTION_NONE_RESPONSE = "NoneResponse"

ACTION_STRING_RESPONSE = "StringResponse"
STRING_RESPONSE = "String response from http_get_view() unittest plugin."

ACTION_HTTP_RESPONSE = "HttpResponse"
HTTP_RESPONSE = "HttpResponse from unittest plugin."

ACTION_REDIRECT = "RedirectResponse"
REDIRECT_URL = "/"


def http_get_view(request):
    action = request.GET[GET_KEY]

    logger.debug("http_get_view() called with action: %r" % action)

    if action == "MSG_ERROR":
        logger.debug("MSG_ERROR message created.")
        messages.error(request, message="A error messages")
        return

    elif action == "csrf_test":
        return _csrf_page(request, view_name="csrf get view")

    elif action == ACTION_NONE_RESPONSE:
        # normal PageContent would be used.
        return None

    elif action == ACTION_STRING_RESPONSE:
        # replace the PageContent with the returned string.
        return STRING_RESPONSE

    elif action == ACTION_HTTP_RESPONSE:
        # replace the complete response content.
        return http.HttpResponse(content=HTTP_RESPONSE)

    elif action == ACTION_REDIRECT:
        # redirect to a url
        return http.HttpResponseRedirect(REDIRECT_URL)

    else:
        raise AssertionError("Wrong GET action parameter!")


#_____________________________________________________________________________
# CsrfTest

@render_to("unittest_plugin/csrf_info.html")
def _csrf_page(request, view_name):
    context = {
        "view_name": view_name,
        "request_dont_enforce_csrf_checks": getattr(request, "_dont_enforce_csrf_checks", None),
    }
    return context

@csrf_exempt
def csrf_exempt_view(request):
    return _csrf_page(request, view_name="csrf_exempt_view()")

def csrf_no_decorator_view(request):
    return _csrf_page(request, view_name="csrf_no_decorator_view()")


#_____________________________________________________________________________
# PluginPage views for unittests in test_pluginAPI

PLUGINPAGE_ROOT_STRING_RESPONSE = "String response from pylucid_plugins.unittest_plugin.view_root()"
PLUGINPAGE_HTTP_RESPONSE = "HttpResponse response from pylucid_plugins.unittest_plugin.test_HttpResponse()"
PLUGINPAGE_TEMPLATE_RESPONSE = "Template response from pylucid_plugins.unittest_plugin.test_plugin_template()"
PLUGINPAGE_URL_ARGS_PREFIX = "Unittest url args:"
PLUGINPAGE_URL_REVERSE_PREFIX = "Unitest url reverse:"
PLUGINPAGE_API_TEST_CONTENT = "Test content for unittest_plugin.test_PyLucid_api()"
PLUGINPAGE_API_TEST_PAGE_MSG = "page messages test for unittest_plugin.test_PyLucid_api()"

def view_root(request):
    """ String response """
    return PLUGINPAGE_ROOT_STRING_RESPONSE

def test_HttpResponse(request):
    """ replace the complete response with own HttpResponse object """
    return http.HttpResponse(PLUGINPAGE_HTTP_RESPONSE)

def test_plugin_template(request):
    """ Use own template witch use {% extends template_name %} """
    context = request.PYLUCID.context
    context["content"] = PLUGINPAGE_TEMPLATE_RESPONSE
    return render_to_response('unittest_plugin/template_test.html', context)

def test_url_args(request, arg1, arg2):
    """ test arguments in urls """
    return http.HttpResponse("%s [%r] [%r]" % (PLUGINPAGE_URL_ARGS_PREFIX, arg1, arg2))

def test_return_none(request):
    """ return None -> raised a error """
    return None

def test_url_reverse(request, url_name):
    """ Test the django url reverse function """
    url = reverse(url_name)
    return http.HttpResponse("%s [%r]" % (PLUGINPAGE_URL_REVERSE_PREFIX, url))

def test_PyLucid_api(request):
    """
    Test the PyLucid API
    see also: http://www.pylucid.org/permalink/133/pylucid-objects
    """
    messages.info(request, PLUGINPAGE_API_TEST_PAGE_MSG)

    context = request.PYLUCID.context
    output = []
    context_middlewares = request.PYLUCID.context_middlewares.keys()
    context_middlewares.sort()
    output.append("context_middlewares: %s" % context_middlewares)
    output.append("lang_entry: %r" % request.PYLUCID.current_language)
    output.append("pagetree: %r" % request.PYLUCID.pagetree)
    output.append("pagemeta: %r" % request.PYLUCID.pagemeta)

    default_lang_entry = Language.objects.get_or_create_default(request)
    output.append("default_lang_code: %s" % default_lang_entry.code)
    output.append("default_lang_entry: %r" % default_lang_entry)

    context["output"] = output
    context["content"] = PLUGINPAGE_API_TEST_CONTENT
    return render_to_response('unittest_plugin/API_test.html', context)

#_____________________________________________________________________________
# PluginPage views for unittests in test_PluginBreadcrumb

ADDED_LINK_NAME = "added-link"
ADDED_LINK_TITLE = "Unittest added link"
ADDED_LINK_URL = "the/added/url/"
ADDED_LINK_RESPONSE_STRING = "test_PluginBreadcrumb content"

def test_BreadcrumbPlugin(request):
    """
    Test view for tests.test_PluginBreadcrumb.
    Add a link to the bradcrumbs.
    """
    lang = request.PYLUCID.current_language
    breadcrumb = request.PYLUCID.request.PYLUCID.context_middlewares["breadcrumb"]
    add_url = "/%s/%s" % (lang.code, ADDED_LINK_URL)
    breadcrumb.add_link(name=ADDED_LINK_NAME, title=ADDED_LINK_TITLE, url=add_url)

    return ADDED_LINK_RESPONSE_STRING


#_____________________________________________________________________________
# Add headfiles tests

def test_add_headfiles(request):
    """
    Add content into html head with {% extrahead %} block tag in plugin template.
    """
    context = request.PYLUCID.context
    output = render_to_response('unittest_plugin/test_extrahead_blocktag.html', context)
    return output

#_____________________________________________________________________________


def test_cache(request):
    msg = request.COOKIES.get("test_messages", "not set")
    return "Response from unittest_plugin.test_cache() [%s]" % msg

def test_messages(request):
    for msg_type in ("debug", "info", "success", "warning", "error"):
        callable = getattr(messages, msg_type)
        callable(request, "A %r message" % msg_type)
    msg = request.COOKIES.get("test_messages", "not set")
    return "Response from unittest_plugin.test_messages() [%s]" % msg


########NEW FILE########
__FILENAME__ = urls
# coding: utf-8

"""
    global url patterns
    ~~~~~~~~~~~~~~~~~~~

    :copyleft: 2009-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import sys

from django.conf import settings
from django.conf.urls.defaults import patterns, url, include
from django.contrib import admin
from django.http import HttpResponse
from django.views.defaults import server_error, page_not_found


# TODO: Use own error views?
handler500 = server_error
handler404 = page_not_found


admin.autodiscover()


urlpatterns = patterns('',
    #_____________________________________
    # PYLUCID UPDATE SECTION
    url('^%s/update/' % settings.ADMIN_URL_PREFIX, include('pylucid_update.urls')),

    #_____________________________________
    # PYLUCID ADMIN
    url(r'^%s/' % settings.PYLUCID_ADMIN_URL_PREFIX, include('pylucid_admin.urls')),

    # move it somewhere?
    url(r'^comments/', include('django.contrib.comments.urls')),

    # https://docs.djangoproject.com/en/1.4/topics/i18n/translation/#module-django.views.i18n
    url(r'^jsi18n/(?P<packages>\S+?)/$', 'django.views.i18n.javascript_catalog'),

    #_____________________________________
    # DJANGO ADMIN PANEL
    url(r'^%s/' % settings.ADMIN_URL_PREFIX, include(admin.site.urls)),
)

#-----------------------------------------------------------------------------

# Default robots.txt content. If you want to use your own robots.txt, look into .htaccess
# more information: http://www.pylucid.org/permalink/390/robots-txt
if settings.DEBUG and not settings.RUN_WITH_DEV_SERVER:
    # Disallow access to all pages in DEBUG mode. 
    urlpatterns += patterns("",
        url(
            "^robots.txt$",
            lambda r: HttpResponse("User-agent: *\nDisallow: /", mimetype="text/plain")
        ),
    )
else:
    # Disallow all URLs that one '?' contains
    urlpatterns += patterns("",
        url(
            "^robots.txt$",
            lambda r: HttpResponse("User-agent: *\nDisallow: /*?", mimetype="text/plain")
        ),
    )

#-----------------------------------------------------------------------------

# serve static files
if settings.RUN_WITH_DEV_SERVER and "--insecure" in sys.argv and "--nostatic" in sys.argv:
    # The automatic static serve is without index views.
    # We add 'django.views.static.serve' here, to add show_indexes==True
    #
    # The developer server must be start with --insecure and --nostatic e.g.:
    #     ./manage.py runserver --insecure --nostatic
    #
    # https://docs.djangoproject.com/en/1.4/ref/contrib/staticfiles/#runserver
    print " *** Serve static files from %r at %r ***" % (settings.STATIC_ROOT, settings.STATIC_URL)
    urlpatterns += patterns('',
        url('^%s/(?P<path>.*)$' % settings.STATIC_URL.strip("/"), 'django.views.static.serve',
            {'document_root': settings.STATIC_ROOT, 'show_indexes': True}),
    )
    print " *** Serve media files from %r at %r ***" % (settings.MEDIA_ROOT, settings.MEDIA_URL)
    urlpatterns += patterns('',
        url('^%s/(?P<path>.*)$' % settings.MEDIA_URL.strip("/"), 'django.views.static.serve',
            {'document_root': settings.MEDIA_ROOT, 'show_indexes': True}),
    )

urlpatterns += patterns('',
    url('^', include('pylucid.urls')),
)

#_____________________________________________________________________________
# use the undocumented django function to add the "lucidTag" to the tag library.
# 
from django.template import add_to_builtins
add_to_builtins('pylucid_project.apps.pylucid.defaulttags')

########NEW FILE########
__FILENAME__ = closure_compiler
#!/usr/bin/env python
# coding: utf-8

"""
    static javascript helper
    ~~~~~~~~~~~~~~~~~~~~~~~~
    
    Get JavaScript files and save it compressed.
    use:
        http://code.google.com/closure/compiler/

    :copyleft: 2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import datetime
import json # New in Python v2.6
import os
import pprint
import time
import urllib


class ClosureCompiler(object):
    compile_url = "http://closure-compiler.appspot.com/compile"

    # http://code.google.com/closure/compiler/docs/api-ref.html
    compile_defaults = {
        # Required Request Parameters
        "compilation_level": "SIMPLE_OPTIMIZATIONS",
        "output_format": "json",
        "output_info": ("compiled_code", "statistics"),
    }

    def __init__(self, out_dir):
        self.out_dir = out_dir

    def get_and_save(self, filename, urls):
        print "_" * 79
        print " *** %r ***" % filename
        print "urls:"
        print "\n".join(urls)

        post_data = self.compile_defaults.copy()
        post_data["code_url"] = urls
    #    print post_data
        params = urllib.urlencode(post_data, doseq=True)
    #    print params

        print "request %s..." % self.compile_url,
        start_time = time.time()
        f = urllib.urlopen(self.compile_url, params)
        payload = f.read()
        print "get response in %.2fsec" % (time.time() - start_time)

        response_data = json.loads(payload)
#        pprint.pprint(response_data)
        if not "compiledCode" in response_data:
            print "Response error, response data:"
            pprint.pprint(response_data)
        else:
            code = response_data["compiledCode"]

            statistics = response_data["statistics"]
            print "original size....:", statistics["originalSize"]
            print "compressed size..:", statistics["compressedSize"]
            print "compile time:", statistics["compileTime"]

            out_path = os.path.join(self.out_dir, filename)
            print "Write file %r..." % out_path,
            f = file(out_path, "w")
            f.write("/* content from:\n")
            for url in urls:
                f.write(" * %s\n" % url)
            f.write(" * closure compiled %s */\n" % datetime.date.today().isoformat())
            f.write(code)
            f.close()
            print "OK"

        print "-" * 79

########NEW FILE########
__FILENAME__ = crypt
# coding: utf-8

"""
    PyLucid.tools.crypt
    ~~~~~~~~~~~~~~~~~~~

    Routines for the PyLucid SHA-JS-Login.
    more info:
        http://www.pylucid.org/permalink/42/secure-login-without-https

    unittest: ./dev_scripts/unittests/unittest_crypt.py

    :copyleft: 2007-2013 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import base64
import hashlib
import os
import random
import re
import sys
import time

if __name__ == "__main__":
    print "Local DocTest..."
    settings = type('Mock', (object,), {})()
    settings.SECRET_KEY = "DocTest"
    smart_str = str
else:
    from django.conf import settings
    from django.utils.encoding import smart_str


# Warning: Debug must always be False in productiv environment!
#DEBUG = True
DEBUG = False
if DEBUG:
    import warnings
    warnings.warn("Debugmode is on", UserWarning)

HASH_TYP = "sha1"

OLD_SALT_LEN = 5 # old length of the random salt value

# Django used 12 as default in hashers.SHA1PasswordHasher()
# number comes from django.utils.crypto.get_random_string()
SALT_LEN = 12 # new length of the random salt value

HASH_LEN = 40 # length of a SHA-1 hexdigest

# SHA-1 hexdigest + "sha1" + (2x "$") + salt length
SALT_HASH_LEN = HASH_LEN + 4 + 2 + SALT_LEN
OLD_SALT_HASH_LEN = HASH_LEN + 4 + 2 + OLD_SALT_LEN


class SaltHashError(Exception):
    pass

#______________________________________________________________________________

SHA1_RE = re.compile(r'[a-f0-9]{40}$')

def validate_sha_value(sha_value):
    """
    Check if the given >sha_value< is a possible SHA1 hexdigest ;)
    returned true or false

    Should we better use a RE method?
    http://www.python-forum.de/post-74657.html

    >>> validate_sha_value("wrong length")
    False
    >>> validate_sha_value(1234)
    False
    >>> validate_sha_value("right length but not a SHA1 hexdigest!!!")
    False
    >>> validate_sha_value("790f2ebcb902c966fb0e232515ec1319dc9118af")
    True
    """
    if not isinstance(sha_value, basestring):
        return False

    if SHA1_RE.match(sha_value):
        return True

    return False
#
#    if not (isinstance(sha_value, basestring) and len(sha_value) == HASH_LEN):
#        return False
#
#    try:
#        int(sha_value, 16)
#    except (ValueError, OverflowError), e:
#        return False
#    else:
#        return True

#______________________________________________________________________________


def get_new_seed(can_debug=True):
    """
    Generate a new, random seed value.

    >>> get_new_seed() # DEBUG is True in DocTest!
    'DEBUG_1234567890'
    >>> seed = get_new_seed(can_debug=False)
    >>> assert seed != 'DEBUG', "seed is: %s" % seed
    >>> assert len(seed) == HASH_LEN, "Wrong length: %s" % len(seed)
    """
    if can_debug and DEBUG:
        seed = "DEBUG_1234567890"
    else:
        raw_seed = "%s%s%s%s" % (
            random.randint(0, sys.maxint - 1), os.getpid(), time.time(),
            settings.SECRET_KEY
        )
        seed = hashlib.sha1(raw_seed).hexdigest()

    return seed


def get_new_salt(can_debug=True):
    """
    Generate a new, random salt value.

    >>> get_new_salt() # DEBUG is True in DocTest!
    'DEBUG_123456'
    >>> salt = get_new_salt(can_debug=False)
    >>> assert salt != 'DEBUG_1234567890', "salt is: %s" % salt
    >>> assert len(salt) == SALT_LEN, "Wrong length: %s" % len(salt)
    """
    seed = get_new_seed(can_debug)
    return seed[:SALT_LEN]

def get_pseudo_salt(*args):
    """
    generate a pseudo salt (used, if user is wrong)
    """
    temp = "".join([repr(arg) for arg in args])
    return hashlib.sha1(temp).hexdigest()[:SALT_LEN]


def make_hash(txt, salt):
    """
    make a SHA1 hexdigest from the given >txt< and >salt<.
    IMPORTANT:
        This routine must work like
        django.contrib.auth.models.User.set_password()!

    >>> make_hash(txt="test", salt='DEBUG')
    '790f2ebcb902c966fb0e232515ec1319dc9118af'
    """
    sha1hash = hashlib.sha1(salt + smart_str(txt)).hexdigest()
    return sha1hash


def get_salt_and_hash(txt):
    """
    Generate a hast value with a random salt
    returned salt and sha1hash as a tuple

    >>> get_salt_and_hash("test")
    ('sha1', 'DEBUG_123456', '9f5ee85f5c91adb5741d8f93483386989d5d49ae')
    """
    if not isinstance(txt, str):
        raise SaltHashError("Only string allowed!")

    salt = get_new_salt()
    sha1hash = make_hash(txt, salt)

    return (HASH_TYP, salt, sha1hash)


def make_salt_hash(txt):
    """
    make from the given string a hash with a salt value
    returned one string back

    >>> make_salt_hash("test")
    'sha1$DEBUG_123456$9f5ee85f5c91adb5741d8f93483386989d5d49ae'
    """
    salt_hash = "$".join(get_salt_and_hash(txt))
    return salt_hash


def check_salt_hash(txt, salt_hash):
    """
    compare txt with the salt-sha1hash.

    TODO: Should we used the django function for this?
        Look at: django.contrib.auth.models.check_password

    >>> salt_hash = make_salt_hash("test")
    >>> salt_hash
    'sha1$DEBUG_123456$9f5ee85f5c91adb5741d8f93483386989d5d49ae'
    >>> check_salt_hash("test", salt_hash)
    True
    """
#    if not (isinstance(txt, str) and isinstance(salt_hash, str)):
#        raise SaltHashError("Only string allowed!")

    if len(salt_hash) not in (SALT_HASH_LEN, OLD_SALT_HASH_LEN):
        raise SaltHashError("Wrong salt-sha1hash length.")

    try:
        hash_type, salt, sha1hash = salt_hash.split("$")
    except ValueError:
        raise SaltHashError("Wrong salt-sha1hash format.")

    if hash_type != "sha1":
        raise SaltHashError("Unsupported sha1hash method.")

    test_hash = make_hash(txt, salt)
#    raise
    if sha1hash != test_hash:
        msg = "salt-sha1hash compare failed."
        if DEBUG:
            msg += " (txt: '%s', salt: '%s', sha1hash: '%s', test_hash: '%s')" % (
                txt, salt, sha1hash, test_hash
            )
        raise SaltHashError(msg)

    return True


def salt_hash_to_dict(salt_hash):
    """
    >>> result = salt_hash_to_dict("sha$salt_value$the_SHA_value")
    >>> result == {'salt': 'salt_value', 'hash_type': 'sha', 'hash_value': 'the_SHA_value'}
    True
    """
    hash_type, salt, hash_value = salt_hash.split("$")
    return {
        "hash_type": hash_type,
        "salt": salt,
        "hash_value": hash_value
    }


#______________________________________________________________________________

class CryptLengthError(AssertionError):
    pass


def crypt(txt, key):
    """
    XOR ciphering
    >txt< and >key< should be unicode.

    >>> crypt("1234", "ABCD")
    u'pppp'
    """
    if len(txt) != len(key):
        raise CryptLengthError("XOR cipher error: %r and %r must have the same length!" % (txt, key))

    crypted = [unichr(ord(t) ^ ord(k)) for t, k in zip(txt, key)]
    return u"".join(crypted)


def encrypt(txt, key, use_base64=True, can_debug=True):
    """
    XOR ciphering with a SHA salt-hash checksum

    >>> encrypt(u"1234", u"ABCD") # DEBUG is True in DocTest!
    u'crypt 1234 with ABCD'

    >>> encrypt(u"1234", u"ABCD", can_debug=False)
    u'sha1$DEBUG_123456$91ca222581d9b8f61934d7bf25fb3625141cda91cHBwcA=='

    >>> encrypt(u"1234", u"ABCD", use_base64=False, can_debug=False)
    u'sha1$DEBUG_123456$91ca222581d9b8f61934d7bf25fb3625141cda91pppp'
    """
    if not (isinstance(txt, unicode) and isinstance(key, unicode)):
        raise UnicodeError("Only unicode allowed!")

    if can_debug and DEBUG:
        return "crypt %s with %s" % (txt, key)

    salt_hash = make_salt_hash(repr(txt))
    salt_hash = unicode(salt_hash)

    crypted = crypt(txt, key)
    if use_base64 == True:
        crypted = base64.b64encode(crypted)
    return salt_hash + crypted


def decrypt(crypted, key, use_base64=True, can_debug=True):
    """
    1. Decrypt a XOR crypted String.
    2. Compare the inserted sSHA salt-hash checksum.

    >>> decrypt('crypt 1234 with ABCD', "ABCD") # DEBUG is True in DocTest!
    u'1234'

    >>> crypted = encrypt(u"1234", u"ABCD", can_debug=False)
    >>> crypted
    u'sha1$DEBUG_123456$91ca222581d9b8f61934d7bf25fb3625141cda91cHBwcA=='
    >>> decrypt(crypted, u"ABCD", can_debug=False)
    u'1234'

    >>> decrypt(u'sha1$DEBUG$b323f546665b1f034742630133d1b489480a24e2cHBwcA==', u"ABCD", can_debug=False)
    u'1234'

    >>> crypted = encrypt(u"1234", u"ABCD", use_base64=False, can_debug=False)
    >>> decrypt(crypted, u"ABCD", use_base64=False, can_debug=False)
    u'1234'
    """
    crypted = unicode(crypted)
    key = unicode(key)

    if can_debug and DEBUG:
        txt, _, key2 = crypted.split(" ", 3)[1:]
        assert key == key2, "key: %s != key2: %s" % (key, key2)
        return txt

    salt_hash = str(crypted[:SALT_HASH_LEN])
    crypted1 = crypted[SALT_HASH_LEN:]
    if use_base64 == True:
        crypted1 = base64.b64decode(crypted1)
        crypted1 = unicode(crypted1)

    try:
        decrypted = crypt(crypted1, key)
    except CryptLengthError:
        # Try with the OLD_SALT_HASH_LEN
        salt_hash = str(crypted[:OLD_SALT_HASH_LEN])
        crypted2 = crypted[OLD_SALT_HASH_LEN:]
        if use_base64 == True:
            crypted2 = base64.b64decode(crypted2)
            crypted2 = unicode(crypted2)
        decrypted = crypt(crypted2, key)

    # raised a SaltHashError() if the checksum is wrong:
    check_salt_hash(repr(decrypted), salt_hash)

    return decrypted


#______________________________________________________________________________

def django_to_sha_checksum(django_salt_hash):
    """
    Create a JS-SHA-Checksum from the django user password.
    (For the unittest)

    The >django_salt_hash< is:
        user = User.objects.get(...)
        django_salt_hash = user.password

    >>> django_to_sha_checksum("sha1$DEBUG$50b412a7ef09f4035f2daca882a1f8bfbe263b62")
    ('DEBUG', u'crypt 50b412a7ef09f4035f2d with aca882a1f8bfbe263b62')
    """
    hash_typ, salt, hash_value = django_salt_hash.split("$")
    assert hash_typ == "sha1", "hash_value typ not supported!"
    assert len(hash_value) == HASH_LEN, "Wrong hash_value length! (Not a SHA1 hash_value?)"

    # Split the SHA1-Hash in two pieces
    sha_a = hash_value[:(HASH_LEN / 2)]
    sha_b = hash_value[(HASH_LEN / 2):]

    sha_a = unicode(sha_a)
    sha_b = unicode(sha_b)
    sha_checksum = encrypt(txt=sha_a, key=sha_b)

    return salt, sha_checksum

def make_sha_checksum2(raw_password):
    """
    Create a SHA1-JS-Login checksum from a plaintext password.

    >>> make_sha_checksum2("test")
    ('DEBUG_123456', u'crypt 9f5ee85f5c91adb5741d with 8f93483386989d5d49ae')
    """
    _, salt, hash_value = get_salt_and_hash(raw_password)

    return salt, make_sha_checksum(hash_value)

def make_sha_checksum(hash_value):
    """
    Made the needed sha_checksum for the SHA1-JS-Login.

    >>> make_sha_checksum("50b412a7ef09f4035f2daca882a1f8bfbe263b62")
    u'crypt 50b412a7ef09f4035f2d with aca882a1f8bfbe263b62'
    """
    # Split the SHA1-Hash in two pieces
    sha_a = hash_value[:(HASH_LEN / 2)]
    sha_b = hash_value[(HASH_LEN / 2):]

    sha_a = unicode(sha_a)
    sha_b = unicode(sha_b)
    sha_checksum = encrypt(txt=sha_a, key=sha_b)
    return sha_checksum


def check_js_sha_checksum(challenge, sha_a, sha_b, sha_checksum, loop_count, cnonce):
    """
    Check a PyLucid JS-SHA-Login

    >>> salt1 = "a salt value"
    >>> challenge = "debug"
    >>> loop_count = 5
    >>> cnonce = "0123456789abcdef0123456789abcdef01234567"
    >>> password = "test"
    >>>
    >>> hash_value = make_hash(password, salt1)
    >>> hash_value
    'f893fc3ebdfd886836822161b6bc2ccac955e014'
    >>> sha_checksum = make_sha_checksum(hash_value)
    >>> sha_checksum
    u'crypt f893fc3ebdfd88683682 with 2161b6bc2ccac955e014'
    >>>
    >>> sha_a = hash_value[:(HASH_LEN/2)]
    >>> sha_a
    'f893fc3ebdfd88683682'
    >>> sha_b = hash_value[(HASH_LEN/2):]
    >>> sha_b
    '2161b6bc2ccac955e014'
    >>> for i in range(loop_count):
    ...    sha_a
    ...    sha_a = hashlib.sha1("%s%s%s%s" % (sha_a, i, challenge, cnonce)).hexdigest()
    'f893fc3ebdfd88683682'
    '7416451ba99917ccd09cfb5168678308933ed82c'
    'ec569defb31299e6134ad8e0c03ff40ab37972da'
    'c8036fe582d777da7090a941e8405982b39a5a71'
    'a0a793881a87782364816ab3e433d02f4527acbb'
    >>> sha_a
    'fa5746d279f5be31fa031100837a6a6b0233467c'
    >>> check_js_sha_checksum(challenge, sha_a, sha_b, sha_checksum, loop_count, cnonce)
    True
    """
    local_sha_a = decrypt(sha_checksum, sha_b)

    for i in range(loop_count):
        local_sha_a = hashlib.sha1(
            "%s%s%s%s" % (local_sha_a, i, challenge, cnonce)
        ).hexdigest()

    if local_sha_a == sha_a:
        return True
    elif DEBUG:
        return "%r != %r" % (local_sha_a, sha_a)

    return False



if __name__ == "__main__":
    DEBUG = True

    import doctest
    print doctest.testmod(
        verbose=False
    )

########NEW FILE########
__FILENAME__ = css_color_utils
# coding:utf-8

"""
    CSS color utilities
    ~~~~~~~~~~~~~~~~~~~
    
    
    some parts are borrowed from colorname sourcecode (GPL v2):
        http://code.foosel.org/colorname (
        by: Philippe 'demod' Neumann and Gina 'foosel' Huge
        
    :copyleft: 2009-2010 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import re
import math


CSS_RE = re.compile(r'#([a-f0-9]{6})[\s;]', re.IGNORECASE)
CSS_CONVERT_RE = re.compile(r'#([a-f0-9])([a-f0-9])([a-f0-9]) *;', re.IGNORECASE)


class ColorVector(tuple):
    def __sub__(self, v):
        return (self[0] - v[0], self[1] - v[1], self[2] - v[2])

COLOR_NAMES = { # CSS3 names, http://www.w3.org/TR/css3-color/
    'indigo': ColorVector((75, 0, 130)),
    'gold': ColorVector((255, 215, 0)),
    'hotpink': ColorVector((255, 105, 180)),
    'firebrick': ColorVector((178, 34, 34)),
    'indianred': ColorVector((205, 92, 92)),
    'yellow': ColorVector((255, 255, 0)),
    'mistyrose': ColorVector((255, 228, 225)),
    'darkolivegreen': ColorVector((85, 107, 47)),
    'olive': ColorVector((128, 128, 0)),
    'darkseagreen': ColorVector((143, 188, 143)),
    'pink': ColorVector((255, 192, 203)),
    'tomato': ColorVector((255, 99, 71)),
    'lightcoral': ColorVector((240, 128, 128)),
    'orangered': ColorVector((255, 69, 0)),
    'navajowhite': ColorVector((255, 222, 173)),
    'lime': ColorVector((0, 255, 0)),
    'palegreen': ColorVector((152, 251, 152)),
    'darkslategrey': ColorVector((47, 79, 79)),
    'greenyellow': ColorVector((173, 255, 47)),
    'burlywood': ColorVector((222, 184, 135)),
    'seashell': ColorVector((255, 245, 238)),
    'mediumspringgreen': ColorVector((0, 250, 154)),
    'fuchsia': ColorVector((255, 0, 255)),
    'papayawhip': ColorVector((255, 239, 213)),
    'blanchedalmond': ColorVector((255, 235, 205)),
    'chartreuse': ColorVector((127, 255, 0)),
    'dimgray': ColorVector((105, 105, 105)),
    'black': ColorVector((0, 0, 0)),
    'peachpuff': ColorVector((255, 218, 185)),
    'springgreen': ColorVector((0, 255, 127)),
    'aquamarine': ColorVector((127, 255, 212)),
    'white': ColorVector((255, 255, 255)),
    'orange': ColorVector((255, 165, 0)),
    'lightsalmon': ColorVector((255, 160, 122)),
    'darkslategray': ColorVector((47, 79, 79)),
    'brown': ColorVector((165, 42, 42)),
    'ivory': ColorVector((255, 255, 240)),
    'dodgerblue': ColorVector((30, 144, 255)),
    'peru': ColorVector((205, 133, 63)),
    'lawngreen': ColorVector((124, 252, 0)),
    'chocolate': ColorVector((210, 105, 30)),
    'crimson': ColorVector((220, 20, 60)),
    'forestgreen': ColorVector((34, 139, 34)),
    'darkgrey': ColorVector((169, 169, 169)),
    'lightseagreen': ColorVector((32, 178, 170)),
    'cyan': ColorVector((0, 255, 255)),
    'mintcream': ColorVector((245, 255, 250)),
    'silver': ColorVector((192, 192, 192)),
    'antiquewhite': ColorVector((250, 235, 215)),
    'mediumorchid': ColorVector((186, 85, 211)),
    'skyblue': ColorVector((135, 206, 235)),
    'gray': ColorVector((128, 128, 128)),
    'darkturquoise': ColorVector((0, 206, 209)),
    'goldenrod': ColorVector((218, 165, 32)),
    'darkgreen': ColorVector((0, 100, 0)),
    'floralwhite': ColorVector((255, 250, 240)),
    'darkviolet': ColorVector((148, 0, 211)),
    'darkgray': ColorVector((169, 169, 169)),
    'moccasin': ColorVector((255, 228, 181)),
    'saddlebrown': ColorVector((139, 69, 19)),
    'grey': ColorVector((128, 128, 128)),
    'darkslateblue': ColorVector((72, 61, 139)),
    'lightskyblue': ColorVector((135, 206, 250)),
    'lightpink': ColorVector((255, 182, 193)),
    'mediumvioletred': ColorVector((199, 21, 133)),
    'slategrey': ColorVector((112, 128, 144)),
    'red': ColorVector((255, 0, 0)),
    'deeppink': ColorVector((255, 20, 147)),
    'limegreen': ColorVector((50, 205, 50)),
    'darkmagenta': ColorVector((139, 0, 139)),
    'palegoldenrod': ColorVector((238, 232, 170)),
    'plum': ColorVector((221, 160, 221)),
    'turquoise': ColorVector((64, 224, 208)),
    'lightgrey': ColorVector((211, 211, 211)),
    'lightgoldenrodyellow': ColorVector((250, 250, 210)),
    'darkgoldenrod': ColorVector((184, 134, 11)),
    'lavender': ColorVector((230, 230, 250)),
    'maroon': ColorVector((128, 0, 0)),
    'yellowgreen': ColorVector((154, 205, 50)),
    'sandybrown': ColorVector((244, 164, 96)),
    'thistle': ColorVector((216, 191, 216)),
    'violet': ColorVector((238, 130, 238)),
    'navy': ColorVector((0, 0, 128)),
    'magenta': ColorVector((255, 0, 255)),
    'dimgrey': ColorVector((105, 105, 105)),
    'tan': ColorVector((210, 180, 140)),
    'rosybrown': ColorVector((188, 143, 143)),
    'olivedrab': ColorVector((107, 142, 35)),
    'blue': ColorVector((0, 0, 255)),
    'lightblue': ColorVector((173, 216, 230)),
    'ghostwhite': ColorVector((248, 248, 255)),
    'honeydew': ColorVector((240, 255, 240)),
    'cornflowerblue': ColorVector((100, 149, 237)),
    'slateblue': ColorVector((106, 90, 205)),
    'linen': ColorVector((250, 240, 230)),
    'darkblue': ColorVector((0, 0, 139)),
    'powderblue': ColorVector((176, 224, 230)),
    'seagreen': ColorVector((46, 139, 87)),
    'darkkhaki': ColorVector((189, 183, 107)),
    'snow': ColorVector((255, 250, 250)),
    'sienna': ColorVector((160, 82, 45)),
    'mediumblue': ColorVector((0, 0, 205)),
    'royalblue': ColorVector((65, 105, 225)),
    'lightcyan': ColorVector((224, 255, 255)),
    'green': ColorVector((0, 128, 0)),
    'mediumpurple': ColorVector((147, 112, 216)),
    'midnightblue': ColorVector((25, 25, 112)),
    'cornsilk': ColorVector((255, 248, 220)),
    'paleturquoise': ColorVector((175, 238, 238)),
    'bisque': ColorVector((255, 228, 196)),
    'slategray': ColorVector((112, 128, 144)),
    'darkcyan': ColorVector((0, 139, 139)),
    'khaki': ColorVector((240, 230, 140)),
    'wheat': ColorVector((245, 222, 179)),
    'teal': ColorVector((0, 128, 128)),
    'darkorchid': ColorVector((153, 50, 204)),
    'deepskyblue': ColorVector((0, 191, 255)),
    'salmon': ColorVector((250, 128, 114)),
    'darkred': ColorVector((139, 0, 0)),
    'steelblue': ColorVector((70, 130, 180)),
    'palevioletred': ColorVector((216, 112, 147)),
    'lightslategray': ColorVector((119, 136, 153)),
    'aliceblue': ColorVector((240, 248, 255)),
    'lightslategrey': ColorVector((119, 136, 153)),
    'lightgreen': ColorVector((144, 238, 144)),
    'orchid': ColorVector((218, 112, 214)),
    'gainsboro': ColorVector((220, 220, 220)),
    'mediumseagreen': ColorVector((60, 179, 113)),
    'lightgray': ColorVector((211, 211, 211)),
    'mediumturquoise': ColorVector((72, 209, 204)),
    'lemonchiffon': ColorVector((255, 250, 205)),
    'cadetblue': ColorVector((95, 158, 160)),
    'lightyellow': ColorVector((255, 255, 224)),
    'lavenderblush': ColorVector((255, 240, 245)),
    'coral': ColorVector((255, 127, 80)),
    'purple': ColorVector((128, 0, 128)),
    'aqua': ColorVector((0, 255, 255)),
    'whitesmoke': ColorVector((245, 245, 245)),
    'mediumslateblue': ColorVector((123, 104, 238)),
    'darkorange': ColorVector((255, 140, 0)),
    'mediumaquamarine': ColorVector((102, 205, 170)),
    'darksalmon': ColorVector((233, 150, 122)),
    'beige': ColorVector((245, 245, 220)),
    'blueviolet': ColorVector((138, 43, 226)),
    'azure': ColorVector((240, 255, 255)),
    'lightsteelblue': ColorVector((176, 196, 222)),
    'oldlace': ColorVector((253, 245, 230)),
}


def hypot(a, b):
    return math.sqrt(a * a + b * b)


def calc_distance(a, b):
    """
    @return: the euclidean distance between the vectors "a" and "b"
    @param a,b: ColorVector objects
    
    >>> calc_distance(ColorVector((255, 255, 255)), ColorVector((255, 255, 255)))
    0.0
    >>> calc_distance(ColorVector((255, 255, 255)), ColorVector((255, 255, 128)))
    127.0
    >>> calc_distance(ColorVector((255, 255, 255)), ColorVector((255, 0, 255)))
    255.0
    """
    return reduce(hypot, a - b)


def hex_string2colorvector(hex_string):
    r = int(hex_string[:2], 16)
    g = int(hex_string[2:4], 16)
    b = int(hex_string[4:6], 16)
    return ColorVector((r, g, b))


def hex2color_names(hex_string):
    """
    >>> sorted(hex2color_names("FF0000"))[0]
    (0.0, 'red')
    >>> sorted(hex2color_names("faebd7"))[0]
    (0.0, 'antiquewhite')
    >>> sorted(hex2color_names("faebd4"))[0]
    (3.0, 'antiquewhite')
    """
    sourcecolor = hex_string2colorvector(hex_string)
    result = []
    for color_name, colorvector in COLOR_NAMES.iteritems():
        distance = calc_distance(sourcecolor, colorvector)
        result.append((distance, color_name))
    return result


def hex2color_name(hex_string):
    """
    >>> hex2color_name("7b68ee")
    (0.0, 'mediumslateblue')
    >>> hex2color_name("f5f5f5")
    (0.0, 'whitesmoke')
    >>> hex2color_name("f5f3f5")
    (2.0, 'whitesmoke')
    """
    sourcecolor = hex_string2colorvector(hex_string)
    best_distance = 256
    best_name = "unknown"
    for color_name, colorvector in COLOR_NAMES.iteritems():
        distance = calc_distance(sourcecolor, colorvector)
        if distance < best_distance:
            best_distance = distance
            best_name = color_name
            if distance == 0.0:
                break

    return (best_distance, best_name)


#------------------------------------------------------------------------------


CSS_RE2 = re.compile(r'#([a-f0-9]{3,6}) *;', re.IGNORECASE)

def unify_spelling(content):
    """
    unify the 'spelling' of all existing css color values.
    
    >>> unify_spelling("color1: #f00; color2: #Ff0000;")
    ('color1: #ff0000; color2: #ff0000; color3: #aabbcc;', set(['ff0000']))
    
    >>> unify_spelling("color: #aAbBcC  ;")
    ('color: #aabbcc;', set(['aabbcc']))
    """
    existing_values = set()
    def callback(matchobj):
        css_value = matchobj.group(1)
        if len(css_value) == 3:
            # convert 3 length css color values to 6 length
            css_value = css_value[0] + css_value[0] + css_value[1] + css_value[1] + css_value[2] + css_value[2]
        css_value = css_value.lower()

        existing_values.add(css_value)
        return "#%s;" % css_value

    new_content = CSS_RE2.sub(callback, content)
    return new_content, existing_values




def filter_content(content):
    """
    Skip all lines, start with .pygments - Used in update routine.
    Note: result is not valid CSS!
    """
    result = []
    for line in content.splitlines():
        line = line.strip()
        if line and not line.startswith(".pygments"):
            result.append(line)
    return "\n".join(result)


def unique_color_name(existing_colors, hex_string):
    """   
    >>> unique_color_name((), "ffff00")
    'yellow'
    
    >>> unique_color_name(('yellow',), "ffff00")
    'yellow_2'
    
    >>> unique_color_name((), "0000f5")
    'blue_d10'
    
    >>> unique_color_name(('blue_d10',), "0000f5")
    'blue_d10_2'
    """
    distance, color_name = hex2color_name(hex_string)
    if distance > 5.0:
        # add distance if color values are too different
        color_name += "_d%i" % round(distance)

    if color_name in existing_colors:
        # name exist -> make unique by adding a number
        for no in xrange(2, 1000):
            # get a new color name, witch not exist yet.
            test_name = "%s_%s" % (color_name, no)
            if test_name not in existing_colors:
                color_name = test_name
                break
    return color_name


def convert_3to6_colors(content):
    """
    Convert all 3 length css color values to 6 length
    
    >>> convert_3to6_colors("#f00; #aabbcc;")
    '#ff0000; #aabbcc;'
    """
    new_content = CSS_CONVERT_RE.sub("#\g<1>\g<1>\g<2>\g<2>\g<3>\g<3>;", content)
    return new_content


def findall_color_values(content, case_sensitive=True):
    """
    return all css color values
    
    >>> findall_color_values("#ff0000;")
    set(['ff0000'])
    
    >>> sorted(findall_color_values("#aabbcc; #112233;"))
    ['112233', 'aabbcc']
    
    # If case_sensitive==False: merge different large- and lowercase:
    >>> sorted(findall_color_values("#C9C573; #c9c573;"))
    ['C9C573', 'c9c573']
    >>> findall_color_values("#C9C573; #c9c573;", case_sensitive=False)
    set(['c9c573'])
    
    # Note: Didn't find 3 length color values! Use convert_3to6_colors()
    >>> findall_color_values("#abc;")
    set([])
    """
    colors = set(CSS_RE.findall(content))
    if not case_sensitive:
        colors = set([c.lower() for c in colors])
    return colors



def extract_colors(content, existing_color_dict=None):
    """   
    >>> extract_colors(".foo { color: #000000; }")
    ('.foo { color: {{ black }}; }', {'black': '000000'})
    
    it's case insensitivity:
    >>> extract_colors(".foo{color:#C9C573;} .bar{color:#c9c573;}")
    ('.foo{color:{{ darkkhaki_d20 }};} .bar{color:{{ darkkhaki_d20 }};}', {'darkkhaki_d20': 'c9c573'})
    
    Convert/merge 3 length values:
    >>> extract_colors(".foo{color:#11AAff;} .bar{color:#1af;}")
    ('.foo{color:{{ deepskyblue_d27 }};} .bar{color:{{ deepskyblue_d27 }};}', {'deepskyblue_d27': '11aaff'})
    
    You can give a existing color map:
    >>> extract_colors(".foo { color: #000000; }", existing_color_dict={"black":"000000"})
    ('.foo { color: {{ black }}; }', {'black': '000000'})
    
    Existing color names would not overwritten
    >>> extract_colors(".foo { color: #112233; }", existing_color_dict={"black":"000000"})
    ('.foo { color: {{ darkslategrey_d61 }}; }', {'black': '000000', 'darkslategrey_d61': '112233'})
    
    Existing color names would not overwritten
    >>> extract_colors(".foo { color: #010101; }", existing_color_dict={"black":"000000"})
    ('.foo { color: {{ black_2 }}; }', {'black_2': '010101', 'black': '000000'})
    
    Skip non color values:
    >>> extract_colors("to short #12345; to long #1234567; /* no # 123; color #aa11ff-value */")
    ('to short #12345; to long #1234567; /* no # 123; color #aa11ff-value */', {})
    """
    new_content = convert_3to6_colors(content)

    colors = findall_color_values(new_content)

    if existing_color_dict:
        color_dict = existing_color_dict.copy()
        exist_color = dict([(v, k) for k, v in existing_color_dict.iteritems()])
    else:
        color_dict = {}
        exist_color = {}

    for color in colors:
        color_lower = color.lower()

        if color_lower in exist_color:
            # color exist in other case
            color_name = exist_color[color_lower]
        else:# new color
            color_name = unique_color_name(color_dict, color)

            color_dict[color_name] = color_lower
            exist_color[color_lower] = color_name

        new_content = new_content.replace("#%s" % color, "{{ %s }}" % color_name)

    return new_content, color_dict


def replace_css_name(old_name, new_name, content):
    """
    >>> replace_css_name("old", "new", "color: {{ old }};")
    'color: {{ new }};'
    >>> replace_css_name("foo", "bar", "color: {{   foo   }};")
    'color: {{ bar }};'
    >>> replace_css_name("a", "b", "color: {{a}};")
    'color: {{ b }};'
    """
    return re.sub("\{\{\s*(" + old_name + ")\s*\}\}", "{{ %s }}" % new_name, content)


def get_new_css_names(existing_colors, content):
    """
    >>> get_new_css_names((), "{{ new }}")
    ['new']
    >>> get_new_css_names(("old",), "foo {{ old }} bar {{ new }}!")
    ['new']
    >>> get_new_css_names(("old",), "foo {{  old  }} bar {{  new  }}!")
    ['new']
    >>> get_new_css_names(("old",), "foo {{old}} bar {{new}}!")
    ['new']
    >>> get_new_css_names((), "foo {{ #ffddee }} bar {{new}}!")
    ['new']
    """
    # FIXME: Rexp should not match on colors!
    raw_colors = re.findall("\{\{\s*(.*?)\}\}", content)
    colors = set([color.strip() for color in raw_colors])
    new_colors = [color for color in colors if not color.startswith("#") and not color in existing_colors]
    return new_colors




if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = diff
# -*- coding: utf-8 -*-
"""
    PyLucid.utils.diff
    ~~~~~~~~~~~~~~~~~~

    combine difflib.Differ() with pygments.

    Used request.render.highlight or request.render.get_hightlighted


    example-1::
        from PyLucid.tools.Diff import display_diff
        display_diff(file_content, db_content, self.request)

    example-2::
        from PyLucid.tools.Diff import get_diff
        html_diff_page = get_diff(file_content, db_content, self.request)
        self.response.write(html_diff_page)


    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2007-2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


import difflib


def diff_lines(content1, content2):
    """
    Display a diff without pygments.
    """
    results = []
    diff = make_diff(content1, content2)

    def is_diff_line(line):
        for char in ("-", "+", "?"):
            if line.startswith(char):
                return True
        return False

    old_line = ""
    in_block = False
    old_lineno = lineno = 0
    for line in diff:
        if line.startswith(" ") or line.startswith("+"):
            lineno += 1

        if old_lineno == lineno:
            display_line = "%4s | %s" % ("", line.rstrip())
        else:
            display_line = "%4s | %s" % (lineno, line.rstrip())

        if is_diff_line(line):
            if not in_block:
                results.append("...")
                # Display previous line
                results.append(old_line)
                in_block = True

            results.append(display_line)
        else:
            if in_block:
                # Display the next line after a diff-block
                results.append(display_line)
            in_block = False

        old_line = display_line
        old_lineno = lineno
    results.append("...")

    return "\n".join(results)



def make_diff(content1, content2, mode="Differ"):
    """
    returns the diff as a String, made with difflib.Differ.
    """
    def prepare(content):
        if isinstance(content, (list, tuple)):
            return content

        return content.splitlines()

    content1 = prepare(content1)
    content2 = prepare(content2)

    if mode == "Differ":
        diff = difflib.Differ().compare(content1, content2)
    elif mode == "HtmlDiff":
        diff = difflib.HtmlDiff(tabsize=4).make_table(content1, content2)
    elif mode == "unified":
        diff = difflib.unified_diff(content1, content2)
    else:
        raise AssertionError("diff mode %r unknown." % mode)

    return diff

########NEW FILE########
__FILENAME__ = escape
# -*- coding: utf-8 -*-

"""
    PyLucid escape
    ~~~~~~~~~~~~~~
    
    * Escape "&", "<", ">" and django template tags chars like "{" and "}"
    * Escape only django template tags chars like "{" and "}"

    Last commit info:
    ~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2007-2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details
"""

import shlex, re
from xml.sax.saxutils import escape as sax_escape

from django.utils.safestring import mark_safe


ENTITIES = {
    "{{" : "&#x7B;&#x7B;",
    "}}" : "&#x7D;&#x7D;",
    "{%" : "&#x7B;%",
    "%}" : "%&#x7D;",
}

def escape(txt):
    """
    Escape "&", "<", ">" and django template tags chars like "{" and "}"
    defined in ENTITIES to the HTML character entity.
    >>> escape("<test1> & {{ test2 }} {% test3 %}")
    '&lt;test1&gt; &amp; &#x7B;&#x7B; test2 &#x7D;&#x7D; &#x7B;% test3 %&#x7D;'
    """
    txt = sax_escape(txt, entities=ENTITIES)
    return mark_safe(txt) 

def escape_django_tags(txt):
    """
    Escape only django template tags chars like "{" and "}" defined in ENTITIES
    to the HTML character entity.

    >>> escape_django_tags("<test1> &")
    '<test1> &'

    >>> escape_django_tags("{{ test2 }} {% test3 %}")
    '&#x7B;&#x7B; test2 &#x7D;&#x7D; &#x7B;% test3 %&#x7D;'
    """
    for source, dest in ENTITIES.iteritems():
        txt = txt.replace(source, dest)
    return txt


if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."
########NEW FILE########
__FILENAME__ = form_utils
# coding:utf-8

def make_kwargs(data, keys):
    """
    Simple form util for transfer values from a dict.
    If you have a form for more than one model and you would like to easy get
    all needed key/values for the models.
    
    >>> POST = {1:"one", 2:"two", 3:"three"}
    >>> make_kwargs(POST, keys=[1,3])
    {1: 'one', 3: 'three'}
    >>> make_kwargs(POST, keys=[2,99])
    {2: 'two'}
    """
    kwargs = {}
    for key in keys:
        if key in data:
            kwargs[key] = data[key]
    return kwargs


if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = i18n_utils
# encoding: utf-8

"""
    i18n utilities
    ~~~~~~~~~~~~~~
    
    :copyleft: 2011 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""


def filter_by_language(values_list, prefered_languages_pk):
    """
    Filter existing items with client prefered languages. 
    
    values_list is like this: queryset.values_list("pk", "entry", "language")
    
    returns a list if ids, usage e.g.:
        used_content = self.model.objects.filter(pk__in=used_ids)
    
    Note: In this DocTest we have change the prefered_languages_pk numbers
    to strings, for better understanding:
    
    >>> values_list = [
    ...    (7, 5, "en"), (6, 5, "de"),
    ...    (1, 4, "en"), (2, 4, "de"), (5, 4, "es"),
    ...    (3, 3, "en"), (8, 3, "es"),
    ...    (9, 1, "en"), (10, 1, "xx"),
    ...    (4, 2, "en")
    ... ]
    >>> filter_by_language(values_list, ("de", "en"))
    [9, 4, 3, 2, 6]

    >>> filter_by_language(values_list, ("en", "de"))
    [9, 4, 3, 1, 7]

    >>> filter_by_language(values_list, ("xx", "en"))
    [10, 4, 3, 1, 7]

    >>> filter_by_language(values_list, ("es", "en", "de"))
    [9, 4, 8, 5, 7]

    >>> filter_by_language(values_list, ("de", "es", "en"))
    [9, 4, 8, 2, 6]
    """
    # Group language & content by entry
    entry_dict = {}
    for content_id, entry_id, language_id in values_list:
        if entry_id not in entry_dict:
            entry_dict[entry_id] = [(language_id, content_id)]
        else:
            entry_dict[entry_id].append((language_id, content_id))


    # Create a list of content id's which the best language match
    used_ids = []
    for existing_entries in entry_dict.values():
        temp_content_dict = dict(existing_entries)
        for prefered in prefered_languages_pk:
            if prefered in temp_content_dict:
                used_ids.append(temp_content_dict[prefered])
                break

    return used_ids


if __name__ == "__main__":
    import doctest
    print doctest.testmod()
    print "DocTest end."

########NEW FILE########
__FILENAME__ = python_tools
# -*- coding: utf-8 -*-

"""
    PyLucid utils
    ~~~~~~~~~~~~~

    Some tiny funtions:
        - without any imports from django or PyLucid

    Last commit info:
    ~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2007-2008 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v2 or above, see LICENSE for more details
"""

import re
import os
import shlex
from xml.sax.saxutils import escape as sax_escape

from django.utils.safestring import mark_safe


ENTITIES = {
    "{{" : "&#x7B;&#x7B;",
    "}}" : "&#x7D;&#x7D;",
    "{%" : "&#x7B;%",
    "%}" : "%&#x7D;",
}

def escape(txt):
    """
    Escape "&", "<", ">" and django template tags chars like "{" and "}"
    defined in ENTITIES to the HTML character entity.
    >>> escape("<test1> & {{ test2 }} {% test3 %}")
    '&lt;test1&gt; &amp; &#x7B;&#x7B; test2 &#x7D;&#x7D; &#x7B;% test3 %&#x7D;'
    """
    txt = sax_escape(txt, entities=ENTITIES)
    return mark_safe(txt)

def escape_django_tags(txt):
    """
    Escape only django template tags chars like "{" and "}" defined in ENTITIES
    to the HTML character entity.

    >>> escape_django_tags("<test1> &")
    '<test1> &'

    >>> escape_django_tags("{{ test2 }} {% test3 %}")
    '&#x7B;&#x7B; test2 &#x7D;&#x7D; &#x7B;% test3 %&#x7D;'
    """
    for source, dest in ENTITIES.iteritems():
        txt = txt.replace(source, dest)
    return txt


# For make_kwargs()
KEYWORD_MAP = {
    "True": True,
    "False": False,
    "None": None,
}

def make_kwargs(raw_content, encoding="UTF-8"):
    """
    convert a string into a dictionary. e.g.:

    >>> make_kwargs('key1="value1" key2="value2"')
    {'key2': 'value2', 'key1': 'value1'}

    >>> make_kwargs('A="B" C=1 D=1.1 E=True F=False G=None')
    {'A': 'B', 'C': 1, 'E': True, 'D': '1.1', 'G': None, 'F': False}
    
    >>> make_kwargs('''key1="'1'" key2='"2"' key3="""'3'""" ''')
    {'key3': 3, 'key2': 2, 'key1': 1}

    >>> make_kwargs(u'unicode=True')
    {'unicode': True}
    """
    if isinstance(raw_content, unicode):
        # shlex.split doesn't work with unicode?!?
        raw_content = raw_content.encode(encoding)

    parts = shlex.split(raw_content)

    result = {}
    for part in parts:
        key, value = part.split("=", 1)

        if value in KEYWORD_MAP:
            # True False or None
            value = KEYWORD_MAP[value]
        else:
            # A number?
            try:
                value = int(value.strip("'\""))
            except ValueError:
                pass

        result[key] = value

    return result




def contains_char(text, chars):
    """
    returns True if text contains a characters from the given chars list.
    
    >>> contains_char("1234", ["a", "b"])
    False
    >>> contains_char("1234", ["2", "b"])
    True
    >>> contains_char("1234", "wrong")
    Traceback (most recent call last):
    ...
    AssertionError
    """
    assert isinstance(chars, (list, tuple))
    for char in chars:
        if char in text:
            return True
    return False




def cutout(content, terms, max_lines=5, cutout_len=10):
    """
    Cut out all lines witch contains one of the terms.
    
    The >cutout_len< argument sets the size of the text around the match:
    
    >>> cutout("12 3 4567 8 90", ["3", "4", "6", "8"], cutout_len=2)
    [('12', '3', '45'), ('67', '8', '90')]
    >>> cutout("1 23456789 0", ["1", "0"], cutout_len=3)
    [('', '1', '234'), ('789', '0', '')]
    
    
    The >max_lines< argument is the maximum cutouts for all terms:
    
    >>> cutout("1 x 23 y 45 x 67 y 8", ["x", "y"], max_lines=1, cutout_len=1)
    [('1', 'x', '2')]
    >>> cutout("1 x 23 y 45 x 67 y 8", ["x", "y"], max_lines=2, cutout_len=1)
    [('1', 'x', '2'), ('3', 'y', '4')]
    >>> cutout("1 x 23 y 45 x 67 y 8", ["x", "y"], max_lines=3, cutout_len=1)
    [('1', 'x', '2'), ('3', 'y', '4'), ('5', 'x', '6')]
    """
    re_terms = [re.escape(term) for term in terms]
    regex = re.compile(
        r"(.{0,%(cutout_len)i})\W(%(terms)s)\W(.{0,%(cutout_len)i})" % {
            "cutout_len": cutout_len,
            "terms": "|".join(re_terms)
        },
        re.DOTALL | re.IGNORECASE
    )

    result = []
    max_lines -= 1 # enumerate starts with 0 (the start argument is new in Python 2.6)
    for no, m in enumerate(regex.finditer(" " + content + " ")):#, start=1):
        result.append(m.groups())
        if no >= max_lines:
            break

    return result



def has_init_file(path):
    """ return True/False if path contains a __init__.py file """
    init_filepath = os.path.join(path, "__init__.py")
    return os.path.isfile(init_filepath)



if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = safe_obtain
# coding: utf-8

from django.conf import settings
from django.utils.translation import ugettext as _

def safe_get_integer(request, get_key, default, min, max):
    """
    safe way to get a integer from a request.GET parameter.
    use default, if GET parameter doesn't exist or is not a integer.
    Limit the number to min and max. 
    """
    error = None
    number = request.GET.get(get_key, default)
    try:
        number = int(number)
    except ValueError:
        error = _("%r is not a integer. (Use default number)") % get_key
        number = default

    if number < min:
        error = _("%(get_key)r is too small. (Use: %(min)s)") % {
            "get_key": get_key, "min": min
        }
        return min, error
    if number > max:
        error = _("%(get_key)r is too large. (Use: %(max)s)") % {
            "get_key": get_key, "max": max
        }
        return max, error

    return number, error


def safe_pref_get_integer(request, get_key, Preferences,
              default_key, default_fallback,
              min_key, min_fallback,
              max_key, max_fallback):
    """
    returns a integer from request.GET[get_key] in a safe way.
    
    Use information from a DBPreferences class for limiting with min/max.
    If GET Parameter doesn't exist or is not a integer, use default number.

    default_key, min_key and max_key:
        names of the DBPreferences Attributes
        
    default_fallback, min_fallback and max_fallback:
        fallback, if preferences doesn't exist, yet.
    """
    pref_form = Preferences()
    preferences = pref_form.get_preferences()

    default = preferences.get(default_key, default_fallback)
    min = preferences.get(min_key, min_fallback)
    max = preferences.get(max_key, max_fallback)

    number, error = safe_get_integer(request, get_key, default, min, max)
    return number, error

########NEW FILE########
__FILENAME__ = SimpleStringIO
# -*- coding: utf-8 -*-

"""
    SimpleStringIO
    ~~~~~~~~~~~~~~

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2007-2008 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

if __name__ == "__main__":
    # For doctest only
    import os
    os.environ["DJANGO_SETTINGS_MODULE"] = "django.conf.global_settings"

from django.conf import settings


class SimpleStringIO(object):
    """
    Minimalistic StringIO-file-like object.
    Encode unicode to the default charset (imported from the settings).
    See http://docs.python.org/lib/bltin-file-objects.html
    
    >>> s = SimpleStringIO()
    >>> s.write("one\\n")
    >>> s(u"two")
    >>> s.getvalue()
    'one\\ntwo'
    >>> s.getlines()
    ['one\n', 'two']
    """
    def __init__(self):
        self._charset = settings.DEFAULT_CHARSET
        self._container = []

    def write(self, content):
        """
        Append a new chunk.
        Encode unicode to the default charset.
        """
        if isinstance(content, unicode):
            content = content.encode(self._charset)
        self._container.append(content)

    def __call__(self, content):
        self.write(content)

    def getlines(self):
        """
        returns the container list
        """
        return self._container

    def getvalue(self):
        """
        Get all content.
        """
        content = ''.join(self._container)
        return content

    def isatty(self):
        """
        Used for the _install section: Redirected the syncdb command.
        It checks sys.stdout.isatty() in django.core.management.color
        """
        return False


if __name__ == "__main__":
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."
########NEW FILE########
__FILENAME__ = site_utils
# coding: utf-8

"""
    Simple helper for site preselection
    
    used in pylucid plugins e.g.: lexicon, blog
"""

from django import forms
from django.contrib.sites.models import Site
from django.utils.translation import ugettext as _


def get_site_preselection(pref_form, request):
    """
    Get the form init value for a M2M to site for preselecting it.
    """
    pref_data = pref_form.get_preferences()
    preselect = pref_data["site_preselection"]

    if preselect == pref_form.PRESELECT_ALL:
        # Preselect all accessible sites
        user_profile = request.user.get_profile()
        # All accessible sites from the current user:
        return user_profile.sites.values_list('id', flat=True)
    elif preselect == pref_form.PRESELECT_CURRENT:
        # Preselect the current site only
        return [Site.objects.get_current().pk]

    # Do not preselect the site
    return []


class SitePreselectPreference(forms.Form):
    """
    Usage in a DBPreferencesBaseForm 
    """
    PRESELECT_NONE = "N"
    PRESELECT_CURRENT = "C"
    PRESELECT_ALL = "A"

    PRESELECT_CHOICES = (
        (PRESELECT_NONE, _("No site")),
        (PRESELECT_CURRENT, _("current site")),
        (PRESELECT_ALL, _("all accessable sites")),
    )
    PRESELECT_DICT = dict(PRESELECT_CHOICES)

    site_preselection = forms.ChoiceField(choices=PRESELECT_CHOICES,
        help_text=_("Witch site(s) sould be preselected if you create a new entry?"),
        initial=PRESELECT_ALL,
    )

########NEW FILE########
__FILENAME__ = slug
# -*- coding: utf-8 -*-

"""
    Slug
    ~~~~
    
    A slug is a short label for something, containing only letters, numbers, underscores or hyphens.
    Theyre generally used in URLs. See also: http://docs.djangoproject.com/en/dev/glossary/

    Some usefull routines around unique slug.

    Last commit info:
    ~~~~~~~~~~~~~~~~~
    $LastChangedDate$
    $Rev$
    $Author$

    :copyleft: 2007-2009 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import string

ALLOW_CHARS = string.ascii_letters + string.digits + "_"
SEPERATOR = "-"

def verify_slug(slug):
    """
    Check a slug. Raise AssertionError if something seems to be wrong.
    But normaly the urls-re should only filter the bad thing from urls ;)
    
    >>> verify_slug("ThisIs-A-Slug_123")
    
    >>> verify_slug("")
    Traceback (most recent call last):
    ...
    AssertionError: Slug is empty!
    
    >>> verify_slug("Wrong!")
    Traceback (most recent call last):
    ...
    AssertionError: Not allowed character in slug: '!'
    """
    if slug=="":
        raise AssertionError("Slug is empty!")

    for char in slug:
        if not char in ALLOW_CHARS+SEPERATOR:
            raise AssertionError(
                "Not allowed character in slug: %r" % char
            )


def makeUniqueSlug(item_name, existing_slugs=[]):
    """
    returns a URL safe, unique slug.
    - delete all non-ALLOW_CHARS characters.
    - if the shotcut already exists in existing_slugs -> add a sequential number
    Note:
    Not only used for making page slugs unique with getUniqueSlug(),
    also used in:
        -PyLucid.defaulttags.lucidTag.lucidTagNode._add_unique_div()
        -PyLucid.middlewares.headline_anchor.HeadlineAnchor()
    
    >>> makeUniqueSlug("Please make *me* slug!")
    'Please-make-me-slug'
    >>> makeUniqueSlug("And me - too! -, please.")
    'And-me-too-please'
    
    >>> existing_slugs = ["Exist", "ExistToo", "ExistToo1"]
    >>> makeUniqueSlug("NewItem", existing_slugs)
    'NewItem'
    >>> makeUniqueSlug("Exist", existing_slugs)
    'Exist1'
    >>> makeUniqueSlug("ExistToo", existing_slugs)
    'ExistToo2'
    
    to make a slug unique we ignore case!
    >>> makeUniqueSlug("SLUG", existing_slugs=['slug',"Slug1"])
    'SLUG2'
    
    If item is empty, we get '1' back:
    >>> makeUniqueSlug("", [])
    '1'
    """
    # delete all non-ALLOW_CHARS characters and separate in parts
    parts = [""]
    for char in item_name:
        if not char in ALLOW_CHARS:
            if parts[-1] not in ("", SEPERATOR):
                # No double "-" e.g.: "foo - bar" -> "foo-bar" not "foo---bar"
                parts.append("")
        else:
            parts[-1] += char

    item_name = SEPERATOR.join(parts)
    item_name = item_name.strip(SEPERATOR)

    if item_name == "":
        # No slug? That won't work.
        item_name = "1"
        
    if existing_slugs==[]:
        return item_name

    existing_slugs2 = [i.lower() for i in existing_slugs]

    # make double slug unique (add a new free sequential number)
    if item_name.lower() in existing_slugs2:
        for i in xrange(1, 1000):
            testname = "%s%i" % (item_name, i)
            if testname.lower() not in existing_slugs2:
                item_name = testname
                break

    return item_name


#def getUniqueSlug(slug, exclude_slug=None):
#    from PyLucid.models import Page
#
##    print "source slug:", slug
#    slugs = Page.objects.values("slug")
##    print "exclude slug: '%s'" % exclude_slug
#    if exclude_slug != None:
#        slugs = slugs.exclude(slug=exclude_slug)
#    existing_slugs = [i["slug"] for i in slugs]
##    print "existing_slugs:", existing_slugs
#    return makeUniqueSlug(slug, existing_slugs)



if __name__ == "__main__":
    #
    # There exist a unitest for the page slugs:
    #     ./unittests/unittest_UniqueSlugs
    #
    import doctest
    doctest.testmod(
#        verbose=True
        verbose=False
    )
    print "DocTest end."

########NEW FILE########
__FILENAME__ = timezone
# coding:utf-8

"""
    small utils around timezone
"""

from datetime import datetime, timedelta


def utc_offset():
    """
    returns the offset between datetime.now() and datetime.utcnow() as a datetime.timedelta
    from contrib/syndication/feeds.py
    """
    now = datetime.now()
    utcnow = datetime.utcnow()

    # Must always subtract smaller time from larger time here.
    if utcnow > now:
        sign = -1
        tzDifference = (utcnow - now)
    else:
        sign = 1
        tzDifference = (now - utcnow)

    # Round the timezone offset to the nearest half hour.
    tzOffsetMinutes = sign * ((tzDifference.seconds / 60 + 15) / 30) * 30
    tzOffset = timedelta(minutes=tzOffsetMinutes)
    return tzOffset

########NEW FILE########
__FILENAME__ = local_settings_example
# coding:utf-8

import os, tempfile

#
# Here a example local_settings.py
#
# At least you must specify STATIC_ROOT and DATABASES.
#
# see also:
# http://www.pylucid.org/permalink/332/a-complete-local_settingspy-example
#
BASE_PATH = os.path.abspath(os.path.dirname(__file__))


# Absolute _local_filesystem_path_ to the directory that holds media.
#
# STATIC_ROOT is for images, CSS, Javascript files that 
#             are needed to render a complete web page
# https://docs.djangoproject.com/en/1.4/ref/settings/#static-root
#
# MEDIA_ROOT is for user-uploaded media files (e.g. images)
# https://docs.djangoproject.com/en/1.4/ref/settings/#media-root
#
STATIC_ROOT = "/var/www/YourSite/static/"
MEDIA_ROOT = "/var/www/YourSite/media/"


# URL that handles the media served from STATIC_ROOT / MEDIA_ROOT
#     Example-1: "/static/" - "/media/" (default)
#     Example-2: "http://other_domain.net/static/"
#     Example-3: "http://static.your_domain.net/"
#
# Note: the URL mist have a trailing slash.
#
STATIC_URL = "/static/"
MEDIA_URL = "/media/"


# Changeable if needed (But should be off in productive usage!):
DEBUG = False
SQL_DEBUG = False
TEMPLATE_DEBUG = False

# Enable debug for one/some IP(s):
# https://docs.djangoproject.com/en/1.4/ref/settings/#internal-ips
INTERNAL_IPS = (
    # "123.456.789.012",
)

# Database connection info.
# http://docs.djangoproject.com/en/dev/intro/tutorial01/#database-setup
# http://docs.djangoproject.com/en/dev/ref/settings/#setting-DATABASES
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_PATH, "test.db3") # You should use a absolute path to the SQlite file!
    }
}


SITE_ID = 1
LANGUAGE_CODE = "en"

# A secret key for this particular Django installation.
# Used to provide a seed in secret-key hashing algorithms.
# Set this to a random string -- the longer, the better.
SECRET_KEY = "add-a-secret-key"


# more info about CACHES setup here:
# http://www.pylucid.org/permalink/332/a-complete-local_settingspy-example#CACHES
#
#CACHE_MIDDLEWARE_SECONDS = 3600 # 1h
#
#_BACKEND = "django_tools.cache.smooth_cache_backends.SmoothFileBasedCache"
#_LOCATION_PREFIX = "/var/tmp/PyLucid_"
#CACHES = {
#    'default': {
#        'BACKEND': _BACKEND,
#        'LOCATION': _LOCATION_PREFIX + 'default-cache',
#        'TIMEOUT': CACHE_MIDDLEWARE_SECONDS,
#    },
#    'dbtemplates': {
#        'BACKEND': _BACKEND,
#        'LOCATION': _LOCATION_PREFIX + 'dbtemplates-cache',
#        'TIMEOUT': CACHE_MIDDLEWARE_SECONDS,
#    },
#    'LOCAL_SYNC_CACHE_BACKEND': {
#        'BACKEND': _BACKEND,
#        'LOCATION': _LOCATION_PREFIX + 'local_sync-cache',
#        'TIMEOUT': CACHE_MIDDLEWARE_SECONDS,
#    },
#}


# Please change email-/SMTP-Settings:

# http://docs.djangoproject.com/en/dev/ref/settings/#email-backend
EMAIL_HOST = "localhost"
EMAIL_HOST_USER = "root@%s" % EMAIL_HOST
EMAIL_HOST_PASSWORD = ""

# http://docs.djangoproject.com/en/dev/ref/settings/#default-from-email
DEFAULT_FROM_EMAIL = EMAIL_HOST_USER

# http://docs.djangoproject.com/en/dev/ref/settings/#server-email
SERVER_EMAIL = DEFAULT_FROM_EMAIL

# Please uncomment and insert your mail and email address:
#MANAGERS = (('John', 'john@example.com'), ('Mary', 'mary@example.com'))
#ADMINS = MANAGERS


########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid - manage.py
    ~~~~~~~~~~~~~~~~~~~


    Please change ROOT_DIR path to your needs!


    http://docs.djangoproject.com/en/dev/ref/django-admin/

    borrowed from the pinax project.
"""

import os
import sys


##############################################################################
# Change this path:
ROOT_DIR = "/please/insert/path/to/PyLucid_env/"
##############################################################################


os.environ['DJANGO_SETTINGS_MODULE'] = "pylucid_project.settings"

sys.path.insert(0, os.path.join(ROOT_DIR, "src/pylucid/pylucid_project"))

sys.stderr = sys.stdout

print "virtualenv activate...",
virtualenv_file = os.path.join(ROOT_DIR, "bin/activate_this.py")
try:
    execfile(virtualenv_file, dict(__file__=virtualenv_file))
except Exception, err:
    print "Error: Can't activate the virtualenv!"
    print
    print "Failed to execute file %r" % virtualenv_file
    print
    print "-" * 79
    import traceback
    traceback.print_exc()
    print "-" * 79
    print
    print "ROOT_DIR = %r" % ROOT_DIR
    print "Please check ROOT_DIR in this file (%s)" % __file__
    print
    sys.exit(1)

print "OK"






def _error(msg):
    print "Import Error:", msg
    print "-" * 79
    import traceback
    traceback.print_exc()
    print "-" * 79
    print "Did you activate the virtualenv?"
    sys.exit(1)

try:
    from django.core.management import setup_environ, execute_from_command_line
except ImportError, msg:
    _error(msg)


try:
    import pylucid_project
except ImportError, msg:
    _error(msg)


try:
    import settings as settings_mod
except ImportError:
    _error("Error: Can't import settings.py\n")


# setup the environment before we start accessing things in the settings.
setup_environ(settings_mod)

if __name__ == "__main__":
    execute_from_command_line()

########NEW FILE########
__FILENAME__ = manage
#!/usr/bin/env python
# coding: utf-8

"""
    PyLucid - manage.py
    ~~~~~~~~~~~~~~~~~~~
    
    http://docs.djangoproject.com/en/dev/ref/django-admin/
"""

from django.core.management import setup_environ, execute_from_command_line

import pylucid_project # only a test, if exist
from pylucid_project import settings as settings_mod

# setup the environment before we start accessing things in the settings.
setup_environ(settings_mod)

if __name__ == "__main__":
    execute_from_command_line()


########NEW FILE########
__FILENAME__ = upgrade_pylucid_env
#!/usr/bin/env python
# coding: utf-8

"""
    upgrade PyLucid environment
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    upgrade a existing PyLucid virtual environment via pip.
    Display a menu based on requirements from ./pylucid/requirements/*.txt
    
    Would be started from:
     * upgrade_pylucid_dev_env.sh  with: --env_type=developer
     * upgrade_pylucid_env.sh      with: --env_type=normal
    
    See also:
    http://www.pylucid.org/permalink/71/update-a-old-pylucid-installation#by-cli-script
    
    
    You can also list installed packages with version information from PyPi, e.g.:
        ./src/pylucid/scripts/upgrade_pylucid_env.py --version-info
    
      
    :copyleft: 2011-2012 by the PyLucid team, see AUTHORS for more details.
    :license: GNU GPL v3 or above, see LICENSE for more details.
"""

import os
import sys
import subprocess
from optparse import OptionParser


if __name__ == "__main__":
    # precheck if we in a activated virtualenv
    # if not, the pip import can raise a ImportError, if pip not installed
    # in the global python environment
    if not hasattr(sys, 'real_prefix'):
        print("")
        print("Error: It seems that we are not running in a activated virtualenv!")
        print("")
        print("Please activate your environment first, e.g:")
        print("\t...my_env$ source bin/activate")
        print("")
        sys.exit(-1)


import pkg_resources

from pip import locations
from pip.backwardcompat import xmlrpclib
from pip.commands.search import highest_version
from pip.util import get_terminal_size, get_installed_distributions
import pip

try:
    import pylucid_project
except ImportError, err:
    print "Import error:", err
    print
    print "Not running in activated virtualenv?"
    print
    sys.exit(-1)

PYLUCID_BASE_PATH = os.path.abspath(os.path.dirname(pylucid_project.__file__))

def get_req_path(filename):
    filepath = os.path.join(PYLUCID_BASE_PATH, "../requirements", filename)
    if not os.path.exists(filepath):
        print "ERROR: file %r doesn't exists!" % filepath
        sys.exit(-1)
    return filepath


INSTALL_NORMAL = "normal"
INSTALL_DEV = "developer"
CHOICES = {
    INSTALL_NORMAL:"normal_installation.txt",
    INSTALL_DEV:"developer_installation.txt",
}
NO_DEPENDENCIES = ("pylucid", "django-processinfo", "django-reversion-compare")

# http://wiki.python.org/moin/PyPiXmlRpc
INDEX_URL = "http://pypi.python.org/pypi"


class ColorOut(object):
    """
    Borrowed from Django:
    http://code.djangoproject.com/browser/django/trunk/django/utils/termcolors.py
    
    >>> c = ColorOut()
    >>> c.supports_colors()
    True
    >>> c.color_support = True
    >>> c.colorize('no color')
    'no color'
    >>> c.colorize('bold', opts=("bold",))
    '\\x1b[1mbold\\x1b[0m'
    >>> c.colorize("colors!", foreground="red", background="blue", opts=("bold", "blink"))
    '\\x1b[31;44;1;5mcolors!\\x1b[0m'
    """
    color_names = ('black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white')
    foreground_colors = dict([(color_names[x], '3%s' % x) for x in range(8)])
    background_colors = dict([(color_names[x], '4%s' % x) for x in range(8)])
    opt_dict = {'bold': '1', 'underscore': '4', 'blink': '5', 'reverse': '7', 'conceal': '8'}

    def __init__(self):
        self.color_support = self.supports_colors()

    def supports_colors(self):
        if sys.platform in ('win32', 'Pocket PC'):
            return False

        # isatty is not always implemented!
        if hasattr(sys.stdout, 'isatty') and sys.stdout.isatty():
            return True
        else:
            return False

    def colorize(self, text, foreground=None, background=None, opts=()):
        """
        Returns your text, enclosed in ANSI graphics codes.
        """
        if not self.color_support:
            return text

        code_list = []

        if foreground:
            code_list.append(self.foreground_colors[foreground])
        if background:
            code_list.append(self.background_colors[background])

        for option in opts:
            code_list.append(self.opt_dict[option])

        if not code_list:
            return text

        return "\x1b[%sm%s\x1b[0m" % (';'.join(code_list), text)
c = ColorOut()


def check_activation():
    print("")
    print("sys.real_prefix: %s" % c.colorize(sys.real_prefix, foreground="magenta"))
    print("sys.prefix: %s" % c.colorize(sys.prefix, foreground="green", opts=("bold",)))
    print("use pip from: %s" % c.colorize(os.path.dirname(pip.__file__), foreground="blue", opts=("bold",)))
    print("")


def check_pip_version():
    try:
        pkg_resources.require("pip >= 1.0.1")
    except pkg_resources.VersionConflict, err:
        print(c.colorize("Error: outdated pip version!", foreground="red"))
        print("Original error: %s" % err)
        print("")
        print("You should upgrade pip, e.g.:")
        print("\tpip install --upgrade pip")
        print("")


def print_options(options):
    output = []
    if options.dryrun:
        output.append("dry-run is on")
    if options.verbose:
        output.append("pip verbose mode is on")
    output.append("log saved in '%s'" % options.logfile)

    print(c.colorize("used options:", opts=("underscore",)))
    for line in output:
        print(c.colorize("\t* %s" % line, foreground="magenta"))


def parse_requirements(filename):
    filepath = get_req_path(filename)
    f = file(filepath, "r")
    entries = []
    for line in f:
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if line.startswith("-r"):
            recursive_filename = line.split("-r ")[1]
            entries += parse_requirements(recursive_filename)
            continue
        if line.startswith("-e"):
            url = line.split("-e ")[1]
            entries.append("--editable=%s" % url)
        else:
            entries.append(line)
    f.close()
    return entries


def call_pip(options, pip_args):
    """ call pip with 'pip_args' """
    pip_executeable = os.path.join(locations.bin_py, "pip")
    
    cmd = [pip_executeable]
    cmd += pip_args
    
    print("_" * get_terminal_size()[0])
    print(c.colorize(" ".join(cmd), foreground="blue"))
    if not options.dryrun:
        subprocess.call(cmd)


def call_pip_install(options, no_dependencies, *args):
    """ install a package with pip """
    pip_args = [
        "install",
        "--download-cache=%s" % options.download_cache, "--upgrade"
    ]
    if no_dependencies:
        pip_args.append("--no-dependencies")

    if options.verbose:
        pip_args.append("--verbose")

    if options.logfile:
        pip_args.append("--log=%s" % options.logfile)

    pip_args += args
    call_pip(options, pip_args)


def select_requirement(options, filename):
    requirements = parse_requirements(filename)

    print "\nWhich package should be upgraded?\n"
    print c.colorize("Important:", foreground="red"), "Check if there are backward incompatible changes:"
    print "http://www.pylucid.org/en/blog/tags/backward%20incompatible/"
    print
    for no, requirement in enumerate(requirements): # XXX: enumerate(requirements,1) since Python 2.6!
        print "(%i) %s" % (no+1, requirement)

    print "(a) upgrade all packages"

    try:
        input = raw_input("\nPlease select (one entry or comma seperated):")
    except KeyboardInterrupt:
        print(c.colorize("Abort, ok.", foreground="blue"))
        sys.exit()

    selection = [i.strip() for i in input.split(",") if i.strip()]
    if len(selection) == 0:
        print(c.colorize("Abort, ok.", foreground="blue"))
        sys.exit()

    print "Your selection:", repr(selection)

    if "a" in selection:
        print "Upgrade all packages."
        return requirements

    req_dict = dict([(str(no+1), r) for no, r in enumerate(requirements)]) # XXX: enumerate(requirements,1) since Python 2.6!
    selected_req = []
    for item in selection:
        print "%s\t" % item,
        try:
            req = req_dict[item]
        except KeyError:
            print "(Invalid, skip.)"
        else:
            print req
            selected_req.append(req)

    return selected_req


def do_upgrade(options, requirements):

    pylucid_index = None
    for no, requirement in enumerate(requirements):
        if "pylucid" in requirement:
            pylucid_index = no
            break

    if pylucid_index is not None:
        # move pylucid to the beginning of the list
        pylucid = requirements.pop(no)
        requirements.insert(0, pylucid)

#    print "\n".join(requirements)
#    return

    def set_dependencies(requirement):
        for name in NO_DEPENDENCIES:
            if name in requirement:
                return True
        return False

    for requirement in requirements:
        no_dependencies = set_dependencies(requirement)
        call_pip_install(options, no_dependencies, requirement)


def do_version_info(options):
    """
    List all installed packages with his versions and version info from PyPi
    """
    local_only = True # exclude globally-installed packages in a virtualenv
    dependency_links = []
    for dist in pkg_resources.working_set:
        if dist.has_metadata('dependency_links.txt'):
            dependency_links.extend(
                dist.get_metadata_lines('dependency_links.txt'),
            )
    
    installed_info = []
    for dist in get_installed_distributions(local_only=local_only):
        req = dist.as_requirement() # pkg_resources.Requirement() instance
        project_name = req.project_name
        specs = req.specs
        version = specs[0][1]
        installed_info.append((project_name, version))
        
    max_name_len = max([len(i[0]) for i in installed_info])
    max_ver_len = max([len(i[1]) for i in installed_info])
    if max_name_len<20:
        max_name_len = 20
    if max_ver_len<20:
        max_ver_len = 20
    max_len_others = get_terminal_size()[0] - max_name_len - max_ver_len - 7    
    
    table_header = " package name".ljust(max_name_len)
    table_header += " installed version".ljust(max_ver_len)
    table_header += "  versions on PyPi".ljust(max_len_others)
    print c.colorize(table_header, opts=("underscore",))
    
    for project_name, version in installed_info:
        print project_name.ljust(max_name_len),
        print version.ljust(max_ver_len),
               
        # http://wiki.python.org/moin/PyPiXmlRpc
        client = xmlrpclib.ServerProxy(INDEX_URL)
        versions = client.package_releases(project_name)
        
        if not versions:
            print c.colorize("No version found at PyPi!", foreground="yellow")
        else:
            latest = highest_version(versions)
            older_versions = [v for v in versions if latest!=v]
            pypi_info = "%s" % latest
            if older_versions:
                pypi_info += " - %s" % ", ".join(older_versions)

            if len(pypi_info)>max_len_others:
                pypi_info = pypi_info[:max_len_others] + " ..."
            
            print pypi_info
        



def main():
    parser = OptionParser()
    parser.add_option("-t", "--env_type", type="string",
        dest="env_type", default=None,
        help="PyLucid env install type: %s" % ", ".join(CHOICES.keys())
    )
    parser.add_option("--dry-run",
                      action="store_true", dest="dryrun", default=False,
                      help="display only the pip commands and do nothing.")
    parser.add_option("--verbose",
                      action="store_true", dest="verbose", default=False,
                      help="Turn on pip verbose mode")
    parser.add_option("--log",
                      action="store", dest="logfile", default="upgrade_pylucid_env.log",
                      help="Log file where complete pip output will be kept")
    parser.add_option("--download-cache",
                      action="store", dest="download_cache",
                      default=os.path.join(sys.prefix, "pypi_cache"),
                      help="Cache downloaded packages in DIR")
    parser.add_option("--version-info",
                      action="store_true", dest="version_info", default=False,
                      help="Display version info of all packages.")

    options, args = parser.parse_args()
#    print options, args

    if options.version_info:
        do_version_info(options)
        sys.exit()

    if not options.env_type:
        print(c.colorize("\nError: No env type given!\n", foreground="red", opts=("bold",)))
        parser.print_help()
        sys.exit(-1)

    try:
        filename = CHOICES[options.env_type]
    except KeyError:
        print(c.colorize("\nError: Wrong env type!\n", foreground="red", opts=("bold",)))
        parser.print_help()
        sys.exit(-1)

    check_activation()
    check_pip_version()

    print_options(options)

    requirements = select_requirement(options, filename)
    if len(requirements) == 0:
        print "Nothing to upgrade, abort."
        sys.exit()

    try:
        input = raw_input("\nStart upgrade (y/n) ?")
    except KeyboardInterrupt:
        print(c.colorize("Abort, ok.", foreground="blue"))
        sys.exit()
    if input.lower() not in ("y", "j"):
        print(c.colorize("Abort, ok.", foreground="blue"))
        sys.exit()

    do_upgrade(options, requirements)

    print("-"*get_terminal_size()[0])

    print("")
    print(c.colorize("PyLucid virtual environment updated.", foreground="blue"))
    if options.dryrun:
        print("dry-run: nothing changes.")
    else:
        print("Look into %s for more information." % options.logfile)
    print("")


if __name__ == "__main__":
    main()



########NEW FILE########
