__FILENAME__ = bootstrap
##############################################################################
#
# Copyright (c) 2006 Zope Foundation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Bootstrap a buildout-based project

Simply run this script in a directory containing a buildout.cfg.
The script accepts buildout command-line options, so you can
use the -c option to specify an alternate configuration file.
"""

import os
import shutil
import sys
import tempfile

from optparse import OptionParser

tmpeggs = tempfile.mkdtemp()

usage = '''\
[DESIRED PYTHON FOR BUILDOUT] bootstrap.py [options]

Bootstraps a buildout-based project.

Simply run this script in a directory containing a buildout.cfg, using the
Python that you want bin/buildout to use.

Note that by using --find-links to point to local resources, you can keep 
this script from going over the network.
'''

parser = OptionParser(usage=usage)
parser.add_option("-v", "--version", help="use a specific zc.buildout version")

parser.add_option("-t", "--accept-buildout-test-releases",
                  dest='accept_buildout_test_releases',
                  action="store_true", default=False,
                  help=("Normally, if you do not specify a --version, the "
                        "bootstrap script and buildout gets the newest "
                        "*final* versions of zc.buildout and its recipes and "
                        "extensions for you.  If you use this flag, "
                        "bootstrap and buildout will get the newest releases "
                        "even if they are alphas or betas."))
parser.add_option("-c", "--config-file",
                  help=("Specify the path to the buildout configuration "
                        "file to be used."))
parser.add_option("-f", "--find-links",
                  help=("Specify a URL to search for buildout releases"))


options, args = parser.parse_args()

######################################################################
# load/install setuptools

to_reload = False
try:
    import pkg_resources
    import setuptools
except ImportError:
    ez = {}

    try:
        from urllib.request import urlopen
    except ImportError:
        from urllib2 import urlopen

    exec(urlopen('https://bootstrap.pypa.io/ez_setup.py').read(), ez)
    setup_args = dict(to_dir=tmpeggs, download_delay=0)
    ez['use_setuptools'](**setup_args)

    if to_reload:
        reload(pkg_resources)
    import pkg_resources
    # This does not (always?) update the default working set.  We will
    # do it.
    for path in sys.path:
        if path not in pkg_resources.working_set.entries:
            pkg_resources.working_set.add_entry(path)

######################################################################
# Install buildout

ws = pkg_resources.working_set

cmd = [sys.executable, '-c',
       'from setuptools.command.easy_install import main; main()',
       '-mZqNxd', tmpeggs]

find_links = os.environ.get(
    'bootstrap-testing-find-links',
    options.find_links or
    ('http://downloads.buildout.org/'
     if options.accept_buildout_test_releases else None)
    )
if find_links:
    cmd.extend(['-f', find_links])

setuptools_path = ws.find(
    pkg_resources.Requirement.parse('setuptools')).location

requirement = 'zc.buildout'
version = options.version
if version is None and not options.accept_buildout_test_releases:
    # Figure out the most recent final version of zc.buildout.
    import setuptools.package_index
    _final_parts = '*final-', '*final'

    def _final_version(parsed_version):
        for part in parsed_version:
            if (part[:1] == '*') and (part not in _final_parts):
                return False
        return True
    index = setuptools.package_index.PackageIndex(
        search_path=[setuptools_path])
    if find_links:
        index.add_find_links((find_links,))
    req = pkg_resources.Requirement.parse(requirement)
    if index.obtain(req) is not None:
        best = []
        bestv = None
        for dist in index[req.project_name]:
            distv = dist.parsed_version
            if _final_version(distv):
                if bestv is None or distv > bestv:
                    best = [dist]
                    bestv = distv
                elif distv == bestv:
                    best.append(dist)
        if best:
            best.sort()
            version = best[-1].version
if version:
    requirement = '=='.join((requirement, version))
cmd.append(requirement)

import subprocess
if subprocess.call(cmd, env=dict(os.environ, PYTHONPATH=setuptools_path)) != 0:
    raise Exception(
        "Failed to execute command:\n%s",
        repr(cmd)[1:-1])

######################################################################
# Import and run buildout

ws.add_entry(tmpeggs)
ws.require(requirement)
import zc.buildout.buildout

if not [a for a in args if '=' not in a]:
    args.append('bootstrap')

# if -c was provided, we push it back into args for buildout' main function
if options.config_file is not None:
    args[0:0] = ['-c', options.config_file]

zc.buildout.buildout.main(args)
shutil.rmtree(tmpeggs)

########NEW FILE########
__FILENAME__ = conf
# -*- coding: utf-8 -*-
#
# Adhocracy documentation build configuration file, created by
# sphinx-quickstart on Sat Apr 10 13:10:20 2010.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import os
import sys
import pkg_resources

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
#sys.path.append(os.path.abspath('.'))

# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinx.ext.autodoc', 'sphinx.ext.intersphinx', 'sphinx.ext.pngmath']

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Adhocracy'
copyright = u'2013, Liquid Democracy e.V.'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = pkg_resources.require("adhocracy")[0].version
# The full version, including alpha/beta/rc tags.
release = version

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#language = None

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = ['_build']

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
html_theme = 'default'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {}

# Add any paths that contain custom themes here, relative to this directory.
#html_theme_path = []

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
#html_title = None

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
#html_use_index = True

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Adhocracydoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Adhocracy.tex', u'Adhocracy Documentation',
   u'Liquid Democracy e.V.', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# Example configuration for intersphinx: refer to the Python standard library.
intersphinx_mapping = {'http://docs.python.org/': None}

########NEW FILE########
__FILENAME__ = bootstrap
##############################################################################
#
# Copyright (c) 2006 Zope Corporation and Contributors.
# All Rights Reserved.
#
# This software is subject to the provisions of the Zope Public License,
# Version 2.1 (ZPL).  A copy of the ZPL should accompany this distribution.
# THIS SOFTWARE IS PROVIDED "AS IS" AND ANY AND ALL EXPRESS OR IMPLIED
# WARRANTIES ARE DISCLAIMED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
# WARRANTIES OF TITLE, MERCHANTABILITY, AGAINST INFRINGEMENT, AND FITNESS
# FOR A PARTICULAR PURPOSE.
#
##############################################################################
"""Bootstrap a buildout-based project

Simply run this script in a directory containing a buildout.cfg.
The script accepts buildout command-line options, so you can
use the -c option to specify an alternate configuration file.

$Id$
"""

import os, shutil, sys, tempfile, urllib2
from optparse import OptionParser

tmpeggs = tempfile.mkdtemp()

is_jython = sys.platform.startswith('java')

# parsing arguments
parser = OptionParser(
    'This is a custom version of the zc.buildout %prog script.  It is '
    'intended to meet a temporary need if you encounter problems with '
    'the zc.buildout 1.5 release.')
parser.add_option("-v", "--version", dest="version", default='1.4.4',
                          help='Use a specific zc.buildout version.  *This '
                          'bootstrap script defaults to '
                          '1.4.4, unlike usual buildpout bootstrap scripts.*')
parser.add_option("-d", "--distribute",
                   action="store_true", dest="distribute", default=False,
                   help="Use Disribute rather than Setuptools.")

parser.add_option("-c", None, action="store", dest="config_file",
                   help=("Specify the path to the buildout configuration "
                         "file to be used."))

options, args = parser.parse_args()

# if -c was provided, we push it back into args for buildout' main function
if options.config_file is not None:
    args += ['-c', options.config_file]

if options.version is not None:
    VERSION = '==%s' % options.version
else:
    VERSION = ''

USE_DISTRIBUTE = options.distribute
args = args + ['bootstrap']

to_reload = False
try:
    import pkg_resources
    if not hasattr(pkg_resources, '_distribute'):
        to_reload = True
        raise ImportError
except ImportError:
    ez = {}
    if USE_DISTRIBUTE:
        exec urllib2.urlopen('http://python-distribute.org/distribute_setup.py'
                         ).read() in ez
        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0, no_fake=True)
    else:
        exec urllib2.urlopen('http://peak.telecommunity.com/dist/ez_setup.py'
                             ).read() in ez
        ez['use_setuptools'](to_dir=tmpeggs, download_delay=0)

    if to_reload:
        reload(pkg_resources)
    else:
        import pkg_resources

if sys.platform == 'win32':
    def quote(c):
        if ' ' in c:
            return '"%s"' % c # work around spawn lamosity on windows
        else:
            return c
else:
    def quote (c):
        return c

ws  = pkg_resources.working_set

if USE_DISTRIBUTE:
    requirement = 'distribute'
else:
    requirement = 'setuptools'

env = dict(os.environ,
           PYTHONPATH=
           ws.find(pkg_resources.Requirement.parse(requirement)).location
           )

cmd = [quote(sys.executable),
       '-c',
       quote('from setuptools.command.easy_install import main; main()'),
       '-mqNxd',
       quote(tmpeggs)]

if 'bootstrap-testing-find-links' in os.environ:
    cmd.extend(['-f', os.environ['bootstrap-testing-find-links']])

cmd.append('zc.buildout' + VERSION)

if is_jython:
    import subprocess
    exitcode = subprocess.Popen(cmd, env=env).wait()
else: # Windows prefers this, apparently; otherwise we would prefer subprocess
    exitcode = os.spawnle(*([os.P_WAIT, sys.executable] + cmd + [env]))
assert exitcode == 0

ws.add_entry(tmpeggs)
ws.require('zc.buildout' + VERSION)
import zc.buildout.buildout
zc.buildout.buildout.main(args)
shutil.rmtree(tmpeggs)

########NEW FILE########
__FILENAME__ = add_all_users_to_instances
#!/usr/bin/env python
"""Add all users into the instances given on the command line.
"""
import os
import sys
from argparse import ArgumentParser

from paste.deploy import appconfig
from adhocracy.config.environment import load_environment
from adhocracy import model


def load_config(filename):
    conf = appconfig('config:' + os.path.abspath(filename) + '#content')
    load_environment(conf.global_conf, conf.local_conf)


def parse_args():
    parser = ArgumentParser(description=__doc__)
    parser.add_argument("conf_file", help="configuration to use")
    parser.add_argument("instance_keys", metavar='instance', nargs='+',
                        help=("Instance key(s). If ALL is given, the "
                              "users will be added to all visible instances."))
    return parser.parse_args()


def main():
    args = parse_args()
    load_config(args.conf_file)
    session = model.meta.Session

    num_added = {}
    keys_added = {}

    def increment(dict_, key):
        num = dict_.get(key, 0)
        num += 1
        dict_[key] = num

    # filter the instances we have to add
    instance_keys = args.instance_keys
    instances = model.Instance.all()
    if not 'ALL' in instance_keys:
        instances = [instance for instance in instances if instance.key
                     in instance_keys]

    num_instances = len(instances)
    users = model.User.all()
    num_users = len(users)
    total_added = 0

    print "\n***Adding users***\n"
    for user in users:
        user_status = user.user_name + ': '
        added = 0
        for instance in set(instances) - set(user.instances):
            increment(keys_added, instance.key)
            user_status += instance.key + ' '
            added += 1
            total_added += 1
            membership = model.Membership(user, instance,
                                          instance.default_group)
            session.add(membership)
            if (total_added % 2) == 0:
                session.commit()
        if added:
            print "%s (%s)" % (user_status, added)
        increment(num_added, added)
    session.commit()

    print "\n***Statistics***"
    print "Instances:", num_instances
    print "Users:", num_users

    print "\n**Instances added per user**\n"
    added = 0
    for (key, count) in sorted(num_added.items()):
        added += key * count
        print "%s membership added for %s users" % (key, count)
    print ''
    print "Mean number of memberships added per user: %s" % (float(added) /
                                                             float(num_users))

    print "\n**Users added per group**\n"
    for key in sorted(keys_added.keys()):
        print "%s: %s" % (key, (float(keys_added[key]) / float(num_users)))


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = argparse
# Author: Steven J. Bethard <steven.bethard@gmail.com>.

"""Command-line parsing library

This module is an optparse-inspired command-line parsing library that:

    - handles both optional and positional arguments
    - produces highly informative usage messages
    - supports parsers that dispatch to sub-parsers

The following is a simple usage example that sums integers from the
command-line and writes the result to a file::

    parser = argparse.ArgumentParser(
        description='sum the integers at the command line')
    parser.add_argument(
        'integers', metavar='int', nargs='+', type=int,
        help='an integer to be summed')
    parser.add_argument(
        '--log', default=sys.stdout, type=argparse.FileType('w'),
        help='the file where the sum should be written')
    args = parser.parse_args()
    args.log.write('%s' % sum(args.integers))
    args.log.close()

The module contains the following public classes:

    - ArgumentParser -- The main entry point for command-line parsing. As the
        example above shows, the add_argument() method is used to populate
        the parser with actions for optional and positional arguments. Then
        the parse_args() method is invoked to convert the args at the
        command-line into an object with attributes.

    - ArgumentError -- The exception raised by ArgumentParser objects when
        there are errors with the parser's actions. Errors raised while
        parsing the command-line are caught by ArgumentParser and emitted
        as command-line messages.

    - FileType -- A factory for defining types of files to be created. As the
        example above shows, instances of FileType are typically passed as
        the type= argument of add_argument() calls.

    - Action -- The base class for parser actions. Typically actions are
        selected by passing strings like 'store_true' or 'append_const' to
        the action= argument of add_argument(). However, for greater
        customization of ArgumentParser actions, subclasses of Action may
        be defined and passed as the action= argument.

    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,
        ArgumentDefaultsHelpFormatter -- Formatter classes which
        may be passed as the formatter_class= argument to the
        ArgumentParser constructor. HelpFormatter is the default,
        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser
        not to change the formatting for help text, and
        ArgumentDefaultsHelpFormatter adds information about argument defaults
        to the help.

All other classes in this module are considered implementation details.
(Also note that HelpFormatter and RawDescriptionHelpFormatter are only
considered public as object names -- the API of the formatter objects is
still considered an implementation detail.)
"""

__version__ = '1.2.1'
__all__ = [
    'ArgumentParser',
    'ArgumentError',
    'ArgumentTypeError',
    'FileType',
    'HelpFormatter',
    'ArgumentDefaultsHelpFormatter',
    'RawDescriptionHelpFormatter',
    'RawTextHelpFormatter',
    'Namespace',
    'Action',
    'ONE_OR_MORE',
    'OPTIONAL',
    'PARSER',
    'REMAINDER',
    'SUPPRESS',
    'ZERO_OR_MORE',
]


import copy as _copy
import os as _os
import re as _re
import sys as _sys
import textwrap as _textwrap

from gettext import gettext as _

try:
    set
except NameError:
    # for python < 2.4 compatibility (sets module is there since 2.3):
    from sets import Set as set

try:
    basestring
except NameError:
    basestring = str

try:
    sorted
except NameError:
    # for python < 2.4 compatibility:
    def sorted(iterable, reverse=False):
        result = list(iterable)
        result.sort()
        if reverse:
            result.reverse()
        return result


def _callable(obj):
    return hasattr(obj, '__call__') or hasattr(obj, '__bases__')


SUPPRESS = '==SUPPRESS=='

OPTIONAL = '?'
ZERO_OR_MORE = '*'
ONE_OR_MORE = '+'
PARSER = 'A...'
REMAINDER = '...'
_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'

# =============================
# Utility functions and classes
# =============================

class _AttributeHolder(object):
    """Abstract base class that provides __repr__.

    The __repr__ method returns a string in the format::
        ClassName(attr=name, attr=name, ...)
    The attributes are determined either by a class-level attribute,
    '_kwarg_names', or by inspecting the instance __dict__.
    """

    def __repr__(self):
        type_name = type(self).__name__
        arg_strings = []
        for arg in self._get_args():
            arg_strings.append(repr(arg))
        for name, value in self._get_kwargs():
            arg_strings.append('%s=%r' % (name, value))
        return '%s(%s)' % (type_name, ', '.join(arg_strings))

    def _get_kwargs(self):
        return sorted(self.__dict__.items())

    def _get_args(self):
        return []


def _ensure_value(namespace, name, value):
    if getattr(namespace, name, None) is None:
        setattr(namespace, name, value)
    return getattr(namespace, name)


# ===============
# Formatting Help
# ===============

class HelpFormatter(object):
    """Formatter for generating usage messages and argument help strings.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def __init__(self,
                 prog,
                 indent_increment=2,
                 max_help_position=24,
                 width=None):

        # default setting for width
        if width is None:
            try:
                width = int(_os.environ['COLUMNS'])
            except (KeyError, ValueError):
                width = 80
            width -= 2

        self._prog = prog
        self._indent_increment = indent_increment
        self._max_help_position = max_help_position
        self._width = width

        self._current_indent = 0
        self._level = 0
        self._action_max_length = 0

        self._root_section = self._Section(self, None)
        self._current_section = self._root_section

        self._whitespace_matcher = _re.compile(r'\s+')
        self._long_break_matcher = _re.compile(r'\n\n\n+')

    # ===============================
    # Section and indentation methods
    # ===============================
    def _indent(self):
        self._current_indent += self._indent_increment
        self._level += 1

    def _dedent(self):
        self._current_indent -= self._indent_increment
        assert self._current_indent >= 0, 'Indent decreased below 0.'
        self._level -= 1

    class _Section(object):

        def __init__(self, formatter, parent, heading=None):
            self.formatter = formatter
            self.parent = parent
            self.heading = heading
            self.items = []

        def format_help(self):
            # format the indented section
            if self.parent is not None:
                self.formatter._indent()
            join = self.formatter._join_parts
            for func, args in self.items:
                func(*args)
            item_help = join([func(*args) for func, args in self.items])
            if self.parent is not None:
                self.formatter._dedent()

            # return nothing if the section was empty
            if not item_help:
                return ''

            # add the heading if the section was non-empty
            if self.heading is not SUPPRESS and self.heading is not None:
                current_indent = self.formatter._current_indent
                heading = '%*s%s:\n' % (current_indent, '', self.heading)
            else:
                heading = ''

            # join the section-initial newline, the heading and the help
            return join(['\n', heading, item_help, '\n'])

    def _add_item(self, func, args):
        self._current_section.items.append((func, args))

    # ========================
    # Message building methods
    # ========================
    def start_section(self, heading):
        self._indent()
        section = self._Section(self, self._current_section, heading)
        self._add_item(section.format_help, [])
        self._current_section = section

    def end_section(self):
        self._current_section = self._current_section.parent
        self._dedent()

    def add_text(self, text):
        if text is not SUPPRESS and text is not None:
            self._add_item(self._format_text, [text])

    def add_usage(self, usage, actions, groups, prefix=None):
        if usage is not SUPPRESS:
            args = usage, actions, groups, prefix
            self._add_item(self._format_usage, args)

    def add_argument(self, action):
        if action.help is not SUPPRESS:

            # find all invocations
            get_invocation = self._format_action_invocation
            invocations = [get_invocation(action)]
            for subaction in self._iter_indented_subactions(action):
                invocations.append(get_invocation(subaction))

            # update the maximum item length
            invocation_length = max([len(s) for s in invocations])
            action_length = invocation_length + self._current_indent
            self._action_max_length = max(self._action_max_length,
                                          action_length)

            # add the item to the list
            self._add_item(self._format_action, [action])

    def add_arguments(self, actions):
        for action in actions:
            self.add_argument(action)

    # =======================
    # Help-formatting methods
    # =======================
    def format_help(self):
        help = self._root_section.format_help()
        if help:
            help = self._long_break_matcher.sub('\n\n', help)
            help = help.strip('\n') + '\n'
        return help

    def _join_parts(self, part_strings):
        return ''.join([part
                        for part in part_strings
                        if part and part is not SUPPRESS])

    def _format_usage(self, usage, actions, groups, prefix):
        if prefix is None:
            prefix = _('usage: ')

        # if usage is specified, use that
        if usage is not None:
            usage = usage % dict(prog=self._prog)

        # if no optionals or positionals are available, usage is just prog
        elif usage is None and not actions:
            usage = '%(prog)s' % dict(prog=self._prog)

        # if optionals and positionals are available, calculate usage
        elif usage is None:
            prog = '%(prog)s' % dict(prog=self._prog)

            # split optionals from positionals
            optionals = []
            positionals = []
            for action in actions:
                if action.option_strings:
                    optionals.append(action)
                else:
                    positionals.append(action)

            # build full usage string
            format = self._format_actions_usage
            action_usage = format(optionals + positionals, groups)
            usage = ' '.join([s for s in [prog, action_usage] if s])

            # wrap the usage parts if it's too long
            text_width = self._width - self._current_indent
            if len(prefix) + len(usage) > text_width:

                # break usage into wrappable parts
                part_regexp = r'\(.*?\)+|\[.*?\]+|\S+'
                opt_usage = format(optionals, groups)
                pos_usage = format(positionals, groups)
                opt_parts = _re.findall(part_regexp, opt_usage)
                pos_parts = _re.findall(part_regexp, pos_usage)
                assert ' '.join(opt_parts) == opt_usage
                assert ' '.join(pos_parts) == pos_usage

                # helper for wrapping lines
                def get_lines(parts, indent, prefix=None):
                    lines = []
                    line = []
                    if prefix is not None:
                        line_len = len(prefix) - 1
                    else:
                        line_len = len(indent) - 1
                    for part in parts:
                        if line_len + 1 + len(part) > text_width:
                            lines.append(indent + ' '.join(line))
                            line = []
                            line_len = len(indent) - 1
                        line.append(part)
                        line_len += len(part) + 1
                    if line:
                        lines.append(indent + ' '.join(line))
                    if prefix is not None:
                        lines[0] = lines[0][len(indent):]
                    return lines

                # if prog is short, follow it with optionals or positionals
                if len(prefix) + len(prog) <= 0.75 * text_width:
                    indent = ' ' * (len(prefix) + len(prog) + 1)
                    if opt_parts:
                        lines = get_lines([prog] + opt_parts, indent, prefix)
                        lines.extend(get_lines(pos_parts, indent))
                    elif pos_parts:
                        lines = get_lines([prog] + pos_parts, indent, prefix)
                    else:
                        lines = [prog]

                # if prog is long, put it on its own line
                else:
                    indent = ' ' * len(prefix)
                    parts = opt_parts + pos_parts
                    lines = get_lines(parts, indent)
                    if len(lines) > 1:
                        lines = []
                        lines.extend(get_lines(opt_parts, indent))
                        lines.extend(get_lines(pos_parts, indent))
                    lines = [prog] + lines

                # join lines into usage
                usage = '\n'.join(lines)

        # prefix with 'usage:'
        return '%s%s\n\n' % (prefix, usage)

    def _format_actions_usage(self, actions, groups):
        # find group indices and identify actions in groups
        group_actions = set()
        inserts = {}
        for group in groups:
            try:
                start = actions.index(group._group_actions[0])
            except ValueError:
                continue
            else:
                end = start + len(group._group_actions)
                if actions[start:end] == group._group_actions:
                    for action in group._group_actions:
                        group_actions.add(action)
                    if not group.required:
                        if start in inserts:
                            inserts[start] += ' ['
                        else:
                            inserts[start] = '['
                        inserts[end] = ']'
                    else:
                        if start in inserts:
                            inserts[start] += ' ('
                        else:
                            inserts[start] = '('
                        inserts[end] = ')'
                    for i in range(start + 1, end):
                        inserts[i] = '|'

        # collect all actions format strings
        parts = []
        for i, action in enumerate(actions):

            # suppressed arguments are marked with None
            # remove | separators for suppressed arguments
            if action.help is SUPPRESS:
                parts.append(None)
                if inserts.get(i) == '|':
                    inserts.pop(i)
                elif inserts.get(i + 1) == '|':
                    inserts.pop(i + 1)

            # produce all arg strings
            elif not action.option_strings:
                part = self._format_args(action, action.dest)

                # if it's in a group, strip the outer []
                if action in group_actions:
                    if part[0] == '[' and part[-1] == ']':
                        part = part[1:-1]

                # add the action string to the list
                parts.append(part)

            # produce the first way to invoke the option in brackets
            else:
                option_string = action.option_strings[0]

                # if the Optional doesn't take a value, format is:
                #    -s or --long
                if action.nargs == 0:
                    part = '%s' % option_string

                # if the Optional takes a value, format is:
                #    -s ARGS or --long ARGS
                else:
                    default = action.dest.upper()
                    args_string = self._format_args(action, default)
                    part = '%s %s' % (option_string, args_string)

                # make it look optional if it's not required or in a group
                if not action.required and action not in group_actions:
                    part = '[%s]' % part

                # add the action string to the list
                parts.append(part)

        # insert things at the necessary indices
        for i in sorted(inserts, reverse=True):
            parts[i:i] = [inserts[i]]

        # join all the action items with spaces
        text = ' '.join([item for item in parts if item is not None])

        # clean up separators for mutually exclusive groups
        open = r'[\[(]'
        close = r'[\])]'
        text = _re.sub(r'(%s) ' % open, r'\1', text)
        text = _re.sub(r' (%s)' % close, r'\1', text)
        text = _re.sub(r'%s *%s' % (open, close), r'', text)
        text = _re.sub(r'\(([^|]*)\)', r'\1', text)
        text = text.strip()

        # return the text
        return text

    def _format_text(self, text):
        if '%(prog)' in text:
            text = text % dict(prog=self._prog)
        text_width = self._width - self._current_indent
        indent = ' ' * self._current_indent
        return self._fill_text(text, text_width, indent) + '\n\n'

    def _format_action(self, action):
        # determine the required width and the entry label
        help_position = min(self._action_max_length + 2,
                            self._max_help_position)
        help_width = self._width - help_position
        action_width = help_position - self._current_indent - 2
        action_header = self._format_action_invocation(action)

        # ho nelp; start on same line and add a final newline
        if not action.help:
            tup = self._current_indent, '', action_header
            action_header = '%*s%s\n' % tup

        # short action name; start on the same line and pad two spaces
        elif len(action_header) <= action_width:
            tup = self._current_indent, '', action_width, action_header
            action_header = '%*s%-*s  ' % tup
            indent_first = 0

        # long action name; start on the next line
        else:
            tup = self._current_indent, '', action_header
            action_header = '%*s%s\n' % tup
            indent_first = help_position

        # collect the pieces of the action help
        parts = [action_header]

        # if there was help for the action, add lines of help text
        if action.help:
            help_text = self._expand_help(action)
            help_lines = self._split_lines(help_text, help_width)
            parts.append('%*s%s\n' % (indent_first, '', help_lines[0]))
            for line in help_lines[1:]:
                parts.append('%*s%s\n' % (help_position, '', line))

        # or add a newline if the description doesn't end with one
        elif not action_header.endswith('\n'):
            parts.append('\n')

        # if there are any sub-actions, add their help as well
        for subaction in self._iter_indented_subactions(action):
            parts.append(self._format_action(subaction))

        # return a single string
        return self._join_parts(parts)

    def _format_action_invocation(self, action):
        if not action.option_strings:
            metavar, = self._metavar_formatter(action, action.dest)(1)
            return metavar

        else:
            parts = []

            # if the Optional doesn't take a value, format is:
            #    -s, --long
            if action.nargs == 0:
                parts.extend(action.option_strings)

            # if the Optional takes a value, format is:
            #    -s ARGS, --long ARGS
            else:
                default = action.dest.upper()
                args_string = self._format_args(action, default)
                for option_string in action.option_strings:
                    parts.append('%s %s' % (option_string, args_string))

            return ', '.join(parts)

    def _metavar_formatter(self, action, default_metavar):
        if action.metavar is not None:
            result = action.metavar
        elif action.choices is not None:
            choice_strs = [str(choice) for choice in action.choices]
            result = '{%s}' % ','.join(choice_strs)
        else:
            result = default_metavar

        def format(tuple_size):
            if isinstance(result, tuple):
                return result
            else:
                return (result, ) * tuple_size
        return format

    def _format_args(self, action, default_metavar):
        get_metavar = self._metavar_formatter(action, default_metavar)
        if action.nargs is None:
            result = '%s' % get_metavar(1)
        elif action.nargs == OPTIONAL:
            result = '[%s]' % get_metavar(1)
        elif action.nargs == ZERO_OR_MORE:
            result = '[%s [%s ...]]' % get_metavar(2)
        elif action.nargs == ONE_OR_MORE:
            result = '%s [%s ...]' % get_metavar(2)
        elif action.nargs == REMAINDER:
            result = '...'
        elif action.nargs == PARSER:
            result = '%s ...' % get_metavar(1)
        else:
            formats = ['%s' for _ in range(action.nargs)]
            result = ' '.join(formats) % get_metavar(action.nargs)
        return result

    def _expand_help(self, action):
        params = dict(vars(action), prog=self._prog)
        for name in list(params):
            if params[name] is SUPPRESS:
                del params[name]
        for name in list(params):
            if hasattr(params[name], '__name__'):
                params[name] = params[name].__name__
        if params.get('choices') is not None:
            choices_str = ', '.join([str(c) for c in params['choices']])
            params['choices'] = choices_str
        return self._get_help_string(action) % params

    def _iter_indented_subactions(self, action):
        try:
            get_subactions = action._get_subactions
        except AttributeError:
            pass
        else:
            self._indent()
            for subaction in get_subactions():
                yield subaction
            self._dedent()

    def _split_lines(self, text, width):
        text = self._whitespace_matcher.sub(' ', text).strip()
        return _textwrap.wrap(text, width)

    def _fill_text(self, text, width, indent):
        text = self._whitespace_matcher.sub(' ', text).strip()
        return _textwrap.fill(text, width, initial_indent=indent,
                                           subsequent_indent=indent)

    def _get_help_string(self, action):
        return action.help


class RawDescriptionHelpFormatter(HelpFormatter):
    """Help message formatter which retains any formatting in descriptions.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _fill_text(self, text, width, indent):
        return ''.join([indent + line for line in text.splitlines(True)])


class RawTextHelpFormatter(RawDescriptionHelpFormatter):
    """Help message formatter which retains formatting of all help text.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _split_lines(self, text, width):
        return text.splitlines()


class ArgumentDefaultsHelpFormatter(HelpFormatter):
    """Help message formatter which adds default values to argument help.

    Only the name of this class is considered a public API. All the methods
    provided by the class are considered an implementation detail.
    """

    def _get_help_string(self, action):
        help = action.help
        if '%(default)' not in action.help:
            if action.default is not SUPPRESS:
                defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]
                if action.option_strings or action.nargs in defaulting_nargs:
                    help += ' (default: %(default)s)'
        return help


# =====================
# Options and Arguments
# =====================

def _get_action_name(argument):
    if argument is None:
        return None
    elif argument.option_strings:
        return '/'.join(argument.option_strings)
    elif argument.metavar not in (None, SUPPRESS):
        return argument.metavar
    elif argument.dest not in (None, SUPPRESS):
        return argument.dest
    else:
        return None


class ArgumentError(Exception):
    """An error from creating or using an argument (optional or positional).

    The string value of this exception is the message, augmented with
    information about the argument that caused it.
    """

    def __init__(self, argument, message):
        self.argument_name = _get_action_name(argument)
        self.message = message

    def __str__(self):
        if self.argument_name is None:
            format = '%(message)s'
        else:
            format = 'argument %(argument_name)s: %(message)s'
        return format % dict(message=self.message,
                             argument_name=self.argument_name)


class ArgumentTypeError(Exception):
    """An error from trying to convert a command line string to a type."""
    pass


# ==============
# Action classes
# ==============

class Action(_AttributeHolder):
    """Information about how to convert command line strings to Python objects.

    Action objects are used by an ArgumentParser to represent the information
    needed to parse a single argument from one or more strings from the
    command line. The keyword arguments to the Action constructor are also
    all attributes of Action instances.

    Keyword Arguments:

        - option_strings -- A list of command-line option strings which
            should be associated with this action.

        - dest -- The name of the attribute to hold the created object(s)

        - nargs -- The number of command-line arguments that should be
            consumed. By default, one argument will be consumed and a single
            value will be produced.  Other values include:
                - N (an integer) consumes N arguments (and produces a list)
                - '?' consumes zero or one arguments
                - '*' consumes zero or more arguments (and produces a list)
                - '+' consumes one or more arguments (and produces a list)
            Note that the difference between the default and nargs=1 is that
            with the default, a single value will be produced, while with
            nargs=1, a list containing a single value will be produced.

        - const -- The value to be produced if the option is specified and the
            option uses an action that takes no values.

        - default -- The value to be produced if the option is not specified.

        - type -- The type which the command-line arguments should be converted
            to, should be one of 'string', 'int', 'float', 'complex' or a
            callable object that accepts a single string argument. If None,
            'string' is assumed.

        - choices -- A container of values that should be allowed. If not None,
            after a command-line argument has been converted to the appropriate
            type, an exception will be raised if it is not a member of this
            collection.

        - required -- True if the action must always be specified at the
            command line. This is only meaningful for optional command-line
            arguments.

        - help -- The help string describing the argument.

        - metavar -- The name to be used for the option's argument with the
            help string. If None, the 'dest' value will be used as the name.
    """

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        self.option_strings = option_strings
        self.dest = dest
        self.nargs = nargs
        self.const = const
        self.default = default
        self.type = type
        self.choices = choices
        self.required = required
        self.help = help
        self.metavar = metavar

    def _get_kwargs(self):
        names = [
            'option_strings',
            'dest',
            'nargs',
            'const',
            'default',
            'type',
            'choices',
            'help',
            'metavar',
        ]
        return [(name, getattr(self, name)) for name in names]

    def __call__(self, parser, namespace, values, option_string=None):
        raise NotImplementedError(_('.__call__() not defined'))


class _StoreAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        if nargs == 0:
            raise ValueError('nargs for store actions must be > 0; if you '
                             'have nothing to store, actions such as store '
                             'true or store const may be more appropriate')
        if const is not None and nargs != OPTIONAL:
            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
        super(_StoreAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=nargs,
            const=const,
            default=default,
            type=type,
            choices=choices,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, values)


class _StoreConstAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 const,
                 default=None,
                 required=False,
                 help=None,
                 metavar=None):
        super(_StoreConstAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            const=const,
            default=default,
            required=required,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        setattr(namespace, self.dest, self.const)


class _StoreTrueAction(_StoreConstAction):

    def __init__(self,
                 option_strings,
                 dest,
                 default=False,
                 required=False,
                 help=None):
        super(_StoreTrueAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            const=True,
            default=default,
            required=required,
            help=help)


class _StoreFalseAction(_StoreConstAction):

    def __init__(self,
                 option_strings,
                 dest,
                 default=True,
                 required=False,
                 help=None):
        super(_StoreFalseAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            const=False,
            default=default,
            required=required,
            help=help)


class _AppendAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 nargs=None,
                 const=None,
                 default=None,
                 type=None,
                 choices=None,
                 required=False,
                 help=None,
                 metavar=None):
        if nargs == 0:
            raise ValueError('nargs for append actions must be > 0; if arg '
                             'strings are not supplying the value to append, '
                             'the append const action may be more appropriate')
        if const is not None and nargs != OPTIONAL:
            raise ValueError('nargs must be %r to supply const' % OPTIONAL)
        super(_AppendAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=nargs,
            const=const,
            default=default,
            type=type,
            choices=choices,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        items = _copy.copy(_ensure_value(namespace, self.dest, []))
        items.append(values)
        setattr(namespace, self.dest, items)


class _AppendConstAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 const,
                 default=None,
                 required=False,
                 help=None,
                 metavar=None):
        super(_AppendConstAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            const=const,
            default=default,
            required=required,
            help=help,
            metavar=metavar)

    def __call__(self, parser, namespace, values, option_string=None):
        items = _copy.copy(_ensure_value(namespace, self.dest, []))
        items.append(self.const)
        setattr(namespace, self.dest, items)


class _CountAction(Action):

    def __init__(self,
                 option_strings,
                 dest,
                 default=None,
                 required=False,
                 help=None):
        super(_CountAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=0,
            default=default,
            required=required,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        new_count = _ensure_value(namespace, self.dest, 0) + 1
        setattr(namespace, self.dest, new_count)


class _HelpAction(Action):

    def __init__(self,
                 option_strings,
                 dest=SUPPRESS,
                 default=SUPPRESS,
                 help=None):
        super(_HelpAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)

    def __call__(self, parser, namespace, values, option_string=None):
        parser.print_help()
        parser.exit()


class _VersionAction(Action):

    def __init__(self,
                 option_strings,
                 version=None,
                 dest=SUPPRESS,
                 default=SUPPRESS,
                 help="show program's version number and exit"):
        super(_VersionAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            default=default,
            nargs=0,
            help=help)
        self.version = version

    def __call__(self, parser, namespace, values, option_string=None):
        version = self.version
        if version is None:
            version = parser.version
        formatter = parser._get_formatter()
        formatter.add_text(version)
        parser.exit(message=formatter.format_help())


class _SubParsersAction(Action):

    class _ChoicesPseudoAction(Action):

        def __init__(self, name, help):
            sup = super(_SubParsersAction._ChoicesPseudoAction, self)
            sup.__init__(option_strings=[], dest=name, help=help)

    def __init__(self,
                 option_strings,
                 prog,
                 parser_class,
                 dest=SUPPRESS,
                 help=None,
                 metavar=None):

        self._prog_prefix = prog
        self._parser_class = parser_class
        self._name_parser_map = {}
        self._choices_actions = []

        super(_SubParsersAction, self).__init__(
            option_strings=option_strings,
            dest=dest,
            nargs=PARSER,
            choices=self._name_parser_map,
            help=help,
            metavar=metavar)

    def add_parser(self, name, **kwargs):
        # set prog from the existing prefix
        if kwargs.get('prog') is None:
            kwargs['prog'] = '%s %s' % (self._prog_prefix, name)

        # create a pseudo-action to hold the choice help
        if 'help' in kwargs:
            help = kwargs.pop('help')
            choice_action = self._ChoicesPseudoAction(name, help)
            self._choices_actions.append(choice_action)

        # create the parser and add it to the map
        parser = self._parser_class(**kwargs)
        self._name_parser_map[name] = parser
        return parser

    def _get_subactions(self):
        return self._choices_actions

    def __call__(self, parser, namespace, values, option_string=None):
        parser_name = values[0]
        arg_strings = values[1:]

        # set the parser name if requested
        if self.dest is not SUPPRESS:
            setattr(namespace, self.dest, parser_name)

        # select the parser
        try:
            parser = self._name_parser_map[parser_name]
        except KeyError:
            tup = parser_name, ', '.join(self._name_parser_map)
            msg = _('unknown parser %r (choices: %s)' % tup)
            raise ArgumentError(self, msg)

        # parse all the remaining options into the namespace
        # store any unrecognized options on the object, so that the top
        # level parser can decide what to do with them
        namespace, arg_strings = parser.parse_known_args(arg_strings, namespace)
        if arg_strings:
            vars(namespace).setdefault(_UNRECOGNIZED_ARGS_ATTR, [])
            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)


# ==============
# Type classes
# ==============

class FileType(object):
    """Factory for creating file object types

    Instances of FileType are typically passed as type= arguments to the
    ArgumentParser add_argument() method.

    Keyword Arguments:
        - mode -- A string indicating how the file is to be opened. Accepts the
            same values as the builtin open() function.
        - bufsize -- The file's desired buffer size. Accepts the same values as
            the builtin open() function.
    """

    def __init__(self, mode='r', bufsize=None):
        self._mode = mode
        self._bufsize = bufsize

    def __call__(self, string):
        # the special argument "-" means sys.std{in,out}
        if string == '-':
            if 'r' in self._mode:
                return _sys.stdin
            elif 'w' in self._mode:
                return _sys.stdout
            else:
                msg = _('argument "-" with mode %r' % self._mode)
                raise ValueError(msg)

        # all other arguments are used as file names
        if self._bufsize:
            return open(string, self._mode, self._bufsize)
        else:
            return open(string, self._mode)

    def __repr__(self):
        args = [self._mode, self._bufsize]
        args_str = ', '.join([repr(arg) for arg in args if arg is not None])
        return '%s(%s)' % (type(self).__name__, args_str)

# ===========================
# Optional and Positional Parsing
# ===========================

class Namespace(_AttributeHolder):
    """Simple object for storing attributes.

    Implements equality by attribute names and values, and provides a simple
    string representation.
    """

    def __init__(self, **kwargs):
        for name in kwargs:
            setattr(self, name, kwargs[name])

    __hash__ = None

    def __eq__(self, other):
        return vars(self) == vars(other)

    def __ne__(self, other):
        return not (self == other)

    def __contains__(self, key):
        return key in self.__dict__


class _ActionsContainer(object):

    def __init__(self,
                 description,
                 prefix_chars,
                 argument_default,
                 conflict_handler):
        super(_ActionsContainer, self).__init__()

        self.description = description
        self.argument_default = argument_default
        self.prefix_chars = prefix_chars
        self.conflict_handler = conflict_handler

        # set up registries
        self._registries = {}

        # register actions
        self.register('action', None, _StoreAction)
        self.register('action', 'store', _StoreAction)
        self.register('action', 'store_const', _StoreConstAction)
        self.register('action', 'store_true', _StoreTrueAction)
        self.register('action', 'store_false', _StoreFalseAction)
        self.register('action', 'append', _AppendAction)
        self.register('action', 'append_const', _AppendConstAction)
        self.register('action', 'count', _CountAction)
        self.register('action', 'help', _HelpAction)
        self.register('action', 'version', _VersionAction)
        self.register('action', 'parsers', _SubParsersAction)

        # raise an exception if the conflict handler is invalid
        self._get_handler()

        # action storage
        self._actions = []
        self._option_string_actions = {}

        # groups
        self._action_groups = []
        self._mutually_exclusive_groups = []

        # defaults storage
        self._defaults = {}

        # determines whether an "option" looks like a negative number
        self._negative_number_matcher = _re.compile(r'^-\d+$|^-\d*\.\d+$')

        # whether or not there are any optionals that look like negative
        # numbers -- uses a list so it can be shared and edited
        self._has_negative_number_optionals = []

    # ====================
    # Registration methods
    # ====================
    def register(self, registry_name, value, object):
        registry = self._registries.setdefault(registry_name, {})
        registry[value] = object

    def _registry_get(self, registry_name, value, default=None):
        return self._registries[registry_name].get(value, default)

    # ==================================
    # Namespace default accessor methods
    # ==================================
    def set_defaults(self, **kwargs):
        self._defaults.update(kwargs)

        # if these defaults match any existing arguments, replace
        # the previous default on the object with the new one
        for action in self._actions:
            if action.dest in kwargs:
                action.default = kwargs[action.dest]

    def get_default(self, dest):
        for action in self._actions:
            if action.dest == dest and action.default is not None:
                return action.default
        return self._defaults.get(dest, None)


    # =======================
    # Adding argument actions
    # =======================
    def add_argument(self, *args, **kwargs):
        """
        add_argument(dest, ..., name=value, ...)
        add_argument(option_string, option_string, ..., name=value, ...)
        """

        # if no positional args are supplied or only one is supplied and
        # it doesn't look like an option string, parse a positional
        # argument
        chars = self.prefix_chars
        if not args or len(args) == 1 and args[0][0] not in chars:
            if args and 'dest' in kwargs:
                raise ValueError('dest supplied twice for positional argument')
            kwargs = self._get_positional_kwargs(*args, **kwargs)

        # otherwise, we're adding an optional argument
        else:
            kwargs = self._get_optional_kwargs(*args, **kwargs)

        # if no default was supplied, use the parser-level default
        if 'default' not in kwargs:
            dest = kwargs['dest']
            if dest in self._defaults:
                kwargs['default'] = self._defaults[dest]
            elif self.argument_default is not None:
                kwargs['default'] = self.argument_default

        # create the action object, and add it to the parser
        action_class = self._pop_action_class(kwargs)
        if not _callable(action_class):
            raise ValueError('unknown action "%s"' % action_class)
        action = action_class(**kwargs)

        # raise an error if the action type is not callable
        type_func = self._registry_get('type', action.type, action.type)
        if not _callable(type_func):
            raise ValueError('%r is not callable' % type_func)

        return self._add_action(action)

    def add_argument_group(self, *args, **kwargs):
        group = _ArgumentGroup(self, *args, **kwargs)
        self._action_groups.append(group)
        return group

    def add_mutually_exclusive_group(self, **kwargs):
        group = _MutuallyExclusiveGroup(self, **kwargs)
        self._mutually_exclusive_groups.append(group)
        return group

    def _add_action(self, action):
        # resolve any conflicts
        self._check_conflict(action)

        # add to actions list
        self._actions.append(action)
        action.container = self

        # index the action by any option strings it has
        for option_string in action.option_strings:
            self._option_string_actions[option_string] = action

        # set the flag if any option strings look like negative numbers
        for option_string in action.option_strings:
            if self._negative_number_matcher.match(option_string):
                if not self._has_negative_number_optionals:
                    self._has_negative_number_optionals.append(True)

        # return the created action
        return action

    def _remove_action(self, action):
        self._actions.remove(action)

    def _add_container_actions(self, container):
        # collect groups by titles
        title_group_map = {}
        for group in self._action_groups:
            if group.title in title_group_map:
                msg = _('cannot merge actions - two groups are named %r')
                raise ValueError(msg % (group.title))
            title_group_map[group.title] = group

        # map each action to its group
        group_map = {}
        for group in container._action_groups:

            # if a group with the title exists, use that, otherwise
            # create a new group matching the container's group
            if group.title not in title_group_map:
                title_group_map[group.title] = self.add_argument_group(
                    title=group.title,
                    description=group.description,
                    conflict_handler=group.conflict_handler)

            # map the actions to their new group
            for action in group._group_actions:
                group_map[action] = title_group_map[group.title]

        # add container's mutually exclusive groups
        # NOTE: if add_mutually_exclusive_group ever gains title= and
        # description= then this code will need to be expanded as above
        for group in container._mutually_exclusive_groups:
            mutex_group = self.add_mutually_exclusive_group(
                required=group.required)

            # map the actions to their new mutex group
            for action in group._group_actions:
                group_map[action] = mutex_group

        # add all actions to this container or their group
        for action in container._actions:
            group_map.get(action, self)._add_action(action)

    def _get_positional_kwargs(self, dest, **kwargs):
        # make sure required is not specified
        if 'required' in kwargs:
            msg = _("'required' is an invalid argument for positionals")
            raise TypeError(msg)

        # mark positional arguments as required if at least one is
        # always required
        if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:
            kwargs['required'] = True
        if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:
            kwargs['required'] = True

        # return the keyword arguments with no option strings
        return dict(kwargs, dest=dest, option_strings=[])

    def _get_optional_kwargs(self, *args, **kwargs):
        # determine short and long option strings
        option_strings = []
        long_option_strings = []
        for option_string in args:
            # error on strings that don't start with an appropriate prefix
            if not option_string[0] in self.prefix_chars:
                msg = _('invalid option string %r: '
                        'must start with a character %r')
                tup = option_string, self.prefix_chars
                raise ValueError(msg % tup)

            # strings starting with two prefix characters are long options
            option_strings.append(option_string)
            if option_string[0] in self.prefix_chars:
                if len(option_string) > 1:
                    if option_string[1] in self.prefix_chars:
                        long_option_strings.append(option_string)

        # infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'
        dest = kwargs.pop('dest', None)
        if dest is None:
            if long_option_strings:
                dest_option_string = long_option_strings[0]
            else:
                dest_option_string = option_strings[0]
            dest = dest_option_string.lstrip(self.prefix_chars)
            if not dest:
                msg = _('dest= is required for options like %r')
                raise ValueError(msg % option_string)
            dest = dest.replace('-', '_')

        # return the updated keyword arguments
        return dict(kwargs, dest=dest, option_strings=option_strings)

    def _pop_action_class(self, kwargs, default=None):
        action = kwargs.pop('action', default)
        return self._registry_get('action', action, action)

    def _get_handler(self):
        # determine function from conflict handler string
        handler_func_name = '_handle_conflict_%s' % self.conflict_handler
        try:
            return getattr(self, handler_func_name)
        except AttributeError:
            msg = _('invalid conflict_resolution value: %r')
            raise ValueError(msg % self.conflict_handler)

    def _check_conflict(self, action):

        # find all options that conflict with this option
        confl_optionals = []
        for option_string in action.option_strings:
            if option_string in self._option_string_actions:
                confl_optional = self._option_string_actions[option_string]
                confl_optionals.append((option_string, confl_optional))

        # resolve any conflicts
        if confl_optionals:
            conflict_handler = self._get_handler()
            conflict_handler(action, confl_optionals)

    def _handle_conflict_error(self, action, conflicting_actions):
        message = _('conflicting option string(s): %s')
        conflict_string = ', '.join([option_string
                                     for option_string, action
                                     in conflicting_actions])
        raise ArgumentError(action, message % conflict_string)

    def _handle_conflict_resolve(self, action, conflicting_actions):

        # remove all conflicting options
        for option_string, action in conflicting_actions:

            # remove the conflicting option
            action.option_strings.remove(option_string)
            self._option_string_actions.pop(option_string, None)

            # if the option now has no option string, remove it from the
            # container holding it
            if not action.option_strings:
                action.container._remove_action(action)


class _ArgumentGroup(_ActionsContainer):

    def __init__(self, container, title=None, description=None, **kwargs):
        # add any missing keyword arguments by checking the container
        update = kwargs.setdefault
        update('conflict_handler', container.conflict_handler)
        update('prefix_chars', container.prefix_chars)
        update('argument_default', container.argument_default)
        super_init = super(_ArgumentGroup, self).__init__
        super_init(description=description, **kwargs)

        # group attributes
        self.title = title
        self._group_actions = []

        # share most attributes with the container
        self._registries = container._registries
        self._actions = container._actions
        self._option_string_actions = container._option_string_actions
        self._defaults = container._defaults
        self._has_negative_number_optionals = \
            container._has_negative_number_optionals

    def _add_action(self, action):
        action = super(_ArgumentGroup, self)._add_action(action)
        self._group_actions.append(action)
        return action

    def _remove_action(self, action):
        super(_ArgumentGroup, self)._remove_action(action)
        self._group_actions.remove(action)


class _MutuallyExclusiveGroup(_ArgumentGroup):

    def __init__(self, container, required=False):
        super(_MutuallyExclusiveGroup, self).__init__(container)
        self.required = required
        self._container = container

    def _add_action(self, action):
        if action.required:
            msg = _('mutually exclusive arguments must be optional')
            raise ValueError(msg)
        action = self._container._add_action(action)
        self._group_actions.append(action)
        return action

    def _remove_action(self, action):
        self._container._remove_action(action)
        self._group_actions.remove(action)


class ArgumentParser(_AttributeHolder, _ActionsContainer):
    """Object for parsing command line strings into Python objects.

    Keyword Arguments:
        - prog -- The name of the program (default: sys.argv[0])
        - usage -- A usage message (default: auto-generated from arguments)
        - description -- A description of what the program does
        - epilog -- Text following the argument descriptions
        - parents -- Parsers whose arguments should be copied into this one
        - formatter_class -- HelpFormatter class for printing help messages
        - prefix_chars -- Characters that prefix optional arguments
        - fromfile_prefix_chars -- Characters that prefix files containing
            additional arguments
        - argument_default -- The default value for all arguments
        - conflict_handler -- String indicating how to handle conflicts
        - add_help -- Add a -h/-help option
    """

    def __init__(self,
                 prog=None,
                 usage=None,
                 description=None,
                 epilog=None,
                 version=None,
                 parents=[],
                 formatter_class=HelpFormatter,
                 prefix_chars='-',
                 fromfile_prefix_chars=None,
                 argument_default=None,
                 conflict_handler='error',
                 add_help=True):

        if version is not None:
            import warnings
            warnings.warn(
                """The "version" argument to ArgumentParser is deprecated. """
                """Please use """
                """"add_argument(..., action='version', version="N", ...)" """
                """instead""", DeprecationWarning)

        superinit = super(ArgumentParser, self).__init__
        superinit(description=description,
                  prefix_chars=prefix_chars,
                  argument_default=argument_default,
                  conflict_handler=conflict_handler)

        # default setting for prog
        if prog is None:
            prog = _os.path.basename(_sys.argv[0])

        self.prog = prog
        self.usage = usage
        self.epilog = epilog
        self.version = version
        self.formatter_class = formatter_class
        self.fromfile_prefix_chars = fromfile_prefix_chars
        self.add_help = add_help

        add_group = self.add_argument_group
        self._positionals = add_group(_('positional arguments'))
        self._optionals = add_group(_('optional arguments'))
        self._subparsers = None

        # register types
        def identity(string):
            return string
        self.register('type', None, identity)

        # add help and version arguments if necessary
        # (using explicit default to override global argument_default)
        if '-' in prefix_chars:
            default_prefix = '-'
        else:
            default_prefix = prefix_chars[0]
        if self.add_help:
            self.add_argument(
                default_prefix+'h', default_prefix*2+'help',
                action='help', default=SUPPRESS,
                help=_('show this help message and exit'))
        if self.version:
            self.add_argument(
                default_prefix+'v', default_prefix*2+'version',
                action='version', default=SUPPRESS,
                version=self.version,
                help=_("show program's version number and exit"))

        # add parent arguments and defaults
        for parent in parents:
            self._add_container_actions(parent)
            try:
                defaults = parent._defaults
            except AttributeError:
                pass
            else:
                self._defaults.update(defaults)

    # =======================
    # Pretty __repr__ methods
    # =======================
    def _get_kwargs(self):
        names = [
            'prog',
            'usage',
            'description',
            'version',
            'formatter_class',
            'conflict_handler',
            'add_help',
        ]
        return [(name, getattr(self, name)) for name in names]

    # ==================================
    # Optional/Positional adding methods
    # ==================================
    def add_subparsers(self, **kwargs):
        if self._subparsers is not None:
            self.error(_('cannot have multiple subparser arguments'))

        # add the parser class to the arguments if it's not present
        kwargs.setdefault('parser_class', type(self))

        if 'title' in kwargs or 'description' in kwargs:
            title = _(kwargs.pop('title', 'subcommands'))
            description = _(kwargs.pop('description', None))
            self._subparsers = self.add_argument_group(title, description)
        else:
            self._subparsers = self._positionals

        # prog defaults to the usage message of this parser, skipping
        # optional arguments and with no "usage:" prefix
        if kwargs.get('prog') is None:
            formatter = self._get_formatter()
            positionals = self._get_positional_actions()
            groups = self._mutually_exclusive_groups
            formatter.add_usage(self.usage, positionals, groups, '')
            kwargs['prog'] = formatter.format_help().strip()

        # create the parsers action and add it to the positionals list
        parsers_class = self._pop_action_class(kwargs, 'parsers')
        action = parsers_class(option_strings=[], **kwargs)
        self._subparsers._add_action(action)

        # return the created parsers action
        return action

    def _add_action(self, action):
        if action.option_strings:
            self._optionals._add_action(action)
        else:
            self._positionals._add_action(action)
        return action

    def _get_optional_actions(self):
        return [action
                for action in self._actions
                if action.option_strings]

    def _get_positional_actions(self):
        return [action
                for action in self._actions
                if not action.option_strings]

    # =====================================
    # Command line argument parsing methods
    # =====================================
    def parse_args(self, args=None, namespace=None):
        args, argv = self.parse_known_args(args, namespace)
        if argv:
            msg = _('unrecognized arguments: %s')
            self.error(msg % ' '.join(argv))
        return args

    def parse_known_args(self, args=None, namespace=None):
        # args default to the system args
        if args is None:
            args = _sys.argv[1:]

        # default Namespace built from parser defaults
        if namespace is None:
            namespace = Namespace()

        # add any action defaults that aren't present
        for action in self._actions:
            if action.dest is not SUPPRESS:
                if not hasattr(namespace, action.dest):
                    if action.default is not SUPPRESS:
                        default = action.default
                        if isinstance(action.default, basestring):
                            default = self._get_value(action, default)
                        setattr(namespace, action.dest, default)

        # add any parser defaults that aren't present
        for dest in self._defaults:
            if not hasattr(namespace, dest):
                setattr(namespace, dest, self._defaults[dest])

        # parse the arguments and exit if there are any errors
        try:
            namespace, args = self._parse_known_args(args, namespace)
            if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):
                args.extend(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))
                delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)
            return namespace, args
        except ArgumentError:
            err = _sys.exc_info()[1]
            self.error(str(err))

    def _parse_known_args(self, arg_strings, namespace):
        # replace arg strings that are file references
        if self.fromfile_prefix_chars is not None:
            arg_strings = self._read_args_from_files(arg_strings)

        # map all mutually exclusive arguments to the other arguments
        # they can't occur with
        action_conflicts = {}
        for mutex_group in self._mutually_exclusive_groups:
            group_actions = mutex_group._group_actions
            for i, mutex_action in enumerate(mutex_group._group_actions):
                conflicts = action_conflicts.setdefault(mutex_action, [])
                conflicts.extend(group_actions[:i])
                conflicts.extend(group_actions[i + 1:])

        # find all option indices, and determine the arg_string_pattern
        # which has an 'O' if there is an option at an index,
        # an 'A' if there is an argument, or a '-' if there is a '--'
        option_string_indices = {}
        arg_string_pattern_parts = []
        arg_strings_iter = iter(arg_strings)
        for i, arg_string in enumerate(arg_strings_iter):

            # all args after -- are non-options
            if arg_string == '--':
                arg_string_pattern_parts.append('-')
                for arg_string in arg_strings_iter:
                    arg_string_pattern_parts.append('A')

            # otherwise, add the arg to the arg strings
            # and note the index if it was an option
            else:
                option_tuple = self._parse_optional(arg_string)
                if option_tuple is None:
                    pattern = 'A'
                else:
                    option_string_indices[i] = option_tuple
                    pattern = 'O'
                arg_string_pattern_parts.append(pattern)

        # join the pieces together to form the pattern
        arg_strings_pattern = ''.join(arg_string_pattern_parts)

        # converts arg strings to the appropriate and then takes the action
        seen_actions = set()
        seen_non_default_actions = set()

        def take_action(action, argument_strings, option_string=None):
            seen_actions.add(action)
            argument_values = self._get_values(action, argument_strings)

            # error if this argument is not allowed with other previously
            # seen arguments, assuming that actions that use the default
            # value don't really count as "present"
            if argument_values is not action.default:
                seen_non_default_actions.add(action)
                for conflict_action in action_conflicts.get(action, []):
                    if conflict_action in seen_non_default_actions:
                        msg = _('not allowed with argument %s')
                        action_name = _get_action_name(conflict_action)
                        raise ArgumentError(action, msg % action_name)

            # take the action if we didn't receive a SUPPRESS value
            # (e.g. from a default)
            if argument_values is not SUPPRESS:
                action(self, namespace, argument_values, option_string)

        # function to convert arg_strings into an optional action
        def consume_optional(start_index):

            # get the optional identified at this index
            option_tuple = option_string_indices[start_index]
            action, option_string, explicit_arg = option_tuple

            # identify additional optionals in the same arg string
            # (e.g. -xyz is the same as -x -y -z if no args are required)
            match_argument = self._match_argument
            action_tuples = []
            while True:

                # if we found no optional action, skip it
                if action is None:
                    extras.append(arg_strings[start_index])
                    return start_index + 1

                # if there is an explicit argument, try to match the
                # optional's string arguments to only this
                if explicit_arg is not None:
                    arg_count = match_argument(action, 'A')

                    # if the action is a single-dash option and takes no
                    # arguments, try to parse more single-dash options out
                    # of the tail of the option string
                    chars = self.prefix_chars
                    if arg_count == 0 and option_string[1] not in chars:
                        action_tuples.append((action, [], option_string))
                        char = option_string[0]
                        option_string = char + explicit_arg[0]
                        new_explicit_arg = explicit_arg[1:] or None
                        optionals_map = self._option_string_actions
                        if option_string in optionals_map:
                            action = optionals_map[option_string]
                            explicit_arg = new_explicit_arg
                        else:
                            msg = _('ignored explicit argument %r')
                            raise ArgumentError(action, msg % explicit_arg)

                    # if the action expect exactly one argument, we've
                    # successfully matched the option; exit the loop
                    elif arg_count == 1:
                        stop = start_index + 1
                        args = [explicit_arg]
                        action_tuples.append((action, args, option_string))
                        break

                    # error if a double-dash option did not use the
                    # explicit argument
                    else:
                        msg = _('ignored explicit argument %r')
                        raise ArgumentError(action, msg % explicit_arg)

                # if there is no explicit argument, try to match the
                # optional's string arguments with the following strings
                # if successful, exit the loop
                else:
                    start = start_index + 1
                    selected_patterns = arg_strings_pattern[start:]
                    arg_count = match_argument(action, selected_patterns)
                    stop = start + arg_count
                    args = arg_strings[start:stop]
                    action_tuples.append((action, args, option_string))
                    break

            # add the Optional to the list and return the index at which
            # the Optional's string args stopped
            assert action_tuples
            for action, args, option_string in action_tuples:
                take_action(action, args, option_string)
            return stop

        # the list of Positionals left to be parsed; this is modified
        # by consume_positionals()
        positionals = self._get_positional_actions()

        # function to convert arg_strings into positional actions
        def consume_positionals(start_index):
            # match as many Positionals as possible
            match_partial = self._match_arguments_partial
            selected_pattern = arg_strings_pattern[start_index:]
            arg_counts = match_partial(positionals, selected_pattern)

            # slice off the appropriate arg strings for each Positional
            # and add the Positional and its args to the list
            for action, arg_count in zip(positionals, arg_counts):
                args = arg_strings[start_index: start_index + arg_count]
                start_index += arg_count
                take_action(action, args)

            # slice off the Positionals that we just parsed and return the
            # index at which the Positionals' string args stopped
            positionals[:] = positionals[len(arg_counts):]
            return start_index

        # consume Positionals and Optionals alternately, until we have
        # passed the last option string
        extras = []
        start_index = 0
        if option_string_indices:
            max_option_string_index = max(option_string_indices)
        else:
            max_option_string_index = -1
        while start_index <= max_option_string_index:

            # consume any Positionals preceding the next option
            next_option_string_index = min([
                index
                for index in option_string_indices
                if index >= start_index])
            if start_index != next_option_string_index:
                positionals_end_index = consume_positionals(start_index)

                # only try to parse the next optional if we didn't consume
                # the option string during the positionals parsing
                if positionals_end_index > start_index:
                    start_index = positionals_end_index
                    continue
                else:
                    start_index = positionals_end_index

            # if we consumed all the positionals we could and we're not
            # at the index of an option string, there were extra arguments
            if start_index not in option_string_indices:
                strings = arg_strings[start_index:next_option_string_index]
                extras.extend(strings)
                start_index = next_option_string_index

            # consume the next optional and any arguments for it
            start_index = consume_optional(start_index)

        # consume any positionals following the last Optional
        stop_index = consume_positionals(start_index)

        # if we didn't consume all the argument strings, there were extras
        extras.extend(arg_strings[stop_index:])

        # if we didn't use all the Positional objects, there were too few
        # arg strings supplied.
        if positionals:
            self.error(_('too few arguments'))

        # make sure all required actions were present
        for action in self._actions:
            if action.required:
                if action not in seen_actions:
                    name = _get_action_name(action)
                    self.error(_('argument %s is required') % name)

        # make sure all required groups had one option present
        for group in self._mutually_exclusive_groups:
            if group.required:
                for action in group._group_actions:
                    if action in seen_non_default_actions:
                        break

                # if no actions were used, report the error
                else:
                    names = [_get_action_name(action)
                             for action in group._group_actions
                             if action.help is not SUPPRESS]
                    msg = _('one of the arguments %s is required')
                    self.error(msg % ' '.join(names))

        # return the updated namespace and the extra arguments
        return namespace, extras

    def _read_args_from_files(self, arg_strings):
        # expand arguments referencing files
        new_arg_strings = []
        for arg_string in arg_strings:

            # for regular arguments, just add them back into the list
            if arg_string[0] not in self.fromfile_prefix_chars:
                new_arg_strings.append(arg_string)

            # replace arguments referencing files with the file content
            else:
                try:
                    args_file = open(arg_string[1:])
                    try:
                        arg_strings = []
                        for arg_line in args_file.read().splitlines():
                            for arg in self.convert_arg_line_to_args(arg_line):
                                arg_strings.append(arg)
                        arg_strings = self._read_args_from_files(arg_strings)
                        new_arg_strings.extend(arg_strings)
                    finally:
                        args_file.close()
                except IOError:
                    err = _sys.exc_info()[1]
                    self.error(str(err))

        # return the modified argument list
        return new_arg_strings

    def convert_arg_line_to_args(self, arg_line):
        return [arg_line]

    def _match_argument(self, action, arg_strings_pattern):
        # match the pattern for this action to the arg strings
        nargs_pattern = self._get_nargs_pattern(action)
        match = _re.match(nargs_pattern, arg_strings_pattern)

        # raise an exception if we weren't able to find a match
        if match is None:
            nargs_errors = {
                None: _('expected one argument'),
                OPTIONAL: _('expected at most one argument'),
                ONE_OR_MORE: _('expected at least one argument'),
            }
            default = _('expected %s argument(s)') % action.nargs
            msg = nargs_errors.get(action.nargs, default)
            raise ArgumentError(action, msg)

        # return the number of arguments matched
        return len(match.group(1))

    def _match_arguments_partial(self, actions, arg_strings_pattern):
        # progressively shorten the actions list by slicing off the
        # final actions until we find a match
        result = []
        for i in range(len(actions), 0, -1):
            actions_slice = actions[:i]
            pattern = ''.join([self._get_nargs_pattern(action)
                               for action in actions_slice])
            match = _re.match(pattern, arg_strings_pattern)
            if match is not None:
                result.extend([len(string) for string in match.groups()])
                break

        # return the list of arg string counts
        return result

    def _parse_optional(self, arg_string):
        # if it's an empty string, it was meant to be a positional
        if not arg_string:
            return None

        # if it doesn't start with a prefix, it was meant to be positional
        if not arg_string[0] in self.prefix_chars:
            return None

        # if the option string is present in the parser, return the action
        if arg_string in self._option_string_actions:
            action = self._option_string_actions[arg_string]
            return action, arg_string, None

        # if it's just a single character, it was meant to be positional
        if len(arg_string) == 1:
            return None

        # if the option string before the "=" is present, return the action
        if '=' in arg_string:
            option_string, explicit_arg = arg_string.split('=', 1)
            if option_string in self._option_string_actions:
                action = self._option_string_actions[option_string]
                return action, option_string, explicit_arg

        # search through all possible prefixes of the option string
        # and all actions in the parser for possible interpretations
        option_tuples = self._get_option_tuples(arg_string)

        # if multiple actions match, the option string was ambiguous
        if len(option_tuples) > 1:
            options = ', '.join([option_string
                for action, option_string, explicit_arg in option_tuples])
            tup = arg_string, options
            self.error(_('ambiguous option: %s could match %s') % tup)

        # if exactly one action matched, this segmentation is good,
        # so return the parsed action
        elif len(option_tuples) == 1:
            option_tuple, = option_tuples
            return option_tuple

        # if it was not found as an option, but it looks like a negative
        # number, it was meant to be positional
        # unless there are negative-number-like options
        if self._negative_number_matcher.match(arg_string):
            if not self._has_negative_number_optionals:
                return None

        # if it contains a space, it was meant to be a positional
        if ' ' in arg_string:
            return None

        # it was meant to be an optional but there is no such option
        # in this parser (though it might be a valid option in a subparser)
        return None, arg_string, None

    def _get_option_tuples(self, option_string):
        result = []

        # option strings starting with two prefix characters are only
        # split at the '='
        chars = self.prefix_chars
        if option_string[0] in chars and option_string[1] in chars:
            if '=' in option_string:
                option_prefix, explicit_arg = option_string.split('=', 1)
            else:
                option_prefix = option_string
                explicit_arg = None
            for option_string in self._option_string_actions:
                if option_string.startswith(option_prefix):
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, explicit_arg
                    result.append(tup)

        # single character options can be concatenated with their arguments
        # but multiple character options always have to have their argument
        # separate
        elif option_string[0] in chars and option_string[1] not in chars:
            option_prefix = option_string
            explicit_arg = None
            short_option_prefix = option_string[:2]
            short_explicit_arg = option_string[2:]

            for option_string in self._option_string_actions:
                if option_string == short_option_prefix:
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, short_explicit_arg
                    result.append(tup)
                elif option_string.startswith(option_prefix):
                    action = self._option_string_actions[option_string]
                    tup = action, option_string, explicit_arg
                    result.append(tup)

        # shouldn't ever get here
        else:
            self.error(_('unexpected option string: %s') % option_string)

        # return the collected option tuples
        return result

    def _get_nargs_pattern(self, action):
        # in all examples below, we have to allow for '--' args
        # which are represented as '-' in the pattern
        nargs = action.nargs

        # the default (None) is assumed to be a single argument
        if nargs is None:
            nargs_pattern = '(-*A-*)'

        # allow zero or one arguments
        elif nargs == OPTIONAL:
            nargs_pattern = '(-*A?-*)'

        # allow zero or more arguments
        elif nargs == ZERO_OR_MORE:
            nargs_pattern = '(-*[A-]*)'

        # allow one or more arguments
        elif nargs == ONE_OR_MORE:
            nargs_pattern = '(-*A[A-]*)'

        # allow any number of options or arguments
        elif nargs == REMAINDER:
            nargs_pattern = '([-AO]*)'

        # allow one argument followed by any number of options or arguments
        elif nargs == PARSER:
            nargs_pattern = '(-*A[-AO]*)'

        # all others should be integers
        else:
            nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)

        # if this is an optional action, -- is not allowed
        if action.option_strings:
            nargs_pattern = nargs_pattern.replace('-*', '')
            nargs_pattern = nargs_pattern.replace('-', '')

        # return the pattern
        return nargs_pattern

    # ========================
    # Value conversion methods
    # ========================
    def _get_values(self, action, arg_strings):
        # for everything but PARSER args, strip out '--'
        if action.nargs not in [PARSER, REMAINDER]:
            arg_strings = [s for s in arg_strings if s != '--']

        # optional argument produces a default when not present
        if not arg_strings and action.nargs == OPTIONAL:
            if action.option_strings:
                value = action.const
            else:
                value = action.default
            if isinstance(value, basestring):
                value = self._get_value(action, value)
                self._check_value(action, value)

        # when nargs='*' on a positional, if there were no command-line
        # args, use the default if it is anything other than None
        elif (not arg_strings and action.nargs == ZERO_OR_MORE and
              not action.option_strings):
            if action.default is not None:
                value = action.default
            else:
                value = arg_strings
            self._check_value(action, value)

        # single argument or optional argument produces a single value
        elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:
            arg_string, = arg_strings
            value = self._get_value(action, arg_string)
            self._check_value(action, value)

        # REMAINDER arguments convert all values, checking none
        elif action.nargs == REMAINDER:
            value = [self._get_value(action, v) for v in arg_strings]

        # PARSER arguments convert all values, but check only the first
        elif action.nargs == PARSER:
            value = [self._get_value(action, v) for v in arg_strings]
            self._check_value(action, value[0])

        # all other types of nargs produce a list
        else:
            value = [self._get_value(action, v) for v in arg_strings]
            for v in value:
                self._check_value(action, v)

        # return the converted value
        return value

    def _get_value(self, action, arg_string):
        type_func = self._registry_get('type', action.type, action.type)
        if not _callable(type_func):
            msg = _('%r is not callable')
            raise ArgumentError(action, msg % type_func)

        # convert the value to the appropriate type
        try:
            result = type_func(arg_string)

        # ArgumentTypeErrors indicate errors
        except ArgumentTypeError:
            name = getattr(action.type, '__name__', repr(action.type))
            msg = str(_sys.exc_info()[1])
            raise ArgumentError(action, msg)

        # TypeErrors or ValueErrors also indicate errors
        except (TypeError, ValueError):
            name = getattr(action.type, '__name__', repr(action.type))
            msg = _('invalid %s value: %r')
            raise ArgumentError(action, msg % (name, arg_string))

        # return the converted value
        return result

    def _check_value(self, action, value):
        # converted value must be one of the choices (if specified)
        if action.choices is not None and value not in action.choices:
            tup = value, ', '.join(map(repr, action.choices))
            msg = _('invalid choice: %r (choose from %s)') % tup
            raise ArgumentError(action, msg)

    # =======================
    # Help-formatting methods
    # =======================
    def format_usage(self):
        formatter = self._get_formatter()
        formatter.add_usage(self.usage, self._actions,
                            self._mutually_exclusive_groups)
        return formatter.format_help()

    def format_help(self):
        formatter = self._get_formatter()

        # usage
        formatter.add_usage(self.usage, self._actions,
                            self._mutually_exclusive_groups)

        # description
        formatter.add_text(self.description)

        # positionals, optionals and user-defined groups
        for action_group in self._action_groups:
            formatter.start_section(action_group.title)
            formatter.add_text(action_group.description)
            formatter.add_arguments(action_group._group_actions)
            formatter.end_section()

        # epilog
        formatter.add_text(self.epilog)

        # determine help from format above
        return formatter.format_help()

    def format_version(self):
        import warnings
        warnings.warn(
            'The format_version method is deprecated -- the "version" '
            'argument to ArgumentParser is no longer supported.',
            DeprecationWarning)
        formatter = self._get_formatter()
        formatter.add_text(self.version)
        return formatter.format_help()

    def _get_formatter(self):
        return self.formatter_class(prog=self.prog)

    # =====================
    # Help-printing methods
    # =====================
    def print_usage(self, file=None):
        if file is None:
            file = _sys.stdout
        self._print_message(self.format_usage(), file)

    def print_help(self, file=None):
        if file is None:
            file = _sys.stdout
        self._print_message(self.format_help(), file)

    def print_version(self, file=None):
        import warnings
        warnings.warn(
            'The print_version method is deprecated -- the "version" '
            'argument to ArgumentParser is no longer supported.',
            DeprecationWarning)
        self._print_message(self.format_version(), file)

    def _print_message(self, message, file=None):
        if message:
            if file is None:
                file = _sys.stderr
            file.write(message)

    # ===============
    # Exiting methods
    # ===============
    def exit(self, status=0, message=None):
        if message:
            self._print_message(message, _sys.stderr)
        _sys.exit(status)

    def error(self, message):
        """error(message: string)

        Prints a usage message incorporating the message to stderr and
        exits.

        If you override this in a subclass, it should not return -- it
        should either exit or raise an exception.
        """
        self.print_usage(_sys.stderr)
        self.exit(2, _('%s: error: %s\n') % (self.prog, message))

########NEW FILE########
__FILENAME__ = check_port_free
#!/usr/bin/env python
# -*- coding: utf-8 -*-

from __future__ import print_function

import os
import socket
import struct
import glob
import re
import sys
import time
import signal

_STATE_LISTEN = '0A'

_NETSTAT_FILES_TCP = ['/proc/net/tcp', '/proc/net/tcp6']

def _signalByName(name):
    try:
        return int(name)
    except ValueError:
        pass
    signames = dict((k, v) for k,v in signal.__dict__.items() if k.startswith('SIG'))
    if name in signames:
        return signames[name]
    sname = 'SIG_' + name
    if sname in signames:
        return signames[sname]
    sname = 'SIG' + name
    if sname in signames:
        return signames[sname]
    raise ValueError('Cannot find signal ' + str(name))

def _parseIpPort(kernelStr):
    ipStr,_,portStr = kernelStr.partition(':')
    port = int(portStr, 16)
    ipInt = int(ipStr, 16)
    if len(ipStr) == 8: # IPv4
        ip = socket.inet_ntop(socket.AF_INET, struct.pack('=I', ipInt))
    else: # IPv6
        ip = socket.inet_ntop(socket.AF_INET6, struct.pack('=IIII',
            ((ipInt >> 96) & 0xffffffff),
            ((ipInt >> 64) & 0xffffffff),
            ((ipInt >> 32) & 0xffffffff),
            ((ipInt >> 0) & 0xffffffff)
        ))
    return ip,port

class NoProcessException(Exception):
    def __init__(self, msg):
        super(NoProcessException, self).__init__()
        self.msg = msg

def _get_open_ports(sourceFiles=_NETSTAT_FILES_TCP):
    for sfn in sourceFiles:
        with open(sfn) as sf:
            proto = os.path.basename(sfn)
            next(sf) # Skip header line

            for line in sf:
                entries = line.split()
                state = entries[3]
                sockId = entries[9]
                if state != _STATE_LISTEN:
                    continue

                local_ip,local_port = _parseIpPort(entries[1])

                yield {
                    'proto': proto,
                    'port': local_port,
                    'local_address': local_ip,
                    'sockId': sockId,
                }

def netstat(includePrograms=True, sourceFiles=_NETSTAT_FILES_TCP):
    """ Returns a list of dictionaries with the following properties:
        proto: The procotol name ('tcp' or 'tcp6')
        port: The port number the application is listening on
        pid: The process ID
        pgid: The process group ID
        exe: executable name of the program in question
    """
    res = list(_get_open_ports(sourceFiles))
    if includePrograms:
        for fdFile in glob.iglob('/proc/[0-9]*/fd/*'):
            pid = int(fdFile.split('/')[2])
            try:
                linkTarget = os.readlink(fdFile)
            except OSError:
                continue

            m = re.match('^socket:\[(?P<sockId>[0-9]+)\]$', linkTarget)
            if m is not None:
                sockId = m.group('sockId')
                for d in res:
                    if d['sockId'] == sockId:
                        d['pid'] = pid
                        try:
                            d['exe'] = os.readlink('/proc/' + str(pid) + '/exe')
                        except OSError:
                            pass
                        try:
                            with open('/proc/' + str(pid) + '/stat') as statf:
                                d['pgid'] = int(statf.read().split()[4])
                        except IOError:
                            pass

    return res

def checkOnce(ports, opts_open=False, opts_kill='dont', opts_killSignal=signal.SIGTERM):
    nstat = netstat()
    errors = []
    messages = []
    for p in ports:
        matchingDicts = list(filter(lambda d: d['port'] == p, nstat))
        if len(matchingDicts) == 0:
            if opts_open:
                errors.append('Port %s not taken by any program' % p)
        else:
            if not opts_open:
                d = matchingDicts[0]

                # Recheck if that's still the case;
                # the port may have been closed since we last checkd
                if not any(recheckd['port'] == d['port']
                           for recheckd in _get_open_ports()):
                    continue

                bexename = os.path.basename(d.get('exe', '-'))

                errors.append('Port %s taken by %s/%s' % (d['port'], d.get('pid', '-'), bexename))
                if opts_kill == 'pid':
                    if 'pid' not in d:
                        raise NoProcessException('Cannot find process occupying port %s - are you root?' % d['port'])
                    messages.append('Killing pid ' + str(d['pid']) + ' (' + bexename + ' bound to ' + d['local_address'] + ':' + str(d['port']) + ')')
                    try:
                        os.kill(d['pid'], opts_killSignal)
                    except OSError as ose:
                        if ose.errno != errno.ESRCH:
                            raise
                elif opts_kill == 'pgid':
                    if 'pgid' not in d:
                        raise NoProcessException('Cannot find process group occupying port %s - are you root?' % d['port'])
                    messages.append('Killing pgid ' + str(d['pgid']) + ' (' + bexename + ' bound to ' + d['local_address'] + ':' + str(d['port']) + ')')
                    try:
                        os.killpg(d['pgid'], opts_killSignal)
                    except OSError as ose:
                        if ose.errno != errno.ESRCH:
                            raise
    return messages,errors

def check_port_free(ports, message_printer=None, opts_gracePeriod=0, opts_graceInterval=1, opts_open=False, opts_kill='dont', opts_killSignal=signal.SIGTERM):
    if message_printer is None:
        message_printer = lambda messages: None
    remaining_grace = opts_gracePeriod
    while True:
        messages,errors = checkOnce(ports, opts_open, opts_kill, opts_killSignal)
        if messages:
            message_printer(messages)
        if not errors or remaining_grace <= 0:
            break
        if messages:
            message_printer(messages)

        sleepTime = min(remaining_grace, opts_graceInterval)
        time.sleep(sleepTime)
        remaining_grace -= sleepTime
    if errors:
        message_printer(errors)
    return errors


def main():
    from optparse import OptionParser
    parser = OptionParser(usage='usage: %prog [options] port [port..]')
    parser.add_option(
        '-o', '--open',
        dest='open', action='store_true', default=False,
        help='require ports to be opened by a process instead of free')
    parser.add_option(
        '-k', '--kill-pid',
        dest='kill', action='store_const', const='pid', default=None,
        help='kill offending processes by process id')
    parser.add_option(
        '--kill-pgid',
        dest='kill', action='store_const', const='pgid', default=None,
        help='kill the offending process groups')
    parser.add_option(
        '--kill-signal',
        dest='killSignalStr', default=signal.SIGTERM,
        help='Use the specified signal instead of SIGTERM', metavar='SIGNAL')
    parser.add_option(
        '-g', '--grace-period',
        dest='gracePeriod', type='float', default=0, metavar='SECONDS',
        help='Seconds to wait for the condition to be fulfilled')
    parser.add_option('--grace-interval',
        dest='graceInterval', type='float', default=1, metavar='SECONDS',
        help='Check every n seconds')
    (opts, args) = parser.parse_args()

    ports = list(map(int, args))
    if not ports:
        parser.error('Need at least one port to test')
    opts.killSignal = _signalByName(opts.killSignalStr)
    message_printer = lambda messages: print('\n'.join(messages))

    try:
        errors = check_port_free(ports, message_printer,
            opts_gracePeriod=opts.gracePeriod,
            opts_graceInterval=opts.graceInterval,
            opts_open=opts.open, opts_kill=opts.kill,
            opts_killSignal=opts.killSignal)
    except NoProcessException as ne:
        sys.stderr.write(ne.msg + '\n')
        sys.exit(4)
    sys.exit(1 if errors else 0)

if __name__ == '__main__':
    main()


########NEW FILE########
__FILENAME__ = common
"""
Utility code to use in command line scripts.
You need some boilerplate code to import from this module
Cause it's probably not in the python path::

  # boilerplate code. copy that to a new commandline script
  import os
  import sys
  sys.path.insert(0,  os.path.abspath(os.path.dirname(__file__)))
  from common import create_parser, get_instances, load_from_args
  # /end boilerplate code

* Parse command line arguments with a preconfigured argparser::

    parser = create_parser('description of the command...', use_instances=True)
    # You can add more arguments to the parser
    # parser.add_argument(...)
    args = parser.parse_args()
    # args will contain all command line args
    load_from_args(args)
    instances = get_instances(args)  # returns instance objects
"""

try:
    from argparse import ArgumentParser
except ImportError:
    print ('This script uses argparse. It is part of python 2.7/3.2\n'
           'and can be installed from pypi for other versions:\n'
           'http://pypi.python.org/pypi/argparse')
    exit(1)
import os

from sqlalchemy import engine_from_config
from paste.deploy import appconfig

from adhocracy.config.environment import load_environment
from adhocracy.model import Instance

section = 'content'


def config_from_args(args):
    filename = args.file
    section = args.section
    return appconfig('config:%s#%s' % (os.path.abspath(filename), section))


def load_config(config):
    return load_environment(config.global_conf, config.local_conf)


def load_from_args(args):
    config = config_from_args(args)
    return load_config(config)


def create_parser(description, use_instance=True,
                  instance_help='Instances to consider'):
    parser = ArgumentParser(description=description)
    parser.add_argument("file", help="configuration file to use",
                        metavar="<config file>")
    parser.add_argument("-n", default=section, dest="section",
                        help=('name of the "app:"-section to use. (default: '
                              '%s)' % section))
    if use_instance:
        parser.add_argument(
            "-i", "--instance", metavar='INSTANCE', nargs="*",
            dest="instances", help=instance_help, action="append")
    return parser


def get_instances(args):
    '''
    Flatten out the instances parsed by a parser from create_parser
    used with `use_instance=True`
    '''
    if args.instances:
        keys = [item for sublist in args.instances for item in
                sublist]
        instances = []
        for key in keys:
            obj = Instance.find(key)
            if obj is None:
                raise ValueError("Instance '%s' does not exist" % key)
            instances.append(obj)
        return instances
    return None


def get_engine(conf, echo=True):
    return engine_from_config(conf.local_conf, echo=echo)

########NEW FILE########
__FILENAME__ = drop_data
#!/usr/bin/env python
"""
Drop all tables from the database specified in the <config file>
"""

# boilerplate code. copy that
import os
import sys
sys.path.insert(0,  os.path.abspath(os.path.dirname(__file__)))
# /end boilerplate code

from sqlalchemy.engine import reflection
from sqlalchemy.schema import (MetaData, Table, DropTable,
                               ForeignKeyConstraint, DropConstraint)

from common import create_parser, config_from_args, get_engine


def main():
    parser = create_parser(description=__doc__, use_instance=False)
    parser.add_argument('-f', dest='force', default=False, action='store_true',
                        help="force deletion without asking for confirmation")
    args = parser.parse_args()

    if not args.force:
        input = raw_input('Delete all data? No backup will be done! '
                          'If so type "yes": ')
        if input != 'yes':
            print 'Answer not "yes", but: "%s"\nAborting.' % input
            exit(1)

    config = config_from_args(args)
    engine = get_engine(config, echo=True)
    conn = engine.connect()

    # the transaction only applies if the DB supports
    # transactional DDL, i.e. Postgresql, MS SQL Server
    trans = conn.begin()

    inspector = reflection.Inspector.from_engine(engine)

    # gather all data first before dropping anything.
    # some DBs lock after things have been dropped in
    # a transaction.

    metadata = MetaData()

    tbs = []
    all_fks = []

    for table_name in inspector.get_table_names():
        fks = []
        for fk in inspector.get_foreign_keys(table_name):
            if not fk['name']:
                continue
            fks.append(
                ForeignKeyConstraint((), (), name=fk['name'])
                )
        t = Table(table_name, metadata, *fks)
        tbs.append(t)
        all_fks.extend(fks)

    for fkc in all_fks:
        conn.execute(DropConstraint(fkc))

    for table in tbs:
        conn.execute(DropTable(table))

    trans.commit()

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = generate-db-diagrams
from sqlalchemy.orm import class_mapper
from sqlalchemy_schemadisplay import create_schema_graph, create_uml_graph

from adhocracy import model


# create a diagram of all tables

graph = create_schema_graph(
    metadata=model.meta.data,
    show_datatypes=True,
    show_indexes=False,
    rankdir='LR',
    concentrate=False   # Don't try to join the relation lines together
)

graph.write_png('adhocracy-tables.png')


# create an uml diagramm of all mapped classes

mappers = []
for attr in dir(model):
    if attr[0] == '_':
        continue
    try:
        cls = getattr(model, attr)
        mappers.append(class_mapper(cls))
    except:
        pass

graph = create_uml_graph(mappers,
                         show_operations=False,
                         show_multiplicity_one=True)

graph.write_png('adhocracy-classes.png')

########NEW FILE########
__FILENAME__ = import_database_dump
#!/usr/bin/env python
"""
Import a dump file from pg_dump into the database specified
in the <config file>.
"""

# boilerplate code. copy that
import os
import sys
sys.path.insert(0,  os.path.abspath(os.path.dirname(__file__)))
from common import create_parser, config_from_args, get_engine
# /end boilerplate code

import subprocess


def main():
    parser = create_parser(description=__doc__, use_instance=False)
    parser.add_argument('--dump', default=None, required=True,
                        help="Path to the SQL dump file.")
    args = parser.parse_args()

    # check and cleanup dump file
    dump_path = os.path.join(os.getcwd(), args.dump)
    if not os.path.exists(dump_path):
        parser.error('SQL dump file "%s" does not exist.' % args.dump)

    # get an engine to get the driver type and connection details.
    engine = get_engine(config_from_args(args))
    drivername = engine.url.drivername

    error = False
    if drivername == 'postgresql':
        # use the psql command line script for imports.
        # pg_dump by default emits COPY ... FROM STDIN statements
        # which the psycopg2 driver can't handle.
        # pg_dump can emit inserts (--inserts), but that's
        # dead slow to import.
        vars = engine.url.__dict__.copy()
        vars['dump_path'] = dump_path
        command = ('psql -U {username} -h {host} -p {port} -'
                   'd {database} -f {dump_path}').format(**vars)
        print 'Executing command: %s' % command
        if engine.url.password is not None:
            print 'Prefixing it with PGPASSWORD="<password>"'
            command = 'PGPASSWORD="%s %s" ' % (engine.url.password, command)

        error = subprocess.call(command, shell=True)
    else:
        print ('Action for driver "%s" is not defined.\n'
               "Note: sqlite3 has a non-standard executescript() method.")
        exit(1)

    if error:
        print 'Process exited with Error: %s' % error
        exit(error)


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = invite
# open with bin/adhocpy

"""manage user invitations"""

import os
import sys
from argparse import ArgumentParser

import formencode
from paste.deploy import appconfig
import pylons
from pylons.i18n.translation import _get_translator

from adhocracy.config.environment import load_environment
from adhocracy.model import meta, Instance, User, UserBadge, UserBadges

from adhocracy.lib.user_import import user_import
from adhocracy.forms.common import UsersCSV, ContainsEMailPlaceholders


def load_config(filename):
    conf = appconfig('config:' + os.path.abspath(filename) + '#content')
    config = load_environment(conf.global_conf, conf.local_conf)
    pylons.config.update(config)
    translator = _get_translator(pylons.config.get('lang'))
    pylons.translator._push_object(translator)


def parse_args():
    parser = ArgumentParser(description=__doc__)
    parser.add_argument('conf_file', help=u'configuration to use')
    parser.add_argument('-b', '--badge', default=u'invited', help=u'badge'
                        u' (title or id) which is used to mark invited users')
    parser.add_argument('-i', '--instance', default=None)
    subparsers = parser.add_subparsers()

    invite_parser = subparsers.add_parser('invite', help=u'invite new users'
                                          u' to adhocracy')
    invite_parser.add_argument('csv_file', help=u'csv files of users to add')
    invite_parser.add_argument('template', help=u'text file with mail body')
    invite_parser.add_argument('-s', '--subject',
                               default=u"Welcome to Adhocracy!",
                               help=u'email subject')
    invite_parser.set_defaults(action=u'invite')

    reinvite_parser = subparsers.add_parser(
        'reinvite', help=u'invite again all users who have not yet activated'
        u' their accounts')
    reinvite_parser.add_argument('template', help=u'text file with mail body')
    reinvite_parser.add_argument('-s', '--subject',
                                 default=u"Welcome to Adhocracy!",
                                 help=u'email subject')
    reinvite_parser.set_defaults(action=u'reinvite')

    revoke_parser = subparsers.add_parser(
        'revoke', help=u'revoke invitation for all users who have not'
                       u' activated their accounts after invitation')
    revoke_parser.set_defaults(action=u'revoke')

    uninvite_parser = subparsers.add_parser(
        'uninvite', help=u'remove "invited"-badge from given users')
    uninvite_parser.add_argument('users', metavar='user', nargs='+')
    uninvite_parser.add_argument(
        '-r', '--revoke', action='store_true', help=u'also revoke invitation'
        u' if not already activated')
    uninvite_parser.set_defaults(action=u'uninvite')

    return parser.parse_args()


def invited_users(invited_badge, instance=None, joined=None, activated=None):
    """get all invited users

    joined/activated may be one of the following:

    -   True  - return only those invited users who have joined the instance/
                activated their accounts
    -   False - return only those invited users who have not joined the
                instance/activated their accounts
    -   None  - return all invited users
    """
    if instance is None and joined is not None:
        raise Exception('instance must not be None if joined specified')
    if joined is True:
        q = User.all_q(instance=instance)
    else:
        q = User.all_q(instance=None)
    q = q.join(UserBadges, UserBadges.user_id == User.id) \
         .filter(UserBadges.badge_id == invited_badge.id)
    users = q.all()
    if joined is False:
        users = filter(lambda u: instance not in u.instances, users)
    if activated is not None:
        users = filter(lambda u: u.is_email_activated() == activated, users)
    return users


def revoke(user):
    if len(user.instances) == 0:
        user.delete()
        print(u"revoked invitation for user %s" % user.user_name)
    else:
        print(u"did not revoke invitation for user %s: is member in"
              u" other instances" % user.user_name)


def uninvite(user, invited_badge, revoke=False):
    if invited_badge in user.badges:
        user.badges.remove(invited_badge)
        print(u"uninvited user %s" % user.user_name)
        if revoke:
            revoke(user)
    else:
        print(u"%s was not invited" % user.user_name)


def valid_instance(name):
    instance = Instance.find(name)
    if instance is None:
        print(u"Invalid instance: %s" % name)
        sys.exit(1)
    else:
        return instance


def valid_userbadge(title, instance=None):
    invited_badge = UserBadge.find_by_instance(title, instance)
    if invited_badge is None:
        invited_badge = UserBadge.create(title, u'#000000', False,
                                         u'This user has been invited',
                                         instance=instance)
        print(u"Badge %r created" % invited_badge)
    return invited_badge


def valid_template(filename):
    template_file = open(filename)
    template_string = template_file.read().decode('utf-8')
    template_file.close()
    template_validator = ContainsEMailPlaceholders(not_empty=True)
    try:
        return template_validator.to_python(template_string)
    except formencode.Invalid as e:
        print u"Invalid template: %s" % unicode(e.msg).replace('<br />', '\n')
        sys.exit(1)


def valid_csv(filename):
    csv_file = open(filename)
    csv_string = csv_file.read().decode('utf-8')
    csv_file.close()
    csv_validator = UsersCSV()
    try:
        return csv_validator.to_python(csv_string, None)
    except formencode.Invalid as e:
        print u"Invalid csv: %s" % unicode(e.msg).replace('<br />', '\n')
        sys.exit(1)


def print_invite_result(data, reinvite=False):
    if len(data['users']) != 0:
        for user in data['users']:
            if user.user_name in data['not_created'] or \
               user.user_name in data['not_mailed']:
                print(u"Errors while %sinviting user %s:" %
                      (u're' if reinvite else u'', user.user_name))
                if user.user_name in data['not_created']:
                    print(u"    not created")
                if user.user_name in data['not_mailed']:
                    print(u"    not mailed")
            else:
                print(u"%sinvited user %s" %
                      (u're' if reinvite else u'', user.user_name))
    else:
        print(u"No users to reinvite")


def main():
    args = parse_args()
    load_config(args.conf_file)

    if args.instance is None:
        instance = None
    else:
        instance = valid_instance(args.instance)
    invited_badge = valid_userbadge(args.badge.decode('utf-8'), instance)
    creator = User.find(u'admin')

    if args.action == u'invite':
        template = valid_template(args.template)
        csv_data = valid_csv(args.csv_file)
        for user_info in csv_data:
            user_info[u'user_badges'].add(invited_badge)

        ret = user_import(csv_data, args.subject, template, creator, instance)
        print_invite_result(ret)
    elif args.action == u'reinvite':
        template = valid_template(args.template)

        users = invited_users(invited_badge, activated=False)
        csv_data = [{
                    u'email': u.email,
                    u'user_name': u.user_name,
                    u'display_name': u.display_name,
                    u'user_badges': set(),
                    } for u in users]

        ret = user_import(csv_data, args.subject, template, creator, instance,
                          reinvite=True)
        print_invite_result(ret, reinvite=True)
    elif args.action == u'revoke':
        users = invited_users(invited_badge, activated=False)
        if len(users) != 0:
            for user in users:
                revoke(user)
        else:
            print(u"No users to revoke")
    elif args.action == u'uninvite':
        if len(args.users) != 0:
            for name in args.users:
                user = User.find(name)
                uninvite(user, invited_badge, revoke=args.revoke)
        else:
            print(u"No users to uninvite")

    meta.Session.commit()


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = list_userdata
#!/usr/bin/env python
"""
List data of existing users. The default template lists the username
and email address.
"""
from datetime import datetime

from sqlalchemy import and_, or_

from adhocracy.model import Membership, User

# boilerplate code. copy that
import os
import sys
sys.path.insert(0,  os.path.abspath(os.path.dirname(__file__)))
from common import create_parser, get_instances, load_from_args
# /end boilerplate code

section = 'content'
template = u"{name} <{email}>"
user_info_attrs = ['id',
                   'name',
                   'display_name',
                   'user_name',
                   'email',
                   'locale',
                   'email_priority',
                   'create_time',
                   ]
possible_attrs = ', '.join(user_info_attrs)


def main():
    parser = create_parser(description=__doc__)
    parser.add_argument(
        "-t", dest="template", default=template, type=unicode,
        help=("The template to use. "
              "(default: '%s', possible keys: %s)" % (template,
                                                      possible_attrs)))
    args = parser.parse_args()
    load_from_args(args)
    instances = get_instances(args)

    query = User.all_q()

    if instances is not None:
        instance_ids = [instance.id for instance in instances]
        query = query.filter(User.memberships.any(
            and_(Membership.instance_id.in_(instance_ids),
                 or_(Membership.expire_time == None,  # noqa
                     Membership.expire_time > datetime.utcnow()))))

    for user in query:
        userinfo = user_info(user)
        s = args.template.format(**userinfo)
        print s.encode('utf-8')


def user_info(user):
    info = dict([(attr, getattr(user, attr)) for attr in user_info_attrs])
    return info


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = make_user_admin
#!/usr/bin/env python
"""
Extract email adresses from adhocracy. Emails from deleted users won't be
exported.
"""
from datetime import datetime

from sqlalchemy import and_, or_

from adhocracy.model import Group, Membership, meta, User

# boilerplate code. copy that
import os
import sys
sys.path.insert(0,  os.path.abspath(os.path.dirname(__file__)))
from common import create_parser, get_instances, load_from_args
# /end boilerplate code


def main():
    parser = create_parser(description=__doc__, use_instance=False)
    parser.add_argument(
        "username",
        help=("The name of the user who should become a global admin"))
    args = parser.parse_args()
    load_from_args(args)

    user = User.find(args.username)
    if user is None:
        print 'Cannot find user %s\n' % args.username
        parser.exit()

    global_membership = [membership for membership in user.memberships if
                         membership.instance is None][0]
    admin_group = Group.by_code(Group.CODE_ADMIN)
    global_membership.group = admin_group
    meta.Session.commit()
if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = merge_instance
# open with bin/adhocpy

"""Move all contents of on instance into another one."""

import os
import sys
from argparse import ArgumentParser

from paste.deploy import appconfig
import pylons
from pylons.i18n.translation import _get_translator

from adhocracy.config.environment import load_environment
from adhocracy import model


def load_config(filename):
    conf = appconfig('config:' + os.path.abspath(filename) + '#content')
    config = load_environment(conf.global_conf, conf.local_conf)
    pylons.config.update(config)
    translator = _get_translator(pylons.config.get('lang'))
    pylons.translator._push_object(translator)


def parse_args():
    parser = ArgumentParser(description=__doc__)

    parser.add_argument('--conf_file', '-c', help=u'configuration to use')
    parser.add_argument('src_instance',
                        help=u'move objects from this instance')
    parser.add_argument('trgt_instance', help=u'move objects to this instance')

    return parser.parse_args()


def merge(i1, i2):
    # merge objects
    tables = [
        model.badge_table,
        model.delegateable_table,
        model.event_table,
        model.message_table,
        model.milestone_table,
        model.votedetail_table,
    ]
    for t in tables:
        print(u"merging %s" % t.name)
        stmt = t.update()\
            .where(t.c.instance_id == i1.id)\
            .values(instance_id=i2.id)
        model.meta.Session.execute(stmt)

    # merge members
    print(u"merging membership")
    memberships = model.Membership.all_q()\
        .filter(model.Membership.instance == i1).all()
    for m in memberships:
        if m.user.instance_membership(i2) is None:
            m.instance = i2
            model.meta.Session.add(m)

    model.meta.Session.commit()


def main():
    args = parse_args()
    load_config(args.conf_file)

    i1 = model.Instance.find(args.src_instance)
    if i1 is None:
        print(u"Could not find source instance %s" % args.src_instance)
        return 1

    i2 = model.Instance.find(args.trgt_instance)
    if i2 is None:
        print(u"Could not find target instance %s" % args.trgt_instance)
        return 1

    return merge(i1, i2)

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = mostcommentedproposal
#!/usr/bin/env python
"""
List the Proposals in an instance sorted by the number of comments.
"""

from adhocracy.model import Proposal

# boilerplate code. copy that
import os
import sys
sys.path.insert(0,  os.path.abspath(os.path.dirname(__file__)))
from common import create_parser, get_instances, load_from_args
# /end boilerplate code


def main():
    parser = create_parser(description=__doc__)
    args = parser.parse_args()
    load_from_args(args)
    instances = get_instances(args)

    for instance in instances:
        proposals = Proposal.all_q(instance=instance)
        proposals = sorted(proposals, key=lambda x: x.comment_count(),
                           reverse=True)

        print instance.label
        for proposal in proposals:
            print "%s: %s" % (proposal.comment_count(), proposal.title)

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = randomize_usernames
"""
This script randomizes all user ids by using the
adhocracy.lib.util.random_username function.

Run from within a paster environment.
"""

import sys

from sqlalchemy import not_

from adhocracy.model import meta
from adhocracy.model.user import User
from adhocracy.lib.util import random_username


EXCLUDED_USERNAMES = ['admin', 'nidi']
SET_DISPLAY_NAMES = True


def main():
    users = User.all_q(include_deleted=None)\
        .filter(not_(User.user_name.in_(EXCLUDED_USERNAMES))).all()

    for user in users:
        user_name = None
        while user_name is None:
            try_user_name = random_username()
            if User.find(try_user_name) is None:
                user_name = try_user_name
        if SET_DISPLAY_NAMES and user.display_name is None:
            user.display_name = user.user_name
        user.user_name = user_name
        meta.Session.flush()

    meta.Session.commit()


if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = replay_notifications
#!/usr/bin/env python
"""
Replay all events in order to create Notification entries to the database which
do not exist yet.
"""

# boilerplate code. copy that
import os
import sys
from argparse import ArgumentParser
sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))
# /end boilerplate code

from paste.deploy import appconfig
import pylons
from pylons.i18n.translation import _get_translator

from adhocracy.config.environment import load_environment
from adhocracy.lib.event.notification import notify
from adhocracy.model import meta, Event


def load_config(filename):
    conf = appconfig('config:' + os.path.abspath(filename) + '#content')
    load_environment(conf.global_conf, conf.local_conf)
    translator = _get_translator(pylons.config.get('lang'))
    pylons.translator._push_object(translator)


def parse_args():
    parser = ArgumentParser(description=__doc__)
    parser.add_argument("conf_file", help="configuration to use")
    return parser.parse_args()


def main():
    args = parse_args()
    load_config(args.conf_file)
    all_events = meta.Session.query(Event).all()

    for event in all_events:
        notify(event, database_only=True)

    meta.Session.commit()

if __name__ == '__main__':
    sys.exit(main())

########NEW FILE########
__FILENAME__ = version
# -*- coding: utf-8 -*-
# Author: Douglas Creager <dcreager@dcreager.net>
# This file is placed into the public domain.

# Calculates the current version number.  If possible, this is the
# output of git describe, modified to conform to the versioning
# scheme that setuptools uses.  If git describe returns an error
# (most likely because we're in an unpacked copy of a release tarball,
# rather than in a git working copy), then we fall back on reading the
# contents of the RELEASE-VERSION file.
#
# To use this script, simply import it your setup.py file, and use the
# results of get_git_version() as your package version:
#
# from version import *
#
# setup(
#     version=get_git_version(),
#     .
#     .
#     .
# )
#
# This will automatically update the RELEASE-VERSION file, if
# necessary.  Note that the RELEASE-VERSION file should *not* be
# checked into git; please add it to your top-level .gitignore file.
#
# You'll probably want to distribute the RELEASE-VERSION file in your
# sdist tarballs; to do this, just create a MANIFEST.in file that
# contains the following line:
#
#   include RELEASE-VERSION

__all__ = ("get_git_version")

from subprocess import Popen, PIPE


def call_git_describe():
    try:
        p = Popen(['git', 'describe', '--always', '--tags'],
                  stdout=PIPE, stderr=PIPE)
        p.stderr.close()
        line = p.stdout.readline()
        p.stdout.flush()
        return line.strip()

    except:
        return None


def read_release_version():
    try:
        f = open("RELEASE-VERSION", "r")

        try:
            version = f.readlines()[0]
            return version.strip()

        finally:
            f.close()

    except:
        return None


def write_release_version(version):
    f = open("RELEASE-VERSION", "w")
    f.write("%s\n" % version)
    f.close()


def test():
    return "D"


def get_git_version():
    # Read in the version that's currently in RELEASE-VERSION.
    release_version = read_release_version()

    # First try to get the current version using git describe.

    version = call_git_describe()

    # If that doesn't work, fall back on the value that's in
    # RELEASE-VERSION.

    if version is None:
        version = release_version

    # If we still don't have anything, that's an error.

    if version is None:
        raise ValueError("Cannot find the version number!")

    # If the current version is different from what's in the
    # RELEASE-VERSION file, update the file to be current.

    if version != release_version:
        write_release_version(version)

    # Finally, return the current version.

    return version


if __name__ == "__main__":
    print get_git_version()

########NEW FILE########
__FILENAME__ = watching_testrunnter
#!/usr/bin/env python

import glob
import os
import sys
import time


class FileWatcher(object):
    def __init__(self, basepath, watch_wildcard):
        self.basepath = basepath
        self.wildcard = watch_wildcard
        self.existing_files = {}
    
    def file_did_change(self, filename):
        change_detected = False
        
        current_mtime = os.path.getmtime(filename)
        if filename in self.existing_files:
            known_mtime = self.existing_files[filename]
            if known_mtime < current_mtime:
                change_detected = True
        else:
            # TODO: Currently there is no handling of deleted files.
            change_detected = True
        self.existing_files[filename] = current_mtime
        return change_detected
    
    def _check_for_file_changes_in_dir(self, topdir):
        change_detected = False
        filenames = glob.glob(os.path.join(topdir, self.wildcard))
        for filename in filenames:
            if self.file_did_change(filename):
                change_detected = True
        return change_detected
    
    def _check_for_changes_in_subdirs(self, topdir):
        change_detected = False
        for item in os.listdir(topdir):
            itemname = os.path.join(topdir, item)
            if os.path.isdir(itemname):
                change_in_subdirectory = self.did_files_change(itemname)
                if change_in_subdirectory == True:
                    change_detected = True
        return change_detected
    
    def did_files_change(self, topdir=None):
        if topdir is None:
            topdir = self.basepath
        file_changed = self._check_for_file_changes_in_dir(topdir)
        subdir_changed = self._check_for_changes_in_subdirs(topdir)
        return (file_changed or subdir_changed)
    

class Command(object):
    def __init__(self, cmd):
        self.cmd = cmd
    
    def execute(self):
        os.system(self.cmd)


def main(argv):
    if len(argv) == 1 or len(argv) > 4:
        sys.exit('usage: %s command [basepath [watch_wildcard]]' % os.path.basename(argv[0]))
    shell_command = argv[1]
    basepath = '.'
    watch_wildcard = '*.py'
    if len(argv) > 2:
        basepath = argv[2]
    if len(argv) > 3:
        watch_wildcard = argv[3]
    command = Command(shell_command)
    watcher = FileWatcher(basepath, watch_wildcard)
    while True:
        if watcher.did_files_change():
            command.execute()
            print " -- done --"
        time.sleep(1)


if __name__ == '__main__':
    main(sys.argv)

########NEW FILE########
__FILENAME__ = env
from __future__ import with_statement
from alembic import context
from sqlalchemy import engine_from_config, pool
from logging.config import fileConfig

from adhocracy.model.meta import data

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)

# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
target_metadata = data

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(url=url)

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(
        config.get_section(config.config_ini_section),
        prefix='sqlalchemy.',
        poolclass=pool.NullPool)

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()

if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

########NEW FILE########
__FILENAME__ = 27af318320bd_add_page_abstract
"""Add page abstract

Revision ID: 27af318320bd
Revises: None
Create Date: 2014-02-27 19:33:58.700529

"""

# revision identifiers, used by Alembic.
revision = '27af318320bd'
down_revision = None

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('page', sa.Column('abstract', sa.Unicode(length=255),
                                    nullable=True))


def downgrade():
    op.drop_column('page', 'abstract')

########NEW FILE########
__FILENAME__ = 3bbf46ecc286_add_instance_theme
"""empty message

Revision ID: 3bbf46ecc286
Revises: 27af318320bd
Create Date: 2014-03-10 16:56:37.528652

"""

# revision identifiers, used by Alembic.
revision = '3bbf46ecc286'
down_revision = '27af318320bd'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('instance', sa.Column('theme', sa.Unicode(), nullable=True))


def downgrade():
    op.drop_column('instance', 'theme')

########NEW FILE########
__FILENAME__ = 486aab29697a_added_velruse_table
"""Added velruse table

Revision ID: 486aab29697a
Revises: 60dd2bc41b
Create Date: 2014-03-11 10:58:58.788954

"""

# revision identifiers, used by Alembic.
revision = '486aab29697a'
down_revision = '60dd2bc41b'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.create_table(
        'velruse',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('create_time', sa.DateTime(), nullable=True),
        sa.Column('delete_time', sa.DateTime(), nullable=True),
        sa.Column('domain', sa.Unicode(length=255), nullable=False),
        sa.Column('domain_user', sa.Unicode(length=255), nullable=False),
        sa.Column('user_id', sa.Integer(), nullable=False),
        sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('domain', 'domain_user',
                            name='unique_velruse_user')
    )
    op.create_index('ix_velruse_domain', 'velruse', ['domain'],
                    unique=False)
    op.create_index('ix_velruse_domain_user', 'velruse', ['domain_user'],
                    unique=False)


def downgrade():
    op.drop_index('ix_velruse_domain_user', table_name='velruse')
    op.drop_index('ix_velruse_domain', table_name='velruse')
    op.drop_table('velruse')

########NEW FILE########
__FILENAME__ = 60dd2bc41b_simplify_message
"""simplify_message

Revision ID: 60dd2bc41b
Revises: 79808779aa1
Create Date: 2014-02-04 21:35:56.943445

"""

# revision identifiers, used by Alembic.
revision = '60dd2bc41b'
down_revision = '79808779aa1'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('message', sa.Column('instance_id', sa.INTEGER(),
                                       nullable=True))
    op.alter_column('message', 'sender_email', nullable=True)


def downgrade():
    op.alter_column('message', 'sender_email', nullable=False)
    op.drop_column('message', 'instance_id')

########NEW FILE########
__FILENAME__ = 79808779aa1_add_logo_as_background
"""add_logo_as_background

Revision ID: 79808779aa1
Revises: 3bbf46ecc286
Create Date: 2014-03-11 14:29:26.115844

"""

# revision identifiers, used by Alembic.
revision = '79808779aa1'
down_revision = '3bbf46ecc286'

from alembic import op
import sqlalchemy as sa


def upgrade():
    op.add_column('instance', sa.Column('logo_as_background', sa.Boolean(),
                  nullable=True))


def downgrade():
    op.drop_column('instance', 'logo_as_background')

########NEW FILE########
__FILENAME__ = client
#!/usr/bin/python
#
# Python REST client library.

__version__ = '0.1'
__description__ = 'The Adhocracy client python package.'
__license__ = 'BSD'

import base64
import json
import logging
import urllib
import urllib2


log = logging.getLogger('adhocracyclient')


class RequestWithMethod(urllib2.Request):

    def __init__(self, method, *args, **kwargs):
        self._method = method
        urllib2.Request.__init__(self, *args, **kwargs)

    def get_method(self):
        return self._method


class AdhocracyClient(object):
    """ Example implementation of a REST client for Adhocracy. """

    base_location = 'http://adhocracy.lan:5000'

    def __init__(self, base_location=None, user=None,
                 password=None, instance=None):
        if base_location is not None:
            self.base_location = base_location
        self.user = user
        self.password = password
        self.instance = None
        if instance:
            self._select(instance)

    def reset(self):
        self.last_status = None
        self.last_body = None
        self.last_headers = None
        self.last_message = None
        self.last_http_error = None
        self.last_url_error = None

    def open_url(self, location, method='GET', data=None, headers={}):
        try:
            if data is not None:
                data = urllib.urlencode(data)

            req = RequestWithMethod(method, location, data, headers)

            if self.user is not None and self.password is not None:
                auth = base64.encodestring('%s:%s' % (self.user,
                                                      self.password))
                auth = "Basic %s" % auth
                req.add_header("Authorization", auth)

            self.url_response = urllib2.urlopen(req)
        except urllib2.HTTPError, inst:
            log.debug("adhocracyclient: Received HTTP error code from "
                      "Adhocracy.")
            log.debug("adhocracyclient: location: %s" % location)
            log.debug("adhocracyclient: response code: %s" % inst.fp.code)
            log.debug("adhocracyclient: request headers: %s" % headers)
            log.debug("adhocracyclient: request data: %s" % data)
            self.last_http_error = inst
            self.last_status = inst.code
            self.last_message = inst.read()
        except urllib2.URLError, inst:
            self.last_url_error = inst
            self.last_status, self.last_message = inst.reason
        else:
            log.debug("adhocracyclient: OK opening Adhocracy resource: %s" %
                      location)
            self.last_status = self.url_response.code
            self.last_body = self.url_response.read()
            self.last_headers = self.url_response.headers
            try:
                self.last_message = self.__loadstr(self.last_body)
            except ValueError:
                pass

    def get_location(self, resource_name, entity_id=None,
                     variant=None, member=None, format='json'):
        base = self.base_location
        if self.instance is not None:
            base = self.instance.get('instance_url')
        path = resource_name
        if entity_id is not None:
            path += '/' + str(entity_id)
        if variant is not None:
            path += '/' + variant
        if member is not None:
            path += '/' + member
        url = base + '/' + path
        if format is not None:
            url = url + '.json'
        log.debug("adhocracyclient: request url: %s" % url)
        return url

    def _select(self, key):
        self.instance = self.instance_get(key)

    def instance_index(self):
        self.reset()
        url = self.get_location('instance')
        self.open_url(url)
        return self.last_message

    def instance_get(self, key):
        self.reset()
        url = self.get_location('instance', entity_id=key)
        self.open_url(url)
        return self.last_message

    def proposal_index(self):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('proposal')
        self.open_url(url)
        return self.last_message

    def proposal_get(self, id):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('proposal', entity_id=id)
        self.open_url(url)
        return self.last_message

    def proposal_create(self, proposal):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('proposal', format=None)
        self.open_url(url, method='POST', data=proposal)
        return self.last_message

    def proposal_update(self, proposal):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('proposal', entity_id=proposal.get('id'),
                                format=None)
        self.open_url(url, method='PUT', data=proposal)
        return self.last_message

    def proposal_delete(self, id):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('proposal', entity_id=id)
        self.open_url(url, method='DELETE')
        return self.last_message

    def page_index(self):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('page')
        self.open_url(url)
        return self.last_message

    def page_history(self, id, variant):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('page', entity_id=id, variant=variant,
                                member='history')
        self.open_url(url)
        return self.last_message

    def page_get(self, id, variant=None):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('page', entity_id=id, variant=variant,
                                format='json')
        self.open_url(url)
        return self.last_message

    def page_create(self, page):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('page', format=None)
        self.open_url(url, method='POST', data=page)
        return self.last_message

    def page_update(self, page, variant=None):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('page', entity_id=page.get('id'),
                                variant=variant, format=None)
        self.open_url(url, method='PUT', data=page)
        return self.last_message

    def page_delete(self, id):
        if self.instance is None:
            raise ValueError("No instance is set")
        self.reset()
        url = self.get_location('page', entity_id=id)
        self.open_url(url, method='DELETE')
        return self.last_message

    # def package_register_get(self):
    #     self.reset()
    #     url = self.get_location('Package Register')
    #     self.open_url(url)
    #     return self.last_message
    #
    # def package_register_post(self, package_dict):
    #     self.reset()
    #     url = self.get_location('Package Register')
    #     data = self.__dumpstr(package_dict)
    #     headers = {'Authorization': self.api_key}
    #     self.open_url(url, data, headers)
    #
    # def package_search(self, q, search_options={}):
    #     self.reset()
    #     url = self.get_location('Package Search')
    #     search_options['q'] = q
    #     data = self.__dumpstr(search_options)
    #     headers = {'Authorization': self.api_key}
    #     self.open_url(url, data, headers)
    #     return self.last_message

    def __dumpstr(self, data):
        return json.dumps(data)

    def __loadstr(self, string):
        return json.loads(string)


# test_prop = {
#     "label": "foo schnasel",
#     "text": "this is an API test foo schnasel",
#     "tags": "tag, tag2, tag3"
# }


# test = AdhocracyClient('http://adhocracy.lan:5000', user='admin',
#                         password='password', instance='schnasel')

########NEW FILE########
__FILENAME__ = environment
"""Pylons environment configuration"""
import os
import time
import sys
import traceback

from mako.lookup import TemplateLookup
from paste.deploy.converters import asbool
from pylons import tmpl_context as c
from pylons.error import handle_mako_error
from pylons.configuration import PylonsConfig
from sqlalchemy import engine_from_config
from sqlalchemy.interfaces import ConnectionProxy

import adhocracy.lib.app_globals as app_globals
import adhocracy.lib.helpers
from adhocracy.config.routing import make_map
from adhocracy.model import init_model
from adhocracy.lib.search import init_search
from adhocracy.lib.democracy import init_democracy
from adhocracy.lib.util import create_site_subdirectory
from adhocracy.lib import init_site
from adhocracy.lib.queue import RQConfig


def load_environment(global_conf, app_conf, with_db=True):
    """Configure the Pylons environment via the ``pylons.config``
    object
    """
    # Pylons paths
    conf_copy = global_conf.copy()
    conf_copy.update(app_conf)
    site_templates = create_site_subdirectory('templates', app_conf=conf_copy)
    root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
    client_containing = app_conf.get('adhocracy.client_location')
    if client_containing:
        client_root = os.path.join(client_containing, 'adhocracy_client')
        sys.path.insert(0, client_containing)
        import adhocracy_client.static
        sys.modules['adhocracy.static'] = adhocracy_client.static
    else:
        client_root = root
    import adhocracy.static
    paths = dict(root=root,
                 controllers=os.path.join(root, 'controllers'),
                 static_files=os.path.join(client_root, 'static'),
                 templates=[site_templates,
                            os.path.join(client_root, 'templates')])

    # Initialize config with the basic options
    config = PylonsConfig()

    config.init_app(global_conf, app_conf, package='adhocracy', paths=paths)

    config['routes.map'] = make_map(config)
    config['pylons.app_globals'] = app_globals.Globals(config)
    config['pylons.h'] = adhocracy.lib.helpers

    # Create the Mako TemplateLookup, with the default auto-escaping
    config['pylons.app_globals'].mako_lookup = TemplateLookup(
        directories=paths['templates'],
        error_handler=handle_mako_error,
        module_directory=os.path.join(app_conf['cache_dir'], 'templates'),
        input_encoding='utf-8', default_filters=['escape'],
        imports=['from markupsafe import escape'])

    config['pylons.strict_tmpl_context'] = False

    # Setup the SQLAlchemy database engine
    engineOpts = {}
    if asbool(config.get('adhocracy.debug.sql', False)):
        engineOpts['connectionproxy'] = TimerProxy()

    engine = engine_from_config(config, 'sqlalchemy.', **engineOpts)
    init_model(engine)

    # CONFIGURATION OPTIONS HERE (note: all config options will override
    # any Pylons config options)
    init_site(config)
    if with_db:
        init_search()
    init_democracy()
    RQConfig.setup_from_config(config)

    return config


class TimerProxy(ConnectionProxy):
    '''
    A timing proxy with code borrowed from spline and
    pyramid_debugtoolbar. This will work for sqlalchemy 0.6,
    but not 0.7. pyramid_debugtoolbar works for 0.7.
    '''

    def cursor_execute(self, execute, cursor, statement, parameters, context,
                       executemany):
        start_time = time.time()

        try:
            return execute(cursor, statement, parameters, context)
        finally:
            duration = time.time() - start_time

            # Find who spawned this query.  Rewind up the stack until we
            # escape from sqlalchemy code -- including this file, which
            # contains proxy stuff
            caller = '(unknown)'
            for frame_file, frame_line, frame_func, frame_code in \
                    reversed(traceback.extract_stack()):

                if __file__.startswith(frame_file) \
                        or '/sqlalchemy/' in frame_file:

                    continue

                # OK, this is it
                caller = "{0}:{1} in {2}".format(
                    frame_file, frame_line, frame_func)
                break

            # save interesting information for presentation later
            try:
                if not c.pdtb_sqla_queries:
                    c.pdtb_sqla_queries = []
                queries = c.pdtb_sqla_queries
                query_data = {
                    'duration': duration,
                    'statement': statement,
                    'parameters': parameters,
                    'context': context,
                    'caller': caller,
                }
                queries.append(query_data)
            except TypeError:
                # happens when sql is emitted before pylons has started
                # or outside of a request
                pass

########NEW FILE########
__FILENAME__ = middleware
"""Pylons middleware initialization"""
import beaker.middleware
from fanstatic import Fanstatic
from paste.cascade import Cascade
from paste.registry import RegistryManager
from paste.urlparser import StaticURLParser
from paste.deploy.converters import asbool
from paste.deploy.config import make_prefix_middleware
from pylons.middleware import ErrorHandler, StatusCodeRedirect
from pylons.wsgiapp import PylonsApp
from routes.middleware import RoutesMiddleware

from adhocracy.lib.auth.authentication import setup_auth
from adhocracy.lib.cors import CorsMiddleware
from adhocracy.lib.instance import setup_discriminator
from adhocracy.lib.machine_name import IncludeMachineName
from adhocracy.lib.util import get_site_path
from adhocracy.config.environment import load_environment
from adhocracy.lib.requestlog import RequestLogger
from adhocracy.lib.helpers.site_helper import base_url
from adhocracy.lib.session import CookieSessionMiddleware


def make_app(global_conf, full_stack=True, static_files=True, **app_conf):
    """Create a Pylons WSGI application and return it

    ``global_conf``
        The inherited configuration for this application. Normally from
        the [DEFAULT] section of the Paste ini file.

    ``full_stack``
        Whether this application provides a full WSGI stack (by default,
        meaning it handles its own exceptions and errors). Disable
        full_stack when this application is "managed" by another WSGI
        middleware.

    ``static_files``
        Whether this application serves its own static files; disable
        when another web server is responsible for serving them.

    ``app_conf``
        The application's local configuration. Normally specified in
        the [app:<name>] section of the Paste ini file (where <name>
        defaults to main).

    """

    debug = (asbool(global_conf.get('debug', False)) or
             asbool(app_conf.get('debug', False)))

    # Configure the Pylons environment
    config = load_environment(global_conf, app_conf)

    # The Pylons WSGI app
    app = PylonsApp(config=config)

    if debug and asbool(app_conf.get('adhocracy.enable_profiling', False)):
        from werkzeug.contrib.profiler import ProfilerMiddleware
        app = ProfilerMiddleware(app, sort_by=('ncalls',),
                                 restrictions=('src/adhocracy/.*', 25))

    # Routing/Session/Cache Middleware
    app = RoutesMiddleware(app, config['routes.map'])
    if config.get('adhocracy.session.implementation', 'beaker') == 'cookie':
        app = CookieSessionMiddleware(app, config)
    else:
        app = beaker.middleware.SessionMiddleware(app, config)
        app = beaker.middleware.CacheMiddleware(app, config)

    # app = make_profile_middleware(app, config, log_filename='profile.log.tmp')

    # CUSTOM MIDDLEWARE HERE (filtered by error handling middlewares)
    app = setup_auth(app, config)
    app = make_prefix_middleware(app, config,
                                 scheme=config.get('adhocracy.protocol',
                                                   'http'))
    app = setup_discriminator(app, config)
    if asbool(config.get('adhocracy.requestlog_active', 'False')):
        app = RequestLogger(app, config)

    if asbool(full_stack):
        # Handle Python exceptions
        app = ErrorHandler(app, global_conf, **config['pylons.errorware'])

    # Display error documents for 401, 403, 404 status codes
    app = StatusCodeRedirect(app, [400, 401, 403, 404, 500])

    # Establish the Registry for this application
    app = RegistryManager(app)

    if asbool(static_files):
        cache_age = int(config.get('adhocracy.static.age', 7200))
        # Serve static files
        overlay_app = StaticURLParser(
            get_site_path('static', app_conf=config),
            cache_max_age=None if debug else cache_age)
        static_app = StaticURLParser(
            config['pylons.paths']['static_files'],
            cache_max_age=None if debug else cache_age)
        app = Cascade([overlay_app, static_app, app])

    # Fanstatic inserts links for javascript and css ressources.
    # The required resources can be specified at runtime with <resource>.need()
    # and can will be delivered with version specifiers in the url and
    # minified when not in debug mode.
    fanstatic_base_url = base_url('', instance=None, config=config).rstrip('/')
    app = Fanstatic(app,
                    minified=not(debug),
                    versioning=True,
                    recompute_hashes=debug,
                    bundle=not(debug),
                    base_url=fanstatic_base_url,
                    bottom=True
                    )

    if asbool(config.get('adhocracy.include_machine_name_in_header', 'false')):
        app = IncludeMachineName(app, config)

    app = CorsMiddleware(app, config)
    app.config = config

    return app

########NEW FILE########
__FILENAME__ = routing
"""Routes configuration

The more specific and detailed routes should be defined first so they
may take precedent over the more generic routes. For more information
refer to the routes manual at http://routes.groovie.org/docs/
"""
from routes import Mapper


def make_map(config):
    """Create, configure and return the routes Mapper"""
    map = Mapper(directory=config['pylons.paths']['controllers'])
    map.minimization = False

    # The ErrorController route (handles 404/500 error pages); it should
    # likely stay at the top, ensuring it can always be resolved
    map.connect('/error/{action}', controller='error')
    map.connect('/error/{action}/{id}', controller='error')

    # CUSTOM ROUTES HERE
    map.connect('/', controller='root', action='index')
    map.connect('/index{.format}', controller='root', action='index')

    map.connect('/openid/{action}', controller='openidauth')
    map.connect('/twitter/{action}', controller='twitteroauth')

    map.connect('/oembed{.format}', controller='oembed', action='oembed',
                conditions=dict(method=['GET']))

    map.connect('/user/all', controller='user',
                action='all', conditions=dict(method=['GET']))
    map.connect('/user/{id}/badges{.format}', controller='user',
                action='edit_badges', conditions=dict(method=['GET']))
    map.connect('/user/{id}/badges{.format}', controller='user',
                action='update_badges', conditions=dict(method=['POST']))
    # Old dashboard
    map.connect('/user/{id}/dashboard', controller='user',
                action='legacy_dashboard')
    map.connect('/user/{id}/dashboard_proposals', controller='user',
                action='legacy_dashboard_proposals')
    map.connect('/user/{id}/dashboard_pages', controller='user',
                action='legacy_dashboard_pages')

    # New event stream dashboard
    map.connect('/user/dashboard', controller='user',
                action='dashboard')
    map.connect('/user/dashboard/contributions', controller='user',
                action='dashboard_contributions')
    map.connect('/user/dashboard/votes', controller='user',
                action='dashboard_votes')
    map.connect('/user/dashboard/delegations', controller='user',
                action='dashboard_delegations')
    map.connect('/user/dashboard/messages', controller='user',
                action='dashboard_messages')
    map.connect('/welcome/{id}/{token}', controller='user',
                action='welcome')

    # avatar
    map.connect('/user/{id}_{x}x{y}.png',
                controller='user', action='avatar')
    map.connect('/user/{id}_{y}.png',
                controller='user', action='avatar')

    map.resource('user', 'user', member={'votes': 'GET',
                                         'delegations': 'GET',
                                         'instances': 'GET',
                                         'about': 'GET',
                                         'latest_events': 'GET',
                                         'latest_contributions': 'GET',
                                         'latest_milestones': 'GET',
                                         'latest_votes': 'GET',
                                         'latest_delegations': 'GET',
                                         'watchlist': 'GET',
                                         'groupmod': 'GET',
                                         'ban': 'GET',
                                         'unban': 'GET',
                                         'ask_delete': 'GET',
                                         'revert': 'GET',
                                         'reset': 'GET',
                                         'activate': 'GET',
                                         'ask_activate': 'GET',
                                         'pending_activate': 'GET',
                                         'resend': 'GET',
                                         'set_password': 'POST',
                                         'generate_welcome_link': 'POST'},
                 collection={'complete': 'GET',
                             'filter': 'GET',
                             # provide user-independent URLs to user settings
                             'redirect_settings': 'GET',
                             'redirect_settings_login': 'GET',
                             'redirect_settings_notifications': 'GET',
                             'redirect_settings_advanced': 'GET',
                             'redirect_settings_optional': 'GET',
                             })

    # TODO work this into a complete subcontroller.
    map.connect('/user/{id}/message.{format}', controller='message',
                action='create',
                conditions=dict(method=['POST', 'PUT']))
    map.connect('/user/{id}/message', controller='message', action='create',
                conditions=dict(method=['POST', 'PUT']))
    map.connect('/user/{id}/message/new.{format}', controller='message',
                action='new',
                conditions=dict(method=['GET']))
    map.connect('/user/{id}/message/new', controller='message', action='new',
                conditions=dict(method=['GET']))
    map.connect('/user/{id}/settings{.format}',
                controller='user', action='settings_personal',
                conditions=dict(method=['GET']))
    map.connect('/user/{id}/settings{.format}',
                controller='user', action='settings_personal_update',
                conditions=dict(method=['PUT']))
    map.connect('/user/{id}/settings/login{.format}',
                controller='user', action='settings_login',
                conditions=dict(method=['GET']))
    map.connect('/user/{id}/settings/login{.format}',
                controller='user', action='settings_login_update',
                conditions=dict(method=['PUT']))
    map.connect('/user/{id}/settings/notifications{.format}',
                controller='user', action='settings_notifications',
                conditions=dict(method=['GET']))
    map.connect('/user/{id}/settings/notifications{.format}',
                controller='user', action='settings_notifications_update',
                conditions=dict(method=['PUT']))
    map.connect('/user/{id}/settings/advanced{.format}',
                controller='user', action='settings_advanced',
                conditions=dict(method=['GET']))
    map.connect('/user/{id}/settings/advanced{.format}',
                controller='user', action='settings_advanced_update',
                conditions=dict(method=['PUT']))
    map.connect('/user/{id}/settings/optional{.format}',
                controller='user', action='settings_optional',
                conditions=dict(method=['GET']))
    map.connect('/user/{id}/settings/optional{.format}',
                controller='user', action='settings_optional_update',
                conditions=dict(method=['PUT']))

    map.connect('/message/new', controller='massmessage', action='new')
    map.connect('/message/preview', controller='massmessage', action='preview')
    map.connect('/message/create', controller='massmessage', action='create')
    map.connect('/message/{id}', controller='message', action='show')

    map.connect('/register', controller='user', action='new')
    map.connect('/login', controller='user', action='login')
    map.connect('/logout', controller='user', action='logout')
    map.connect('/post_logout', controller='user', action='post_logout')
    map.connect('/post_login', controller='user', action='post_login')
    map.connect('/perform_login', controller='user', action='perform_login')
    map.connect('/reset', controller='user', action='reset_form',
                conditions=dict(method=['GET']))
    map.connect('/reset', controller='user', action='reset_request',
                conditions=dict(method=['POST']))

    # map.connect('/proposal/{id}/badges', controller='proposal',
    #             action='badges', conditions=dict(method=['GET']))
    # map.connect('/proposal/{id}/badges', controller='proposal',
    #             action='update_badges', conditions=dict(method=['POST']))

    map.resource('proposal', 'proposal', member={'delegations': 'GET',
                                                 'activity': 'GET',
                                                 'ask_delete': 'GET',
                                                 'ask_adopt': 'GET',
                                                 'adopt': 'POST',
                                                 'badges': 'GET',
                                                 'update_badges': 'POST',
                                                 'comments': 'GET',
                                                 'history': 'GET'},
                 collection={'filter': 'GET'})
    map.connect('/proposal/{proposal_id}/{selection_id}/details{.format}',
                controller='selection',
                action='details')

    map.connect('/proposal/{proposal_id}/message/new{.format}',
                controller='massmessage',
                action='new_proposal', conditions=dict(method=['GET']))
    map.connect('/proposal/{proposal_id}/message{.format}',
                controller='massmessage',
                action='create_proposal', conditions=dict(method=['POST']))

    map.resource('implementation', 'implementation', controller='selection',
                 member={'ask_delete': 'GET'},
                 collection={'include': 'GET',
                             'propose': 'GET'},
                 parent_resource=dict(member_name='proposal',
                                      collection_name='proposal'))

    map.connect('/page/{id}_{x}x{y}.png', controller='page',
                action='logo')
    map.connect('/page/{id}_{y}.png', controller='page',
                action='logo')

    map.connect('/page/diff', controller='page', action='diff',
                conditions=dict(method=['GET']))

    map.connect('/page/{id}/amendment{.format}',
                controller='page',
                action='show', amendment=True,
                conditions=dict(method=['GET']),
                )
    map.connect('/page/{page}/amendment{.format}',
                controller='proposal',
                action='create', amendment=True,
                conditions=dict(method=['POST'])
                )
    map.connect('/page/{page}/amendment/new{.format}',
                controller='proposal',
                action='new', amendment=True,
                conditions=dict(method=['GET']),
                )
    map.connect('/page/{id}/amendment/{variant}{.format}',
                controller='page',
                action='show', amendment=True,
                conditions=dict(method=['GET']),
                )
    map.connect('/page/{page}/amendment/{id}{.format}',
                controller='proposal',
                action='update',
                conditions=dict(method=['PUT'])
                )
    map.connect('/page/{page}/amendment/{id}{.format}',
                controller='proposal',
                action='delete',
                conditions=dict(method=['DELETE'])
                )
    map.connect('/page/{page}/amendment/{id}/edit{.format}',
                controller='proposal',
                action='edit',
                conditions=dict(method=['GET']),
                )
    map.connect('/page/{page}/amendment/{id}/ask_delete{.format}',
                controller='proposal',
                action='ask_delete',
                conditions=dict(method=['GET']),
                )

    map.connect('/page/{id}/{variant}/history{.format}',
                controller='page',
                action='history',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/history{.format}',
                controller='page',
                action='history',
                conditions=dict(method=['GET']),
                )
    map.connect('/page/{id}/comments{.format}',
                controller='page',
                action='comments',
                conditions=dict(method=['GET']),
                )
    map.connect('/page/{id}/{variant}/branch',
                controller='page',
                action='edit',
                branch=True,
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant}/ask_purge',
                controller='page', action='ask_purge',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant}/purge',
                controller='page',
                action='purge',
                conditions=dict(method=['POST', 'DELETE']))
    map.connect('/page/{id};{text}/ask_purge_history',
                controller='page', action='ask_purge_history',
                conditions=dict(method=['GET']))
    map.connect('/page/{id};{text}/purge_history',
                controller='page',
                action='purge_history',
                conditions=dict(method=['POST', 'DELETE']))
    map.connect('/page/{id}/{variant}/edit.{format}',
                controller='page',
                action='edit',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant}/edit', controller='page', action='edit',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/edit.{format}', controller='page', action='edit',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/branch', controller='page', action='edit',
                branch=True,
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/edit', controller='page', action='edit',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/ask_delete{.format}', controller='page',
                action='ask_delete',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant};{text}.{format}', controller='page',
                action='show',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant};{text}/branch', controller='page',
                action='edit', branch=True,
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant};{text}', controller='page',
                action='show',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant}.{format}', controller='page',
                action='show',
                conditions=dict(method=['GET']))
    map.connect('/page/{id}/{variant}', controller='page', action='show',
                conditions=dict(method=['GET']))
    map.connect('/page/{id};{text}.{format}', controller='page', action='show',
                conditions=dict(method=['GET']))
    map.connect('/page/{id};{text}/branch', controller='page', action='edit',
                branch=True,
                conditions=dict(method=['GET']))
    map.connect('/page/{id};{text}', controller='page', action='show',
                conditions=dict(method=['GET']))

    map.resource('page', 'page', member={'ask_delete': 'GET'})

    # map.connect('/adopted', controller='proposal', action='adopted')

    map.resource('comment', 'comment', member={'history': 'GET',
                                               'revert': 'GET',
                                               'purge_history': 'GET',
                                               'ask_delete': 'GET'})

    map.connect('/comment/form/edit/{id}', controller='comment',
                action='edit_form')
    map.connect('/comment/form/create/{topic}', controller='comment',
                action='create_form', variant=None)
    map.connect('/comment/form/reply/{id}', controller='comment',
                action='reply_form')

    map.resource('milestone', 'milestone', member={'ask_delete': 'GET'})

    map.connect('/poll/{id}/rate{.format}', controller='poll', action='rate',
                conditions=dict(method=['GET', 'POST']))

    map.connect('/poll/{id}/widget{.format}', controller='poll',
                action='widget', conditions=dict(method=['GET', 'POST']))

    map.connect('/poll/{id}/vote{.format}', controller='poll', action='vote',
                conditions=dict(method=['GET', 'POST']))

    map.resource('poll', 'poll', member={'votes': 'GET',
                                         'ask_delete': 'GET',
                                         'widget': 'GET'})

    map.connect('/badge{.format}', controller='badge', action='index',
                conditions=dict(method=['GET']))
    map.connect('/badge/{badge_type}{.format}', controller='badge',
                action='index_type', conditions=dict(method=['GET']))
    map.connect('/badge/{badge_type}/add{.format}', controller='badge',
                action='add', conditions=dict(method=['GET']))
    map.connect('/badge/{badge_type}/add{.format}', controller='badge',
                action='create', conditions=dict(method=['POST']))
    map.connect('/badge/edit/{id}{.format}', controller='badge',
                action="edit", conditions=dict(method=['GET']))
    map.connect('/badge/edit/{id}{.format}',
                controller='badge', action="update",
                conditions=dict(method=['POST']))
    map.connect('/badge/delete/{id}{.format}',
                controller='badge', action="ask_delete",
                conditions=dict(method=['GET']))
    map.connect('/badge/delete/{id}{.format}',
                controller='badge', action="delete",
                conditions=dict(method=['POST']))

    # category image
    map.connect('/category/{id}_{x}x{y}.png', controller='category',
                action='image')
    map.connect('/category/{id}_{y}.png', controller='category',
                action='image')

    map.connect('/category{.format}', controller='category', action='index',
                conditions=dict(method=['GET']))
    map.connect('/category/{id}{.format}', controller='category',
                action='show', conditions=dict(method=['GET']))
    map.connect('/category/{id}/description{.format}', controller='category',
                action='description', conditions=dict(method=['GET']))
    map.connect('/category/{id}/events{.format}', controller='category',
                action='events', conditions=dict(method=['GET']))
    map.connect('/category/{id}/milestones{.format}', controller='category',
                action='milestones', conditions=dict(method=['GET']))

    # not using REST since tags may contain dots, thus failing format
    # detection.
    map.connect('/tag', controller='tag', action='index',
                conditions=dict(method=['GET']))
    map.connect('/tag', controller='tag', action='create',
                conditions=dict(method=['POST']))
    map.connect('/tag/autocomplete', controller='tag', action='autocomplete')
    map.connect('/untag', controller='tag', action='untag')
    map.connect('/untag_all', controller='tag', action='untag_all')
    map.connect('/tag/{id}', controller='tag', action='show')

    map.resource('delegation', 'delegation')
    # map.resource('delegations', 'delegation')

    map.connect('/d/{id}', controller='root', action='dispatch_delegateable')
    map.connect('/sitemap.xml', controller='root', action='sitemap_xml')
    map.connect('/robots.txt', controller='root', action='robots_txt')
    map.connect('/feed.rss', controller='root', action='index', format='rss')
    map.connect('/tutorials', controller='root', action='tutorials')

    map.connect('/search/filter', controller='search', action='filter')
    map.connect('/search{.format}', controller='search', action='query')

    map.connect('/abuse/report', controller='abuse', action='report')
    map.connect('/abuse/new', controller='abuse', action='new')

    map.connect('/instance/{id}_{x}x{y}.png',
                controller='instance', action='icon')
    map.connect('/instance/{id}_{y}.png',
                controller='instance', action='icon')
    map.connect('/instance/{id}/settings{.format}',
                controller='instance', action='settings_legacy',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/overview{.format}',
                controller='instance', action='settings_overview',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/overview{.format}',
                controller='instance', action='settings_overview_update',
                conditions=dict(method=['PUT']))
    map.connect('/instance/{id}/settings/general{.format}',
                controller='instance', action='settings_general',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/general{.format}',
                controller='instance', action='settings_general_update',
                conditions=dict(method=['PUT']))
    map.connect('/instance/{id}/settings/process{.format}',
                controller='instance', action='settings_process',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/process{.format}',
                controller='instance', action='settings_process_update',
                conditions=dict(method=['PUT']))
    map.connect('/instance/{id}/settings/members{.format}',
                controller='instance', action='settings_members',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/members{.format}',
                controller='instance', action='settings_members_update',
                conditions=dict(method=['PUT']))
    map.connect('/instance/{id}/settings/advanced{.format}',
                controller='instance', action='settings_advanced',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/advanced{.format}',
                controller='instance', action='settings_advanced_update',
                conditions=dict(method=['PUT']))
    map.connect('/instance/{id}/settings/{part}/{badge_type}/add{.format}',
                controller='instance',
                action='settings_badges_add', conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/{part}/{badge_type}/add{.format}',
                controller='instance',
                action='settings_badges_create',
                conditions=dict(method=['POST']))
    map.connect('/instance/{id}/settings/{part}/edit/{badge_id}{.format}',
                controller='instance',
                action="settings_badges_edit", conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/{part}/edit/{badge_id}{.format}',
                controller='instance', action="settings_badges_update",
                conditions=dict(method=['POST']))
    map.connect('/instance/{id}/settings/{part}/delete/{badge_id}{.format}',
                controller='instance', action="settings_badges_ask_delete",
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/{part}/delete/{badge_id}{.format}',
                controller='instance', action="settings_badges_delete",
                conditions=dict(method=['POST']))
    map.connect('/instance/{id}/message/new{.format}',
                controller='massmessage', action='new',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/message{.format}',
                controller='massmessage', action='create',
                conditions=dict(method=['POST']))
    map.connect('/instance/{id}/message/preview{.format}',
                controller='massmessage', action='preview',
                conditions=dict(method=['POST']))
    map.connect('/instance/{id}/members_import{.format}',
                controller='instance', action='members_import',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/members_import{.format}',
                controller='instance', action='members_import_save',
                conditions=dict(method=['PUT', 'POST']))
    map.connect('/instance/{id}/settings/presets{.format}',
                controller='instance', action='settings_presets',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/settings/presets{.format}',
                controller='instance', action='settings_presets_update',
                conditions=dict(method=['PUT', 'POST']))
    map.connect('/instance/{id}/presets{.format}',
                controller='instance', action='presets',
                conditions=dict(method=['GET']))
    map.connect('/instance/{id}/presets{.format}',
                controller='instance', action='presets_update',
                conditions=dict(method=['POST']))

    map.resource('instance', 'instance', member={'join': 'GET',
                                                 'ask_join': 'GET',
                                                 'leave': 'POST',
                                                 'filter': 'GET',
                                                 'ask_leave': 'GET',
                                                 'ask_delete': 'GET',
                                                 'style': 'GET',
                                                 'badges': 'GET',
                                                 'update_badges': 'POST',
                                                 'activity': 'GET'})

    map.connect('/stats/', controller='stats')

    map.connect('/admin', controller='admin', action="index")
    map.connect('/admin/users/import{.format}', controller='admin',
                action="user_import", conditions=dict(method=['POST']))
    map.connect('/admin/users/import{.format}', controller='admin',
                action="user_import_form", conditions=dict(method=['GET']))
    map.connect('/admin/export',
                controller='admin', action='export_dialog')
    map.connect('/admin/export/do',
                controller='admin', action='export_do')
    map.connect('/admin/import{.format}',
                controller='admin', action='import_dialog')
    map.connect('/admin/import/do',
                controller='admin', action='import_do')
    map.connect('/admin/treatment/',
                controller='treatment', action='index',
                conditions={'method': 'GET'},)
    map.connect('/admin/treatment/',
                controller='treatment', action='create',
                conditions={'method': 'POST'},)
    map.connect('/admin/treatment/{key}/assign',
                controller='treatment', action='assign',
                conditions={'method': 'POST'},)
    map.connect('/admin/treatment/{key}/assigned',
                controller='treatment', action='assigned')

    map.connect('/static{.format}', controller='static', action='index',
                conditions=dict(method=['GET', 'HEAD']))
    map.connect('/static{.format}', controller='static', action='make_new',
                conditions=dict(method=['POST']))
    map.connect('/static/new{.format}', controller='static', action='new')
    map.connect('/static/edit/{lang}/*key',
                controller='static', action='edit',
                conditions=dict(method=['GET', 'HEAD']))
    map.connect('/static/edit/{lang}/*(key){.format}',
                controller='static', action='update',
                conditions=dict(method=['POST']))
    map.connect('/static/*(key){.format}', controller='static',
                action='serve')
    map.connect('/outgoing_link/{url_enc}', controller='redirect',
                action='outgoing_link',
                conditions=dict(method=['GET', 'HEAD']))

    map.connect('/event/all{.format}', controller='event', action='all')
    map.connect('/event/carousel{.format}', controller='event',
                action='carousel')

    map.connect('/{controller}/{action}')
    map.connect('/{controller}/{action}/{id}')

    return map

########NEW FILE########
__FILENAME__ = conftest
import os
import sys
import pkg_resources
from paste.deploy import loadapp
import pylons
import pylons.test
from pylons.i18n.translation import _get_translator
import py.test


def pytest_sessionstart():
    # setup resources before any test is executed
    pylonsapp = None
    pylons.test.pylonsapp = pylonsapp
    path = os.getcwd()
    sys.path.insert(0, path)
    pkg_resources.working_set.add_entry(path)
    config_file = py.test.config.inicfg.get("test_ini")
    pylonsapp = pylons.test.pylonsapp = loadapp('config:' + config_file,
                                                relative_to=path)

    # Setup the config and app_globals, only works if we can get
    # to the config object
    conf = getattr(pylonsapp, 'config')
    if conf:
        pylons.config._push_object(conf)

        if 'pylons.app_globals' in conf:
            pylons.app_globals._push_object(conf['pylons.app_globals'])

    # Initialize a translator for tests that utilize i18n
    translator = _get_translator(pylons.config.get('lang'))
    pylons.translator._push_object(translator)

########NEW FILE########
__FILENAME__ = GPG
""" A wrapper for the 'gpg' command.

We're wrapping gpg instead of using, for example, cryptlib, in order
to reduce dependencies and cut down on the amount of code which
institutional ISconf users would have to audit before installing.
This portability will cost slightly us in terms of performance due to
the fact that we have to fork 'gpg' one or more times for each message
processed.  I don't expect ISconf4 message rates to be high enough for
this to matter.  If and when we start chunking files and managing
large blobs like install images with ISconf, this will likely have to
change.

This is a generic wrapper and is not ISconf-specific -- feel free to
use it in your own applications, and see the pycrypto license below.

Portions of this module are derived from A.M. Kuchling's well-designed
GPG.py, using Richard Jones' updated version 1.3, which can be found
in the pycrypto CVS repository on Sourceforge:

    http://cvs.sourceforge.net/viewcvs.py/pycrypto/gpg/GPG.py

This module is *not* forward-compatible with amk's; some of the
old interface has changed.  For instance, since I've added decrypt
functionality, I elected to initialize with a 'gnupghome' argument
instead of 'keyring', so that gpg can find both the public and secret
keyrings.  I've also altered some of the returned objects in order for
the caller to not have to know as much about the internals of the
result classes.

While the rest of ISconf is released under the GPL, I am releasing
this single file under the same terms that A.M. Kuchling used for
pycrypto:

_____________________ pycrypto LICENSE file starts __________________________
===================================================================
Distribute and use freely; there are no restrictions on further
dissemination and usage except those imposed by the laws of your
country of residence.  This software is provided "as is" without
warranty of fitness for use or suitability for any purpose, express
or implied. Use at your own risk or not at all.
===================================================================

Incorporating the code into commercial products is permitted; you do
not have to make source available or contribute your changes back
(though that would be nice).

--amk                                                             (www.amk.ca)
_______________________ pycrypto LICENSE file ends __________________________



Steve Traugott, stevegt@terraluna.org
Thu Jun 23 21:27:20 PDT 2005


"""

import os
import StringIO
import popen2


class GPG:

    def __init__(self, gpgbinary='gpg', gnupghome=None, verbose=False):
        """Initialize a GPG process wrapper.  Options are:

        gpgbinary -- full pathname for GPG binary.

        gnupghome -- full pathname to where we can find the public and
        private keyrings.  Default is whatever gpg defaults to.

        >>> gpg = GPG(gnupghome="/tmp/pygpgtest")

        """
        self.gpgbinary = gpgbinary
        self.gnupghome = gnupghome
        self.verbose = verbose
        if gnupghome and not os.path.isdir(self.gnupghome):
            os.makedirs(self.gnupghome, 0700)
        # if not os.path.isfile(self.gnupghome + "/secring.gpg"):
        #     self.gen_key()

    def _open_subprocess(self, args, passphrase=None):
        # Internal method: open a pipe to a GPG subprocess and return
        # the file objects for communicating with it.
        cmd = [self.gpgbinary, '--status-fd 2 --no-tty']
        if self.gnupghome:
            cmd.append('--homedir "%s" ' % self.gnupghome)
        if passphrase:
            cmd.append('--passphrase-fd 3')

        cmd.extend(args)
        cmd = ' '.join(cmd)
        if self.verbose:
            print cmd

        child_stdout, child_stdin, child_stderr, child_pass = \
            PopenHi.open(cmd, 3)
        if passphrase:
            child_pass.write(passphrase + "\n")
            child_pass.close()
        return child_stdout, child_stdin, child_stderr

    def _read_response(self, child_stderr, response):
        # Internal method: reads all the output from GPG, taking notice
        # only of lines that begin with the magic [GNUPG:] prefix.
        #
        # Calls methods on the response object for each valid token found,
        # with the arg being the remainder of the status line.
        response.stderr = ''
        while 1:
            line = child_stderr.readline()
            response.stderr += line
            if self.verbose:
                print line
            if line == "":
                break
            line = line.rstrip()
            if line[0:9] == '[GNUPG:] ':
                # Chop off the prefix
                line = line[9:]
                L = line.split(None, 1)
                keyword = L[0]
                if len(L) > 1:
                    value = L[1]
                else:
                    value = ""
                getattr(response, keyword)(value)

    def _handle_gigo(self, args, file, result, passphrase=None):
        # Handle a basic data call - pass data to GPG, handle the output
        # including status information. Garbage In, Garbage Out :)
        child_stdout, child_stdin, child_stderr = \
            self._open_subprocess(args, passphrase)

        # Copy the file to the GPG subprocess
        while 1:
            data = file.read(1024)
            if data == "":
                break
            child_stdin.write(data)
        child_stdin.close()

        # Get the response information
        self._read_response(child_stderr, result)
        self._read_data(child_stdout, result)

        return result

    def _read_data(self, child_stdout, result):
        # Read the contents of the file from GPG's stdout
        result.data = ""
        while 1:
            data = child_stdout.read(1024)
            if data == "":
                break
            result.data = result.data + data

    #
    # SIGNATURE METHODS
    #
    def sign(self, message, keyid=None, passphrase=None, clearsign=True):
        """sign message"""

        args = ["-sa"]
        if clearsign:
            args.append("--clearsign")
        if keyid:
            args.append("--default-key %s" % keyid)
        child_stdout, child_stdin, child_stderr = \
            self._open_subprocess(args, passphrase=passphrase)
        child_stdin.write(message)
        child_stdin.close()
        # Get the response information
        result = Sign()
        self._read_response(child_stderr, result)
        self._read_data(child_stdout, result)
        return result

    def verify(self, data):
        """Verify the signature on the contents of the string 'data'

        >>> gpg = GPG(gnupghome="/tmp/pygpgtest")
        >>> input = gpg.gen_key_input(Passphrase='foo')
        >>> key = gpg.gen_key(input)
        >>> assert key
        >>> sig = gpg.sign('hello',keyid=key.fingerprint,passphrase='bar')
        >>> assert not sig
        >>> sig = gpg.sign('hello',keyid=key.fingerprint,passphrase='foo')
        >>> assert sig
        >>> verify = gpg.verify(str(sig))
        >>> assert verify

        """

        file = StringIO.StringIO(data)
        return self.verify_file(file)

    def verify_file(self, file):
        "Verify the signature on the contents of the file-like object 'file'"
        sig = Verify()
        self._handle_gigo([], file, sig)
        return sig

    #
    # KEY MANAGEMENT
    #

    def import_key(self, key_data):
        """ import the key_data into our keyring

        >>> import shutil
        >>> shutil.rmtree("/tmp/pygpgtest")
        >>> gpg = GPG(gnupghome="/tmp/pygpgtest")
        >>> input = gpg.gen_key_input()
        >>> result = gpg.gen_key(input)
        >>> print1 = result.fingerprint
        >>> result = gpg.gen_key(input)
        >>> print2 = result.fingerprint
        >>> pubkey1 = gpg.export_key(print1)
        >>> seckey1 = gpg.export_key(print1,secret=True)
        >>> seckeys = gpg.list_keys(secret=True)
        >>> pubkeys = gpg.list_keys()
        >>> assert print1 in seckeys.fingerprints
        >>> assert print1 in pubkeys.fingerprints
        >>> gpg.delete_key(print1,secret=True)
        ''
        >>> gpg.delete_key(print1)
        ''
        >>> seckeys = gpg.list_keys(secret=True)
        >>> pubkeys = gpg.list_keys()
        >>> assert not print1 in seckeys.fingerprints
        >>> assert not print1 in pubkeys.fingerprints
        >>> result = gpg.import_key('foo')
        >>> assert not result
        >>> result = gpg.import_key(pubkey1)
        >>> pubkeys = gpg.list_keys()
        >>> seckeys = gpg.list_keys(secret=True)
        >>> assert not print1 in seckeys.fingerprints
        >>> assert print1 in pubkeys.fingerprints
        >>> result = gpg.import_key(seckey1)
        >>> assert result
        >>> seckeys = gpg.list_keys(secret=True)
        >>> pubkeys = gpg.list_keys()
        >>> assert print1 in seckeys.fingerprints
        >>> assert print1 in pubkeys.fingerprints
        >>> assert print2 in pubkeys.fingerprints

        """
        child_stdout, child_stdin, child_stderr = \
            self._open_subprocess(['--import'])

        child_stdin.write(key_data)
        child_stdin.close()

        # Get the response information
        result = ImportResult()
        resp = self._read_response(child_stderr, result)

        return result

    def delete_key(self, fingerprint, secret=False):
        which = 'key'
        if secret:
            which = 'secret-key'
        args = ["--batch --delete-%s %s" % (which, fingerprint)]
        child_stdout, child_stdin, child_stderr = \
            self._open_subprocess(args)
        child_stdin.close()
        # XXX might want to check more status here
        return child_stdout.read()

    def export_key(self, keyid, secret=False):
        """export the indicated key -- 'keyid' is anything gpg accepts"""
        which = ''
        if secret:
            which = '-secret-key'
        args = ["--armor --export%s %s" % (which, keyid)]
        child_stdout, child_stdin, child_stderr = \
            self._open_subprocess(args)
        child_stdin.close()
        # gpg --export produces no status-fd output; stdout will be
        # empty in case of failure
        return child_stdout.read()

    def list_keys(self, secret=False):
        """ list the keys currently in the keyring

        >>> import shutil
        >>> shutil.rmtree("/tmp/pygpgtest")
        >>> gpg = GPG(gnupghome="/tmp/pygpgtest")
        >>> input = gpg.gen_key_input()
        >>> result = gpg.gen_key(input)
        >>> print1 = result.fingerprint
        >>> result = gpg.gen_key(input)
        >>> print2 = result.fingerprint
        >>> pubkeys = gpg.list_keys()
        >>> assert print1 in pubkeys.fingerprints
        >>> assert print2 in pubkeys.fingerprints

        """

        which = 'keys'
        if secret:
            which = 'secret-keys'
        args = "--list-%s --fixed-list-mode --fingerprint --with-colons" % (which)
        args = [args]
        child_stdout, child_stdin, child_stderr = \
            self._open_subprocess(args)
        child_stdin.close()

        # there might be some status thingumy here I should handle... (amk)
        # ...nope, unless you care about expired sigs or keys (stevegt)

        # Get the response information
        result = ListKeys()
        valid_keywords = 'pub uid sec fpr'.split()
        while 1:
            line = child_stdout.readline()
            if self.verbose:
                print line
            if not line:
                break
            L = line.strip().split(':')
            if not L:
                continue
            keyword = L[0]
            if keyword in valid_keywords:
                getattr(result, keyword)(L)
        return result

    def gen_key(self, input):
        """Generate a key; you might use gen_key_input() to create the
        control input.

        >>> gpg = GPG(gnupghome="/tmp/pygpgtest")
        >>> input = gpg.gen_key_input()
        >>> result = gpg.gen_key(input)
        >>> assert result
        >>> result = gpg.gen_key('foo')
        >>> assert not result

        """
        args = ["--gen-key --batch"]
        result = GenKey()
        file = StringIO.StringIO(input)
        self._handle_gigo(args, file, result)
        return result

    def gen_key_input(self, **kwargs):
        """
        Generate --gen-key input per gpg doc/DETAILS

        """
        parms = {}
        for (key, val) in kwargs.items():
            key = key.replace('_', '-')
            parms[key] = val
        parms.setdefault('Key-Type', 'RSA')
        parms.setdefault('Key-Length', 1024)
        parms.setdefault('Name-Real', "Autogenerated Key")
        parms.setdefault('Name-Comment', "Generated by isconf.GPG")
        logname = os.environ['LOGNAME']
        import socket
        hostname = socket.gethostname()
        parms.setdefault('Name-Email', "%s@%s" % (logname, hostname))
        out = "Key-Type: %s\n" % parms['Key-Type']
        del parms['Key-Type']
        for (key, val) in parms.items():
            out += "%s: %s\n" % (key, str(val))
        out += "%commit\n"
        return out

        # Key-Type: RSA
        # Key-Length: 1024
        # Name-Real: ISdlink Server on %s
        # Name-Comment: Created by %s
        # Name-Email: isdlink@%s
        # Expire-Date: 0
        # %commit
        #
        #
        # Key-Type: DSA
        # Key-Length: 1024
        # Subkey-Type: ELG-E
        # Subkey-Length: 1024
        # Name-Real: Joe Tester
        # Name-Comment: with stupid passphrase
        # Name-Email: joe@foo.bar
        # Expire-Date: 0
        # Passphrase: abc
        # %pubring foo.pub
        # %secring foo.sec
        # %commit

    def import_keys(self, keydata, filter=None):
        """import a set of keys, but only if filter(fingerprint)
        is true for all of them

        XXX test filter

        """
        args = "--with-fingerprint --with-colons" % self.path
        args = [args]
        result = ListKeys()
        file = StringIO.StringIO(keydata)
        self._handle_gigo(args, file, result)
        for key in result:
            if filter and not filter(key.fingerprint):
                return None
        return self.import_key(keydata)

    def showpubkey(self, i=0):
        """return the ascii armored public key for the first key on
        the secret ring, or the 'i'th key if given

        XXX test

        """
        keys = self.list_keys(secret=True)
        primary = keys[i]
        ascii = self.export_key(keyid=primary['keyid'])
        return ascii

    def fingerprints(self, keyid='', secret=False):
        keys = self.list_keys(secret=True)
        return keys.fingerprints

    #
    # ENCRYPTION
    #
    def encrypt_file(self, file, recipients, sign=None,
            always_trust=False, passphrase=None):
        "Encrypt the message read from the file-like object 'file'"
        args = ['--encrypt --armor']
        if not (isinstance(recipients, list) or isinstance(recipients, tuple)):
            recipients = [recipients]
        for recipient in recipients:
            args.append('--recipient %s' % recipient)
        if sign:
            args.append("--sign --default-key %s" % sign)
        if always_trust:
            args.append("--always-trust")
        result = Crypt()
        self._handle_gigo(args, file, result, passphrase=passphrase)
        return result

    def encrypt(self, data, recipients, **kwargs):
        """Encrypt the message contained in the string 'data'

        >>> import shutil
        >>> if os.path.exists("/tmp/pygpgtest"):
        ...     shutil.rmtree("/tmp/pygpgtest")
        >>> gpg = GPG(gnupghome="/tmp/pygpgtest")
        >>> input = gpg.gen_key_input(passphrase='foo')
        >>> result = gpg.gen_key(input)
        >>> print1 = result.fingerprint
        >>> input = gpg.gen_key_input()
        >>> result = gpg.gen_key(input)
        >>> print2 = result.fingerprint
        >>> result = gpg.encrypt("hello",print2)
        >>> message = str(result)
        >>> assert message != 'hello'
        >>> result = gpg.decrypt(message)
        >>> assert result
        >>> str(result)
        'hello'
        >>> result = gpg.encrypt("hello again",print1)
        >>> message = str(result)
        >>> result = gpg.decrypt(message)
        >>> result.status
        'need passphrase'
        >>> result = gpg.decrypt(message,passphrase='bar')
        >>> result.status
        'bad passphrase'
        >>> assert not result
        >>> result = gpg.decrypt(message,passphrase='foo')
        >>> result.status
        'decryption ok'
        >>> str(result)
        'hello again'
        >>> result = gpg.encrypt("signed hello",print2,sign=print1)
        >>> result.status
        'need passphrase'
        >>> result = gpg.encrypt("signed hello",print2,sign=print1,passphrase='foo')
        >>> result.status
        'encryption ok'
        >>> message = str(result)
        >>> result = gpg.decrypt(message)
        >>> result.status
        'decryption ok'
        >>> assert result.fingerprint == print1

        """
        file = StringIO.StringIO(data)
        return self.encrypt_file(file, recipients, **kwargs)

    def decrypt(self, message, always_trust=False, passphrase=None):
        args = ["--decrypt"]
        if always_trust:
            args.append("--always-trust")
        result = Crypt()
        file = StringIO.StringIO(message)
        self._handle_gigo(args, file, result, passphrase)
        return result


class Verify:

    "Used to hold output of --verify"

    def __init__(self):
        self.valid = 0
        self.fingerprint = self.creation_date = self.timestamp = None
        self.signature_id = self.key_id = None
        self.username = None

    def __nonzero__(self):
        if self.is_valid():
            return 1
        return 0

    def BADSIG(self, value):
        self.valid = 0
        self.key_id, self.username = value.split(None, 1)

    def GOODSIG(self, value):
        self.valid = 1
        self.key_id, self.username = value.split(None, 1)

    def VALIDSIG(self, value):
        #         C54065C14467F344A9585C1B96D482BAE5F1EA31 2005-08-10
        #         1123652038 0 3 0 1 2 01
        #         C54065C14467F344A9585C1B96D482BAE5F1EA31
        self.fingerprint, self.creation_date, self.sig_timestamp, \
                self.expire_timestamp = value.split()[:4]

    def SIG_ID(self, value):
        self.signature_id, self.creation_date, self.timestamp = value.split()

    # XXX do something with these; start using trust db
    def TRUST_UNDEFINED(self, value):
        pass

    def TRUST_NEVER(self, value):
        pass

    def TRUST_MARGINAL(self, value):
        pass

    def TRUST_FULLY(self, value):
        pass

    def TRUST_ULTIMATE(self, value):
        pass

    # these showed up in gpg 1.4.1
    def PLAINTEXT(self, value):
        pass

    def PLAINTEXT_LENGTH(self, value):
        pass

    def is_valid(self):
        return self.valid


class ImportResult:

    "Used to hold information about a key import result"

    counts = '''count no_user_id imported imported_rsa unchanged
            n_uids n_subk n_sigs n_revoc sec_read sec_imported
            sec_dups not_imported'''.split()

    def __init__(self):
        self.imported = []
        self.results = []
        self.fingerprints = []
        for result in self.counts:
            setattr(self, result, None)

    def __nonzero__(self):
        if self.not_imported:
            return 0
        if not self.fingerprints:
            return 0
        return 1

    def NODATA(self, value):
        self.results.append({'fingerprint': None,
            'problem': '0', 'text': 'No valid data found'})

    def IMPORTED(self, value):
        # this duplicates info we already see in import_ok and import_problem
        pass

    ok_reason = {
        '0': 'Not actually changed',
        '1': 'Entirely new key',
        '2': 'New user IDs',
        '4': 'New signatures',
        '8': 'New subkeys',
        '16': 'Contains private key',
    }

    def IMPORT_OK(self, value):
        reason, fingerprint = value.split()
        reasons = []
        for (code, text) in self.ok_reason.items():
            if int(reason) | int(code) == int(reason):
                reasons.append(text)
        reasontext = '\n'.join(reasons) + "\n"
        self.results.append({'fingerprint': fingerprint,
            'ok': reason, 'text': reasontext})
        self.fingerprints.append(fingerprint)

    problem_reason = {
        '0': 'No specific reason given',
        '1': 'Invalid Certificate',
        '2': 'Issuer Certificate missing',
        '3': 'Certificate Chain too long',
        '4': 'Error storing certificate',
    }

    def IMPORT_PROBLEM(self, value):
        try:
            reason, fingerprint = value.split()
        except:
            reason = value
            fingerprint = '<unknown>'
        self.results.append({'fingerprint': fingerprint,
            'problem': reason, 'text': self.problem_reason[reason]})

    def IMPORT_RES(self, value):
        import_res = value.split()
        for i in range(len(self.counts)):
            setattr(self, self.counts[i], int(import_res[i]))

    def summary(self):
        l = []
        l.append('%d imported' % self.imported)
        if self.not_imported:
            l.append('%d not imported' % self.not_imported)
        return ', '.join(l)


class ListKeys(list):

    ''' Parse a --list-keys output

        Handle pub and uid (relating the latter to the former).

        Don't care about (info from src/DETAILS):

        crt = X.509 certificate
        crs = X.509 certificate and private key available
        sub = subkey (secondary key)
        ssb = secret subkey (secondary key)
        uat = user attribute (same as user id except for field 10).
        sig = signature
        rev = revocation signature
        pkd = public key data (special field format, see below)
        grp = reserved for gpgsm
        rvk = revocation key
    '''

    def __init__(self):
        self.curkey = None
        self.fingerprints = []

    def key(self, args):
        vars = ("""
            type trust length algo keyid date expires dummy ownertrust uid
        """).split()
        self.curkey = {}
        for i in range(len(vars)):
            self.curkey[vars[i]] = args[i]
        self.curkey['uids'] = [self.curkey['uid']]
        del self.curkey['uid']
        self.append(self.curkey)

    pub = sec = key

    def fpr(self, args):
        # fpr:::::::::3324C8D0D1196A6CB497ABD6D694CE9742ABDCE6:
        self.curkey['fingerprint'] = args[9]
        self.fingerprints.append(args[9])

    def uid(self, args):
        self.curkey['uids'].append(args[9])


class Crypt(Verify):

    """Handle --encrypt or --decrypt status """

    def __init__(self):
        Verify.__init__(self)
        self.data = ''
        self.ok = False
        self.status = ''

    def __nonzero__(self):
        if self.ok:
            return 1
        return 0

    def __str__(self):
        return self.data

    def ENC_TO(self, value):
        pass

    def USERID_HINT(self, value):
        pass

    def NEED_PASSPHRASE(self, value):
        self.status = 'need passphrase'

    def BAD_PASSPHRASE(self, value):
        self.status = 'bad passphrase'

    def GOOD_PASSPHRASE(self, value):
        self.status = 'good passphrase'

    def BEGIN_DECRYPTION(self, value):
        self.status = self.status or 'decryption incomplete'

    def DECRYPTION_FAILED(self, value):
        self.status = self.status or 'decryption failed'

    def DECRYPTION_OKAY(self, value):
        self.status = 'decryption ok'
        self.ok = True

    def GOODMDC(self, value):
        pass

    def END_DECRYPTION(self, value):
        pass

    def BEGIN_ENCRYPTION(self, value):
        self.status = self.status or 'encryption incomplete'

    def END_ENCRYPTION(self, value):
        self.status = 'encryption ok'
        self.ok = True

    def INV_RECP(self, value):
        self.status = 'invalid recipient'

    def KEYEXPIRED(self, value):
        self.status = 'key expired'

    def SIG_CREATED(self, value):
        self.status = 'sig expired'

    def SIGEXPIRED(self, value):
        self.status = 'sig expired'


class GenKey:

    """Handle --gen-key status """

    def __init__(self):
        self.type = None
        self.fingerprint = None

    def __nonzero__(self):
        if self.fingerprint:
            return 1
        return 0

    def __str__(self):
        return self.fingerprint or ''

    def PROGRESS(self, value):
        pass

    def GOOD_PASSPHRASE(self, value):
        pass

    def NODATA(self, value):
        pass

    def KEY_CREATED(self, value):
        # P 95C91606D36AB8CACEB762DCD8DA31F0EE77B3A6
        (self.type, self.fingerprint) = value.split()


class Sign:

    """Handle --sign status """

    def __init__(self):
        self.type = None
        self.fingerprint = None

    def __nonzero__(self):
        if self.fingerprint:
            return 1
        return 0

    def __str__(self):
        return self.data or ''

    def USERID_HINT(self, value):
        pass

    def NEED_PASSPHRASE(self, value):
        pass

    def BAD_PASSPHRASE(self, value):
        pass

    def GOOD_PASSPHRASE(self, value):
        pass

    # SIG_CREATED <type> <pubkey algo> <hash algo> <class> <timestamp> <key fpr>
    def SIG_CREATED(self, value):
        # P 95C91606D36AB8CACEB762DCD8DA31F0EE77B3A6
        (self.type, algo, hashalgo, cls, self.timestamp, self.fingerprint
            ) = value.split()

import types


class PopenHi:

    """derived from open2.Popen3, but opens a fourth, high-numbered
    fd for input to the child

    """

    try:
        MAXFD = os.sysconf('SC_OPEN_MAX')
    except (AttributeError, ValueError):
        MAXFD = 256

    _active = []

    def _cleanup(cls):
        for obj in cls._active[:]:
            obj.poll()
    _cleanup = classmethod(_cleanup)

    def __init__(self, cmd, fd, bufsize=-1):
        PopenHi._cleanup()
        self.sts = -1
        p2cread, p2cwrite = os.pipe()
        c2pread, c2pwrite = os.pipe()
        hiread, hiwrite = os.pipe()
        errout, errin = os.pipe()
        self.pid = os.fork()
        if self.pid == 0:
            # Child
            # os.setsid() # disconnect from tty
            os.dup2(p2cread, 0)
            os.dup2(c2pwrite, 1)
            os.dup2(errin, 2)
            os.dup2(hiread, fd)
            if isinstance(cmd, types.StringTypes):
                cmd = ['/bin/sh', '-c', cmd]
            for i in range(3, PopenHi.MAXFD):
                if i == fd:
                    continue
                try:
                    os.close(i)
                except OSError:
                    pass
            # debug = "%d child running %s\n" % (os.getpid(), cmd)
            # open("/tmp/debug", 'w').write(debug)
            try:
                os.execvp(cmd[0], cmd)
            finally:
                os._exit(1)
        os.close(p2cread)
        self.tochild = os.fdopen(p2cwrite, 'w', bufsize)
        os.close(c2pwrite)
        self.fromchild = os.fdopen(c2pread, 'r', bufsize)
        os.close(errin)
        self.childerr = os.fdopen(errout, 'r', bufsize)
        os.close(hiread)
        self.childhi = os.fdopen(hiwrite, 'w', bufsize)
        PopenHi._active.append(self)

    def poll(self):
        """Return the exit status of the child process if it has finished,
        or -1 if it hasn't finished yet."""
        if self.sts < 0:
            try:
                pid, sts = os.waitpid(self.pid, os.WNOHANG)
                if pid == self.pid:
                    self.sts = sts
                    PopenHi._active.remove(self)
            except os.error:
                pass
        return self.sts

    def open(cls, cmd, fd, bufsize=-1):
        obj = PopenHi(cmd, fd, bufsize=-1)
        return obj.fromchild, obj.tochild, obj.childerr, obj.childhi
    open = classmethod(open)

if __name__ == '__main__':
    import sys
    if len(sys.argv) == 1:
        print 'Usage: GPG.py <signed file>'
        sys.exit()

    obj = GPGSubprocess()
    file = open(sys.argv[1], 'rb')
    sig = obj.verify_file(file)
    print sig.__dict__

########NEW FILE########
__FILENAME__ = oauthtwitter
#!/usr/bin/env python
#
# Copyright under  the latest Apache License 2.0

'''A class the inherits everything from python-twitter and allows oauth based access

Requires:
  python-twitter
  oauth
'''

__author__ = "Hameedullah Khan <hameed@hameedkhan.net>"
__version__ = "0.2"

import json

from twitter import Api, User
from oauth import oauth


# Taken from oauth implementation at: http://github.com/harperreed/twitteroauth-python/tree/master
REQUEST_TOKEN_URL = 'https://twitter.com/oauth/request_token'
ACCESS_TOKEN_URL = 'https://twitter.com/oauth/access_token'
AUTHORIZATION_URL = 'http://twitter.com/oauth/authorize'
SIGNIN_URL = 'http://twitter.com/oauth/authenticate'


class OAuthApi(Api):

    def __init__(self, consumer_key, consumer_secret, access_token=None):
        if access_token:
            Api.__init__(self, access_token.key, access_token.secret)
        else:
            Api.__init__(self)
        self._Consumer = oauth.OAuthConsumer(consumer_key, consumer_secret)
        self._signature_method = oauth.OAuthSignatureMethod_HMAC_SHA1()
        self._access_token = access_token

    def _GetOpener(self):
        opener = self._urllib.build_opener()
        return opener

    def _FetchUrl(self,
                    url,
                    post_data=None,
                    parameters=None,
                    no_cache=None):
        '''Fetch a URL, optionally caching for a specified time.

        Args:
          url: The URL to retrieve
          post_data:
            A dict of (str, unicode) key/value pairs.  If set, POST will be used.
          parameters:
            A dict whose key/value pairs should encoded and added
            to the query string. [OPTIONAL]
          no_cache: If true, overrides the cache on the current request

        Returns:
          A string containing the body of the response.
        '''
        # Build the extra parameters dict
        extra_params = {}
        if self._default_params:
          extra_params.update(self._default_params)
        if parameters:
          extra_params.update(parameters)

        # Add key/value parameters to the query string of the url
        # url = self._BuildUrl(url, extra_params=extra_params)

        if post_data:
            http_method = "POST"
            extra_params.update(post_data)
        else:
            http_method = "GET"

        req = self._makeOAuthRequest(url, parameters=extra_params,
                                                    http_method=http_method)
        self._signRequest(req, self._signature_method)

        # Get a url opener that can handle Oauth basic auth
        opener = self._GetOpener()

        # encoded_post_data = self._EncodePostData(post_data)

        if post_data:
            encoded_post_data = req.to_postdata()
            url = req.get_normalized_http_url()
        else:
            url = req.to_url()
            encoded_post_data = ""

        no_cache = True
        # Open and return the URL immediately if we're not going to cache
        # OR we are posting data
        if encoded_post_data or no_cache:
          if encoded_post_data:
              url_data = opener.open(url, encoded_post_data).read()
          else:
              url_data = opener.open(url).read()
          opener.close()
        else:
          # Unique keys are a combination of the url and the username
          if self._username:
            key = self._username + ':' + url
          else:
            key = url

          # See if it has been cached before
          last_cached = self._cache.GetCachedTime(key)

          # If the cached version is outdated then fetch another and store it
          if not last_cached or time.time() >= last_cached + self._cache_timeout:
            url_data = opener.open(url).read()
            opener.close()
            self._cache.Set(key, url_data)
          else:
            url_data = self._cache.Get(key)

        # Always return the latest version
        return url_data

    def _makeOAuthRequest(self, url, token=None,
                                        parameters=None, http_method="GET"):
        '''Make a OAuth request from url and parameters

        Args:
          url: The Url to use for creating OAuth Request
          parameters:
             The URL parameters
          http_method:
             The HTTP method to use
        Returns:
          A OAauthRequest object
        '''
        if not token:
            token = self._access_token
        request = oauth.OAuthRequest.from_consumer_and_token(
                            self._Consumer, token=token,
                            http_url=url, parameters=parameters,
                            http_method=http_method)
        return request

    def _signRequest(self, req, signature_method=oauth.OAuthSignatureMethod_HMAC_SHA1()):
        '''Sign a request

        Reminder: Created this function so incase
        if I need to add anything to request before signing

        Args:
          req: The OAuth request created via _makeOAuthRequest
          signate_method:
             The oauth signature method to use
        '''
        req.sign_request(signature_method, self._Consumer, self._access_token)

    def getAuthorizationURL(self, token, url=AUTHORIZATION_URL):
        '''Create a signed authorization URL

        Returns:
          A signed OAuthRequest authorization URL
        '''
        req = self._makeOAuthRequest(url, token=token)
        self._signRequest(req)
        return req.to_url()

    def getSigninURL(self, token, url=SIGNIN_URL):
        '''Create a signed Sign-in URL

        Returns:
          A signed OAuthRequest Sign-in URL
        '''

        signin_url = self.getAuthorizationURL(token, url)
        return signin_url

    def getAccessToken(self, url=ACCESS_TOKEN_URL):
        token = self._FetchUrl(url, no_cache=True)
        return oauth.OAuthToken.from_string(token)

    def getRequestToken(self, url=REQUEST_TOKEN_URL):
        '''Get a Request Token from Twitter

        Returns:
          A OAuthToken object containing a request token
        '''
        resp = self._FetchUrl(url, no_cache=True)
        token = oauth.OAuthToken.from_string(resp)
        return token

    def GetUserInfo(self, url='https://twitter.com/account/verify_credentials.json'):
        '''Get user information from twitter

        Returns:
          Returns the twitter.User object
        '''
        json_data = self._FetchUrl(url)
        data = json.loads(json_data)
        self._CheckForTwitterError(data)
        return User.NewFromJsonDict(data)

########NEW FILE########
__FILENAME__ = abuse
import logging

import formencode
from formencode import htmlfill, Invalid, validators

from pylons import request, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.i18n import _

from adhocracy.lib import helpers as h
from adhocracy.lib.auth import guard
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render
import adhocracy.lib.broadcast as broadcast


log = logging.getLogger(__name__)


class AbuseReportForm(formencode.Schema):
    allow_extra_fields = True
    url = validators.String(max=500, not_empty=True)
    message = validators.String(max=20000, min=2, not_empty=True)


class AbuseController(BaseController):

    @guard.perm('abuse.report')
    def new(self, format='html', errors={}):
        c.url = request.params.get('url', request.environ.get('HTTP_REFERER'))
        # require.user.message(c.page_user)
        html = render("/abuse/new.html", overlay=format == u'overlay')
        return htmlfill.render(html, defaults=request.params,
                               errors=errors, force_defaults=False)

    @RequireInternalRequest()
    @guard.perm('abuse.report')
    def report(self, format='html'):
        try:
            self.form_result = AbuseReportForm().to_python(request.params)
        except Invalid, i:
            return self.new(errors=i.unpack_errors())

        broadcast.notify_abuse(c.instance, c.user,
                               self.form_result.get('url'),
                               self.form_result.get('message'))
        h.flash(_("Thank you for helping."), 'notice')
        redirect(self.form_result.get('url'))

########NEW FILE########
__FILENAME__ = admin
import logging

import formencode
import formencode.htmlfill
from pylons import request, tmpl_context as c
from pylons.i18n import lazy_ugettext as L_, _
from pylons.controllers.util import redirect

from adhocracy import config
from adhocracy import model, forms
from adhocracy.lib.auth import guard
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.auth.welcome import can_welcome
from adhocracy.lib.base import BaseController
from adhocracy.lib.helpers import base_url, flash
from adhocracy.lib.templating import render, ret_abort
from adhocracy.lib.search import index
from adhocracy.lib.user_import import user_import, get_user_import_state
import adhocracy.lib.importexport

log = logging.getLogger(__name__)


class UserImportForm(formencode.Schema):
    allow_extra_fields = True
    users_csv = forms.UsersCSV()
    email_subject = formencode.validators.String(
        not_empty=True,
        messages={'empty': L_('Please insert a subject for the '
                              'mail we will send to the users.')})
    email_template = forms.ContainsEMailPlaceholders(
        not_empty=True,
        messages={'empty': L_('Please insert a template for the '
                              'mail we will send to the users.')})


class ExportForm(formencode.Schema):
    include_user = formencode.validators.StringBoolean(if_missing=False)
    include_badge = formencode.validators.StringBoolean(if_missing=False)
    include_instance = formencode.validators.StringBoolean(if_missing=False)
    include_instance_proposal = formencode.validators.StringBoolean(
        if_missing=False)
    include_instance_proposal_comment = formencode.validators.StringBoolean(
        if_missing=False)
    include_proposal_creator_badges = formencode.validators.StringBoolean(
        if_missing=False)
    include_ratings = formencode.validators.StringBoolean(if_missing=False)
    include_requestlog = formencode.validators.StringBoolean(if_missing=False)
    include_staticpage = formencode.validators.StringBoolean(if_missing=False)
    user_personal = formencode.validators.StringBoolean(if_missing=False)
    user_password = formencode.validators.StringBoolean(if_missing=False)
    format = formencode.validators.OneOf(
        ['json', 'json_download', 'json_gzip',
         'zip',
         'tar', 'tar_gz', 'tar_bz2'])
    _tok = formencode.validators.String()


class ImportForm(formencode.Schema):
    include_user = formencode.validators.StringBoolean(if_missing=False)
    welcome = formencode.validators.StringBoolean(if_missing=False)
    include_badge = formencode.validators.StringBoolean(if_missing=False)
    include_instance = formencode.validators.StringBoolean(if_missing=False)
    include_instance_proposal = formencode.validators.StringBoolean(
        if_missing=False)
    include_staticpage = formencode.validators.StringBoolean(if_missing=False)
    filetype = formencode.validators.OneOf(['detect', 'json', 'zip'])
    importfile = formencode.validators.FieldStorageUploadConverter(
        not_empty=True)
    replacement = formencode.validators.OneOf(['update', 'skip'])
    _tok = formencode.validators.String()


class AdminController(BaseController):

    identifier = 'admin'

    @guard.perm("global.admin")
    def index(self):
        return render("/admin/index.html", {})

    @guard.perm("global.admin")
    def update_index(self):
        for entity_type in model.refs.TYPES:
            if hasattr(entity_type, "all"):
                for entity in entity_type.all():
                    index.update(entity)
        flash(_('Solr index updated.'), 'success')
        redirect(base_url('/admin'))

    @guard.perm("global.admin")
    def fix_autojoin(self):
        config_autojoin = config.get('adhocracy.instances.autojoin')
        if not config_autojoin:
            return ret_abort('autojoin is not enabled')

        users = model.User.all()
        instances = model.Instance.all(include_hidden=True)
        added = 0
        if config_autojoin != 'ALL':
            instance_keys = [key.strip() for key in
                             config_autojoin.split(",")]
            instances = [instance for instance in instances
                         if instance.key in instance_keys]
        for user in users:
            to_join = set(instances)
            for m in user.memberships:
                to_join.discard(m.instance)
            for instance in to_join:
                autojoin_membership = model.Membership(
                    user, instance,
                    instance.default_group)
                model.meta.Session.add(autojoin_membership)
                added += 1
        if added > 0:
            model.meta.Session.commit()

        flash(_('Autojoin fixed - added %s memberships.') % added, 'success')
        return redirect(base_url('/admin'))

    @RequireInternalRequest()
    @guard.perm("global.admin")
    def permissions(self):
        if request.method == "POST":
            groups = model.Group.all(ordered=True)
            for permission in model.Permission.all():
                for group in groups:
                    t = request.params.get("%s-%s" % (
                        group.code, permission.permission_name))
                    if t and permission not in group.permissions:
                        group.permissions.append(permission)
                    elif not t and permission in group.permissions:
                        group.permissions.remove(permission)
            for group in groups:
                model.meta.Session.add(group)
            model.meta.Session.commit()
        return render("/admin/permissions.html", {})

    @guard.perm("global.admin")
    def user_import_form(self, errors=None, format='html'):
        return formencode.htmlfill.render(
            render("/admin/userimport_form.html", {},
                   overlay=format == 'overlay'),
            defaults=dict(request.params),
            errors=errors,
            force_defaults=False)

    @RequireInternalRequest(methods=['POST'])
    @guard.perm("global.admin")
    def user_import(self, format='html'):

        if request.method == "POST":
            try:
                self.form_result = UserImportForm().to_python(
                    request.params, state=get_user_import_state())
                data = user_import(self.form_result['users_csv'],
                                   self.form_result['email_subject'],
                                   self.form_result['email_template'],
                                   c.user,
                                   c.instance)
                return render("/admin/userimport_success.html", data,
                              overlay=format == u'overlay')
            except formencode.Invalid as i:
                return self.user_import_form(errors=i.unpack_errors())
        else:
            return self.user_import_form(format=format)

    @guard.perm("global.admin")
    def import_dialog(self, errors=None, defaults=None, format=u'html'):
        data = {
            'welcome_enabled': can_welcome()
        }
        if defaults is None:
            defaults = dict(request.POST)
        tpl = render('admin/import_dialog.html', data,
                     overlay=format == u'overlay')
        return formencode.htmlfill.render(
            tpl,
            defaults=defaults,
            errors=errors,
            force_defaults=False)

    @RequireInternalRequest(methods=['POST'])
    @guard.perm("global.admin")
    def import_do(self):
        try:
            options = ImportForm().to_python(dict(request.params))
        except formencode.Invalid as i:
            return self.import_dialog(errors=i.unpack_errors())

        if not can_welcome() and options['welcome']:
            return ret_abort(_("Requested generation of welcome codes, but "
                               "welcome functionality"
                               "(adhocracy.enable_welcome) is not enabled."),
                             code=403)
        obj = request.POST['importfile']
        options['user_personal'] = True
        adhocracy.lib.importexport.import_(options, obj.file)
        return render('admin/import_success.html', {})

    @guard.perm("global.admin")
    def export_dialog(self, format=u'html'):
        return render('admin/export_dialog.html', {},
                      overlay=format == u'overlay')

    @RequireInternalRequest(methods=['POST'])
    @guard.perm("global.admin")
    def export_do(self):
        options = ExportForm().to_python(dict(request.params))
        return adhocracy.lib.importexport.export(options)
        # Above writes out a file; don't render anything

########NEW FILE########
__FILENAME__ = badge
import logging

from cgi import FieldStorage
import formencode
from formencode import Any, All, htmlfill, Invalid, validators
from paste.deploy.converters import asbool
from pylons import request, tmpl_context as c
from pylons.controllers.util import abort
from pylons.controllers.util import redirect
from pylons.i18n import _

from adhocracy import config
from adhocracy.forms.common import ValidInstanceGroup
from adhocracy.forms.common import ValidHTMLColor
from adhocracy.forms.common import ContainsChar
from adhocracy.forms.common import ValidBadgeInstance
from adhocracy.forms.common import ValidImageFileUpload
from adhocracy.forms.common import ValidFileUpload
from adhocracy.forms.common import ValidCategoryBadge
from adhocracy.forms.common import ValidParentCategory
from adhocracy.forms.common import ValidateNoCycle
from adhocracy.forms.common import ProposalSortOrder
from adhocracy.model import UPDATE
from adhocracy.model import meta
from adhocracy.model import Badge
from adhocracy.model import Group
from adhocracy.model import CategoryBadge
from adhocracy.model import DelegateableBadge
from adhocracy.model import InstanceBadge
from adhocracy.model import ThumbnailBadge
from adhocracy.model import UserBadge
from adhocracy.lib import helpers as h, logo
from adhocracy.lib.auth.authorization import has
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.auth import require
from adhocracy.lib.auth import guard
from adhocracy.lib.auth import can
from adhocracy.lib.base import BaseController
from adhocracy.lib.behavior import behavior_enabled
from adhocracy.lib.pager import PROPOSAL_SORTS
from adhocracy.lib.queue import update_entity
from adhocracy.lib.templating import render
from adhocracy.lib.templating import OVERLAY_SMALL


log = logging.getLogger(__name__)


BADGE_TYPE_MAPPING = {
    'user': UserBadge,
    'delegateable': DelegateableBadge,
    'category': CategoryBadge,
    'instance': InstanceBadge,
    'thumbnail': ThumbnailBadge,
}


class BadgeForm(formencode.Schema):
    allow_extra_fields = True
    title = All(validators.String(max=40, not_empty=True),
                ContainsChar())
    description = validators.String(max=255)
    color = ValidHTMLColor()
    instance = ValidBadgeInstance()
    impact = validators.Int(min=-10, max=10, if_missing=0)
    if behavior_enabled():
        behavior_proposal_sort_order = ProposalSortOrder()


class CategoryBadgeForm(BadgeForm):
    select_child_description = validators.String(max=255)
    parent = ValidCategoryBadge(not_empty=False)
    long_description = validators.String(
        max=config.get_int('adhocracy.category.long_description.max_length'))
    chained_validators = [
        # make sure parent has same instance as we
        ValidParentCategory()
    ]


class CategoryBadgeUpdateForm(CategoryBadgeForm):
    id = ValidCategoryBadge(not_empty=True)
    chained_validators = [
        # make sure parent has same instance as we
        ValidParentCategory(),
        # make sure we don't create a cycle
        ValidateNoCycle(),
    ]


class UserBadgeForm(BadgeForm):
    pass


class UserBadgeFormSupervise(UserBadgeForm):
    group = Any(validators.Empty, ValidInstanceGroup())
    display_group = validators.StringBoolean(if_missing=False)


class ThumbnailBadgeForm(BadgeForm):
    thumbnail = All(ValidImageFileUpload(not_empty=False),
                    ValidFileUpload(not_empty=False), )


class BadgeController(BaseController):
    """Badge controller base class"""

    form_template = "/badge/form.html"
    index_template = "/badge/index.html"
    base_url_ = None
    identifier = "badges"

    @property
    def base_url(self):
        if self.base_url_ is None:
            self.base_url_ = h.site.base_url(instance=c.instance,
                                             path='/badge')
        return self.base_url_

    def _get_badge_data(self, badge_type):
        cls = self._get_badge_class(badge_type)
        if cls is None:
            abort(404, _(u"No such badge type"))

        return {
            'badge_type': badge_type,
            'badge_header': self._get_badge_header(badge_type),
            'badge_base_url': self.base_url,
            'global_badges': (cls.all(instance=None)
                              if has('global.admin')
                              else None),
            'instance_badges': (cls.all(instance=c.instance)
                                if c.instance is not None
                                else None),
        }

    def _redirect(self):
        if c.came_from:
            redirect(c.came_from)
        else:
            redirect(self.base_url)

    @guard.perm('badge.index')
    def index(self, format='html'):
        c.badge_tables = dict((type_, self._get_badge_data(type_))
                              for type_ in ['user', 'category', 'thumbnail',
                                            'delegateable', 'instance'])
        return render('/badge/index_all.html', overlay=format == u'overlay')

    @guard.perm('badge.index')
    def index_type(self, badge_type, format='html'):
        data = self._get_badge_data(badge_type)
        data['came_from'] = self.base_url + '/' + badge_type
        return render(self.index_template, data, overlay=format == u'overlay',
                      overlay_size=OVERLAY_SMALL)

    def _redirect_not_found(self, id):
        h.flash(_("We cannot find the badge with the id %s") % str(id),
                'error')
        self._redirect()

    def _set_parent_categories(self, exclude=None):
        local_categories = CategoryBadge.all_q(instance=c.instance)

        if exclude is not None:
            local_categories = filter(lambda c: not(c.is_ancester(exclude)),
                                      local_categories)

        c.local_category_parents = sorted(
            [(b.id, b.get_key()) for b in local_categories],
            key=lambda x: x[1])

        if h.has_permission('global.admin'):
            global_categories = CategoryBadge.all_q(instance=None)

            if exclude is not None:
                global_categories = filter(
                    lambda c: not(c.is_ancester(exclude)), global_categories)
            c.global_category_parents = sorted(
                [(b.id, b.get_key()) for b in global_categories],
                key=lambda x: x[1])

    def add(self, badge_type=None, errors=None, format=u'html'):
        data = {
            'form_type': 'add',
            'groups': Group.all_instance(),
            'sorting_orders': PROPOSAL_SORTS,
        }
        if not c.came_from:
            c.came_from = self.base_url
        if badge_type is not None:
            data['badge_type'] = badge_type

        if (c.instance is not None
           and not asbool(request.GET.get('global', False))):
            require.badge.manage_instance()
            instance = c.instance.key
        else:
            require.badge.manage_global()
            instance = ''

        defaults = {'visible': True,
                    'select_child_description': '',
                    'impact': 0,
                    'instance': instance,
                    }
        defaults.update(dict(request.params))

        self._set_parent_categories()

        html = render(self.form_template, data, overlay=format == u'overlay',
                      overlay_size=OVERLAY_SMALL)
        return htmlfill.render(html,
                               defaults=defaults,
                               errors=errors,
                               force_defaults=False)

    def _dispatch(self, action, badge_type, id=None, format=u'html'):
        '''
        dispatch to a suitable "create" or "edit" action

        Methods are named <action>_<badge_type>_badge().
        '''
        assert action in ['create', 'update']
        types = ['user', 'delegateable', 'category', 'instance', 'thumbnail']
        if badge_type not in types:
            raise AssertionError('Unknown badge_type: %s' % badge_type)

        c.badge_type = badge_type
        c.form_type = action
        c.badge_base_url = self.base_url

        methodname = "%s_%s_badge" % (action, badge_type)
        method = getattr(self, methodname, None)
        if method is None:
            raise AttributeError(
                'Method not found for action "%s", badge_type: %s' %
                (action, badge_type))
        if id is not None:
            return method(id, format=format)
        else:
            return method(format=format)

    @RequireInternalRequest()
    def create(self, badge_type, format=u'html'):
        return self._dispatch('create', badge_type, format=format)

    @RequireInternalRequest()
    def create_instance_badge(self, format=u'html'):
        try:
            self.form_result = BadgeForm().to_python(request.params)
        except Invalid as i:
            return self.add('instance', i.unpack_errors())
        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        if instance is None:
            require.badge.manage_global()
        else:
            require.badge.manage_instance()

        InstanceBadge.create(title, color, visible, description, impact,
                             instance)
        # commit cause redirect() raises an exception
        meta.Session.commit()
        self._redirect()

    @RequireInternalRequest()
    def create_user_badge(self, format=u'html'):
        try:
            if can.user.supervise():
                form = UserBadgeFormSupervise()
            else:
                form = UserBadgeForm()
            self.form_result = form.to_python(request.params)
        except Invalid as i:
            return self.add('user', i.unpack_errors())

        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        if instance is None:
            require.badge.manage_global()
        else:
            require.badge.manage_instance()

        if can.user.supervise():
            group = self.form_result.get('group')
            display_group = self.form_result.get('display_group')

            UserBadge.create(title, color, visible, description,
                             group=group,
                             display_group=display_group,
                             impact=impact,
                             instance=instance)
        else:
            UserBadge.create(title, color, visible, description,
                             impact=impact,
                             instance=instance)

        # commit cause redirect() raises an exception
        meta.Session.commit()
        self._redirect()

    @RequireInternalRequest()
    def create_delegateable_badge(self, format=u'html'):
        try:
            self.form_result = BadgeForm().to_python(request.params)
        except Invalid as i:
            return self.add('delegateable', i.unpack_errors())
        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        if instance is None:
            require.badge.manage_global()
        else:
            require.badge.manage_instance()

        DelegateableBadge.create(title, color, visible, description, impact,
                                 instance)
        # commit cause redirect() raises an exception
        meta.Session.commit()
        self._redirect()

    @RequireInternalRequest()
    def create_category_badge(self, format=u'html'):
        try:
            self.form_result = CategoryBadgeForm().to_python(request.params)
        except Invalid as i:
            return self.add('category', i.unpack_errors())

        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        if instance is None:
            require.badge.manage_global()
        else:
            require.badge.manage_instance()

        child_descr = self.form_result.get("select_child_description")
        child_descr = child_descr.replace("$badge_title", title)
        long_description = self.form_result.get("long_description")
        parent = self.form_result.get("parent")
        parent = self.form_result.get("parent")
        if parent and parent.id == id:
            parent = None
        badge = CategoryBadge.create(title, color, visible, description,
                                     impact, instance, parent=parent,
                                     long_description=long_description,
                                     select_child_description=child_descr)

        try:
            # fixme: show image errors in the form
            if ('image' in request.POST and
                    hasattr(request.POST.get('image'), 'file') and
                    request.POST.get('image').file):
                logo.store(badge, request.POST.get('image').file)
        except Exception, e:
            meta.Session.rollback()
            h.flash(unicode(e), 'error')
            log.debug(e)
            return self.add('category')

        # commit cause redirect() raises an exception
        meta.Session.commit()
        self._redirect()

    @RequireInternalRequest()
    def create_thumbnail_badge(self, format=u'html'):
        try:
            self.form_result = BadgeForm().to_python(request.params)
        except Invalid as i:
            return self.add('thumbnail', i.unpack_errors())
        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        if instance is None:
            require.badge.manage_global()
        else:
            require.badge.manage_instance()

        thumbnail = self.form_result.get("thumbnail")
        if isinstance(thumbnail, FieldStorage):
            thumbnail = thumbnail.file.read()
        else:
            thumbnail = None
        ThumbnailBadge.create(title, color, visible, description, thumbnail,
                              impact, instance)
        # commit cause redirect() raises an exception
        meta.Session.commit()
        self._redirect()

    def _get_common_fields(self, form_result):
        '''
        return a tuple of (title, color, visible, description, impact,
                           instance).
        '''
        if h.has_permission('global.admin'):
            instance = form_result.get('instance')
        else:
            # instance only admins can only create/edit
            # badges inside the current instance
            instance = c.instance
        return (form_result.get('title').strip(),
                form_result.get('color').strip(),
                'visible' in form_result,
                form_result.get('description').strip(),
                form_result.get('impact'),
                instance,
                )

    def _get_badge_type(self, badge):
        return badge.polymorphic_identity

    def _get_badge_class(self, badge_type):
        return BADGE_TYPE_MAPPING.get(badge_type)

    def _get_badge_header(self, badge_type):
        BADGE_HEADERS = {
            'user': _(u'User Badges'),
            'delegateable': _(u'Proposal Badges'),
            'category': _(u'Categories'),
            'instance': _(u'Instance Badges'),
            'thumbnail': _(u'Status Badges'),
        }
        return BADGE_HEADERS.get(badge_type)

    def _get_badge_or_redirect(self, id):
        '''
        Get a badge. Redirect if it does not exist. Redirect if
        the badge is not from the current instance, but the user is
        only an instance admin, not a global admin
        '''
        badge = Badge.by_id(id, instance_filter=False)
        if badge is None:
            self._redirect_not_found(id)
        if badge.instance != c.instance and not has('global.admin'):
            self._redirect_not_found(id)
        return badge

    def edit(self, id, errors=None, format=u'html'):
        badge = self._get_badge_or_redirect(id)
        require.badge.edit(badge)

        data = {
            'badge_type': self._get_badge_type(badge),
            'form_type': 'update',
            'return_url': self.base_url,
            'sorting_orders': PROPOSAL_SORTS,
        }
        if getattr(badge, "thumbnail", None):
            data['logo'] = h.badge_helper.generate_thumbnail_tag(badge)
        elif self._get_badge_type(badge) == 'category' and logo.exists(badge):
            data['logo'] = '<img src="%s" />' % h.logo_url(badge, 48)

        self._set_parent_categories(exclude=badge)

        # Plug in current values
        instance_default = badge.instance.key if badge.instance else ''
        defaults = dict(
            title=badge.title,
            description=badge.description,
            long_description=badge.long_description,
            color=badge.color,
            visible=badge.visible,
            display_group=badge.display_group,
            impact=badge.impact,
            instance=instance_default,
            behavior_proposal_sort_order=badge.behavior_proposal_sort_order)
        if isinstance(badge, UserBadge):
            c.groups = Group.all_instance()
            defaults['group'] = badge.group and badge.group.code or ''
        if isinstance(badge, CategoryBadge):
            defaults['parent'] = badge.parent and badge.parent.id or ''
            defaults['select_child_description'] =\
                badge.select_child_description

        if not c.came_from:
            c.came_from = self.base_url

        return htmlfill.render(render(self.form_template, data,
                                      overlay=format == u'overlay',
                                      overlay_size=OVERLAY_SMALL),
                               errors=errors,
                               defaults=defaults,
                               force_defaults=False)

    @RequireInternalRequest()
    def update(self, id, format=u'html'):
        badge = self._get_badge_or_redirect(id)
        require.badge.edit(badge)
        c.badge_type = self._get_badge_type(badge)
        return self._dispatch('update', c.badge_type, id=id, format=format)

    @RequireInternalRequest()
    def update_user_badge(self, id, format=u'html'):
        try:
            if can.user.supervise():
                form = UserBadgeFormSupervise()
            else:
                form = UserBadgeForm()
            self.form_result = form.to_python(request.params)
        except Invalid as i:
            return self.edit(id, i.unpack_errors())

        badge = self._get_badge_or_redirect(id)
        require.badge.edit(badge)
        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        badge.title = title
        badge.color = color
        badge.visible = visible
        badge.description = description
        badge.instance = instance
        if can.user.supervise():
            badge.group = self.form_result.get('group')
            badge.display_group = self.form_result.get('display_group')
        if behavior_enabled():
            badge.behavior_proposal_sort_order = self.form_result.get(
                'behavior_proposal_sort_order')
        if badge.impact != impact:
            badge.impact = impact
            meta.Session.commit()
            for user in badge.users:
                update_entity(user, UPDATE)
        else:
            meta.Session.commit()
        h.flash(_("Badge changed successfully"), 'success')
        self._redirect()

    @RequireInternalRequest()
    def update_delegateable_badge(self, id, format=u'html'):
        try:
            self.form_result = BadgeForm().to_python(request.params)
        except Invalid as i:
            return self.edit(id, i.unpack_errors())
        badge = self._get_badge_or_redirect(id)
        require.badge.edit(badge)
        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        badge.title = title
        badge.color = color
        badge.visible = visible
        badge.description = description
        badge.instance = instance
        if badge.impact != impact:
            badge.impact = impact
            meta.Session.commit()
            for delegateable in badge.delegateables:
                update_entity(delegateable, UPDATE)
        else:
            meta.Session.commit()
        h.flash(_("Badge changed successfully"), 'success')
        self._redirect()

    @RequireInternalRequest()
    def update_instance_badge(self, id, format=u'html'):
        try:
            self.form_result = BadgeForm().to_python(request.params)
        except Invalid as i:
            return self.edit(id, i.unpack_errors())
        badge = self._get_badge_or_redirect(id)
        require.badge.edit(badge)
        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)

        badge.title = title
        badge.color = color
        badge.visible = visible
        badge.description = description
        badge.instance = instance
        if badge.impact != impact:
            badge.impact = impact
            meta.Session.commit()
            for instance in badge.instances:
                update_entity(instance, UPDATE)
        else:
            meta.Session.commit()
        h.flash(_("Badge changed successfully"), 'success')
        self._redirect()

    @RequireInternalRequest()
    def update_category_badge(self, id, format=u'html'):
        try:
            params = request.params.copy()
            params['id'] = id
            self.form_result = CategoryBadgeUpdateForm().to_python(params)
        except Invalid as i:
            return self.edit(id, i.unpack_errors())
        badge = self._get_badge_or_redirect(id)
        require.badge.edit(badge)

        # delete the logo if the button was pressed and exit
        if 'delete_image' in self.form_result:
            updated = logo.delete(badge)
            if updated:
                h.flash(_(u'The image has been deleted.'), 'success')
            self._redirect()

        try:
            # fixme: show image errors in the form
            if ('image' in request.POST and
                    hasattr(request.POST.get('image'), 'file') and
                    request.POST.get('image').file):
                logo.store(badge, request.POST.get('image').file)
        except Exception, e:
            meta.Session.rollback()
            h.flash(unicode(e), 'error')
            log.debug(e)
            return self.edit('category')

        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)
        child_descr = self.form_result.get("select_child_description")
        child_descr = child_descr.replace("$badge_title", title)
        long_description = self.form_result.get("long_description", u'')
        # TODO global badges must have only global badges children, joka
        parent = self.form_result.get("parent")
        if parent and parent.id == id:
            parent = None
        badge.title = title
        badge.color = color
        badge.visible = visible
        badge.description = description
        badge.instance = instance
        badge.select_child_description = child_descr
        badge.long_description = long_description
        badge.parent = parent
        if badge.impact != impact:
            badge.impact = impact
            meta.Session.commit()
            for delegateable in badge.delegateables:
                update_entity(delegateable, UPDATE)
        else:
            meta.Session.commit()
        h.flash(_("Badge changed successfully"), 'success')
        self._redirect()

    @RequireInternalRequest()
    def update_thumbnail_badge(self, id, format=u'html'):
        try:
            self.form_result = ThumbnailBadgeForm().to_python(request.params)
        except Invalid as i:
            return self.edit(id, i.unpack_errors())
        badge = self._get_badge_or_redirect(id)
        require.badge.edit(badge)
        title, color, visible, description, impact, instance =\
            self._get_common_fields(self.form_result)
        thumbnail = self.form_result.get("thumbnail")
        if isinstance(thumbnail, FieldStorage):
            badge.thumbnail = thumbnail.file.read()
        if 'delete_thumbnail' in self.form_result:
            badge.thumbnail = None
        badge.title = title
        badge.color = color
        badge.visible = visible
        badge.description = description
        badge.instance = instance
        if badge.impact != impact:
            badge.impact = impact
            meta.Session.commit()
            for delegateable in badge.delegateables:
                update_entity(delegateable, UPDATE)
        else:
            meta.Session.commit()
        h.flash(_("Badge changed successfully"), 'success')
        self._redirect()

    def ask_delete(self, id, format=u'html'):
        badge = self._get_badge_or_redirect(id)
        require.badge.manage(badge)

        data = {
            'badge': badge,
            'badge_type': self._get_badge_type(badge),
            'badged_entities': badge.badged_entities(),
        }
        if not c.came_from:
            c.came_from = self.base_url

        return render('/badge/ask_delete.html', data,
                      overlay=format == u'overlay')

    @RequireInternalRequest()
    def delete(self, id, format=u'html'):
        badge = self._get_badge_or_redirect(id)
        require.badge.manage(badge)

        for badge_instance in badge.badges():
            meta.Session.delete(badge_instance)
            update_entity(badge_instance.badged_entity(), UPDATE)
        meta.Session.delete(badge)
        meta.Session.commit()
        h.flash(_(u"Badge deleted successfully"), 'success')
        self._redirect()

########NEW FILE########
__FILENAME__ = category
from paste.deploy.converters import asbool

from pylons import tmpl_context as c
from pylons import request
from pylons.decorators import validate
from pylons.controllers.util import abort

from adhocracy.lib import helpers as h
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render, render_logo
from adhocracy.lib.templating import OVERLAY_SMALL
from adhocracy.lib import pager
from adhocracy.lib import tiles
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.auth import require
from adhocracy.lib.staticpage import add_static_content
from adhocracy.lib.util import get_entity_or_abort

from adhocracy import config
from adhocracy import model

from proposal import ProposalFilterForm


class CategoryController(BaseController):

    identifier = 'category'

    @RequireInstance
    @validate(schema=ProposalFilterForm(), post_only=False, on_get=True)
    def show(self, id, format=u'html'):
        if not c.instance.display_category_pages:
            abort(404)
        require.proposal.index()
        query = self.form_result.get('proposals_q')

        category = get_entity_or_abort(model.CategoryBadge, id)

        pages = model.Page.all_q(instance=c.instance,
                                 functions=model.Page.LISTED) \
            .join(model.DelegateableBadges) \
            .filter(model.DelegateableBadges.badge_id == category.id) \
            .all()
        pages = filter(lambda p: p.parent is None, pages)
        pages_pager = pager.NamedPager('pages', pages, tiles.page.smallrow,
                                       enable_pages=False, enable_sorts=False)

        default_sorting = config.get(
            'adhocracy.listings.instance_proposal.sorting')
        proposals_pager = pager.solr_proposal_pager(
            c.instance,
            {'text': query},
            default_sorting=default_sorting,
            extra_filter={'facet.delegateable.badgecategory': category.id})

        data = {
            'category': category,
            'pages_pager': pages_pager,
            'proposals_pager': proposals_pager,
        }
        return render('/category/show.html', data,
                      overlay=format == u'overlay')

    @RequireInstance
    def index(self, format=u'html'):
        if not c.instance.display_category_pages:
            abort(404)
        categories = model.CategoryBadge.all(instance=c.instance,
                                             visible_only=True)
        data = {
            'categories': filter(lambda c: len(c.children) == 0, categories)
        }
        add_static_content(data, u'adhocracy.static.category_index_heading',
                           body_key=u'heading_text',
                           title_key=u'heading_title')
        return render('/category/index.html', data,
                      overlay=format == u'overlay')

    @RequireInstance
    def image(self, id, y, x=None):
        if not c.instance.display_category_pages:
            abort(404)
        category = get_entity_or_abort(model.CategoryBadge, id,
                                       instance_filter=False)
        return render_logo(category, y, x=x)

    @RequireInstance
    def description(self, id, format=u'html'):
        if not c.instance.display_category_pages:
            abort(404)
        category = get_entity_or_abort(model.CategoryBadge, id)

        description = category.long_description
        description = h.render(description)
        description = h.text.truncate_html(description, 65, u'&hellip;')

        data = {
            'category': category,
            'description': description,
        }
        return render('/category/description.html', data,
                      overlay=format == 'overlay',
                      overlay_size=OVERLAY_SMALL)

    @RequireInstance
    def events(self, id, format=u'html'):
        if not c.instance.display_category_pages:
            abort(404)
        category = get_entity_or_abort(model.CategoryBadge, id)

        events = h.category.event_q(
            category,
            event_filter=request.params.getall('event_filter'),
            count=min(int(request.params.get('count', 50)), 100),
        ).all()

        enable_sorts = asbool(request.params.get('enable_sorts', 'true'))
        enable_pages = asbool(request.params.get('enable_pages', 'true'))
        row_type = request.params.get('row_type', 'row')

        if row_type not in ['row', 'profile_row', 'sidebar_row', 'tiny_row']:
            abort(400)

        data = {
            'event_pager': pager.events(events,
                                        enable_sorts=enable_sorts,
                                        enable_pages=enable_pages,
                                        row_type=row_type),
        }
        return render('/category/events.html', data,
                      overlay=format == 'overlay',
                      overlay_size=OVERLAY_SMALL)

    @RequireInstance
    def milestones(self, id, format=u'html'):
        if not c.instance.display_category_pages:
            abort(404)
        category = get_entity_or_abort(model.CategoryBadge, id)

        milestones = model.Milestone.all_future_q(instance=c.instance)\
            .filter(model.Milestone.category_id == category.id)\
            .limit(int(request.params.get('count', 50))).all()

        enable_sorts = asbool(request.params.get('enable_sorts', 'true'))
        enable_pages = asbool(request.params.get('enable_pages', 'true'))

        data = {
            'milestone_pager': pager.milestones(milestones,
                                                enable_sorts=enable_sorts,
                                                enable_pages=enable_pages),
        }
        return render('/category/milestones.html', data,
                      overlay=format == 'overlay',
                      overlay_size=OVERLAY_SMALL)

########NEW FILE########
__FILENAME__ = comment
import logging

import formencode
from formencode import htmlfill, Invalid, validators

from pylons import request, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import forms, model
from adhocracy.lib import democracy
from adhocracy.lib import event, helpers as h, sorting, tiles
from adhocracy.lib.auth import can, csrf, require, guard
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.pager import NamedPager
from adhocracy.lib.templating import (render, render_def, render_json,
                                      ret_abort, ret_success)
from adhocracy.lib.util import get_entity_or_abort

log = logging.getLogger(__name__)


class CommentNewForm(formencode.Schema):
    allow_extra_fields = True
    topic = forms.ValidDelegateable()
    reply = forms.ValidComment(if_empty=None, if_missing=None)
    wiki = validators.StringBool(not_empty=False, if_empty=False,
                                 if_missing=False)
    variant = forms.VariantName(not_empty=False, if_empty=model.Text.HEAD,
                                if_missing=model.Text.HEAD)


class CommentCreateForm(CommentNewForm):
    text = validators.String(max=21000, min=4, not_empty=True)
    sentiment = validators.Int(min=model.Comment.SENT_CON,
                               max=model.Comment.SENT_PRO, if_empty=0,
                               if_missing=0)


class CommentUpdateForm(formencode.Schema):
    allow_extra_fields = True
    text = validators.String(max=21000, min=4, not_empty=True)
    sentiment = validators.Int(min=model.Comment.SENT_CON,
                               max=model.Comment.SENT_PRO, if_empty=0,
                               if_missing=0)


class CommentRevertForm(formencode.Schema):
    allow_extra_fields = True
    to = forms.ValidRevision()


class CommentPurgeForm(formencode.Schema):
    allow_extra_fields = True
    rev = forms.ValidRevision()


class CommentController(BaseController):

    identifier = "comments"

    @RequireInstance
    @guard.comment.index()
    def index(self, format='html'):
        comments = model.Comment.all()
        c.comments_pager = NamedPager(
            'comments', comments, tiles.comment.row, count=10,
            sorts={_("oldest"): sorting.entity_oldest,
                   _("newest"): sorting.entity_newest},
            default_sort=sorting.entity_newest)

        if format == 'json':
            return render_json(c.comments_pager)
        else:
            return self.not_implemented(format=format)

    @RequireInstance
    @validate(schema=CommentNewForm(), form="bad_request",
              post_only=False, on_get=True)
    def new(self, errors=None, format='html'):
        c.topic = self.form_result.get('topic')
        c.reply = self.form_result.get('reply')
        c.wiki = self.form_result.get('wiki')
        c.variant = self.form_result.get('variant')
        defaults = dict(request.params)
        if c.reply:
            require.comment.reply(c.reply)
        else:
            require.comment.create_on(c.topic)

        if format == 'ajax':
            html = self._render_ajax_create_form(c.reply, c.topic, c.variant)
        else:
            html = render('/comment/new.html', overlay=format == u'overlay')
        return htmlfill.render(html, defaults=defaults,
                               errors=errors, force_defaults=False)

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @guard.comment.create()
    def create(self, format='html'):
        try:
            self.form_result = CommentCreateForm().to_python(request.params)
        except Invalid, i:
            return self.new(errors=i.unpack_errors(), format=format)

        topic = self.form_result.get('topic')
        if not topic.allow_comment:
            return ret_abort(
                _("Topic %s does not allow comments") % topic.title,
                code=400, format=format)

        reply = self.form_result.get('reply')
        if reply:
            require.comment.reply(reply)
        else:
            require.comment.create_on(topic)

        variant = self.form_result.get('variant')
        if hasattr(topic, 'variants') and variant not in topic.variants:
            return ret_abort(_("Comment topic has no variant %s") % variant,
                             code=400)

        comment = model.Comment.create(
            self.form_result.get('text'),
            c.user, topic,
            reply=reply,
            wiki=self.form_result.get('wiki'),
            variant=variant,
            sentiment=self.form_result.get('sentiment'),
            with_vote=can.user.vote())

        # watch comments by default!
        model.Watch.create(c.user, comment)
        model.meta.Session.commit()
        event.emit(event.T_COMMENT_CREATE, c.user, instance=c.instance,
                   topics=[topic], comment=comment, topic=topic,
                   rev=comment.latest)
        if c.came_from != u'':
            redirect(c.came_from + "#c" + str(comment.id))
        if format != 'html':
            return ret_success(entity=comment, format=format)
        else:
            return ret_success(entity=comment, format='fwd')

    @RequireInstance
    def edit(self, id, format='html'):
        c.comment = get_entity_or_abort(model.Comment, id)
        require.comment.edit(c.comment)
        extra_vars = {'comment': c.comment}
        if c.came_from != u'':
            extra_vars[u'came_from'] = c.came_from
        if format == 'ajax':
            return render_def('/comment/tiles.html', 'edit_form',
                              extra_vars=extra_vars)
        elif format == 'overlay':
            return render('/comment/edit.html', overlay=True)
        else:
            return render('/comment/edit.html')

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=CommentUpdateForm(), form="edit", post_only=True)
    def update(self, id, format='html'):
        c.comment = get_entity_or_abort(model.Comment, id)
        require.comment.edit(c.comment)
        rev = c.comment.create_revision(
            self.form_result.get('text'),
            c.user,
            sentiment=self.form_result.get('sentiment'))
        model.meta.Session.commit()
        if can.user.vote():
            decision = democracy.Decision(c.user, c.comment.poll)
            if not decision.result == model.Vote.YES:
                decision.make(model.Vote.YES)
        model.meta.Session.commit()

        # do not modify watch state as comments are always watched

        event.emit(event.T_COMMENT_EDIT, c.user, instance=c.instance,
                   topics=[c.comment.topic], comment=c.comment,
                   topic=c.comment.topic, rev=rev)
        if c.came_from != u'':
            redirect(c.came_from + "#c" + str(c.comment.id))
        if format != 'html':
            return ret_success(entity=c.comment, format=format)
        else:
            return ret_success(entity=c.comment, format='fwd')

    @RequireInstance
    def show(self, id, format='html'):
        c.comment = get_entity_or_abort(model.Comment, id)
        require.comment.show(c.comment)
        if format == 'fwd':
            redirect(h.entity_url(c.comment))
        elif format == 'json':
            return render_json(c.comment)
        return render('/comment/show.html', overlay=format == u'overlay')

    @RequireInstance
    def ask_delete(self, id, format=u'html'):
        c.comment = get_entity_or_abort(model.Comment, id)
        require.comment.delete(c.comment)
        return render('/comment/ask_delete.html',
                      overlay=format == u'overlay')

    @RequireInstance
    @csrf.RequireInternalRequest()
    def delete(self, id, format='html'):
        c.comment = get_entity_or_abort(model.Comment, id)
        require.comment.delete(c.comment)
        c.comment.delete()
        model.meta.Session.commit()

        event.emit(event.T_COMMENT_DELETE, c.user, instance=c.instance,
                   topics=[c.comment.topic], comment=c.comment,
                   topic=c.comment.topic)
        return ret_success(message=_("The comment has been deleted."),
                           entity=c.comment.topic,
                           format=format)

    @RequireInstance
    def history(self, id, format='html'):
        c.comment = get_entity_or_abort(model.Comment, id)
        require.comment.show(c.comment)
        c.revisions_pager = NamedPager(
            'revisions', c.comment.revisions, tiles.revision.row, count=10,
            sorts={_("oldest"): sorting.entity_oldest,
                   _("newest"): sorting.entity_newest},
            default_sort=sorting.entity_newest)

        if format == 'json':
            return render_json(c.revisions_pager)
        elif format == 'ajax':
            return c.revisions_pager.render_pager()
        elif format == 'overlay':
            return render('/comment/history.html', overlay=True)
        else:
            return render('/comment/history.html')

    @RequireInstance
    @csrf.RequireInternalRequest()
    @guard.perm("comment.edit")
    @validate(schema=CommentRevertForm(), form="history",
              post_only=False, on_get=True)
    def revert(self, id, format='html'):
        c.comment = get_entity_or_abort(model.Comment, id)
        require.comment.revert(c.comment)
        revision = self.form_result.get('to')
        if revision.comment != c.comment:
            return ret_abort(_("You're trying to revert to a revision which "
                               "is not part of this comment's history"),
                             code=400, format=format)
        rev = c.comment.create_revision(revision.text,
                                        c.user,
                                        sentiment=revision.sentiment)
        model.meta.Session.commit()
        event.emit(event.T_COMMENT_EDIT, c.user, instance=c.instance,
                   topics=[c.comment.topic], comment=c.comment,
                   topic=c.comment.topic, rev=rev)
        return ret_success(message=_("The comment has been reverted."),
                           entity=c.comment, format=format)

    @RequireInstance
    @csrf.RequireInternalRequest()
    @guard.perm("global.admin")
    @validate(schema=CommentPurgeForm(), form="history",
              post_only=False, on_get=True)
    def purge_history(self, id, format='html'):
        c.comment = get_entity_or_abort(model.Comment, id)

        require.comment.revert(c.comment)
        revision = self.form_result.get('rev')
        if revision.comment != c.comment:
            return ret_abort(_("You're trying to purge a revision which "
                               "is not part of this comment's history"),
                             code=400, format=format)

        model.meta.Session.delete(revision)
        model.meta.Session.commit()
        return ret_success(message=_("The comment revision has been deleted."),
                           entity=c.comment, format=format)

    def create_form(self, topic):
        topic = model.Delegateable.find(int(topic))
        if topic is None:
            return ret_abort(_('Wrong topic'))  # FIXME: better msg
        require.comment.create_on(topic)
        variant = request.params.get('variant', None)
        if hasattr(topic, 'variants') and variant not in topic.variants:
            return ret_abort(_("Comment topic has no variant %s") % variant,
                             code=400)
        return self._render_ajax_create_form(None, topic, variant)

    def _render_ajax_create_form(self, parent, topic, variant, came_from=None):
        '''
        render a create form fragment that can be inserted loaded
        into another page.
        '''
        if came_from is None:
            came_from = ''

        # FIXME: uncomment the format parameter when we have javascript
        # code to submit the form with ajax and replace the form with the
        # response
        # For now, it renders the form with error messages or redirects
        # the user to the new comments anchor on success
        template_args = dict(parent=parent,
                             topic=topic,
                             variant=variant,
                             # format="ajax",
                             came_from=came_from,
                             )
        return render_def('/comment/tiles.html', 'create_form',
                          extra_vars=template_args)

    def reply_form(self, id):
        parent = get_entity_or_abort(model.Comment, int(id))
        require.comment.reply(parent)
        topic = parent.topic
        variant = getattr(topic, 'variant', None)
        came_from = c.came_from
        return self._render_ajax_create_form(parent, topic, variant, came_from)

########NEW FILE########
__FILENAME__ = debug
from pylons import request, tmpl_context as c

from adhocracy import config
from adhocracy.lib.base import BaseController
from adhocracy.lib.helpers import json_loads
from adhocracy.lib.templating import render
from adhocracy.model.meta import engine


class DebugController(BaseController):

    def explain(self):
        if not config.get_bool('adhocracy.debug.sql'):
            raise ValueError('Not in debugging mode')
        statement = request.params.get('statement')
        if not statement.lower().startswith('select'):
            raise ValueError('We explain only select statements')
        parameters = request.params.get('parameters')
        c.parameters = json_loads(parameters)

        # collect explain results
        if engine.name.startswith('sqlite'):
            explain_query = 'EXPLAIN QUERY PLAN %s' % statement
        else:
            explain_query = 'EXPLAIN %s' % statement

        explain_result = engine.execute(explain_query, c.parameters)
        data_result = engine.execute(statement, c.parameters)
        c.results = []
        for (title, result) in (('Explain', explain_result),
                                ('Data', data_result)):
            c.results.append({'title': title,
                              'result': result.fetchall(),
                              'headers': result.keys()})

        # other data to display
        c.statement = statement
        c.duration = float(request.params['duration'])

        return render('/debug/explain.html')

    def components(self):
        if not config.get_bool('debug'):
            raise ValueError('Not in debugging mode')
        else:
            return render('/debug/components.html')

########NEW FILE########
__FILENAME__ = delegation
import logging

from formencode import validators, foreach, Schema

from pylons import tmpl_context as c, response
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import forms, model
from adhocracy.lib import democracy
from adhocracy.lib import event, helpers as h, pager, sorting, tiles
from adhocracy.lib.auth import csrf, require
from adhocracy.lib.auth import guard
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.templating import (render, render_json, ret_abort,
                                      ret_success)
from adhocracy.lib.util import get_entity_or_abort


log = logging.getLogger(__name__)


class DelegationNewForm(Schema):
    allow_extra_fields = True
    scope = forms.ValidDelegateable()


class DelegationCreateForm(DelegationNewForm):
    agent = foreach.ForEach(forms.ExistingUserName())
    replay = validators.Int(if_empty=1, if_missing=1, not_empty=False)


class DelegationController(BaseController):

    identifier = "delegations"

    @RequireInstance
    @guard.delegation.index()
    def index(self, format='html'):
        c.delegations = model.Delegation.all(instance=c.instance)
        if format == 'dot':
            c.users = model.User.all(instance=c.instance)
            response.content_type = "text/plain"
            return render("/delegation/graph.dot")
        elif format == 'json':
            c.delegations_pager = pager.delegations(c.delegations)
            return render_json(c.delegations_pager)
        else:
            return self.not_implemented(format=format)

    @RequireInstance
    @validate(schema=DelegationNewForm(), form="bad_request",
              post_only=False, on_get=True)
    def new(self, format=u'html'):
        c.scope = self.form_result.get('scope')
        require.delegation.create(c.scope)
        return render("/delegation/new.html", overlay=format == u'overlay')

    @RequireInstance
    @csrf.RequireInternalRequest(methods=["POST"])
    @validate(schema=DelegationCreateForm(), form="new", post_only=True)
    def create(self, format='html'):
        c.scope = self.form_result.get('scope')
        require.delegation.create(c.scope)
        agents = filter(lambda f: f is not None, self.form_result.get('agent'))
        if not len(agents) or agents[0] == c.user:
            h.flash(_("Invalid delegation recipient"), 'error')
            return self.new()

        existing = model.Delegation.find_by_agent_principal_scope(agents[0],
                                                                  c.user,
                                                                  c.scope)
        if existing is not None:
            h.flash(_("You have already delegated voting to %s in %s") %
                    (agents[0].name, c.scope.label),
                    'notice')
            return self.new()

        delegation = model.Delegation.create(
            c.user, agents[0], c.scope,
            replay=self.form_result.get('replay') == 1)
        model.meta.Session.commit()

        event.emit(event.T_DELEGATION_CREATE, c.user,
                   instance=c.instance,
                   topics=[c.scope], scope=c.scope,
                   agent=agents[0], delegation=delegation)

        return ret_success(entity=delegation.scope, format=format)

    @RequireInstance
    @csrf.RequireInternalRequest()
    def delete(self, id):
        c.delegation = get_entity_or_abort(model.Delegation, id)
        require.delegation.delete(c.delegation)
        if not c.delegation.principal == c.user:
            return ret_abort(_("Cannot access delegation %(id)s") %
                             {'id': id}, code=403)
        c.delegation.revoke()
        model.meta.Session.commit()
        event.emit(event.T_DELEGATION_REVOKE, c.user,
                   topics=[c.delegation.scope],
                   scope=c.delegation.scope, instance=c.instance,
                   agent=c.delegation.agent)
        return ret_success(message=_("The delegation is now revoked."),
                           entity=c.delegation.scope)

    @RequireInstance
    def show(self, id, format='html'):
        c.delegation = get_entity_or_abort(model.Delegation, id)
        require.delegation.show(c.delegation)
        c.scope = c.delegation.scope
        decisions = democracy.Decision.for_user(c.delegation.principal,
                                                c.instance)
        decisions = filter(lambda d: c.delegation in d.delegations, decisions)
        decisions = filter(lambda d: isinstance(d.poll.subject,
                                                model.Proposal),
                           decisions)
        c.decisions_pager = pager.NamedPager(
            'decisions', decisions, tiles.decision.user_row,
            sorts={_("oldest"): sorting.entity_oldest,
                   _("newest"): sorting.entity_newest},
            default_sort=sorting.entity_newest)

        if format == 'json':
            return render_json((c.delegation, c.decisions_pager))
        elif format == 'overlay':
            return render("delegation/show.html", overlay=True)
        else:
            return render("delegation/show.html")

    @RequireInstance
    def edit(self, format='html'):
        return self.not_implemented(format=format)

    @RequireInstance
    def update(self, format='html'):
        return self.not_implemented(format=format)

########NEW FILE########
__FILENAME__ = error
import cgi
import re

from pylons import request, response, tmpl_context as c
from pylons.i18n import _
from pylons.i18n import lazy_ugettext
from pylons.controllers.util import abort

from paste.urlparser import PkgResourcesParser
from pylons.controllers.util import forward

from adhocracy import config
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render

BODY_RE = re.compile("<br \/><br \/>(.*)<\/body", re.S)


ERROR_MESSAGES = {
    404: lazy_ugettext(u"The requested page could not be found."),
    503: lazy_ugettext(u"The system is currently down for maintenance. "
                       u"Please check back soon!"),
}
ERROR_NAMES = {
    400: lazy_ugettext('Bad Request'),
    401: lazy_ugettext('Unauthorized'),
    403: lazy_ugettext('Forbidden'),
    404: lazy_ugettext('Not Found'),
    418: lazy_ugettext('I\'m a teapot'),
    500: lazy_ugettext('Internal Server Error'),
    503: lazy_ugettext('Service Unavailable'),
}


class ErrorController(BaseController):

    """Generates error documents as and when they are required.

    The StatusCodeRedirect middleware forwards to ErrorController when error
    related status codes are returned from the application.

    This behaviour can be altered by changing the parameters to the
    StatusCodeRedirect middleware in your config/middleware.py file.

    """

    identifier = "error"

    def document(self):
        resp = request.environ.get('pylons.original_response')
        if resp is None:
            raise abort(404)
        response.status = resp.status
        if resp.content_type == 'text/javascript':
            response.content_type == resp.content_type
            return resp.body

        c.error_code = resp.status_int

        c.hide_notify = (c.error_code not in [400, 500])

        # Try to extract error message from environment, e.g.
        # adhocracy.lib.templating.ret_status sets this.
        c.error_message = request.environ.get('adhocracy.error_message')

        if not c.error_message:
            # Try to extract error message from stub response
            for match in BODY_RE.finditer(resp.body):
                c.error_message = match.group(1).strip()

        if not c.error_message:
            # Fallback to default empty message
            c.error_message = ERROR_MESSAGES.get(c.error_code, '')

        c.error_name = ERROR_NAMES.get(c.error_code, '')

        if config.get_bool('adhocracy.interactive_debugging'):
            c.trace_url = request.environ['pylons.original_response']\
                .headers.get('X-Debug-URL', None)

            if c.trace_url is not None:
                # this may only happen in debug mode
                assert(config.get_bool('debug', False))
        else:
            c.trace_url = None

        return render("/error/http.html")

    def show(self):
        """Force an error message.

        Always return status 200, but render the HTML error message.
        """
        if not config.get_bool('debug'):
            raise abort(404)
        status = request.GET.get('force_status')
        if status is None:
            raise abort(404)
        data = {
            'hide_code': 'hide_code' in request.GET,
            'hide_notify': 'hide_notify' in request.GET,
            'error_code': int(status),
            'error_name': ERROR_NAMES.get(int(status), ''),
            'error_message': ERROR_MESSAGES.get(int(status), ''),
        }
        return render("/error/http.html", data)

    def img(self, id):
        """Serve Pylons' stock images"""
        return self._serve_file('/'.join(['media/img', id]))

    def style(self, id):
        """Serve Pylons' stock stylesheets"""
        return self._serve_file('/'.join(['media/style', id]))

    def _serve_file(self, path):
        """Call Paste's FileApp (a WSGI application) to serve the file
        at the specified path
        """
        request.environ['PATH_INFO'] = '/%s' % path
        return forward(PkgResourcesParser('pylons', 'pylons'))

########NEW FILE########
__FILENAME__ = event
import logging

from pylons import request, tmpl_context as c
from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import event, helpers as h
from adhocracy.lib import pager
from adhocracy.lib.auth import require
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render, render_def
from adhocracy.lib.templating import OVERLAY_SMALL

log = logging.getLogger(__name__)


class EventController(BaseController):

    identifier = 'events'

    def all(self, format='html'):
        if c.instance is None:
            require.perm('event.index_all')

        events = model.Event.all_q(
            instance=c.instance,
            include_hidden=False,
            event_filter=request.params.getall('event_filter'))\
            .order_by(model.Event.time.desc())\
            .limit(min(int(request.params.get('count', 50)), 100)).all()

        if format == 'rss':
            return event.rss_feed(events,
                                  _('%s News' % h.site.name()),
                                  h.base_url(instance=None),
                                  _("News from %s") % h.site.name())

        elif format == 'ajax':
            query_params = request.params.copy()
            while True:
                try:
                    query_params.pop('count')
                except KeyError:
                    break

            more_url = h.base_url(instance=c.instance,
                                  member='event/all',
                                  query_params=query_params)
            return render_def('/event/tiles.html', 'carousel',
                              events=events, more_url=more_url)
        else:
            c.event_pager = pager.events(events, count=50)

            if format == 'overlay':
                return render('/event/all.html', overlay=True,
                              overlay_size=OVERLAY_SMALL)
            else:
                return render('/event/all.html')

    def carousel(self, format=u'html'):
        if c.instance is None:
            require.perm('event.index_all')

        data = {
            u'data_url': h.base_url('/event/all', query_params=request.params)
        }

        return render('/event/carousel.html', data,
                      overlay=format == u'overlay',
                      overlay_size=OVERLAY_SMALL)

########NEW FILE########
__FILENAME__ = instance
from collections import OrderedDict
import logging

from webob.multidict import MultiDict

import formencode
from formencode import htmlfill
from formencode import validators

from pylons import request, response, tmpl_context as c
from pylons.controllers.util import abort, redirect
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import config
from adhocracy import forms, i18n, model
from adhocracy.controllers.admin import UserImportForm
from adhocracy.controllers.badge import BadgeController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib import event, helpers as h, logo, pager, sorting, tiles
from adhocracy.lib import votedetail
from adhocracy.lib.settings import INSTANCE_UPDATED_MSG
from adhocracy.lib.settings import NO_UPDATE_REQUIRED
from adhocracy.lib.settings import error_formatter
from adhocracy.lib.settings import Menu
from adhocracy.lib.settings import update_attributes
from adhocracy.lib.auth import can, csrf, require, guard
from adhocracy.lib.base import BaseController
from adhocracy.lib.queue import update_entity
from adhocracy.lib.staticpage import get_static_page
from adhocracy.lib.staticpage import render_body
from adhocracy.lib.templating import (render, render_json, render_logo,
                                      ret_abort, ret_success, render_def)
from adhocracy.lib.templating import OVERLAY_SMALL
from adhocracy.lib.user_import import user_import, get_user_import_state
from adhocracy.lib.util import get_entity_or_abort


log = logging.getLogger(__name__)


PRESETS = {
    'agenda_setting': set((
        'allow_delegate',
        'show_proposals_navigation',
    )),
    'consultation': set((
        'use_norms',
        'show_norms_navigation',
    )),
    'planning_ideas': set((
        'allow_delegate',
        'milestones',
    )),
    # Only settings which are part of at least one preset will be changed.
    # Add settings to this pseudo-preset to disable it on every reset
    'always_off': set((
        'hide_global_categories',
        'display_category_pages',
        'allow_propose',
        'allow_propose_changes',
        'require_selection',
    )),
}


def settings_url(instance, path):
    full_path = 'settings/%s' % path
    return h.instance.url(instance, member=full_path)


def settings_menu(instance, current):

    return Menu.create(instance, current, OrderedDict([
        ('overview', (_(u'Overview'),)),
        ('general', (_('General settings'),)),
        ('process', (_('Process settings'),)),
        ('members', (_('Manage members'),)),
        ('advanced', (_('Advanced settings'),)),
        ('presets', (_('Process presets'),)),
    ]))


class InstanceBadgesForm(formencode.Schema):
    allow_extra_fields = True
    badge = formencode.foreach.ForEach(forms.ValidInstanceBadge())


class InstanceCreateForm(formencode.Schema):
    allow_extra_fields = True
    key = formencode.All(
        validators.String(
            min=config.get_int('adhocracy.instance_key_length_min'),
            max=config.get_int('adhocracy.instance_key_length_max')),
        forms.UniqueInstanceKey())
    label = validators.String(min=4, max=254, not_empty=True)
    description = validators.String(max=100000, if_empty=None, not_empty=False)


class InstanceOverviewEditForm(formencode.Schema):
    allow_extra_fields = True
    label = validators.String(min=4, max=254, not_empty=True)
    description = validators.String(max=100000, if_empty=None, not_empty=False)
    logo_as_background = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)


class InstanceGeneralEditForm(formencode.Schema):
    allow_extra_fields = True
    allow_delegate = validators.StringBool(not_empty=False, if_empty=False,
                                           if_missing=False)
    milestones = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    display_category_pages = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    locale = forms.ValidLocale()
    theme = validators.String(not_empty=False, if_empty=None, if_missing=None)


class InstanceProcessEditForm(formencode.Schema):
    allow_extra_fields = True
    allow_propose = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    allow_propose_changes = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    show_norms_navigation = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    show_proposals_navigation = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    use_norms = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)


class InstanceMembersEditForm(formencode.Schema):
    allow_extra_fields = True
    require_valid_email = validators.StringBool(not_empty=False,
                                                if_empty=False,
                                                if_missing=False)
    default_group = forms.ValidInstanceGroup(not_empty=True)


class InstanceAdvancedEditForm(formencode.Schema):
    allow_extra_fields = True
    editable_comments_default = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    editable_proposals_default = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    require_selection = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    hide_global_categories = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    page_index_as_tiles = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    votedetail_badges = forms.ValidUserBadges()
    hidden = validators.StringBool(not_empty=False, if_empty=False,
                                   if_missing=False)
    # currently no ui
    # allow_index = validators.StringBool(
    #     not_empty=False, if_empty=False, if_missing=False)
    frozen = validators.StringBool(
        not_empty=False, if_empty=False, if_missing=False)
    css = validators.String(max=100000, if_empty=None, not_empty=False,
                            if_missing=None)
    thumbnailbadges_width = validators.Int(not_empty=False, if_empty=None,
                                           if_missing=None)
    thumbnailbadges_height = validators.Int(not_empty=False, if_empty=None,
                                            if_missing=None)
    is_authenticated = validators.StringBool(not_empty=False, if_empty=False,
                                             if_missing=False)


class InstanceBadgesEditForm(formencode.Schema):
    allow_extra_fields = True


class InstanceSnameEditForm(formencode.Schema):
    allow_extra_fields = True
    pass


class InstancePresetsForm(formencode.Schema):
    allow_extra_fields = True
    agenda_setting = validators.StringBool(not_empty=False, if_empty=False,
                                           if_missing=False)
    consultation = validators.StringBool(not_empty=False, if_empty=False,
                                         if_missing=False)
    chained_validators = [
        forms.common.NotAllFalse(PRESETS.keys(),
                                 _(u"Please select at least one preset")),
    ]


# --[ Controller ]----------------------------------------------------------

class InstanceController(BaseController):

    identifier = 'instances'

    @guard.instance.index()
    def index(self, format="html"):

        c.active_global_nav = 'instances'

        include_hidden = h.has_permission('global.admin')
        c.instance_pager = pager.solr_instance_pager(include_hidden)

        if format == 'json':
            return render_json(c.instance_pager)

        c.tile = tiles.instance.InstanceTile(c.instance)
        if format == 'overlay':
            return render("/instance/index.html", overlay=True)
        else:
            return render("/instance/index.html")

    @guard.instance.create()
    def new(self, format=u'html'):

        data = {}
        protocol = config.get('adhocracy.protocol').strip()
        domain = config.get('adhocracy.domain').strip()

        if config.get_bool('adhocracy.relative_urls'):
            data['url_pre'] = '%s://%s/i/' % (protocol, domain)
            data['url_post'] = ''
            data['url_right_align'] = False
        else:
            data['url_pre'] = '%s://' % protocol
            data['url_post'] = '.%s' % domain
            data['url_right_align'] = True

        return render("/instance/new.html", data,
                      overlay=format == u'overlay')

    @csrf.RequireInternalRequest(methods=['POST'])
    @guard.instance.create()
    @validate(schema=InstanceCreateForm(), form="new", post_only=True)
    def create(self, format='html'):
        instance = model.Instance.create(
            self.form_result.get('key'), self.form_result.get('label'),
            c.user, description=self.form_result.get('description'),
            locale=c.locale)
        model.meta.Session.commit()
        event.emit(event.T_INSTANCE_CREATE, c.user, instance=instance)
        return redirect(h.entity_url(instance, member='presets'))

    # @RequireInstance
    def show(self, id, format='html'):
        c.page_instance = get_entity_or_abort(model.Instance, id)
        require.instance.show(c.page_instance)

        if format == 'json':
            return render_json(c.page_instance)
        elif format == 'rss':
            return self.activity(id, format)

        if c.page_instance != c.instance:
            redirect(h.entity_url(c.page_instance))

        static_path = config.get(
            'adhocracy.instance-%s.static_overview_path' % c.page_instance.key,
            None)
        if static_path is not None:
            page = get_static_page(static_path)
            if page is None:
                return abort(404, _('The requested page was not found'))
            data = {
                'static': page,
                'body_html': render_body(page.body),
                'full_width': True,
            }
            if not data['static'].title:
                if h.config.get_bool('adhocracy.wording.intro_for_overview'):
                    data['static'].title = _(u'Intro')
                else:
                    data['static'].title = _(u'Overview')
            c.body_css_classes += page.css_classes
            return render("/static/show.html", data,
                          overlay=format == 'overlay')

        c.tile = tiles.instance.InstanceTile(c.page_instance)
        c.sidebar_delegations = (_('Delegations are enabled.') if
                                 c.page_instance.allow_delegate else
                                 _('Delegations are disabled.'))

        overview_contents = config.get_list(
            'adhocracy.instance_overview_contents')
        overview_sidebar_contents = config.get_list(
            'adhocracy.instance_overview_sidebar_contents')

        if u'milestones' in overview_contents and c.page_instance.milestones:

            number = config.get_int(
                'adhocracy.number_instance_overview_milestones')

            milestones = model.Milestone.all_future_q(
                instance=c.page_instance).limit(number).all()

            c.next_milestones_pager = pager.milestones(
                milestones, size=number, enable_sorts=False,
                enable_pages=False, default_sort=sorting.milestone_time)

        c.events_pager = None
        if u'events' in overview_contents:
            events = model.Event.find_by_instance(c.page_instance, limit=10)
            c.events_pager = pager.events(events,
                                          enable_pages=False,
                                          enable_sorts=False)

        c.sidebar_events_pager = None
        if u'events' in overview_sidebar_contents:
            events = model.Event.find_by_instance(c.page_instance, limit=3)
            c.sidebar_events_pager = pager.events(events,
                                                  enable_pages=False,
                                                  enable_sorts=False,
                                                  row_type=u'sidebar_row')

        c.proposals_pager = None
        if u'proposals' in overview_contents:
            proposals = model.Proposal.all(instance=c.page_instance)

            if config.get_bool(
                    'adhocracy.show_instance_overview_proposals_all'):
                c.proposals_pager = pager.proposals(proposals, size=100,
                                                    initial_size=100)
            else:
                c.proposals_pager = pager.proposals(
                    proposals, size=7, enable_sorts=False,
                    enable_pages=False, default_sort=sorting.entity_newest)

        c.stats = None
        if config.get_bool('adhocracy.show_instance_overview_stats'):
            c.stats = {
                'comments': model.Comment.all_q().count(),
                'proposals': model.Proposal.all_q(
                    instance=c.page_instance).count(),
                'members': model.Membership.all_q().count()
            }

        c.tutorial_intro = _('tutorial_instance_show_intro')
        c.tutorial = 'instance_show'

        if c.page_instance.hidden:
            h.flash(_(u"This instance is not yet open for public "
                      u"participation."), 'warning')
        elif c.page_instance.frozen:
            h.flash(_(u"This instance is not active for use and is archived. "
                      u"It isn't possible to perform any changes to the "
                      u"instance, but all content is available to be read."),
                    'warning')

        if format == 'overlay':
            return render("/instance/show.html", overlay=True)
        else:
            return render("/instance/show.html")

    @RequireInstance
    def activity(self, id, format='html'):
        """ deprecated in favour of /event/all """
        return redirect(h.base_url('/event/all.' + format,
                                   query_params=request.params),
                        code=301)

    @RequireInstance
    def edit(self, id):
        # This is deprecated, but the route is still created as
        # by routes' .resource()
        c.page_instance = self._get_current_instance(id)
        redirect(h.instance.url(c.page_instance, member='settings'))

    def update(self, id, format='html'):
        # This is deprecated, but the route is still created as
        # by routes' .resource()
        return self.edit(id)

    @classmethod
    def _editable_badges(cls, instance):
        '''
        Return the badges editable that can be assigned by the current
        user.
        '''
        badges = []
        if can.badge.edit_global():
            badges.extend(model.InstanceBadge.all(instance=None))
        badges = sorted(badges, key=lambda badge: badge.title)
        return badges

    @guard.perm("global.admin")
    def badges(self, id, errors=None, format='html'):
        c.page_instance = get_entity_or_abort(model.Instance, id)
        c.badges = self._editable_badges(c.page_instance)
        defaults = {
            'badge': [str(badge.id) for badge in c.page_instance.badges],
            '_tok': csrf.token_id(),
        }
        if format == 'ajax':
            checked = [badge.id for badge in c.page_instance.badges]
            json = {'title': c.page_instance.label,
                    'badges': [{
                        'id': badge.id,
                        'description': badge.description,
                        'title': badge.title,
                        'checked': badge.id in checked} for badge in c.badges]}
            return render_json(json)
        else:
            return formencode.htmlfill.render(
                render("/instance/badges.html", overlay=format == u'overlay',
                       overlay_size=OVERLAY_SMALL),
                defaults=defaults)

    @validate(schema=InstanceBadgesForm(), form='badges')
    @guard.perm("global.admin")
    @csrf.RequireInternalRequest(methods=['POST'])
    def update_badges(self, id, format='html'):
        instance = get_entity_or_abort(model.Instance, id)
        editable_badges = self._editable_badges(instance)
        badges = self.form_result.get('badge')
        # remove badges
        for badge in instance.badges:
            if badge not in editable_badges:
                # the user can not edit the badge, so we don't remove it
                continue
            if badge not in badges:
                instance.badges.remove(badge)
        # add badges
        for badge in badges:
            if badge not in instance.badges:
                badge.assign(instance, c.user)

        model.meta.Session.commit()
        update_entity(instance, model.UPDATE)
        if format == 'ajax':
            obj = {'html': render_def('/badge/tiles.html', 'badges',
                                      badges=instance.badges)}
            return render_json(obj)

    def _settings_result(self, updated, instance, setting_name, message=None):
        '''
        Sets a redirect code and location header, stores a flash
        message and returns the message. If *message* is not None, a
        message is chosen depending on the boolean value of
        *updated*. The redirect *location* URL is chosen based on the
        instance and *setting_name*.

        This method will *not raise an redirect exception* but set the
        headers and return the message string.

        *updated* (bool)
           Indicate that a value was updated. Used to choose a generic
           message if *message* is not given explicitly.
        *instance* (:class:`adhocracy.model.Instance`)
           The instance to generate the redirct URL for.
        *setting_name* (str)
           The setting name for which the URL will be build.
        *message* (unicode)
           An explicit message to use instead of the generic message.

        Returns
           The message generated or given.
        '''
        if updated:
            event.emit(event.T_INSTANCE_EDIT, c.user, instance=c.page_instance)
            message = message if message else unicode(INSTANCE_UPDATED_MSG)
            category = 'success'
        else:
            message = message if message else unicode(NO_UPDATE_REQUIRED)
            category = 'notice'
        h.flash(message, category=category)
        response.status_int = 303
        url = settings_menu(instance, setting_name).url_for(setting_name)
        response.headers['location'] = url
        return unicode(message)

    @guard.perm('instance.index')
    def icon(self, id, y=24, x=None):
        instance = get_entity_or_abort(model.Instance, id,
                                       instance_filter=False)
        return render_logo(instance, y, x=x, fallback=logo.INSTANCE)

    @RequireInstance
    def settings_legacy(self, id, format=u'html'):
        instance = self._get_current_instance(id)
        require.instance.edit(instance)
        redirect(h.entity_url(instance, member='settings/overview'), code=301)

    def _settings_overview_form(self, id):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, 'overview')

        c.current_logo = None
        if tiles.instance.InstanceTile(c.page_instance).show_icon():
            c.current_logo = h.logo_url(c.page_instance, 48)

        return render("/instance/settings_overview.html")

    @RequireInstance
    def settings_overview(self, id, format=u'html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit_overview(c.page_instance)
        form_content = self._settings_overview_form(id)
        return htmlfill.render(
            form_content,
            defaults={
                '_method': 'PUT',
                'label': c.page_instance.label,
                'description': c.page_instance.description,
                'logo_as_background': c.page_instance.logo_as_background,
                '_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstanceOverviewEditForm(),
              form="_settings_overview_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_overview_update(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit_overview(c.page_instance)

        # delete the logo if the button was pressed and exit
        if 'delete_logo' in self.form_result:
            updated = logo.delete(c.page_instance)
            return self._settings_result(
                updated, c.page_instance, 'overview',
                message=_(u'The logo has been deleted.'))

        updated = update_attributes(c.page_instance, self.form_result,
                                    ['description', 'label'])

        if c.page_instance.is_authenticated:
            auth_updated = update_attributes(c.page_instance,
                                             self.form_result,
                                             ['logo_as_background'])
            updated = updated or auth_updated

        try:
            # fixme: show logo errors in the form
            if ('logo' in request.POST and
                hasattr(request.POST.get('logo'), 'file') and
                    request.POST.get('logo').file):
                logo.store(c.page_instance, request.POST.get('logo').file)
                updated = True
        except Exception, e:
            model.meta.Session.rollback()
            h.flash(unicode(e), 'error')
            log.debug(e)
            return self.settings_overview(id)

        return self._settings_result(updated, c.page_instance, 'overview')

    def _settings_general_form(self, id):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, 'general')

        c.locales = []
        for locale in i18n.LOCALES:
            c.locales.append({'value': str(locale),
                              'label': locale.language_name,
                              'selected': locale == c.page_instance.locale})

        return render("/instance/settings_general.html")

    @RequireInstance
    def settings_general(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)
        cat_badge_data = self.badge_controller(c.page_instance, 'general')\
            ._get_badge_data('category')
        c.category_badge_tables = render_def('/badge/index.html',
                                             'render_context_tables',
                                             cat_badge_data)
        theme = '' if c.page_instance.theme is None else c.page_instance.theme

        return htmlfill.render(
            self._settings_general_form(id),
            defaults={
                '_method': 'PUT',
                'allow_delegate': c.page_instance.allow_delegate,
                'milestones': c.page_instance.milestones,
                'display_category_pages':
                c.page_instance.display_category_pages,
                'locale': c.page_instance.locale,
                'theme': theme,
                '_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstanceGeneralEditForm(),
              Form="_settings_general_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_general_update(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        updated = update_attributes(c.page_instance, self.form_result,
                                    ['allow_delegate', 'locale', 'milestones',
                                     'display_category_pages'])

        stylesheets = config.get_list('adhocracy.instance_stylesheets')
        themes = config.get_list('adhocracy.instance_themes')
        if (c.page_instance.is_authenticated and themes
                and c.page_instance.key not in stylesheets):
            auth_updated = update_attributes(c.page_instance,
                                             self.form_result,
                                             ['theme'])
            updated = updated or auth_updated

        return self._settings_result(updated, c.page_instance, 'general')

    def _settings_process_form(self, id):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, 'process')

        return render("/instance/settings_process.html")

    @RequireInstance
    def settings_process(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)
        thumb_badge_data = self.badge_controller(c.page_instance, 'process')\
            ._get_badge_data('thumbnail')
        c.thumbnail_badge_tables = render_def('/badge/index.html',
                                              'render_context_tables',
                                              thumb_badge_data)
        deleg_badge_data = self.badge_controller(c.page_instance, 'process')\
            ._get_badge_data('delegateable')
        c.delegateable_badge_tables = render_def('/badge/index.html',
                                                 'render_context_tables',
                                                 deleg_badge_data)
        return htmlfill.render(
            self._settings_process_form(id),
            defaults={
                '_method': 'PUT',
                'allow_propose': c.page_instance.allow_propose,
                'allow_propose_changes': c.page_instance.allow_propose_changes,
                'show_norms_navigation': c.page_instance.show_norms_navigation,
                'show_proposals_navigation':
                c.page_instance.show_proposals_navigation,
                'use_norms': c.page_instance.use_norms,
                '_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstanceProcessEditForm(),
              Form="_settings_process_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_process_update(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        updated = update_attributes(
            c.page_instance, self.form_result,
            ['allow_propose', 'allow_propose_changes', 'use_norms',
             'show_norms_navigation', 'show_proposals_navigation'])

        return self._settings_result(updated, c.page_instance, 'process')

    def _settings_members_form(self, id):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, 'members')

        c.default_group_options = []
        c.default_group = (c.page_instance.default_group.code if
                           c.page_instance.default_group else
                           model.Group.INSTANCE_DEFAULT)

        for groupname in model.Group.INSTANCE_GROUPS:
            group = model.Group.by_code(groupname)
            c.default_group_options.append(
                {'value': group.code,
                 'label': h.literal(_(group.group_name)),
                 'selected': group.code == c.default_group})

        return render("/instance/settings_members.html")

    @RequireInstance
    def settings_members(self, id):
        c.page_instance = self._get_current_instance(id)
        badge_data = self.badge_controller(c.page_instance, 'members')\
            ._get_badge_data('user')
        c.user_badge_tables = render_def('/badge/index.html',
                                         'render_context_tables',
                                         badge_data)

        require.instance.edit(c.page_instance)
        return htmlfill.render(
            self._settings_members_form(id),
            defaults={
                '_method': 'PUT',
                'require_valid_email': c.page_instance.require_valid_email,
                'default_group': c.default_group,
                '_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstanceMembersEditForm(),
              form="_settings_members_form",
              post_only=True)
    def settings_members_update(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        updated = update_attributes(
            c.page_instance, self.form_result, ['require_valid_email',
                                                'default_group'])

        return self._settings_result(updated, c.page_instance, 'members')

    def _settings_advanced_form(self, id):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, 'advanced')

        if votedetail.is_enabled():
            c.votedetail_all_userbadges = model.UserBadge.all(
                instance=c.page_instance, include_global=True)
        else:
            c.votedetail_all_userbadges = None

        return render("/instance/settings_advanced.html")

    @RequireInstance
    def settings_advanced(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        query_params = MultiDict([
            ('event_filter', 't_proposal_create'),
            ('event_filter', 't_page_create'),
            ('event_filter', 't_comment_create'),
        ])
        embed_url = h.base_url('/event/carousel.overlay',
                               query_params=query_params, absolute=True)
        embed_code = ('<iframe src="%s" frameborder="0" width="320"'
                      ' height="320"></iframe>' % embed_url)

        defaults = {
            '_method': 'PUT',
            'editable_comments_default':
            c.page_instance.editable_comments_default,
            'editable_proposals_default':
            c.page_instance.editable_proposals_default,
            'require_selection': c.page_instance.require_selection,
            'hide_global_categories': c.page_instance.hide_global_categories,
            'page_index_as_tiles': c.page_instance.page_index_as_tiles,
            'hidden': c.page_instance.hidden,
            'frozen': c.page_instance.frozen,
            'css': c.page_instance.css,
            'thumbnailbadges_width':
            c.page_instance.thumbnailbadges_width,
            'thumbnailbadges_height':
            c.page_instance.thumbnailbadges_height,
            'is_authenticated': c.page_instance.is_authenticated,
            'embed_code': embed_code,
            '_tok': csrf.token_id()}
        if votedetail.is_enabled():
            defaults['votedetail_badges'] = [
                b.id for b in c.page_instance.votedetail_userbadges]
        return htmlfill.render(
            self._settings_advanced_form(id),
            defaults=defaults)

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstanceAdvancedEditForm(),
              form="_settings_advanced_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_advanced_update(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        updated = update_attributes(
            c.page_instance, self.form_result,
            ['editable_comments_default', 'editable_proposals_default',
             'require_selection', 'hide_global_categories', 'hidden',
             'frozen', 'page_index_as_tiles'])
        # currently no ui for allow_index

        if h.has_permission('global.admin'):
            auth_updated = update_attributes(c.page_instance, self.form_result,
                                             ['css',
                                              'thumbnailbadges_width',
                                              'thumbnailbadges_height',
                                              'is_authenticated'])
            updated = updated or auth_updated

        if votedetail.is_enabled():
            new_badges = self.form_result['votedetail_badges']
            updated_vd = c.page_instance.votedetail_userbadges != new_badges
            if updated_vd:
                c.page_instance.votedetail_userbadges = new_badges
            updated = updated or updated_vd

        return self._settings_result(updated, c.page_instance, 'advanced')

    def badge_controller(self, instance, settings_part):
        '''
        ugly hack to dispatch to the badge controller.
        '''
        controller = BadgeController()
        controller.index_template = 'instance/settings_badges.html'
        controller.form_template = 'instance/settings_badges_form.html'
        controller.base_url_ = settings_url(instance, settings_part)
        controller._py_object = self._py_object
        controller.start_response = self.start_response
        return controller

    @RequireInstance
    def settings_badges_add(self, id, part, badge_type, format='html'):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, part)
        controller = self.badge_controller(c.page_instance, part)
        return controller.add(badge_type=badge_type, format=format)

    @RequireInstance
    def settings_badges_create(self, id, part, badge_type, format='html'):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, part)
        controller = self.badge_controller(c.page_instance, part)
        return controller.create(badge_type=badge_type, format=format)

    @RequireInstance
    def settings_badges_edit(self, id, part, badge_id, format='html'):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, part)
        controller = self.badge_controller(c.page_instance, part)
        return controller.edit(badge_id, format=format)

    @RequireInstance
    def settings_badges_update(self, id, part, badge_id, format='html'):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, part)
        controller = self.badge_controller(c.page_instance, part)
        return controller.update(badge_id, format=format)

    @RequireInstance
    def settings_badges_ask_delete(self, id, part, badge_id, format='html'):
        c.page_instance = self._get_current_instance(id)
        controller = self.badge_controller(c.page_instance, part)
        return controller.ask_delete(badge_id, format=format)

    @RequireInstance
    def settings_badges_delete(self, id, part, badge_id, format='html'):
        c.page_instance = self._get_current_instance(id)
        controller = self.badge_controller(c.page_instance, part)
        return controller.delete(badge_id, format=format)

    def _members_import_form(self, id):
        c.page_instance = self._get_current_instance(id)
        return render("/instance/members_import.html")

    @RequireInstance
    def members_import(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)
        return htmlfill.render(
            self._members_import_form(id),
            defaults={
                '_method': 'PUT',
                '_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=UserImportForm(),
              form="_members_import_form",
              post_only=True, auto_error_formatter=error_formatter,
              state=get_user_import_state())
    def members_import_save(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        try:
            self.form_result = UserImportForm().to_python(
                request.params, state=get_user_import_state())
            require.instance.edit(c.page_instance)
            data = user_import(self.form_result['users_csv'],
                               self.form_result['email_subject'],
                               self.form_result['email_template'],
                               c.user,
                               c.instance)
            return render("/instance/members_import_success.html",
                          data, overlay=format == u'overlay')
        except formencode.Invalid as i:
            return self._members_import_form(errors=i.unpack_errors())

# --[ template ]------------------------------------------------------------

    def settings_sname_form(self, id):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, 'sname')
        return render("/instance/settings_sname.html")

    @RequireInstance
    def settings_sname(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)
        return htmlfill.render(
            self.settings_sname_form(id),
            defaults={
                '_method': 'PUT',
                '_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstanceSnameEditForm(),
              form="settings_sname_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_sname_update(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        updated = update_attributes(c.page_instance, self.form_result, [])
        return self._settings_result(updated, c.page_instance, 'sname')

    def _presets_update(self, instance, form_result):
        active_settings = set()
        all_settings = set()
        for key, settings in PRESETS.iteritems():
            if form_result.get(key):
                active_settings.update(settings)
            all_settings.update(settings)

        updated = False
        for setting in active_settings:
            if not getattr(instance, setting):
                setattr(instance, setting, True)
                updated = True
        for setting in all_settings.difference(active_settings):
            if getattr(instance, setting):
                setattr(instance, setting, False)
                updated = True

        if updated:
            model.meta.Session.add(instance)
            model.meta.Session.commit()

        return updated

    def settings_presets_form(self, id):
        c.page_instance = self._get_current_instance(id)
        c.settings_menu = settings_menu(c.page_instance, 'presets')
        return render("/instance/settings_presets.html")

    @RequireInstance
    def settings_presets(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)
        return htmlfill.render(
            self.settings_presets_form(id),
            defaults={'_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstancePresetsForm(),
              form="settings_presets_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_presets_update(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        updated = self._presets_update(c.page_instance, self.form_result)
        return self._settings_result(updated, c.page_instance, 'presets')

    def presets_form(self, id):
        c.page_instance = self._get_current_instance(id)
        return render("/instance/presets.html")

    @RequireInstance
    def presets(self, id, format=u'html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)
        return formencode.htmlfill.render(
            self.presets_form(id),
            defaults={'_tok': csrf.token_id()})

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @validate(schema=InstancePresetsForm(), form="presets_form")
    def presets_update(self, id, format=u'html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.edit(c.page_instance)

        self._presets_update(c.page_instance, self.form_result)

        if config.get_bool('adhocracy.instance.show_settings_after_create'):
            member = 'settings/overview'
        else:
            member = None

        return ret_success(
            message=_(u'Instance created successfully. You can now configure '
                      u'it in greater detail if you wish.'),
            category='success', entity=c.page_instance,
            member=member)

    @RequireInstance
    def style(self, id):
        c.page_instance = self._get_current_instance(id)
        response.content_type = 'text/css'
        if c.page_instance.css:
            return c.page_instance.css
        return ''

    @RequireInstance
    def ask_delete(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.delete(c.page_instance)
        c.tile = tiles.instance.InstanceTile(c.page_instance)
        return render('/instance/ask_delete.html')

    @csrf.RequireInternalRequest()
    def delete(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.delete(c.page_instance)
        c.page_instance.delete()
        model.meta.Session.commit()
        event.emit(event.T_INSTANCE_DELETE, c.user, instance=c.instance,
                   topics=[])
        return ret_success(format=format,
                           message=_("The instance %s has been deleted.") %
                           c.page_instance.label,
                           force_path='/')

    @RequireInstance
    def ask_join(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.join(c.page_instance)
        return render('/instance/ask_join.html')

    @RequireInstance
    @csrf.RequireInternalRequest()
    def join(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        require.instance.join(c.page_instance)

        membership = model.Membership(c.user, c.page_instance,
                                      c.page_instance.default_group)
        model.meta.Session.expunge(membership)
        model.meta.Session.add(membership)
        model.meta.Session.commit()

        event.emit(event.T_INSTANCE_JOIN, c.user,
                   instance=c.page_instance)

        return ret_success(entity=c.page_instance, format=format,
                           message=_("Welcome to %(instance)s") % {
                               'instance': c.page_instance.label
                           },
                           category='success',
                           force_path=c.came_from)

    def ask_leave(self, id):
        c.page_instance = self._get_current_instance(id)
        require.instance.leave(c.page_instance)

        c.tile = tiles.instance.InstanceTile(c.page_instance)
        return render('/instance/ask_leave.html')

    @csrf.RequireInternalRequest(methods=['POST'])
    def leave(self, id, format='html'):
        c.page_instance = self._get_current_instance(id)
        if c.page_instance not in c.user.instances:
            return ret_abort(
                entity=c.page_instance, format=format,
                message=_("You're not a member of %(instance)s.") % {
                    'instance': c.page_instance.label})
        elif c.user == c.page_instance.creator:
            return ret_abort(
                entity=c.page_instance, format=format,
                message=_("You're the founder of %s, cannot leave.") % {
                    'instance': c.page_instance.label})
        require.instance.leave(c.page_instance)

        for membership in c.user.memberships:
            if membership.is_expired():
                continue
            if membership.instance == c.page_instance:
                membership.expire()
                model.meta.Session.add(membership)
                update_entity(c.user, model.UPDATE)

                c.user.revoke_delegations(c.page_instance)

                event.emit(event.T_INSTANCE_LEAVE, c.user,
                           instance=c.page_instance)
        model.meta.Session.commit()
        return ret_success(entity=c.page_instance, format=format,
                           message=_("You've left %(instance)s.") % {
                               'instance': c.page_instance.label})

    @classmethod
    def _get_current_instance(cls, id):
        if id != c.instance.key:
            abort(403, _("You cannot manipulate one instance from within "
                         "another instance."))
        return c.instance

########NEW FILE########
__FILENAME__ = massmessage
import logging
import textwrap

from pylons import request
from pylons import tmpl_context as c
from pylons.decorators import validate
from pylons.controllers.util import redirect
from pylons.i18n import _

import formencode
from formencode import validators, htmlfill

from adhocracy import config
from adhocracy import forms
from adhocracy.controllers.instance import InstanceController
from adhocracy.lib.auth import require
from adhocracy.lib.auth.authorization import has
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib import helpers as h
from adhocracy.lib.message import render_body
from adhocracy.lib.message import send as send_message
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render, ret_abort, ret_success
from adhocracy.lib.util import get_entity_or_abort
from adhocracy.lib import democracy
from adhocracy.model import Instance
from adhocracy.model import Membership
from adhocracy.model import Permission
from adhocracy.model import User
from adhocracy.model import UserBadge
from adhocracy.model import UserBadges
from adhocracy.model import Proposal

log = logging.getLogger(__name__)


class MassmessageBaseForm(formencode.Schema):
    allow_extra_fields = True
    subject = validators.String(max=140, not_empty=True)
    body = validators.String(min=2, not_empty=True)


class MassmessageForm(MassmessageBaseForm):
    filter_instances = forms.MessageableInstances(not_empty=True)
    filter_badges = forms.ValidUserBadges()
    sender_email = validators.String(not_empty=True)
    sender_name = validators.String(not_empty=False, if_missing=None)
    include_footer = formencode.validators.StringBoolean(if_missing=False)


class MassmessageProposalForm(MassmessageBaseForm):
    creators = validators.StringBool(not_empty=False, if_empty=False,
                                     if_missing=False)
    supporters = validators.StringBool(not_empty=False, if_empty=False,
                                       if_missing=False)
    opponents = validators.StringBool(not_empty=False, if_empty=False,
                                      if_missing=False)
    chained_validators = [
        forms.ProposalMessageNoRecipientGroup(),
    ]


def _get_options(func):
    """ Decorator that calls the functions with the following parameters:
        sender_email - Email address of the sender
        sender_name  - Name of the sender
        subject      - Subject of the message
        body         - Body of the message
        recipients   - A list of users the email is going to
    """
    @RequireInternalRequest(methods=['POST'])
    @validate(schema=MassmessageForm(), form='new')
    def wrapper(self):
        allowed_sender_options = self._get_allowed_sender_options(c.user)
        sender_email = self.form_result.get('sender_email')
        if ((sender_email not in allowed_sender_options) or
                (not allowed_sender_options[sender_email]['enabled'])):
            return ret_abort(_("Sorry, but you're not allowed to set these "
                               "message options"), code=403)
        sender_name = None
        if has('global.message'):
            sender_name = self.form_result.get('sender_name')
        if not sender_name:
            sender_name = c.user.name

        recipients = User.all_q()
        filter_instances = self.form_result.get('filter_instances')
        recipients = recipients.join(Membership).filter(
            Membership.instance_id.in_(filter_instances))
        filter_badges = self.form_result.get('filter_badges')
        if filter_badges:
            recipients = recipients.join(UserBadges,
                                         UserBadges.user_id == User.id)
            recipients = recipients.filter(
                UserBadges.badge_id.in_([fb.id for fb in filter_badges]))

        if has('global.admin'):
            include_footer = self.form_result.get('include_footer')
        else:
            include_footer = True

        if len(filter_instances) == 1:
            instance = Instance.find(filter_instances[0])
        else:
            instance = None

        return func(self,
                    self.form_result.get('subject'),
                    self.form_result.get('body'),
                    recipients.all(),
                    sender_email=allowed_sender_options[sender_email]['email'],
                    sender_name=sender_name,
                    instance=instance,
                    include_footer=include_footer,
                    )
    return wrapper


class MassmessageController(BaseController):
    """
    This deals with messages to multiple users at the same time. This will be
    will be merged with the MessageController at some point.
    """

    @classmethod
    def _get_allowed_instances(cls, user):
        """
        returns all instances in which the given user has permission to send a
        message to all users
        """
        if has('global.message'):
            return Instance.all(include_hidden=True)
        else:
            perm = Permission.find('instance.message')
            instances = [m.instance for m in user.memberships
                         if (m.instance is not None
                             and m.instance.is_authenticated
                             and perm in m.group.permissions)]
            return sorted(instances, key=lambda i: i.label)

    @classmethod
    def _get_allowed_sender_options(cls, user):
        sender_options = {
            'user': {
                'email': user.email,
                'checked': False,
                'enabled': user.is_email_activated(),
                'reason': _("Email isn't activated"),
            },
            'system': {
                'email': config.get('adhocracy.email.from'),
                'checked': False,
                'enabled': config.get_bool(
                    'allow_system_email_in_mass_messages'),
                'reason': _("Not permitted in system settings"),
            },
            'support': {
                'email': config.get('adhocracy.registration_support_email'),
                'checked': False,
                'enabled': (config.get('adhocracy.registration_support_email')
                            is not None),
                'reason': _("adhocracy.registration_support_email not set"),
            }
        }

        if sender_options['user']['enabled']:
            sender_options['user']['checked'] = True
        elif sender_options['system']['enabled']:
            sender_options['system']['checked'] = True

        return sender_options

    def new(self, id=None, errors={}, format=u'html'):

        if id is None:
            require.perm('global.message')
            template = '/massmessage/new.html'
            c.preview_url = h.base_url('/message/preview')
        else:
            c.page_instance = InstanceController._get_current_instance(id)
            require.instance.message(c.page_instance)
            template = '/instance/message.html'
            c.preview_url = h.base_url(
                '/instance/%s/message/preview' % id)

        defaults = dict(request.params)
        defaults.setdefault('include_footer', 'on')

        data = {
            'instances': self._get_allowed_instances(c.user),
            'sender_options': self._get_allowed_sender_options(c.user),
            'userbadges': UserBadge.all(instance=c.instance,
                                        include_global=True)
        }

        return htmlfill.render(render(template, data,
                                      overlay=format == u'overlay'),
                               defaults=defaults, errors=errors,
                               force_defaults=False)

    @_get_options
    def preview(self, subject, body, recipients, sender_email, sender_name,
                instance, include_footer):
        recipients_list = sorted(list(recipients), key=lambda r: r.name)
        if recipients_list:
            try:
                rendered_body = render_body(body, recipients_list[0],
                                            is_preview=True)
            except (KeyError, ValueError) as e:
                rendered_body = _('Could not render message: %s') % str(e)
        else:
            rendered_body = body

        # wrap body, but leave long words (e.g. links) intact
        rendered_body = u'\n'.join(textwrap.fill(line, break_long_words=False)
                                   for line in rendered_body.split(u'\n'))

        data = {
            'sender_email': sender_email,
            'sender_name': sender_name,
            'subject': subject,
            'body': rendered_body,
            'recipients': recipients_list,
            'recipients_count': len(recipients_list),
            'params': request.params,
            'include_footer': include_footer,
            'instance': instance,
        }
        return render('/massmessage/preview.html', data)

    @_get_options
    def create(self, subject, body, recipients, sender_email, sender_name,
               instance, include_footer):
        send_message(subject, body, c.user, recipients,
                     sender_email=sender_email,
                     sender_name=sender_name,
                     instance=instance,
                     include_footer=include_footer)
        return ret_success(
            message=_("Message sent to %d users.") % len(recipients))

    def new_proposal(self, proposal_id, errors={}, format=u'html'):
        c.proposal = get_entity_or_abort(Proposal, proposal_id)
        require.proposal.message(c.proposal)
        defaults = dict(request.params)
        return htmlfill.render(render('/massmessage/new_proposal.html',
                                      overlay=format == u'overlay'),
                               defaults=defaults, errors=errors,
                               force_defaults=False)

    @validate(schema=MassmessageProposalForm(), form='new_proposal')
    def create_proposal(self, proposal_id):
        c.proposal = get_entity_or_abort(Proposal, proposal_id)
        require.proposal.message(c.proposal)

        recipients = set()
        if self.form_result.get(u'supporters'):
            recipients.update(democracy.supporters(c.proposal.rate_poll))
        if self.form_result.get(u'opponents'):
            recipients.update(democracy.opponents(c.proposal.rate_poll))
        if self.form_result.get(u'creators'):
            recipients.update(c.proposal.get_creators())

        send_message(self.form_result.get('subject'),
                     self.form_result.get('body'),
                     c.user,
                     recipients,
                     instance=c.instance)
        h.flash(_("Message sent to %d users.") % len(recipients), 'success')
        redirect(h.entity_url(c.proposal))

########NEW FILE########
__FILENAME__ = message
import logging

from formencode import htmlfill, Invalid, Schema, validators

from pylons import request, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import helpers as h
from adhocracy.lib import message as _message
from adhocracy.lib.auth import require
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render
from adhocracy.lib.util import get_entity_or_abort
from adhocracy.lib.message import send as send_message

log = logging.getLogger(__name__)


class MessageCreateForm(Schema):
    allow_extra_fields = True
    subject = validators.String(max=250, not_empty=True)
    body = validators.String(max=20000, min=2, not_empty=True)


class MessageController(BaseController):

    def new(self, id, format='html', errors={}):
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.message(c.page_user)
        html = render("/message/new.html", overlay=format == u'overlay')
        return htmlfill.render(html, defaults=request.params,
                               errors=errors, force_defaults=False)

    def create(self, id, format='html'):
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.message(c.page_user)
        try:
            self.form_result = MessageCreateForm().to_python(request.params)
        except Invalid, i:
            return self.new(id, errors=i.unpack_errors())

        body = self.form_result.get('body')
        subject = self.form_result.get('subject')

        send_message(subject, body, c.user, [c.page_user], instance=c.instance,
                     massmessage=False)

        h.flash(_("Your message has been sent. Thanks."), 'success')
        redirect(h.entity_url(c.page_user, instance=c.instance))

    def show(self, id, format='html'):
        c.message = get_entity_or_abort(model.Message, id)
        require.message.show(c.message)
        c.body = _message.render_body(c.message.body, c.user)
        return render('/message/show.html', overlay=format == 'overlay')

########NEW FILE########
__FILENAME__ = milestone
from datetime import date, datetime, time
import logging

import formencode
from formencode import htmlfill, Invalid, validators

from pylons import request, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import config
from adhocracy import forms, model
from adhocracy.lib import helpers as h, pager, tiles, watchlist
from adhocracy.lib.auth import can
from adhocracy.lib.auth import csrf, require
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.templating import render, render_json
from adhocracy.lib.util import get_entity_or_abort

import adhocracy.lib.text as text


log = logging.getLogger(__name__)


class MilestoneNewForm(formencode.Schema):
    allow_extra_fields = True


class MilestoneCreateForm(MilestoneNewForm):
    title = validators.String(max=2000, min=4, not_empty=True)
    text = validators.String(max=60000, min=4, not_empty=True)
    category = forms.ValidCategoryBadge(if_missing=None, if_empty=None)
    show_all_proposals = validators.StringBool(not_empty=False, if_empty=False,
                                               if_missing=False)
    time = forms.ValidDate(not_empty=True)
    watch = validators.StringBool(not_empty=False, if_empty=False,
                                  if_missing=False)


class MilestoneEditForm(formencode.Schema):
    allow_extra_fields = True


class MilestoneUpdateForm(MilestoneEditForm):
    title = validators.String(max=2000, min=4, not_empty=True)
    text = validators.String(max=60000, min=4, not_empty=True)
    category = forms.ValidCategoryBadge(if_missing=None, if_empty=None)
    show_all_proposals = validators.StringBool(not_empty=False, if_empty=False,
                                               if_missing=False)
    time = forms.ValidDate(not_empty=True)
    watch = validators.StringBool(not_empty=False, if_empty=False,
                                  if_missing=False)


class MilestoneController(BaseController):

    identifier = 'milestones'

    @RequireInstance
    def index(self, format="html"):
        require.milestone.index()

        milestones = model.Milestone.all(instance=c.instance)
        broken = [m for m in milestones if m.time is None]
        for milestone in broken:
            log.warning('Time of Milestone is None: %s' %
                        h.entity_url(milestone))
        milestones = [m for m in milestones if m.time is not None]
        today = datetime.combine(date.today(), time(0, 0))
        past_milestones = [m for m in milestones if m.time < today]
        c.show_past_milestones = len(past_milestones)
        c.past_milestones_pager = pager.milestones(past_milestones)

        current_milestones = [m for m in milestones if m not in
                              past_milestones]
        c.show_current_milestones = (bool(current_milestones)
                                     or not c.show_past_milestones)
        c.current_milestones_pager = pager.milestones(current_milestones)
        c.milestones = past_milestones + current_milestones  # for the timeline
        if format == 'json':
            return render_json(c.milestones_pager)

        c.tile = tiles.instance.InstanceTile(c.instance)
        c.tutorial = 'milestone_index'
        c.tutorial_intro = _('tutorial_milestones_tab')
        if format == 'overlay':
            return render("/milestone/index.html", overlay=True)
        else:
            return render("/milestone/index.html")

    @RequireInstance
    @validate(schema=MilestoneNewForm(), form='bad_request',
              post_only=False, on_get=True)
    def new(self, errors=None, format=u'html'):
        require.milestone.create()
        c.categories = model.CategoryBadge.all(instance=c.instance)
        defaults = dict(request.params)
        if not defaults:
            defaults['watch'] = True
        return htmlfill.render(render("/milestone/new.html",
                                      overlay=format == u'overlay'),
                               defaults=defaults, errors=errors,
                               force_defaults=False)

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    def create(self, format='html'):
        require.milestone.create()
        c.categories = model.CategoryBadge.all(instance=c.instance)
        try:
            self.form_result = MilestoneCreateForm().to_python(request.params)
        except Invalid, i:
            return self.new(errors=i.unpack_errors())

        category = self.form_result.get('category')
        milestone = model.Milestone.create(c.instance, c.user,
                                           self.form_result.get("title"),
                                           self.form_result.get('text'),
                                           self.form_result.get('time'),
                                           category=category)
        if config.get_bool('adhocracy.milestone.allow_show_all_proposals'):
            milestone.show_all_proposals = self.form_result.get(
                'show_all_proposals')

        model.meta.Session.commit()
        if can.watch.create():
            watchlist.set_watch(milestone, self.form_result.get('watch'))
        # event.emit(event.T_PROPOSAL_CREATE, c.user, instance=c.instance,
        #            topics=[proposal], proposal=proposal,
        #            rev=description.head)
        redirect(h.entity_url(milestone, format=format))

    @RequireInstance
    @validate(schema=MilestoneEditForm(), form="bad_request",
              post_only=False, on_get=True)
    def edit(self, id, errors={}):
        c.categories = model.CategoryBadge.all(instance=c.instance)
        c.milestone = get_entity_or_abort(model.Milestone, id)
        require.milestone.edit(c.milestone)
        defaults = {'category': (str(c.milestone.category.id) if
                                 c.milestone.category else None),
                    'show_all_proposals': c.milestone.show_all_proposals,
                    'watch': h.find_watch(c.milestone),
                    }
        defaults.update(dict(request.params))
        return htmlfill.render(render("/milestone/edit.html"),
                               defaults=defaults,
                               errors=errors, force_defaults=False)

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    def update(self, id, format='html'):
        try:
            c.milestone = get_entity_or_abort(model.Milestone, id)
            self.form_result = MilestoneUpdateForm().to_python(request.params)
        except Invalid, i:
            return self.edit(id, errors=i.unpack_errors())

        require.milestone.edit(c.milestone)

        c.milestone.title = self.form_result.get('title')
        c.milestone.text = self.form_result.get('text')
        c.milestone.category = self.form_result.get('category')
        c.milestone.time = self.form_result.get('time')
        if config.get_bool('adhocracy.milestone.allow_show_all_proposals'):
            c.milestone.show_all_proposals = self.form_result.get(
                'show_all_proposals')
        model.meta.Session.commit()
        if can.watch.create():
            watchlist.set_watch(c.milestone, self.form_result.get('watch'))
        # event.emit(event.T_PROPOSAL_EDIT, c.user, instance=c.instance,
        #            topics=[c.proposal], proposal=c.proposal, rev=_text)
        redirect(h.entity_url(c.milestone))

    @RequireInstance
    def show(self, id, format='html'):
        c.milestone = get_entity_or_abort(model.Milestone, id)
        require.milestone.show(c.milestone)

        if format == 'json':
            return render_json(c.milestone)

        c.tile = tiles.milestone.MilestoneTile(c.milestone)

        extra_filter = {}
        alternatives_filter = {}

        if (config.get_bool('adhocracy.milestone.allow_show_all_proposals')
           and c.milestone.show_all_proposals
           and not c.milestone.over):
            extra_filter['facet.delegateable.frozen'] = False
        else:

            # proposals .. directly assigned
            alternatives_filter['facet.delegateable.milestones']\
                = c.milestone.id

            # proposals .. with the same category
            if c.milestone.category:
                alternatives_filter['facet.delegateable.badgecategory']\
                    = c.milestone.category.id

        c.proposals_pager = pager.solr_proposal_pager(
            c.instance, extra_filter=extra_filter,
            alternatives_filter=alternatives_filter)

        c.show_proposals_pager = bool(c.proposals_pager.total_num_items())

        # pages
        pages = model.Page.by_milestone(c.milestone,
                                        instance=c.instance,
                                        include_deleted=False,
                                        functions=[model.Page.NORM])
        c.pages_pager = pager.pages(pages, size=20, enable_sorts=False)
        c.show_pages_pager = len(pages) and c.instance.use_norms

        self._common_metadata(c.milestone)
        c.tutorial_intro = _('tutorial_milestone_details_tab')
        c.tutorial = 'milestone_show'

        return render("/milestone/show.html", overlay=(format == 'overlay'))

    @RequireInstance
    def ask_delete(self, id):
        c.milestone = get_entity_or_abort(model.Milestone, id)
        require.milestone.delete(c.milestone)
        c.tile = tiles.milestone.MilestoneTile(c.milestone)
        return render('/milestone/ask_delete.html')

    @RequireInstance
    @csrf.RequireInternalRequest()
    def delete(self, id):
        c.milestone = get_entity_or_abort(model.Milestone, id)
        require.milestone.delete(c.milestone)
        # event.emit(event.T_milestone_DELETE, c.user, instance=c.instance,
        #            topics=[c.milestone], milestone=c.milestone)
        c.milestone.delete()
        model.meta.Session.commit()
        h.flash(_("The milestone %s has been deleted.") % c.milestone.title,
                'success')
        redirect(h.entity_url(c.instance))

    def _common_metadata(self, milestone):
        h.add_meta("description",
                   text.meta_escape(milestone.text,
                                    markdown=False)[0:160])
        h.add_meta("dc.title",
                   text.meta_escape(milestone.title, markdown=False))
        h.add_meta("dc.date",
                   (milestone.time and milestone.time.strftime("%Y-%m-%d") or
                    ''))
        h.add_meta("dc.author",
                   text.meta_escape(milestone.creator.name, markdown=False))

########NEW FILE########
__FILENAME__ = oembed
import logging

import urlparse
import re

from pylons import request

from adhocracy import config
from adhocracy.lib import helpers as h
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render_json, ret_abort

log = logging.getLogger(__name__)


class OembedController(BaseController):
    """ see http://www.oembed.com/ """

    identifier = 'oembed'

    def oembed(self, format=u'json'):
        if 'url' not in request.params:
            return ret_abort(u"Required parameter 'url' is missing", code=400)

        u = urlparse.urlparse(request.params.get('url'))

        # validate input url
        if (u.scheme != config.get('adhocracy.protocol')
                or u.netloc != config.get('adhocracy.domain')):
            return ret_abort(u"URL not supported", code=404)

        # set format to overlay
        path = re.sub('(\.[^./]*)?$', '.overlay', u.path)
        new_url = urlparse.ParseResult(u.scheme, u.netloc, path,
                                       u.params, u.query, u.fragment)
        new_url = urlparse.urlunparse(new_url)

        width = min(640, int(request.params.get('maxwidth', 640)))
        height = int(request.params.get('maxheight', 750))

        html = ('<iframe src="%s" width="%i "height="%i"'
                ' frameborder="0"></iframe>' % (new_url, width, height))

        data = {
            'type': 'rich',
            'version': '1.0',
            'width': width,
            'height': height,
            'html': html,
            'provider_name': config.get('adhocracy.site.name'),
            'provider_url': h.base_url(instance=None, absolute=True),
        }

        if format == u'json':
            return render_json(data)
        else:
            ret_abort(u"The format parameter must be one of: {json}.",
                      code=501)

########NEW FILE########
__FILENAME__ = openidauth
import logging
import re

import formencode
from formencode import validators

from pylons import request, response, session, tmpl_context as c
from pylons.controllers.util import abort, redirect
from pylons.decorators import validate
from pylons.i18n import _
from webob.exc import HTTPFound

from openid.consumer.consumer import SUCCESS
from openid.extensions import sreg, ax

from adhocracy import config
from adhocracy import forms, model
from adhocracy.lib import event, helpers as h
from adhocracy.lib.auth import login_user, require, can
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.openidstore import create_consumer
from adhocracy.lib.templating import render
import adhocracy.lib.mail as libmail
from adhocracy.lib.auth.authentication import allowed_login_types
from adhocracy.lib.templating import ret_abort

log = logging.getLogger(__name__)


AX_MAIL_SCHEMA_AX = u'http://axschema.org/contact/email'
AX_MAIL_SCHEMA_OPENID = u'http://schema.openid.net/contact/email'
AX_MEMBERSHIP_SCHEMA = u'http://schema.liqd.de/membership/signed/'

MYOPENID_RE = r'https?://[^./]+\.myopenid\.com/?$'
GOOGLE_RE = r'https://www\.google\.com/accounts/.*'
YAHOO_RE = r'https?://me\.yahoo\.com(?:/?$|/.*)'

SESSION_KEY = 'openid_session'

TRUSTED_PROVIDER_RES = [
    MYOPENID_RE,
    GOOGLE_RE,
    YAHOO_RE,
]


def openid_login_allowed():
    return 'openid' in allowed_login_types()


def is_trusted_provider(identity):
    """
    Check whether the provided ID matches the regular expression of a trusted
    OpenID provider.
    """
    return any(re.match(r, identity) for r in TRUSTED_PROVIDER_RES)


def get_ax_mail_schema(openid):
    """
    Different OpenID providers use different attribute exchange schemata.
    """
    if re.match(YAHOO_RE, openid):
        return AX_MAIL_SCHEMA_AX
    else:
        return AX_MAIL_SCHEMA_OPENID


class OpenIDInitForm(formencode.Schema):
    openid = validators.OpenId(not_empty=False, if_empty=None,
                               if_missing=None, if_invalid=None)


class OpenIDUsernameForm(formencode.Schema):
    login = formencode.All(validators.PlainText(not_empty=True),
                           forms.UniqueUsername(),
                           forms.ContainsChar())


class OpenidauthController(BaseController):

    def _create(self, user_name, email, identity):
        """
        Create a user based on data gathered from OpenID
        """
        user = model.User.create(user_name, email, locale=c.locale,
                                 openid_identity=identity)
        if email is not None:
            if is_trusted_provider(identity):
                # trust provided email:
                user.activation_code = None
            else:
                libmail.send_activation_link(user)
        model.meta.Session.commit()
        event.emit(event.T_USER_CREATE, user)
        return user

    def _login(self, user, register=False):
        """
        log the user in and redirect him to a sane place.
        """
        login_user(user, request, response)
        session['login_type'] = 'openid'
        if c.instance and not user.is_member(c.instance):
            redirect(h.base_url("/instance/join/%s?%s" % (c.instance.key,
                                                          h.url_token())))
        if register:
            redirect(h.user.post_register_url(user))
        else:
            redirect(h.user.post_login_url(user))

    def _failure(self, openid, message):
        """
        Abort an OpenID authenication attempt and return to login page,
        giving an error message at the openid field.
        """
        log.info("OpenID: %s - Error: %s" % (openid, message))
        if c.user:
            h.flash(message, 'error')
            return redirect(h.entity_url(c.user, member='settings/login'))
        else:
            loginhtml = render("/user/login_tile.html")
            form = formencode.htmlfill.render(loginhtml,
                                              defaults={'openid': openid},
                                              errors={'openid': message})
            return render('/user/login.html', {'login_form_code': form})

    def __before__(self):
        self.openid_session = self.get_session()

    @validate(schema=OpenIDInitForm(), post_only=False, on_get=True)
    def init(self):
        self.consumer = create_consumer(self.openid_session)
        if not hasattr(self, 'form_result'):
            return self._failure('', _("Invalid input."))
        openid = self.form_result.get("openid")
        try:
            if not openid:
                raise ValueError(_("No OpenID given!"))
            authrequest = self.consumer.begin(openid)

            if not c.user and not model.OpenID.find(openid):
                axreq = ax.FetchRequest(h.base_url('/openid/update',
                                                   absolute=True))
                axreq.add(ax.AttrInfo(get_ax_mail_schema(openid),
                                      alias="email",
                                      required=True))
                authrequest.addExtension(axreq)
                sreq = sreg.SRegRequest(required=['nickname'],
                                        optional=['email'])
                authrequest.addExtension(sreq)

            redirecturl = authrequest.redirectURL(
                h.base_url('/', absolute=True),
                return_to=h.base_url('/openid/verify', absolute=True),
                immediate=False)
            self.set_session(self.openid_session)
            session.save()
            return redirect(redirecturl)
        except HTTPFound:
            raise
        except Exception, e:
            log.exception(e)
            return self._failure(openid, str(e))

    def connect(self):
        if (not openid_login_allowed()
                and 'facebook' not in allowed_login_types()):
            ret_abort(_("Connection not allowed, single sign-on has been "
                        "disabled on this installation"), code=403)
        require.user.edit(c.user)
        if not c.user:
            h.flash(_("No OpenID was entered."), 'warning')
            redirect("/login")
        return render("/openid/connect.html")

    @RequireInternalRequest()
    def revoke(self):
        if not openid_login_allowed():
            ret_abort(_("Removal not allowed, OpenID has been disabled on "
                        "this installation"), code=403)
        require.user.edit(c.user)
        id = request.params.get('id')
        openid = model.OpenID.by_id(id)
        if not openid:
            abort(404, _("No OpenID with ID '%s' exists.") % id)
        page_user = openid.user
        if not (page_user == c.user or can.user.manage()):
            abort(403,
                  _("You're not authorized to change %s's settings.") % id)
        openid.delete()
        model.meta.Session.commit()
        h.flash(_("Successfully removed OpenID from account"), 'success')
        log.info("User %s revoked OpenID '%s'" % (
            c.user.user_name, id))
        redirect(h.entity_url(c.user, member='settings/login'))

    def verify(self):
        if not openid_login_allowed():
            ret_abort(_("OpenID login has been disabled on this installation"),
                      code=403)

        self.consumer = create_consumer(self.openid_session)
        info = self.consumer.complete(request.params,
                                      h.base_url('/openid/verify',
                                                 absolute=True))
        if not info.status == SUCCESS:
            return self._failure(info.identity_url, _("OpenID login failed."))
        email = None
        user_name = None
        # evaluate Simple Registration Extension data
        srep = sreg.SRegResponse.fromSuccessResponse(info)
        if srep:
            if srep.get('nickname'):
                user_name = srep.get('nickname').strip()
            if srep.get('email'):
                email = srep.get('email')
        # evaluate Attribute Exchange data
        # TBD: AXSCHEMA friendlyName
        # TBD: SignedMembership
        axrep = ax.FetchResponse.fromSuccessResponse(info)
        if axrep:
            ax_mail_schema = get_ax_mail_schema(info.identity_url)
            try:
                email = axrep.getSingle(ax_mail_schema) or email
            except ValueError:
                email = axrep.get(ax_mail_schema)[0]
            except KeyError:
                email = email

        if 'openid_session' in session:
            self.delete_session()

        oid = model.OpenID.find(info.identity_url)
        if oid:
            if c.user:
                if oid.user == c.user:
                    return self._failure(
                        info.identity_url,
                        _("You have already claimed this OpenID."))
                else:
                    return self._failure(
                        info.identity_url,
                        _("OpenID %s is already connected to an account.")
                        % (info.identity_url, oid.user.name))
            else:
                self._login(oid.user)
                # returns
        else:
            if c.user:
                oid = model.OpenID(unicode(info.identity_url), c.user)
                model.meta.Session.add(oid)
                model.meta.Session.commit()
                h.flash(_("Successfully added OpenID to user account."),
                        'success')
                redirect(h.entity_url(c.user, member='settings/login'))
            else:

                if not h.allow_user_registration():
                    h.flash(_(
                        "OpenID %s doesn't belong to an existing user account "
                        "and user registration is disabled in this "
                        "installation." % info.identity_url
                    ), 'warning')
                    redirect(h.base_url('/login'))

                user_by_email = model.User.find_by_email(email)
                if user_by_email is not None:
                    if is_trusted_provider(info.identity_url):
                        # A user with the email returned by the OpenID provider
                        # exists. As we trust the OpenID provider, we log in
                        # that account and assign the OpenID to this user.
                        oid = model.OpenID(unicode(info.identity_url),
                                           user_by_email)
                        model.meta.Session.add(oid)
                        model.meta.Session.commit()
                        h.flash(_(
                            "Successfully added OpenID to user account."
                        ), 'success')
                        self._login(user_by_email)
                    else:
                        # A user with the email returned by the OpenID provider
                        # exists. As we don't trust the OpenID provider, we
                        # demand that the user needs to login first.
                        #
                        # Note: We could store the successful OpenID
                        # authentication in the session and assign it after
                        # login. However probably more is gained if the
                        # list of trusted OpenID providers is extended.
                        h.flash(_(
                            "The email address %s which was returned by the "
                            "OpenID provider already belongs to a different "
                            "user account. Please login with that account "
                            "or use the forgot password functionality, and "
                            "add the OpenID in your user profile settings "
                            "afterwards. Sorry for the inconvenience." % email
                        ), 'warning')
                        redirect(h.base_url('/login'))

                try:
                    forms.UniqueUsername(not_empty=True).to_python(user_name)
                    formencode.All(validators.PlainText(not_empty=True),
                                   forms.UniqueUsername(),
                                   forms.ContainsChar())
                except:
                    session['openid_req'] = (info.identity_url, user_name,
                                             email)
                    session.save()
                    redirect(h.base_url('/openid/username'))
                user = self._create(user_name, email, info.identity_url)
                h.flash(_("Successfully created new user account %s" %
                          user_name), 'success')
                self._login(user, register=True)

    @validate(schema=OpenIDUsernameForm(), form="username", post_only=True)
    def username(self):
        """
        Called when the nickname proposed by the OpenID identity provider is
        unavailable locally.
        """
        if not openid_login_allowed():
            ret_abort(_("OpenID login has been disabled on this installation"),
                      code=403)
        if 'openid_req' in session:
            (openid, c.openid_username, email) = session['openid_req']
            if request.method == "POST":
                c.user_name = forms.UniqueUsername(
                    not_empty=True).to_python(self.form_result.get('login'))
                if c.user_name:
                    user = self._create(c.user_name, email, openid)
                    del session['openid_req']
                    self._login(user, register=True)
            else:
                c.user_name = c.openid_username
            return render('/openid/username.html')
        else:
            redirect('/register')

    def xrds(self):
        response.headers['Content-Type'] = ("application/xrds+xml; "
                                            "charset=utf-8")
        return render('/openid/xrds.xml')

    # If we're using a JSON based session backend, we need to serialize some
    # openid related stuff first. See liqd/adhocracy#469 and
    # openid/python-openid#17.

    def get_session(self):
        ses = session.get(SESSION_KEY, {})
        if ses and config.get('adhocracy.session.implementation') == 'cookie':
            import pickle
            ses = pickle.loads(ses)
        return ses

    def set_session(self, ses):
        if config.get('adhocracy.session.implementation') == 'cookie':
            import pickle
            ses = pickle.dumps(ses)
        session[SESSION_KEY] = ses

    def delete_session(self):
        del session[SESSION_KEY]

########NEW FILE########
__FILENAME__ = page
import json
import logging
from operator import itemgetter


import formencode
from formencode import htmlfill, Invalid, validators

from pylons import request, tmpl_context as c
from pylons.controllers.util import abort, redirect
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import config
from adhocracy import forms, model
from adhocracy.lib import democracy, event, helpers as h
from adhocracy.lib import pager, sorting, tiles, watchlist, logo
from adhocracy.lib.auth import guard
from adhocracy.lib.auth import can, require
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.staticpage import add_static_content
from adhocracy.lib.templating import (render, render_json, ret_abort,
                                      render_logo)
from adhocracy.lib.templating import OVERLAY_SMALL
from adhocracy.lib.text.diff import (norm_texts_inline_compare,
                                     page_titles_compare)
from adhocracy.lib.text.render import render_line_based, render as render_text
import adhocracy.lib.text as libtext
from adhocracy.lib.util import get_entity_or_abort


log = logging.getLogger(__name__)


class NoneObject(object):
    pass

NoPage = NoneObject()


class PageCreateForm(formencode.Schema):
    allow_extra_fields = True
    title = forms.ValidTitle(unused_label=True)
    text = validators.String(max=20000, min=0, not_empty=False,
                             if_empty=None, if_missing=None)
    parent = forms.ValidPage(if_missing=None, if_empty=None, not_empty=False)
    proposal = forms.ValidProposal(not_empty=False, if_empty=None,
                                   if_missing=None)
    tags = validators.String(max=20000, not_empty=False)
    milestone = forms.MaybeMilestone(if_empty=None, if_missing=None)
    category = formencode.foreach.ForEach(forms.ValidCategoryBadge())
    formatting = validators.StringBool(not_empty=False, if_empty=False,
                                       if_missing=False)
    container = validators.StringBool(not_empty=False, if_empty=False,
                                      if_missing=False)
    sectionpage = validators.StringBool(not_empty=False, if_empty=False,
                                        if_missing=False)
    allow_comment = validators.StringBool(not_empty=False, if_empty=False,
                                          if_missing=False)
    allow_selection = validators.StringBool(not_empty=False, if_empty=False,
                                            if_missing=False)
    always_show_original = validators.StringBool(not_empty=False,
                                                 if_empty=False,
                                                 if_missing=False)
    watch = validators.StringBool(not_empty=False, if_empty=False,
                                  if_missing=False)
    if config.get_bool('adhocracy.page.allow_abstracts'):
        abstract = validators.String(max=255, not_empty=False, if_empty=None,
                                     if_missing=None)


class PageEditForm(formencode.Schema):
    allow_extra_fields = True


class PageUpdateForm(formencode.Schema):
    allow_extra_fields = True
    title = forms.ValidTitle()
    variant = forms.VariantName(not_empty=True)
    text = validators.String(max=20000, min=0, not_empty=False,
                             if_empty=None, if_missing=None)
    parent_text = forms.ValidText(if_missing=None, if_empty=None,
                                  not_empty=False)
    parent_page = forms.ValidPage(if_missing=NoPage, if_empty=None,
                                  not_empty=False)
    proposal = forms.ValidProposal(not_empty=False, if_empty=None,
                                   if_missing=None)
    milestone = forms.MaybeMilestone(if_empty=None,
                                     if_missing=None)
    category = formencode.foreach.ForEach(forms.ValidCategoryBadge())
    formatting = validators.StringBool(not_empty=False, if_empty=False,
                                       if_missing=False)
    sectionpage = validators.StringBool(not_empty=False, if_empty=False,
                                        if_missing=False)
    allow_comment = validators.StringBool(not_empty=False, if_empty=False,
                                          if_missing=False)
    allow_selection = validators.StringBool(not_empty=False, if_empty=False,
                                            if_missing=False)
    always_show_original = validators.StringBool(not_empty=False,
                                                 if_empty=False,
                                                 if_missing=False)
    watch = validators.StringBool(not_empty=False, if_empty=False,
                                  if_missing=False)
    if config.get_bool('adhocracy.page.allow_abstracts'):
        abstract = validators.String(max=255, not_empty=False, if_empty=None,
                                     if_missing=None)


class PageFilterForm(formencode.Schema):
    allow_extra_fields = True
    pages_q = validators.String(max=255, not_empty=False, if_empty=u'',
                                if_missing=u'')


class PageDiffForm(formencode.Schema):
    allow_extra_fields = True
    left = forms.ValidText()
    right = forms.ValidText()


class PageController(BaseController):

    identifier = 'norms'

    @RequireInstance
    @guard.page.index()
    @validate(schema=PageFilterForm(), post_only=False, on_get=True)
    def index(self, format="html"):
        data = {}
        pages = model.Page.all(instance=c.instance,
                               functions=model.Page.LISTED)
        if request.params.get('pages_sort', '4') == '4':
            # crude hack to get only top level pages cause the pager
            # cannot handle this and we can not pass arguments to the tile
            # WARNING: This will break if the index of the sort changes.
            c.is_hierarchical = True
            pages = [page for page in pages if page.parent is None]

        data['pages_pager'] = pager.pages(pages)

        if format == 'json':
            return render_json(data['pages_pager'])

        tags = model.Tag.popular_tags(limit=30)
        data['cloud_tags'] = sorted(h.tag.tag_cloud_normalize(tags),
                                    key=lambda (k, c, v): k.name)
        data['tutorial_intro'] = _('tutorial_norms_overview_tab')
        data['tutorial'] = 'page_index'

        add_static_content(data, u'adhocracy.static.page_index_heading',
                           body_key=u'heading_text',
                           title_key=u'heading_title')

        if c.instance.page_index_as_tiles:
            return render("/page/index_tiles.html", data,
                          overlay=format == u'overlay',
                          overlay_size=OVERLAY_SMALL)
        else:
            return render("/page/index.html", data,
                          overlay=format == u'overlay',
                          overlay_size=OVERLAY_SMALL)

    @RequireInstance
    @guard.page.create()
    def new(self, errors=None, format=u'html'):
        defaults = dict(request.params)

        if not defaults:
            defaults['watch'] = True

        c.title = request.params.get('title', None)
        proposal_id = request.params.get("proposal")
        c.categories = model.CategoryBadge.all(
            c.instance, include_global=not c.instance.hide_global_categories)

        c.section = u'section_parent' in request.params
        if c.section:
            c.parent = get_entity_or_abort(
                model.Page, request.params.get(u'section_parent'))
            if c.title is None:
                c.title = u"%s %i" % (c.parent.label,
                                      len(c.parent.children))

        html = None
        if proposal_id is not None:
            c.proposal = model.Proposal.find(proposal_id)
            html = render('/selection/propose.html',
                          overlay=format == u'overlay')
        else:
            c.propose = None
            html = render("/page/new.html", overlay=format == u'overlay')

        return htmlfill.render(html, defaults=defaults, errors=errors,
                               force_defaults=False)

    @RequireInstance
    @RequireInternalRequest(methods=['POST'])
    @guard.page.create()
    def create(self, format='html'):
        try:
            self.form_result = PageCreateForm().to_python(request.params)
            # a proposal that this norm should be integrated with
            proposal = self.form_result.get("proposal")
            _text = self.form_result.get("text")
            if not can.norm.create():
                if not proposal:
                    msg = _("No proposal has been specified")
                    raise Invalid(msg, branch, state_(),
                                  error_dict={'title': msg})
                if not c.instance.allow_propose:
                    msg = _("You cannot create a new norm")
                    raise Invalid(msg, branch, state_(),
                                  error_dict={'title': msg})
                # if a proposal is specified, create a stub:
                _text = None
        except Invalid, i:
            return self.new(errors=i.unpack_errors())

        variant = self.form_result.get("title")
        container = self.form_result.get('container')
        page = model.Page.create(
            c.instance, variant, _text, c.user,
            function=(model.Page.CONTAINER if container else model.Page.NORM),
            formatting=(self.form_result.get("formatting")
                        or self.form_result.get("container")),
            sectionpage=(False if container
                         else self.form_result.get("sectionpage")),
            allow_comment=self.form_result.get("allow_comment"),
            allow_selection=self.form_result.get("allow_selection"),
            always_show_original=self.form_result.get("always_show_original"),
            tags=self.form_result.get("tags"))

        page.milestone = self.form_result.get('milestone')

        if self.form_result.get("parent") is not None:
            page.parents.append(self.form_result.get("parent"))

        if (config.get_bool('adhocracy.page.allow_abstracts')
                and c.instance.page_index_as_tiles
                and not page.is_section()):
            page.abstract = self.form_result.get('abstract')

        if c.came_from != u'':
            came_from = c.came_from
        elif proposal is not None and can.selection.create(proposal):
            model.Selection.create(proposal, page, c.user, variant=variant)
            # if a selection was created, go there instead:
            came_from = h.page.url(page, member='branch',
                                   query={'proposal': proposal.id})
        else:
            came_from = h.entity_url(page)  # by default, redirect to the page

        categories = self.form_result.get('category')
        category = categories[0] if categories else None
        page.set_category(category, c.user)

        model.meta.Session.commit()

        try:
            # fixme: show image errors in the form
            if ('logo' in request.POST and
                    hasattr(request.POST.get('logo'), 'file') and
                    request.POST.get('logo').file):
                logo.store(page, request.POST.get('logo').file)
        except Exception, e:
            h.flash(_(u"errors while uploading image: %s") % unicode(e),
                    'error')
            log.debug(e)

        if can.watch.create():
            watchlist.set_watch(page, self.form_result.get('watch'))
        event.emit(event.T_PAGE_CREATE, c.user, instance=c.instance,
                   topics=[page], page=page, rev=page.head)
        redirect(came_from)

    @RequireInstance
    @validate(schema=PageEditForm(), form='edit', post_only=False, on_get=True)
    def edit(self, id, variant=None, text=None, branch=False, errors={},
             format=u'html'):
        c.page, c.text, c.variant = self._get_page_and_text(id, variant, text)
        c.variant = request.params.get("variant", c.variant)
        c.proposal = request.params.get("proposal")
        c.formatting = request.params.get("formatting", False)
        c.sectionpage = request.params.get("sectionpage", True)
        c.allow_comment = request.params.get("allow_comment", False)
        c.allow_selection = request.params.get("allow_selection", False)
        c.always_show_original = request.params.get("always_show_original",
                                                    False)
        c.branch = branch
        c.container = c.page.function == c.page.CONTAINER
        c.abstract = request.params.get("abstract")

        c.section = 'section_parent' in request.params
        if c.section:
            c.parent = get_entity_or_abort(
                model.Page, request.params.get(u'section_parent'))

        if branch or c.variant is None:
            c.variant = ""

        require.norm.edit(c.page, c.variant)

        # all available categories
        c.categories = model.CategoryBadge.all(c.instance, include_global=True)

        # categories for this page
        # (single category not assured in db model)
        c.category = c.page.category

        if logo.exists(c.page):
            c.logo = '<img src="%s" />' % h.logo_url(c.page, 48)

        defaults = dict(request.params)
        if 'watch' not in defaults:
            defaults['watch'] = h.find_watch(c.page)

        if branch and c.text is None:
            c.text = c.page.head.text

        if c.came_from != u'':
            c.came_from = c.came_from
        elif c.section:
            c.came_from = h.entity_url(c.parent,
                                       anchor="subpage-%i" % c.page.id)
        else:
            c.came_from = h.entity_url(c.text)

        c.text_rows = libtext.text_rows(c.text)
        c.left = c.page.head
        html = render('/page/edit.html', overlay=format == u'overlay',
                      overlay_size=OVERLAY_SMALL)
        return htmlfill.render(html, defaults=defaults,
                               errors=errors, force_defaults=False)

    @RequireInstance
    @RequireInternalRequest(methods=['POST'])
    def update(self, id, variant=None, text=None, format='html'):
        c.page, c.text, c.variant = self._get_page_and_text(id, variant, text)
        branch = False
        try:
            class state_(object):
                page = c.page

            # branch is validated on its own, since it needs to be
            # carried to the
            # error page.
            branch_val = validators.StringBool(not_empty=False,
                                               if_empty=False,
                                               if_missing=False)
            branch = branch_val.to_python(request.params.get('branch'))

            self.form_result = PageUpdateForm().to_python(request.params,
                                                          state=state_())

            # delete the logo if the button was pressed and exit
            if 'delete_logo' in self.form_result:
                updated = logo.delete(c.page)
                h.flash(_(u'The logo has been deleted.'), 'success')
                redirect(h.entity_url(c.page))

            try:
                # fixme: show image errors in the form
                if ('logo' in request.POST and
                        hasattr(request.POST.get('logo'), 'file') and
                        request.POST.get('logo').file):
                    logo.store(c.page, request.POST.get('logo').file)
            except Exception, e:
                model.meta.Session.rollback()
                h.flash(unicode(e), 'error')
                log.debug(e)
                return self.edit(id, variant=c.variant, text=c.text.id,
                                 branch=branch, format=format)

            parent_text = self.form_result.get("parent_text")
            if ((branch or
                 parent_text.variant != self.form_result.get("variant")) and
                    self.form_result.get("variant") in c.page.variants):
                msg = (_("Variant %s is already present, cannot branch.") %
                       self.form_result.get("variant"))
                raise Invalid(msg, branch, state_(),
                              error_dict={'variant': msg})
        except Invalid, i:
            return self.edit(id, variant=c.variant, text=c.text.id,
                             branch=branch, errors=i.unpack_errors(),
                             format=format)

        c.variant = self.form_result.get("variant")
        require.norm.edit(c.page, c.variant)

        if parent_text.page != c.page:
            return ret_abort(_("You're trying to update to a text which is "
                               "not part of this pages history"),
                             code=400, format=format)

        if can.variant.edit(c.page, model.Text.HEAD):
            parent_page = self.form_result.get("parent_page", NoPage)
            if parent_page != NoPage and parent_page != c.page:
                c.page.parent = parent_page

        if can.page.manage(c.page):
            c.page.milestone = self.form_result.get('milestone')

            categories = self.form_result.get('category')
            category = categories[0] if categories else None
            c.page.set_category(category, c.user)

            c.page.formatting = self.form_result.get('formatting')
            c.page.sectionpage = self.form_result.get('sectionpage')
            c.page.allow_comment = self.form_result.get('allow_comment')
            c.page.allow_selection = self.form_result.get('allow_selection')
            c.page.always_show_original = self.form_result.get(
                'always_show_original')

        if not branch and c.variant != parent_text.variant \
                and parent_text.variant != model.Text.HEAD:
            c.page.rename_variant(parent_text.variant, c.variant)

        text = model.Text.create(c.page, c.variant, c.user,
                                 self.form_result.get("title"),
                                 self.form_result.get("text"),
                                 parent=parent_text)

        target = text
        proposal = self.form_result.get("proposal")
        if proposal is not None and can.selection.create(proposal):
            target = model.Selection.create(proposal, c.page, c.user,
                                            variant=c.variant)
            poll = target.variant_poll(c.variant)
            if poll and can.poll.vote(poll):
                decision = democracy.Decision(c.user, poll)
                decision.make(model.Vote.YES)
                model.Tally.create_from_poll(poll)

        if (config.get_bool('adhocracy.page.allow_abstracts')
                and c.instance.page_index_as_tiles
                and not c.page.is_section()):
            c.page.abstract = self.form_result.get('abstract')

        model.meta.Session.commit()
        if can.watch.create():
            watchlist.set_watch(c.page, self.form_result.get('watch'))
        event.emit(event.T_PAGE_EDIT, c.user, instance=c.instance,
                   topics=[c.page], page=c.page, rev=text)
        if c.came_from != u'':
            redirect(c.came_from)
        else:
            redirect(h.entity_url(text))

    @classmethod
    def _diff_details(cls, left, right, formatting):
        left_text = left.text.strip() if left.text else ''
        right_text = right.text.strip() if right.text else ''
        has_changes = ((left_text != right_text))

        title = right.title
        if formatting:
            text = render_text(right.text)
        else:
            text = render_line_based(right)
        text_diff = norm_texts_inline_compare(left, right)
        title_diff = page_titles_compare(left, right)

        return dict(title=title, text=text, title_diff=title_diff,
                    text_diff=text_diff, has_changes=has_changes,
                    is_head=(right.variant == model.Text.HEAD))

    @classmethod
    def _selection_urls(cls, selection):
        urls = {}
        for (variant, poll) in selection.variant_polls:
            urls[variant] = {
                'votes': h.entity_url(poll, member="votes"),
                'poll_widget': h.entity_url(poll, member="widget.big")}
        return {'urls': urls}

    @classmethod
    def _selections_details(cls, page, variant, current_selection=None):
        try:
            selections = model.Selection.by_variant(page, variant)
        except IndexError:
            selections = []
        return [cls._selection_details(selection, variant,
                                       current_selection=current_selection)
                for selection in selections]

    @classmethod
    def _selection_details(cls, selection, variant, current_selection=None):
        try:
            score = selection.variant_poll(variant).tally.score
        except:
            score = 0
        rendered_score = "%+d" % score
        current = False
        if current_selection is not None:
            current = selection.id == current_selection.id
        return {'score': score,
                'rendered_score': rendered_score,
                'selection_id': selection.id,
                'proposal_title': selection.proposal.title,
                'proposal_text': render_text(
                    selection.proposal.description.head.text),
                'proposal_url': h.selection.url(selection),
                'proposal_creator_name': selection.proposal.creator.name,
                'proposal_creator_url': h.entity_url(
                    selection.proposal.creator),
                'proposal_create_time': h.datetime_tag(
                    selection.proposal.create_time),
                'proposal_edit_url': h.entity_url(
                    selection.proposal, member='edit'),
                'proposal_can_edit': can.proposal.edit(selection.proposal),
                'proposal_delete_url': h.entity_url(selection.proposal,
                                                    member='ask_delete'),
                'proposal_can_delete': can.proposal.delete(selection.proposal),
                'current': current,
                }

    @classmethod
    def _variant_details(cls, page, variant):
        '''
        Return details for a variant including diff information
        and details about the proposals that selected this variant.
        '''
        head_text = page.head
        variant_text = page.variant_head(variant)
        details = cls._diff_details(head_text, variant_text, page.formatting)

        # Replace items coming from diff_details for the UI
        messages = (('text', _('<i>(No text)</i>')),
                    ('title', _('<i>(No title)</i>')),
                    ('text_diff', _('<i>(No differences)</i>')),
                    ('title_diff', _('<i>(No differences)</i>')))
        for (key, message) in messages:
            if details[key].strip() == '':
                details[key] = message

        selections = cls._selections_details(page, variant)
        if variant == model.Text.HEAD:
            is_head = True
            votewidget_url = ''
        else:
            is_head = False
            try:
                selection = model.Selection.by_variant(page, variant)[0]
                votewidget_url = h.entity_url(
                    selection.proposal.rate_poll,
                    member="widget.big")
            except IndexError:
                votewidget_url = ''
        details.update(
            {'variant': variant,
             'display_title': cls._variant_display_title(variant),
             'history_url': h.entity_url(variant_text, member='history'),
             'history_count': len(variant_text.history),
             'selections': selections,
             'num_selections': len(selections),
             'is_head': is_head,
             'can_edit': can.variant.edit(page, variant),
             'edit_url': h.entity_url(variant_text, member='edit'),
             'votewidget_url': votewidget_url})
        return details

    @classmethod
    def _variant_display_title(cls, variant):
        if variant == model.Text.HEAD:
            return _('Original version')
        return _(u'Variant: "%s"') % variant

    @classmethod
    def _variant_item(cls, page, variant):
        '''
        Return a `dict` with information about the variant.
        '''
        is_head = (variant == model.Text.HEAD)
        title = _('Original Version') if is_head else variant
        return {'href': h.page.page_variant_url(page, variant=variant),
                'title': title,
                'display_title': title,  # bbb
                'is_head': is_head,
                'variant': variant}

    @classmethod
    def _variant_items(self, page, selection=None):
        '''
        Return a `list` of `dicts` with information about the variants.
        '''
        items = []
        for variant in page.variants:
            if selection and (variant not in selection.variants):
                continue
            item = self._variant_item(page, variant)
            items.append(item)

        return items

    @classmethod
    def _insert_variant_score_and_sort(self, items, score_func):
        '''
        Insert the score into the items and sort the variant items based
        on their *score* with mode.Text.HEAD as the first item.

        score_func is a method that receives the item as the only
        argument.
        '''
        head_item = None
        other_items = []
        for item in items:
            if item['variant'] == model.Text.HEAD:
                item['score'] = None
                item['rendered_score'] = ''
                head_item = item
            else:
                score = score_func(item)
                item['score'] = score
                item['rendered_score'] = '%+d' % score
                other_items.append(item)

        items = sorted(other_items, key=itemgetter('score'), reverse=True)
        items.insert(0, head_item)
        return items

    @RequireInstance
    def show(self, id, variant=None, text=None, format='html',
             amendment=False):
        if amendment:
            # variant may actually be a proposal id
            proposal = model.Proposal.find(variant)
            if proposal is not None and proposal.is_amendment:
                variant = proposal.selection.selected

        c.page, c.text, c.variant = self._get_page_and_text(id, variant, text)
        require.page.show(c.page)

        c.overlay = format == 'overlay'
        c.amendment = amendment

        if c.amendment and not c.page.allow_selection:
            return ret_abort(
                _("Page %s does not allow selections") % c.page.title,
                code=400, format=format)

        # Error handling and json api
        if c.text.variant != c.variant:
            abort(404, _("Variant %s does not exist!") % c.variant)
        if format == 'json':
            return render_json(c.page.to_dict(text=c.text))

        c.category = c.page.category
        # variant details and returning them as json when requested.
        c.variant_details = self._variant_details(c.page, c.variant)
        if 'variant_json' in request.params:
            return render_json(c.variant_details)
        c.variant_details_json = json.dumps(c.variant_details, indent=4)

        # Make a list of variants to render the vertical tab navigation
        variant_items = self._variant_items(c.page)

        def get_score(item):
            selections = model.Selection.by_variant(c.page,
                                                    item['variant'])
            if len(selections):
                return selections[0].proposal.rate_poll.tally.score
            else:
                return 0

        variant_items = self._insert_variant_score_and_sort(variant_items,
                                                            get_score)

        # filter out all but the highest rated variant from a proposal
        c.variant_items = []
        selections = []
        for item in variant_items:
            variant = item['variant']
            if variant == model.Text.HEAD:
                c.variant_items.append(item)
                continue
            selections_ = model.Selection.by_variant(c.page, variant)
            if not selections_:
                log.warning('continue - no selection: %s' % variant)
                continue
            selection = selections_[0]
            if selection not in selections:
                selections.append(selection)
                c.variant_items.append(item)

        # Metadata and subpages pager
        sorts = {_("oldest"): sorting.entity_oldest,
                 _("newest"): sorting.entity_newest,
                 _("alphabetically"): sorting.delegateable_title}
        c.subpages_pager = pager.NamedPager(
            'subpages', c.page.subpages,
            (tiles.page.row
             if c.page.function == model.Page.CONTAINER
             else tiles.page.smallrow),
            sorts=sorts, default_sort=sorting.delegateable_title)
        self._common_metadata(c.page, c.text)
        c.tutorial_intro = _('tutorial_norm_show_tab')
        c.tutorial = 'page_show'

        if c.page.function == c.page.CONTAINER:
            return render("/page/show_container.html")
        elif not c.amendment and c.page.is_sectionpage():
            return render("/page/show_sectionpage.html",
                          overlay=(format == 'overlay'))
        else:
            return render("/page/show.html",
                          overlay=(format == 'overlay'))

    @RequireInstance
    def history(self, id, variant=model.Text.HEAD, text=None, format='html'):
        c.page, c.text, c.variant = self._get_page_and_text(id, variant, text)
        require.page.show(c.page)
        if c.text is None:
            h.flash(_("No such text revision."), 'notice')
            redirect(h.entity_url(c.page))
        c.texts_pager = pager.NamedPager(
            'texts', c.text.history, tiles.text.history_row, count=10,
            sorts={},
            default_sort=sorting.entity_newest)

        if format == 'json':
            return render_json(c.texts_pager)
        c.tile = tiles.page.PageTile(c.page)
        self._common_metadata(c.page, c.text)

        if format == 'ajax':
            return c.texts_pager.here()
        elif format == 'overlay':
            return render('/page/history.html', overlay=True)
        else:
            return render('/page/history.html')

    @RequireInstance
    def comments(self, id, variant=model.Text.HEAD, text=None, format=None):
        c.page, c.text, c.variant = self._get_page_and_text(id, variant, text)
        require.page.show(c.page)
        if not c.page.allow_comment:
            return ret_abort(
                _("Page %s does not allow comments") % c.page.title,
                code=400, format=format)

        if c.text is None:
            h.flash(_("No such text revision."), 'notice')
            redirect(h.entity_url(c.page))
        self._common_metadata(c.page, c.text)
        c.came_from = ''

        if format == 'ajax':
            return tiles.comment.list(c.page)
        elif format == 'overlay':
            c.came_from = h.entity_url(c.page, member='comments') + '.overlay'
            return render('/page/comments.html', overlay=True,
                          overlay_size=OVERLAY_SMALL)
        else:
            return render('/page/comments.html')

    @RequireInstance
    @validate(schema=PageDiffForm(), form='bad_request', post_only=False,
              on_get=True)
    def diff(self):
        left = self.form_result.get('left')
        right = self.form_result.get('right')
        require.page.show(left.page)
        require.page.show(right.page)
        options = [right.page.variant_head(v) for v in right.page.variants]
        return self._differ(left, right, options=options)

    def _differ(self, left, right, options=None):
        if left == right:
            h.flash(_("Cannot compare identical text revisions."), 'notice')
            redirect(h.entity_url(right))
        c.left, c.right = (left, right)
        c.left_options = options
        if c.left.page != c.right.page:
            h.flash(_("Cannot compare versions of different texts."), 'notice')
            redirect(h.entity_url(c.right))
        c.tile = tiles.page.PageTile(c.right.page)
        self._common_metadata(c.right.page, c.right)
        return render("/page/diff.html")

    @RequireInstance
    def ask_purge(self, id, variant):
        c.page, c.text, c.variant = self._get_page_and_text(id, variant, None)
        require.variant.delete(c.page, c.variant)
        c.tile = tiles.page.PageTile(c.page)
        return render("/page/ask_purge.html")

    @RequireInstance
    @RequireInternalRequest()
    def purge(self, id, variant):
        c.page, c.text, c.variant = self._get_page_and_text(id, variant, None)
        require.variant.delete(c.page, c.variant)
        c.page.purge_variant(c.variant)
        model.meta.Session.commit()
        # event.emit(event.T_PAGE_DELETE, c.user, instance=c.instance,
        #            topics=[c.page], page=c.page)
        h.flash(_("The variant %s has been deleted.") % c.variant,
                'success')
        redirect(h.entity_url(c.page))

    @RequireInstance
    def ask_purge_history(self, id, text):
        c.page, c.text, c.variant = self._get_page_and_text(id, None, text)
        require.page.delete_history(c.page)
        if c.text.valid_child() is None and c.text.valid_parent() is None:
            h.flash(_("Cannot delete, if there's only one version"), 'error')
            return redirect(h.entity_url(c.text))
        return render("/page/ask_purge_history.html")

    @RequireInstance
    @RequireInternalRequest()
    def purge_history(self, id, text):
        c.page, c.text, c.variant = self._get_page_and_text(id, None, text)
        require.page.delete_history(c.page)
        if c.text.valid_child() is None and c.text.valid_parent() is None:
            h.flash(_("Cannot delete, if there's only one version"), 'error')
            return redirect(h.entity_url(c.text))
        c.text.delete()
        model.meta.Session.commit()
        h.flash(_("The selected version has been deleted."), 'success')
        redirect(h.entity_url(c.page))

    @RequireInstance
    def ask_delete(self, id, format="html"):
        c.page = get_entity_or_abort(model.Page, id)
        require.page.delete(c.page)
        c.tile = tiles.page.PageTile(c.page)

        c.section = u'section_parent' in request.params
        if c.section:
            c.parent = get_entity_or_abort(
                model.Page, request.params.get(u'section_parent'))
            c.came_from = h.entity_url(c.parent)
        else:
            c.came_from = h.entity_url(c.page.instance)

        return render("/page/ask_delete.html", overlay=(format == u'overlay'))

    @RequireInstance
    @RequireInternalRequest()
    def delete(self, id):
        c.page = get_entity_or_abort(model.Page, id)
        require.page.delete(c.page)
        c.page.delete()
        model.meta.Session.commit()
        event.emit(event.T_PAGE_DELETE, c.user, instance=c.instance,
                   topics=[c.page], page=c.page)
        h.flash(_("The page %s has been deleted.") % c.page.title,
                'success')
        redirect(c.came_from)

    def _get_page_and_text(self, id, variant, text):
        page = get_entity_or_abort(model.Page, id)
        _text = page.head
        if text is not None:
            _text = get_entity_or_abort(model.Text, text)
            if _text.page != page or (variant and _text.variant != variant):
                abort(404, _("Invalid text ID %s for this page/variant!") %
                      text)
            variant = _text.variant
        elif variant is not None:
            _text = page.variant_head(variant)
            if _text is None:
                _text = page.head
        else:
            variant = _text.variant
        return (page, _text, variant)

    def _common_metadata(self, page, text):
        if text and text.text and len(text.text):
            h.add_meta("description",
                       libtext.meta_escape(text.text, markdown=False)[0:160])
        tags = page.tags
        if len(tags):
            h.add_meta("keywords", ", ".join([k.name for (k, v) in tags]))
        h.add_meta("dc.title",
                   libtext.meta_escape(page.title, markdown=False))
        h.add_meta("dc.date",
                   page.create_time.strftime("%Y-%m-%d"))
        h.add_meta("dc.author",
                   libtext.meta_escape(text.user.name, markdown=False))

    @RequireInstance
    def logo(self, id, y, x=None):
        page = get_entity_or_abort(model.Page, id)
        return render_logo(page, y, x=x)

########NEW FILE########
__FILENAME__ = poll
import logging

import formencode
from formencode import validators

from pylons import tmpl_context as c
from pylons.controllers.util import abort, redirect
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import democracy, event, helpers as h, pager, tiles
from adhocracy.lib import votedetail
from adhocracy.lib.auth import require
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.templating import render, render_def, render_json
from adhocracy.lib.templating import ret_abort, ret_success
from adhocracy.lib.util import get_entity_or_abort


log = logging.getLogger(__name__)


class PollVotesFilterForm(formencode.Schema):
    allow_extra_fields = True
    result = validators.Int(not_empty=False, if_empty=None, if_missing=None,
                            min=model.Vote.NO, max=model.Vote.YES)


class PollVoteForm(formencode.Schema):
    allow_extra_fields = True
    position = validators.Int(min=model.Vote.NO, max=model.Vote.YES,
                              not_empty=True)


class PollController(BaseController):

    def index(self, format='html'):
        return self.not_implemented(format=format)

    def new(self, id, format='html'):
        return self.not_implemented(format=format)

    def create(self, id, format='html'):
        return self.not_implemented(format=format)

    def edit(self, id, format='html'):
        return self.not_implemented(format=format)

    def update(self, id, format='html'):
        return self.not_implemented(format=format)

    @RequireInstance
    def show(self, id, format='html'):
        poll = get_entity_or_abort(model.Poll, id)
        require.poll.show(poll)

        if format == 'json':
            return render_json(poll)
        else:
            return self.not_implemented(format=format)

    @RequireInstance
    @RequireInternalRequest()
    @validate(schema=PollVoteForm(), form="bad_request", post_only=False,
              on_get=True)
    def vote(self, id, format):
        c.poll = self._get_open_poll(id)
        if c.poll.action != model.Poll.ADOPT:
            abort(400, _("This is not an adoption poll."))
        require.poll.vote(c.poll)
        decision = democracy.Decision(c.user, c.poll)
        votes = decision.make(self.form_result.get("position"))
        model.meta.Session.commit()

        if not h.poll.hide_individual_votes(c.poll):
            for vote in votes:
                event.emit(event.T_VOTE_CAST, vote.user, instance=c.instance,
                           topics=[c.poll.scope], vote=vote, poll=c.poll)

        if format == 'json':
            vdetail = votedetail.calc_votedetail_dict(c.instance, c.poll)\
                if votedetail.is_enabled() else None
            return render_json(dict(decision=decision,
                                    score=c.poll.tally.score,
                                    votedetail=vdetail))
        else:
            redirect(h.entity_url(c.poll.subject))

    @RequireInstance
    @RequireInternalRequest()
    @validate(schema=PollVoteForm(), form="bad_request",
              post_only=False, on_get=True)
    def rate(self, id, format):
        # rating is like polling but steps via abstention, i.e. if you have
        # first voted "for", rating will first go to "abstain" and only
        # then produce "against"-
        c.poll = self._get_open_poll(id)
        if c.poll.action not in [model.Poll.RATE, model.Poll.SELECT]:
            abort(400, _("This is not a rating poll."))
        require.poll.vote(c.poll)

        decision = democracy.Decision(c.user, c.poll)
        old = decision.result
        new = self.form_result.get("position")
        positions = {(model.Vote.YES, model.Vote.YES): model.Vote.YES,
                     (model.Vote.ABSTAIN, model.Vote.YES): model.Vote.YES,
                     (model.Vote.NO, model.Vote.YES): model.Vote.ABSTAIN,
                     (model.Vote.YES, model.Vote.NO): model.Vote.ABSTAIN,
                     (model.Vote.ABSTAIN, model.Vote.NO): model.Vote.NO,
                     (model.Vote.NO, model.Vote.NO): model.Vote.NO}
        position = positions.get((old, new), new)
        votes = decision.make(position)
        tally = model.Tally.create_from_poll(c.poll)
        event_type = {model.Poll.RATE: event.T_RATING_CAST,
                      model.Poll.SELECT: event.T_SELECT_VARIANT
                      }.get(c.poll.action)
        model.meta.Session.commit()

        if not h.poll.hide_individual_votes(c.poll):
            for vote in votes:
                event.emit(event_type, vote.user, instance=c.instance,
                           topics=[c.poll.scope], vote=vote, poll=c.poll)

        if format == 'json':
            vdetail = votedetail.calc_votedetail_dict(c.instance, c.poll)\
                if votedetail.is_enabled() else None
            return render_json(dict(decision=decision,
                                    tally=tally.to_dict(),
                                    votedetail=vdetail))
        elif format == 'ajax':
            return self.widget(id, format=self.form_result.get('cls'))
        elif c.poll.action == model.Poll.SELECT:
            redirect(h.entity_url(c.poll.selection))
        else:
            redirect(h.entity_url(c.poll.subject))

    @RequireInstance
    @validate(schema=PollVotesFilterForm(), post_only=False, on_get=True)
    def votes(self, id, format='html'):
        c.poll = get_entity_or_abort(model.Poll, id)

        # cover over data inconsistency because of a bug where pages (norms)
        # were deleted when a proposal was deleted.
        # Fixes http://trac.adhocracy.de/ticket/262
        if (c.poll.action == model.Poll.SELECT and
                c.poll.selection is None):
            logmsg = ('Poll: "%s" is a model.Poll.rate poll, which should '
                      'have a selection, but the selection is None. Subject '
                      'of the Poll is %s') % (c.poll, c.poll.subject)
            log.error(logmsg)
            raise abort(404)

        require.poll.show(c.poll)
        decisions = democracy.Decision.for_poll(c.poll)
        if (hasattr(self, 'form_result') and
                self.form_result.get('result') is not None):
            result_form = self.form_result.get('result')
            decisions = filter(lambda d: d.result == result_form, decisions)
        c.decisions_pager = pager.scope_decisions(decisions)

        if format == 'json':
            return render_json(c.decisions_pager)
        elif format == 'ajax':
            return render_def('/pager.html', 'overlay_pager',
                              pager=c.decisions_pager,
                              render_facets=False)
        elif format == 'overlay':
            return render("/poll/votes.html", overlay=True)
        else:
            return render("/poll/votes.html")

    def ask_delete(self, id):
        c.poll = self._get_open_poll(id)
        require.poll.delete(c.poll)
        return render('/poll/ask_delete.html')

    def delete(self, id, format):
        c.poll = self._get_open_poll(id)
        require.poll.delete(c.poll)
        c.poll.end()
        model.meta.Session.commit()
        event.emit(event.T_PROPOSAL_STATE_REDRAFT, c.user, instance=c.instance,
                   topics=[c.poll.scope], proposal=c.poll.scope, poll=c.poll)
        return ret_success(message=_("The poll has ended."),
                           entity=c.poll.subject)

    def _get_open_poll(self, id):
        poll = get_entity_or_abort(model.Poll, id)
        if poll.has_ended():
            return ret_abort(_("The proposal is not undergoing a poll."),
                             code=404)
        return poll

    def widget(self, id, format):
        if format is None:
            format = ''
        poll = get_entity_or_abort(model.Poll, id)
        return tiles.poll.widget(poll, cls=format)

########NEW FILE########
__FILENAME__ = proposal
import logging
import urllib

import formencode
from formencode import htmlfill, Invalid, validators

from pylons import request, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import config
from adhocracy import forms, model
from adhocracy.lib import democracy, event, helpers as h, pager
from adhocracy.lib import sorting, tiles, watchlist
from adhocracy.lib import votedetail
from adhocracy.lib.auth import authorization, can, csrf, require, guard
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.templating import render, render_def, render_json, ret_abort
from adhocracy.lib.templating import OVERLAY_SMALL
from adhocracy.lib.queue import update_entity
from adhocracy.lib.util import get_entity_or_abort
from adhocracy.lib.util import split_filter
from adhocracy.lib.text import title2alias
from adhocracy.lib.text import variant_normalize

import adhocracy.lib.text as text


log = logging.getLogger(__name__)


class ProposalNewForm(formencode.Schema):
    allow_extra_fields = True


class PageInclusionForm(formencode.Schema):
    id = forms.ValidPage()
    text = validators.String(max=20000, min=0, if_empty="")


class ProposalCreateForm(ProposalNewForm):
    pre_validators = [formencode.variabledecode.NestedVariables()]
    title = forms.ValidProposalTitle(unused_label=True)
    text = validators.String(max=20000, min=4, not_empty=True)
    tags = validators.String(max=20000, not_empty=False, if_missing=None)
    amendment = validators.StringBool(not_empty=False, if_empty=False,
                                      if_missing=False)
    milestone = forms.MaybeMilestone(if_empty=None,
                                     if_missing=None)
    page = formencode.foreach.ForEach(PageInclusionForm())
    category = formencode.foreach.ForEach(forms.ValidCategoryBadge())
    watch = validators.StringBool(not_empty=False, if_empty=False,
                                  if_missing=False)
    wiki = validators.StringBool(not_empty=False, if_empty=False,
                                 if_missing=False)


class ProposalEditForm(formencode.Schema):
    allow_extra_fields = True


class ProposalUpdateForm(ProposalEditForm):
    title = forms.ValidProposalTitle()
    text = validators.String(max=20000, min=4, not_empty=True)
    wiki = validators.StringBool(not_empty=False, if_empty=False,
                                 if_missing=False)
    frozen = validators.StringBool(not_empty=False, if_empty=False,
                                   if_missing=False)
    milestone = forms.MaybeMilestone(if_empty=None,
                                     if_missing=None)
    category = formencode.foreach.ForEach(forms.ValidCategoryBadge())
    watch = validators.StringBool(not_empty=False, if_empty=False,
                                  if_missing=False)
    badge = formencode.foreach.ForEach(forms.ValidDelegateableBadge())
    thumbnailbadge = formencode.foreach.ForEach(forms.ValidThumbnailBadge())


class ProposalFilterForm(formencode.Schema):
    allow_extra_fields = True
    proposals_q = validators.String(max=255, not_empty=False,
                                    if_empty=None, if_missing=None)
    proposals_state = validators.String(max=255, not_empty=False,
                                        if_empty=None, if_missing=None)


class DelegateableBadgesForm(formencode.Schema):
    allow_extra_fields = True
    badge = formencode.foreach.ForEach(forms.ValidDelegateableBadge())
    thumbnailbadge = formencode.foreach.ForEach(forms.ValidThumbnailBadge())


class ProposalController(BaseController):

    identifier = 'proposals'

    def __init__(self):
        super(ProposalController, self).__init__()

    @RequireInstance
    @validate(schema=ProposalFilterForm(), post_only=False, on_get=True)
    def index(self, format="html"):
        require.proposal.index()
        query = self.form_result.get('proposals_q')

        # FIXME: Add tag filtering again (now solr based)
        # FIXME: Live filtering ignores selected facets.
        c.proposals_pager = pager.solr_proposal_pager(
            c.instance,
            {'text': query})

        if format == 'json':
            return render_json(c.proposals_pager)

        c.tile = tiles.instance.InstanceTile(c.instance)
        c.tutorial_intro = _('tutorial_proposal_overview_tab')
        c.tutorial = 'proposal_index'

        if format == 'overlay':
            return render("/proposal/index.html", overlay=True)
        else:
            return render("/proposal/index.html")

    def _set_categories(self):
        categories = model.CategoryBadge.all(
            c.instance, include_global=not c.instance.hide_global_categories)

        toplevel, lowerlevel = split_filter(lambda c: c.parent is None,
                                            categories)

        # If there is exactly one top level category and there are lower
        # level categories, only these are shown in the category chooser,
        # and the (single) toplevel select description is used as the toplevel
        # select prompt.

        if len(toplevel) == 1 and len(lowerlevel) > 0:
            categories = lowerlevel
            c.toplevel_question = toplevel[0].select_child_description
            root = toplevel[0]
        else:
            c.toplevel_question = None
            root = None

        c.categories = sorted(
            [(cat.id, cat.get_key(root), cat.select_child_description)
             for cat in categories],
            key=lambda x: x[1])

    @RequireInstance
    @guard.proposal.create()
    @validate(schema=ProposalNewForm(), form='bad_request',
              post_only=False, on_get=True)
    def new(self, errors=None, page=None, amendment=False, format='html'):
        c.pages = []
        c.exclude_pages = []
        c.amendment = bool(amendment)
        if c.amendment:
            c.page = get_entity_or_abort(model.Page, page)

        if c.amendment and not c.page.allow_selection:
            return ret_abort(
                _("Page %s does not allow selections") % c.page.title,
                code=400, format=format)

        if h.site.is_local_url(request.params.get(u'cancel_url', u'')):
            c.cancel_url = request.params['cancel_url']
        elif amendment:
            c.cancel_url = h.entity_url(c.page, member='amendment')
        else:
            c.cancel_url = h.base_url('/proposal')

        self._set_categories()

        if 'category' in request.params:
            badge = model.CategoryBadge.find(request.params['category'])
            if badge is not None:
                c.selected_category = (badge.id, badge.title)

        def append_page(pid, text=None):
            page = model.Page.find(pid)
            if (page
                and page not in c.exclude_pages
                and page.function == model.Page.NORM
                and (page.allow_selection
                     or c.instance.allow_propose_changes)):
                c.pages.append((page.id, page.title,
                                page.head.text if text is None else text))
                c.exclude_pages.append(page)

        if page is not None:
            append_page(page)
        if 'page' in request.params:
            append_page(request.params.get('page'))

        try:
            val = formencode.variabledecode.NestedVariables()
            form = val.to_python(request.params)
            for pg in form.get('page', []):
                append_page(pg.get('id'), pg.get('text'))
        except:
            pass

        if c.instance.use_norms and c.instance.allow_propose_changes:
            q = model.meta.Session.query(model.Page)
            q = q.filter(model.Page.function == model.Page.NORM)
            q = q.filter(model.Page.instance == c.instance)
            q = q.filter(model.Page.allow_selection == False)  # noqa
            c.exclude_pages += q.all()
            c.can_select = True
        else:
            c.can_select = False

        defaults = dict(request.params)
        if not defaults:
            defaults['watch'] = True
            defaults['wiki'] = c.instance.editable_proposals_default

        return htmlfill.render(render("/proposal/new.html",
                                      overlay=format == u'overlay'),
                               defaults=defaults, errors=errors,
                               force_defaults=False)

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    @guard.proposal.create()
    def create(self, page=None, format='html', amendment=False):
        """amendment does only indicate if this controller was called from
        the amendment route. The information about wether this will be an
        amendment or classic proposal must be given in the form."""

        try:
            self.form_result = ProposalCreateForm().to_python(request.params)
        except Invalid, i:
            return self.new(errors=i.unpack_errors(), page=page,
                            amendment=amendment)

        title = self.form_result.get('title')
        label = title2alias(title)
        variant = variant_normalize(title)

        pages = self.form_result.get('page', [])
        is_amendment = self.form_result.get('amendment', False)

        if ((is_amendment and len(pages) != 1) or
                any([not p['id'].allow_selection for p in pages]) or
                (not is_amendment and not c.instance.allow_propose_changes and
                    len(pages) != 0)):
            return self.new(
                errors={u'msg':
                        u'Cannot change arbitrary norms within proposals'})

        if c.instance.require_selection and len(pages) < 1:
            h.flash(
                _('Please select norm and propose a change to it.'),
                'error')
            return self.new()
        proposal = model.Proposal.create(c.instance,
                                         label,
                                         c.user, with_vote=can.user.vote(),
                                         tags=self.form_result.get("tags"),
                                         is_amendment=is_amendment)
        proposal.milestone = self.form_result.get('milestone')
        model.meta.Session.flush()
        description = model.Page.create(c.instance,
                                        title,
                                        self.form_result.get('text'),
                                        c.user,
                                        function=model.Page.DESCRIPTION,
                                        wiki=self.form_result.get('wiki'),
                                        formatting=True)
        description.parents = [proposal]
        model.meta.Session.flush()
        proposal.description = description

        categories = self.form_result.get('category')
        category = categories[0] if categories else None
        proposal.set_category(category, c.user)

        for page in pages:
            page_text = page.get('text', '')
            page = page.get('id')
            if page is None or page.function != model.Page.NORM:
                continue
            if not can.norm.edit(page, variant) or \
               not can.selection.create(proposal):
                continue
            model.Text.create(page, variant, c.user,
                              page.head.title,
                              page_text, parent=page.head)
            selection = model.Selection.create(proposal, page, c.user,
                                               variant=variant)
            poll = selection.variant_poll(variant)
            if poll and can.poll.vote(poll):
                decision = democracy.Decision(c.user, poll)
                decision.make(model.Vote.YES)
                model.Tally.create_from_poll(poll)

        model.meta.Session.commit()
        if can.watch.create():
            watchlist.set_watch(proposal, self.form_result.get('watch'))
        if is_amendment:
            event.emit(event.T_AMENDMENT_CREATE, c.user, instance=c.instance,
                       topics=[proposal, page], proposal=proposal,
                       rev=description.head, page=page)
        else:
            event.emit(event.T_PROPOSAL_CREATE, c.user, instance=c.instance,
                       topics=[proposal], proposal=proposal,
                       rev=description.head)
        redirect(h.entity_url(proposal, format=format, in_overlay=False))

    @RequireInstance
    @validate(schema=ProposalEditForm(), form="bad_request",
              post_only=False, on_get=True)
    def edit(self, id, errors={}, page=None, format=u'html'):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        c.badges = self._editable_badges(c.proposal)
        c.thumbnailbadges = self._editable_thumbnailbadges(c.proposal)
        require.proposal.edit(c.proposal)
        c.can_edit_wiki = self._can_edit_wiki(c.proposal, c.user)

        c.text_rows = text.text_rows(c.proposal.description.head)

        self._set_categories()

        # categories for this proposal
        # (single category not assured in db model)
        c.category = c.proposal.category

        force_defaults = False
        if errors:
            force_defaults = True
        defaults = dict(request.POST)
        if not defaults:
            # Just clicked on edit
            defaults['watch'] = h.find_watch(c.proposal) is not None
            defaults['frozen'] = c.proposal.frozen
        defaults.update({"category": c.category.id if c.category else None})
        return htmlfill.render(render("/proposal/edit.html",
                                      overlay=format == u'overlay',
                                      overlay_size=OVERLAY_SMALL),
                               defaults=defaults,
                               errors=errors, force_defaults=force_defaults)

    @RequireInstance
    @csrf.RequireInternalRequest(methods=['POST'])
    def update(self, id, format='html'):
        try:
            c.proposal = get_entity_or_abort(model.Proposal, id)

            class state_(object):
                page = c.proposal.description

            self.form_result = ProposalUpdateForm().to_python(request.params,
                                                              state=state_())

            badges = self.form_result.get('badge')
            thumbnailbadges = self.form_result.get('thumbnailbadge')
        except Invalid, i:
            return self.edit(id, errors=i.unpack_errors())

        require.proposal.edit(c.proposal)

        c.proposal.milestone = self.form_result.get('milestone')
        model.meta.Session.add(c.proposal)

        if not config.get_bool('adhocracy.proposal.split_badge_edit'):
            added, removed = self._update_badges(badges, thumbnailbadges,
                                                 c.proposal)
        else:
            added = removed = []

        # change the category
        categories = self.form_result.get('category')
        category = categories[0] if categories else None
        c.proposal.set_category(category, c.user)

        if self._can_edit_wiki(c.proposal, c.user):
            wiki = self.form_result.get('wiki')
        else:
            wiki = c.proposal.description.head.wiki

        if h.has_permission('proposal.freeze'):
            c.proposal.frozen = self.form_result.get('frozen')

        _text = model.Text.create(c.proposal.description, model.Text.HEAD,
                                  c.user,
                                  self.form_result.get('title'),
                                  self.form_result.get('text'),
                                  parent=c.proposal.description.head,
                                  wiki=wiki)
        model.meta.Session.commit()
        if can.watch.create():
            watchlist.set_watch(c.proposal, self.form_result.get('watch'))
        if c.proposal.is_amendment:
            page = c.proposal.selection.page
            event.emit(event.T_AMENDMENT_EDIT, c.user, instance=c.instance,
                       topics=[c.proposal, page], proposal=c.proposal,
                       page=page, rev=_text,
                       badges_added=added, badges_removed=removed)
        else:
            event.emit(event.T_PROPOSAL_EDIT, c.user, instance=c.instance,
                       topics=[c.proposal], proposal=c.proposal, rev=_text,
                       badges_added=added, badges_removed=removed)
        redirect(h.entity_url(c.proposal, format=format, in_overlay=False))

    @RequireInstance
    def show(self, id, format='html'):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.show(c.proposal)

        c.num_selections = c.proposal.selections
        c.show_selections = (c.proposal.instance.use_norms
                             and c.proposal.instance.allow_propose_changes)
        if c.show_selections:
            c.sorted_selections = sorting.sortable_text(
                c.proposal.selections,
                key=lambda s: s.page.title)

        if votedetail.is_enabled():
            c.votedetail = votedetail.calc_votedetail_dict(
                c.instance, c.proposal.rate_poll)

        if format == 'rss':
            return self.activity(id, format)
        elif format == 'json':
            return render_json(c.proposal)

        c.tile = tiles.proposal.ProposalTile(c.proposal)
        used_pages = [selection.page for selection in c.proposal.selections]
        functions = [model.Page.NORM]
        available_pages = model.Page.all(instance=c.instance,
                                         exclude=used_pages,
                                         functions=functions)
        c.disable_include = len(available_pages) == 0
        c.history_url = h.entity_url(c.proposal.description.head,
                                     member='history')
        c.category = c.proposal.category
        self._common_metadata(c.proposal)
        c.tutorial_intro = _('tutorial_proposal_show_tab')
        c.tutorial = 'proposal_show'
        monitor_comment_behavior = config.get_bool(
            'adhocracy.monitor_comment_behavior')
        if monitor_comment_behavior:
            c.monitor_comment_url = '%s?%s' % (
                h.base_url('/stats/read_comments'),
                urllib.urlencode({'path':
                                  h.entity_url(c.proposal).encode('utf-8')}))

        if format == 'overlay':
            return render("/proposal/show.html", overlay=True)
        else:
            return render("/proposal/show.html")

    @RequireInstance
    def comments(self, id, format="html"):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.show(c.proposal)
        c.page = c.proposal.description

        if format == u'overlay':
            c.came_from = h.entity_url(c.proposal,
                                       member='comments',
                                       in_overlay=False,
                                       format='overlay')
            return render("/page/comments.html", overlay=True,
                          overlay_size=OVERLAY_SMALL)
        else:
            return render("/page/comments.html")

    @RequireInstance
    def history(self, id, format="html"):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.show(c.proposal)

        proposal_text = c.proposal.description.head
        c.texts_pager = pager.NamedPager(
            'texts', proposal_text.history, tiles.text.history_row, count=10,
            sorts={_("oldest"): sorting.entity_oldest,
                   _("newest"): sorting.entity_newest},
            default_sort=sorting.entity_newest)

        self._common_metadata(c.proposal)
        if format == 'ajax':
            return render_def('/proposal/history.html', 'content')
        elif format == 'overlay':
            return render('/proposal/history.html', overlay=True,
                          overlay_size=OVERLAY_SMALL)
        else:
            return render('/proposal/history.html')

    @RequireInstance
    def delegations(self, id, format="html"):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.show(c.proposal)
        delegations = c.proposal.current_delegations()
        c.delegations_pager = pager.delegations(delegations)

        if format == 'json':
            return render_json(c.delegations_pager)

        c.tile = tiles.proposal.ProposalTile(c.proposal)
        self._common_metadata(c.proposal)
        if format == 'overlay':
            return render("/proposal/delegations.html", overlay=True)
        else:
            return render("/proposal/delegations.html")

    @RequireInstance
    def activity(self, id, format='html'):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.show(c.proposal)

        if format == 'rss':
            events = model.Event.find_by_topic(c.proposal, limit=50)
            return event.rss_feed(
                events, _("Proposal: %s") % c.proposal.title,
                h.entity_url(c.proposal),
                description=_("Activity on the %s proposal") % c.proposal.title
            )

        events = model.Event.find_by_topic(c.proposal)
        c.tile = tiles.proposal.ProposalTile(c.proposal)
        c.events_pager = pager.events(events)
        self._common_metadata(c.proposal)
        if format == 'overlay':
            return render("/proposal/activity.html", overlay=True)
        else:
            return render("/proposal/activity.html")

    @RequireInstance
    def ask_delete(self, id):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.delete(c.proposal)
        c.tile = tiles.proposal.ProposalTile(c.proposal)

        if format == 'overlay':
            return render('/proposal/ask_delete.html', overlay=True)
        else:
            return render('/proposal/ask_delete.html')

    @RequireInstance
    @csrf.RequireInternalRequest()
    def delete(self, id):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.delete(c.proposal)
        if c.proposal.is_amendment:
            came_from = h.entity_url(c.proposal.selection.page,
                                     member='amendment')
            page = c.proposal.selection.page
            event.emit(event.T_AMENDMENT_DELETE, c.user, instance=c.instance,
                       topics=[c.proposal, page], proposal=c.proposal,
                       page=page)
        else:
            came_from = h.entity_url(c.instance)
            event.emit(event.T_PROPOSAL_DELETE, c.user, instance=c.instance,
                       topics=[c.proposal], proposal=c.proposal)
        c.proposal.delete()
        model.meta.Session.commit()
        h.flash(_("The proposal %s has been deleted.") % c.proposal.title,
                'success')
        redirect(came_from)

    @RequireInstance
    def ask_adopt(self, id):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.adopt(c.proposal)
        return render('/proposal/ask_adopt.html')

    @RequireInstance
    def adopt(self, id):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.adopt(c.proposal)
        poll = model.Poll.create(c.proposal, c.user, model.Poll.ADOPT)
        model.meta.Session.commit()
        c.proposal.adopt_poll = poll
        model.meta.Session.commit()
        event.emit(event.T_PROPOSAL_STATE_VOTING, c.user, instance=c.instance,
                   topics=[c.proposal], proposal=c.proposal, poll=poll)
        redirect(h.entity_url(c.proposal, in_overlay=False))

    @RequireInstance
    @validate(schema=ProposalFilterForm(), post_only=False, on_get=True)
    def filter(self):
        require.proposal.index()
        query = self.form_result.get('proposals_q')
        proposals_pager = pager.solr_proposal_pager(c.instance,
                                                    {'text': query})
        return render_json({'listing': proposals_pager.here(),
                            'facets': proposals_pager.render_facets()})

    def _common_metadata(self, proposal):
        h.add_meta("description",
                   text.meta_escape(proposal.description.head.text,
                                    markdown=True)[0:160])
        tags = proposal.tags
        if len(tags):
            h.add_meta("keywords", ", ".join([k.name for (k, v) in tags]))
        h.add_meta("dc.title",
                   text.meta_escape(proposal.title, markdown=False))
        h.add_meta("dc.date",
                   proposal.create_time.strftime("%Y-%m-%d"))
        h.add_meta("dc.author",
                   text.meta_escape(proposal.creator.name, markdown=False))
        h.add_rss(_("Proposal: %(proposal)s") % {'proposal': proposal.title},
                  h.entity_url(c.proposal, format='rss'))

    def _can_edit_wiki(self, proposal, user):
        if authorization.has('instance.admin'):
            return True
        if proposal.creator == user:
            return True
        return False

    @classmethod
    def _editable_badges(cls, proposal):
        '''
        Return the badges editable that can be assigned by the current
        user.
        '''
        badges = []
        if can.proposal.edit_badges(proposal):
            badges.extend(model.DelegateableBadge.all(instance=c.instance))
            badges.extend(model.DelegateableBadge.all(instance=None))
        badges = sorted(badges, key=lambda badge: badge.title)
        return badges

    @classmethod
    def _editable_thumbnailbadges(cls, proposal):
        '''
        Return the thumbnailbadges editable that can be assigned by the current
        user.
        '''
        thumbnailbadges = []
        if can.proposal.edit_badges(proposal):
            thumbnailbadges.extend(
                model.ThumbnailBadge.all(instance=c.instance))
            thumbnailbadges.extend(model.ThumbnailBadge.all(instance=None))
        thumbnailbadges = sorted(thumbnailbadges,
                                 key=lambda badge: badge.title)
        return thumbnailbadges

    def badges(self, id, errors=None, format='html'):
        c.proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.edit_badges(c.proposal)
        c.badges = self._editable_badges(c.proposal)
        c.thumbnailbadges = self._editable_thumbnailbadges(c.proposal)
        default_thumbnail = c.proposal.thumbnails and \
            c.proposal.thumbnails[0].id or ''
        defaults = {'badge': [str(badge.id) for badge in c.proposal.badges],
                    '_tok': csrf.token_id(),
                    'thumbnailbadge': default_thumbnail,
                    }
        return formencode.htmlfill.render(
            render("/proposal/badges.html", overlay=format == u'overlay',
                   overlay_size=OVERLAY_SMALL),
            defaults=defaults)

    def _update_badges(self, badges, thumbnailbadges, proposal):
        editable_badges = self._editable_badges(proposal)
        editable_badges.extend(self._editable_thumbnailbadges(c.proposal))
        added = []
        removed = []

        for badge in badges + thumbnailbadges:
            if badge not in editable_badges:
                ret_abort(_(u"You are not allowed to edit badge %i")
                          % badge.id, code=403)

        for badge in proposal.badges:
            if badge not in badges:
                removed.append(badge)
                proposal.badges.remove(badge)
        for badge in proposal.thumbnails:
            if badge not in thumbnailbadges:
                removed.append(badge)
                proposal.thumbnails.remove(badge)

        for badge in badges + thumbnailbadges:
            if badge not in proposal.badges + proposal.thumbnails:
                badge.assign(proposal, c.user)
                added.append(badge)

        if added or removed:
            # FIXME: needs commit() cause we do a redirect() which raises
            # an Exception.
            model.meta.Session.commit()
            update_entity(proposal, model.UPDATE)

        return added, removed

    @RequireInternalRequest()
    @validate(schema=DelegateableBadgesForm(), form='badges')
    @csrf.RequireInternalRequest(methods=['POST'])
    def update_badges(self, id, format='html'):
        proposal = get_entity_or_abort(model.Proposal, id)
        require.proposal.edit_badges(proposal)
        badges = self.form_result.get('badge')
        thumbnailbadges = self.form_result.get('thumbnailbadge')
        redirect_to_proposals = self.form_result.get('redirect_to_proposals')

        added, removed = self._update_badges(badges, thumbnailbadges, proposal)
        if added or removed:
            event.emit(event.T_PROPOSAL_BADGE, c.user, instance=c.instance,
                       topics=[proposal], proposal=proposal,
                       badges_added=added, badges_removed=removed)

        if format == 'ajax':
            obj = {'badges_html': render_def('/badge/tiles.html', 'badges',
                                             badges=proposal.badges),
                   'thumbnailbadges_html': render_def(
                       '/badge/tiles.html', 'badges',
                       badges=proposal.thumbnails),
                   }
            return render_json(obj)
        elif redirect_to_proposals:
            redirect("/proposal")
        else:
            redirect(h.entity_url(proposal))

########NEW FILE########
__FILENAME__ = redirect
from pylons.controllers.util import redirect
from adhocracy.lib.base import BaseController
from adhocracy.lib.outgoing_link import decode_redirect


class RedirectController(BaseController):

    def outgoing_link(self, url_enc):
        url = decode_redirect(url_enc.decode('ascii'))
        return redirect(url)

########NEW FILE########
__FILENAME__ = root
from datetime import datetime
import logging

from pylons import request, response, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.decorators import validate
from sqlalchemy import not_

from adhocracy import config
from adhocracy import model
from adhocracy.controllers.event import EventController
from adhocracy.lib import helpers as h
from adhocracy.lib import pager, sorting
from adhocracy.lib.auth import guard
from adhocracy.lib.base import BaseController
from adhocracy.lib.staticpage import add_static_content
from adhocracy.lib.templating import render
from adhocracy.lib.util import get_entity_or_abort

from proposal import ProposalFilterForm


log = logging.getLogger(__name__)


class RootController(BaseController):

    @guard.proposal.index()
    @validate(schema=ProposalFilterForm(), post_only=False, on_get=True)
    def index(self, format='html'):

        if c.instance:
            redirect(h.entity_url(c.instance))

        if format == 'rss':
            return EventController().all(format='rss')

        name = config.get('adhocracy.redirect_startpage_to_instance')
        if name != u'':
            # get_entity_or_abort does no work for instances
            instance = model.Instance.find(name)
            if instance is not None:
                redirect(h.entity_url(instance))

        data = {}

        instances_in_root = config.get_int(
            'adhocracy.startpage.instances.list_length')
        if instances_in_root > 0:
            data['instances'] = model.Instance.all(limit=instances_in_root)
        elif instances_in_root == -1:
            data['instances'] = model.Instance.all()

        add_static_content(data, u'adhocracy.static_index_path')
        c.body_css_classes += data.get('css_classes', [])
        c.body_css_classes.append('added_static_content')
        if data['title'] is None:
            data['title'] = config.get('adhocracy.site.name')

        proposals_number = config.get_int(
            'adhocracy.startpage.proposals.list_length')

        if proposals_number > 0:
            proposals = model.Proposal.all_q()\
                .join(model.Instance).filter(not_(
                    model.Instance.key.in_(model.Instance.SPECIAL_KEYS)))\
                .order_by(model.Proposal.create_time.desc())

            data['new_proposals_pager'] = pager.proposals(
                proposals, size=proposals_number,
                default_sort=sorting.entity_newest,
                enable_pages=False,
                enable_sorts=False)
        else:
            data['new_proposals_pager'] = None

        if config.get_bool('adhocracy.show_stats_on_frontpage'):
            data['stats_global'] = {
                "members": model.User.all_q().count(),
                "comments": model.Comment.all_q().count(),
                "proposals": model.Proposal.all_q().count(),
                "votes": model.Vote.all_q().count(),
            }

        if format == 'overlay':
            return render('index.html', data, overlay=True)
        else:
            return render('index.html', data)

    # @RequireInstance
    def dispatch_delegateable(self, id):
        dgb = get_entity_or_abort(model.Delegateable, id,
                                  instance_filter=False)
        redirect(h.entity_url(dgb))

    @guard.proposal.index()
    def sitemap_xml(self):
        if c.instance:
            redirect(h.base_url('/sitemap.xml', None))
        c.proposals = model.Proposal.all()
        c.pages = model.Page.all(functions=[model.Page.NORM])
        c.change_time = datetime.utcnow()
        response.content_type = "text/xml"
        return render("sitemap.xml")

    def robots_txt(self):
        response.content_type = "text/plain"
        if not c.instance:
            return render("robots.txt")
        return render("instance/robots.txt")

    def tutorials(self):
        if 'disable' in request.params:
            name = request.params.get('disable')
            if name == 'ALL':
                h.tutorial.disable(None, c.user)
            else:
                h.tutorial.disable(name, c.user)
        else:
            h.tutorial.enable()

########NEW FILE########
__FILENAME__ = search
import logging

import formencode

from pylons import tmpl_context as c
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy.lib import search as libsearch, sorting, tiles
from adhocracy.lib.auth import guard
from adhocracy.lib.base import BaseController
from adhocracy.lib.pager import NamedPager
from adhocracy.lib.templating import render
from adhocracy.model import Comment

log = logging.getLogger(__name__)


class SearchQueryForm(formencode.Schema):
    allow_extra_fields = True
    serp_q = formencode.validators.String(max=255, min=1, if_empty="",
                                          if_missing="", not_empty=False)


class SearchController(BaseController):

    def _search_form(self):
        return render("search/results.html")

    @guard.proposal.index()
    @validate(schema=SearchQueryForm(), form="_search_form",
              post_only=False, on_get=True)
    def query(self, format=u'html'):
        c.query = self.form_result.get("serp_q", u"*:*")
        self._query_pager()
        return formencode.htmlfill.render(
            self._search_form(),
            defaults={'serp_q': c.query})

    @guard.proposal.index()
    @validate(schema=SearchQueryForm(), post_only=False, on_get=True)
    def filter(self):
        c.query = self.form_result.get("serp_q", '')
        self._query_pager()
        return c.entities_pager.here()

    def _query_pager(self):
        instance = c.instance if c.instance else None
        c.entities = libsearch.query.run(c.query, instance=instance,
                                         excluded_entity_types=set([Comment]))
        c.entities_pager = NamedPager(
            'serp', c.entities, tiles.dispatch_row,
            sorts={_("oldest"): sorting.entity_oldest,
                   _("newest"): sorting.entity_newest,
                   _("relevance"): sorting.entity_stable},
            default_sort=sorting.entity_stable,
            q=c.query)

########NEW FILE########
__FILENAME__ = selection
import json
import logging

import formencode
from formencode import htmlfill, Invalid

from pylons import request, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.i18n import _

from adhocracy import forms, model
from adhocracy.controllers.page import PageController
from adhocracy.lib import helpers as h, tiles
from adhocracy.lib.auth import guard
from adhocracy.lib.auth import require
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.templating import render, ret_abort
from adhocracy.lib.util import get_entity_or_abort

log = logging.getLogger(__name__)


class SelectionCreateForm(formencode.Schema):
    allow_extra_fields = True
    page = forms.ValidPage()


class SelectionController(BaseController):

    @RequireInstance
    def index(self, proposal_id, format="html"):
        return self.not_implemented()

    @RequireInstance
    @guard.norm.propose()
    def propose(self, proposal_id, errors=None, format=u'html'):
        return self._new(proposal_id, '/selection/propose.html', errors,
                         format=format)

    @RequireInstance
    def include(self, proposal_id, errors={}, format=u'html'):
        return self._new(proposal_id, '/selection/include.html', errors,
                         format=format)

    def _new(self, proposal_id, template, errors, format=u'html'):
        c.proposal = get_entity_or_abort(model.Proposal, proposal_id)
        require.selection.create(c.proposal)
        defaults = dict(request.params)
        c.proposal_tile = tiles.proposal.ProposalTile(c.proposal)
        c.exclude_pages = [s.page for s in c.proposal.selections]

        q = model.meta.Session.query(model.Page)
        q = q.filter(model.Page.function == model.Page.NORM)
        q = q.filter(model.Page.instance == c.instance)
        q = q.filter(model.Page.allow_selection == False)  # noqa
        c.exclude_pages += q.all()

        html = render(template, overlay=format == u'overlay')
        return htmlfill.render(html, defaults=defaults,
                               errors=errors, force_defaults=False)

    @RequireInstance
    @RequireInternalRequest(methods=['POST'])
    def create(self, proposal_id, format='html'):
        c.proposal = get_entity_or_abort(model.Proposal, proposal_id)
        require.selection.create(c.proposal)
        try:
            self.form_result = SelectionCreateForm().to_python(request.params)
        except Invalid, i:
            return self.propose(proposal_id, errors=i.unpack_errors())

        page = self.form_result.get('page')
        selection = model.Selection.create(c.proposal, page,
                                           c.user)
        model.meta.Session.commit()
        # TODO implement:
        # TODO emit an event

        if len(page.variants) < 2:
            return redirect(h.entity_url(page, member='branch',
                                         query={'proposal': c.proposal.id}))
        return redirect(h.entity_url(selection))

    def edit(self, proposal_id, id, errors={}):
        return self.not_implemented()

    def update(self, proposal_id, id, format='html'):
        return self.not_implemented()

    @RequireInstance
    def show(self, proposal_id, id, format='html'):
        c.selection = get_entity_or_abort(model.Selection, id)
        require.selection.show(c.selection)
        redirect(h.selection.url(c.selection))

    @RequireInstance
    def ask_delete(self, proposal_id, id):
        c.proposal = get_entity_or_abort(model.Proposal, proposal_id)
        c.selection = get_entity_or_abort(model.Selection, id)
        require.selection.delete(c.selection)
        c.proposal_tile = tiles.proposal.ProposalTile(c.proposal)

        return render("/selection/ask_delete.html")

    @RequireInstance
    @RequireInternalRequest()
    def delete(self, proposal_id, id):
        c.proposal = get_entity_or_abort(model.Proposal, proposal_id)
        c.selection = get_entity_or_abort(model.Selection, id)
        require.selection.delete(c.selection)

        # TODO implement
        # event.emit(event.T_PROPOSAL_DELETE, c.user, instance=c.instance,
        #            topics=[c.proposal], proposal=c.proposal)
        c.selection.delete()
        model.meta.Session.commit()
        h.flash(_("The inclusion of %s has been deleted.") %
                c.selection.page.title,
                'success')

        redirect(h.entity_url(c.proposal))

    @RequireInstance
    def details(self, proposal_id, selection_id, format='html'):
        '''
        '''
        c.selection = get_entity_or_abort(model.Selection, selection_id)
        require.selection.show(c.selection)
        proposal = get_entity_or_abort(model.Proposal, proposal_id)
        if c.selection.proposal is not proposal:
            ret_abort(_('Page not Found'), code=404)
        c.page = c.selection.page
        variant_polls = dict(c.selection.variant_polls)
        variant_to_show = c.selection.selected
        if not variant_to_show:
            variant_to_show = model.Text.HEAD

        variant_items = PageController._variant_items(c.page,
                                                      selection=c.selection)
        get_score = lambda item: \
            c.selection.variant_poll(item['variant']).tally.score
        c.variant_items = PageController._insert_variant_score_and_sort(
            variant_items, get_score)

        c.variant_details = PageController._variant_details(
            c.page, variant_to_show)
        c.variant_details_json = json.dumps(c.variant_details, indent=4)
        c.selection_details = PageController._selection_urls(c.selection)
        c.selection_details_json = json.dumps(c.selection_details, indent=4)
        c.current_variant_poll = variant_polls[variant_to_show]

        if format == 'overlay':
            return render('/proposal/details.html', overlay=True)
        else:
            return render('/proposal/details.html')

########NEW FILE########
__FILENAME__ = shibboleth
from urllib import urlencode
import formencode
from pylons import request
from pylons import response
from pylons import session
from pylons.controllers.util import redirect
from pylons.i18n import _
from adhocracy import config
from adhocracy import forms
from adhocracy.lib import helpers as h
from adhocracy.lib.auth import login_user
from adhocracy.lib.auth.authentication import allowed_login_types
from adhocracy.lib.auth.csrf import check_csrf
from adhocracy.lib.auth.shibboleth import get_attribute
from adhocracy.lib.auth.shibboleth import USERBADGE_MAPPERS
from adhocracy.lib.auth.shibboleth import DISPLAY_NAME_FUNCTIONS
from adhocracy.lib.base import BaseController
from adhocracy.lib.staticpage import add_static_content
from adhocracy.lib.templating import render
from adhocracy.lib.templating import ret_abort
from adhocracy.model import meta
from adhocracy.model.user import User
from adhocracy.model.badge import UserBadge


class ShibbolethRegisterForm(formencode.Schema):
    _tok = formencode.validators.String()
    if not config.get_bool('adhocracy.force_randomized_user_names'):
        username = formencode.All(
            formencode.validators.PlainText(not_empty=True),
            forms.UniqueUsername(),
            forms.ContainsChar())
    if config.get_bool('adhocracy.set_display_name_on_register'):
        display_name = formencode.validators.String(not_empty=False,
                                                    if_missing=None)
    email = formencode.All(formencode.validators.Email(
        not_empty=config.get_bool('adhocracy.require_email')),
        forms.UniqueEmail())
    # store custom attributes checkboxes


class ShibbolethController(BaseController):
    """
    The reason not to use a proper repoze.who plugin is that such a plugin
    would be very hard to understand as the repoze.who API doesn't fit the
    Shibboleth requirements very well (we first did that and it was ugly).
    """

    def request_auth(self):
        if 'shibboleth' not in allowed_login_types():
            ret_abort(_("Shibboleth authentication not enabled"), code=403)

        came_from = request.GET.get('came_from', '/')

        came_from_qs = urlencode({'came_from': came_from})
        shib_qs = urlencode(
            {'target': '/shibboleth/post_auth?%s' % came_from_qs})

        redirect('/Shibboleth.sso/Login?%s' % shib_qs)

    def post_auth(self):
        """
        This controller is called after successful Shibboleth authentication.
        It checks whether the authenticated user already exists. If yes, the
        corresponding Adhocracy user is logged in. If no, an intermediate step
        querying the user for additional information is performed and a new
        Adhocracy user is registered.

        In any case the Shibboleth headers are only used once for logging in
        and immediatly removed afterwards. The reason for this design decision
        is that Single-Sign-Off isn't recommended by Shibboleth as it is either
        very complicated or even impossible.

        NOTE: There isn't one clear way on how to deal with user deletion in
        environments with external user management. We now implemented the
        following:
        If a user logs in into a deleted account, this account is undeleted
        on the fly.
        """
        if 'shibboleth' not in allowed_login_types():
            ret_abort(_("Shibboleth authentication not enabled"), code=403)

        persistent_id = self._get_persistent_id()
        if persistent_id is None:
            ret_abort(_("This URL shouldn't be called directly"), code=403)

        user = User.find_by_shibboleth(persistent_id, include_deleted=True)

        if user is not None:
            if user.is_deleted():
                user.undelete()
                meta.Session.commit()
                h.flash(_("User %s has been undeleted") % user.user_name,
                        'success')
            return self._login(user, h.user.post_login_url(user))
        else:
            return self._register(persistent_id)

    def _get_persistent_id(self):
        return request.environ.get('HTTP_PERSISTENT_ID', None)

    def _login(self, user, target):
        self._update_userbadges(user)

        if config.get_bool('adhocracy.shibboleth.display_name.force_update'):
            display_name = self._get_display_name()
            if display_name is not None:
                user.display_name = display_name
                meta.Session.commit()

        login_user(user, request, response)
        session['login_type'] = 'shibboleth'

        came_from = request.GET.get('came_from', target)
        qs = urlencode({'return': came_from})

        return redirect('/Shibboleth.sso/Logout?%s' % qs)

    def _register_form(self, defaults=None, errors=None):

        data = {
            'email_required': (config.get_bool('adhocracy.require_email')),
        }
        add_static_content(data,
                           u'adhocracy.static_shibboleth_register_ontop_path',
                           body_key=u'body_ontop')
        add_static_content(data,
                           u'adhocracy.static_shibboleth_register_below_path',
                           body_key=u'body_below', title_key=u'_ignored')
        return formencode.htmlfill.render(
            render("/shibboleth/register.html", data),
            defaults=defaults, errors=errors,
            force_defaults=False)

    def _create_user_and_login(self, persistent_id, username, email=None,
                               display_name=None, locale=None):
        user = User.create(username,
                           email,
                           locale=locale,
                           display_name=display_name,
                           shibboleth_persistent_id=persistent_id)
        # NOTE: We might want to automatically join the current instance
        # here at some point

        meta.Session.commit()
        return self._login(user, h.user.post_register_url(user))

    def _register(self, persistent_id):

        # initializing user data dict
        user_data = {}

        user_data['email'] = get_attribute(request, 'shib-email', None)

        if config.get_bool('adhocracy.force_randomized_user_names'):
            user_data['username'] = None
        else:
            user_data['username'] = get_attribute(request, 'shib-username')

        user_data['display_name'] = self._get_display_name()

        locale_attribute = config.get("adhocracy.shibboleth.locale.attribute")
        if locale_attribute is not None:
            user_data['locale'] = get_attribute(request, locale_attribute)

        # what to do
        if request.method == 'GET':
            if config.get_bool('adhocracy.shibboleth.register_form'):
                # render a form for missing uaser data
                return self._register_form(defaults=user_data)
            else:
                # register_form is False -> user data should be complete
                return self._create_user_and_login(persistent_id, **user_data)

        else:  # POST
            check_csrf()

            try:
                form_result = ShibbolethRegisterForm().to_python(
                    request.POST)

                user_data['username'] = form_result.get(
                    'username', user_data['username'])
                user_data['display_name'] = form_result.get(
                    'display_name', user_data['display_name'])
                user_data['email'] = form_result.get(
                    'email', user_data['email'])

                return self._create_user_and_login(persistent_id, **user_data)

            except formencode.Invalid, i:
                return self._register_form(errors=i.unpack_errors())

    def _get_display_name(self):
        display_name_function = config.get_json(
            "adhocracy.shibboleth.display_name.function")
        if display_name_function is not None:
            function = display_name_function["function"]
            kwargs = display_name_function["args"]
            display_name = DISPLAY_NAME_FUNCTIONS[function](request, **kwargs)
        else:
            display_name = None
        return display_name

    def _update_userbadges(self, user):

        mappings = config.get_json("adhocracy.shibboleth.userbadge_mapping")

        is_modified = False

        for m in mappings:
            badge_title = m["title"]
            function_name = m["function"]
            kwargs = m["args"]

            badge = UserBadge.find(badge_title)
            if badge is None:
                raise Exception('configuration expects badge "%s"'
                                % badge_title)
            want_badge = USERBADGE_MAPPERS[function_name](request, **kwargs)
            has_badge = badge in user.badges

            if want_badge and not has_badge:
                # assign badge
                badge.assign(user=user, creator=user)
                is_modified = True
            elif has_badge and not want_badge:
                # unassign badge
                user.badges.remove(badge)
                is_modified = True

        if is_modified:
            meta.Session.commit()

########NEW FILE########
__FILENAME__ = static
import logging

import formencode
from formencode import htmlfill, validators, Invalid

from pylons import request, tmpl_context as c
from pylons.controllers.util import abort, redirect
from pylons.i18n import _

from adhocracy import forms
from adhocracy import i18n
from adhocracy.lib import helpers
from adhocracy.lib.auth import guard, csrf
from adhocracy.lib.base import BaseController
from adhocracy.lib.staticpage import (get_static_page, get_backend,
                                      render_body)
from adhocracy.lib.templating import render, ret_abort

log = logging.getLogger(__name__)

guard_perms = guard.perm("global.admin")


class EditForm(formencode.Schema):
    allow_extra_fields = True

    title = validators.String()
    body = validators.String()


class NewForm(EditForm):
    key = forms.StaticPageKey()
    lang = validators.OneOf(set(i18n.all_languages()))


class StaticController(BaseController):

    identifier = "staticpages"

    @guard_perms
    def index(self):
        try:
            data = {
                'static_pages': get_backend().all()
            }
            return render('/static/index.html', data)
        except NotImplementedError:
            abort(404)

    @guard_perms
    def new(self, errors=None, format=u'html'):
        data = {
            'all_language_infos': list(i18n.all_language_infos())
        }
        defaults = dict(request.params)
        defaults['_tok'] = csrf.token_id()
        return htmlfill.render(render('/static/new.html', data,
                                      overlay=format == u'overlay'),
                               defaults=defaults, errors=errors)

    @guard_perms
    @csrf.RequireInternalRequest(methods=['POST'])
    def make_new(self):
        try:
            form_result = NewForm().to_python(request.params)
        except Invalid as i:
            return self.new(errors=i.unpack_errors())

        key = form_result.get('key')
        lang = form_result.get('lang')

        backend = get_backend()
        if backend.get(key, lang) is not None:
            msg = _('Page does already exist. Select another key or language.')
            helpers.flash(msg, 'error')
            return self.new()

        backend.create(key,
                       lang,
                       form_result.get('body'),
                       form_result.get('title'))
        helpers.flash(_('Page updated'), 'notice')
        return redirect(helpers.base_url('/static'))

    @guard_perms
    def edit(self, key, lang, errors=None, format=u'html'):
        backend = get_backend()
        sp = backend.get(key, [lang])
        if not sp:
            return ret_abort(_('Cannot find static page to edit'), code=404)
        data = {'staticpage': sp}
        defaults = {
            'title': sp.title,
            'body': sp.body,
        }
        defaults.update(dict(request.params))
        defaults['_tok'] = csrf.token_id()
        return htmlfill.render(render('/static/edit.html', data,
                                      overlay=format == u'overlay'),
                               defaults=defaults, errors=errors)

    @guard_perms
    @csrf.RequireInternalRequest(methods=['POST'])
    def update(self, key, lang):
        backend = get_backend()
        sp = backend.get(key, [lang])
        if not sp:
            return ret_abort(_('Cannot find static page to edit'), code=404)

        try:
            form_result = EditForm().to_python(request.params)
        except Invalid as i:
            return self.edit(errors=i.unpack_errors())

        sp.title = form_result.get('title')
        sp.body = form_result.get('body')
        sp.commit()
        helpers.flash(_('Page updated'), 'notice')
        return redirect(helpers.base_url('/static'))

    @guard.perm('static.show')
    def serve(self, key, format='html'):
        page = get_static_page(key)
        if page is None:
            return abort(404, _('The requested page was not found'))
        c.body_css_classes += page.css_classes
        if page.redirect_url != u'':
            return redirect(page.redirect_url)
        data = {
            'static': page,
            'body_html': render_body(page.body),
            'active_global_nav': key,
        }

        if format == 'simple':
            return render('/plain_doc.html', data)
        elif format == 'overlay':
            return render('/static/show.html', data, overlay=True)
        else:
            return render('/static/show.html', data)

########NEW FILE########
__FILENAME__ = stats
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render_json


class StatsController(BaseController):
    """ This controller is an endpoint for AJAX requests that monitor user
    behavior. You'll want to enable `adhocracy.requestlog_active` to record
    them.  """

    def read_comments(self, format='json'):
        return render_json({})

    def on_page(self, format='json'):
        return render_json({})

    def record_external(self, format='json'):
        return render_json({})

########NEW FILE########
__FILENAME__ = tag
import logging

import formencode
from formencode import validators

from pylons import tmpl_context as c
from pylons.controllers.util import redirect
from pylons.decorators import validate
from pylons.i18n import _


from adhocracy import model
from adhocracy.lib import helpers as h, search as libsearch, sorting, tiles
from adhocracy.lib.auth import guard
from adhocracy.lib.auth import require
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
from adhocracy.lib.pager import NamedPager
from adhocracy.lib.queue import update_entity
from adhocracy.lib.templating import render, render_json
from adhocracy.lib.templating import ret_success
from adhocracy.lib.util import get_entity_or_abort

import adhocracy.lib.text as text
import adhocracy.forms as forms

log = logging.getLogger(__name__)


class TaggingCreateForm(formencode.Schema):
    allow_extra_fields = True
    tags = validators.String(max=10000, not_empty=True)
    delegateable = forms.ValidDelegateable()


class TaggingDeleteForm(formencode.Schema):
    allow_extra_fields = True
    tagging = forms.ValidTagging()


class TaggingAllDeleteForm(formencode.Schema):
    allow_extra_fields = True
    tag = forms.ValidTag()
    delegateable = forms.ValidDelegateable()


class TaggingCompleteForm(formencode.Schema):
    allow_extra_fields = True
    q = validators.String(max=10000, not_empty=False, if_empty=u'',
                          if_missing=u'')


class TagController(BaseController):

    @RequireInstance
    @guard.tag.index()
    def index(self, format='html'):
        tags = model.Tag.popular_tags(limit=500)
        if format == 'json':
            return render_json(tags)
        c.tags = sorted(h.tag.tag_cloud_normalize(tags),
                        key=lambda (k, c, v): k.name.lower())
        if format == 'overlay':
            return render("/tag/index.html", overlay=True)
        else:
            return render("/tag/index.html")

    @RequireInstance
    def show(self, id, format='html'):
        c.tag = get_entity_or_abort(model.Tag, id)
        require.tag.show(c.tag)
        require.proposal.index()
        require.page.index()

        if format == 'json':
            return render_json(c.tag)

        entities = libsearch.query.run(u'tag:' + c.tag.name,
                                       instance=c.instance)
        entities = [e for e in entities if (isinstance(e, model.Proposal) or
                                            isinstance(e, model.Page))]

        c.entities_pager = NamedPager(
            'entities', entities, tiles.dispatch_row,
            sorts={_("oldest"): sorting.entity_oldest,
                   _("newest"): sorting.entity_newest,
                   _("alphabetically"): sorting.delegateable_title,
                   _("relevance"): sorting.entity_stable},
            default_sort=sorting.entity_stable,
            q=c.query)

        tags = model.Tag.similar_tags(c.tag, limit=50)
        c.cloud_tags = sorted(h.tag.tag_cloud_normalize(tags),
                              key=lambda (k, c, v): k.name)

        if format == 'overlay':
            return render("/tag/show.html", overlay=True)
        else:
            return render("/tag/show.html")

    @RequireInstance
    @guard.tag.create()
    @validate(schema=TaggingCreateForm(), form="bad_request",
              post_only=False, on_get=True)
    def create(self, format='html'):
        delegateable = self.form_result.get('delegateable')
        for tag_text in text.tag_split(self.form_result.get('tags')):
            if not model.Tagging.find_by_delegateable_name_creator(
                    delegateable, tag_text, c.user):
                model.Tagging.create(delegateable, tag_text, c.user)
        model.meta.Session.commit()
        redirect(h.entity_url(delegateable, format=format))

    @RequireInstance
    @RequireInternalRequest()
    @validate(schema=TaggingDeleteForm(), form="bad_request", post_only=False,
              on_get=True)
    def untag(self, format='html'):
        tagging = self.form_result.get('tagging')
        require.tag.delete(tagging)
        tagging.delete()
        model.meta.Session.commit()
        redirect(h.entity_url(tagging.delegateable, format=format))

    @RequireInstance
    @RequireInternalRequest()
    @validate(schema=TaggingAllDeleteForm(), form="bad_request",
              post_only=False, on_get=True)
    def untag_all(self, format='html'):
        # HACK create a proper permission
        require.instance.edit(c.instance)
        delegateable = self.form_result.get('delegateable')
        tag = self.form_result.get('tag')
        for tagging in delegateable.taggings:
            if tagging.tag == tag:
                tagging.delete()
        update_entity(delegateable, model.UPDATE)
        model.meta.Session.commit()
        return ret_success(
            message=_('Tag "%s" has been removed from %s "%s".') % (
                tag.name,
                _(delegateable.type),
                delegateable.label),
            category='success',
            entity=delegateable,
            format=format)

    @RequireInstance
    @guard.tag.index()
    @validate(schema=TaggingCompleteForm(), form="bad_request",
              post_only=False, on_get=True)
    def autocomplete(self):
        prefix = self.form_result.get('q')
        (base, prefix) = text.tag_split_last(prefix)
        results = []
        for (tag, freq) in model.Tag.complete(prefix, 10):
            display = "%s (%s)" % (tag.name, freq)
            full = base + tag.name + ", "
            results.append(dict(display=display, tag=full))
        return render_json(results)

########NEW FILE########
__FILENAME__ = treatment
import formencode
from pylons.decorators import validate
from pylons.i18n import _

from adhocracy import forms, model
from adhocracy.lib import helpers as h
from adhocracy.lib.auth import guard
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.templating import render, redirect, ret_abort
from adhocracy.lib.treatment import (assign_users,
                                     get_assignments_by_source_badge)


class TreatmentCreateForm(formencode.Schema):
    key = formencode.validators.String(not_empty=True)
    source_badges = forms.ValidUserBadges(not_empty=True)
    variant_count = formencode.validators.Int(min=2)
    _tok = formencode.validators.String()


class TreatmentController(BaseController):

    @guard.perm("global.admin")
    def index(self):
        userbadges = [b
                      for b in model.UserBadge.all(include_global=True)
                      if not b.title.startswith('treatment-')]
        treatments = model.Treatment.all()
        data = {
            'treatments': treatments,
            'userbadges': userbadges,
        }
        return render('treatment/index.html', data)

    @guard.perm("global.admin")
    @RequireInternalRequest(methods=['POST'])
    @validate(schema=TreatmentCreateForm(), form='index', post_only=True)
    def create(self):
        t = model.Treatment.create(
            self.form_result['key'],
            self.form_result['source_badges'],
            self.form_result['variant_count'],
        )
        model.meta.Session.commit()
        h.flash(_("Treatment has been created."), 'success')
        return redirect(h.base_url('/admin/treatment/'))

    @guard.perm("global.admin")
    @RequireInternalRequest(methods=['POST'])
    def assign(self, key):
        treatment = model.Treatment.find(key)
        if not treatment:
            return ret_abort(_("Could not find the entity '%s'") % id,
                             code=404)

        if assign_users(treatment):
            model.meta.Session.commit()

            h.flash(_("All users have been assigned to their respective "
                      "treatment badges."), 'success')
        else:
            h.flash(_("All users are already assigned to their respective "
                      "treatment badges."))
        return redirect(h.base_url('/admin/treatment/'))

    @guard.perm("global.admin")
    def assigned(self, key):
        treatment = model.Treatment.find(key)
        if not treatment:
            return ret_abort(_("Could not find the entity '%s'") % id,
                             code=404)

        assignments = [
            {
                'source_badge': source_badge,
                'variants': current_assignment,
            }
            for source_badge, current_assignment, unassigned in (
                get_assignments_by_source_badge(treatment))]

        data = {
            'assignments': assignments,
            'treatment': treatment,
        }
        return render('treatment/assigned.html', data)

########NEW FILE########
__FILENAME__ = twitteroauth
import logging
from urllib2 import HTTPError

from oauth import oauth

from pylons import request, session, tmpl_context as c
from pylons.controllers.util import redirect
from pylons.i18n import _


from adhocracy import model
from adhocracy.lib import helpers as h
from adhocracy.lib.auth import require
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController
from adhocracy.lib.microblog import create_oauth, system_user


log = logging.getLogger(__name__)


class TwitteroauthController(BaseController):

    @RequireInternalRequest()
    def init(self):
        require.user.edit(c.user)
        api = create_oauth()
        request_token = api.getRequestToken()
        session['request_token'] = request_token.to_string()
        session.save()
        redirect(api.getAuthorizationURL(request_token))

    def callback(self):
        require.user.edit(c.user)
        if 'denied' in request.params:
            redirect(h.entity_url(c.user, member='edit'))
        request_token = session.get('request_token')
        if not request_token:
            h.flash(_("You have been logged out while authenticating "
                      "at twitter. Please try again."), 'notice')
            redirect(h.entity_url(c.user, member='edit'))
        request_token = oauth.OAuthToken.from_string(request_token)
        req_api = create_oauth(key=request_token.key,
                               secret=request_token.secret)
        access_token = req_api.getAccessToken()
        api = create_oauth(key=access_token.key, secret=access_token.secret)
        user_data = api.GetUserInfo()
        twitter = model.Twitter(int(user_data.id), c.user,
                                user_data.screen_name,
                                unicode(access_token.key),
                                unicode(access_token.secret))
        model.meta.Session.add(twitter)
        model.meta.Session.commit()
        try:
            # workaround to a hashing fuckup in oatuh
            api._FetchUrl("http://twitter.com/friendships/create.json",
                          post_data={'screen_name': system_user()},
                          no_cache=True)
            h.flash(_("You're now following %s on twitter so we "
                      + "can send you notifications as direct messages") %
                    system_user(),
                    'success')
        except HTTPError, he:
            log.warn(he.read())
        redirect(h.entity_url(c.user, member='edit'))

    @RequireInternalRequest()
    def revoke(self):
        require.user.edit(c.user)
        if not c.user.twitter:
            h.flash(_("You have no twitter association."), 'notice')
            redirect(h.entity_url(c.user, member='edit'))
        c.user.twitter.delete()
        model.meta.Session.commit()
        redirect(h.entity_url(c.user, member='edit'))

########NEW FILE########
__FILENAME__ = user
from collections import OrderedDict
import logging
import re

import formencode
from formencode import ForEach, htmlfill, validators

from pylons import request, response, session, tmpl_context as c
from pylons.controllers.util import abort
from pylons.controllers.util import redirect
from pylons.decorators import validate
from pylons.i18n import _

from webob.exc import HTTPFound

from repoze.who.api import get_api

from adhocracy import config
from adhocracy import forms, model
from adhocracy import i18n
from adhocracy.lib import democracy, event, helpers as h, pager, logo
from adhocracy.lib import sorting, search as libsearch, tiles, text
from adhocracy.lib.auth import require, can, login_user, guard
from adhocracy.lib.auth.authorization import has
from adhocracy.lib.auth.csrf import RequireInternalRequest, token_id
from adhocracy.lib.auth.welcome import (welcome_enabled, can_welcome,
                                        welcome_url)
from adhocracy.lib.base import BaseController
from adhocracy.lib.instance import RequireInstance
import adhocracy.lib.mail as libmail
from adhocracy.lib.pager import (NamedPager, solr_global_users_pager,
                                 solr_instance_users_pager, PROPOSAL_SORTS)
from adhocracy.lib.settings import INSTANCE_UPDATED_MSG
from adhocracy.lib.settings import NO_UPDATE_REQUIRED
from adhocracy.lib.settings import error_formatter
from adhocracy.lib.settings import Menu
from adhocracy.lib.settings import settings_url
from adhocracy.lib.settings import update_attributes
from adhocracy.lib.staticpage import add_static_content
from adhocracy.lib.templating import render, render_json, ret_abort
from adhocracy.lib.templating import render_def
from adhocracy.lib.templating import ret_success, render_logo
from adhocracy.lib.queue import update_entity
from adhocracy.lib.util import get_entity_or_abort, random_token

from adhocracy.lib.event.types import (S_VOTE, S_DELEGATION, S_CONTRIBUTION,
                                       S_MESSAGE)


log = logging.getLogger(__name__)


def settings_menu(instance, current):

    show_login = (h.user.can_change_password(c.page_user) or
                  'openid' in h.allowed_login_types())
    show_optional = bool(config.get('adhocracy.user.optional_attributes'))

    return Menu.create(instance, current, OrderedDict([
        ('personal', (_(u'Personal'), True, 'settings')),
        ('login', (_(u'Login'), show_login)),
        ('notifications', (_('Notifications'),)),
        ('advanced', (_('Advanced'),)),
        ('optional', (_('Optional'), show_optional)),
    ]))


class UserCreateForm(formencode.Schema):
    allow_extra_fields = True
    if not config.get_bool('adhocracy.force_randomized_user_names'):
        user_name = formencode.All(validators.PlainText(not_empty=True),
                                   forms.UniqueUsername(),
                                   forms.ContainsChar())
    if config.get_bool('adhocracy.set_display_name_on_register'):
        display_name = validators.String(not_empty=False, if_missing=None)
    email = formencode.All(validators.Email(
        not_empty=config.get_bool('adhocracy.require_email')),
        forms.UniqueOtherEmail())
    password = validators.String(not_empty=True)
    password_confirm = validators.String(not_empty=True)
    if h.get_captcha_type() == 'captchasdotnet':
        captchasdotnet_captcha = forms.CaptchasDotNetCaptcha(session,
                                                             h.captchasdotnet)
    chained_validators = [validators.FieldsMatch(
        'password', 'password_confirm')]
    if config.get_bool('adhocracy.registration.require_terms_check'):
        chained_validators.append(forms.TermsCheckValidator())


class UserSettingsPersonalForm(formencode.Schema):
    allow_extra_fields = True
    locale = forms.ValidLocale()
    if config.get_bool('adhocracy.user.display_name.allow_change'):
        display_name = validators.String(not_empty=False)
    bio = validators.String(
        max=(None if config.get_bool('adhocracy.user.bio.no_max_length')
             else config.get_int('adhocracy.user.bio.max_length')),
        min=0, not_empty=False)
    _is_organization = validators.StringBool(not_empty=False, if_empty=False,
                                             if_missing=False)


class UserSettingsLoginForm(formencode.Schema):
    allow_extra_fields = True
    password_change = validators.String(not_empty=False, if_missing=None)
    password_confirm = validators.String(not_empty=False, if_missing=None)
    chained_validators = [validators.FieldsMatch(
        'password_change', 'password_confirm')]


class UserSettingsNotificationsForm(formencode.Schema):
    allow_extra_fields = True
    email = formencode.All(validators.Email(
        not_empty=config.get_bool('adhocracy.require_email')),
        forms.UniqueOtherEmail())
    email_priority = validators.Int(min=0, max=6, not_empty=False,
                                    if_missing=3)
    email_messages = validators.StringBool(not_empty=False, if_empty=False,
                                           if_missing=False)


class UserSettingsAdvancedForm(formencode.Schema):
    allow_extra_fields = True
    no_help = validators.StringBool(not_empty=False, if_empty=False,
                                    if_missing=False)
    page_size = validators.Int(min=1, max=200, not_empty=False,
                               if_empty=10, if_missing=10)
    proposal_sort_order = forms.ProposalSortOrder()


class UserSettingsOptionalForm(formencode.Schema):
    allow_extra_fields = True
    chained_validators = [
        forms.common.OptionalAttributes(),
    ]


class UserCodeForm(formencode.Schema):
    allow_extra_fields = True
    c = validators.String(not_empty=False)


class UserResetApplyForm(formencode.Schema):
    allow_extra_fields = True
    email = validators.Email(not_empty=True)


class UserGroupmodForm(formencode.Schema):
    allow_extra_fields = True
    to_group = forms.ValidInstanceGroup()


class UserFilterForm(formencode.Schema):
    allow_extra_fields = True
    users_q = validators.String(max=255, not_empty=False, if_empty=u'',
                                if_missing=u'')
    users_group = validators.String(max=255, not_empty=False, if_empty=None,
                                    if_missing=None)


class UserBadgesForm(formencode.Schema):
    allow_extra_fields = True
    badge = ForEach(forms.ValidUserBadge())


class UserSetPasswordForm(formencode.Schema):
    allow_extra_fields = True
    password = validators.String(not_empty=False)


class NoPasswordForm(formencode.Schema):
    allow_extra_fields = True
    login = validators.String(not_empty=False)


class UserController(BaseController):

    identifier = 'members'

    @RequireInstance
    @guard.user.index()
    @validate(schema=UserFilterForm(), post_only=False, on_get=True)
    def index(self, format='html'):

        default_sorting = config.get(
            'adhocracy.listings.instance_user.sorting', 'ACTIVITY')
        c.users_pager = solr_instance_users_pager(c.instance, default_sorting)

        # if format == 'json':
        #     return render_json(c.users_pager)

        c.tutorial_intro = _('tutorial_user_index_intro')
        c.tutorial = 'user_index'

        return render("/user/index.html", overlay=(format == 'overlay'))

    @guard.perm('user.index_all')
    def all(self):
        c.users_pager = solr_global_users_pager()
        return render("/user/all.html")

    def new(self, defaults=None, format=u'html'):
        if not h.allow_user_registration():
            return ret_abort(
                _("Sorry, registration has been disabled by administrator."),
                category='error', code=403)
        c.active_global_nav = "login"
        if c.user:
            redirect('/')
        else:
            data = {}
            captcha_type = h.get_captcha_type()
            if defaults is None:
                defaults = {}
            defaults['_tok'] = token_id()
            if captcha_type == 'captchasdotnet':
                cap = h.captchasdotnet.get_captchasdotnet()
                random = session.get('captchasdotnet_random')
                if random is None:
                    random = cap.random()
                    session['captchasdotnet_random'] = random
                data['captcha'] = render_def(
                    '/user/tiles.html', 'captchasdotnet', cap=cap,
                    random=random)
            elif captcha_type == 'recaptcha':
                data['captcha'] = h.recaptcha.displayhtml(use_ssl=True)
            add_static_content(data, u'adhocracy.static_agree_text',
                               body_key=u'agree_text', title_key='_ignored')
            if data['agree_text'] is None:
                data['agree_text'] = (
                    _(u"I agree with the %s. We'll "
                      u"occasionally inform you about important events such "
                      u"as the start of a new participation process via "
                      u"email.")
                    % h.help_link(_("Terms and Conditions"), 'terms'))
            return htmlfill.render(render("/user/register.html", data,
                                          overlay=format == u'overlay'),
                                   defaults=defaults)

    @RequireInternalRequest(methods=['POST'])
    @guard.user.create()
    @validate(schema=UserCreateForm(), form="new", post_only=True)
    def create(self):
        if not h.allow_user_registration():
            return ret_abort(
                _("Sorry, registration has been disabled by administrator."),
                category='error', code=403)

        if self.email_is_blacklisted(self.form_result['email']):
            return ret_abort(_("Sorry, but we don't accept registrations with "
                               "this email address."), category='error',
                             code=403)

        # SPAM protection captcha
        captcha_type = h.get_captcha_type()
        if captcha_type == 'captchasdotnet':
            # validation is done in forms.CaptchasDotNetCaptcha, this is only
            # cleanup
            del session['captchasdotnet_random']

        elif captcha_type == 'recaptcha':
            # FIXME: use FormEncode to validate, as all input is lost like that
            recaptcha_response = h.recaptcha.submit()
            if not recaptcha_response.is_valid:
                c.recaptcha = h.recaptcha.displayhtml(
                    use_ssl=True,
                    error=recaptcha_response.error_code)
                redirect("/register")

        # SPAM protection hidden input
        input_css = self.form_result.get("input_css")
        input_js = self.form_result.get("input_js")
        if input_css or input_js:
            redirect("/")

        # create user
        if config.get_bool('adhocracy.force_randomized_user_names'):
            user_name = None
        else:
            user_name = self.form_result.get("user_name")
        user = model.User.create(
            user_name,
            self.form_result.get("email"),
            password=self.form_result.get("password"),
            locale=c.locale,
            display_name=self.form_result.get("display_name"))
        model.meta.Session.commit()

        event.emit(event.T_USER_CREATE, user)
        libmail.send_activation_link(user)

        if c.instance:
            membership = user.instance_membership(c.instance)
            if membership is None:
                membership = model.Membership(user, c.instance,
                                              c.instance.default_group)
                model.meta.Session.expunge(membership)
                model.meta.Session.add(membership)
                model.meta.Session.commit()

        # authenticate the new registered member using the repoze.who
        # api. This is done here and not with an redirect to the login
        # to omit the generic welcome message
        who_api = get_api(request.environ)
        login_configuration = h.allowed_login_types()
        if 'username+password' in login_configuration:
            login = user.user_name
        elif 'email+password' in login_configuration:
            login = self.form_result.get("email")
        else:
            raise Exception('We have no way of authenticating the newly'
                            'created user %s; check adhocracy.login_type' %
                            login)
        credentials = {
            'login': login,
            'password': self.form_result.get("password")
        }
        authenticated, headers = who_api.login(credentials)
        if authenticated:
            session['logged_in'] = True
            session.save()
            if c.came_from != u'':
                location = h.url.unquote(c.came_from)
            else:
                location = h.user.post_register_url(user)
            raise HTTPFound(location=location, headers=headers)
        else:
            raise Exception('We have added the user to the Database '
                            'but cannot authenticate him: '
                            '%s (%s)' % (credentials['login'], user))

    def edit(self, id):
        """ legacy url """
        page_user = get_entity_or_abort(model.User, id,
                                        instance_filter=False)
        redirect(h.entity_url(page_user, instance=c.instance,
                              member='settings'))

    def _settings_result(self, updated, user, setting_name, message=None):
        '''
        Sets a redirect code and location header, stores a flash
        message and returns the message. If *message* is not None, a
        message is chosen depending on the boolean value of
        *updated*. The redirect *location* URL is chosen based on the
        instance and *setting_name*.

        This method will *not raise an redirect exception* but set the
        headers and return the message string.

        *updated* (bool)
           Indicate that a value was updated. Used to choose a generic
           message if *message* is not given explicitly.
        *user* (:class:`adhocracy.model.User`)
           The user to generate the redirect URL for.
        *setting_name* (str)
           The setting name for which the URL will be build.
        *message* (unicode)
           An explicit message to use instead of the generic message.

        Returns
           The message generated or given.
        '''
        if updated:
            event.emit(event.T_USER_EDIT, c.user)
            message = message if message else unicode(INSTANCE_UPDATED_MSG)
            category = 'success'
        else:
            message = message if message else unicode(NO_UPDATE_REQUIRED)
            category = 'notice'
        h.flash(message, category=category)
        response.status_int = 303
        url = settings_menu(user, setting_name).url_for(setting_name)
        response.headers['location'] = url
        return unicode(message)

    def _settings_all(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)
        if c.instance is None:
            c.active_global_nav = 'user'

    def _settings_personal_form(self, id, format=u'html'):
        self._settings_all(id)
        c.settings_menu = settings_menu(c.page_user, 'personal')

        c.locales = []
        for locale in i18n.LOCALES:
            c.locales.append({'value': str(locale),
                              'label': locale.language_name,
                              'selected': locale == c.user.locale})

        c.salutations = [
            {'value': u'u', 'label': _(u'Gender-neutral')},
            {'value': u'f', 'label': _(u'Female')},
            {'value': u'm', 'label': _(u'Male')},
        ]

        if logo.exists(c.page_user):
            c.current_avatar = h.logo_url(c.page_user, 64)

        return render("/user/settings_personal.html",
                      overlay=format == u'overlay')

    def settings_personal(self, id, format=u'html'):
        form_content = self._settings_personal_form(id, format=format)
        return htmlfill.render(
            form_content,
            defaults={
                '_method': 'PUT',
                'display_name': c.page_user.display_name,
                'locale': c.page_user.locale,
                'bio': c.page_user.bio,
                'gender': c.page_user.gender,
                '_is_organization': c.page_user._is_organization,
                '_tok': token_id()})

    @validate(schema=UserSettingsPersonalForm(),
              form="_settings_personal_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_personal_update(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)

        _attributes = ['locale', 'bio', '_is_organization']
        if config.get_bool('adhocracy.user.display_name.allow_change'):
            _attributes.append('display_name')
        updated = update_attributes(c.page_user, self.form_result,
                                    _attributes)

        # delete the logo if the button was pressed and exit
        if 'delete_avatar' in self.form_result:
            updated = logo.delete(c.page_user)
            return self._settings_result(
                updated, c.page_user, 'personal',
                message=_(u'The avatar has been deleted.'))

        try:
            # fixme: show logo errors in the form
            if ('avatar' in request.POST and
                    hasattr(request.POST.get('avatar'), 'file') and
                    request.POST.get('avatar').file):
                logo.store(c.page_user, request.POST.get('avatar').file)
                updated = True
        except Exception, e:
            model.meta.Session.rollback()
            h.flash(unicode(e), 'error')
            log.debug(e)
            return self.settings_personal(id)

        if config.get_bool('adhocracy.enable_gender'):
            gender = self.form_result.get("gender")
            if gender in ('f', 'm', 'u') and gender != c.page_user.gender:
                c.page_user.gender = gender
                updated = True
                model.meta.Session.commit()

        return self._settings_result(updated, c.page_user, 'personal')

    def _settings_login_form(self, id, format=u'html'):
        self._settings_all(id)
        c.settings_menu = settings_menu(c.page_user, 'login')

        return render("/user/settings_login.html",
                      overlay=format == u'overlay')

    def settings_login(self, id, format=u'html'):
        form_content = self._settings_login_form(id, format=format)
        return htmlfill.render(
            form_content,
            defaults={
                '_method': 'PUT',
            })

    @validate(schema=UserSettingsLoginForm(), form="_settings_login_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_login_update(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)

        updated = False
        if self.form_result.get("password_change"):
            if h.user.can_change_password(c.page_user):
                c.page_user.password = self.form_result.get("password_change")
                updated = True
            else:
                log.error(
                    'Attempt to change password although disabled (user %s)' %
                    c.page_user.user_name)

        return self._settings_result(updated, c.page_user, 'login')

    def _settings_notifications_form(self, id, format=u'html'):
        self._settings_all(id)
        c.settings_menu = settings_menu(c.page_user, 'notifications')

        return render("/user/settings_notifications.html",
                      overlay=format == u'overlay')

    def settings_notifications(self, id, format=u'html'):
        form_content = self._settings_notifications_form(id, format=format)
        return htmlfill.render(
            form_content,
            defaults={
                '_method': 'PUT',
                'email': c.page_user.email,
                'email_priority': c.page_user.email_priority,
                'email_messages': c.page_user.email_messages,
                '_tok': token_id()})

    @validate(schema=UserSettingsNotificationsForm(),
              form="_settings_notifications_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_notifications_update(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)
        old_email = c.page_user.email
        old_activated = c.page_user.is_email_activated()
        updated = update_attributes(c.page_user, self.form_result,
                                    ['email',
                                     'email_priority',
                                     'email_messages'])
        model.meta.Session.commit()

        email = self.form_result.get("email")
        if email != old_email:
            # Logging email address changes in order to ensure accountability
            log.info('User %s changed email address from %s%s to %s' % (
                c.page_user.user_name,
                old_email,
                ' (validated)' if old_activated else '',
                email))
            libmail.send_activation_link(c.page_user)
        c.page_user.email = email
        c.page_user.email_priority = self.form_result.get("email_priority")
        # if c.page_user.twitter:
        #     c.page_user.twitter.priority = \
        #         self.form_result.get("twitter_priority")
        #     model.meta.Session.add(c.page_user.twitter)
        return self._settings_result(updated, c.page_user, 'notifications')

    def _settings_advanced_form(self, id, format=u'html'):
        self._settings_all(id)
        c.tile = tiles.user.UserTile(c.page_user)
        c.settings_menu = settings_menu(c.page_user, 'advanced')

        c.pager_sizes = [{'value': str(size),
                          'label': str(size),
                          'selected': size == c.user.page_size}
                         for size in [10, 20, 50, 100, 200]]
        c.sorting_orders = PROPOSAL_SORTS

        return render("/user/settings_advanced.html",
                      overlay=format == u'overlay')

    def settings_advanced(self, id, format=u'html'):
        form_content = self._settings_advanced_form(id, format=format)
        return htmlfill.render(
            form_content,
            defaults={
                '_method': 'PUT',
                'no_help': c.page_user.no_help,
                'page_size': c.page_user.page_size,
                'proposal_sort_order': c.page_user.proposal_sort_order,
                '_tok': token_id()})

    @validate(schema=UserSettingsAdvancedForm(),
              form="_settings_advanced_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_advanced_update(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)
        updated = update_attributes(c.page_user, self.form_result,
                                    ['no_help',
                                     'page_size',
                                     'proposal_sort_order'])

        return self._settings_result(updated, c.page_user, 'advanced')

    def _settings_optional_form(self, id, data={}, format=u'html'):
        if not config.get('adhocracy.user.optional_attributes'):
            abort(400, _("No optional attributes defined."))
        self._settings_all(id)
        data['page_user'] = c.page_user
        data['tile'] = tiles.user.UserTile(c.page_user)
        data['settings_menu'] = settings_menu(c.page_user, 'optional')

        data['optional_attributes'] = config.get_optional_user_attributes()
        add_static_content(data,
                           u'adhocracy.static_optional_path')

        return render("/user/settings_optional.html", data,
                      overlay=format == u'overlay')

    def settings_optional(self, id, format=u'html'):
        form_content = self._settings_optional_form(id, format=format)
        defaults = c.page_user.optional_attributes or {}

        # Workaround, as htmlfill will match select option values in their
        # html encoded form.
        # Proper fix would be to explicitly declare database and shown option
        # value in the configuration in adhocracy.user.optional_attributes.xxx
        # That way the shown value can also be changed later.
        import cgi
        defaults = dict((k, cgi.escape(unicode(v)))
                        for k, v in defaults.items())

        defaults.update({
            '_method': 'PUT',
            '_tok': token_id()})
        return htmlfill.render(form_content, defaults=defaults)

    @validate(schema=UserSettingsOptionalForm(),
              form="_settings_optional_form",
              post_only=True, auto_error_formatter=error_formatter)
    def settings_optional_update(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)
        updated = self._update_optional_attributes(c.page_user,
                                                   self.form_result)
        if updated:
            model.meta.Session.commit()

        return self._settings_result(updated, c.page_user, 'optional')

    def _update_optional_attributes(self, user, attributes):

        current = user.optional_attributes or {}
        updated = False
        for (key, _, _, _, _) in config.get_optional_user_attributes():
            if current.get(key, None) != attributes[key]:
                current[key] = attributes[key]
                updated = True
        if updated:
            user.optional_attributes = current
        return updated

    def redirect_settings(self, item=None):
        if c.user is None:
            redirect(h.login_redirect_url())
        if item is None:
            redirect(settings_url(c.user, None, force_url='settings'))
        else:
            redirect(settings_url(c.user, item))

    def redirect_settings_login(self):
        self.redirect_settings('login')

    def redirect_settings_notifications(self):
        self.redirect_settings('notifications')

    def redirect_settings_advanced(self):
        self.redirect_settings('advanced')

    def redirect_settings_optional(self):
        self.redirect_settings('optional')

    @RequireInternalRequest(methods=['POST'])
    @validate(schema=UserSetPasswordForm(), form='edit', post_only=True)
    def set_password(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)
        c.page_user.password = self.form_result.get('password')
        model.meta.Session.add(c.page_user)
        model.meta.Session.commit()

        h.flash(_('Password has been set. Have fun!'), 'success')
        redirect(h.base_url('/'))

    def reset_form(self):
        return render("/user/reset_form.html")

    @RequireInternalRequest(methods=['POST'])
    @validate(schema=UserResetApplyForm(), form="reset_form", post_only=True)
    def reset_request(self):
        user = model.User.find_by_email(self.form_result.get('email'))
        if user is None:
            msg = _("There is no user registered with that email address.")
            return htmlfill.render(self.reset_form(), errors=dict(email=msg))
        return self._handle_reset(user)

    def _handle_reset(self, user):
        c.page_user = user

        if welcome_enabled():
            welcome_code = (c.page_user.welcome_code
                            if c.page_user.welcome_code
                            else random_token())
            c.page_user.reset_code = u'welcome!' + welcome_code
            model.meta.Session.add(c.page_user)
            model.meta.Session.commit()
            url = welcome_url(c.page_user, welcome_code)
            body = (
                _("you have requested that your password be reset. In order "
                  "to confirm the validity of your claim, please open the "
                  "link below in your browser:") +
                "\n\n  " + url + "\n")
            libmail.to_user(c.page_user,
                            _("Login for %s") % h.site.name(),
                            body)
        else:
            c.page_user.reset_code = random_token()
            model.meta.Session.add(c.page_user)
            model.meta.Session.commit()
            url = h.base_url("/user/%s/reset?c=%s" % (c.page_user.user_name,
                                                      c.page_user.reset_code),
                             absolute=True)
            body = (
                _("you have requested that your password be reset. In order "
                  "to confirm the validity of your claim, please open the "
                  "link below in your browser:") +
                "\r\n\r\n  " + url + "\n" +
                _("Your user name to login is: %s") % c.page_user.user_name)

            libmail.to_user(c.page_user, _("Reset your password"), body)
        return render("/user/reset_pending.html")

    @validate(schema=UserCodeForm(), form="reset_form", post_only=False,
              on_get=True)
    def reset(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        try:
            if c.page_user.reset_code != self.form_result.get('c'):
                raise ValueError()
            new_password = random_token()
            c.page_user.password = new_password
            model.meta.Session.add(c.page_user)
            model.meta.Session.commit()
            body = (
                _("your password has been reset. It is now:") +
                "\r\n\r\n  " + new_password + "\r\n\r\n" +
                _("Please login and change the password in your user "
                  "settings.") + "\n\n" +
                _("Your user name to login is: %s") % c.page_user.user_name
            )
            libmail.to_user(c.page_user, _("Your new password"), body)
            h.flash(_("Success. You have been sent an email with your new "
                      "password."), 'success')
        except Exception:
            h.flash(_("The reset code is invalid. Please repeat the password"
                      " recovery procedure."), 'error')
        redirect('/login')

    @validate(schema=UserCodeForm(), form="edit", post_only=False, on_get=True)
    def activate(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        code = self.form_result.get('c')

        # If activate_came_from is set, we assume that we've tried to do
        # validate email address during doing some other action.
        activate_came_from = session.get('activate_came_from')
        if activate_came_from:
            c.came_from = activate_came_from
            del session['activate_came_from']
            success_url = activate_came_from
            no_success_url = h.validate_redirect_url()
        else:
            success_url = h.entity_url(c.page_user)
            no_success_url = h.entity_url(c.page_user)

        if c.page_user.activation_code != code:
            h.flash(_("The activation code is invalid. Please have it "
                      "resent."), 'error')
            redirect(no_success_url)
        if c.page_user.activation_code is None:
            h.flash(_(u'Thank you, The address is already activated.'))
            redirect(success_url)

        c.page_user.activation_code = None
        model.meta.Session.commit()
        if code.startswith(model.User.IMPORT_MARKER):
            # Users imported by admins
            login_user(c.page_user, request, response)
            h.flash(_("Welcome to %s") % h.site.name(), 'success')
            if c.instance:
                membership = model.Membership(c.page_user, c.instance,
                                              c.instance.default_group)
                model.meta.Session.expunge(membership)
                model.meta.Session.add(membership)
                model.meta.Session.commit()
                redirect(h.entity_url(c.instance))
            else:
                redirect(h.user.post_register_url(c.page_user))
        else:
            h.flash(_("Your email has been confirmed."), 'success')
            redirect(success_url)

        redirect(success_url)

    def ask_activate(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        if c.page_user.is_email_activated():
            if c.came_from:
                redirect(c.came_from)
            else:
                redirect(h.entity_url(c.page_user))

        c.hide_activate_attention_getter = True
        return render('/user/ask_activate.html')

    def pending_activate(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        if c.page_user.is_email_activated():
            if c.came_from:
                redirect(c.came_from)
            else:
                redirect(h.entity_url(c.page_user))

        c.hide_activate_attention_getter = True
        return render('/user/pending_activate.html')

    @RequireInternalRequest()
    def resend(self, id):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.edit(c.page_user)
        libmail.send_activation_link(c.page_user)

        if c.came_from:
            session['activate_came_from'] = c.came_from
            force_path = h.entity_url(c.page_user, member='pending_activate',
                                      query={'came_from': c.came_from})
        else:
            force_path = None

        ret_success(
            message=_("The activation link has been re-sent to your email "
                      "address."), category='success',
            entity=c.page_user, member='settings/notifications',
            format=None, force_path=force_path)

    @staticmethod
    def _get_profile_nav(user, active_key):
        c.member = {
            u'about': u'about',
            u'activity': u'latest_events',
            u'contributions': u'latest_contributions',
            u'votes': u'latest_votes',
            u'delegations': u'latest_delegations',
        }[active_key]
        nav = [
            (u'about' == active_key, _(u'About us')
                if c.page_user.is_organization else _(u'About me'),
                h.entity_url(c.page_user, member='about')),
            (u'activity' == active_key, _(u'Newest events'), h.entity_url(
                c.page_user, member='latest_events')),
            (u'contributions' == active_key, _(u'Contributions'), h.entity_url(
                c.page_user, member='latest_contributions')),
            (u'votes' == active_key, _(u'Votes'), h.entity_url(
                c.page_user, member='latest_votes')),
        ]
        if ((c.instance is None and any(i.allow_delegate for i in c.instances))
                or (c.instance is not None and c.instance.allow_delegate)):
            nav.append((u'delegations' == active_key,
                       _(u'Delegations'),
                       h.entity_url(c.page_user,
                                    member='latest_delegations')))
        return nav

    @staticmethod
    def _get_dashboard_nav(user, active_key):
        c.member = {
            u'all': None,
            u'contributions': u'contributions',
            u'votes': u'votes',
            u'delegations': u'delegations',
            u'messages': u'messages',
        }[active_key]
        nav = [
            (u'all' == active_key, _(u'All Events'), h.base_url(
                u'/user/dashboard', instance=c.instance)),
            (u'contributions' == active_key, _(u'Contributions'), h.base_url(
                u'/user/dashboard/contributions', instance=c.instance)),
            (u'votes' == active_key, _(u'Votes'), h.base_url(
                u'/user/dashboard/votes', instance=c.instance)),
            (u'messages' == active_key, _(u'Messages'), h.base_url(
                u'/user/dashboard/messages', instance=c.instance)),
        ]
        if ((c.instance is None and any(i.allow_delegate for i in c.instances))
                or (c.instance is not None and c.instance.allow_delegate)):
            nav.append((u'delegations' == active_key,
                       _(u'Delegations'),
                       h.base_url(u'/user/dashboard/delegations',
                                  instance=c.instance)))
        return nav

    def _get_events(self, nr_events=None, event_filter=[]):
        """get events triggerd by this user"""
        query = model.Event.all_q(instance=c.instance,
                                  include_hidden=False,
                                  event_filter=event_filter)
        query = query.filter(model.Event.user == c.page_user)
        query = query.order_by(model.Event.time.desc())
        if nr_events is not None:
            query = query.limit(nr_events)
        return query.all()

    def _get_notifications(self, nr_notifications=None, event_filter=[]):
        """get notifications for this user"""
        q = model.meta.Session.query(model.Notification)
        q = q.filter(model.Notification.user == c.user)
        q = q.join(model.Event).order_by(model.Event.time.desc())
        if event_filter:
            q = q.filter(model.Notification.event_type.in_(event_filter))
        if c.instance:
            q = q.filter(model.Event.instance == c.instance)
        if nr_notifications is not None:
            q = q.limit(nr_notifications)
        return q.all()

    def _show_common(self, id, user, events):
        """
        Adds some pieces of information to the user info sidebar box.
        Requires events list in order to determine last activity.
        """
        if c.instance is None:
            c.active_global_nav = 'user'

        c.last_activity = events[0].time if events else None
        badges = user.badges
        if c.instance:
            c.local_badges = filter(lambda b: b.instance == c.instance, badges)
        else:
            c.local_badges = []
        c.global_badges = filter(lambda b: b.instance is None, badges)
        c.visible_badges = filter(lambda b: b.visible,
                                  c.global_badges + c.local_badges)
        c.instances = c.page_user.real_instances(exclude_current=False)

        c.tile = tiles.user.UserTile(user)
        self._common_metadata(user, add_canonical=True)

    def _show(self, id, format=None, current_nav=None, event_filter=[]):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)

        require.user.show(c.page_user)
        c.events = self._get_events(nr_events=100, event_filter=event_filter)
        self._show_common(id, user=c.page_user, events=c.events)

        if format == 'json':
            return render_json(c.page_user)

        if format == 'rss':
            return event.rss_feed(
                c.events, "%s Latest Actions" % c.page_user.name,
                h.base_url('/user/%s' % c.page_user.user_name, None),
                c.page_user.bio)

        c.events_pager = pager.events(c.events,
                                      row_type=u'profile_row')

        c.user_nav = self._get_profile_nav(c.page_user, current_nav)

        data = {
            u'show_upload_avatar': (c.page_user == c.user and
                                    can.user.edit(c.page_user) and
                                    not logo.exists(c.page_user)),
        }

        return render("/user/show.html", data=data,
                      overlay=(format == 'overlay'))

    def show(self, id, format=None):
        """ legacy route. """
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        redirect(h.entity_url(c.page_user, member=u'about', format=format))

    def dashboard(self, format='html', current_nav=u'all', event_filter=[]):
        if c.user is None:
            redirect(h.base_url('/login', query_params={
                u'came_from': request.url,
            }))

        require.user.show_dashboard(c.user)

        c.page_user = c.user

        notifications = self._get_notifications(100, event_filter)
        c.events = [n.event for n in notifications]
        self._show_common(id, user=c.user, events=c.events)

        if format == 'json':
            return render_json(c.user)

        if format == 'rss':
            return event.rss_feed(
                c.events, "%s Latest Actions" % c.user.name,
                h.base_url('/user/%s' % c.user.user_name, None),
                c.user.bio)

        c.events_pager = pager.events(c.events)

        c.dashboard = True
        c.user_nav = self._get_dashboard_nav(c.user, current_nav)

        return render("/user/show.html", overlay=(format == 'overlay'))

    def dashboard_contributions(self, format='html',
                                current_nav=u'contributions'):
        return self.dashboard(format=format, current_nav=current_nav,
                              event_filter=S_CONTRIBUTION)

    def dashboard_votes(self, format='html', current_nav=u'votes'):
        return self.dashboard(format=format, current_nav=current_nav,
                              event_filter=S_VOTE)

    def dashboard_delegations(self, format='html', current_nav=u'delegations'):
        return self.dashboard(format=format, current_nav=current_nav,
                              event_filter=S_DELEGATION)

    def dashboard_messages(self, format='html', current_nav=u'messages'):
        return self.dashboard(format=format, current_nav=current_nav,
                              event_filter=S_MESSAGE)

    def about(self, id, format='html'):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.show(c.page_user)
        c.events = self._get_events()
        self._show_common(id, user=c.page_user, events=c.events)
        c.user_nav = self._get_profile_nav(c.page_user, u'about')

        data = {
            u'show_upload_avatar': (c.page_user == c.user and
                                    can.user.edit(c.page_user) and
                                    not logo.exists(c.page_user)),
            u'about': True,
            u'bio': c.page_user.bio,
        }

        return render("/user/show.html", data=data,
                      overlay=(format == 'overlay'))

    def latest_events(self, id, format='html'):
        return self._show(id, format, u'activity')

    def latest_contributions(self, id, format='html'):
        return self._show(id, format, u'contributions', S_CONTRIBUTION)

    def latest_milestones(self, id, format='html'):
        # Milestone events don't exist yet
        return NotImplemented

    def latest_votes(self, id, format='html'):
        return self._show(id, format, u'votes', S_VOTE)

    def latest_delegations(self, id, format='html'):
        return self._show(id, format, u'delegations', S_DELEGATION)

    @guard.perm('user.view')
    def avatar(self, id, y=24, x=None):
        user = get_entity_or_abort(model.User, id, instance_filter=False)
        return render_logo(user, y, x=x, fallback=logo.USER)

    def login(self):
        c.active_global_nav = "login"
        if c.user:
            if c.came_from != u'':
                redirect(h.url.unquote(c.came_from))
            else:
                redirect(h.user.post_login_url(c.user))
        else:
            return self._render_loginform()

    def _render_loginform(self, errors=None, defaults=None, format=u'html'):
        if defaults is None:
            defaults = dict(request.params)
            defaults.setdefault('have_password', 'true')
            if '_login_value' in request.environ:
                defaults['login'] = request.environ['_login_value']
            defaults['_tok'] = token_id()
        data = {}
        data['hide_locallogin'] = (
            config.get_bool('adhocracy.hide_locallogin')
            and 'locallogin' not in request.GET)
        add_static_content(data, u'adhocracy.static_login_path')
        form = render('/user/login_tile.html', data,
                      overlay=format == u'overlay')
        form = htmlfill.render(form,
                               errors=errors,
                               defaults=defaults)
        return render('/user/login.html', {'login_form_code': form},
                      overlay=format == u'overlay')

    def perform_login(self):
        pass  # managed by repoze.who

    def post_login(self):
        if c.user:
            session['logged_in'] = True
            session.save()
            if c.came_from != u'':
                redirect(h.url.unquote(c.came_from))
            else:
                # redirect to the dashboard inside the instance exceptionally
                # to be able to link to proposals and norms in the welcome
                # message.
                redirect(h.user.post_login_url(c.user))
        else:
            login_configuration = h.allowed_login_types()
            error_message = _("Invalid login")

            if 'username+password' in login_configuration:
                if 'email+password' in login_configuration:
                    error_message = _("Invalid email / user name or password")
                else:
                    error_message = _("Invalid user name or password")
            else:
                if 'email+password' in login_configuration:
                    error_message = _("Invalid email or password")

            return self._render_loginform(errors={"login": error_message})

    def logout(self):
        pass  # managed by repoze.who

    def post_logout(self):
        login_type = session.get('login_type', None)
        session.delete()
        # Note: This flash message only works with adhocracy cookie sessions
        # and not with beaker sessions due to the way session deletion is
        # handled in beaker.
        if login_type == 'shibboleth':
            logout_url = config.get('adhocracy.shibboleth_logout_url')
            if logout_url is None:
                target_msg = u''
            else:
                target_msg = (_(u"You can finish that session <a href='%s'>"
                                u"here</a>.") % logout_url)
            h.flash(_(
                u"<p>You have successfully logged out of Adhocracy. However "
                u"you might still be logged in at the central identity "
                u"provider. %s</p>"
                u""
                u"<p>If you're on a public computer, please close your "
                u"browser to complete the logout.</p>") % target_msg,
                'warning')
        elif login_type == 'openid':
            h.flash(_(
                u"You have successfully logged out of Adhocracy. However you "
                u"might still be logged in through your OpenID provider. "),
                'warning')
        else:
            h.flash(_(u"Successfully logged out"), 'success')
        redirect(h.base_url())

    @RequireInternalRequest(methods=['POST'])
    @validate(schema=NoPasswordForm(), post_only=True)
    def nopassword(self):
        """ (Alternate login) User clicked "I have no password" """

        assert config.get('adhocracy.login_style') == 'alternate'
        user = request.environ['_adhocracy_nopassword_user']
        if user:
            return self._handle_reset(user)

        login = self.form_result.get('login')
        if u'@' not in login:
            msg = _("Please use a valid email address.")
            return self._render_loginform(errors={'login': msg})

        if h.allow_user_registration():
            handle = login.partition(u'@')[0]
            defaults = {
                'email': login,
                'user_name': re.sub('[^0-9a-zA-Z_-]', '', handle),
            }
            return self.new(defaults=defaults)

        support_email = config.get('adhocracy.registration_support_email')
        if support_email:
            body = (_('A user tried to register on %s with the email address'
                      ' %s. Please contact them at %s .') %
                    (h.site.name(),
                     login,
                     h.base_url('/', absolute=True)))
            libmail.to_mail(
                to_name=h.site.name(),
                to_email=support_email,
                subject=_('Registration attempt on %s') % h.site.name(),
                body=body,
                decorate_body=False,
            )
            data = {
                'email': login,
            }
            return render('/user/registration_request_sent.html', data=data)

        return ret_abort(
            _("Sorry, registration has been disabled by administrator."),
            category='error', code=403)

    def legacy_dashboard(self, id):
        redirect(h.base_url(u'/user/dashboard'))

    def legacy_dashboard_proposals(self, id):
        redirect(h.base_url(u'/user/dashboard/proposals'))

    def legacy_dashboard_pages(self, id):
        redirect(h.base_url(u'/user/dashboard/pages'))

    @guard.perm("user.view")
    def complete(self):
        prefix = unicode(request.params.get('q', u''))
        users = model.User.complete(prefix, 15)
        results = []
        for user in users:
            if user == c.user:
                continue
            display = "%s (%s)" % (user.user_name, user.name) if \
                      user.display_name else user.name
            results.append(dict(display=display, user=user.user_name))
        return render_json(results)

    @RequireInstance
    def votes(self, id, format='html'):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.show(c.page_user)
        decisions = democracy.Decision.for_user(c.page_user, c.instance)

        if format == 'json':
            return render_json(list(decisions))

        decisions = filter(lambda d: d.poll.action != model.Poll.RATE,
                           decisions)
        c.decisions_pager = pager.user_decisions(decisions)
        self._common_metadata(c.page_user, member='votes')

        return render("/user/votes.html", overlay=(format == 'overlay'))

    @RequireInstance
    def delegations(self, id, format='html'):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.show(c.page_user)
        scope_id = request.params.get('scope', None)

        if format == 'json':
            delegations = model.Delegation.find_by_principal(c.page_user)
            scope = model.Delegateable.find(scope_id) if scope_id else None
            if scope is not None:
                delegations = [d for d in delegations if d.is_match(scope)]
            delegations_pager = pager.delegations(delegations)
            return render_json(delegations_pager)

        c.dgbs = []
        if scope_id:
            c.scope = forms.ValidDelegateable().to_python(scope_id)
            c.dgbs = [c.scope] + c.scope.children
        else:
            c.dgbs = model.Delegateable.all(instance=c.instance)
        c.nodeClass = democracy.DelegationNode
        self._common_metadata(c.page_user, member='delegations')

        return render("/user/delegations.html", overlay=(format == 'overlay'))

    def instances(self, id, format='html'):
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.show(c.page_user)
        instances = [i for i in c.page_user.instances if i.is_shown()]
        c.instances_pager = pager.instances(instances)

        if format == 'json':
            return render_json(c.instances_pager)

        self._common_metadata(c.page_user, member='instances',
                              add_canonical=True)

        return render("/user/instances.html", overlay=(format == 'overlay'))

    @guard.watch.index()
    def watchlist(self, id, format='html'):
        c.active_global_nav = 'watchlist'
        c.page_user = get_entity_or_abort(model.User, id,
                                          instance_filter=False)
        require.user.show_watchlist(c.page_user)
        watches = model.Watch.all_by_user(c.page_user)
        entities = [w.entity for w in watches if (w.entity is not None)
                    and (not isinstance(w.entity, unicode))]

        c.entities_pager = NamedPager(
            'watches', entities, tiles.dispatch_row_with_comments,
            sorts={_("oldest"): sorting.entity_oldest,
                   _("newest"): sorting.entity_newest},
            default_sort=sorting.entity_newest)

        if format == 'json':
            return render_json(c.entities_pager)

        self._common_metadata(c.page_user, member='watchlist')
        return render("/user/watchlist.html", overlay=(format == 'overlay'))

    @RequireInstance
    @RequireInternalRequest()
    @validate(schema=UserGroupmodForm(), form="edit",
              post_only=False, on_get=True)
    def groupmod(self, id):
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.supervise(c.page_user)
        to_group = self.form_result.get("to_group")
        had_vote = c.page_user._has_permission("vote.cast")
        for membership in c.page_user.memberships:
            if (not membership.is_expired() and
                    membership.instance == c.instance):
                membership.group = to_group
        model.meta.Session.commit()
        event.emit(event.T_INSTANCE_MEMBERSHIP_UPDATE, c.page_user,
                   instance=c.instance, group=to_group, admin=c.user)
        if had_vote and not c.page_user._has_permission("vote.cast"):
            # user has lost voting privileges
            c.page_user.revoke_delegations(c.instance)
        model.meta.Session.commit()
        redirect(h.entity_url(c.page_user))

    @RequireInternalRequest()
    def ban(self, id):
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.manage(c.page_user)
        c.page_user.banned = True
        model.meta.Session.commit()
        h.flash(_("The account has been suspended."), 'success')
        redirect(h.entity_url(c.page_user))

    @RequireInternalRequest()
    def unban(self, id):
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.manage(c.page_user)
        c.page_user.banned = False
        model.meta.Session.commit()
        h.flash(_("The account has been re-activated."), 'success')
        redirect(h.entity_url(c.page_user))

    def ask_delete(self, id):
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.delete(c.page_user)
        return render('/user/ask_delete.html')

    @RequireInternalRequest()
    def delete(self, id):
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.delete(c.page_user)
        c.page_user.delete()
        model.meta.Session.commit()
        h.flash(_("The account has been deleted."), 'success')
        if c.instance is not None:
            redirect(h.instance.url(c.instance))
        else:
            redirect(h.site.base_url(instance=None))

    @guard.user.index()
    @validate(schema=UserFilterForm(), post_only=False, on_get=True)
    def filter(self):
        query = self.form_result.get('users_q')
        users = libsearch.query.run(query + u"*", entity_type=model.User,
                                    instance_filter=True)
        c.users_pager = pager.users(users, has_query=True)
        return c.users_pager.here()

    def _allowed_badges(self):
        if has('global.admin'):
            global_badges = model.UserBadge.all(instance=None)
        else:
            global_badges = []
        if c.instance is None:
            instance_badges = []
        else:
            instance_badges = model.UserBadge.all(instance=c.instance)
        return (global_badges, instance_badges)

    def _all_allowed_badges(self):
        allowed = self._allowed_badges()
        return set(allowed[0]).union(set(allowed[1]))

    def edit_badges(self, id, errors=None, format=u'html'):
        c.badges, c.instance_badges = self._allowed_badges()
        c.page_user = get_entity_or_abort(model.User, id)
        require.user.badge(c.page_user)
        defaults = {'badge': [str(badge.id) for badge in c.page_user.badges]}
        return formencode.htmlfill.render(
            render("/user/badges.html", overlay=format == u'overlay'),
            defaults=defaults,
            force_defaults=False)

    @RequireInternalRequest()
    @validate(schema=UserBadgesForm(), form='edit_badges')
    def update_badges(self, id, format=u'html'):
        user = get_entity_or_abort(model.User, id)
        require.user.badge(user)
        want = set(self.form_result.get('badge'))

        allowed = self._all_allowed_badges()
        if not want.issubset(allowed):
            h.flash(_(u'Invalid badge choice.'), u'error')
            redirect(h.entity_url(user))

        notwant = allowed.difference(want)
        has = set(user.badges)

        removed = set()
        for badge in has.intersection(notwant):
            user.badges.remove(badge)
            removed.add(badge)

        added = set()
        creator = c.user
        for badge in want.difference(has):
            badge.assign(user, creator)
            added.add(badge)

        model.meta.Session.flush()
        # FIXME: needs commit() cause we do an redirect() which raises
        # an Exception.
        model.meta.Session.commit()
        update_entity(user, model.UPDATE)
        if added:
            h.flash(u'%s: %s' % (
                _(u"Added badges") if len(added) > 1 else _(u"Added badge"),
                ', '.join(badge.title for badge in added)), u'success')
        if removed:
            h.flash(u'%s: %s' % (
                _(u"Removed badges") if len(removed) > 1
                else _(u"Removed badge"),
                ', '.join(badge.title for badge in removed)), u'success')
        redirect(h.entity_url(user, instance=c.instance))

    def _common_metadata(self, user, member=None, add_canonical=False):
        bio = user.bio
        if not bio:
            bio = _("%(user)s is using Adhocracy, a democratic "
                    "decision-making tool.") % {'user': user.name}
        description = h.truncate(text.meta_escape(bio), length=200,
                                 whole_word=True)
        h.add_meta("description", description)
        h.add_meta("dc.title", text.meta_escape(user.name))
        h.add_meta("dc.date", user.access_time.strftime("%Y-%m-%d"))
        h.add_meta("dc.author", text.meta_escape(user.name))
        h.add_rss(_("%(user)ss Activity") % {'user': user.name},
                  h.entity_url(user, format='rss'))
        if c.instance and not user.is_member(c.instance):
            h.flash(_("%s is not a member of %s") % (user.name,
                                                     c.instance.label),
                    'notice')
        if user.banned:
            h.flash(_("%s is banned from the system.") % user.name, 'notice')

    @classmethod
    def email_is_blacklisted(self, email):
        if email is None:
            return False
        listed = config.get('adhocracy.registration.email.blacklist')
        listed = listed.replace(',', ' ').replace('.', '').split()
        email = email.replace('.', '')
        if email in listed:
            return True
        else:
            return False

    def welcome(self, id, token):
        # Intercepted by WelcomeRepozeWho, only errors go in here
        if c.user:
            return redirect(request.params.get('came_from', '/'))

        h.flash(_('You already have a password - use that to log in.'),
                'error')
        return redirect(h.base_url('/login', query_params=request.params))

    @RequireInternalRequest(methods=['POST'])
    @guard.perm('global.admin')
    def generate_welcome_link(self, id):
        if not can_welcome():
            return ret_abort(_("Requested generation of welcome codes, but "
                               "welcome functionality"
                               "(adhocracy.enable_welcome) is not enabled."),
                             code=403)

        page_user = get_entity_or_abort(model.User, id,
                                        instance_filter=False)
        if not page_user.welcome_code:
            page_user.welcome_code = random_token()
            model.meta.Session.add(page_user)
            model.meta.Session.commit()
        url = welcome_url(page_user, page_user.welcome_code)
        h.flash(_('The user can now log in via %s') % url, 'success')
        redirect(h.entity_url(page_user))

########NEW FILE########
__FILENAME__ = velruse
import logging
import random
from json import loads, dumps

from pylons import request, response, session, tmpl_context as c
from pylons.controllers.util import abort
from pylons.controllers.util import redirect
from pylons.i18n import _
from sqlalchemy.exc import IntegrityError
from requests import get

from adhocracy.lib.auth.authentication import allowed_login_types
from adhocracy.lib.base import BaseController
from adhocracy.lib import event
from adhocracy.lib.auth import can
from adhocracy.lib.auth import login_user
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.model.velruse import Velruse
from adhocracy import model
from adhocracy.model.user import User
from adhocracy.lib import helpers as h
from adhocracy.lib.exceptions import DatabaseInconsistent
from adhocracy.lib.templating import render

log = logging.getLogger(__name__)

MAX_USER_NAME_LENGTH = User.user_name.property.columns[0].type.length


def unused_user_name(preferred_user_name, recursion_depth=913):
    """
    Will find an adhocracy username which is not used
    but similiar to the given one.
    """

    if (recursion_depth < 0):
        raise "internal error: could not find any unused user names!"

    if (len(preferred_user_name) > MAX_USER_NAME_LENGTH
            or preferred_user_name == ""):
        unused_user_name("user",
                         recursion_depth=recursion_depth - 1)

    if User.find_by_user_name(preferred_user_name) is None:
        return preferred_user_name
    else:
        random_digit = random.randint(0, 9)
        return unused_user_name(preferred_user_name + str(random_digit),
                                recursion_depth=recursion_depth - 1)


def update_email_trust(adhocracy_user, velruse_email):
    if adhocracy_user.email == velruse_email:
        adhocracy_user.set_email_verified()


class VelruseController(BaseController):

    def login_with_velruse(self):
        session['came_from'] = request.params.get('came_from',
                                                  h.base_url('/login'))
        session.save()
        return render("/velruse/redirect_post.html")

    def logged_in(self):
        """
        Recieves authentication messages from the velruse service.
        It will log in users or connect their adhocracy account
        to an existing velruse account.
        It also creates adhocracy accounts if it thinks the user has none.
        We expect the ssi service to provide a *verified* email address.
        If none is provided, this function will crash.
        """

        redirect_url = session.get('came_from', h.base_url('/login'))

        token = request.params['token']
        payload = {'format': 'json', 'token': token}
        rsp = get(h.velruse_url('/auth_info'),
                  params=payload,
                  timeout=1)
        if rsp.status_code >= 400:
            return self._failure(_('Internal server error:'
                                 'velruse service not available.'),
                                 redirect_url=redirect_url)

        auth_info = loads(rsp.content)
        log.debug('received auth_info from velruse:\n' +
                  '<pre>' + dumps(auth_info, indent=4) + '</pre>')

        if 'error' in auth_info:
            error = auth_info['error']
            if error == 'user_denied':
                return self._failure(_('Login failed: ') +
                                     _('You have to give Adhocracy permission '
                                       'to connect to your Facebook account.'),
                                     auth_info,
                                     redirect_url=redirect_url)
            else:
                return self._failure(_('Login failed: ') + auth_info['error'],
                                     auth_info, redirect_url=redirect_url)

        provider_name = auth_info['provider_name']

        if provider_name not in allowed_login_types():
            self._failure(_("Logging in with %s "
                          "is not allowed on this installation.")
                          % provider_name.capitalize(),
                          auth_info, redirect_url=redirect_url)
        else:
            try:
                profile = auth_info['profile']
                email = profile['verifiedEmail']  # FIXME: this is not always available.  we should catch that earlier above.
                display_name = profile['displayName']
                preferred_name = profile['preferredUsername'].replace('.', '_')
                user_name = unused_user_name(preferred_name)
                accounts = profile['accounts']
            except KeyError:
                log.error('could not parse velruse response:\n' +
                          '<pre>' + dumps(auth_info, indent=4) + '</pre>')
                self._failure(_("Error"))

            if c.user is not None:
                adhocracy_user = c.user
                velruse_user = Velruse.by_user_and_domain_first(
                    adhocracy_user,
                    accounts[0]['domain'])

                if velruse_user is not None:
                    self._failure(_("This %(provider)s account"
                                    " is already connected.")
                                  % {'provider': provider_name.capitalize()},
                                  redirect_url=redirect_url)
            else:
                velruse_user = Velruse.find_any(accounts)

                if velruse_user is not None:
                    adhocracy_user = velruse_user.user
                else:
                    adhocracy_user = None

            if velruse_user is not None:
                domain = velruse_user.domain
                domain_user = velruse_user.domain_user
            else:
                domain = accounts[0]['domain']
                domain_user = accounts[0]['userid']  # FIXME: this is not always available.  we should catch that earlier above.

            if not domain or not domain_user:
                log.error('domain and/or domain_user not found:\n' +
                          '<pre>\n' +
                          str(domain, domain_user) + '\n' +
                          dumps(auth_info, indent=4) + '\n' +
                          '</pre>')
                self._failure(_("Error"), redirect_url=redirect_url)

            try:
                # login right away
                if adhocracy_user is not None and velruse_user is not None:
                    update_email_trust(adhocracy_user, email)
                    self._login(adhocracy_user, redirect_url=redirect_url)

                # create new user in both Velruse and User and login
                elif adhocracy_user is None and velruse_user is None:
                    new_user = self._create(user_name,
                                            email,
                                            domain,
                                            domain_user,
                                            email_verified=True,
                                            display_name=display_name,
                                            redirect_url=redirect_url)

                    adhocracy_user, velruse_user = new_user
                    self._login(adhocracy_user, redirect_url=redirect_url)

                # create new user in Velruse for a logged in user
                elif adhocracy_user is not None and velruse_user is None:
                    self._connect(adhocracy_user, domain, domain_user,
                                  provider_name,
                                  email, email_verified=True,
                                  redirect_url=redirect_url)

                # error case
                else:
                    raise DatabaseInconsistent('velruse user is not associated'
                                               ' with any adhocracy user')

            # if users are deleted and we try to create them again
            # we get an IntegrityError
            except IntegrityError:
                self._failure(_("Your %(provider)s account is locked.")
                              % {'provider': provider_name.capitalize()})

    def _login(self, adhocracy_user, redirect_url=None):
        """
        Log the user in and redirect him to a sane place.
        """

        assert adhocracy_user

        login_user(adhocracy_user, request, response)
        session['login_type'] = 'velruse'

        if redirect_url is None:
            if c.instance and not adhocracy_user.is_member(c.instance):
                redirect(h.base_url("/instance/join/%s?%s" % (c.instance.key,
                                                              h.url_token())))
            else:
                redirect(h.user.post_login_url(adhocracy_user))
        else:
            redirect(redirect_url)

    def _failure(self, message, auth_info=None,
                 redirect_url=None):
        """
        Abort a velruse authenication attempt and return to login page,
        giving an error message at the openid / velruse area.
        """

        log.info('velruse login error: ' + message)
        if auth_info:
            log.debug('<pre>' + dumps(auth_info, indent=4) + '</pre>')

        h.flash(message, 'error')

        if redirect_url is None:
            if c.user:
                return redirect(h.entity_url(c.user, member='settings/login'))
            else:
                redirect("/login")
        else:
            redirect(redirect_url)

    def _create(self, user_name, email, domain, domain_user,
                email_verified=False, display_name=None,
                redirect_url=None):
        """
        Create a user based on data gathered from velruse.
        """

        model.meta.Session.begin(subtransactions=True)

        try:
            user = User.find_by_email(email)
            if user is None:
                user = model.User.create(user_name,
                                         email,
                                         locale=c.locale,
                                         display_name=display_name)

            if email_verified:
                user.set_email_verified()

            v = Velruse(unicode(domain), unicode(domain_user), user)
            model.meta.Session.add(v)

            model.meta.Session.commit()

            event.emit(event.T_USER_CREATE, user)
            return user, v

        except Exception as e:
            model.meta.Session.rollback()
            raise e

    def _connect(self, adhocracy_user, domain, domain_user,
                 provider_name,
                 velruse_email, email_verified=False,
                 redirect_url=None):
        """
        Connect existing adhocracy user to velruse.
        """

        if not Velruse.find(domain, domain_user):
            velruse_user = Velruse.connect(adhocracy_user, domain, domain_user,
                                           velruse_email, email_verified)

            model.meta.Session.commit()

            h.flash(_("You successfully connected to %s."
                      % provider_name.capitalize()),
                    'success')

            if redirect_url is None:
                redirect(h.user.post_login_url(adhocracy_user))
            else:
                redirect(redirect_url)
            return velruse_user

        else:
            h.flash(_("Your %s account is already connected."
                      % provider_name.capitalize()),
                    'error')

            redirect(h.user.post_login_url(adhocracy_user))
            return None

    @RequireInternalRequest()
    def revoke(self, redirect_url=None):
        v_id = request.params.get('id', None)

        if v_id is None:
            abort(401, "id of velruse account not specified")

        v = Velruse.by_id(v_id)
        if v is None:
            self._failure(_("You are trying to disconnect from a provider"
                            " you are disconnected from already."))
            return None

        elif not (v.user == c.user or can.user.manage()):
            abort(403, _("You're not authorized to change %s's settings.")
                  % c.user.id)
        else:
            v.delete_forever()
            model.meta.Session.commit()

            h.flash(_("You successfully disconnected from %(provider)s.")
                    % {'provider': v.domain},
                    'success')

            if redirect_url is None:
                redirect(h.entity_url(c.user, member='settings/login'))
            else:
                redirect(redirect_url)

########NEW FILE########
__FILENAME__ = watch
import logging

import formencode

from pylons import tmpl_context as c
from pylons.controllers.util import abort, redirect
from pylons.decorators import validate
from pylons.i18n import _


from adhocracy import model
import adhocracy.forms as forms
from adhocracy.lib import helpers as h
from adhocracy.lib.auth import guard
from adhocracy.lib.auth import require
from adhocracy.lib.auth.csrf import RequireInternalRequest
from adhocracy.lib.base import BaseController


log = logging.getLogger(__name__)


class WatchCreateForm(formencode.Schema):
    allow_extra_fields = True
    ref = forms.ValidRef()


class WatchDeleteForm(formencode.Schema):
    allow_extra_fields = True
    watch = forms.ValidWatch()


class WatchController(BaseController):

    @RequireInternalRequest()
    @guard.watch.create()
    @validate(schema=WatchCreateForm(), form='bad_request', post_only=False,
              on_get=True)
    def create(self, format='html'):
        entity = self.form_result.get('ref')
        try:
            model.Watch.create(c.user, entity, check_existing=True)
            model.meta.Session.commit()
        except model.watch.WatchAlreadyExists:
            h.flash(_(u"A watchlist entry for this entity already exists."),
                    u'notice')
        redirect(h.entity_url(entity))

    @RequireInternalRequest()
    @validate(schema=WatchDeleteForm(), form='bad_request',
              post_only=False, on_get=True)
    def delete(self, format='html'):
        watch = self.form_result.get('watch')
        require.watch.delete(watch)
        if watch.user != c.user and not h.has_permission('instance.admin'):
            abort(403, _("You're not authorized to delete %s's watchlist "
                         "entries.") % watch.user.name)
        watch.delete()
        model.meta.Session.commit()
        redirect(h.entity_url(watch.entity))

########NEW FILE########
__FILENAME__ = common
import csv
from datetime import datetime
import re
from StringIO import StringIO
from PIL import Image

import formencode
from pylons import tmpl_context as c
from pylons.i18n import _
from webhelpers.html import literal

from sqlalchemy import func

from adhocracy import config
from adhocracy.lib.auth import can
from adhocracy.lib.unicode import UnicodeDictReader


FORBIDDEN_NAMES = ["www", "static", "mail", "edit", "create", "settings",
                   "join", "leave", "control", "test", "support", "page",
                   "proposal", "wiki", "blog", "proposals", "admin", "dl",
                   "downloads", "stats", "branch", "merge", "pull", "push",
                   "hg", "git", "adhocracy", "user", "openid", "auth", "watch",
                   "poll", "delegation", "event", "comment", "root", "search",
                   "tag", "svn", "trac", "lists", "list", "new", "update",
                   "variant", "provision", "untag", "code", "sso", "velruse"]


VALIDUSER = re.compile(r"^[a-zA-Z0-9_\-]{3,255}$")
VALIDVARIANT = re.compile(r"^[\w\-_ ]{1,255}$", re.U)
TIME = re.compile(r"\d{1,2}.\d{1,2}.\d{4}")


class UniqueUsername(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import meta, User
        if not value or not isinstance(value, basestring):
            raise formencode.Invalid(
                _('No username is given'),
                value, state)
        if len(value.strip()) < 3:
            raise formencode.Invalid(
                _('Username is too short'),
                value, state)
        if not VALIDUSER.match(value) or value in FORBIDDEN_NAMES:
            raise formencode.Invalid(
                _('The username is invalid'),
                value, state)
        if meta.Session.query(User.user_name).filter(
            func.lower(User.user_name) == value.lower()
        ).count():
            raise formencode.Invalid(
                _('That username already exists'),
                value, state)
        return value


class UniqueEmail(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import User
        if User.all_q()\
                .filter(func.lower(User.email) == value.lower()).count():
            raise formencode.Invalid(
                _('That email is already registered'),
                value, state)
        return value


class UniqueOtherEmail(formencode.FancyValidator):
    """
    Check if email is unused or belongs to the current user.
    """
    def _to_python(self, value, state):
        if (c.user is not None and c.user.email is not None
           and c.user.email.lower() == value.lower()):
            return value
        from adhocracy.model import User
        if User.all_q()\
                .filter(func.lower(User.email) == value.lower()).count():
            raise formencode.Invalid(
                _('That email is already used by another account'),
                value, state)
        return value


class ValidLocale(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy import i18n
        if value in i18n.LOCALE_STRINGS:
            return value
        else:
            raise formencode.Invalid(_('Invalid locale choice'), value, state)


class ValidDate(formencode.FancyValidator):
    def _to_python(self, value, state):
        if not TIME.match(value):
            raise formencode.Invalid(
                _('Invalid date, expecting DD.MM.YYYY'),
                value, state)
        try:
            return datetime.strptime(value, "%d.%m.%Y")
        except ValueError:
            raise formencode.Invalid(
                _('Invalid date, expecting DD.MM.YYYY'),
                value, state)
        return value


class ValidHTMLColor(formencode.validators.Regex):

    regex = r'^#[0-9a-fA-F]{1,6}'

    def to_python(self, value, state):
        try:
            super(ValidHTMLColor, self).to_python(value, state)
        except formencode.Invalid:
            raise formencode.Invalid(
                _("Please enter a html color code like '#f0f0f0'. "
                  "'%(value)' is not a valid color code."), value, state)
        return value


class UniqueInstanceKey(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Instance
        if not value:
            raise formencode.Invalid(
                _('No instance key is given'),
                value, state)
        if not Instance.INSTANCE_KEY.match(value) or value in FORBIDDEN_NAMES:
            raise formencode.Invalid(
                _('The instance key is invalid'),
                value, state)
        if Instance.find(value):
            raise formencode.Invalid(
                _('An instance with that key already exists'),
                value, state)
        return value


class StaticPageKey(formencode.FancyValidator):
    def to_python(self, value, state):
        from adhocracy.lib import staticpage
        if not value:
            raise formencode.Invalid(
                _('No static key is given'),
                value, state)
        if not staticpage.STATICPAGE_KEY.match(value) or value in ['new']:
            raise formencode.Invalid(
                _('The static key is invalid'),
                value, state)
        return value


class ValidDelegateable(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Delegateable
        delegateable = Delegateable.find(value)
        if not delegateable:
            raise formencode.Invalid(
                _("No entity with ID '%s' exists") % value,
                value, state)
        return delegateable


class ValidProposal(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Proposal
        proposal = Proposal.find(value)
        if not proposal:
            raise formencode.Invalid(
                _("No proposal with ID '%s' exists") % value,
                value, state)
        return proposal


class ValidInstanceGroup(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Group
        group = Group.by_code(value)
        if not group:
            raise formencode.Invalid(
                _("No group with ID '%s' exists") % value,
                value, state)
        if not group.is_instance_group():
            raise formencode.Invalid(
                _("Group '%s' is no instance group") % group.code,
                value, state)
        return group


class ContainsChar(formencode.validators.Regex):

    regex = r"[a-zA-Z]"

    def to_python(self, value, state):
        try:
            super(ContainsChar, self).to_python(value, state)
        except formencode.Invalid:
            raise formencode.Invalid(_("At least one character is required"),
                                     value, state)
        return value


class ValidBadgeInstance(formencode.FancyValidator):

    def _to_python(self, value, state):
        from adhocracy.model import Instance
        if can.badge.manage_global() or can.badge.edit_global():
            if value:
                instance = Instance.find(value)
                if instance is None:
                    raise AssertionError("Could not find instance %s" % value)
                return instance
            return None
        elif can.badge.manage_instance() or can.badge.edit_instance():
            instance = Instance.find(value)
            if instance is not None and instance == c.instance:
                return instance
        raise formencode.Invalid(
            _("You're not allowed to edit global badges"),
            value, state)


class ValidUserBadge(formencode.FancyValidator):

    def _to_python(self, value, state):
        from adhocracy.model import UserBadge
        badge = UserBadge.by_id(value, instance_filter=False)
        if badge is None or badge.instance not in [None, c.instance]:
            raise formencode.Invalid(
                _("No Badge ID '%s' exists") % value,
                value, state)
        return badge


class ValidUserBadges(formencode.FancyValidator):
    """ Check for a set of user badges, inputted by ID """

    accept_iterator = True

    def __init__(self, not_empty=False):
        super(formencode.FancyValidator, self).__init__()
        self.not_empty = not_empty
        if not not_empty:
            self.if_missing = []

    def _to_python(self, value, state):
        from adhocracy.model import UserBadge

        if value is None:
            if self.not_empty:
                raise formencode.Invalid(_('No badges selected'), value, state)

            return []

        if isinstance(value, (str, unicode)):
            value = [value]

        if len(value) != len(set(value)):
            raise formencode.Invalid(
                _("Duplicates in input set of user badge IDs"),
                value, state)

        if self.not_empty and not value:
            raise formencode.Invalid(_('No badges selected'), value, state)

        badges = UserBadge.findall_by_ids(value)
        if len(badges) != len(value):
            missing = set(value).difference(b.id for b in badges)
            raise formencode.Invalid(
                _("Could not find badges %s") % ','.join(map(str, missing)),
                value, state)
        return badges


class ValidUserBadgeNames(formencode.FancyValidator):

    def __init__(self, instance_filter=True, **kwargs):
        super(formencode.FancyValidator, self).__init__(**kwargs)
        self.instance_filter = instance_filter

    def _to_python(self, value, state):
        from adhocracy.model import UserBadge

        if value is None or value == '':
            return []

        labels = [l.strip() for l in value.split(',')]

        if len(labels) != len(set(labels)):
            raise formencode.Invalid(
                _("Duplicates in input set of user badge labels"),
                value, state)

        badges = set()
        missing = set()

        for label in labels:
            badge = UserBadge.find(label, instance_filter=self.instance_filter)
            if badge is None:
                missing.add(label)
            else:
                badges.add(badge)

        if missing:
            raise formencode.Invalid(
                _("Could not find badges %s") % ','.join(missing),
                value, state)
        else:
            return badges


class ValidInstanceBadge(formencode.FancyValidator):

    def _to_python(self, value, state):
        from adhocracy.model import InstanceBadge
        try:
            value = int(value)
        except ValueError:
            pass
        badge = InstanceBadge.by_id(value, instance_filter=False)
        if badge is None or badge.instance not in [None, c.instance]:
            raise formencode.Invalid(
                _("No Badge ID '%s' exists") % value,
                value, state)
        return badge


class ValidDelegateableBadge(formencode.FancyValidator):

    def _to_python(self, value, state):
        from adhocracy.model import DelegateableBadge
        try:
            value = int(value)
        except:
            pass
        badge = DelegateableBadge.by_id(value, instance_filter=False)
        if badge is None or badge.instance not in [None, c.instance]:
            raise formencode.Invalid(
                _("No Badge ID '%s' exists") % value,
                value, state)
        return badge


class ValidThumbnailBadge(formencode.FancyValidator):

    def _to_python(self, value, state):
        from adhocracy.model import ThumbnailBadge
        try:
            value = int(value)
        except:
            pass
        badge = ThumbnailBadge.by_id(value, instance_filter=False)
        if badge is None or badge.instance not in [None, c.instance]:
            raise formencode.Invalid(
                _("No Badge ID '%s' exists") % value,
                value, state)
        return badge


class ValidCategoryBadge(formencode.FancyValidator):

    def _to_python(self, value, state):
        from adhocracy.model import CategoryBadge
        try:
            value = int(value)
        except:
            pass
        badge = CategoryBadge.by_id(value, instance_filter=False)
        if badge is None:
            raise formencode.Invalid(
                _("No Badge ID '%s' exists") % value,
                value, state)
        if badge.instance is None and c.instance is not None\
           and c.instance.hide_global_categories:
            raise formencode.Invalid(
                _("Cannot use global category %s in this instance") % value,
                value, state)
        if badge.instance not in [None, c.instance]:
            raise formencode.Invalid(
                _("Badge with ID '%s' not valid in this instance") % value,
                value, state)
        return badge


class ValidParentCategory(formencode.validators.FormValidator):

    def validate_python(self, field_dict, state):
        if (field_dict['parent'] is not None and
           field_dict['parent'].instance is not field_dict['instance']):
            msg = _("Parent and child category instance have to match")
            raise formencode.Invalid(
                msg, field_dict, state,
                error_dict={'parent': msg}
            )
        else:
            return field_dict


class ValidateNoCycle(formencode.validators.FormValidator):

    def validate_python(self, field_dict, state):

        def parent_okay(category):
            if category is None:
                # no cycle
                return True
            elif category == field_dict['id']:
                # cycle
                return False
            else:
                return parent_okay(category.parent)

        if parent_okay(field_dict['parent']):
            return field_dict
        else:
            msg = _('You shall not create cycles!')
            raise formencode.Invalid(
                msg, field_dict, state,
                error_dict={'parent': msg}
            )


class MaybeMilestone(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Milestone
        try:
            return Milestone.find(value)
        except Exception:
            return None


class ValidRevision(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Revision
        revision = Revision.find(value)
        if not revision:
            raise formencode.Invalid(
                _("No revision with ID '%s' exists") % value,
                value, state)
        return revision


class ValidComment(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Comment
        comment = Comment.find(value)
        if not comment:
            raise formencode.Invalid(
                _("No comment with ID '%s' exists") % value,
                value, state)
        return comment


class ValidWatch(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Watch
        watch = Watch.by_id(value)
        if not watch:
            raise formencode.Invalid(
                _("No watchlist entry with ID '%s' exists") % value,
                value, state)
        return watch


class ValidRef(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import refs
        try:
            entity = refs.from_url(value)
            if not entity:
                raise TypeError()
            return entity
        except:
            raise formencode.Invalid(_("Invalid reference"), value, state)


class ExistingUserName(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import User
        user = User.find(value)
        if not user:
            raise formencode.Invalid(
                _("No user with the user name '%s' exists") % value,
                value, state)
        return user


class ValidTagging(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Tagging
        tagging = Tagging.find(value)
        if not tagging:
            raise formencode.Invalid(
                _("No tagging with ID '%s' exists") % value,
                value, state)
        return tagging


class ValidTag(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Tag
        tag = Tag.find(value)
        if not tag:
            raise formencode.Invalid(
                _("No tag with ID '%s' exists") % value,
                value, state)
        return tag


class ValidText(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Text
        text = Text.find(value)
        if not text:
            raise formencode.Invalid(
                _("No text with ID '%s' exists") % value,
                value, state)
        return text


class ValidPage(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Page
        page = Page.find(value)
        if not page:
            raise formencode.Invalid(_("No page '%s' exists") % value,
                                     value, state)
        return page


class ValidPageFunction(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.model import Page
        function = value.lower().strip()
        if function not in Page.FUNCTIONS:
            raise formencode.Invalid(_("Invalid page function: %s") % value,
                                     value, state)
        return function


class VariantName(formencode.FancyValidator):
    def _to_python(self, value, state):
        from adhocracy.lib.text import variant_normalize
        var = variant_normalize(value)
        if not var or len(var) < 2:
            raise formencode.Invalid(_("No name is given."),
                                     value, state)

        if (var.lower() in FORBIDDEN_NAMES or not
                VALIDVARIANT.match(var.lower())):
            raise formencode.Invalid(_("Invalid name: %s") % value,
                                     value, state)
        try:
            int(var)
            raise formencode.Invalid(
                _("Name cannot be purely numeric: %s") % value,
                value, state)
        except:
            return var


class ValidTitle(formencode.validators.String):

    def __init__(self, unused_label=False):
        super(ValidTitle, self).__init__(min=3, max=254, not_empty=True)
        self.unused_label = unused_label

    def _to_python(self, value, state):
        from adhocracy.model import Page
        from adhocracy.lib.text import title2alias
        value = super(ValidTitle, self)._to_python(value, state)

        if self.unused_label and not Page.unused_label(title2alias(value)):
            raise formencode.Invalid(
                _("An entry with this title already exists"), value, state)

        if not value or len(value) < 2:
            raise formencode.Invalid(_("No page name is given."), value, state)

        if value.lower() in FORBIDDEN_NAMES:
            raise formencode.Invalid(_("Invalid page name: %s") % value,
                                     value, state)

        try:
            int(value)
            raise formencode.Invalid(
                _("Variant name cannot be purely numeric: %s") % value,
                value, state)
        except:
            return value


class ValidProposalTitle(ValidTitle):

    def validate_python(self, value, state):
        value = super(ValidProposalTitle, self)._to_python(value, state)

        # must be a valid variant name
        try:
            variant_name_validator = VariantName()
            variant_name_validator._to_python(value, state)
        except formencode.Invalid as e:
            raise formencode.Invalid(e.msg, value, state)

        return value


class ProposalMessageNoRecipientGroup(formencode.validators.FormValidator):

    def validate_python(self, field_dict, state):
        if (not field_dict.get('creators', False) and
                not field_dict.get('supporters', False) and
                not field_dict.get('opponents', False)):
            msg = _(u"Please select at least one recipient group")
            raise formencode.Invalid(
                msg, field_dict, state,
                error_dict={'creators': msg}
            )

USER_NAME = 'user_name'
DISPLAY_NAME = 'display_name'
EMAIL = 'email'
USER_BADGES = 'user_badges'
USERNAME_VALIDATOR = formencode.All(
    formencode.validators.PlainText(not_empty=True),
    UniqueUsername(),
    ContainsChar())
EMAIL_VALIDATOR = formencode.All(formencode.validators.Email(not_empty=True),
                                 UniqueEmail())


class UsersCSV(formencode.FancyValidator):

    def to_python(self, value, state=None):
        if state is None:
            global_admin = False
        else:
            global_admin = getattr(state, u'global_admin', False)
        fieldnames = [USER_NAME, DISPLAY_NAME, EMAIL, USER_BADGES]
        errors = []
        items = []
        self.usernames = {}
        self.emails = {}
        self.duplicates = False
        value = value.encode('utf-8')
        reader = UnicodeDictReader(StringIO(value), fieldnames=fieldnames)
        try:
            for item in reader:
                error_list, cleaned_item = self._check_item(
                    item, reader.line_num, global_admin=global_admin)
                if error_list:
                    errors.append((reader.line_num, error_list))
                if not errors:
                    items.append(cleaned_item)
        except csv.Error, E:
            line_content = value.split('\n')[reader.line_num]
            msg = _('Error "%(error)s" while reading line '
                    '<pre><i>%(line_content)s</i></pre>') % dict(
                line_content=line_content,
                error=str(E))
            errors.append((reader.line_num + 1, [msg]))
        if errors or self.duplicates:
            error_msg = _('The following errors occured while reading '
                          'the list of users: <br />%s')
            line_error_messages = []
            for (line, messages) in errors:
                line_error_messages.append(
                    _('Line %s: %s') % (line, ', '.join(messages)))

            # Insert messages for duplicate emails and usernames
            self._insert_duplicate_messages(
                line_error_messages,
                self.emails,
                _('Email %s is used multiple times'))
            self._insert_duplicate_messages(
                line_error_messages,
                self.usernames,
                _('Username %s is used multiple times'))
            error_msg = error_msg % ('<br />'.join(line_error_messages))
            raise formencode.Invalid(literal(error_msg), value, state)
        else:
            return items

    def _insert_duplicate_messages(self, line_error_messages, duplicate_dict,
                                   msg_template):
        for (value, lines) in duplicate_dict.items():
            if len(lines) > 1:
                lines = [str(line) for line in lines]
                line_error_messages.append(
                    _('Lines %s: %s') % (
                        ', '.join(lines),
                        msg_template % value))

    def _check_item(self, item, line, global_admin=False):
        error_list = []
        user_name = item.get(USER_NAME, '').strip()
        email = item.get(EMAIL, '')
        badges = item.get(USER_BADGES, '')
        if email is not None:
            email = email.strip()
        validated = {}
        USERBADGE_VALIDATOR = ValidUserBadgeNames(
            not_empty=False, if_empty=[],
            instance_filter=(not global_admin))
        for (validator, value) in ((USERNAME_VALIDATOR, user_name),
                                   (EMAIL_VALIDATOR, email),
                                   (USERBADGE_VALIDATOR, badges),
                                   ):
            try:
                validated[validator] = validator.to_python(value, None)
            except formencode.Invalid, E:
                error_list.append(u'%s (%s)' % (E.msg, value))
        emails = self.emails.setdefault(email, [])
        emails.append(line)
        usernames = self.usernames.setdefault(user_name.strip(), [])
        usernames.append(line)
        if len(emails) > 1 or len(usernames) > 1:
            self.duplicates = True
        cleaned_item = item.copy()
        cleaned_item.update({USER_NAME: user_name,
                             EMAIL: email,
                             USER_BADGES: validated.get(validator),
                             })
        return error_list, cleaned_item


class ContainsEMailPlaceholders(formencode.FancyValidator):

    def _to_python(self, value, state):
        required = ['{url}', '{user_name}', '{password}']
        missing = []
        for s in required:
            if s not in value:
                missing.append(s)
        if missing != []:
            raise formencode.Invalid(
                _('You need to insert the following placeholders into '
                  'the email text so we can insert enough information '
                  'for the user: %s') % ', '.join(missing),
                value, state)
        return value


class ValidImageFileUpload(formencode.FancyValidator):

    max_size = 5 * 1024 * 1024

    def _to_python(self, value, state):
        payload = value.file.read(self.max_size + 1)
        if len(payload) > 0:
            try:
                value.file.seek(0)
                im = Image.open(value.file)
                value.file.seek(0)
                del im
            except IOError:
                raise formencode.Invalid(_("This is not a valid image file"),
                                         value, state)
        return value


class ValidFileUpload(formencode.FancyValidator):

    max_size = 1024 * 1024

    def _to_python(self, value, state):
        payload = value.file.read(self.max_size)
        value.file.seek(0)
        if len(payload) == self.max_size:
            raise formencode.Invalid(_("The file is too big (>1MB)"),
                                     value, state)
        return value


class MessageableInstances(formencode.FancyValidator):
    """
    Check if the given instance can be mass messaged by the current user.
    """

    accept_iterator = True

    def _to_python(self, value, state):

        if not value:
            raise formencode.Invalid(
                _('Please select at least one instance'), value, state)

        if not isinstance(value, list):
            value = [value]

        from adhocracy.controllers.massmessage import MassmessageController
        allowed_ids = (i.id for i in
                       MassmessageController._get_allowed_instances(c.user))
        if any(int(i) not in allowed_ids for i in value):
            raise formencode.Invalid(
                _('Disallowed instance selected'), value, state)

        return value


class ProposalSortOrder(formencode.validators.OneOf):

    def __init__(self, **kwargs):
        from adhocracy.lib.pager import PROPOSAL_SORTS
        super(ProposalSortOrder, self).__init__(
            [''] +
            [
                v.value
                for g in PROPOSAL_SORTS.by_group.values()
                for v in g
            ])

    def _to_python(self, value, state):
        return value if value else None


class OptionalAttributes(formencode.validators.FormValidator):

    def validate_python(self, field_dict, state):

        optional_attributes = config.get_optional_user_attributes()
        error_dict = {}
        for (key, type_, converter, label, allowed) in optional_attributes:

            if key not in field_dict:
                continue

            value = field_dict[key]

            if value and not isinstance(value, type_):
                try:
                    value = converter(value)
                except:
                    error_dict[key] = _(u'Invalid value')
                    continue

            field_dict[key] = value

            if allowed is not None:
                if value not in [a['value'] for a in allowed]:
                    error_dict[key] = _(u'Invalid choice')
                    continue

        if error_dict:
            raise formencode.Invalid(u'_', field_dict, state,
                                     error_dict=error_dict)

        return field_dict


class NotAllFalse(formencode.validators.FormValidator):

    def __init__(self, keys, msg, *args, **kwargs):
        super(NotAllFalse, self).__init__(*args, **kwargs)
        self.keys = keys
        self.msg = msg

    def validate_python(self, field_dict, state):

        if all(not field_dict.get(key, False) for key in self.keys):
            raise formencode.Invalid(
                self.msg, field_dict, state,
                error_dict={self.keys[0]: self.msg}
            )


class CaptchasDotNetCaptcha(formencode.FancyValidator):

    def __init__(self, session, captchasdotnet):
        super(formencode.FancyValidator, self).__init__(not_empty=True)
        self.session = session
        self.captchasdotnet = captchasdotnet

    def _to_python(self, value, state):
        random = self.session.get('captchasdotnet_random')
        cap = self.captchasdotnet.get_captchasdotnet()
        if not cap.verify(value, random):
            raise formencode.Invalid(_(u'Incorrect. Try again.'),
                                     value, state)


class TermsCheckValidator(formencode.validators.FancyValidator):
    field_name = 'accept_terms'

    def validate_python(self, field_dict, state):
        if self.field_name not in field_dict:
            msg = _(u'Please accept the terms of service')
            raise formencode.Invalid(
                msg, field_dict, state,
                error_dict={self.field_name: msg}
            )
        else:
            return field_dict

########NEW FILE########
__FILENAME__ = extra_strings
from pylons.i18n import _


def strings_not_usually_extracted_by_babel():
    x = _("Voter")
    x = _("Observer")
    x = _("Supervisor")
    x = _("Administrator")
    x = _("Default")
    x = _("Advisor")
    x = _("Draft")
    x = _("Polling")
    x = _("Adopted")
    return x

########NEW FILE########
__FILENAME__ = app_globals
"""The application's Globals object"""
import logging

import memcache


log = logging.getLogger(__name__)


class Globals(object):

    """Globals acts as a container for objects available throughout the
    life of the application

    """

    def __init__(self, config):
        """One instance of Globals is created during application
        initialization and is available during requests via the
        'app_globals' variable

        """
        if 'memcached.server' in config:
            self.cache = memcache.Client([config['memcached.server']])
            log.debug("Memcache set up")
            log.debug("Flushing cache")
            self.cache.flush_all()
        else:
            log.warn("Skipped memcache, no results caching will take place.")
            self.cache = None

        if 'adhocracy.instance' in config:
            self.single_instance = config.get('adhocracy.instance')
        else:
            self.single_instance = None

########NEW FILE########
__FILENAME__ = authentication
import logging

from repoze.who.plugins.basicauth import BasicAuthPlugin
from repoze.who.plugins.sa import SQLAlchemyAuthenticatorPlugin
from repoze.who.plugins.sa import SQLAlchemyUserMDPlugin
from repoze.who.plugins.friendlyform import FriendlyFormPlugin

from repoze.what.middleware import setup_auth as setup_what
from repoze.what.plugins.sql.adapters import SqlPermissionsAdapter

import adhocracy.model as model
from . import welcome
from authorization import InstanceGroupSourceAdapter
from instance_auth_tkt import InstanceAuthTktCookiePlugin

from sqlalchemy.orm.exc import NoResultFound, MultipleResultsFound
from pylons import config
from webob import Request

log = logging.getLogger(__name__)


def allowed_login_types(config=config):
    login = config.get('adhocracy.login_type',
                       'openid,username+password,email+password')
    login = login.split(',')
    return login


class _EmailBaseSQLAlchemyPlugin(object):
    default_translations = {
        'user_name': 'user_name',
        'email': 'email',
        'validate_password': 'validate_password'
    }

    def get_user(self, login):
        login_configuration = allowed_login_types()
        allow_name = 'username+password' in login_configuration
        allow_email = 'email+password' in login_configuration

        if allow_name:
            if allow_email:
                login_type = u'email' if u'@' in login else u'user_name'
            else:
                login_type = u'user_name'
        else:
            if allow_email:
                login_type = u'email'
            else:
                return None

        login_attr = getattr(self.user_class, self.translations[login_type])
        query = self.dbsession.query(self.user_class)
        query = query.filter(login_attr == login)

        try:
            return query.one()
        except (NoResultFound, MultipleResultsFound):
            # As recommended in the docs for repoze.who, it's important to
            # verify that there's only _one_ matching userid.
            return None


class EmailSQLAlchemyAuthenticatorPlugin(_EmailBaseSQLAlchemyPlugin,
                                         SQLAlchemyAuthenticatorPlugin):

    def authenticate(self, environ, identity):
        if not ("login" in identity and "password" in identity):
            return None

        user = self.get_user(identity['login'])

        if user:
            validator = getattr(user, self.translations['validate_password'])
            if validator(identity['password']):
                return user.user_name


class EmailSQLAlchemyUserMDPlugin(_EmailBaseSQLAlchemyPlugin,
                                  SQLAlchemyUserMDPlugin):
    pass


class AlternateLoginFriendlyFormPlugin(FriendlyFormPlugin):
    def __init__(self, get_user, *args, **kwargs):
        self._get_user = get_user
        super(AlternateLoginFriendlyFormPlugin, self).__init__(*args, **kwargs)

    def identify(self, environ):
        if environ['PATH_INFO'] == self.login_handler_path:
            request = Request(environ, charset=self.charset)
            form = dict(request.POST)
            if form.get('have_password') == 'false':
                environ['PATH_INFO'] = '/user/nopassword'
                login = form.get('login')
                environ['_adhocracy_nopassword_user'] = self._get_user(login)
                return None

        return super(AlternateLoginFriendlyFormPlugin, self).identify(environ)


def setup_auth(app, config):
    groupadapter = InstanceGroupSourceAdapter()
    # groupadapter.translations.update({'sections': 'groups'})
    permissionadapter = SqlPermissionsAdapter(model.Permission,
                                              model.Group,
                                              model.meta.Session)
    # permissionadapter.translations.update(permission_translations)

    group_adapters = {'sql_auth': groupadapter}
    permission_adapters = {'sql_auth': permissionadapter}

    basicauth = BasicAuthPlugin('Adhocracy HTTP Authentication')
    auth_tkt = InstanceAuthTktCookiePlugin(
        config,
        config.get('adhocracy.auth.secret', config['beaker.session.secret']),
        cookie_name='adhocracy_login', timeout=86400 * 2,
        reissue_time=3600,
        secure=config.get('adhocracy.protocol', 'http') == 'https'
    )

    sqlauth = EmailSQLAlchemyAuthenticatorPlugin(model.User,
                                                 model.meta.Session)
    sql_user_md = SQLAlchemyUserMDPlugin(model.User, model.meta.Session)

    login_urls = [
        '/login',
        '/perform_login',
        '/post_login',
        '/logout',
        '/post_logout',
    ]
    login_options = dict(
        login_counter_name='_login_tries',
        rememberer_name='auth_tkt',
        charset='utf-8',
    )
    if config.get('adhocracy.login_style') == 'alternate':
        form = AlternateLoginFriendlyFormPlugin(sqlauth.get_user,
                                                *login_urls, **login_options)
    else:
        form = FriendlyFormPlugin(*login_urls, **login_options)

    identifiers = [('form', form),
                   ('basicauth', basicauth),
                   ('auth_tkt', auth_tkt)]
    authenticators = [('sqlauth', sqlauth), ('auth_tkt', auth_tkt)]
    challengers = [('form', form), ('basicauth', basicauth)]
    mdproviders = [('sql_user_md', sql_user_md)]

    welcome.setup_auth(config, identifiers, authenticators)

    log_stream = None
    # log_stream = sys.stdout

    # If a webserver already sets a HTTP_REMOTE_USER environment variable,
    # repoze.who merely acts as a pass through and doesn't set up the proper
    # environment (e.g. environ['repoze.who.api'] is missing).
    #
    # This happens for example in the case of Shibboleth based authentication -
    # we weren't able to prevent mod_shibboleth from setting the header.
    # Therefore the remote user key to look for is not set to HTTP_REMOTE_USER,
    # but to the non-existing DONT_USE_HTTP_REMOTE_USER environment variable.

    REMOTE_USER_KEY = 'DONT_USE_HTTP_REMOTE_USER'

    return setup_what(app, group_adapters, permission_adapters,
                      identifiers=identifiers,
                      authenticators=authenticators,
                      challengers=challengers,
                      mdproviders=mdproviders,
                      log_stream=log_stream,
                      log_level=logging.DEBUG,
                      # kwargs passed to repoze.who.plugins.testutils:
                      skip_authentication=config.get('skip_authentication'),
                      remote_user_key=REMOTE_USER_KEY)

########NEW FILE########
__FILENAME__ = authorization
import logging

from pylons import tmpl_context as c
from pylons import request

from sqlalchemy import or_
from sqlalchemy.orm import eagerload
from sqlalchemy.orm.exc import NoResultFound

from repoze.what.predicates import has_permission as what_has_permission
from repoze.what.adapters import SourceError
from repoze.what.plugins.sql.adapters import SqlGroupsAdapter

from adhocracy import config
import adhocracy.model as model


log = logging.getLogger(__name__)


NOT_LOGGED_IN = 'not_logged_in'


class InstanceGroupSourceAdapter(SqlGroupsAdapter):

    def __init__(self, *args, **kwargs):
        super(InstanceGroupSourceAdapter, self).__init__(model.Group,
                                                         model.User,
                                                         model.meta.Session)
        self.is_writable = False

    def _get_section_items(self, section):
        q = model.meta.Session.query(model.User.user_name)
        q = q.join(model.Membership)
        q = q.join(model.Group)
        q = q.filter(model.Group.code == section)
        q = q.filter(
            or_(model.Membership.instance == None,  # noqa
                model.Membership.instance == model.filter.get_instance()))
        return q.all()

    def _find_sections(self, credentials):
        sections = super(InstanceGroupSourceAdapter,
                         self)._find_sections(credentials)
        sections.add(u"Anonymous")
        return sections

    def _get_item_as_row(self, item_name):
        q = model.meta.Session.query(model.User)
        q = q.filter(model.User.user_name == unicode(item_name))
        q = q.options(eagerload(model.User.memberships))

        try:
            return q.one()
        except NoResultFound, e:
            log.exception(e)
            raise SourceError("No such user: %s" % item_name)


class has_permission(what_has_permission):
    """
    This modified version of ``repoze.what``'s ``has_permission`` will
    apply ``Anonymous`` rights to any user making requests. This allows
    to call ``has_permission`` on methods even when they are not protected,
    thus making the authorization system more configurable.
    """

    def evaluate(self, environ, credentials):
        if c.user:
            super(has_permission, self).evaluate(environ, credentials)
        else:
            if environ.get('anonymous_permissions') is None:
                anon_group = model.Group.by_code(model.Group.CODE_ANONYMOUS)
                environ['anonymous_permissions'] = [p.permission_name for p in
                                                    anon_group.permissions]
            if self.permission_name not in environ['anonymous_permissions']:
                self.unmet()


class has_default_permission(what_has_permission):
    """
    Checks whether a member of the default group of the given instance has the
    given permission.
    """

    def evaluate(self, environ, credentials):
        if environ.get('default_permissions') is None:
            if c.instance is not None:
                default_group = c.instance.default_group
            else:
                default = model.Group.INSTANCE_DEFAULT
                default_group = model.Group.by_code(default)
            environ['default_permissions'] = [p.permission_name for p in
                                              default_group.permissions]
        if self.permission_name not in environ['default_permissions']:
            self.unmet()


def has(permission):
    # return permission in request.environ.get('repoze.what.credentials',
    #                                          {}).get('permissions', [])
    p = has_permission(permission)
    return p.is_met(request.environ)


class AuthCheck(object):
    """
    AuthCheck collects reasons for authorisation refusals in two sets:
    ``permission_refusals`` and ``other_refusals``. It evaluates to True in
    case authorisation is granted, otherwise False.
    """

    # IDEA: Collect fulfilled authorisation checks as well

    def __init__(self, method):
        self.method = method
        self.permission_refusals = set()
        self.other_refusals = set()
        self.need_valid_email = False

    def __repr__(self):
        return 'AuthCheck for %s' % (self.method)

    def __nonzero__(self):
        return not (self.permission_refusals or self.other_refusals
                    or self.need_valid_email)

    def perm(self, permission):
        """
        Convenience function performing a permission check, which adds the
        permission to ``self.permission_refusal``.
        """
        if not has(permission):
            self.permission_refusals.add(permission)

    def other(self, label, value):
        """
        Convenience function, which adds a refusal label to
        ``self.other_refusals`` in case the given value is ``True``.
        """
        if value is True:
            self.other_refusals.add(label)

    def readonly(self):
        if config.get_bool(u'adhocracy.readonly'):
            e = config.get_bool(u'adhocracy.readonly.global_admin_exception')
            if not (e and has(u'global.admin')):
                self.other_refusals.add(u'readonly')

    def valid_email(self):
        if (c.instance is not None
                and c.instance.requires_valid_email()
                and c.user is not None
                and not c.user.is_email_activated()):
            self.need_valid_email = True

    def permission_missing(self):
        """ Determines whether a permission is missing. """
        return len(self.permission_refusals) > 0

    def need_login(self):
        """
        Login is needed in case a permission refusal exists and the user is
        not logged in.
        """
        return c.user is None and (self.permission_missing() or
                                   NOT_LOGGED_IN in self.other_refusals)

    def _propose_join_or_login(self):
        """
        Only propose to join or login if there are only permission problems
        and if they would be resolved if the user joined or logged in.
        """
        return (self.permission_refusals
                and (not self.other_refusals or
                     (len(self.other_refusals) == 1
                      and NOT_LOGGED_IN in self.other_refusals))
                and all(has_default_permission(perm).is_met(request.environ)
                        for perm in self.permission_refusals))

    def propose_login(self):
        """
        Login is proposed if the user isn't logged in or hasn't joined
        c.instance, but a registered user with default instance permissions
        would be able to perform the action.
        """
        return c.user is None and self._propose_join_or_login()

    def propose_join(self):
        """
        Login is proposed if the user is logged in, but not member of the
        instance and can therefore not perform the requested action.
        """
        return (c.user is not None
                and not c.user.is_member(c.instance)
                and self._propose_join_or_login())

    def propose_validate_email(self):
        """
        Email validation is proposed if the user is logged in, but doesn't
        have a valid email address.
        """
        return (not self.permission_refusals
                and not self.other_refusals
                and self.need_valid_email)

########NEW FILE########
__FILENAME__ = badge
def edit_instance(check):
    check.readonly()
    check.valid_email()
    check.perm('badge.edit_instance')


def edit_global(check):
    check.readonly()
    check.valid_email()
    check.perm('badge.edit_global')


def edit(check, b):
    if b.instance is None:
        edit_global(check)
    else:
        edit_instance(check)


def manage_instance(check):
    check.readonly()
    check.valid_email()
    check.perm('badge.manage_instance')


def manage_global(check):
    check.readonly()
    check.valid_email()
    check.perm('badge.manage_global')


def manage(check, b):
    if b.instance is None:
        manage_global(check)
    else:
        manage_instance(check)

########NEW FILE########
__FILENAME__ = comment
from pylons import tmpl_context as c
from authorization import has

import poll


# helper functions

def is_own(co):
    return c.user and co.creator == c.user


# authorisation checks

def index(check):
    check.perm('comment.view')


def show(check, co):
    check.perm('comment.view')
    check.other('comment_is_deleted', co.is_deleted())


def create(check):
    check.readonly()
    check.valid_email()
    check.perm('comment.create')


def create_on(check, topic):
    check.readonly()
    check.valid_email()
    if has('instance.admin'):
        return
    check.other('comment_topic_frozen', topic.is_frozen())
    check.other('comment_topic_instance_frozen', topic.instance.frozen)
    create(check)


def reply(check, parent):
    check.valid_email()
    create_on(check, parent.topic)
    check.other('parent_deleted', parent.is_deleted())


def edit(check, co):
    check.readonly()
    check.valid_email()
    if has('instance.admin'):
        return
    check.other('comment_not_mutable', not co.is_mutable())
    check.other('comment_topic_instance_frozen', co.topic.instance.frozen)
    check.perm('comment.edit')
    show(check, co)
    check.other('comment_is_not_wiki_or_own', not (co.wiki or is_own(co)))


revert = edit


def delete(check, co):
    check.readonly()
    check.valid_email()
    if has('instance.admin'):
        return
    check.other('comment_topic_instance_frozen', co.topic.instance.frozen)
    edit(check, co)
    check.other('comment_is_not_own', not is_own(co))
    check.other('comment_is_edited', co.is_edited())
    check.perm('comment.delete')
    show(check, co)
    check.other('comment_not_mutable', not co.topic.is_mutable())


def rate(check, co):
    check.valid_email()
    check.other('comment_topic_frozen', co.topic.is_frozen())
    check.other('comment_topic_instance_frozen', co.topic.instance.frozen)
    show(check, co)
    check.other('comment_poll_is_none', co.poll is not None)
    poll.vote(check, co.poll)

########NEW FILE########
__FILENAME__ = csrf
"""
XSRF is Cross-Site Request Forgery, where an attacker has a user follow
a link that triggers an action on a site which the user did not
intentionally want to perform (i.e. vote in a certain way). To prevent
this, some actions are only possible if authorized via HTTP or if a
modtoken - a shared SHA1 hash - is included.
"""

import uuid
import logging
from decorator import decorator

from pylons import session, request
from pylons.i18n import _

from repoze.who.plugins.basicauth import BasicAuthPlugin

log = logging.getLogger(__name__)

KEY = "_tok"


ALL_METHODS = ['POST', 'GET', 'PUT', 'DELETE']


def check_csrf(methods=ALL_METHODS):

    method = request.environ.get('REQUEST_METHOD').upper()
    if method in methods:

        identifier = request.environ.get(
            'repoze.who.identity', {}).get('identifier')
        if (identifier is not None and
                isinstance(identifier, BasicAuthPlugin)):
            return
        if request.params.get(KEY) == token_id():
            return

    from adhocracy.lib.templating import ret_abort
    from adhocracy.lib import helpers as h
    msg = '<p>%s</p><a href="%s">%s</a>' % (
        _(u'The requested action could not be performed, because the session '
          'which was active when you visited the previous page has expired.'),
        h.site.current_url(),
        _(u'Back to your current session'))
    ret_abort(msg, code=403)


def RequireInternalRequest(methods=ALL_METHODS):
    """
    CSRF Spoof Filter

    TODO: There is still a scenario in which an attacker opens an adhocracy
    page in an iframe, extracts a valid modtoken via javascript and uses this
    token to execute the request.
    """
    def _decorate(f, *a, **kw):
        check_csrf(methods)
        return f(*a, **kw)
    return decorator(_decorate)


def token_id():
    if KEY not in session:
        session[KEY] = str(uuid.uuid4()).split("-")[-1]
        session.save()
    return session[KEY]


def url_token():
    return "%s=%s" % (KEY, token_id())


def field_token():
    return '<input name="%s" type="hidden" value="%s" />' % (KEY, token_id())

########NEW FILE########
__FILENAME__ = delegation
from pylons import tmpl_context as c
import user
from adhocracy.lib.auth.authorization import NOT_LOGGED_IN


def index(check):
    check.perm('delegation.show')
    check.other('no_instance_allow_delegate', not c.instance.allow_delegate)


def show(check, d):
    check.perm('delegation.show')
    check.other('delegation_revoked', d.is_revoked)
    check.other('no_instance_allow_delegate', not c.instance.allow_delegate)


def create(check, scope=None):
    check.valid_email()
    check.perm('delegation.create')
    user.vote(check)
    check.other('no_instance_allow_delegate', not c.instance.allow_delegate)
    if scope is not None:
        check.other('scope_frozen', scope.is_frozen())


def edit(check, d):
    check.readonly()
    check.valid_email()
    check.other('scope_frozen', d.scope.is_frozen())
    check.other('cannot_edit_delegations', True)


def delete(check, d):
    check.readonly()
    check.valid_email()
    check.perm('delegation.delete')
    show(check, d)
    check.other('no_instance_allow_delegate', not c.instance.allow_delegate)
    check.other(NOT_LOGGED_IN, not c.user)
    check.other('delegation_principal_is_not_user', d.principal != c.user)
    check.other('scope_frozen', d.scope.is_frozen())

########NEW FILE########
__FILENAME__ = instance
from pylons import tmpl_context as c, app_globals as g
from authorization import has
from adhocracy.lib.auth.authorization import NOT_LOGGED_IN


def index(check):
    check.other('is_single_instance', g.single_instance)
    check.perm('instance.index')


def show(check, i):
    check.perm('instance.show')
    check.other('instance_deleted', i.is_deleted())


def create(check):
    check.readonly()
    check.valid_email()
    check.other('is_single_instance', g.single_instance)
    check.perm('instance.create')


def edit_overview(check, i):
    check.readonly()
    check.perm('instance.manage')
    show(check, i)


def edit(check, i):
    check.readonly()
    check.perm('instance.admin')
    edit_overview(check, i)
    show(check, i)

admin = edit


def any_admin(check):
    check.readonly()
    if has('global.admin'):
        return
    check.perm('instance.admin')


def authenticated_edit(check, instance):
    '''
    Edit allowed only in authenticated instances
    '''
    check.other('is_not_authenticated', not instance.is_authenticated)
    edit(check, instance)


def delete(check, i):
    check.readonly()
    check.other('is_single_instance', g.single_instance)
    check.perm('global.admin')
    show(check, i)


def join(check, i):
    check.readonly()
    check.other('instance_frozen', i.frozen)
    show(check, i)
    check.perm('instance.join')
    check.other(NOT_LOGGED_IN, not c.user)
    if c.user:
        check.other('user_is_member', c.user.is_member(i))


def leave(check, i):
    check.readonly()
    check.other('is_single_instance', g.single_instance)
    check.other('instance_frozen', i.frozen)
    show(check, i)
    check.perm('instance.leave')
    check.other('not_logged_in', not c.user)
    if c.user:
        check.other('user_is_no_member', not c.user.is_member(i))
        check.other('user_is_instance_creator', c.user == i.creator)


def message(check, i):
    check.readonly()

    if has('global.message'):
        return
    check.other('is_not_authenticated', not i.is_authenticated)
    check.perm('instance.message')

########NEW FILE########
__FILENAME__ = instance_auth_tkt
from adhocracy.lib.cookie import get_cookies
from repoze.who.plugins.auth_tkt import AuthTktCookiePlugin


class InstanceAuthTktCookiePlugin(AuthTktCookiePlugin):
    def __init__(self, config, *args, **kwargs):
        super(InstanceAuthTktCookiePlugin, self).__init__(*args, **kwargs)
        self.__config = config

    def _get_cookies(self, environ, value, max_age=None):
        return get_cookies({self.cookie_name: value}, config=self.__config,
                           max_age=max_age, secure=self.secure)

########NEW FILE########
__FILENAME__ = message
from pylons import tmpl_context as c
from authorization import has


def show(check, msg):
    check.other('is_not_creator_or_recipient', c.user != msg.creator and
                c.user not in (r.recipient for r in msg.recipients))


def show_recipients(check, msg):
    show(check, msg)
    check.other('is_not_creator', c.user != msg.creator)

########NEW FILE########
__FILENAME__ = milestone
from pylons import tmpl_context as c

from adhocracy.lib.auth.authorization import has


# helper functions

def is_own(m):
    return c.user and m.creator == c.user


# authorisation checks

def index(check):
    check.perm('milestone.show')
    check.other('instance_without_milestones', not c.instance.milestones)


def show(check, m):
    check.perm('milestone.show')
    check.other('instance_without_milestones', not c.instance.milestones)
    check.other('milestone_deleted', m.is_deleted())


def create(check):
    check.readonly()
    check.valid_email()
    check.other('instance_without_milestones', not c.instance.milestones)
    check.perm('milestone.create')


def edit(check, m):
    check.readonly()
    check.valid_email()
    check.other('instance_without_milestones', not c.instance.milestones)
    if has('instance.admin'):
        return
    check.perm('milestone.edit')
    show(check, m)


def delete(check, m):
    check.readonly()
    check.valid_email()
    check.perm('milestone.delete')
    show(check, m)

########NEW FILE########
__FILENAME__ = norm
from pylons import tmpl_context as c
from authorization import has
from adhocracy.model import Text
import page
import variant as _variant

index = page.index
show = page.show


def create(check, variant=Text.HEAD):
    check.valid_email()
    page.create(check)
    check.other('instance_without_norms', not c.instance.use_norms)
    check.other('instance_frozen', c.instance.frozen)


def propose(check):
    check.readonly()
    check.valid_email()
    check.other('instance_without_norms', not c.instance.use_norms)
    if has('instance.admin'):
        return
    check.other('no_instance_allow_propose', not c.instance.allow_propose)
    check.other('instance_frozen', c.instance.frozen)
    check.perm('page.edit')


def edit(check, page, variant=Text.HEAD):
    check.valid_email()
    check.other('page_instance_without_norms', not page.instance.use_norms)
    _variant.edit(check, page, variant)


def delete(check, n):
    check.readonly()
    check.valid_email()
    check.other('norms_cannot_be_deleted', True)

########NEW FILE########
__FILENAME__ = page
from authorization import has


def index(check):
    check.perm('page.show')


def show(check, p):
    check.perm('page.show')
    check.other('page_deleted', p.is_deleted())


def create(check):
    check.readonly()
    check.valid_email()
    check.perm('page.create')


def edit(check, p):
    check.readonly()
    check.valid_email()
    check.other('page_not_mutable', not p.is_mutable())
    if has('instance.admin'):
        return
    check.perm('page.edit')
    show(check, p)


def manage(check, p):
    check.readonly()
    check.valid_email()
    check.perm('instance.admin')


def delete(check, p):
    check.readonly()
    check.valid_email()
    check.other('page_not_mutable', not p.is_mutable())
    check.perm('page.delete')
    show(check, p)


def delete_history(check, p):
    check.readonly()
    check.valid_email()
    check.perm('page.delete_history')

########NEW FILE########
__FILENAME__ = poll
import user


def index(check):
    check.perm('poll.show')


def show(check, p):
    from adhocracy.lib import helpers as h
    check.perm('poll.show')
    check.other('poll_has_ended', p.has_ended())
    check.other('hide_individual_votes', h.poll.hide_individual_votes(p))


def create(check):
    check.readonly()
    check.valid_email()
    check.perm('poll.create')


def edit(check, p):
    check.readonly()
    check.valid_email()
    check.other('polls_can_not_be_edited', True)


def delete(check, p):
    check.readonly()
    check.valid_email()
    check.perm('poll.delete')
    show(check, p)
    check.other('poll_can_not_end', not p.can_end())


def vote(check, p):
    check.readonly()
    check.valid_email()
    check.other('poll_has_ended', p.has_ended())
    check.other('scope_frozen', p.scope.is_frozen())
    check.other('instance_frozen', p.scope.instance.frozen)

    check.other('select_poll_not_mutable',
                (p.action == p.SELECT and p.selection and
                 not p.selection.proposal.is_mutable()))
    user.vote(check)

########NEW FILE########
__FILENAME__ = proposal
from pylons import tmpl_context as c

from adhocracy.lib.auth import poll
from adhocracy.lib.auth.authorization import has


# helper functions

def is_own(p):
    return c.user and p.creator == c.user


# authorisation checks

def index(check):
    check.perm('proposal.show')


def show(check, p):
    check.perm('proposal.show')
    check.other('proposal_deleted', p.is_deleted())


def create(check, instance=None):
    check.readonly()
    check.valid_email()
    if instance is None:
        instance = c.instance
    check.other('user_is_no_member', not c.user or
                not c.user.is_member(c.instance))
    check.other('instance_frozen', instance.frozen)
    check.perm('proposal.create')


def edit(check, p):
    check.readonly()
    check.valid_email()
    if has('instance.admin') or has('global.admin'):
        # Admins can always edit proposals.
        return

    show(check, p)
    check.other('proposal_not_mutable', not p.is_mutable())
    if has('proposal.edit'):
        # having proposal.edit is enough
        return

    check.other('user_is_no_member', not c.user or
                not c.user.is_member(c.instance))
    check.other('proposal_head_not_wiki_or_own',
                not is_own(p) and not p.description.head.wiki)


def edit_badges(check, p):
    check.readonly()
    check.perm('instance.manage')


def delete(check, p):
    check.readonly()
    check.valid_email()
    if has('instance.admin'):
        return
    check.perm('proposal.delete')
    show(check, p)
    check.other('proposal_not_mutable', not p.is_mutable())


def rate(check, p):
    check.readonly()
    check.valid_email()
    check.other('proposal_frozen', p.frozen)
    check.other('instance_frozen', c.instance.frozen)
    show(check, p)
    if p.rate_poll is None:
        check.other('proposal_no_rate_poll', True)
    else:
        poll.vote(check, p.rate_poll)


def adopt(check, p):
    check.valid_email()
    if c.instance.allow_adopt and has('instance.admin'):
        return
    show(check, p)
    poll.create(check)
    check.other('proposal_cannot_adopt', not p.can_adopt())


def message(check, p):
    check.readonly()

    if has('global.message'):
        return
    check.perm('proposal.message')

########NEW FILE########
__FILENAME__ = selection
from authorization import has
import proposal


def index(check, p):
    return proposal.index(check)


def show(check, s):
    check.perm('proposal.show')
    check.other('selection_is_deleted', s.is_deleted())


def create(check, p):
    check.readonly()
    check.valid_email()
    check.other('proposal_not_mutable', not p.is_mutable())
    if has('instance.admin'):
        return
    check.perm('proposal.edit')
    show(check, p)


def edit(check, s):
    check.readonly()
    check.valid_email()
    check.other('selections_can_not_be_edited', False)
    check.other('proposal_not_mutable',
                s.proposal and not s.proposal.is_mutable())


def delete(check, s):
    check.valid_email()
    proposal.delete(check, s.proposal)
    show(check, s)

########NEW FILE########
__FILENAME__ = shibboleth
'''
Implements configuration options for mapping shibboleth attributes to user
data, e.g. badges and display names. Configuration values have to be given in
JSON.

For examples, see docs/development/use_cases/shibboleth_authentication.rst.

'''

import random
from string import ascii_uppercase

from adhocracy.model import meta
from adhocracy.model.user import User


def get_attribute(request, key, default=None):
    """ Shibboleth attributes are UTF-8 encoded """
    value = request.headers.get(key, default)
    if value is None:
        return None
    else:
        return value.decode('utf-8')


def _attribute_equals(request, key, value):
    """
    exact match
    """
    return get_attribute(request, key) == value


def _attribute_contains(request, key, value):
    """
    contains element
    """
    elements = (e.strip() for e in get_attribute(request, key).split(';'))
    return value in elements


def _attribute_contains_substring(request, key, value):
    """
    contains substring
    """
    return value in get_attribute(request, key)


USERBADGE_MAPPERS = {
    'attribute_equals': _attribute_equals,
    'attribute_contains': _attribute_contains,
    'attribute_contains_substring': _attribute_contains_substring,
}


def _full_name(request, name_attr, surname_attr):
    return u"%s %s" % (get_attribute(request, name_attr),
                       get_attribute(request, surname_attr))


def _full_name_random_suffix(request, name_attr, surname_attr):

    letter = lambda: random.choice(ascii_uppercase)

    base = _full_name(request, name_attr, surname_attr)

    display_name = None
    while display_name is None:

        suffix = letter() + letter()
        try_display_name = '%s %s' % (base, suffix)

        if (meta.Session.query(User)
                .filter(User.display_name == try_display_name).first()  # noqa
                is None):
            display_name = try_display_name

    return display_name


DISPLAY_NAME_FUNCTIONS = {
    "full_name": _full_name,
    "full_name_random_suffix": _full_name_random_suffix,
}

########NEW FILE########
__FILENAME__ = tag
from pylons import tmpl_context as c
from authorization import has
from adhocracy.lib.auth.authorization import NOT_LOGGED_IN


def index(check):
    check.perm('tag.show')


def show(check, t):
    check.perm('tag.show')


def create(check):
    check.readonly()
    check.valid_email()
    check.perm('tag.create')


def edit(check, t):
    check.readonly()
    check.valid_email()
    check.perm('tag.edit')
    show(check, t)


def delete(check, t):
    check.readonly()
    check.valid_email()
    if has('instance.admin'):
        return
    check.perm('tag.delete')
    show(check, t)
    check.other(NOT_LOGGED_IN, not c.user)
    check.other('tag_creator_is_not_user', t.creator != c.user)

########NEW FILE########
__FILENAME__ = user
from pylons import tmpl_context as c

from adhocracy import config
from adhocracy.lib.auth.authorization import has
from adhocracy.lib.auth.authorization import NOT_LOGGED_IN


def is_not_demo(check, u):
    if u is not None:
        demo_users = config.get_list('adhocracy.demo_users')
        check.other('demo_user', u.user_name in demo_users)


def index(check):
    check.perm('user.view')


def show(check, u):
    check.perm('user.view')
    check.other('user_deleted', u.is_deleted())


def create(check):
    check.readonly()
    check.other('user_logged_in', c.user is not None)


def edit(check, u):
    check.readonly()
    if has('user.manage'):
        return
    show(check, u)
    check.other('user_not_self', u != c.user)
    check.other(NOT_LOGGED_IN, not c.user)
    is_not_demo(check, c.user)


def manage(check, u=None):
    """ Manage users on installation level """
    check.readonly()
    check.perm('user.manage')


def message(check, u):
    check.readonly()
    check.perm('user.message')
    check.other('user_is_self', u == c.user)
    if c.instance is not None:
        check.other('no_member_in_instance', not u.is_member(c.instance))


def badge(check, u):
    check.readonly()
    check.perm('user.badge')


def supervise(check, u=None):
    """ Supervise users on instance level """
    check.readonly()
    check.other('not_in_instance', not c.instance)
    if u is not None:
        check.other('no_member_in_instance', not u.is_member(c.instance))
    check.other('not_user.manage_or_instance.admin',
                not (has('user.manage') or has('instance.admin')))


def show_dashboard(check, u):
    show(check, u)
    check.other('user_not_self', u != c.user)


show_watchlist = show_dashboard


def delete(check, u):
    edit(check, u)
    allowed = config.get_bool('adhocracy.self_deletion_allowed')
    check.other('self_deletion_allowed', not allowed)


def vote(check):
    check.readonly()
    check.other('vote_prohibited', has('vote.prohibit'))
    check.other('not_in_instance', not c.instance)
    check.other(NOT_LOGGED_IN, not c.user)
    check.perm('vote.cast')

########NEW FILE########
__FILENAME__ = variant
from authorization import has
from adhocracy.model import Text

import page


def edit(check, p, variant):
    check.valid_email()
    check.other('instance_without_norms', not p.instance.use_norms)
    check.other('instance_frozen', p.instance.frozen)
    check.other('variant_is_none', variant is None)
    if has('instance.admin'):
        return
    page.edit(check, p)

    check.other('page_has_no_variants_and_variant_is_not_head',
                not p.has_variants and variant != Text.HEAD)

    if not has('page.edit_head'):
        check.other('page_is_listed_and_variant_is_head',
                    p.function in p.LISTED and variant == Text.HEAD)


def delete(check, p, variant):
    check.valid_email()
    check.other('variant_is_none', variant is None)
    check.other('variant_is_head', variant == Text.HEAD)
    if has('instance.admin'):
        return
    page.delete(check, p)

########NEW FILE########
__FILENAME__ = watch
def index(check):
    check.perm('watch.show')


def show(check, w):
    check.perm('watch.show')
    check.other('watch_is_deleted', w.is_deleted())


def create(check):
    check.readonly()
    check.perm('watch.create')


def delete(check, w):
    check.readonly()
    check.perm('watch.delete')
    show(check, w)

########NEW FILE########
__FILENAME__ = welcome
""" Automatically log in an invited user """

import urlparse
import re

import adhocracy.model as model
from adhocracy.lib.auth.authorization import has

from paste.deploy.converters import asbool
from pylons import config
from repoze.who.interfaces import IAuthenticator, IIdentifier
from webob.exc import HTTPFound
from zope.interface import implements


def welcome_url(user, code):
    from adhocracy.lib.helpers import base_url
    return base_url("/welcome/%s/%s" % (user.user_name, code),
                    absolute=True)


def welcome_enabled(config=config):
    return asbool(config.get('adhocracy.enable_welcome', 'false'))


def can_welcome():
    """ Can the current user set welcome codes? """
    return welcome_enabled() and has('global.admin')


class WelcomeRepozeWho(object):
    implements(IAuthenticator, IIdentifier)

    def __init__(self, config, rememberer_name, prefix='/welcome/'):
        self.config = config
        self.rememberer_name = rememberer_name
        self.url_rex = re.compile(r'^' + re.escape(prefix) +
                                  r'(?P<id>[^/]+)/(?P<code>[^/]+)$')

    def identify(self, environ):
        path_info = environ['PATH_INFO']
        m = self.url_rex.match(path_info)
        if not m:
            return None
        u = model.User.find(m.group('id'))
        if not u:
            return None
        is_correct = False
        if u.welcome_code:
            if u.welcome_code == m.group('code'):
                is_correct = True
        if not is_correct and (
                u.reset_code and u.reset_code.startswith(u'welcome!')):
            correct_code = u.reset_code.partition(u'welcome!')[2]
            if m.group('code') == correct_code:
                # At this point, we're sure the user really wanted to reset her
                # password, so set the actual welcome code.
                u.welcome_code = correct_code
                u.reset_code = None
                model.meta.Session.add(u)
                model.meta.Session.commit()
                is_correct = True
        if not is_correct:
            return None

        qs = urlparse.parse_qs(environ['QUERY_STRING'])
        if 'came_from' in qs and h.site.is_local_url(qs['came_from'][0]):
            redirect_url = qs['came_from'][0]
        else:
            from adhocracy.lib.helpers import base_url
            redirect_url = base_url('/', instance=None, config=self.config)
        environ['repoze.who.application'] = HTTPFound(location=redirect_url)

        return {
            'repoze.who.plugins.welcome.userid': u.user_name,
        }

    def forget(self, environ, identity):
        rememberer = environ['repoze.who.plugins'][self.rememberer_name]
        return rememberer.forget(environ, identity)

    def remember(self, environ, identity):
        rememberer = environ['repoze.who.plugins'][self.rememberer_name]
        return rememberer.remember(environ, identity)

    def authenticate(self, environ, identity):
        userid = identity.get('repoze.who.plugins.welcome.userid')
        if userid is None:
            return None
        identity['repoze.who.userid'] = userid
        return userid


def setup_auth(config, identifiers, authenticators):
    if not welcome_enabled(config):
        return

    welcome_rwho = WelcomeRepozeWho(config, 'auth_tkt')
    identifiers.append(('welcome', welcome_rwho))
    authenticators.append(('welcome', welcome_rwho))

########NEW FILE########
__FILENAME__ = base
"""The base Controller API

Provides the BaseController class for subclassing.
"""
import logging

from pylons.controllers import WSGIController
from pylons import request, tmpl_context as c
from pylons.i18n import _
from sqlalchemy.orm.scoping import ScopedSession

from adhocracy import config
from adhocracy import i18n, model
from adhocracy.lib import helpers as h
from adhocracy.lib.templating import ret_abort

log = logging.getLogger(__name__)


class BaseController(WSGIController):

    # Identifier for what area this controler is used.
    # This is used to set the c.active_subheader_nav variable and
    # to append a controller specific css class to the body tag.
    identifier = 'base'

    def __call__(self, environ, start_response):
        """Invoke the Controller"""

        c.body_css_classes = []
        c.body_css_classes.append('controller-' + self.identifier)

        if self.identifier in ['proposals', 'milestones', 'norms', 'category',
                               'members']:
            c.active_subheader_nav = self.identifier
            c.body_css_classes.append('area-' + self.identifier)

        c.instance = model.instance_filter.get_instance()
        if c.instance is not None:
            c.body_css_classes.append(u'instance-%s' % c.instance.key)
        # setup a global variable to mark the current item in
        # the global navigation
        global_nav = 'instances' if c.instance is not None else 'home'
        c.active_global_nav = global_nav
        c.body_css_classes.append('global_nav_' + global_nav)
        user_id = environ.get('repoze.who.identity', {}).get('user', None)
        user = None
        # make sure we're not using a detached user object
        if user_id is not None:
            user = model.meta.Session.merge(user_id)
        if user and (user.banned or user.delete_time):
            user = None
        if user is not None:
            c.body_css_classes.append('logged_in')
        else:
            c.body_css_classes.append('not_logged_in')
        c.user = user
        c.active_controller = request.environ.get('pylons.routes_dict')\
            .get('controller')
        c.debug = config.get_bool('debug')
        i18n.handle_request()

        if h.site.is_local_url(request.params.get(u'came_from', u'')):
            c.came_from = request.params.get(u'came_from', u'')

        monitor_page_time_interval = config.get_int(
            'adhocracy.monitor_page_time_interval', -1)
        c.page_stats_url = h.base_url('/stats/on_page')
        if monitor_page_time_interval > 0:
            c.monitor_page_time_interval = monitor_page_time_interval

        if config.get_bool('adhocracy.monitor_external_links'):
            c.monitor_external_links_url = h.base_url('/stats/record_external')

        if config.get_bool('adhocracy.monitor_browser_values'):
            c.monitor_browser_values = "enabled"
        if config.get_bool('adhocracy.monitor_extended'):
            c.monitor_extended = "enabled"
        if config.get_bool('adhocracy.monitor_page_performance'):
            c.monitor_page_performance = "enabled"

        if config.get_bool('adhocracy.monitor_pager_clicks'):
            c.monitor_pager_clicks = "enabled"

        h.add_rss("%s News" % h.site.name(),
                  h.base_url('/feed.rss', None))
        if c.instance:
            h.add_rss("%s News" % c.instance.label,
                      h.base_url('/instance/%s.rss' % c.instance.key))

        h.add_meta("description", config.get(
            'adhocracy.site.description',
            _(u"A liquid democracy platform for making decisions in "
              u"distributed, open groups by cooperatively creating "
              u"proposals and voting on them to establish their "
              u"support.")))

        h.add_meta("keywords",
                   _("adhocracy, direct democracy, liquid democracy, liqd, "
                     "democracy, wiki, voting,participation, group decisions, "
                     "decisions, decision-making"))

        try:
            return WSGIController.__call__(self, environ, start_response)
        except Exception, e:
            log.exception(e)
            model.meta.Session.rollback()
            raise
        finally:
            if isinstance(model.meta.Session, ScopedSession):
                model.meta.Session.remove()

    def bad_request(self, format='html'):
        log.debug("400 Request: %s" % request.params)
        return ret_abort(_("Invalid request. Please go back and try again."),
                         code=400, format=format)

    def not_implemented(self, format='html'):
        return ret_abort(_("The method you used is not implemented."),
                         code=400, format=format)

########NEW FILE########
__FILENAME__ = behavior
""" Change UI depending on user badges """

import collections

from paste.deploy.converters import asbool
from pylons import config
from pylons.i18n import _


def behavior_enabled(config=config):
    return asbool(config.get('adhocracy.enable_behavior', 'False'))


def get_behavior(user, key):
    assert key in ['proposal_sort_order']

    if not behavior_enabled():
        return None

    if user is None:
        return None

    propname = 'behavior_' + key
    for b in user.badges:
        v = getattr(b, propname)
        if v is not None:
            return v
    return None

########NEW FILE########
__FILENAME__ = broadcast
from datetime import datetime
import json

from pylons.i18n import _
from sqlalchemy import or_

import adhocracy.model as model
import adhocracy.i18n as i18n
from adhocracy.lib.queue import async
import mail


def notify_abuse(instance, user, url, message):
    message = {
        'instance': instance.key if instance else None,
        'user': user.user_name if user else 'Anonymous',
        'url': url,
        'message': message
    }
    message = json.dumps(message)
    handle_abuse_message(message)


def get_instance_admins(instance):
    sgroup = model.Group.find(model.Group.CODE_SUPERVISOR)
    agroup = model.Group.find(model.Group.CODE_ADMIN)
    q = model.meta.Session.query(model.User)
    q = q.join(model.Membership)
    q = q.filter(model.Membership.instance == instance)
    q = q.filter(or_(model.Membership.group == sgroup,
                     model.Membership.group == agroup))
    q = q.filter(or_(model.Membership.expire_time == None,  # noqa
                     model.Membership.expire_time >= datetime.utcnow()))
    return q.all()


def get_global_admins():
    group = model.Group.find(model.Group.CODE_ADMIN)
    q = model.meta.Session.query(model.User)
    q = q.join(model.Membership)
    q = q.filter(model.Membership.instance == None)  # noqa
    q = q.filter(model.Membership.group == group)
    q = q.filter(or_(model.Membership.expire_time == None,  # noqa
                     model.Membership.expire_time >= datetime.utcnow()))
    return q.all()


@async
def handle_abuse_message(message):
    message = json.loads(message)
    admins = []
    if message.get('instance'):
        instance = model.Instance.find(message.get('instance'))
        admins = get_instance_admins(instance)
    else:
        admins = get_global_admins()
    for admin in admins:
        i18n.user_language(admin)
        subject = _("Abuse report: %s") % message.get('url')
        body = _("%(user)s has reported abuse on the page %(url)s:"
                 "\r\n\r\n%(message)s")
        body = body % message
        mail.to_user(admin, subject, body)

########NEW FILE########
__FILENAME__ = invalidate
import logging
from adhocracy import model
from adhocracy.lib.cache.util import clear_tag

log = logging.getLogger(__name__)


def invalidate_badge(badge):
    log.debug('invalidate_badge %s' % badge)
    clear_tag(badge)


def invalidate_userbadges(userbadges):
    clear_tag(userbadges)
    invalidate_user(userbadges.user)


def invalidate_delegateablebadges(delegateablebadges):
    clear_tag(delegateablebadges)
    invalidate_delegateable(delegateablebadges.delegateable)


def invalidate_user(user):
    clear_tag(user)


def invalidate_text(text):
    clear_tag(text)
    invalidate_page(text.page)


def invalidate_page(page):
    invalidate_delegateable(page)


def invalidate_delegateable(d, include_parents=True):
    clear_tag(d)
    if include_parents:
        for p in d.parents:
            invalidate_delegateable(p)
        if not len(d.parents):
            clear_tag(d.instance)


def invalidate_revision(rev):
    invalidate_comment(rev.comment)


def invalidate_comment(comment):
    clear_tag(comment)
    if comment.reply:
        invalidate_comment(comment.reply)
    invalidate_delegateable(comment.topic)


def invalidate_delegation(delegation):
    invalidate_user(delegation.principal)
    invalidate_user(delegation.agent)


def invalidate_vote(vote):
    clear_tag(vote)
    invalidate_user(vote.user)
    invalidate_poll(vote.poll)


def invalidate_selection(selection):
    if selection is None:
        return
    clear_tag(selection)
    if selection.page:
        invalidate_delegateable(selection.page)
    if selection.proposal:
        invalidate_delegateable(selection.proposal)


def invalidate_poll(poll):
    clear_tag(poll)
    if poll.action == poll.SELECT:
        invalidate_selection(poll.selection)
    elif isinstance(poll.subject, model.Delegateable):
        invalidate_delegateable(poll.subject)
    elif isinstance(poll.subject, model.Comment):
        invalidate_comment(poll.subject)


def invalidate_instance(instance):
    # muharhar cache epic fail
    clear_tag(instance)
    for d in instance.delegateables:
        invalidate_delegateable(d, include_parents=False)


def invalidate_tagging(tagging):
    clear_tag(tagging)
    invalidate_delegateable(tagging.delegateable)

########NEW FILE########
__FILENAME__ = util
import logging
from hashlib import sha1

from pylons import app_globals

log = logging.getLogger(__name__)

SEP = "|"


class NoneResult(object):
    pass


def _hash(data):
    return sha1(data).hexdigest()


def add_tags(key, tags):
    ctags = app_globals.cache.get_multi(tags)
    for tag in tags:
        if not ctags.get(tag):
            ctags[tag] = key
        else:
            ctags[tag] = ctags[tag] + SEP + key
    app_globals.cache.set_multi(ctags)


def tag_fn(key, args, kwargs):
    tags = [make_tag(a) for a in args]
    tags += [make_tag(v) for v in kwargs.values()]
    add_tags(key, tags)


def make_tag(obj):
    """ Collisisons here don't matter much. """
    rep = "catch_all"
    try:
        rep = repr(obj).encode('ascii', 'ignore')
    except:
        pass
    try:
        rep = unicode(obj).encode('ascii', 'ignore')
    except:
        pass
    return _hash(rep)


def make_key(iden, args, kwargs):
    sig = iden[:200] + make_tag(args) + make_tag(kwargs)
    return sha1(sig).hexdigest()


def clear_tag(tag):
    try:
        entities = app_globals.cache.get(make_tag(tag))
        if entities:
            app_globals.cache.delete_multi(entities.split(SEP))
    except TypeError:
        pass  # when app_globals isn't there yet


def memoize(iden, time=0, make_key=make_key):
    try:
        from pylons import tmpl_context as c
        iden = c.instance.key + '.' + iden if c.instance else iden
    except:
        pass

    def memoize_fn(fn):
        from adhocracy.lib.cache.util import NoneResult

        def new_fn(*a, **kw):
            try:
                cache = app_globals.cache
            except TypeError:
                # Probably in tests
                cache = None
            if not cache:
                res = fn(*a, **kw)
            else:
                key = make_key(iden, a, kw)
                res = cache.get(key)
                if res is None:
                    res = fn(*a, **kw)
                    # print "Cache miss", key + iden
                    if res is None:
                        res = NoneResult
                    # print "Cache set:", key + iden
                    cache.set(key, res, time=time)
                    tag_fn(key, a, kw)
                # else:
                #     print "Cache hit", key + iden
                if res is NoneResult:
                    res = None
            return res
        return new_fn
    return memoize_fn

########NEW FILE########
__FILENAME__ = captchasdotnet
# --------------------------------------------------------------------
# Python module for easy utilization of http://captchas.net
#
# For documentation look at http://captchas.net/sample/python/
#
# Written by Sebastian Wilhelmi <seppi@seppi.de> and
#            Felix Holderied <felix@holderied.de>
# This file is in the public domain.
#
# ChangeLog:
#
# 2006-09-08: Add new optional parameters alphabet, letters
#             height an width. Add audio_url.
#
# 2006-03-01: Only delete the random string from the repository in
#             case of a successful verification.
#
# 2006-02-14: Add new image() method returning an HTML/JavaScript
#             snippet providing a fault tolerant service.
#
# 2005-06-02: Initial version.
#
# --------------------------------------------------------------------

import errno
import os
import md5
import random
import time


class CaptchasDotNet:
    def __init__(self, client, secret,
                 alphabet='abcdefghkmnopqrstuvwxyz',
                 letters=6,
                 width=240,
                 height=80,
                 random_repository='/tmp/captchasnet-random-strings',
                 cleanup_time=3600
                 ):
        self.__client = client
        self.__secret = secret
        self.__alphabet = alphabet
        self.__letters = letters
        self.__width = width
        self.__height = height
        self.__random_repository = random_repository
        self.__cleanup_time = cleanup_time
        self.__time_stamp_file = os.path.join(random_repository,
                                              '__time_stamp__')

    # Return a random string
    def __random_string(self):
        # The random string shall consist of small letters, big letters
        # and digits.
        letters = "abcdefghijklmnopqrstuvwxyz"
        letters += letters.upper() + "0123456789"

        # The random starts out empty, then 40 random possible characters
        # are appended.
        random_string = ''
        for i in range(40):
            random_string += random.choice(letters)

        # Return the random string.
        return random_string

    # Create a new random string and register it.
    def random(self):
        # If the repository directory is does not yet exist, create it.
        if not os.path.isdir(self.__random_repository):
            os.makedirs(self.__random_repository)

        # If the time stamp file does not yet exist, create it.
        if not os.path.isfile(self.__time_stamp_file):
            os.close(os.open(self.__time_stamp_file, os.O_CREAT, 0700))

        # Get the current time.
        now = time.time()

        # Determine the time, before which to remove random strings.
        cleanup_time = now - self.__cleanup_time

        # If the last cleanup is older than specified, cleanup the
        # directory.
        if os.stat(self.__time_stamp_file).st_mtime < cleanup_time:
            os.utime(self.__time_stamp_file, (now, now))
            for file_name in os.listdir(self.__random_repository):
                file_name = os.path.join(self.__random_repository, file_name)
                if os.stat(file_name).st_mtime < cleanup_time:
                    os.unlink(file_name)

        # loop until a valid random string has been found and registered.
        while True:
            # generate a new random string.
            random = self.__random_string()

            # open a file with the corresponding name in the repository
            # directory in such a way, that the creation fails, when the
            # file already exists. That should be near to impossible with
            # good seeding of the random number generator, but it's better
            # to play safe.
            try:
                os.close(os.open(os.path.join(self.__random_repository,
                                              random),
                                 os.O_EXCL | os.O_CREAT, 0700))
            except EnvironmentError, error:
                # if the file already existed, rerun the loop to try the
                # next string.
                if error.errno == errno.EEXIST:
                    continue
                else:
                    # other errors will certainly persist for other random
                    # strings, so raise the exception.
                    raise

            # return the successfully registered random string.
            self.__random = random
            return random

    def image_url(self, random=None, base='http://image.captchas.net/'):
        if not random:
            random = self.__random
        url = base
        url += '?client=%s&amp;random=%s' % (self.__client, random)
        if self.__alphabet != "abcdefghijklmnopqrstuvwxyz":
            url += '&amp;alphabet=%s' % self.__alphabet
        if self.__letters != 6:
            url += '&amp;letters=%s' % self.__letters
        if self.__width != 240:
            url += '&amp;width=%s' % self.__width
        if self.__height != 80:
            url += '&amp;height=%s' % self.__height
        return url

    def audio_url(self, random=None, base='http://audio.captchas.net/'):
        if not random:
            random = self.__random
        url = base
        url += '?client=%s&amp;random=%s' % (self.__client, random)
        if self.__alphabet != "abcdefghijklmnopqrstuvwxyz":
            url += '&amp;alphabet=%s' % self.__alphabet
        if self.__letters != 6:
            url += '&amp;letters=%s' % self.__letters
        return url

    def image(self, random=None, id='captchas.net'):
        return '''
        <img style="border: none; vertical-align: bottom"
            id="%s" src="%s" width="%d" height="%d"
            alt="The CAPTCHA image" />
        <script type="text/javascript">
          <!--
          function captchas_image_error (image)
          {
            if (!image.timeout) return true;
            image.src = image.src.replace (/^http:\/\/image\.captchas\.net/,
                                           'http://image.backup.captchas.net');
            return captchas_image_loaded (image);
          }

          function captchas_image_loaded (image)
          {
            if (!image.timeout) return true;
            window.clearTimeout (image.timeout);
            image.timeout = false;
            return true;
          }

          var image = document.getElementById ('%s');
          image.onerror = function() {return captchas_image_error (image);};
          image.onload = function() {return captchas_image_loaded (image);};
          image.timeout
            = window.setTimeout(
               "captchas_image_error (document.getElementById ('%s'))",
               10000);
          image.src = image.src;
          //-->
        </script>''' % (id, self.image_url(random), self.__width,
                        self.__height, id, id)

    def validate(self, random):
        self.__random = random

        file_name = os.path.join(self.__random_repository, random)

        # Find out, whether the file exists
        result = os.path.isfile(file_name)

        # if the file exists, remember it.
        if result:
            self.__random_file = file_name

        # the random string was valid, if and only if the
        # corresponding file existed.
        return result

    def verify(self, input, random=None):
        if not random:
            random = self.__random

        # The format of the password.
        password_alphabet = self.__alphabet
        password_length = self.__letters

        # If the user input has the wrong lenght, it can't be correct.
        if len(input) != password_length:
            return False

        # Calculate the MD5 digest of the concatenation of secret key and
        # random string.
        encryption_base = self.__secret + random
        if (password_alphabet != "abcdefghijklmnopqrstuvwxyz") \
                or (password_length != 6):
            encryption_base += ":" + password_alphabet + ":" \
                + str(password_length)
        digest = md5.new(encryption_base).digest()

        # Compute password
        correct_password = ''
        for pos in range(password_length):
            letter_num = ord(digest[pos]) % len(password_alphabet)
            correct_password += password_alphabet[letter_num]

        # Check password
        if input != correct_password:
            return False

        # Remove the correspondig random file, if it exists.
        try:
            os.unlink(self.__random_file)
            del self.__random_file
        except:
            pass

        # The user input was correct.
        return True

########NEW FILE########
__FILENAME__ = cli
import itertools
from logging import getLogger
import os
import signal
import threading
import time

import paste.script
import paste.fixture
import paste.registry
import paste.deploy.config
from paste.deploy import loadapp
from paste.script.command import Command
import rq

from adhocracy import model
from adhocracy.lib import search
from adhocracy.lib import queue


log = getLogger(__name__)


class AdhocracyCommand(Command):
    parser = Command.standard_parser(verbose=True)
    parser.add_option('-c', '--config', dest='config',
                      default='etc/adhocracy.ini', help='Config file to use.')
    default_verbosity = 1
    group_name = 'adhocracy'

    def _load_config(self):
        from paste.deploy import appconfig
        if not self.options.config:
            msg = 'No config file supplied'
            raise self.BadCommand(msg)
        self.filename = os.path.abspath(self.options.config)
        self.logging_file_config(self.filename)
        conf = appconfig('config:' + self.filename)
        conf.update(dict(app_conf=conf.local_conf,
                         global_conf=conf.global_conf))
        paste.deploy.config.CONFIG.push_thread_config(conf)
        wsgiapp = loadapp('config:' + self.filename)
        test_app = paste.fixture.TestApp(wsgiapp)
        tresponse = test_app.get('/_test_vars')
        request_id = int(tresponse.body)
        test_app.pre_request_hook = lambda self: \
            paste.registry.restorer.restoration_end()
        test_app.post_request_hook = lambda self: \
            paste.registry.restorer.restoration_begin(request_id)
        paste.registry.restorer.restoration_begin(request_id)

    def _setup_app(self):
        cmd = paste.script.appinstall.SetupCommand('setup-app')
        cmd.run([self.filename])


class AdhocracyTimer(object):

    timer_duration = 60

    periodicals = {
        'minutely': dict(delay=60.0, task=queue.minutely),
        'hourly': dict(delay=3600.0, task=queue.hourly),
        'daily': dict(delay=86400.0, task=queue.daily)}

    def __init__(self, redis, queue_name):
        self.redis = redis
        self.queue_name = queue_name

    @property
    def lock_key(self):
        return '%s.guard.lock' % self.queue_name

    @property
    def schedules_key(self):
        return '%s.shedules' % self.queue_name

    def guard(self):
        '''
        check if any of our peridical functions has to be called.
        This will set up a timer to call itself every 60 seconds.
        '''
        if self.get_lock():
            self.run_periodicals()
        self.setup_timer(self.timer_duration, self.guard)

    def run_periodicals(self):
        '''
        Run the periodical functions and do schedule the next
        execution times if necessary.
        '''
        hash_name = self.schedules_key
        now = time.time()
        for key_name, periodical in self.periodicals.items():
            log.debug('periodical: %s' % str(periodical))
            self.redis.hsetnx(hash_name, key_name, 0)
            next_run = self.redis.hget(hash_name, key_name)
            log.debug('next_run: %s' % next_run)
            if float(next_run) < (now + 1):
                log.debug('run now.')
                periodical['task'].enqueue()
                next_run = float(now + periodical['delay'])
                self.redis.hset(hash_name, key_name, next_run)

        # expire our schedules hash an our after the next sheduled run
        max_duration = max([p['delay'] for p in self.periodicals.values()])
        expire = max_duration + 3600
        self.redis.expire(hash_name, int(expire))

    def get_lock(self):
        '''
        Return `True` if we have or can set a lock in redis. The lock
        will be set or extended for the given *duration* from (from
        the time it is set or renewed) and is valid for the current
        process.
        '''
        redis = self.redis
        key = self.lock_key
        duration = self.timer_duration + 1
        pid = self.pid

        log.debug('get_lock, pid: %s...' % pid)
        # set a new lock if it does not exist
        if redis.setnx(key, pid):
            redis.expire(key, duration)
            log.debug('new')
            return True

        # Get the current lock and check if it is ours:
        current_value = redis.get(key)
        log.debug('current value: %s, type: %s' % (current_value,
                                                   type(current_value)))
        if int(current_value) == pid:
            redis.expire(key, duration)
            # log.debug('extended')
            return True

        log.debug('nope')
        return False

    def setup_timer(self, interval, func):
        timer = threading.Timer(interval, func)
        timer.daemon = True
        timer.start()

    def start(self):
        self.pid = os.getpid()
        self.guard()


class Timer(AdhocracyCommand):
    '''
    Schedule periodical jobs.
    '''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = None
    min_args = None

    def command(self):
        self._load_config()
        redis = queue.rq_config.connection
        if not redis:
            log.error('No redis connection available')
            exit(1)
        self.timer = AdhocracyTimer(redis, queue.rq_config.queue_name)
        self.timer.start()  # this will setup a timer thread
        signal.signal(signal.SIGTERM, lambda signum, frame: exit(0))
        signal.signal(signal.SIGINT, lambda signum, frame: exit(0))
        signal.pause()


class Worker(AdhocracyCommand):
    '''Run Adhocracy background jobs.'''
    summary = __doc__.split('\n')[0]
    usage = __doc__
    max_args = None
    min_args = None

    redis = None
    queue = None

    def command(self):
        self._load_config()
        queue.rq_config.in_worker = True
        connection = queue.rq_config.connection
        if not connection:
            log.error('No redis connection available')
            exit(1)
        queue_ = queue.rq_config.queue
        if not queue_:
            log.error('No queue available.')
            exit(1)
        worker = rq.Worker([queue_], connection=connection)
        worker.work()


class Index(AdhocracyCommand):
    """Re-create Adhocracy's search index."""
    summary = __doc__.split('\n')[0]
    max_args = 999
    min_args = None

    DROP = 'DROP'
    INDEX = 'INDEX'

    errors = False
    _indexed_classes = None

    def get_instances(self, args):

        names = []
        INSTANCES_KEYWORD = '-I'
        remaining_args = args[:]
        if INSTANCES_KEYWORD in args:
            index = args.index(INSTANCES_KEYWORD)
            names = self.args[index + 1:]
            remaining_args = args[:index]

        instances = []
        for name in names:
            instance = model.Instance.find(name, include_deleted=True)
            if not instance:
                print 'Instance "%s" not found.\n' % name
                self.errors = True
            else:
                instances.append(instance)
        return (remaining_args, instances)

    def get_classes(self, args):
        classes = []
        for name in args:
            cls = self.indexed_classes.get(name)
            if cls is None:
                print 'Unknown content type "%s"' % name
                self.errors = True
            else:
                classes.append(cls)
        return classes

    def get_actions(self, args):
        actions = []
        for action in [self.DROP, self.INDEX]:
            if action in args:
                actions.append(action)
                args.remove(action)
        if not actions:
            print 'No actions specified.'
            self.errors = True
        return args, actions

    def command(self):
        self._load_config()

        # b/w compatibity
        if not self.args:
            self.start([self.INDEX], [], [])
            exit(0)

        args = self.args[:]

        args, instances = self.get_instances(args)
        args, actions = self.get_actions(args)
        classes = self.get_classes(args)

        if self.errors:
            exit(1)
        else:
            self.start(actions, classes, instances)

    def printable(self, items, print_=lambda x: x):
        if not items:
            return 'ALL'
        else:
            return ', '.join([print_(item) for item in items])

    def start(self, actions, classes, instances):
        print ('Starting.\n'
               '  Actions: %s\n'
               '  Content Types: %s\n'
               '  Instances: %s\n' % (
                   self.printable(actions),
                   self.printable(classes,
                                  print_=lambda x: x.__name__.lower()),
                   self.printable(instances, print_=lambda x: x.key)))

        if self.DROP in actions:
            p_instances = instances if instances else [None]
            p_classes = classes if classes else [None]

            print 'Dropping docs from solr... '
            for (cls, instance) in itertools.product(p_classes, p_instances):
                print 'content_type: %s, instance: %s' % (cls, instance)
                search.drop(cls, instance)
            print '...done.'

        if self.INDEX in actions:
            classes = classes if classes else self.indexed_classes.values()
            search.rebuild(classes, instances=instances)
            print 'done.'
            return

    @property
    def indexed_classes(self):
        if self._indexed_classes is None:
            self._indexed_classes = dict([(cls.__name__.lower(), cls) for
                                          cls in search.INDEXED_CLASSES])
        return self._indexed_classes

    @property
    def usage(self):
        usage = self.__doc__ + '\n\n'
        indexed_classes = sorted(self.indexed_classes.keys())
        content_types = '\n          '.join(indexed_classes)
        usage += (
            'index (INDEX|DROP|DROP_ALL|ALL) [<entity>, ...] [-I <instance>, '
            '...] -c <inifile>'
            '\n\n'
            '  DROP_ALL:\n'
            '      Remove all documents from solr.\n'
            '  ALL\n'
            '      Index all content in solr.\n'
            '      Default if no arguments are given\n'
            '  <entity>\n'
            '      Names of a content types to index. If not given,\n'
            '      all content is indexed. Types:\n'
            '          %s\n'
            '  -I <instance>, ...\n'
            '      Reindex only content from the instances. Note: Users\n'
            '      are dropped if they are member in one of the instances,\n'
            '      even if they are also member in other instances.'
        ) % content_types

        return usage

########NEW FILE########
__FILENAME__ = cookie
import datetime
import re

from paste.deploy.converters import asbool
from pylons import config

# Valid cookie values, see http://tools.ietf.org/html/rfc6265#section-4.1.1
_COOKIE_VALUE_RE = re.compile(u'^[!#$%&\'()*+./0-9:<=>?@A-Z[\\]^_`a-z{|}~-]*$')


def get_cookies(values, max_age=None, secure=False, config=config):
    return [get_cookie(k, v, max_age=max_age, secure=secure, config=config)
            for k, v in values.items()]


def get_cookie(name, value, max_age=None, secure=False, config=config):
    assert _COOKIE_VALUE_RE.match(value)

    if max_age == 'delete':
        max_age = '; Expires=Thu, 01 Jan 1970 00:00:00 GMT'
    elif max_age is not None:
        now = datetime.datetime.utcnow()
        later = now + datetime.timedelta(seconds=int(max_age))
        # Wdy, DD-Mon-YY HH:MM:SS GMT
        expires = later.strftime('%a, %d %b %Y %H:%M:%S')
        # the Expires header is *required* at least for IE7 (IE7 does
        # not respect Max-Age)
        max_age = "; Max-Age=%s; Expires=%s" % (max_age, expires)
    else:
        max_age = ''

    secure_str = ''
    if secure:
        secure_str = '; secure'
    secure_str += '; HttpOnly'

    if asbool(config.get('adhocracy.relative_urls', 'false')):
        # Serve the cookie for the current host, which may be
        # "localhost" or an IP address.
        return ('Set-Cookie', '%s=%s; Path=/; %s%s' % (
                name, value, max_age, secure_str))
    else:
        cur_domain = config.get('adhocracy.domain').partition(':')[0]
        wild_domain = '.' + cur_domain

        return ('Set-Cookie', '%s=%s; Path=/; Domain=%s%s%s' % (
                name, value, wild_domain, max_age, secure_str))

########NEW FILE########
__FILENAME__ = core
"""
adhocracy.lib.core contains helper functions and classes which don't depend on
any libraries outside of standard Python.
"""


class CustomDict(dict):
    """
    Custom dictionary which allows to overwrite the setitem method by
    passing a custom setter to the constructor.

    This is basically copied from
    http://stackoverflow.com/questions/2060972/subclassing-python-dictionary-to-override-setitem  # noqa
    """

    def __init__(self, setter_fun=lambda k, v: (k, v), *args, **kwargs):
        self.setter_fun = setter_fun
        self.update(*args, **kwargs)

    def __setitem__(self, key, value):
        super(CustomDict, self).__setitem__(*self.setter_fun(key, value))

    def update(self, *args, **kwargs):
        if len(args) > 1:
            raise TypeError("update expected at most 1 arguments, got %d"
                            % len(args))
        other = dict(*args, **kwargs)
        for key in other:
            self[key] = other[key]

    def setdefault(self, key, value=None):
        if key not in self:
            self[key] = value
        return self[key]

########NEW FILE########
__FILENAME__ = cors
class CorsMiddleware(object):
    """ Set CORS header.

    This middleware sets an Access-Control-Allow-Origin HTTP header allowing
    scripts from other domains to load Adhocracy data.

    In our case this is needed in the following case (non-relative URLs):

    - User visits foo.adhocracy.lan
    - Due to fanstatic loading everything from the main URL, a script is loaded
      from adhocracy.lan/js/myscript.js
    - This script wants to access JSON data from the same domain it comes from
      (js.socialshareprivacy-1.5 does that)
    - JSON from adhocracy.lan couldn't be loaded from foo.adhocracy.lan if
      the respective header weren't set.

    It would be sufficient to allow `*.adhocracy.lan` to access JSON data on
    `adhocracy.lan`, but the CORS specs don't allow for that. Therefore we
    allow everybody to use our data.

    """

    def __init__(self, app, config):
        self.app = app
        self.config = config

    def __call__(self, environ, start_response):
        def local_response(status, headers, exc_info=None):
            headers.append(('Access-Control-Allow-Origin', '*'))
            start_response(status, headers, exc_info)
        return self.app(environ, local_response)

########NEW FILE########
__FILENAME__ = crypto
import hashlib
import hmac

from pylons import config

try:
    from hmac import compare_digest
except ImportError:  # Python < 3.3
    def compare_digest(a, b):
        # We'll just try emulating it here and hope that the network noise
        # is sufficient and the Python interpreter isn't too clever

        if type(a) != type(b) or len(a) != len(b):
            # This conforms to the doc, which says:
            # > If a and b are of different lengths, or if an error occurs, a
            # > timing attack could theoretically reveal information about the
            # > types and lengths of a and b - but not their values.
            return False
        res = 1
        for achar, bchar in zip(a, b):
            # The "and" operator short-circuits!
            res = res & int(achar == bchar)
        return res == 1


def get_secret(config=config, key=None):
    search_keys = [
        'adhocracy.crypto.secret',
        'beaker.session.secret',
        'adhocracy.auth.secret',
    ]
    if key is not None:
        search_keys.insert(0, key)
    for k in search_keys:
        if config.get(k):
            assert config[k] != 'autogenerated'
            res = config[k]
            if not isinstance(res, bytes):
                res = res.encode('ascii')
            return res
    raise Exception('No secret configured!')


def _sign(val, secret, salt):
    hm = hmac.new(secret + salt, val, hashlib.sha256)
    digest = hm.hexdigest()
    return digest.encode('ascii')


def sign(val, secret=None, salt=b''):
    if secret is None:
        secret = get_secret()
    assert isinstance(secret, bytes)
    assert isinstance(val, bytes)
    assert isinstance(salt, bytes)

    return _sign(val, secret, salt) + b'!' + val


def verify(signed, secret=None, salt=b''):
    if secret is None:
        secret = get_secret()
    assert isinstance(secret, bytes)
    assert isinstance(signed, bytes)
    assert isinstance(salt, bytes)

    signature, _, val = signed.partition(b'!')
    correct_signature = _sign(val, secret, salt)
    if compare_digest(signature, correct_signature):
        return val
    else:
        raise ValueError(salt.decode('ascii') + u' MAC verification failed')

########NEW FILE########
__FILENAME__ = decision
import logging
import math

from sqlalchemy.orm import eagerload

from adhocracy import model
from adhocracy.lib.cache import memoize
from adhocracy.lib.democracy.delegation_node import DelegationNode
from adhocracy.model import Delegateable, Vote, Poll, User


log = logging.getLogger(__name__)


class DecisionException(Exception):
    """ A general exception for ``Decision`` errors """
    pass


class Decision(object):
    """
    A decision describes the current or past opinion that a user has
    expressed on a given poll. This includes opinions that were determined
    by an agent as a result of delegation.
    """

    def __init__(self, user, poll, at_time=None, votes=None):
        self.user = user
        self.poll = poll
        self.at_time = at_time
        self.node = DelegationNode(user, poll.scope)
        self.votes = votes
        if not votes:
            self.reload()

    def reload(self):
        """
        Load all votes by the user regarding the poll.
        """
        q = model.meta.Session.query(Vote)
        q = q.filter(Vote.user_id == self.user.id)
        q = q.filter(Vote.poll_id == self.poll.id)
        q = q.options(eagerload(Vote.delegation))
        if self.at_time:
            q = q.filter(Vote.create_time <= self.at_time)
        q = q.order_by(Vote.id.desc())
        self.votes = q.all()
        return self

    def _relevant_votes(self):
        """
        Currently relevant votes for the polling interval.

        **WARNING**: A non-empty list of relevant votes does not always
        mean a decision was made. This is not true, for example, when multiple
        delegates match a proposal and their opinions differ.

        :returns: List of ``Vote``
        """
        relevant = {}
        for vote in self.votes:
            if not vote.delegation:
                return [vote]
            create_time = relevant.get(vote.delegation, vote).create_time
            if create_time <= vote.create_time:
                relevant[vote.delegation] = vote
        use_keys = self.node.filter_less_specific_delegations(relevant.keys())
        return [v for k, v in relevant.items() if k in use_keys]

    relevant_votes = property(_relevant_votes)

    def _create_time(self):
        """
        Utility property to see when this decision became effective. Equals
        the latest relevant vote creation date.

        :returns: datetime
        """
        return max(map(lambda v: v.create_time, self.relevant_votes))

    create_time = property(_create_time)

    def _delegations(self):
        """
        The set of delegations which have determined this decision, as per
        ``relevant_votes``.

        :returns: list of ``Delegation``
        """
        return filter(lambda d: d is not None,
                      list(set(map(lambda v: v.delegation,
                                   self.relevant_votes))))

    delegations = property(_delegations)

    def _result(self):
        """
        The result is an ``orientation`` and reflects the ``User``'s current
        decision on the ``Proposal``. Values match those in ``Vote``.
        Given multiple delegates who have voted on the proposal, the
        current approach is to check for an unanimous decision and to
        discard all other constellations. Another approach would be to
        require only a certain majority of agents to support an
        opinion, thus creating an inner vote.
        """
        relevant = self.relevant_votes
        orientations = set(map(lambda v: v.orientation, relevant))
        if len(relevant) and len(orientations) == 1:
            return orientations.pop()
        return None

    result = property(_result)

    # REFACT: this api is dangeous as it assumes but does not check that
    # REFACT: a poll is actually open for this proposal
    def make(self, orientation, _edge=None):
        """
        Make a decision on a given proposal, i.e. vote. Voting
        recursively propagates through the delegation graph to all
        principals who have assigned voting power to the ``User``.
        Each delegated vote will be marked as such by
        saving the ``Delegation`` as a part of the ``Vote``.

        :param orientation: orientation of the vote, ``Vote.YES``, ``Vote.NO``
            or ``Vote.ABSTAIN``
        :returns: the ``Votes`` that has been cast
        """

        def propagating_vote(user, delegateable, edge):
            vote = Vote(user, self.poll, orientation, delegation=edge)
            model.meta.Session.add(vote)
            log.debug("Decision was made: %s is voting '%s' on %s (via %s)" %
                      (repr(user),
                       orientation,
                       self.poll,
                       edge if edge else "self"))
            return vote

        votes = self.node.propagate(propagating_vote, _edge=_edge)
        self.reload()
        return votes

    def is_decided(self):
        """
        Determine if a given decision was made by the user, i.e. if the user
        or one of his/her agents has voted on the proposal.
        """
        return self.result is not None

    def is_self_decided(self):
        """
        Determine if a given decision was made by the user him-/herself.
        This does not consider decisions determined by delegation.
        """

        relevant = self.relevant_votes
        return len(relevant) == 1 and relevant[0].delegation is None

    def __repr__(self):
        return "<Decision(%s,%s)>" % (self.user.user_name, self.poll.id)

    def without_vote(self, vote):
        """
        Return the same decision given that a certain vote had not been
        cast.
        """
        if vote not in self.relevant_votes:
            return self
        else:
            votes = [v for v in self.votes if v != vote]
            return Decision(self.user, self.poll,
                            at_time=self.at_time, votes=votes)

    def to_dict(self):
        d = dict(user=self.user.user_name,
                 poll=self.poll.id,
                 decided=self.is_decided(),
                 self_decided=self.is_self_decided())
        if self.is_decided():
            d['result'] = self.result
        d['delegations'] = map(lambda d: d.id, self.delegations)
        return d

    @classmethod
    def for_user(cls, user, instance, at_time=None):  # FUUUBARD
        """
        Give a list of all decisions the user made within an instance context.

        :param user: The user for which to list ``Decisions``
        :param instance: an ``Instance`` context.
        """
        query = model.meta.Session.query(Poll)
        query = query.distinct().join(Vote)
        query = query.join(Delegateable)
        query = query.filter(Delegateable.instance == instance)
        query = query.filter(Vote.user == user)
        query = query.options(eagerload(Poll.scope))
        for poll in query:
            if not instance or poll.scope.instance == instance:
                yield cls(user, poll, at_time=at_time)

    @classmethod
    def for_poll(cls, poll, at_time=None, user_filter=None):
        """
        Get all decisions that have been made on a poll.

        :param poll: The poll on which to get decisions.
        """
        query = model.meta.Session.query(User)
        if user_filter:
            query = user_filter(query)
        query = query.distinct().join(Vote)
        query = query.filter(Vote.poll_id == poll.id)
        if at_time:
            query = query.filter(Vote.create_time <= at_time)
        return [Decision(u, poll, at_time=at_time) for u in query]

    @classmethod
    def average_decisions(cls, instance):
        """
        The average number of decisions that a ``Poll`` in the given instance
        has. For each proposal, this only includes the current poll in order to
        not accumulate too much historic data.

        :param instance: the ``Instance`` for which to calculate the average.
        """
        @memoize('average_decisions', 86400)
        def avg_decisions(instance):
            query = model.meta.Session.query(Poll)
            query = query.join(Delegateable)
            query = query.filter(Delegateable.instance_id == instance.id)
            query = query.filter(Poll.end_time == None)  # noqa
            query = query.filter(Poll.action != Poll.RATE)
            decisions = []
            for poll in query:
                # only consider current polls to allow for drops
                # in participation
                decisions.append(len(poll.tally))
            avg = sum(decisions) / float(max(1, len(decisions)))
            return int(max(2, math.ceil(avg)))
        return avg_decisions(instance)

    @classmethod
    def replay_decisions(cls, delegation):
        """
        For a new delegation, have the principal reproduce all of the
        agents past decisions within the delegation scope.
        This process is not perfect, since not the full voting history
        is reproduced, but only the latest interim result. The resulting
        decisions should be the same, though.

        :param delegation: The delegation that is newly created.
        """
        for poll in Poll.within_scope(delegation.scope):
            agent_decision = Decision(delegation.agent, poll)
            if agent_decision.is_decided():
                principal_decision = Decision(delegation.principal, poll)
                principal_decision.make(agent_decision.result,
                                        _edge=delegation)
                log.debug("RP: Making %s" % principal_decision)

########NEW FILE########
__FILENAME__ = delegation_node
from datetime import datetime
import logging

from sqlalchemy import or_

from adhocracy import model
from adhocracy.model import Delegation

log = logging.getLogger(__name__)

# REFACT: Rename: DelegationTraverser? Maybe thats also a new object
# that does the traversing in different ways
# That may become a Strategy object on how the delegation should be traversed
# REFACT: Extract: DelegationUserGraph, DelegationTopicGraph,
# perhaps DelegationGraph as common superclass
# This object should represent a whole delegation graph from different
# points of view
# One Goal would be to be able to load the whole subgraph from the db
# in as few queries as possible
# Optimally just one...
# Maybe there will just be one DelegationGraph with different Strategies
# of how create/ traverse/ filter it attached
# Also it needs to be possible to ask the graph for the status at a
# specific time (all objects have a deleted_at property or it can be
# determined when they are overridden by a later choice)

# Some problems with this class:
# - many of the methods work across multiple nodes and layers of the graph
# - many of the methods take additional parameters to determine when to
#   filter this graph for different criteria
# - there are methods that work on the whole graph (some as class-methods)
# - Forward and backward traversal are in the same object
# - it is oblivious as to why the graph is traversed, either to allow
#   all agents to place their vote
#   or to find out what the delegation wheight of a specific user
#   is in a specific context


class DelegationNode(object):
    """
    A ``DelegationNode`` describes a part of the voting delegation graph
    sorrounding a ``Delegateable`` (i.e. a ``Category``, ``Issue`` or
    ``Proposal``) and a ``User``.

    Right now the delegation graph is a graph of incomming and outgoing
    delegations on multiple levels - one level per scope.

    Each DelegationNode represents the incomming and outgoing delegations
    of one user on one level (scope/delegateable) in this graph.

    **TODO:** Developing a good caching strategy for this class would be
    useful in order to cache the delegation graph to memcached.

    :param user: The ``User`` at the center of this ``DelegationNode``.
    :param delegateable: A ``Delegateable``.
    """

    def __init__(self, user, delegateable):
        self.user = user
        self.delegateable = delegateable

    def _query_traverse(self, querymod, recurse, at_time=None):
        if not at_time:  # shouldn't this be if at_time is None: ?
            at_time = datetime.utcnow()

        query = model.meta.Session.query(Delegation)
        query = query.filter(Delegation.scope == self.delegateable)
        query = query.filter(Delegation.create_time <= at_time)
        query = query.filter(or_(Delegation.revoke_time == None,  # noqa
                                 Delegation.revoke_time > at_time))
        query = querymod(query)
        delegations = query.all()
        if recurse:
            for parent in self.delegateable.parents:
                node = DelegationNode(self.user, parent)
                delegations += node._query_traverse(querymod, recurse, at_time)
        return delegations

    def inbound(self, recurse=True, at_time=None,
                is_counting_delegations=False):
        """
        Retrieve all inbound delegations (i.e. those that the user has received
        from other users in order to vote on their behalf) that apply to the
        ``Delegateable``.

        :param recurse: if ``True``, search will include delegations on parent
            ``Delegateables`` in breadth-first traversal order.
        :param at_time: return the delegation graph at the given time, defaults
            to the current time.
        """
        delegations = self._query_traverse(
            lambda q: q.filter(Delegation.agent == self.user),
            recurse, at_time)

        delegations = self._filter_out_overriden_delegations(delegations)
        if is_counting_delegations:
            delegations = self._filter_out_delegations_where_a_more_specific_delegation_exists(delegations)  # noqa
        delegations = self._filter_out_delegations_that_are_overriden_by_direct_votes(delegations)  # noqa
        return delegations

    def transitive_inbound(self, recurse=True, at_time=None, _path=None,
                           is_counting_delegations=False):
        """
        Retrieve inbound delegations recursing through the delegation graph
        as well as through the category tree.

        :param recurse: if ``True``, search will include delegations on parent
            ``Delegateables`` in breadth-first traversal order.
        :param at_time: return the delegation graph at the given time, defaults
            to the current time.
        :returns: list of ``Delegation``
        """
        if _path is None:
            _path = []
        elif self.user in _path:
            return []  # we already visited this node
        # circle detection uses this path of visited nodes
        _path.append(self.user)

        delegations = self.inbound(
            recurse=recurse, at_time=at_time,
            is_counting_delegations=is_counting_delegations)
        for delegation in list(delegations):
            ddnode = DelegationNode(delegation.principal, self.delegateable)
            additional_delegations = ddnode.transitive_inbound(
                recurse=recurse, at_time=at_time, _path=_path,
                is_counting_delegations=is_counting_delegations)
            for additional_delegation in additional_delegations:
                if additional_delegation.principal in _path:
                    # this is a delegation from a node we already visited
                    continue
                else:
                    delegations.append(additional_delegation)
        # _path is used as a stack in the recursion - so we need to remove
        # what we added in going into the recursion
        _path.remove(self.user)
        return delegations

    def outbound(self, recurse=True, at_time=None, filter=True):
        """
        Retrieve all outbound delegations (i.e. those that the user has given
        to other users in order allow them to vote on his/her behalf) that
        apply to the ``Delegateable``.

        :param recurse: if ``True``, search will include delegations on parent
            ``Delegateables`` in breadth-first traversal order.
        :param at_time: return the delegation graph at the given time, defaults
            to the current time.
        :returns: list of ``Delegation``
        """
        delegations = self._query_traverse(
            lambda q: q.filter(Delegation.principal == self.user),
            recurse, at_time)

        if filter:
            by_agent = dict()
            for delegation in set(delegations):
                by_agent[delegation.agent] = (
                    by_agent.get(delegation.agent, []) + [delegation])
            delegations = [self.filter_less_specific_delegations(ds)[0] for
                           ds in by_agent.values()]

        return delegations
    # TODO: consider to add a transitive-outbound to know where the vote
    #        will end up for a specific issue

    # REFACT: rename propagate_vote_to_delegators?
    def propagate(self, callable, _edge=None, _propagation_path=None):
        """
        Propagate a given action along the delegation graph *against*
        its direction, i.e. from the agent node towards its principal.
        This is the natural direction to propagate actions along this
        network since it allows principals to reproduce the actions of
        their agents.

        Propagation will abort on circular dependencies but has no
        recursion depth limit.

        :param callable: A callable that is to be called on each node.
                         It must take three arguments, a ``User``, a
                         ``Delegateable`` and the ``Delegation``
                         which served as a transitory edge during the
                         last step of the propagation.
        :returns: a list of all results produced by the callable.
        """
        if not _propagation_path:
            _propagation_path = [self]
        elif self in _propagation_path:
            return []
        else:
            _propagation_path.append(self)

        result = [callable(self.user, self.delegateable, _edge)]
        if not self.delegateable.instance.allow_delegate:
            return result
        for delegation in self.inbound():
            node = DelegationNode(delegation.principal, self.delegateable)
            result += node.propagate(callable,
                                     _edge=delegation,
                                     _propagation_path=_propagation_path)
        return result

    def number_of_delegations(self):
        return len(self.transitive_inbound(is_counting_delegations=True))

    def __repr__(self):
        return "<DelegationNode(%s,%s)>" % (self.user.user_name,
                                            self.delegateable.id)

    def __eq__(self, other):
        return self.user == other.user and \
            self.delegateable == other.delegateable

    def __ne__(self, other):
        return not self.__eq__(other)

    @classmethod
    def create_delegation(cls, from_user, to_user, scope):
        delegation = model.Delegation(from_user, to_user, scope)
        # dwt: why do I need to add the delegation to the session here?
        # it should just be added via the relation it has to the user and
        # either not be in the session at all or automatically via the
        # user object
        model.meta.Session.add(delegation)
        # dwt: Why is the flush here neccessary? - supplies the id
        # of course - but is that needed?
        model.meta.Session.flush()
        return delegation

    @classmethod
    def filter_less_specific_delegations(cls, delegations):
        """
        Given a set of delegations, remove those that are overriden by others.
        A delegation is overridden whenever there is another delegation with a
        narrower scope that still applies.

        :param delegations: The list of delegations that are to be filtered.
            They need to all be be from the same principal.
        :returns: A filtered list of delegations.
        """
        matches = list(delegations)
        for d in delegations:
            for m in matches:
                if m.scope.is_super(d.scope):
                    matches.remove(m)
        return matches

    def _filter_out_overriden_delegations(self, delegations):
        # return delegations
        by_principal = dict()
        for delegation in set(delegations):
            by_principal[delegation.principal] = by_principal.get(
                delegation.principal, []) + [delegation]
        return [self.filter_less_specific_delegations(ds)[0] for
                ds in by_principal.values()]

    def _filter_out_delegations_that_are_overriden_by_direct_votes(
            self, delegations):
        from adhocracy.lib.democracy.decision import Decision

        def is_overriden_by_own_decision(delegation):
            if not hasattr(delegation.scope, 'poll'):
                return True  # scope doesn't have polls -> can't self decide
            if delegation.scope.poll is None:
                # currently no poll in this cope -> can't self decide
                return True
            decision = Decision(delegation.principal, delegation.scope.poll)
            return not decision.is_self_decided()

        return filter(is_overriden_by_own_decision, delegations)

    # REFACT: this method apears to do the same as
    #         filter_less_specific_delegations (modulo the pre-work
    #         that happens before it is called)
    def _filter_out_delegations_where_a_more_specific_delegation_exists(
            self, delegations):
        def is_overriden_by_other_delegation(delegation):
            node = DelegationNode(delegation.principal, self.delegateable)
            outbound_delegations = node.outbound()
            if 1 == len(outbound_delegations):
                # If this returns false, the data model is invalid!
                return outbound_delegations[0].agent == self.user
            elif len(outbound_delegations) > 1:
                smallest_delegations = [outbound_delegations[0]]
                for delegation in outbound_delegations:
                    scope = smallest_delegations[0].scope
                    if scope.is_super(delegation.scope):
                        smallest_delegations = [delegation]
                    elif scope == delegation.scope:
                        smallest_delegations.append(delegation)
                for delegation in smallest_delegations:
                    if delegation.agent == self.user:
                        return True
            return False

        return filter(is_overriden_by_other_delegation, delegations)

########NEW FILE########
__FILENAME__ = tally
from datetime import datetime


class SimpleTally(object):
    """ A tally class without any backend to get data from. """
    def __init__(self, poll, num_for, num_against, num_abstain):
        self.poll = poll
        self.num_for = num_for
        self.num_against = num_against
        self.num_abstain = num_abstain

    def to_dict(self):
        return {
            'num_for': self.num_for,
            'num_against': self.num_against,
            'num_abstain': self.num_abstain,
        }


def make_from_poll(tally_cls, poll, at_time=None, user_filter=None):
    from adhocracy.lib.democracy import Decision
    from adhocracy.model import Vote
    if at_time is None:
        at_time = datetime.utcnow()
    results = {}
    decisions = Decision.for_poll(poll, at_time=at_time,
                                  user_filter=user_filter)
    for decision in decisions:
        if not decision.is_decided():
            continue
        results[decision.result] = results.get(decision.result, 0) + 1
    tally = tally_cls(poll,
                      results.get(Vote.YES, 0),
                      results.get(Vote.NO, 0),
                      results.get(Vote.ABSTAIN, 0))
    tally.create_time = at_time
    return tally

########NEW FILE########
__FILENAME__ = formatting
# coding: utf-8
import cgi
import logging

from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import helpers as h
from adhocracy.lib.event.types import (S_INSTANCE, S_VOTE, S_DELEGATION_IN,
    S_DELEGATION_OUT, S_PROPOSAL, S_AMENDMENT, S_COMMENT, S_PAGE, S_BADGE,
    S_MESSAGE)

log = logging.getLogger(__name__)
DT_FORMAT = "%Y%m%d%H%M%S"


class ObjectFormatter(object):

    def unicode(self, value):
        return value

    def html(self, value):
        return value


class DelegateableFormatter(ObjectFormatter):

    def unicode(self, delegateable):
        return delegateable.full_title

    def html(self, delegateable):
        return h.delegateable.link(delegateable)


class ProposalFormatter(DelegateableFormatter):
    pass


class PageFormatter(DelegateableFormatter):
    pass


class PollFormatter(ObjectFormatter):

    SELECT_PATTERN = lambda s, v, p: _("variant %(variant)s of %(page)s") % \
        {'variant': v,
         'page': p}

    def _get_formatter(self, poll):
        if isinstance(poll.subject, model.Comment):
            return CommentFormatter()
        if isinstance(poll.subject, model.Delegateable):
            return DelegateableFormatter()
        else:
            return unicode(poll.subject)

    def unicode(self, poll):
        if poll.action == poll.SELECT and poll.selection:
            text = poll.selection.page.variant_head(poll.variant)
            return self.SELECT_PATTERN(text.variant_name,
                                       poll.selection.page.title)
        else:
            fmt = self._get_formatter(poll)
            return fmt.unicode(poll.subject)

    def html(self, poll):
        if poll.action == poll.SELECT:
            text = poll.selection.page.variant_head(poll.variant)
            variant_link = "<a href='%s'>%s</a>" % (h.text.url(text),
                                                    text.variant_html)
            page_link = h.page.link(poll.selection.page)
            return self.SELECT_PATTERN(variant_link, page_link)
        else:
            fmt = self._get_formatter(poll)
            return fmt.html(poll.subject)


class InstanceFormatter(ObjectFormatter):

    def unicode(self, instance):
        return instance.label

    def html(self, instance):
        return u"<a class='event_instance' href='%s'>%s</a>" % (
            h.entity_url(instance),
            instance.label)


class UserFormatter(ObjectFormatter):

    def unicode(self, user):
        return user.name

    def html(self, user):
        return h.user.link(user)


class GroupFormatter(ObjectFormatter):

    def unicode(self, group):
        return _(group.group_name)

    def html(self, group):
        return self.unicode(group)


class VoteFormatter(ObjectFormatter):

    def unicode(self, vote):
        return {1: _("is for"),
                0: _("abstains on"),
                -1: _("is against")}[vote.orientation]

    def html(self, value):
        return {
            1: u'%s <span class="pro">%s </span>' % (
                _(u'is'), _(u'for')),
            0: _(u'abstains on'),
            -1: u'%s <span class="con">%s </span>' % (
                _(u'is'), _(u'against')),
        }[value.orientation]


class CommentFormatter(ObjectFormatter):

    def unicode(self, comment):
        if h.comment.wording():
            return _("comment on %s" % comment.topic.title)
        else:
            return _("argument on %s" % comment.topic.title)

    def html(self, comment):
        if comment.delete_time:
            return self.unicode(comment)
        return "<a href='%s'>%s</a>" % (h.entity_url(comment),
                                        cgi.escape(self.unicode(comment)))


class MessageFormatter(ObjectFormatter):

    def unicode(self, message):
        return message.subject

    def html(self, message):
        return '<a href="%s">%s</a>' % (h.entity_url(message),
                                        cgi.escape(self.unicode(message)))


class FormattedEvent(object):

    FORMATTERS = {model.Vote: VoteFormatter(),
                  model.Group: GroupFormatter(),
                  model.User: UserFormatter(),
                  model.Instance: InstanceFormatter(),
                  model.Proposal: ProposalFormatter(),
                  model.Poll: PollFormatter(),
                  model.Page: PageFormatter(),
                  model.Comment: CommentFormatter(),
                  model.Message: MessageFormatter()}

    def __init__(self, event, decoder):
        self.event = event
        self.decoder = decoder

    def __getitem__(self, item):
        try:
            value = self.event[item]
            for cls in self.FORMATTERS.keys():
                if isinstance(value, cls):
                    return self.decoder(self.FORMATTERS[cls], value)
            return value
        except AttributeError, ae:
            log.exception(ae)
            return _("(Undefined)")


def _format(event, decoder, msg=None):
    if not event.event:
        return _("(Undefined)")
    fe = FormattedEvent(event, decoder)
    if msg is None:
        msg = event.event.event_msg()
    return msg % fe


def as_unicode(event, msg=None):
    return _format(event, lambda f, value: f.unicode(value), msg)


def as_html(event, msg=None):
    return _format(event, lambda f, value: f.html(value), msg)


def as_icon(event, classes=''):
    if event.event.code in S_INSTANCE:
        icon = 'event-instance'
    elif event.event.code in S_PAGE:
        icon = 'event-page'
    elif event.event.code in S_COMMENT:
        icon = 'event-comment'
    elif event.event.code in S_PROPOSAL:
        icon = 'event-proposal'
    elif event.event.code in S_AMENDMENT:
        icon = 'event-amendment'
    elif event.event.code in S_DELEGATION_IN:
        icon = 'event-delegation-in'
    elif event.event.code in S_DELEGATION_OUT:
        icon = 'event-delegation-out'
    elif event.event.code in S_VOTE:
        icon = 'event-vote'
    elif event.event.code in S_BADGE:
        icon = 'event-badge'
    elif event.event.code == 't_massmessage_send':
        icon = 'event-massmessage'
    elif event.event.code in S_MESSAGE:
        icon = 'event-message'
    else:
        icon = 'event-unknown'

    return '<i class="icon-%s %s"></i>' % (icon, classes)

########NEW FILE########
__FILENAME__ = filters
from adhocracy.lib.event.types import (N_COMMENT_EDIT, N_COMMENT_REPLY,
                                       T_COMMENT_CREATE, T_COMMENT_EDIT)
from adhocracy.model import Notification, Event


def self_filter(pipeline):
    for notification in pipeline:
        if notification.type.notify_self:
            yield notification
        if not notification.event.user == notification.user:
            yield notification


def duplicates_filter(pipeline):
    recipient_map = {}
    for notification in pipeline:
        highest = recipient_map.get(notification.user)
        if (not highest) or (highest.priority <= notification.priority):
            recipient_map[notification.user] = notification
    for notification in recipient_map.values():
        yield notification


def hidden_instance_filter(pipeline):
    for notification in pipeline:
        # we cannot access notification.event directly as that would add
        # the notifications to the database, so we take a detour
        event = Event.find(notification.event.id)
        if event.instance is None or not event.instance.hidden:
            yield notification


def _map_pipeline(mapper):
    def _mapping(pipeline):
        for notification in pipeline:
            r = mapper(notification)
            if r:
                yield r
            else:
                yield notification
    return _mapping


def _comment_mapper(n):
    if n.type == T_COMMENT_EDIT:
        for rev in n.event.comment.revisions:
            if rev.user == n.user:
                return Notification(n.event,
                                    n.user,
                                    type=N_COMMENT_EDIT,
                                    watch=n.watch)
    if n.type == T_COMMENT_CREATE:
        def check_parent(comment):
            for rev in comment.revisions:
                if rev.user == n.user:
                    return Notification(n.event,
                                        n.user,
                                        type=N_COMMENT_REPLY,
                                        watch=n.watch)
            if comment.reply:
                return check_parent(comment.reply)
        if n.event.comment.reply:
            return check_parent(n.event.comment.reply)

comment_filter = _map_pipeline(_comment_mapper)

########NEW FILE########
__FILENAME__ = sinks
import logging

from webhelpers import text

from adhocracy import config
from adhocracy.lib import mail, microblog
from adhocracy.model import meta, Notification

TWITTER_LENGTH = 140
TRUNCATE_EXT = '...'

log = logging.getLogger(__name__)


def log_sink(pipeline):
    for notification in pipeline:
        log.debug("Generated notification: %s" % notification)
        yield notification


def twitter_sink(pipeline):
    twitter_enabled = bool(config.get('adhocracy.twitter.username', ''))
    for notification in pipeline:
        user = notification.user
        if (twitter_enabled and user.twitter
           and notification.priority >= user.twitter.priority):
            notification.language_context()
            short_url = microblog.shorten_url(notification.link)
            remaining_length = TWITTER_LENGTH - \
                (1 + len(short_url) + len(TRUNCATE_EXT))
            tweet = text.truncate(notification.subject, remaining_length,
                                  TRUNCATE_EXT, False)
            tweet += ' ' + short_url

            log.debug("twitter DM to %s: %s" % (user.twitter.screen_name,
                                                tweet))
            api = microblog.create_default()
            api.PostDirectMessage(user.twitter.screen_name, tweet)
        else:
            yield notification


def mail_sink(pipeline):
    for notification in pipeline:
        if notification.user.is_email_activated() and \
                notification.priority >= notification.user.email_priority:
            notification.language_context()
            headers = {'X-Notification-Id': notification.get_id(),
                       'X-Notification-Priority': str(notification.priority)}

            log.debug("mail to %s: %s" % (notification.user.email,
                                          notification.subject))
            mail.to_user(notification.user,
                         notification.subject,
                         notification.body,
                         headers=headers)

        else:
            yield notification


def database_sink(pipeline):
    for notification in pipeline:
        if meta.Session.query(Notification)\
                .filter(Notification.event_id == notification.event.id)\
                .filter(Notification.user_id == notification.user.id).all():
            log.warn('Notification already present: %s' % notification)
        else:
            meta.Session.add(notification)

        yield notification

########NEW FILE########
__FILENAME__ = sources
from adhocracy.model import Notification
from adhocracy.lib import democracy, watchlist
from adhocracy.lib.event.types import (
    N_COMMENT_EDIT,
    N_DELEGATE_CONFLICT, N_DELEGATE_VOTED,
    N_DELEGATION_LOST, N_DELEGATION_RECEIVED,
    N_INSTANCE_FORCE_LEAVE, N_INSTANCE_MEMBERSHIP_UPDATE,
    N_SELF_VOTED,
    T_COMMENT_EDIT,
    T_DELEGATION_CREATE, T_DELEGATION_REVOKE,
    T_INSTANCE_FORCE_LEAVE, T_INSTANCE_MEMBERSHIP_UPDATE,
    T_RATING_CAST, T_SELECT_VARIANT, T_VOTE_CAST)


def watchlist_source(event):
    watches = watchlist.traverse_watchlist(event.user)
    for topic in event.topics:
        watches += watchlist.traverse_watchlist(topic)
    for watch in watches:
        yield Notification(event, watch.user, watch=watch)


def vote_source(event):
    """
    Notify users about their voting behaviour, especially about
    delegated votes.
    """
    if event.event in [T_VOTE_CAST, T_SELECT_VARIANT, T_RATING_CAST]:
        decision = democracy.Decision(event.user, event.poll)
        before = decision.without_vote(event.vote)
        if (map(lambda v: v.delegation, decision.relevant_votes) ==
            map(lambda v: v.delegation, before.relevant_votes)) and \
           (before.result == decision.result):
            return
        if not decision.is_decided():
            yield Notification(event, event.user, type=N_DELEGATE_CONFLICT)
        elif decision.is_self_decided():
            yield Notification(event, event.user, type=N_SELF_VOTED)
        else:
            yield Notification(event, event.user, type=N_DELEGATE_VOTED)


def delegation_source(event):
    """
    Notify users of gained and lost delegations.
    """
    if event.event == T_DELEGATION_CREATE:
        yield Notification(event, event.agent, type=N_DELEGATION_RECEIVED)
    elif event.event == T_DELEGATION_REVOKE:
        yield Notification(event, event.agent, type=N_DELEGATION_LOST)


def instance_source(event):
    """
    Notify users of changes in their instance membership.
    """
    if event.event == T_INSTANCE_FORCE_LEAVE:
        yield Notification(event, event.user,
                           type=N_INSTANCE_FORCE_LEAVE)
    elif event.event == T_INSTANCE_MEMBERSHIP_UPDATE:
        yield Notification(event, event.user,
                           type=N_INSTANCE_MEMBERSHIP_UPDATE)


def tag_source(event):
    watches = []
    for topic in event.topics:
        for (tag, count) in topic.tags:
            watches = watchlist.traverse_watchlist(tag)
    for watch in set(watches):
        yield Notification(event, watch.user, watch=watch)


def comment_source(event):
    if event.event == T_COMMENT_EDIT:
        for revision in event.comment.revisions:
            yield Notification(event,
                               revision.user,
                               type=N_COMMENT_EDIT)
    if 'comment' in event.data:
        for watch in watchlist.traverse_watchlist(event.comment):
            yield Notification(event, watch.user, watch=watch)

########NEW FILE########
__FILENAME__ = rss
from pylons import response

from webhelpers.feedgenerator import Rss201rev2Feed as Feed

from adhocracy.lib import pager
from adhocracy.lib.event import formatting


def rss_feed(events, name, link, description):
    rss = Feed(name, link.encode('utf-8'), description)

    def event_item(event):
        try:
            item_link = event.event.link_path(event, absolute=True)
        except:
            item_link = link

        rss.add_item(title=u"%s %s" % (event.user.name,
                                       formatting.as_unicode(event)),
                     link=item_link.encode('utf-8'),
                     pubdate=event.time,
                     description=event.text(),
                     author_name=event.user.name,
                     unique_id=item_link)

    response.content_type = 'application/rss+xml'
    pager.NamedPager('rss', events, event_item, size=50).here()
    return rss.writeString('utf-8')

########NEW FILE########
__FILENAME__ = stats
from datetime import datetime, timedelta
import logging
import math

from adhocracy import model
from adhocracy.lib.cache import memoize
from adhocracy.lib.util import timedelta2seconds

log = logging.getLogger(__name__)


def activity(query_filter, from_time=None, to_time=None):
    if not to_time:
        to_time = datetime.utcnow()
    if not from_time:
        from_time = to_time - timedelta(days=30)
    base_age = timedelta2seconds(to_time - from_time)

    query = model.meta.Session.query(model.Event.time)
    query = query.filter(model.Event.time >= from_time)
    query = query.filter(model.Event.time <= to_time)
    query = query.order_by(model.Event.time.asc())
    query = query_filter(query)

    def evt_value(event_time):
        age = base_age - timedelta2seconds(to_time - event_time)
        return math.log(max(1, age))

    act = sum([evt_value(row[0]) for row in query])
    return act


@memoize('instance_activity', 86400)
def instance_activity(instance, from_time=None, to_time=None):
    def query_filter(q):
        return q.filter(model.Event.instance == instance)
    return activity(query_filter, from_time, to_time)


@memoize('user_activity', 86400)
def user_activity(instance, user, from_time=None, to_time=None):
    '''
    compute the user activity, either for a given
    :class:`adhocracy.model.Instance` *instance*, or across
    all instances if *instance* is `None`
    '''
    def query_filter(q):
        q = q.filter(model.Event.user == user)
        if instance is not None:
            q = q.filter(model.Event.instance == instance)
        return q
    return activity(query_filter, from_time, to_time)


@memoize('user_rating', 86400)
def user_rating(instance, user, from_time=None, to_time=None):
    '''
    simple score summing up the score of the users contributions
    for a given instance
    '''

    proposals = model.meta.Session.query(model.Proposal)\
        .filter(model.Proposal.creator == user)\
        .filter(model.Proposal.instance == instance)

    comments = model.meta.Session.query(model.Comment)\
        .filter(model.Comment.creator == user)\
        .join(model.Delegateable,
              model.Comment.topic_id == model.Delegateable.id)\
        .filter(model.Delegateable.instance == instance)

    rating = sum([p.rate_poll.tally.score for p in proposals])\
        + sum([c.poll.tally.score for c in comments])

    return rating

########NEW FILE########
__FILENAME__ = types
from pylons.i18n import _
from pylons.i18n import lazy_ugettext as L_

from adhocracy.lib import helpers as h

no_text = lambda e: None


class NotificationType(object):
    def __init__(self, code, pri, subject, link_path, text=no_text,
                 notify_self=False):
        self.code = code
        self.priority = pri
        self.subject = subject
        self.link_path = link_path
        self.text = text
        self.notify_self = notify_self

    def __str__(self):
        return self.code

    def __repr__(self):
        return self.code


class EventType(NotificationType):
    def __init__(self, code, pri, subject, link_path, event_msg,
                 text=no_text, notify_self=False):
        self.event_msg = event_msg
        super(EventType, self).__init__(code, pri, subject, link_path,
                                        text=text, notify_self=notify_self)


T_USER_CREATE = EventType(
    u"t_user_create", pri=5,
    subject=lambda: _(u"New user: %(user)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"signed up"))

T_USER_EDIT = EventType(
    u"t_user_edit", pri=4,
    subject=lambda: _(u"%(user)s: profile updated"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"edited their profile"),
    text=lambda e: e.user.bio,
    notify_self=True)

T_USER_ADMIN_EDIT = EventType(
    u"t_user_admin_edit", pri=4,
    subject=lambda: _(u"%(user)s: profile was edited by %(admin)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"had their profile updated by %(admin)s"),
    text=lambda e: e.user.bio,
    notify_self=True)

T_INSTANCE_CREATE = EventType(
    u"t_instance_create", pri=5,
    subject=lambda: _(u"New instance: %(instance)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"founded the %(instance)s instance"),
    text=lambda e: e.instance.description)

T_INSTANCE_EDIT = EventType(
    u"t_instance_edit", pri=4,
    subject=lambda: _(u"%(instance)s: instance was updated"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.instance, absolute=absolute)),
    event_msg=lambda: _(u"updated the %(instance)s instance"),
    text=lambda e: e.instance.description)

T_INSTANCE_DELETE = EventType(
    u"t_instance_delete", pri=4,
    subject=lambda: _(u"Deleted Adhocracy: %(instance)s"),
    link_path=lambda e, absolute=False: (
        h.base_url(instance=None, absolute=absolute)),
    event_msg=lambda: _(u"deleted the %(instance)s instance"))

T_INSTANCE_JOIN = EventType(
    u"t_instance_join", pri=1,
    subject=lambda: _(u"%(instance)s: %(user)s joined"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"joined %(instance)s"))

T_INSTANCE_LEAVE = EventType(
    u"t_instance_leave", pri=1,
    subject=lambda: _(u"%(instance)s: %(user)s left"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"left %(instance)s"))

T_INSTANCE_FORCE_LEAVE = EventType(
    u"t_instance_force_leave", pri=1,
    subject=lambda: _(u"%(instance)s: %(user)s was forced to leave"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"was forced to leave %(instance)s by %(admin)s"))

T_INSTANCE_MEMBERSHIP_UPDATE = EventType(
    u"t_instance_membership_update", pri=1,
    subject=lambda: _(u"%(instance)s: %(user)s is now a %(group)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.user, absolute=absolute)),
    event_msg=lambda: _(u"now is a %(group)s within %(instance)s"))

T_PROPOSAL_CREATE = EventType(
    u"t_proposal_create", pri=5,
    subject=lambda: _(u"New proposal: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.proposal, absolute=absolute)),
    event_msg=lambda: _(u"created %(proposal)s"),
    text=lambda e: e.rev.text if e.rev else None)

T_PROPOSAL_EDIT = EventType(
    u"t_proposal_edit", pri=4,
    subject=lambda: _(u"Edit proposal: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.proposal, absolute=absolute)),
    text=lambda e: e.rev.text if e.text else None,
    event_msg=lambda: _(u"edited %(proposal)s"))

T_PROPOSAL_BADGE = EventType(
    u"t_proposal_badge", pri=4,
    subject=lambda: _(u"Proposal badged: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.proposal, absolute=absolute)),
    event_msg=lambda: _(u"badged %(proposal)s"))

T_PROPOSAL_STATE_REDRAFT = EventType(
    u"t_proposal_state_draft", pri=4,
    subject=lambda: _(u"Poll cancelled: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.proposal, absolute=absolute)),
    event_msg=lambda: _(u"re-drafted %(proposal)s"))

T_PROPOSAL_STATE_VOTING = EventType(
    u"t_proposal_state_voting", pri=4,
    subject=lambda: _(u"New Poll: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.proposal, absolute=absolute)),
    event_msg=lambda: _(u"called a vote on %(proposal)s"))

T_PROPOSAL_DELETE = EventType(
    u"t_proposal_delete", pri=4,
    subject=lambda: _(u"Deleted proposal: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.instance, absolute=absolute)),
    event_msg=lambda: _(u"deleted %(proposal)s"))

T_AMENDMENT_CREATE = EventType(
    u"t_amendment_create", pri=5,
    subject=lambda: _(u"New amendment to %(page)s: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.amendment, absolute=absolute)),
    event_msg=lambda: _(u"created amendment %(proposal)s to %(page)s"),
    text=lambda e: e.rev.text if e.rev else None)

T_AMENDMENT_EDIT = EventType(
    u"t_amendment_edit", pri=4,
    subject=lambda: _(u"Edit amendment to %(page)s: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.amendment, absolute=absolute)),
    text=lambda e: e.rev.text if e.text else None,
    event_msg=lambda: _(u"edited amendment %(proposal)s to %(page)s"))

T_AMENDMENT_DELETE = EventType(
    u"t_amendment_delete", pri=4,
    subject=lambda: _(u"Deleted amendment to %(page)s: %(proposal)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.instance, absolute=absolute)),
    event_msg=lambda: _(u"deleted amendment %(proposal)s to %(page)s"))

T_PAGE_CREATE = EventType(
    u"t_page_create", pri=5,
    subject=lambda: _(u"New page: %(page)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.page, absolute=absolute)),
    event_msg=lambda: _(u"created %(page)s"),
    text=lambda e: e.rev.text if e.rev else None)

T_PAGE_EDIT = EventType(
    u"t_page_edit", pri=4,
    subject=lambda: _(u"Edit page: %(page)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.page, absolute=absolute)),
    text=lambda e: e.rev.text if e.rev else None,
    event_msg=lambda: _(u"edited %(page)s"))

T_PAGE_DELETE = EventType(
    u"t_page_delete", pri=4,
    subject=lambda: _(u"Deleted page: %(page)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.instance, absolute=absolute)),
    event_msg=lambda: _(u"deleted %(page)s"))

T_COMMENT_CREATE = EventType(
    u"t_comment_create", pri=3,
    subject=(lambda: _(u"New comment: in %(topic)s")
             if h.comment.wording() else _(u"New argument: in %(topic)s")),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.comment, absolute=absolute)),
    event_msg=(lambda: _(u"commented on %(topic)s")
               if h.comment.wording() else _(u"discussed %(topic)s")),
    text=lambda e: e.rev.text if e.rev else None)

T_COMMENT_EDIT = EventType(
    u"t_comment_edit", pri=4,
    subject=(lambda: _(u"Edited comment: in %(topic)s")
             if h.comment.wording() else _(u"Edited argument: in %(topic)s")),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.comment, absolute=absolute)),
    event_msg=(lambda: _(u"edited comment on %(topic)s")
               if h.comment.wording()
               else _(u"edited argument about %(topic)s")),
    text=lambda e: e.rev.text if e.rev else None)

T_COMMENT_DELETE = EventType(
    u"t_comment_delete", pri=4,
    subject=(lambda: _(u"Deleted comment: in %(topic)s")
             if h.comment.wording() else _(u"Deleted argument: in %(topic)s")),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.topic, absolute=absolute)),
    event_msg=(lambda: _(u"deleted comment from %(topic)s")
               if h.comment.wording()
               else _(u"deleted argument from %(topic)s")))

T_DELEGATION_CREATE = EventType(
    u"t_delegation_create", pri=2,
    subject=lambda: _(u"New Delegation: %(user)s delegated "
                      "%(scope)s to %(agent)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.delegation, absolute=absolute)),
    event_msg=lambda: _(u"delegated voting on %(scope)s to %(agent)s"))

T_DELEGATION_REVOKE = EventType(
    u"t_delegation_revoke", pri=2,
    subject=lambda: _(u"Revoked Delegation: %(user)s revoked delegation "
                      "to %(agent)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.delegation, absolute=absolute)),
    event_msg=lambda: _(u"revoked their delegation on %(scope)s to %(agent)s"))

T_VOTE_CAST = EventType(
    u"t_vote_cast", pri=2,
    subject=lambda: _(u"Vote: %(user)s %(vote)s %(poll)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.poll.subject, absolute=absolute)),
    event_msg=lambda: _(u"%(vote)s %(poll)s"))

T_RATING_CAST = EventType(
    u"t_rating_cast", pri=2,
    subject=lambda: _(u"Rating: %(user)s %(vote)s %(poll)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.poll.subject, absolute=absolute)),
    event_msg=lambda: _(u"%(vote)s %(poll)s"))

T_SELECT_VARIANT = EventType(
    u"t_select_variant", pri=2,
    subject=lambda: _(u"Variants: %(user)s %(vote)s %(poll)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.poll.selection, absolute=absolute)),
    event_msg=lambda: _(u"%(vote)s %(poll)s"))

T_MESSAGE_SEND = EventType(
    u"t_message_send", pri=1,
    subject=lambda: _(u"Message sent: %(message)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.message, absolute=absolute)),
    event_msg=lambda: _(u"sent message: \"%(message)s\""))

T_MASSMESSAGE_SEND = EventType(
    u"t_massmessage_send", pri=1,
    subject=lambda: _(u"Message sent: %(message)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.message, absolute=absolute)),
    event_msg=lambda: _(u"sent message: \"%(message)s\""))

T_TEST = EventType(
    u"t_test", pri=6,
    subject=lambda: _(u"Adhocracy says hello: %(test)s"),
    link_path=lambda e: "/",
    event_msg=lambda: _(u"test %(test)s"))


N_DELEGATION_RECEIVED = NotificationType(
    "n_delegation_receive", pri=2,
    subject=lambda: _(u"You received %(user)ss delegation on %(scope)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.scope, absolute=absolute)))

N_DELEGATION_LOST = NotificationType(
    "n_delegation_lost", pri=2,
    subject=lambda: _(u"You lost %(user)ss delegation on %(scope)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.scope, absolute=absolute)))

N_INSTANCE_FORCE_LEAVE = NotificationType(
    "n_instance_force_leave", pri=1,
    subject=lambda: _(u"Membership: You've been kicked from %(instance)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.instance, absolute=absolute)),
    notify_self=True)

N_INSTANCE_MEMBERSHIP_UPDATE = NotificationType(
    "n_instance_membership_update", pri=1,
    subject=lambda: _(u"Membership: you're now a %(group)s in %(instance)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.instance, absolute=absolute)),
    notify_self=True)

N_SELF_VOTED = NotificationType(
    "n_self_voted", pri=2,
    subject=lambda: _(u"Your vote %(vote)s %(poll)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.poll.subject, absolute=absolute)),
    notify_self=True)

N_DELEGATE_VOTED = NotificationType(
    "n_delegate_voted", pri=2,
    subject=lambda: _(u"Your delegate %(agent)s %(vote)s %(poll)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.poll.subject, absolute=absolute)),
    notify_self=True)

N_DELEGATE_CONFLICT = NotificationType(
    "n_delegate_conflict", pri=2,
    subject=lambda: _(u"Delegation conflict regarding %(poll)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.poll.subject, absolute=absolute)),
    notify_self=True)

N_COMMENT_REPLY = NotificationType(
    "n_comment_reply", pri=3,
    subject=lambda: _(u"Comment Reply: %(topic)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.comment, absolute=absolute)),
    text=lambda e: e.rev.text if e.rev else None)

N_COMMENT_EDIT = NotificationType(
    "n_comment_edit", pri=4,
    subject=lambda: _(u"Comment Edit: %(topic)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.comment, absolute=absolute)),
    text=lambda e: e.rev.text if e.rev else None)

N_MESSAGE_RECEIVE = NotificationType(
    u"n_message_receive", pri=1,
    subject=lambda: _(u"Message from %(sender)s: %(message)s"),
    link_path=lambda e, absolute=False: (
        h.entity_url(e.message, absolute=absolute)))


# Sets
S_INSTANCE = [
    't_instance_create',
    't_instance_edit',
    't_instance_membership_update',
    'n_instance_membership_update',
    't_instance_join',
    't_instance_leave',
    't_instance_delete',
    'n_instance_force_leave',
    't_instance_force_leave',
]

S_VOTE = [
    't_vote_cast',
    't_rating_cast',
    'n_delegate_voted',
]

S_DELEGATION_IN = [
    't_delegation_create',
    't_delegation_revoke',
]

S_DELEGATION_OUT = [
    'n_delegation_receive',
    'n_delegation_lost',
]

S_DELEGATION = S_DELEGATION_IN + S_DELEGATION_OUT

S_PROPOSAL = [
    't_proposal_create',
    't_proposal_edit',
    't_proposal_delete',
    't_proposal_state_voting',
    't_proposal_state_draft',
]

S_AMENDMENT = [
    't_amendment_create',
    't_amendment_edit',
    't_amendment_delete',
]

S_COMMENT = [
    't_comment_edit',
    't_comment_create',
    't_comment_delete',
    'n_comment_reply',
    'n_comment_edit',
]

S_PAGE = [
    't_page_create',
    't_page_edit',
    't_page_delete',
]

S_BADGE = [
    't_proposal_badge',
]

S_MESSAGE = [
    't_message_send',
    't_massmessage_send',
    'n_message_receive',
]

S_CONTRIBUTION = S_PROPOSAL + S_AMENDMENT + S_COMMENT + S_PAGE


TYPE_MAPPINGS = dict([(v.code, v) for v in locals().values()
                      if isinstance(v, NotificationType)])
TYPES = TYPE_MAPPINGS.values()

TOPIC_TYPES = {
    "t_user_create": L_('User'),
    "t_user_edit": L_('User'),
    "t_user_admin_edit": L_('User'),
    "t_instance_create": L_('Instance'),
    "t_instance_edit": L_('Instance'),
    "t_instance_delete": L_('Instance'),
    "t_instance_join": L_('Instance'),
    "t_instance_leave": L_('Instance'),
    "t_instance_force_leave": L_('Instance'),
    "t_instance_membership_update": L_('Membership'),
    "t_proposal_create": L_('Proposal'),
    "t_proposal_edit": L_('Proposal'),
    "t_proposal_badge": L_('Proposal'),
    "t_proposal_state_draft": L_('Proposal'),
    "t_proposal_state_voting": L_('Proposal'),
    "t_proposal_delete": L_('Proposal'),
    "t_amendment_create": L_('Amendment'),
    "t_amendment_edit": L_('Amendment'),
    "t_amendment_delete": L_('Amendment'),
    "t_page_create": L_('Page'),
    "t_page_edit": L_('Page'),
    "t_page_delete": L_('Page'),
    "t_comment_create": L_('Comment'),
    "t_comment_edit": L_('Comment'),
    "t_comment_delete": L_('Comment'),
    "t_delegation_create": L_('Delegation'),
    "t_delegation_revoke": L_('Delegation'),
    "t_vote_cast": L_('Vote'),
    "t_rating_cast": L_('Rating'),
    "t_select_variant": L_('Variant'),
    "t_message_send": L_('Message'),
    "t_massmessage_send": L_('Massmessage'),
    "t_test": L_('Test'),
    "n_delegation_receive": L_('Delegation'),
    "n_delegation_lost": L_('Delegation'),
    "n_instance_force_leave": L_('Membership'),
    "n_instance_membership_update": L_('Membership'),
    "n_self_voted": L_('Vote'),
    "n_delegate_voted": L_('Vote'),
    "n_delegate_conflict": L_('Vote'),
    "n_comment_reply": L_('Comment'),
    "n_comment_edit": L_('Comment'),
    "n_message_receive": L_('Message'),
}
VERBS = {
    "t_user_create": L_('created'),
    "t_user_edit": L_('edited'),
    "t_user_admin_edit": L_('edited'),
    "t_instance_create": L_('created'),
    "t_instance_edit": L_('edited'),
    "t_instance_delete": L_('delete'),
    "t_instance_join": L_('joined'),
    "t_instance_leave": L_('left'),
    "t_instance_force_leave": L_('left'),
    "t_instance_membership_update": L_('updated'),
    "t_proposal_create": L_('created'),
    "t_proposal_edit": L_('edited'),
    "t_proposal_badge": L_('badged'),
    "t_proposal_state_draft": L_('changed state'),
    "t_proposal_state_voting": L_('changed state'),
    "t_proposal_delete": L_('deleted'),
    "t_amendment_create": L_('created'),
    "t_amendment_edit": L_('edited'),
    "t_amendment_delete": L_('deleted'),
    "t_page_create": L_('created'),
    "t_page_edit": L_('edited'),
    "t_page_delete": L_('deleted'),
    "t_comment_create": L_('created'),
    "t_comment_edit": L_('edited'),
    "t_comment_delete": L_('deleted'),
    "t_delegation_create": L_('created'),
    "t_delegation_revoke": L_('revoked'),
    "t_vote_cast": L_('casted'),
    "t_rating_cast": L_('casted'),
    "t_select_variant": L_('selected'),
    "t_message_send": L_('sent'),
    "t_massmessage_send": L_('sent'),
    "t_test": L_('tested'),
    "n_delegation_receive": L_('received'),
    "n_delegation_lost": L_('lost'),
    "n_instance_force_leave": L_('left'),
    "n_instance_membership_update": L_('updated'),
    "n_self_voted": L_('casted'),
    "n_delegate_voted": L_('casted'),
    "n_delegate_conflict": L_('conflicted'),
    "n_comment_reply": L_('replied'),
    "n_comment_edit": L_('edited'),
    "n_message_receive": L_('received'),
}

########NEW FILE########
__FILENAME__ = exceptions

class DatabaseInconsistent(Exception):
    """This Exception should be raised when
    the data doesn't make sense."""

########NEW FILE########
__FILENAME__ = abuse_helper
from pylons import tmpl_context as c

from adhocracy.lib.helpers import url as _url


def for_entity(entity):
    from adhocracy.lib.helpers import entity_url
    return for_url(entity_url(entity, absolute=True))


def for_url(url):
    instance = c.instance if c.instance else None
    return _url.build(instance, 'abuse', 'new', query={'url': url})

########NEW FILE########
__FILENAME__ = adhocracy_service
import requests
from collections import OrderedDict

from pylons import tmpl_context as c

from adhocracy import config
from adhocracy import i18n


def instance_staticpages_api_address():
    if c.instance is not None:
        key = 'adhocracy.instance-%s.staticpages.rest_api_address'
        return config.get(key % c.instance.key, '')
    else:
        return ''


def staticpages_api_address():
    ret = instance_staticpages_api_address()
    if ret == '':
        ret = config.get('adhocracy_service.staticpages.rest_api_address')
    if ret == '':
        ret = config.get('adhocracy_service.rest_api_address')
    return ret


class RESTAPI(object):
    """Helper to work with the adhocarcy_service rest api
       (adhocracy_kotti.mediacenter, adhocracy_kotti.staticpages, plone).
    """

    session = requests.Session()

    def __init__(self):
        self.staticpages_api_token = config.get(
            'adhocracy_service.staticpages.rest_api_token',
            config.get('adhocracy_service.rest_api_token'))
        self.staticpages_api_address = staticpages_api_address()
        self.staticpages_verify = config.get_bool(
            'adhocracy_service.staticpages.verify_ssl',
            config.get_bool('adhocracy_service.verify_ssl'))
        self.staticpages_headers = {"X-API-Token": self.staticpages_api_token}

    def staticpages_get(self, base=None, languages=None):
        if languages is None:
            languages = i18n.all_languages(include_preferences=True)
        params = OrderedDict({
            'lang': languages
        })
        if base is not None:
            params['base'] = base
        request = requests.Request("GET",
                                   url='%s%s' % (
                                       self.staticpages_api_address,
                                       "staticpages",
                                   ),
                                   params=params,
                                   headers=self.staticpages_headers)
        return self.session.send(request.prepare(),
                                 verify=self.staticpages_verify)

    def staticpage_get(self, path, languages=None):
        if languages is None:
            languages = i18n.all_languages(include_preferences=True)
        request = requests.Request("GET",
                                   url='%s%s' % (
                                       self.staticpages_api_address,
                                       'staticpages/single',
                                   ),
                                   params=OrderedDict({
                                       'path': path,
                                       'lang': languages,
                                   }),
                                   headers=self.staticpages_headers)

        return self.session.send(request.prepare(),
                                 verify=self.staticpages_verify)

########NEW FILE########
__FILENAME__ = badge_helper
from base64 import b64encode
from hashlib import sha1
from io import BytesIO
from PIL import Image, ImageDraw

from pylons.i18n import _

from adhocracy import config
from adhocracy.lib import cache
from adhocracy.lib.helpers import url as _url


def make_key(iden, args, kwargs):
    instance = args[0].instance
    instance_w = instance and instance.thumbnailbadges_width or ""
    instance_h = instance and instance.thumbnailbadges_height or ""
    sig = iden[:200]\
        + cache.util.make_tag(config.get("adhocracy.thumbnailbadges.width"))\
        + cache.util.make_tag(config.get("adhocracy.thumbnailbadges.height"))\
        + cache.util.make_tag(instance_w)\
        + cache.util.make_tag(instance_h)\
        + cache.util.make_tag(args) \
        + cache.util.make_tag(kwargs)
    return sha1(sig).hexdigest()


@cache.memoize('badge_thumbnail', make_key=make_key)
def generate_thumbnail_tag(badge, width=0, height=0):
    """Returns string with the badge thumbnail img tag
       The image is resized and converted to PNG.
    """
    # NOTE Generated image is not Working with IE < 8, joka
    # TODO use real image links instead of URI:data

    size = (width and height) and (width, height)\
        or get_default_thumbnailsize(badge)
    img_template = ('<img src="data:%s;base64,%s" width="%s" height="%s"'
                    'alt="%s"/>')
    imagefile = BytesIO(badge.thumbnail)
    mimetype = "image/png"
    try:
        # resize image
        im = Image.open(imagefile)
        mimetype = "image/" + im.format.lower()
        im.thumbnail(size, Image.ANTIALIAS)
        # optimize image but preserve transparency
        im.load()
        im_opti = Image.new("RGB", im.size, (255, 255, 255))
        if len(im.split()) > 3:
            im_opti.paste(im, mask=im.split()[3])
        else:
            im_opti.paste(im)
        # save image
        f = BytesIO()
        im_opti.save(f, 'PNG')
        del im, im_opti, imagefile
        imagefile = f
    except IOError:
        color = badge.color or u"#ffffff"
        im = Image.new('RGB', (5, 5))
        draw = ImageDraw.Draw(im)
        draw.rectangle((0, 0, 5, 5), fill=color, outline=color)
        im = im.convert('P', colors=1, palette=Image.ADAPTIVE)
        f = BytesIO()
        im.save(f, "PNG")
        del draw, im
        imagefile = f
    data_enc = b64encode(imagefile.getvalue())
    del imagefile

    return (img_template % (mimetype, data_enc, str(size[0]), str(size[1]),
                            badge.title))


def get_default_thumbnailsize(badge):
    instance = badge.instance
    global_w = config.get_int("adhocracy.thumbnailbadges.width", 48)
    global_h = config.get_int("adhocracy.thumbnailbadges.height", 48)
    ins_w = instance and instance.thumbnailbadges_width
    ins_h = instance and instance.thumbnailbadges_height
    return (ins_w or global_w, ins_h or global_h)


def get_parent_badges(badge):
    """Returns a generator with all parent badges
       in hierachical order (root last)
    """
    if hasattr(badge, "parent") and badge.parent:
        parent = badge.parent
        yield parent
        for p in get_parent_badges(parent):
            yield p


def breadcrumbs(badge=None):
    from adhocracy.lib.helpers import base_url
    items = []
    items.append(_url.link(_("Badges"), base_url(u'/badge')))
    return _url.root() + _url.BREAD_SEP.join(items)

########NEW FILE########
__FILENAME__ = captchasdotnet_helper
"""
Helper module for captchas from captchas.net
"""

from adhocracy import config
from adhocracy.lib.captchasdotnet import CaptchasDotNet


def get_captchasdotnet():
    return CaptchasDotNet(
        client=config.get('captchasdotnet.user_name'),
        secret=config.get('captchasdotnet.secret'),
        alphabet=config.get('captchasdotnet.alphabet'),
        letters=config.get_int('captchasdotnet.letters'),
        width=240,
        height=80,
        random_repository=config.get('captchasdotnet.random_repository'),
        cleanup_time=3600
    )

########NEW FILE########
__FILENAME__ = category_helper
from pylons import tmpl_context as c
from pylons.i18n import _

from sqlalchemy.orm import aliased

from adhocracy import model
from adhocracy.lib import cache
from adhocracy.lib import logo
from adhocracy.lib.helpers import url as _url


def logo_url(category, y, x=None):
    from adhocracy.lib.helpers import base_url
    size = "%s" % y if x is None else "%sx%s" % (x, y)
    filename = u"%s_%s.png" % (category.id, size)
    (path, mtime) = logo.path_and_mtime(category)
    return base_url(u'/category/%s' % filename, query_params={'t': str(mtime)})


def url(category, member=None, **kwargs):
    return _url.build(category.instance, 'category', category.id,
                      member=member, **kwargs)


@cache.memoize('category_bc')
def bc_entity(category):
    return _url.BREAD_SEP + _url.link(category.title, url(category))


def breadcrumbs(category):
    from adhocracy.lib.helpers import base_url
    bc = _url.root()
    bc += _url.link(_("Categories"), base_url(u'/category'))
    if category is not None:
        bc += bc_entity(category)
    return bc


def event_q(category, event_filter=[], count=50):
    """Get events related to this category.

    This is not trivial with our current models. For example this query does
    only include one level of page nesting.
    """
    alias = aliased(model.Delegateable)

    proposal_description_q = model.meta.Session.query(model.Delegateable.id)\
        .join(model.Page._proposal)\
        .join(alias, alias.id == model.Proposal.id)\
        .join(alias.categories)

    page_child_q = model.meta.Session.query(model.Delegateable.id)\
        .join(alias, model.Delegateable.parents)\
        .join(alias.categories)

    topic_ids_q = model.meta.Session.query(model.Delegateable.id)\
        .join(model.Delegateable.categories)\
        .union(proposal_description_q)\
        .union(page_child_q)\
        .distinct()\
        .filter(model.Delegateable.instance == c.instance)\
        .filter(model.CategoryBadge.id == category.id)

    events = model.Event.all_q(
        instance=c.instance,
        include_hidden=False,
        event_filter=event_filter)\
        .join(model.Event.topics)\
        .filter(model.Delegateable.id.in_(topic_ids_q))\
        .order_by(model.Event.time.desc())\
        .limit(count)

    return events

########NEW FILE########
__FILENAME__ = comment_helper
from paste.deploy.converters import asbool
from pylons import config

from adhocracy import model
from adhocracy.lib import cache
from adhocracy.lib.helpers import proposal_helper as proposal
from adhocracy.lib.helpers import page_helper as page
from adhocracy.lib.helpers import text_helper as text
from adhocracy.lib.helpers import url as _url


@cache.memoize('comment_url')
def url(comment, member=None, format=None, comment_page=False,
        in_overlay=True, **kwargs):
    if member is None and format is None and not comment_page:
        if isinstance(comment.topic, model.Page):
            if comment.topic.function == model.Page.DESCRIPTION:
                return (proposal.url(comment.topic.proposal,
                                     anchor=u'c%i' % comment.id, **kwargs))
            if comment.topic.is_sectionpage():
                if u'anchor' not in kwargs:
                    kwargs[u'anchor'] = u'c%i' % comment.id
                if in_overlay:
                    kwargs[u'format'] = u'overlay'
                    query = {
                        u'overlay_path': page.url(comment.topic,
                                                  member=u'comments',
                                                  **kwargs),
                        u'overlay_type': u'#overlay-url',
                    }
                    return page.url(comment.topic.sectionpage_root(),
                                    query=query)
                else:
                    return page.url(comment.topic, member=u'comments',
                                    **kwargs),
            return (text.url(comment.topic.variant_head(comment.variant),
                             anchor=u'c%i' % comment.id, **kwargs))
        elif isinstance(comment.topic, model.Proposal):
            return (proposal.url(comment.topic, anchor=u'c%i' % comment.id,
                                 **kwargs))
    return _url.build(comment.topic.instance, 'comment',
                      comment.id, member=member, format=format, **kwargs)


def wording(config=config):
    return asbool(config.get('adhocracy.comment_wording', False))

########NEW FILE########
__FILENAME__ = delegateable_helper
import cgi

from adhocracy import model
from adhocracy.lib import cache

import page_helper as page
import proposal_helper as proposal


@cache.memoize('delegateable_link')
def link(delegateable, link=True):
    if isinstance(delegateable, model.Proposal):
        return proposal.link(delegateable, link=link)
    elif isinstance(delegateable, model.Page):
        return page.link(delegateable, link=link)
    return cgi.escape(delegateable.title)


@cache.memoize('delegateable_bc')
def breadcrumbs(delegateable):
    if isinstance(delegateable, model.Proposal):
        return proposal.breadcrumbs(delegateable)
    elif isinstance(delegateable, model.Page):
        return page.breadcrumbs(delegateable)
    return cgi.escape(delegateable.title)

########NEW FILE########
__FILENAME__ = delegation_helper
from adhocracy.lib import cache
from adhocracy.lib.helpers import url as _url


@cache.memoize('delegation_url')
def url(delegation, **kwargs):
    return _url.build(delegation.scope.instance, 'delegation',
                      delegation.id, **kwargs)

########NEW FILE########
__FILENAME__ = fanstatic_helper
'''
helper functions to work with fanstatic
'''

from js.socialshareprivacy import library
import fanstatic


def get_socialshareprivacy_url():
    '''
    call this after you need()ed socialshareprivacy!
    Returns the url from which socialshareprivacy will be shipped.
    '''
    return fanstatic.get_needed().library_url(library)


def _get_resource(module, name):
    resource = getattr(module, name, None)
    if resource is None:
        raise AttributeError('"%s" does not exist' % name)
    if not isinstance(resource, (fanstatic.Resource, fanstatic.Group)):
        raise ValueError('"%s" is not a valid Resource' % name)
    return resource


class FanstaticNeedHelper(object):
    '''
    A helper class to access fanstatic resources
    defined in :module:`adhocracy.static`

    Use it this way::

        from adhocracy import static
        need = FanstaticNeedHelper(static)
        need.stylesheets

    where "stylesheets" is a fanstatic Resource or Group defined
    in adhocracy.static.
    '''

    def __init__(self, module):
        self.module = module
        self.dynamics = {}

    def __getattr__(self, name):
        return _get_resource(self.module, name).need()

########NEW FILE########
__FILENAME__ = feedback_helper
from adhocracy import config
from adhocracy import model
from adhocracy.lib.helpers import site_helper as _site


def is_configured():
    configured = config.get_bool('adhocracy.use_feedback_instance')
    if not configured:
        return False
    if not config.get_bool('adhocracy.feedback_check_instance'):
        return True
    return get_feedback_instance() is not None


def get_feedback_instance():
    return model.Instance.find(config.get('adhocracy.feedback_instance_key'))


def get_categories():
    if not config.get_bool('adhocracy.feedback_use_categories'):
        return []
    feedback_instance = get_feedback_instance()
    return model.CategoryBadge.all(feedback_instance, include_global=False)


def get_proposal_url():
    return _site.base_url(u'/proposal',
                          config.get('adhocracy.feedback_instance_key'))

########NEW FILE########
__FILENAME__ = instance_helper
from pylons.i18n import _

from adhocracy import config
from adhocracy import static
from adhocracy.lib import logo
from adhocracy.lib.helpers import url as _url


def url(instance, member=None, format=None, **kwargs):
    return _url.build(instance, 'instance', instance.key,
                      member=member, format=format, **kwargs)


def logo_url(instance, y, x=None):
    size = "%s" % y if x is None else "%sx%s" % (x, y)
    filename = "%s_%s.png" % (instance.key, size)
    (path, mtime) = logo.path_and_mtime(instance, fallback=logo.INSTANCE)
    return _url.build(instance, 'instance', filename, query={'t': str(mtime)})


def breadcrumbs(instance=None):
    bc = _url.root()
    return bc


def settings_breadcrumbs(instance, member=None):
    """member is a dict with the keys 'name' and 'label'."""
    bc = breadcrumbs(instance)
    bc += _url.link(_("Settings"), url(instance, member="settings"))
    if member is not None:
        bc += _url.BREAD_SEP + _url.link(
            member['label'],
            url(instance, member="settings/" + member['name']))
    return bc


def area_title(identifier):
    """identifier is typically the value of c.active_subheader_nav"""
    if identifier == 'proposals':
        return _("Proposals")
    elif identifier == 'milestones':
        return _("Milestones")
    elif identifier == 'norms':
        return _("Norms")
    elif identifier == 'category':
        return _("Categories")
    elif identifier == 'members':
        return _("Members")
    else:
        if config.get_bool('adhocracy.wording.intro_for_overview'):
            return _(u"Intro")
        else:
            return _(u"Overview")


def need_stylesheet(instance):
    stylesheets = config.get_list('adhocracy.instance_stylesheets')
    themes = config.get_list('adhocracy.instance_themes')
    if instance is not None and instance.key in stylesheets:
        return static.instance_stylesheet(instance.key).need()
    elif (instance is not None and instance.theme in themes and
            instance.is_authenticated):
        return static.instance_theme(instance.theme).need()
    else:
        return static.style.need()

########NEW FILE########
__FILENAME__ = message_helper
from adhocracy.lib import cache
from adhocracy.lib.helpers import url as _url


@cache.memoize('message_url', 3600)
def url(entity, **kwargs):
    return _url.build(entity.instance, 'message', entity.id, **kwargs)

########NEW FILE########
__FILENAME__ = milestone_helper
import cgi

from pylons.i18n import _

from adhocracy.lib import cache
from adhocracy.lib.helpers import url as _url


@cache.memoize('milestone_link', 3600)
def link(milestone, link=True, **kwargs):
    text = cgi.escape(milestone.title)
    if link and not milestone.is_deleted():
        text = u"<a href='%s'>%s</a>" % (url(milestone, **kwargs),
                                         text)
    return text


@cache.memoize('milestone_url', 3600)
def url(milestone, **kwargs):
    return _url.build(milestone.instance, 'milestone', milestone.id, **kwargs)


@cache.memoize('milestone_bc')
def bc_entity(milestone):
    return _url.BREAD_SEP + _url.link(milestone.title, url(milestone))


def breadcrumbs(milestone):
    bc = _url.root()
    bc += _url.link(_("Milestones"), u'/milestone')
    if milestone is not None:
        bc += bc_entity(milestone)
    return bc

########NEW FILE########
__FILENAME__ = page_helper
import cgi

from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import cache, logo
from adhocracy.lib.helpers import proposal_helper as proposal
from adhocracy.lib.helpers import url as _url


@cache.memoize('page_link')
def link(page, variant=model.Text.HEAD, link=True):
    import text_helper as text
    buf = cgi.escape(page.title)
    text_ = page.variant_head(variant)
    if text_ is None:
        return _("(Unknown)")
    if variant != text_.HEAD:
        buf = u"%s <code>(%s)</code>" % (buf, variant)
    if link and not page.is_deleted():
        buf = (u"<a class='page_link exists' href='%s'>%s</a>" %
               (text.url(text_), buf))
    return buf


def logo_url(page, y, x=None):
    from adhocracy.lib.helpers import base_url
    size = "%s" % y if x is None else "%sx%s" % (x, y)
    filename = u"%s_%s.png" % (page.id, size)
    (path, mtime) = logo.path_and_mtime(page)
    return base_url(u'/page/%s' % filename, query_params={'t': str(mtime)})


@cache.memoize('page_url')
def url(page, in_context=True, member=None, **kwargs):
    if in_context and page.proposal and not member:
        return proposal.url(page.proposal, **kwargs)
    if (in_context and member is None and page.is_sectionpage() and
            page.sectionpage_root() != page):
        if u'anchor' not in kwargs:
            kwargs[u'anchor'] = u'subpage-%i' % page.id
        return url(page.sectionpage_root(), in_context=False, **kwargs)
    label = _url.quote(page.label)
    return _url.build(page.instance, 'page', label, member=member, **kwargs)


def page_variant_url(page, variant):
    '''
    TODO: Hacked together to implement new page views.
    Refactor url functions.
    '''
    label = _url.quote(page.label)
    if variant == model.Text.HEAD:
        variant = None
    else:
        variant = _url.quote(variant)
    return _url.build(page.instance, 'page', label, member=variant)


def page_text_url(page, text, member=None):
    label = '%s;%d' % (_url.quote(page.label), text.id)
    return _url.build(page.instance, 'page', label, member=member)


@cache.memoize('page_bc', time=3600)
def entity_bc(page):
    bc = ''
    if page.parent:
        bc += entity_bc(page.parent)
    return bc + _url.BREAD_SEP + _url.link(page.title, url(page))


def breadcrumbs(page):
    from adhocracy.lib.helpers import base_url
    bc = _url.root()
    bc += _url.link(_("Norms"), base_url(u'/page'))
    if page is not None:
        bc += entity_bc(page)
    return bc

########NEW FILE########
__FILENAME__ = poll_helper
from adhocracy import config
from adhocracy.lib.helpers import url as _url


def url(poll, **kwargs):
    return _url.build(poll.scope.instance, 'poll', poll.id, **kwargs)


def hide_individual_votes(poll):
    hide = config.get_bool('adhocracy.hide_individual_votes.%s'
                           % poll.scope.instance.key)
    if hide is None:
        hide = config.get_bool('adhocracy.hide_individual_votes')
    return hide

########NEW FILE########
__FILENAME__ = proposal_helper
import cgi

from pylons.i18n import _
from pylons import tmpl_context as c

from adhocracy.lib import cache
from adhocracy.lib.text import label2url
from adhocracy.lib.helpers import url as _url
from adhocracy.lib.helpers.category_helper import bc_entity as bc_category


@cache.memoize('proposal_link', 3600)
def link(proposal, link=True, **kwargs):
    text = cgi.escape(proposal.title)
    if link and not proposal.is_deleted():
        text = (u"<a href='%s' class='dgb_link'>%s</a>" %
                (url(proposal, **kwargs), text))
    return text


@cache.memoize('proposal_url', 3600)
def url(proposal, member=None, in_overlay=True, **kwargs):
    if proposal.is_amendment and member is None:
        base = u'page/%s/amendment' % proposal.selection.page.label
        if in_overlay:
            from adhocracy.lib.helpers import page_helper as page
            kwargs[u'format'] = u'overlay'
            query = {
                u'overlay_path': _url.build(proposal.instance, base,
                                            proposal.id, **kwargs),
                u'overlay_type': u'#overlay-url-big',
            }
            return page.url(proposal.selection.page, query=query)
        else:
            return _url.build(proposal.instance, base, proposal.id, **kwargs)
    else:
        ext = str(proposal.id) + '-' + label2url(proposal.title)
        return _url.build(proposal.instance, 'proposal', ext,
                          member=member, **kwargs)


@cache.memoize('proposal_bc')
def bc_entity(proposal):
    return _url.BREAD_SEP + _url.link(proposal.title, url(proposal))


def breadcrumbs(proposal):
    from adhocracy.lib.helpers import base_url
    bc = _url.root()
    if c.instance.show_proposals_navigation:
        bc += _url.link(_("Proposals"), base_url(u'/proposal'))
    elif c.instance.display_category_pages:
        bc += _url.link(_("Categories"), base_url(u'/category'))

        if proposal is not None and proposal.category is not None:
            bc += bc_category(proposal.category)
    else:
        # FIXME this case will produce a double BREAD_SEP
        pass
    if proposal is not None:
        bc += bc_entity(proposal)
    return bc

########NEW FILE########
__FILENAME__ = recaptcha_helper
from pylons import request
from webhelpers.html import literal

from recaptcha.client.captcha import displayhtml
from recaptcha.client.captcha import submit
from recaptcha.client.captcha import RecaptchaResponse

from adhocracy import config


class Recaptcha(object):
    """Recaptcha functionality for Pylons applications.

Add the following items to your config.ini:

::

    recaptcha.public_key = yourpublickey
    recaptcha.private_key = yourprivatekey

Example usage:

::

    #in the controller that renders the recaptcha-proected form::
    c.recaptcha = h.recaptcha.displayhtml() #insert c.recaptcha into the form

    #in the controller that handles the form POST::
    recaptcha_response = h.recaptcha.submit()
    if not recaptcha_response.is_valid:
        #render the form and try again
        c.recaptcha = h.recaptcha.displayhtml(
            error=recaptcha_response.error_code)

"""

    def __init__(self):
        """
        Recaptcha might be called before config is parsed,
        e.g. in project.lib.helpers, so defer config lookup
        """
        RecaptchaResponse

    @property
    def _public_key(self):
        return config.get('recaptcha.public_key')

    @property
    def _private_key(self):
        return config.get('recaptcha.private_key')

    def displayhtml(self, use_ssl=False, error=None):
        """Return HTML string for inserting recaptcha into a form."""
        return literal(displayhtml(self._public_key, use_ssl=use_ssl,
                                   error=error))

    def submit(self):
        """Return an instance of recaptcha.client.captcha.RecaptchaResponse."""
        if request.environ.get('paste.testing', False):
            return RecaptchaResponse(False, 'paste.testing')
        recaptcha_challenge_field = request.POST.get(
            'recaptcha_challenge_field', None)
        recaptcha_response_field = request.POST.get('recaptcha_response_field',
                                                    None)
        return submit(recaptcha_challenge_field, recaptcha_response_field,
                      self._private_key, "127.0.0.1")

########NEW FILE########
__FILENAME__ = selection_helper
from pylons.i18n import _

from adhocracy.lib import cache

from adhocracy.lib.helpers import proposal_helper as proposal
from adhocracy.lib.helpers import url as _url


@cache.memoize('selection_url')
def url(selection, member=None, format='html', selection_page=False, **kwargs):
    if member is None and format == 'html' and not selection_page:
        anchor = "selection_%s" % selection.id
        return proposal.url(selection.proposal, anchor=anchor)
    url = proposal.url(selection.proposal, member='implementation')
    url += "/" + str(selection.id)
    return _url.append_member_and_format(url, member=member, format=format,
                                         **kwargs)


@cache.memoize('selection_bc')
def bc_entity(selection):
    bc = _url.link(_("Implementation"),
                   proposal.url(selection.proposal,
                                member=u'/implementation'))
    bc += _url.BREAD_SEP + _url.link(selection.page.title, url(selection))
    return bc


def breadcrumbs(selection):
    bc = _url.root()
    if selection is not None:
        bc = bc_entity(selection)
    else:
        bc += _("Implementation")
    return bc

########NEW FILE########
__FILENAME__ = site_helper
import urllib
from urlparse import urlparse

from pylons import config, app_globals as g
from pylons import request
from pylons.i18n import _
from paste.deploy.converters import asbool
from adhocracy.model import instance_filter as ifilter
from adhocracy import config as aconfig


CURRENT_INSTANCE = object()


def get_domain_part(domain_with_port):
    return domain_with_port.split(':')[0]


def domain():
    return get_domain_part(config.get('adhocracy.domain'))


def name():
    return config.get('adhocracy.site.name')


def relative_urls(config=config):
    return asbool(config.get('adhocracy.relative_urls', 'false'))


def base_url(path='', instance=CURRENT_INSTANCE, absolute=False,
             append_slash=False, config=config, query_params=None,
             query_string=None, member=None):
    """
    Constructs an URL.

    Path is expected to start with '/'. If not, a relative path to the current
    object will be created.

    If instance isn't defined, the current instance is assumed. Otherwise,
    either an instance, an instance key, or None has to be passed.

    If absolute is True, an absolute URL including the protocol part is
    returned. Otherwise this is avoided, if relative_urls is set to True and
    instance_domains isn't enabled.

    query_params is a dictionary of parameters for the query string of the URL.

    Alternatively to query_params, query_string can be specified which is
    directly used as the query string of the resulting URL.
    """

    if instance == CURRENT_INSTANCE:
        instance = ifilter.get_instance()

    if instance is None:
        instance_key = None
    else:
        if isinstance(instance, (str, unicode)):
            instance_key = instance
        else:
            instance_key = instance.key

    domain = None

    instance_domains = aconfig.get_bool('adhocracy.instance_domains.enabled')

    if instance and instance_domains:
        domain = aconfig.get_json('adhocracy.instance_domains', {})\
            .get(instance_key)

    if domain is not None:
        protocol = config.get('adhocracy.protocol', 'http').strip()
        result = '%s://%s%s' % (protocol, domain, path)

    elif relative_urls(config):

        if instance is None:
            prefix = ''
        else:
            prefix = '/i/' + instance_key

        if absolute or instance_domains:
            protocol = config.get('adhocracy.protocol', 'http').strip()
            domain = config.get('adhocracy.domain').strip()

            result = '%s://%s%s%s' % (protocol, domain, prefix, path)

        else:
            result = '%s%s' % (prefix, path)

    else:

        protocol = config.get('adhocracy.protocol', 'http').strip()
        domain = config.get('adhocracy.domain').strip()

        if instance is None or g.single_instance:
            subdomain = ''
        else:
            subdomain = '%s.' % instance_key

        result = '%s://%s%s%s' % (protocol, subdomain, domain, path)

    if member is not None:
        result += '/' + member

    if result == '':
        result = '/'

    if append_slash and not result.endswith('/'):
        result += '/'

    if query_params:
        result += '&' if '?' in result else '?'
        u = lambda s: unicode(s).encode('utf-8')
        query_params = [(u(k), u(v)) for (k, v) in query_params.iteritems()]
        result += urllib.urlencode(query_params)
    elif query_string:
        result += '&' if '?' in result else '?'
        result += query_string

    return result


def current_url():
    return base_url(request.path)


def shortlink_url(delegateable):
    path = "/d/%s" % delegateable.id
    return base_url(path, None, absolute=True)


def is_local_url(url):
    """check if the url points to this installation of adhocracy to
    avoid fishing attacks and similar.

    see also adhocracy.helpers.is_local_url in adhocracy.js
    """

    if url is None or url == u'':
        return False

    netloc = urlparse(url).netloc
    domain = config.get('adhocracy.domain')

    if netloc == u'' or netloc == domain:
        return True
    elif relative_urls():
        return False
    else:
        # this allows only one subdomain below domain
        return (netloc.endswith(u'.' + domain) and
                (netloc.count(u'.') - domain.count(u'.') == 1))


def velruse_url(path):
    return (aconfig.get('velruse.protocol') + '://' +
            aconfig.get('velruse.domain') + ':' +
            aconfig.get('velruse.port') + '/velruse/' + path.strip('/'))

########NEW FILE########
__FILENAME__ = staticpage_helper
from itertools import izip
import logging
import babel.core
from requests import ConnectionError
from simplejson.scanner import JSONDecodeError

from pylons import tmpl_context as c

from adhocracy import config
from adhocracy.lib import cache, staticpage
from adhocracy.lib.helpers import url as _url
from adhocracy.lib.helpers.adhocracy_service import RESTAPI
from adhocracy.lib.helpers.adhocracy_service import \
    instance_staticpages_api_address

log = logging.getLogger(__name__)


@cache.memoize('staticpage_url')
def url(staticpage, **kwargs):
    instance = c.instance if instance_staticpages_api_address() else None
    pid = staticpage.key
    return _url.build(instance, 'static', pid, **kwargs)


def get_lang_info(lang):
    locale = babel.core.Locale(lang)
    return {'id': lang, 'name': locale.language_name}


def can_edit():
    return staticpage.can_edit()


def get_body(key, default=''):
    res = staticpage.get_static_page(key)
    if res is None:
        return default
    return res.body


def render_footer_column(instance, column):
    if not config.get_bool('adhocracy.customize_footer'):
        return None
    path = u'footer_' + unicode(column)
    if instance and\
       instance.key in config.get('adhocracy.instance_footers'):
        path = u'%s_%s' % (path, instance.key)
    page = staticpage.get_static_page(path)
    if page is None:
        return None
    else:
        return page.body


def breadcrumbs(staticpage):
    return _url.root() + _url.link(staticpage.title, url(staticpage))


def use_external_navigation():
    return config.get_bool('adhocracy.use_external_navigation', False)


def render_external_navigation(current_key):
    if not use_external_navigation():
        return None
    api = RESTAPI()
    base = config.get('adhocracy.external_navigation_base')
    try:
        result = api.staticpages_get(base=base)
    except ConnectionError as e:
        log.error('Error while connecting to static pages backend: %s' % e)
        return None
    if not result.ok:
        log.error('Error while fetching static pages: %s %s'
                  % (result.status_code, result.reason))
        return None
    try:
        nav = result.json()
    except JSONDecodeError as e:
        log.error('Error while decoding static pages: %s' % e)
        return None
    instance = c.instance if instance_staticpages_api_address() else None
    if nav is None or not nav.get('children'):
        log.error('External navigation not found for configured languages')
        return None

    def render_navigation_item(item, path='', toplevel=False):
        from adhocracy.lib.templating import render_def

        if path != '':
            path = '%s/%s' % (path, item['name'])
        else:
            path = item['name']

        url = _url.build(instance, 'static', path, format='html')

        contains_current = (path == current_key)
        if item['children']:
            children, contained_list = izip(
                *map(lambda child: render_navigation_item(child, path),
                     item['children']))
            contains_current = contains_current or any(contained_list)
        else:
            children = []

        html = render_def('static/tiles.html', 'navigation_item',
                          href=url,
                          title=item['title'],
                          current=toplevel and contains_current,
                          children=children)

        return (html, contains_current)

    html_list, _ = izip(
        *map(lambda child: render_navigation_item(child, toplevel=True),
             nav['children']))
    return '\n'.join(html_list)

########NEW FILE########
__FILENAME__ = tag_helper
import cgi
from pylons import tmpl_context as c
from pylons.i18n import _

from adhocracy.lib import cache
from adhocracy.lib.auth import can
from adhocracy.lib.helpers import url as _url
from adhocracy.lib.helpers import url_token
from adhocracy.lib.helpers.site_helper import base_url


def link(tag, count=None, size=None, base_size=12, plain=False, simple=False):
    '''
    Generate a link to a tag. if *simple* is *True* it will create a plain
    <a> link and **ignores all other kwargs!**. If *simple* is *False*,
    it will generate a more fancy link wrapped into a <span>.

    *count* (None or int)
        If an int is given, it will append the count to the link text
    *size* (None or int)
        If given a font-size is set as an inline style.
    *base_size* (int)
        Used to calulate the font size.
    *plain* (boolean)
        Set the 'plain' css class on the wrapper <span>.
    '''
    if simple:
        return u'<a href="%s" rel="tag">%s</a>' % (url(tag),
                                                   cgi.escape(tag.name))

    text = u"<span class='tag_link %s'><a" % ("plain" if plain else "")
    if size is not None:
        text += u" style='font-size: %d%% !important;'" % size
    text += u" href='%s' rel='tag'>%s</a>" % (url(tag), cgi.escape(tag.name))
    if count is not None and count > 1:
        text += u"&thinsp;&times;" + str(count)
    text += u"</span>"
    return text


def link_with_untag(tag, delegateable, simple=True):
    tag_link = link(tag, simple=simple)
    if can.instance.edit(c.instance):
        return '%s (%s)' % (
            tag_link,
            '<a href="%s?tag=%d&delegateable=%d&%s">%s</a>' % (
                base_url('/untag_all'),
                tag.id,
                delegateable.id,
                url_token(),
                _('delete')
            )
        )
    else:
        return tag_link


def url(tag, instance=None, **kwargs):
    if instance is None:
        instance = c.instance

    @cache.memoize('tag_url')
    def url_(tag, instance, **kwargs):
        ident = None
        try:
            ident = _url.quote(tag.name)
        except KeyError:
            ident = tag.id
        return _url.build(instance, u'tag', ident, **kwargs)
    return url_(tag, instance, **kwargs)


def bc_entity(tag):
    return _url.BREAD_SEP + _url.link(tag.name, url(tag))


def breadcrumbs(tag):
    bc = _url.root()
    bc += _url.link(_("Tags"), u'/tag')
    if tag is not None:
        bc += bc_entity(tag)
    return bc


def _tag_size(count, all_counts, steps=6):
    """Calculate a font size based on a list of counts (e.g. for a tag cloud).
    The set `all_counts` is separated into `steps` quantiles. Each quantile
    gets a font size.
    """

    l1 = sorted(set(all_counts))
    i = l1.index(count)

    # avoid deviding by 0
    if len(l1) <= 1:
        return 100

    f = i / float(len(l1) - 1)
    f = int(round(steps * f)) / float(steps)
    return int(90 + f * 110)


def tag_cloud_normalize(tags, steps=6):
    counts = [co for (t, co) in tags]
    return [(t, co, _tag_size(co, counts, steps=steps)) for (t, co) in tags]


def solr_tag_size(tag, all_tags, steps=6):
    count = tag['current_count']
    all_counts = [t['current_count'] for t in all_tags]
    return _tag_size(count, all_counts, steps=steps)

########NEW FILE########
__FILENAME__ = text_helper
from adhocracy import config
from adhocracy.lib import cache
from adhocracy.lib.helpers import url as _url
from adhocracy.lib.text.truncate import truncate


@cache.memoize('text_url')
def url(text, **kwargs):
    import page_helper as page
    if text is None:
        return ''
    in_context = (text == text.page.variant_head(text.variant))
    url = page.url(text.page, in_context=in_context)
    if text.page.has_variants and text.variant != text.HEAD:
        url += u'/' + _url.quote(text.variant)
    if text != text.page.variant_head(text.variant):
        url += u';' + str(text.id)
    return _url.append_member_and_format(url, **kwargs)


@cache.memoize('text_bc')
def entity_bc(text):
    return _url.BREAD_SEP + _url.link(text.variant, url(text))


def breadcrumbs(text):
    import page_helper as page
    bc = page.breadcrumbs(text.page)
    if text is not None and text.variant != text.HEAD:
        bc += entity_bc(text)
    return bc


def getconf_allow_user_html(_testing_override=None):
    if _testing_override is not None:
        return _testing_override
    return config.get_bool('adhocracy.allow_user_html')


def truncate_html(html, target_len, ellipsis='...'):
    return truncate(html, target_len, ellipsis)

########NEW FILE########
__FILENAME__ = treatment_helper

from adhocracy.lib import cache
from adhocracy.lib.helpers import url as _url


@cache.memoize('treatment_url', 3600)
def url(entity, **kwargs):
    return _url.build(None, 'admin/treatment', entity.key, **kwargs)

########NEW FILE########
__FILENAME__ = tutorial
from pylons import session

from adhocracy import config
from adhocracy.model import meta

ALLKEY = 'disable_tutorials'
ONEKEY = 'disable_tutorial_%s'


def show(name, user):
    if not config.get_bool('adhocracy.show_tutorials'):
        return False

    if user is not None and user.no_help:
        return False
    if session.get(ALLKEY, False):
        return False
    elif session.get(ONEKEY % name):
        return False
    else:
        return True


def disable(name, user):
    if name is None:
        if user is None:
            session[ALLKEY] = True
        else:
            user.no_help = True
            meta.Session.commit()
    else:
        session[ONEKEY % name] = True
    session.save()


def enable():
    for key in session:
        if key.startswith('disable_tutorial'):
            session[key] = False
    session.save()

########NEW FILE########
__FILENAME__ = url
# -*- coding: utf-8 -*-
import cgi
import urllib

from pylons import tmpl_context as c
from webhelpers.text import truncate

from adhocracy.lib.helpers import site_helper as site

BREAD_SEP = " &raquo; "


def append_member_and_format(url, member=None, format=None, **kwargs):
    '''
    Add *member* as the last path segment to the url and
    add the extension .<format> if *format* exists.

    *member*:
        An *unicode* or None
    *format*
        An *unicode* or None

    Returns: An *unicode*
    '''
    if member is not None:
        url += u'/' + member
    if format is not None:
        url += u'.' + format.lower()
    return url


def build(instance, base, id, query=None, anchor=None, member=None,
          format=None, absolute=False):
    '''
    Build an url which will be placed in the subdomain of the
    *instance*'. The url will be composed out of *base* and 'id',
    point to the html id *anchor*.
    '''
    if base:
        base = '/' + base + '/'
    else:
        base = u'/'
    id = id.decode('utf-8') if isinstance(id, str) else unicode(id)
    _path = base + id
    url = site.base_url(_path, instance, absolute=absolute)
    url = append_member_and_format(url, member, format)
    if query is not None:
        url += '&' if '?' in url else '?'
        u = lambda s: unicode(s).encode('utf-8')
        query = [(u(k), u(v)) for (k, v) in query.iteritems()]
        url += urllib.urlencode(query)
    if anchor is not None:
        url += "#" + anchor
    return url


def root():
    if c.instance:
        from instance_helper import url
        return link(c.instance.label, url(c.instance)) + BREAD_SEP
    else:
        return link(site.name(), site.base_url(instance=None)) + BREAD_SEP


def link(title, href):
    title = cgi.escape(truncate(title, length=40, whole_word=True))
    return u"<a href='%s'>%s</a>" % (href, title)


def _non_unicode_wrapper(s, func):
    """Use this to wrap functions which do not handle unicode strings properly,
    e.g. urllib

    This takes a unicode or byte string, converts it to a utf-8 encoded
    byte string, runs func on it and returns the result as unicode.

    >>> urllib.quote('')
    '%C3%9F'
    >>> urllib.quote(u'\xdf')  # doctest: +ELLIPSIS
    Traceback (most recent call last):
    KeyError: ...
    >>> _non_unicode_wrapper('', urllib.quote)
    u'%C3%9F'
    >>> _non_unicode_wrapper(u'\xdf', urllib.quote)
    u'%C3%9F'
    """

    if isinstance(s, unicode):
        s = s.encode('utf-8')
    s = func(s)
    if isinstance(s, str):
        s = s.decode('utf-8')
    return s


def quote(s):
    return _non_unicode_wrapper(s, urllib.quote)


def unquote(s):
    return _non_unicode_wrapper(s, urllib.unquote)

########NEW FILE########
__FILENAME__ = user_helper
import cgi

from pylons import tmpl_context as c
from pylons.i18n import _

from adhocracy import config
from adhocracy.lib import cache, logo
from adhocracy.lib.auth.authorization import has
from adhocracy.lib.helpers import url as _url
from adhocracy.lib.helpers.site_helper import CURRENT_INSTANCE
from adhocracy.model import Instance


def link(user, size=16, scope=None, show_badges=True):

    if user.delete_time:
        return _("%s (deleted user)") % user.name

    @cache.memoize('user_generic_link')
    def _generic_link(user, instance, size, scope):
        _url = u'<a href="%s" class="user">%s</a>' % (
            url(user), cgi.escape(user.name))
        return _url

    @cache.memoize('user_specific_link')
    def _specific_link(user, instance, size, scope, other,
                       show_badges):
        from adhocracy.lib import tiles
        url = _generic_link(user, instance, size, scope)
        badges = user.get_badges(instance)
        if show_badges and badges:
            url += u"<span class='badges'>" + \
                unicode(tiles.badge.badges(badges)) + "</span>"
        # FIXME: We removed user icons from the UI. What to do
        # with delegates?
        # if other and scope:
        #     dnode = democracy.DelegationNode(other, scope)
        #     for delegation in dnode.outbound():
        #         if delegation.agent == user:
        #             if show_icon:
        #                 icon = (
        #                     u'<img class="user_icon" width="16" height="16" '
        #                     'src="/img/icons/delegate_16.png" />')
        #             url += u'<a href="%s">%s</a>' % (entity_url(delegation),
        #                                              icon)
        return url

    return _specific_link(user, c.instance, size, scope, c.user, show_badges)


def url(user, instance=CURRENT_INSTANCE, **kwargs):
    '''
    Generate the url for a user. If *instance* is `None`, it will
    fallback to the current instance (taken from c.instance) for
    urls that are supposed to be in an instance subdomain, and ignore
    the instance argument for all other urls so they are always in the
    main domain.
    '''
    return _url.build(instance, 'user', user.user_name, **kwargs)


def logo_url(user, y, x=None):
    from adhocracy.lib.helpers import base_url
    size = "%s" % y if x is None else "%sx%s" % (x, y)
    filename = u"%s_%s.png" % (user.id, size)
    (path, mtime) = logo.path_and_mtime(user, fallback=logo.USER)
    return base_url(u'/user/%s' % filename, query_params={'t': str(mtime)})


def breadcrumbs(user, dashboard=False):
    from adhocracy.lib.helpers import base_url
    items = []
    if c.instance is not None:
        items.append(_url.link(_("Members"), base_url(u'/user')))
    elif has('user.index_all'):
        items.append(_url.link(_("Members"), base_url(u'/user/all')))
    if user is not None:
        items.append(_url.link(user.name, url(user)))
    if dashboard:
        items.append(_url.link(_('Dashboard'), base_url('/user/dashboard')))
    return _url.root() + _url.BREAD_SEP.join(items)


def settings_breadcrumbs(user, member=None):
    """member is a dict with the keys 'name' and 'label'."""
    bc = breadcrumbs(user)
    bc += _url.BREAD_SEP + _url.link(_("Settings"),
                                     url(user, member="settings"))
    if member is not None:
        bc += _url.BREAD_SEP + _url.link(
            member['label'],
            url(user, member="settings/" + member['name']))
    return bc


def post_login_url(user):
    from adhocracy.lib.helpers import base_url
    url = config.get('adhocracy.post_login_url')
    if url is None:
        return base_url('/user/%s/dashboard' % user.user_name)

    instance = config.get('adhocracy.post_login_instance')
    if instance is None:
        return base_url(url)
    else:
        return base_url(url, Instance.find(instance))


def post_register_url(user):
    from adhocracy.lib.helpers import base_url

    url = config.get('adhocracy.post_register_url')
    if url is None:
        return base_url('/user/%s/dashboard' % user.user_name)

    instance = config.get('adhocracy.post_register_instance')
    if instance is None:
        return base_url(url)
    else:
        return base_url(url, Instance.find(instance))


def can_change_password(user):
    if user._shibboleths:
        return config.get_bool('adhocracy.allow_password_change')
    else:
        return True


def activation_url():
    from adhocracy.lib.auth.csrf import url_token
    from adhocracy.lib.helpers import base_url
    return base_url('/user/%s/resend?%s' % (c.user.user_name, url_token()))

########NEW FILE########
__FILENAME__ = velruse_helper
from adhocracy.model.velruse import Velruse
from pylons import tmpl_context as c


def is_user_connected_to_facebook():
    return Velruse.by_user_and_domain(c.user, u'facebook.com') != []


def facebook_account():
    return Velruse.by_user_and_domain_first(c.user, u'facebook.com')

########NEW FILE########
__FILENAME__ = parse
import contextlib
import json
import zipfile


def detect_format(f):
    firstBytes = f.read(4)
    f.seek(0)
    if firstBytes[:1] == b'{':
        return 'json'
    if firstBytes == b'PK\x03\x04':
        return 'zip'
    return 'unknown'


def _read_zip(f):
    res = {}
    with contextlib.closing(zipfile.ZipFile(f, 'r')) as zf:
        for fn in zf.namelist():
            if fn.endswith('.json') and '/' not in fn:
                res[fn[:-len('.json')]] = json.loads(zf.read(fn))
    return res


def read_data(f, format='detect'):
    if format == 'detect':
        format = detect_format(f)

    if format == 'zip':
        return _read_zip(f)
    elif format == 'json':
        return json.load(f)
    else:
        raise ValueError('Invalid import format')

########NEW FILE########
__FILENAME__ = render

import collections
import contextlib
import gzip
import io
import json
import tarfile
import zipfile

from pylons import response


def _render_json(obj):
    return json.dumps(obj, 'utf-8', indent=2)


def _render_data(data):
    result = {}
    for k, v in data.iteritems():
        assert '/' not in k
        result[k + u'.json'] = _render_json(v)
    return result


def _render_zip(data):
    with io.BytesIO() as fake_file:
        with contextlib.closing(zipfile.ZipFile(fake_file, 'a')) as zf:
            for k, v in _render_data(data).iteritems():
                zf.writestr(k, v)
        return fake_file.getvalue()


def _render_json_gzip(data):
    with io.BytesIO() as fake_file:
        with gzip.GzipFile(fileobj=fake_file, mode="w") as zf:
            json.dump(data, zf, indent=2)
        return fake_file.getvalue()


def _render_tar(data, compression=None):
    mode = 'w'
    if compression:
        mode += ':' + compression

    with io.BytesIO() as fake_file:
        otf = tarfile.open(fileobj=fake_file, mode=mode)
        with contextlib.closing(otf) as tf:
            for k, v in _render_data(data).iteritems():
                info = tarfile.TarInfo(name=k)
                info.size = len(v)
                with io.BytesIO() as entry_file:
                    entry_file.write(v)
                    entry_file.seek(0)
                    tf.addfile(tarinfo=info, fileobj=entry_file)
        return fake_file.getvalue()


def _render_tar_gz(data):
    return _render_tar(data, 'gz')


def _render_tar_bz2(data):
    return _render_tar(data, 'bz2')


Renderer = collections.namedtuple(
    'Renderer',
    ('func', 'ext', 'mimetype', 'encoding')
)
RENDERERS = {
    'json': Renderer(
        _render_json, None, 'application/json', 'utf-8'),
    'json_download': Renderer(
        _render_json, '.json', 'application/json', 'utf-8'),
    'json_gzip': Renderer(
        _render_json_gzip, '.json.gz', 'application/gzip', 'binary'),
    'tar': Renderer(
        _render_tar, '.tar', 'application/x-tar', 'binary'),
    'tar_gz': Renderer(
        _render_tar, '.tar.gz', 'application/gzip', 'binary'),
    'tar_bz2': Renderer(
        _render_tar, '.tar.bz2', 'application/x-bzip2', 'binary'),
    'zip': Renderer(
        _render_zip, '.zip', 'application/zip', 'binary'),
}


def render(data, format, title, response=response):
    try:
        r = RENDERERS[format]
    except KeyError:
        raise ValueError('Invalid export format')

    response.content_type = r.mimetype
    response.content_encoding = r.encoding
    if r.ext is not None:
        response.content_disposition = 'attachment; filename="{0}"'.format(
            title + r.ext
        )

    return r.func(data)

########NEW FILE########
__FILENAME__ = transforms

import datetime
import re

from adhocracy.lib import votedetail
from adhocracy import config
from adhocracy import model


def _set_optional(o, data, key, export_prefix=''):
    assert o
    external_key = export_prefix + key
    if external_key in data:
        setattr(o, key, data[external_key])


def encode_locale(locale):
    if locale is None:
        return None
    return '_'.join(filter(None, (locale.language, locale.script,
                                  locale.territory, locale.variant)))


def decode_locale(ldata):
    return ldata


def encode_time(dt):
    return dt.isoformat()


def decode_time(s):
    strptime = datetime.datetime.strptime
    try:
        return strptime(s, '%Y-%m-%dT%H:%M:%S.%f')
    except ValueError:
        try:
            return strptime(s, '%Y-%m-%dT%H:%M:%SZ')
        except ValueError:
            return strptime(s, '%Y-%m-%dT%H:%M:%S')


class _Transform(object):
    """ Every transform must define:
    * _ID_KEY: The name of the property to be used as key
    * _export(self, obj): A method to export an object to JSON
    * import_all(self, data): The method to import an object from data
    Instead of import_all, the class can also use the default implementation
    and define instead:
    * _create(data) - Create a new object with the minimum set of properties
    * _modify(obj, data) - Modify an object to have the specified properties
    """

    def __init__(self, options):
        self._options = options
        self.name = re.match(r'^(.*)Transform$', type(self).__name__).group(1)
        self.public_name = self.name.lower()
        self._model_class = getattr(model, self.name)

    def _get_by_key(self, k):
        """ Returns None if the object cannot be found,
        and the local object in database otherwise. """
        if k is None:
            return None
        findm = getattr(self._model_class, 'find_by_' + self._ID_KEY)
        res = findm(k)
        if res is not None:
            key_val = getattr(res, self._ID_KEY)
            assert key_val == k, (
                u'Unexpected value for %s.find_by_%s: expected %r, got %r' %
                (self._model_class.__name__, self._ID_KEY, k, key_val))
        return res

    def _compute_key(self, o):
        return unicode(getattr(o, self._ID_KEY))

    def _compute_key_from_data(self, data):
        return data.get(self._ID_KEY)

    def export_all(self):
        return dict((self._compute_key(o), self._export(o))
                    for o in self._get_all())

    def _get_all(self):
        return self._model_class.all()

    def import_all(self, odict):
        return dict((k, self._import(data)) for k, data in odict.items())

    def _import(self, data):
        obj = self._get_by_key(self._compute_key_from_data(data))
        if obj:
            doUpdate = self._replacement_strategy == 'update'
        else:
            obj = self._create(data)
            doUpdate = True

        if doUpdate:
            self._modify(obj, data)
        model.meta.Session.add(obj)
        return obj

    @property
    def _replacement_strategy(self):
        return self._options.get('replacement_strategy', 'update')


class BadgeTransform(_Transform):
    _ID_KEY = 'title'

    def _get_by_key(self, k):
        return self._model_class.find(k)

    def _create(self, data):
        btype = data.get('adhocracy_badge_type', 'user')
        if btype == 'user':
            return model.UserBadge.create(
                title=data['title'],
                color=data.get('color', u''),
                visible=data.get('visible', False),
                description=data.get('description', u''))
        else:
            raise NotImplementedError()

    def _modify(self, obj, data):
        obj.title = data['title']
        _set_optional(obj, data, 'color')
        _set_optional(obj, data, 'visible')
        _set_optional(obj, data, 'description')

    def _export(self, obj):
        return {
            'title': obj.title,
            'color': obj.color,
            'visible': obj.visible,
            'description': obj.description,
            'adhocracy_badge_type': obj.polymorphic_identity,
        }


class UserTransform(_Transform):
    """
    Option keys:
    - user_personal - Include identifying information
    - user_password - Include authentication information
    - include_badges - Include a list of badges that the user has
    """
    def __init__(self, options, badge_transform):
        super(UserTransform, self).__init__(options)
        self._badge_transform = badge_transform
        self._opt_personal = self._options.get('user_personal', False)
        if self._opt_personal:
            if config.get_bool('adhocracy.export_personal_email'):
                self._ID_KEY = 'email'
            else:
                self._ID_KEY = 'user_name'
        else:
            self._ID_KEY = 'id'
            self._get_by_key = self._model_class.find
        self._opt_password = self._options.get('user_password', False)
        self._opt_badges = self._options.get('include_badge', False)
        self._opt_welcome = self._options.get('welcome', False)

    def _create(self, data):
        assert self._opt_personal
        res = self._model_class.create(data['user_name'], data['email'])
        res.activation_code = None
        if self._opt_welcome:
            res.initialize_welcome()
        return res

    def _modify(self, o, data):
        assert self._opt_personal
        if self._opt_personal:
            _set_optional(o, data, 'user_name')
            _set_optional(o, data, 'display_name')
            _set_optional(o, data, 'bio')
            _set_optional(o, data, 'email')
            _set_optional(o, data, 'gender')
            if 'locale' in data:
                o.locale = decode_locale(data['locale'])
        if self._opt_password:
            _set_optional(o, data, 'activation_code', 'adhocracy_')
            _set_optional(o, data, 'reset_code', 'adhocracy_')
            _set_optional(o, data, 'password', 'adhocracy_')
            _set_optional(o, data, 'banned', 'adhocracy_')
            _set_optional(o, data, 'welcome_code', 'adhocracy_')
        if self._opt_badges:
            if 'badges' in data:
                old_badges = o.badges
                new_badges = map(self._badge_transform._get_by_key,
                                 data['badges'])
                for b in new_badges:
                    if b not in old_badges:
                        b.assign(o, o)

    def _export(self, o):
        res = {}
        if self._opt_personal:
            res.update({
                'id': o.id,
                'user_name': o.user_name,
                'display_name': o.display_name,
                'bio': o.bio,
                'email': o.email,
                'gender': o.gender,
                'locale': encode_locale(o.locale),
            })
            if config.get('adhocracy.user.optional_attributes'):
                res['optional_attributes'] = o.optional_attributes
        if self._opt_password:
            res.update({
                'adhocracy_activation_code': o.activation_code,
                'adhocracy_reset_code': o.reset_code,
                'adhocracy_password': o.password,
                'adhocracy_banned': o.banned,
                'adhocracy_welcome_code': o.welcome_code,
            })
        if self._opt_badges:
            res['badges'] = [getattr(b, BadgeTransform._ID_KEY)
                             for b in o.badges]
        return res


class InstanceTransform(_Transform):
    _ID_KEY = 'key'

    def __init__(self, options, user_transform, badge_transform):
        super(InstanceTransform, self).__init__(options)
        self._user_transform = user_transform
        self._badge_transform = (
            badge_transform
            if options.get('include_badge', False)
            else None
        )

    def _export(self, obj):
        res = {
            'adhocracy_type': 'instance',
            'key': obj.key,
            'label': obj.label,
            'creator': self._user_transform._compute_key(obj.creator),
            'description': obj.description,
            'adhocracy_required_majority': obj.required_majority,
            'adhocracy_activation_delay': obj.activation_delay,
            'create_time': encode_time(obj.create_time),
            'adhocracy_access_time': encode_time(obj.access_time),
            'adhocracy_delete_time': (encode_time(obj.delete_time)
                                      if obj.delete_time
                                      else None),
            'adhocracy_default_group_id': obj.default_group_id,
            'adhocracy_allow_adopt': obj.allow_adopt,
            'adhocracy_allow_delegate': obj.allow_delegate,
            'adhocracy_allow_propose': obj.allow_propose,
            'adhocracy_allow_index': obj.allow_index,
            'adhocracy_hidden': obj.hidden,
            'locale': encode_locale(obj.locale),
            'adhocracy_css': obj.css,
            'frozen': obj.frozen,
            'adhocracy_milestones': obj.milestones,
            'adhocracy_use_norms': obj.use_norms,
            'adhocracy_require_selection': obj.require_selection,
            'adhocracy_is_authenticated': obj.is_authenticated,
            'adhocracy_hide_global_categories': obj.hide_global_categories,
            'adhocracy_editable_comments_default': (
                obj.editable_comments_default),
            'adhocracy_editable_proposals_default': (
                obj.editable_proposals_default),
            'adhocracy_require_valid_email': obj.require_valid_email,
            'adhocracy_allow_thumbnailbadges': obj.allow_thumbnailbadges,
            'adhocracy_thumbnailbadges_height': obj.thumbnailbadges_height,
            'adhocracy_thumbnailbadges_width': obj.thumbnailbadges_width,
        }
        if self._options.get('include_instance_proposal'):
            ptransform = ProposalTransform(self._options, obj,
                                           self._user_transform)
            res['proposals'] = ptransform.export_all()

        if self._badge_transform and votedetail.is_enabled():
            res['adhocracy_votedetail_userbadges'] = [
                self._badge_transform._compute_key(b)
                for b in obj.votedetail_userbadges
            ]

        return res

    def _create(self, data):
        btype = data.get('adhocracy_type', 'instance')
        if btype == 'instance':
            creator = self._user_transform._get_by_key(data['creator'])
            return model.Instance.create(
                data['key'].lower(),
                data['label'],
                creator)
        else:
            raise NotImplementedError()

    def _modify(self, o, data):
        _set_optional(o, data, 'label')
        if 'creator' in data:
            creator = self._user_transform._get_by_key(data['creator'])
            if creator:
                o.creator = creator
        _set_optional(o, data, 'description')
        _set_optional(o, data, 'required_majority', 'adhocracy_')
        _set_optional(o, data, 'activation_delay', 'adhocracy_')
        if 'create_time' in data:
            o.create_time = decode_time(data['create_time'])
        if 'adhocracy_access_time' in data:
            o.access_time = decode_time(data['adhocracy_access_time'])
        if 'adhocracy_delete_time' in data:
            if data['adhocracy_delete_time'] is None:
                o.delete_time = None
            else:
                o.delete_time = decode_time(data['adhocracy_delete_time'])
        _set_optional(o, data, 'default_group_id', 'adhocracy_')
        _set_optional(o, data, 'allow_adopt', 'adhocracy_')
        _set_optional(o, data, 'allow_delegate', 'adhocracy_')
        _set_optional(o, data, 'allow_propose', 'adhocracy_')
        _set_optional(o, data, 'allow_index', 'adhocracy_')
        _set_optional(o, data, 'hidden', 'adhocracy_')
        if 'locale' in data:
            if data['locale'] is None:
                o.locale = data['locale']
            else:
                o.locale = decode_locale(data['locale'])
        _set_optional(o, data, 'css', 'adhocracy_')
        _set_optional(o, data, 'frozen')
        _set_optional(o, data, 'milestones', 'adhocracy_')
        _set_optional(o, data, 'use_norms', 'adhocracy_')
        _set_optional(o, data, 'require_selection', 'adhocracy_')
        _set_optional(o, data, 'is_authenticated', 'adhocracy_')
        _set_optional(o, data, 'hide_global_categories', 'adhocracy_')
        _set_optional(o, data, 'editable_comments_default', 'adhocracy_')
        _set_optional(o, data, 'editable_proposals_default', 'adhocracy_')
        _set_optional(o, data, 'require_valid_email', 'adhocracy_')
        _set_optional(o, data, 'allow_thumbnailbadges', 'adhocracy_')
        _set_optional(o, data, 'thumbnailbadges_height', 'adhocracy_')
        _set_optional(o, data, 'thumbnailbadges_width', 'adhocracy_')

        if self._options.get('include_instance_proposal'):
            ptransform = ProposalTransform(self._options, o,
                                           self._user_transform)
            ptransform.import_all(data.get('proposals', {}))

        if self._badge_transform and votedetail.is_enabled():
            if 'adhocracy_votedetail_userbadges' in data:
                o.votedetail_userbadges = [
                    self._badge_transform._get_by_key(bid)
                    for bid in data['adhocracy_votedetail_userbadges']
                ]

    def _get_by_key(self, key):
        return self._model_class.find(key)


class ProposalTransform(_Transform):
    _ID_KEY = 'id'

    def __init__(self, options, instance, user_transform):
        super(ProposalTransform, self).__init__(options)
        self._instance = instance
        self._user_transform = user_transform

    def _get_all(self):
        return self._model_class.all_q(self._instance)

    def _create(self, data):
        btype = data.get('adhocracy_type', 'proposal')
        if btype == 'proposal':
            creator = self._user_transform._get_by_key(data['creator'])
            assert creator
            label = data['title']
            desc = data['description']
            o = self._model_class.create(self._instance, label, creator)
            description = model.Page.create(
                self._instance,
                label,
                desc,
                creator,
                function=model.Page.DESCRIPTION,
                formatting=True)
            description.parents = [o]
            o.description = description
            return o
        else:
            raise NotImplementedError()

    def _modify(self, o, data):
        pass

    def _export(self, obj):
        res = {
            'id': obj.id,
            'title': obj.title,
            'create_time': encode_time(obj.create_time),
            'description': (None if obj.description is None
                            else obj.description.head.text),
            'creator': self._user_transform._compute_key(obj.creator),
            'adhocracy_type': 'proposal',
            'category': obj.category.title if obj.category else None,
            'tags': [o.name for o, _ in obj.tags],
            'badges': [o.badge.title for o in obj.delegateablebadges
                       if o.badge.polymorphic_identity != 'category'],
        }
        if self._options.get('include_proposal_creator_badges', False):
            res['creator_badges'] = [o.badge.title
                                     for o in obj.creator.userbadges],
        if self._options.get('include_ratings', False):
            res.update({
                'rate_pro': obj.rate_poll.tally.num_for,
                'rate_contra': obj.rate_poll.tally.num_against,
                'rate_neutral': obj.rate_poll.tally.num_abstain,
            })
            if votedetail.is_enabled():
                vd = votedetail.calc_votedetail_dict(
                    obj.instance, obj.rate_poll, badge_title_only=True)
                if vd:
                    res['votedetail_rate_poll'] = vd

        if self._options.get('include_instance_proposal_comment', False):
            ctransform = CommentTransform(self._options,
                                          obj.description.comments,
                                          None,
                                          self._user_transform)
            res['comments'] = ctransform.export_all()
        return res


class CommentTransform(_Transform):
    _ID_KEY = 'id'

    def __init__(self, options, all_comments, parent_comment, user_transform):
        super(CommentTransform, self).__init__(options)
        self._all_comments = all_comments
        self._parent_comment = parent_comment
        self._user_transform = user_transform

    def _get_all(self):
        return [c for c in self._all_comments
                if c.reply == self._parent_comment]

    def _export(self, obj):
        res = {
            'create_time': encode_time(obj.create_time),
            'text': obj.latest.text,
            'sentiment': obj.latest.sentiment,
            'creator': self._user_transform._compute_key(obj.creator),
            'adhocracy_type': 'comment',
        }
        if self._options.get('include_ratings', False):
            res.update({
                'rate_pro': obj.poll.tally.num_for,
                'rate_contra': obj.poll.tally.num_against,
                'rate_neutral': obj.poll.tally.num_abstain,
            })
        ct = CommentTransform(self._options, self._all_comments, obj,
                              self._user_transform)
        res['comments'] = ct.export_all()
        return res


class RequestLogTransform(_Transform):
    _ID_KEY = 'id'

    def __init__(self, options):
        super(RequestLogTransform, self).__init__(options)

    def _export(self, obj):
        res = obj.to_dict()
        res['access_time'] = encode_time(res['access_time'])
        return res


class StaticPageTransform(_Transform):
    def __init__(self, options, backend=None):
        super(StaticPageTransform, self).__init__(options)
        if backend is None:
            from adhocracy.lib.staticpage import get_backend
            backend = get_backend()
        self._backend = backend

    def _export(self, obj):
        return {
            'key': obj.key,
            'lang': obj.lang,
            'title': obj.title,
            'body': obj.body
        }

    def _create(self, data):
        return self._backend.create(
            data['key'],
            data['lang'],
            data.get('title', u''),
            data.get('body', u''))

    def _modify(self, o, data):
        _set_optional(o, data, 'key')
        _set_optional(o, data, 'lang')
        _set_optional(o, data, 'title')
        _set_optional(o, data, 'body')

    def _get_by_key(self, k):
        key, _, lang = k.partition(u'_')
        return self._backend.get(key, lang)

    def _get_all(self):
        return self._backend.all()

    def _compute_key(self, obj):
        return obj.key + u'_' + obj.lang

    def _compute_key_from_data(self, data):
        return data['key'] + u'_' + data['lang']


def gen_all(options):
    badge_transform = BadgeTransform(options)
    user_transform = UserTransform(options, badge_transform)
    instance_transform = InstanceTransform(
        options, user_transform, badge_transform)
    requestlog_transform = RequestLogTransform(options)
    staticpage_transform = StaticPageTransform(options)
    return [badge_transform, user_transform, instance_transform,
            requestlog_transform, staticpage_transform]


def gen_active(options):
    return [tf for tf in gen_all(options)
            if options.get('include_' + tf.name.lower(), False)]

########NEW FILE########
__FILENAME__ = install
import logging

import adhocracy.model as model
from adhocracy.config import get_bool as config_get_bool
from adhocracy.config import get_json as config_get_json
from adhocracy.lib.auth.authentication import allowed_login_types
from adhocracy.lib.helpers.site_helper import get_domain_part

from paste.deploy.converters import asbool

log = logging.getLogger(__name__)

ADMIN = u'admin'
ADMIN_PASSWORD = u'password'


def mk_group(name, code):
    group = model.Group.by_code(unicode(code))
    if not group:
        log.debug("Creating group: %s" % name)
        group = model.Group(unicode(name), unicode(code))
        model.meta.Session.add(group)
    else:
        group.group_name = unicode(name)
    return group


def mk_perm(name):
    perm = model.Permission.find(name)
    if perm is None:
        log.debug("Creating permission: %s" % name)
        perm = model.Permission(name)
        model.meta.Session.add(perm)
        return perm
    return None


def setup_entities(config, initial_setup):
    # model.meta.Session.begin()
    model.meta.Session.commit()

    # administrate installation wide
    admins = mk_group("Administrator", model.Group.CODE_ADMIN)
    organization = mk_group("Organization", model.Group.CODE_ORGANIZATION)
    # administrate instance
    supervisor = mk_group("Supervisor", model.Group.CODE_SUPERVISOR)
    moderator = mk_group("Moderator", model.Group.CODE_MODERATOR)
    voter = mk_group("Voter", model.Group.CODE_VOTER)
    observer = mk_group("Observer", model.Group.CODE_OBSERVER)
    advisor = mk_group("Advisor", model.Group.CODE_ADVISOR)
    default = mk_group("Default", model.Group.CODE_DEFAULT)
    anonymous = mk_group("Anonymous", model.Group.CODE_ANONYMOUS)
    addressee = mk_group("Addressee", model.Group.CODE_ADDRESSEE)

    model.meta.Session.commit()

    # To simplify initial configuration, we allow to define permission
    # includes, e.g. permissions granted to observers are automatically granted
    # to advisors and organizations as well. This is resolved recursively.
    # Note that this applies only to the initial setup.

    def included_groups(groups):
        all_groups = set(groups)
        includes = set()
        for group in groups:
            includes = includes.union(perm_includes.get(group, []))
        for include in includes:
            all_groups = all_groups.union(included_groups(includes))
        return list(all_groups)

    perm_includes = {
        anonymous: [observer],
        observer: [advisor, organization],
        advisor: [voter],
        voter: [moderator, addressee],
        moderator: [supervisor],
        supervisor: [admins],
    }

    default_permission_groups = {
        u'abuse.report': [anonymous],
        u'badge.index': [anonymous],
        u'badge.edit_global': [admins],
        u'badge.manage_global': [admins],
        u'badge.edit_instance': [moderator],
        u'badge.manage_instance': [moderator],
        u'comment.create': [advisor],
        u'comment.delete': [moderator],
        u'comment.edit': [advisor],
        u'comment.show': [anonymous],
        u'comment.view': [anonymous],
        u'delegation.create': [voter],
        u'delegation.delete': [voter],
        u'delegation.show': [anonymous],
        u'delegation.view': [anonymous],
        u'event.index_all': [anonymous],
        u'global.admin': [admins],
        u'global.member': [admins],
        u'global.message': [admins],
        u'global.organization': [organization],
        u'global.staticpage': [admins],
        u'instance.admin': [supervisor],
        u'instance.manage': [moderator],
        u'instance.create': [admins],
        u'instance.delete': [admins],
        u'instance.index': [anonymous],
        u'instance.join': [default],
        u'instance.leave': [default],
        u'instance.news': [anonymous],
        u'instance.show': [anonymous],
        u'instance.message': [admins],
        u'milestone.create': [supervisor],
        u'milestone.delete': [supervisor],
        u'milestone.edit': [supervisor],
        u'milestone.show': [anonymous],
        u'page.create': [advisor],
        u'page.delete': [moderator],
        u'page.delete_history': [moderator],
        u'page.edit': [advisor],
        u'page.edit_head': [moderator],
        u'page.show': [anonymous],
        u'page.view': [anonymous],
        u'poll.create': [moderator],
        u'poll.delete': [moderator],
        u'poll.show': [anonymous],
        u'proposal.create': [advisor],
        u'proposal.delete': [moderator],
        u'proposal.edit': [moderator],
        u'proposal.freeze': [supervisor],
        u'proposal.show': [anonymous],
        u'proposal.view': [anonymous],
        u'proposal.message': [moderator],
        u'static.show': [anonymous],
        u'static.show_private': [admins],
        u'tag.create': [advisor],
        u'tag.delete': [advisor],
        u'tag.show': [anonymous],
        u'tag.view': [anonymous],
        u'user.edit': [default],
        u'user.index_all': [admins],
        u'user.manage': [admins],
        u'user.message': [advisor],
        u'user.show': [anonymous],
        u'user.view': [anonymous],
        u'user.badge': [moderator],
        u'vote.cast': [voter],
        u'vote.prohibit': [organization],
        u'watch.create': [observer, default],
        u'watch.delete': [observer],
        u'watch.instance': [moderator],
        u'watch.show': [anonymous],
    }

    autoupdate = asbool(config.get('adhocracy.autoassign_permissions', 'true'))
    assign_perms = initial_setup or autoupdate

    for perm_name, groups in default_permission_groups.items():
        new_perm = mk_perm(perm_name)
        if assign_perms and new_perm is not None:
            assigned_groups = included_groups(groups)
            log.debug("Assigning to groups: %s" % assigned_groups)
            new_perm.groups = assigned_groups

    model.meta.Session.commit()

    admin = model.User.find(u"admin")
    if not admin:
        email = u'admin@%s' % get_domain_part(config.get('adhocracy.domain'))
        admin = model.User.create(ADMIN, email,
                                  password=ADMIN_PASSWORD,
                                  global_admin=True)
        admin.activation_code = None

    model.meta.Session.commit()

    if config.get('adhocracy.instance'):
        model.Instance.create(config.get('adhocracy.instance'),
                              u"Adhocracy", admin)
    else:
        if config_get_bool('adhocracy.use_test_instance', config=config)\
                and not model.Instance.find(u"test"):
            log.debug(u'Creating test instance')
            model.Instance.create(u"test", u"Test Instance", admin)

        if config_get_bool('adhocracy.use_feedback_instance', config=config):
            feedback_key = config.get('adhocracy.feedback_instance_key',
                                      u'feedback')
            feedback_label = config.get('adhocracy.feedback_instance_label',
                                        u'Feedback')
            feedback_available = model.Instance.find(feedback_key)
            if feedback_key and feedback_label and not feedback_available:
                log.debug('Creating feedback instance: %s' % feedback_label)
                fb = model.Instance.create(feedback_key, feedback_label, admin)
                fb.use_norms = False
                fb.allow_adopt = False
                fb.allow_delegate = False
                fb.hide_global_categories = True
                fb.require_valid_email = False

    if 'shibboleth' in allowed_login_types(config):
        mappings = config_get_json("adhocracy.shibboleth.userbadge_mapping",
                                   config=config)
        for mapping in mappings:
            title = mapping["title"]
            if model.UserBadge.find(title) is None:
                model.UserBadge.create(mapping["title"], u'#000000', True, u'')

    model.meta.Session.commit()

########NEW FILE########
__FILENAME__ = discriminator
import logging

from adhocracy import config as aconfig
from adhocracy import model
from adhocracy.lib.helpers.site_helper import base_url
from paste.deploy.converters import asbool
from webob import Response

log = logging.getLogger(__name__)


class InstanceDiscriminatorMiddleware(object):

    def __init__(self, app, domain, config):
        self.app = app
        self.domain = domain
        self.config = config
        log.debug("Host name: %s." % domain)
        if aconfig.get_bool('adhocracy.instance_domains.enabled',
                            config=config):
            instances_domains = aconfig.get_json('adhocracy.instance_domains',
                                                 {}, config=config)
            self.domains_instances = dict((v, k) for k, v
                                          in instances_domains.items())
        else:
            self.domains_instances = {}

    def __call__(self, environ, start_response):
        relative_urls = asbool(self.config.get('adhocracy.relative_urls',
                                               'false'))
        environ['adhocracy.domain'] = self.domain
        instance_key = self.config.get('adhocracy.instance')

        if instance_key is None:
            instance_key = self.domains_instances.get(environ.get('HTTP_HOST'))

        if instance_key is None:
            if relative_urls:
                path = environ.get('PATH_INFO', '')
                if path.startswith('/i/'):
                    instance_key = path.split('/')[2]
                    environ['PATH_INFO'] = path[len('/i/' + instance_key):]
                    if environ['PATH_INFO'] == '':
                        response = Response()
                        if instance_key == '':
                            response.status_int = 404
                            # Double slashes are stripped, so we can't redirect
                            # to /i//
                            return response(environ, start_response)

                        response.status_int = 302
                        response.headers['location'] = path + '/'
                        return response(environ, start_response)
            else:
                host = environ.get('HTTP_HOST', "")
                host = host.replace(self.domain, "")
                host = host.replace('localhost', "")
                host = host.split(':', 1)[0]
                host = host.strip('.').strip()
                instance_key = host

        if instance_key:  # instance key is set (neither None nor "")
            instance = model.Instance.find(instance_key)
            if instance is None:
                response = Response()
                if not relative_urls:
                    # HTTP_HOST needs to be set to an existing domain,
                    # otherwise we end up here again after being internally
                    # redirected from StatusCodeRedirect and produce a white
                    # page.
                    environ['HTTP_HOST'] = self.domain
                    # Fair handling of users prefixing everything with www.
                    if instance_key == 'www':
                        response.status_int = 301
                        response.headers['location'] = \
                            base_url(environ.get('PATH_INFO', '/'),
                                     absolute=True, config=self.config)
                        return response(environ, start_response)
                response.status_int = 404
                return response(environ, start_response)
            else:
                model.instance_filter.setup_thread(instance)
        try:
            return self.app(environ, start_response)
        finally:
            model.instance_filter.setup_thread(None)


def setup_discriminator(app, config):
    # warn if abdoned adhocracy.domains is used
    if config.get('adhocracy.domains') is not None:
        raise AssertionError('adhocracy.domains is not supported anymore. '
                             'use adhocracy.domain (without the s) with only '
                             'one domain')
    domain = config.get('adhocracy.domain').strip()
    return InstanceDiscriminatorMiddleware(app, domain, config)

########NEW FILE########
__FILENAME__ = logo
import os.path
import logging
import StringIO

try:
    import Image
except ImportError:
    from PIL import Image


from cache import memoize
import util

log = logging.getLogger(__name__)


"""This provides a simple api for adding logos to entities."""


FALLBACK = ['static', 'images', 'fallback.png']
INSTANCE = ['static', 'img', 'icons', 'site_64.png']
USER = ['static', 'img', 'icons', 'user.png']

ALLOWED_SIZES = [
    (32, 32), (None, 32),
    (48, 48), (None, 48),
    (64, 64), (None, 64),
    (256, 256), (None, 256),
    (320, 160),
]


class NoSuchSizeError(Exception):
    pass


def _entity_key(entity):
    if hasattr(entity, u'key'):
        return entity.key
    else:
        return u"%s-%i" % (entity.__class__.__name__, entity.id)


def validate_xy(x, y, y_default=24):
    try:
        y = int(y)
    except ValueError, ve:
        log.debug(ve)
        y = y_default
    try:
        x = int(x)
    except:
        x = None
    return x, y


def _logo_path(key):
    """the folder is called "instance" for backwards compability"""
    util.create_site_subdirectory('uploads', 'instance')
    return util.get_site_path('uploads', 'instance', key + '.png')


def store(entity, file):
    logo_image = Image.open(file)
    key = _entity_key(entity)
    logo_image.save(_logo_path(key))


def delete(entity):
    if exists(entity):
        key = _entity_key(entity)
        path = _logo_path(key)
        os.remove(path)
        return True


def exists(entity):
    key = _entity_key(entity)
    entity_path = _logo_path(key)
    return os.path.exists(entity_path)


def path_and_mtime(entity, fallback=None):
    """
    Return a tuple with the path to the entity's logo and
    the mtime (converted to an int).

    *entity*
        Get path and mtime for this entity
    *fallback* (tuple of str)
        A fallback path tuple to a logo if the entity
        doesn't have one.

    Returns:
       a (path (`str`), mtime (`int`)) tuple.
    """
    if fallback is None:
        fallback = FALLBACK
    key = _entity_key(entity)
    logo_path = _logo_path(key)
    if not os.path.exists(logo_path):
        logo_path = util.get_path(*fallback)
    mtime = os.path.getmtime(logo_path)
    # strip the fraction to get full seconds
    mtime = int(mtime)
    return logo_path, mtime


def load(entity, size, fallback=None):
    '''
    Load an entity logo or the fallback logo in a
    certain size.

    *entity*
         Get logo for this entity
    *size* (two-tuple of int)
         A tuple with the size like (x_size, y_size) where
         both are int values. x_size may be None in which case
         the image will be scaled down to y_size preserving
         the aspect ratio.

    Returns:
         A tuple with (image_path, mtime, image_data)
         Where image_path is the path on the file system,
         mtime is the mtime of the image file, and image_data
         is a string containing the image data.
    '''
    logo_path, mtime = path_and_mtime(entity, fallback)
    image_data = _load_with_mtime(logo_path, mtime, size)
    return (logo_path, mtime, image_data)


@memoize('instance_image', 3600 * 24)
def _load_with_mtime(logo_path, mtime, size):
    """
    Function to load the logo with sane caching.  The *mtime*
    parameter is the mtime of the current logo file. If the file
    changes it's mtime changes and we don't get outdated cache
    results anymore.

    *logo_path* (string)
         The path to the image file
    *mtime*
         The mtime of the image file or another unique identifier.
         This is used only to modify the cache key if the function
         is cached.
    *size* (two-tuple of int)
         A tuple with the size like (x_size, y_size) where
         both are int values. x_size may be None in which case
         the image will be scaled down to y_size preserving
         the aspect ratio. If x_size is not None the image may get
         cropped.

    Returns:
         A string containing the resized image data.
    """
    if size not in ALLOWED_SIZES:
        raise NoSuchSizeError()
    w, h = size
    logo_image = Image.open(logo_path)
    orig_w, orig_h = logo_image.size

    if w is None:
        # aspect ratio stays the same
        w = h * orig_w / orig_h
        logo_image.thumbnail((w, h), Image.ANTIALIAS)
    else:
        # The image is resized to be at least the requested size while
        # preserving the aspect ratio. Then it is cropped to the requested
        # size.
        if w * orig_h > h * orig_w:
            old_h = h * orig_w / w
            x0 = 0
            x1 = orig_w
            y0 = (orig_h - old_h) / 2
            y1 = y0 + old_h
        else:
            old_w = w * orig_h / h
            x0 = (orig_w - old_w) / 2
            x1 = x0 + old_w
            y0 = 0
            y1 = orig_h
        logo_image = logo_image.transform((w, h), Image.EXTENT,
                                          (x0, y0, x1, y1), Image.BICUBIC)

    sio = StringIO.StringIO()
    logo_image.save(sio, 'PNG')
    return sio.getvalue()

########NEW FILE########
__FILENAME__ = machine_name

import os
import platform


class IncludeMachineName(object):

    def __init__(self, app, config):
        self.app = app
        self.config = config

    def __call__(self, environ, start_response):
        def local_response(status, headers, exc_info=None):
            machine_id = '%s:%s (PID %d)' % (
                platform.node(), environ.get('SERVER_PORT'), os.getpid())
            headers.append(('X-Server-Machine', machine_id))
            start_response(status, headers, exc_info)
        return self.app(environ, local_response)

########NEW FILE########
__FILENAME__ = mail
import email
from email.header import Header
from email.mime.text import MIMEText
import logging
import smtplib
from time import time
import textwrap

from pylons.i18n import _

from adhocracy import config
from adhocracy.lib import helpers as h, version

log = logging.getLogger(__name__)
ENCODING = 'utf-8'


def send(email_from, to_email, message):
    server = smtplib.SMTP(config.get('smtp_server'),
                          config.get_int('smtp_port'))
    # server.set_debuglevel(1)
    server.sendmail(email_from, [to_email], message)
    server.quit()


def to_mail(to_name, to_email, subject, body, headers={}, decorate_body=True,
            email_from=None, reply_to=None, name_from=None):
    try:
        if email_from is None:
            email_from = config.get('adhocracy.email.from')
        if name_from is None:
            name_from = config.get('adhocracy.site.name')

        if decorate_body:
            body = (_(u"Hi %s,") % to_name +
                    u"\r\n\r\n%s\r\n\r\n" % body +
                    _(u"Cheers,\r\n\r\n"
                      u"    the %s Team\r\n") %
                    config.get('adhocracy.site.name'))

        # wrap body, but leave long words (e.g. links) intact
        body = u'\n'.join(textwrap.fill(line, break_long_words=False,
                                        break_on_hyphens=False)
                          for line in body.split(u'\n'))

        msg = MIMEText(body.encode(ENCODING), 'plain', ENCODING)

        for k, v in headers.items():
            msg[k] = v

        subject = Header(subject.encode(ENCODING), ENCODING)
        msg['Subject'] = subject
        msg['From'] = _("%s <%s>") % (name_from, email_from)
        to = Header(u"%s <%s>" % (to_name, to_email), ENCODING)
        msg['To'] = to
        if reply_to is not None:
            msg['Reply-To'] = reply_to
        msg['']
        msg['Date'] = email.Utils.formatdate(time())
        msg['X-Mailer'] = "Adhocracy SMTP %s" % version.get_version()
        # log.debug("MAIL\r\n" + msg.as_string())
        send(email_from, to_email, msg.as_string())
    except Exception:
        log.exception("Sending mail failed.")


def to_user(to_user, subject, body, headers={}, decorate_body=True,
            email_from=None, reply_to=None, name_from=None):
    return to_mail(to_user.name, to_user.email, subject, body, headers,
                   decorate_body, email_from, reply_to, name_from)


def send_activation_link(user):
    url = h.base_url("/user/%s/activate?c=%s" % (user.user_name,
                                                 user.activation_code),
                     instance=None, absolute=True)
    body = _("this email is to check the email address you have provided. "
             "In order to confirm this email address, please open the link "
             "below in your browser:") + "\r\n\r\n  " + url
    to_user(user, _("Confirm your email address"), body)

########NEW FILE########
__FILENAME__ = message
from pylons.i18n import _

from adhocracy import config
from adhocracy.lib.templating import render
from adhocracy.model import meta
from adhocracy.model import Message, MessageRecipient


def render_body(body, recipient, is_preview=False):
    from adhocracy.lib.auth.welcome import welcome_url

    if recipient.gender == 'f':
        salutation = _('Dear Ms.')
    elif recipient.gender == 'm':
        salutation = _('Dear Mr.')
    else:
        salutation = _('Dear')

    if is_preview:
        welcome_url = welcome_url(recipient,
                                  (u'X' * len(recipient.welcome_code)
                                   if recipient.welcome_code
                                   else u'NO_WELCOME_CODE_SET'))
    else:
        welcome_url = welcome_url(recipient, recipient.welcome_code)

    body = body.replace(u'{uid}', u'%d' % recipient.id)
    body = body.replace(u'{name}', recipient.name)
    body = body.replace(u'{email}', recipient.email)
    body = body.replace(u'{welcome_url}', welcome_url)
    body = body.replace(u'{salutation}', salutation)
    return body


def email_subject(message, recipient, _format=None):
    if _format is None:
        _format = _(u"[{site_name}] Message from {sender_name}: {subject}")
    return _format.format(**{
        'subject': message.subject,
        'sender_name': message.creator.name,
        'site_name': config.get('adhocracy.site.name'),
    })


def email_body(message, recipient, body, template=None, massmessage=True):
    if template is None:
        template = "/message/body.txt"
    return render(template, data={
        'message': message,
        'recipient': recipient,
        'massmessage': massmessage,
        'body': body,
    })


def _send(message, force_resend=False, massmessage=True,
          email_subject_format=None, email_body_template=None):
    from adhocracy.model import Notification
    from adhocracy.lib import mail, event

    if massmessage:
        event_type = event.T_MASSMESSAGE_SEND
    else:
        event_type = event.T_MESSAGE_SEND

    e = event.emit(event_type, message.creator, instance=message.instance,
                   message=message,
                   sender=message.creator)
    notification = Notification(e, message.creator)
    meta.Session.add(notification)

    for r in message.recipients:
        if force_resend or not r.email_sent:
            if (r.recipient.is_email_activated() and
                    r.recipient.email_messages):

                body = render_body(message.body, r.recipient)

                mail.to_user(r.recipient,
                             email_subject(message, r.recipient,
                                           email_subject_format),
                             email_body(message, r.recipient, body,
                                        email_body_template,
                                        massmessage=massmessage),
                             headers={},
                             decorate_body=False,
                             email_from=message.email_from,
                             name_from=message.name_from)

            # creator already got a notification
            if r.recipient != message.creator:
                notification = Notification(e, r.recipient,
                                            type=event.N_MESSAGE_RECEIVE)
                meta.Session.add(notification)

            r.email_sent = True

    meta.Session.commit()


def send(subject, body, creator, recipients, sender_email=None,
         sender_name=None, instance=None, include_footer=True,
         massmessage=True, email_subject_format=None,
         email_body_template=None):

    message = Message.create(subject, body, creator,
                             sender_email=sender_email,
                             sender_name=sender_name,
                             instance=instance,
                             include_footer=include_footer)

    for recipient in recipients:
        MessageRecipient.create(message, recipient)

    _send(message,
          massmessage=massmessage,
          email_subject_format=email_subject_format,
          email_body_template=email_body_template)

    return message

########NEW FILE########
__FILENAME__ = microblog
import json
from urllib2 import urlopen
from urllib import urlencode

from oauth import oauth

from adhocracy import config
from adhocracy.contrib.oauthtwitter import OAuthApi
from adhocracy.lib.cache import memoize

SHORTENER_URL = "http://api.bit.ly/shorten"

# No, I am not trying to spy on you but simply want to get around
# the nuisance of bit.ly API keys.
DEFAULT_SHORTENER_USER = "pudo"
DEFAULT_SHORTENER_KEY = "R_b3085006e627e897970d7bdd1d4fda95"


def system_user():
    return config.get('adhocracy.twitter.username')


def create_default():
    key = config.get('adhocracy.twitter.key')
    secret = config.get('adhocracy.twitter.secret')
    return create_oauth(key, secret)


def create_oauth(key=None, secret=None):
    token = None
    if key and secret:
        token = oauth.OAuthToken(key, secret)
    return OAuthApi(consumer_key=config.get('adhocracy.twitter.consumer_key'),
                    consumer_secret=config.get(
                        'adhocracy.twitter.consumer_secret'),
                    access_token=token)


@memoize('short_url')
def shorten_url(url):
    try:
        query = urlencode({
            'login': config.get('adhocracy.bitly.login',
                                DEFAULT_SHORTENER_USER),
            'apiKey': config.get('adhocracy.bitly.key',
                                 DEFAULT_SHORTENER_KEY),
            'longUrl': url.encode('utf-8'),
            'format': 'json',
            'version': '2.0.1'})
        request_url = SHORTENER_URL + "?" + str(query)
        data = json.loads(urlopen(request_url).read())
        if not data['statusCode'] == 'OK':
            return url
        return data['results'][url]['shortUrl']
    except:
        return url

########NEW FILE########
__FILENAME__ = openidstore
import logging

from openid.consumer.consumer import Consumer
from openid.store.sqlstore import MySQLStore, PostgreSQLStore, SQLiteStore

from adhocracy import config
from adhocracy.model import meta

SQL_STORES = {'sqlite': SQLiteStore,
              'mysql': MySQLStore,
              'postgres': PostgreSQLStore,
              'postgresql': PostgreSQLStore}

log = logging.getLogger(__name__)

store = None


def create_store():
    log.debug("Creating SQL-based OpenID store...")
    conn_str = config.get('sqlalchemy.url')
    if conn_str is None:
        raise ValueError("OpenID connection")
    db_type = conn_str.split(':')[0]
    store_cls = SQL_STORES.get(db_type)
    return store_cls(meta.engine.raw_connection())


def create_consumer(openid_session):
    global store
    if store is None:
        store = create_store()
    return Consumer(openid_session, store)

########NEW FILE########
__FILENAME__ = outgoing_link
# Track clicks on links to other websites.
# We implement this similar to google or facebook: The link is rewritten to
# our site, where it gets redirected (by the redirect controller)

import base64
import re
import lxml.etree

from adhocracy import config
from adhocracy.lib.crypto import sign, verify

REDIRECT_SALT = b'static link'


def rewrite_urls(body):
    from adhocracy.lib.helpers import base_url
    if not config.get_bool('adhocracy.track_outgoing_links'):
        return body

    doc = lxml.etree.fromstring('<body>' + body + '</body>')
    for a in doc.xpath('.//a[@href]'):
        if re.match(r'ftps?:|https?:|//', a.attrib['href']):
            url = a.attrib['href']

            # Is it a link to our own site?
            base = base_url('/', instance=None)
            if (url.startswith(base)
                    and not(url.startswith('//') and base == '/')):
                continue

            encoded_url = base64.urlsafe_b64encode(url.encode('utf-8'))
            signed_url = sign(encoded_url, salt=REDIRECT_SALT)
            redirect_url = u'/outgoing_link/' + signed_url.decode('utf-8')
            a.attrib['href'] = base_url(redirect_url)
    res = lxml.etree.tostring(doc)
    return res[len(b'<body>'):-len(b'</body>')]


def decode_redirect(signed_url):
    encoded_url = verify(signed_url.encode('utf-8'), salt=REDIRECT_SALT)
    url = base64.urlsafe_b64decode(encoded_url).decode('utf-8')
    return url

########NEW FILE########
__FILENAME__ = pager
import copy
from functools import partial
from inspect import isclass
import math
import logging
from ordereddict import OrderedDict
import time
import urllib

from formencode import validators
from pylons.i18n import _, lazy_ugettext, lazy_ugettext as L_
from pylons import request, tmpl_context as c, url
from pylons.controllers.util import redirect
from pylons.controllers.util import abort
from webob.multidict import MultiDict

from adhocracy import config
from adhocracy import model
from adhocracy.lib import sorting, tiles
from adhocracy.lib import votedetail
from adhocracy.lib.behavior import get_behavior
from adhocracy.lib.helpers import base_url
from adhocracy.lib.helpers.badge_helper import generate_thumbnail_tag
from adhocracy.lib.helpers.badge_helper import get_parent_badges
from adhocracy.lib.event.stats import user_activity, user_rating
from adhocracy.lib.search.index import get_sunburnt_connection
from adhocracy.lib.search.query import sunburnt_query, add_wildcard_query
from adhocracy.lib.templating import render_def
from adhocracy.lib.util import generate_sequence
from adhocracy.lib.util import split_filter

log = logging.getLogger(__name__)

MAX_SIZE = 500
PAGE_VALIDATOR = validators.Int(min=1, not_empty=True)
SIZE_VALIDATOR = validators.Int(min=1, max=MAX_SIZE, not_empty=True)


marker = object()


def sort_key_getter(item):
    entity = item.get('entity', None)
    if entity:
        for attribute in ['title', 'name', 'id']:
            value = getattr(entity, attribute, marker)
            if value is not marker:
                return value
    return item['facet_count'] * -1  # reverse sorting


def visible_pages(selected_page, pages):
    '''
    determinate which page links in a pager are visible
    and where the '...' seperators should be located.
    **Warning**: This code is 1-based!

    *selected_page*
        The selected page (index 1)
    *pages*
        The number of pages (index 1)
    Returns: A *(visible_pages , seperators)* tuple where both
    are lists.
    '''

    # If we have < 11 pages we show all page links
    # X X X O X X X X X X X
    if pages <= 11:
        return [range(1, pages + 1), []]

    # if we have > 11 pages, we select which boxes and
    # which seperators to show
    #
    # Case: near the start. Show the pages up to 9, a seperator
    # and the last 1
    # X X X X O X X X X ... X
    if selected_page <= 7:
        return [range(1, 9 + 1) + [pages], [10]]
    # Case: near the end. Show the first two pages, the seperator
    # and the last 9
    # X ... X X X X X O X X X
    if (pages - selected_page) <= 7:
        return [[1] + range(pages - 8, pages + 1), [2]]
    # Case: somewhere within the long list
    # X ... X X X O X X X ... X
    return [[1] + range(selected_page - 3, selected_page + 3 + 1) +
            [pages], [2, pages]]


class PagerMixin(object):

    @property
    def offset(self):
        return (self.page - 1) * self.size

    @property
    def pages(self):
        return int(math.ceil(self.total_num_items() / float(self.size)))

    def here(self):
        '''
        backwarts compatibility. Use :meth:`render_pager`.
        '''
        return self.render_pager()

    def page_sizes(self):
        total = self.total_num_items()

        if self.initial_size >= total:
            return []

        page_sizes = []
        sizes = generate_sequence(minimum=self.initial_size,
                                  maximum=min(total, MAX_SIZE))

        for size in sizes:
            page_sizes.append(
                {'current': size == self.size,
                 'url': self.build_url(size=size),
                 'size': size,
                 'last': False})

        if page_sizes:
            page_sizes[-1]['last'] = True
        return page_sizes

    def pages_items(self):

        visible_pages_, seperators = visible_pages(self.page, self.pages)

        items = []
        for number in xrange(1, self.pages + 1):
            if number in seperators:
                item = {'current': False,
                        'url': '',
                        'label': '...',
                        'class': '',
                        'seperator': True}
                items.append(item)

            item = {'current': self.page == number,
                    'url': self.build_url(page=number),
                    'label': str(number),
                    'class': 'hidden' if number not in visible_pages_ else '',
                    'seperator': False}
            items.append(item)

        return items

    def build_url(self, page=None, size=None, sort=None, facets=tuple(),
                  unselect_facets=tuple(), **kwargs):
        '''
        b/w compat
        '''
        query = MultiDict(request.params.items())
        query.update(kwargs)
        query[self.page_param] = page if page else 1
        query[self.size_param] = size if size else self.size
        query[self.sort_param] = sort if sort else self.selected_sort

        # sanitize the the query arguments
        query_items = ([(str(key), unicode(value).encode('utf-8')) for
                        (key, value) in query.items()])
        url_base = base_url(url.current(qualified=False))
        return url_base + "?" + urllib.urlencode(query_items)

    def to_dict(self):
        return self.items

    def render_pager(self):
        '''
        render the template for the pager (without facets)
        '''
        return render_def('/pager.html', 'namedpager', pager=self)

    def render_pages_nav(self):
        """Render template only for the pages navigation.

        This is implicitly called by render_pager. It is useful if you
        use some other mechanism to render the items.
        """
        return render_def('/pager.html', 'pages_nav', pager=self)

    @property
    def sort_param(self):
        return "%s_sort" % self.name

    @property
    def size_param(self):
        return "%s_size" % self.name

    @property
    def page_param(self):
        return "%s_page" % self.name

    def __len__(self):
        return self.total_num_items()


# --[ sql based NamedPager ]------------------------------------------------

class NamedPager(PagerMixin):
    """
    A ``NamedPager`` is a list generator for the UI. The ``name`` is required
    in order to distinguish multiple pagers working on the same page.
    """

    def __init__(self, name, items, itemfunc, initial_size=10,
                 size=None, sorts={}, default_sort=None, enable_sorts=True,
                 enable_pages=True, **kwargs):
        self.name = name
        self._items = items
        self.itemfunc = itemfunc
        self.initial_size = initial_size
        if size is not None:
            self.size = size
        elif c.user and c.user.page_size:
            self.size = c.user.page_size
        else:
            self.size = initial_size
        self.sorts = sorts
        if len(sorts.values()):
            self.selected_sort = sorts.values().index(default_sort) + 1
        else:
            self.selected_sort = 0
        self.sorted = False
        self.enable_sorts = enable_sorts
        self.enable_pages = enable_pages
        self.kwargs = kwargs
        self._parse_request()

    def _parse_request(self):
        try:
            page_value = request.params.get(self.page_param)
            self.page = PAGE_VALIDATOR.to_python(page_value)
        except:
            self.page = 1

        try:
            size_value = request.params.get(self.size_param)
            self.size = SIZE_VALIDATOR.to_python(size_value)
        except:
            pass

        try:
            sort_validator = validators.Int(min=1, max=len(self.sorts.keys()),
                                            not_empty=True)
            sort_value = request.params.get(self.sort_param)
            self.selected_sort = sort_validator.to_python(sort_value)
        except:
            pass

    @property
    def items(self):
        if not self.sorted and len(self.sorts.values()):
            sorter = self.sorts.values()[self.selected_sort - 1]
            self._items = sorter(self._items)
            self.sorted = True
        return self._items[self.offset:self.offset + self.size]

    def total_num_items(self):
        return len(self._items)


def instances(instances):
    OLDEST = 'OLDEST'
    NEWEST = 'NEWEST'
    ACTIVITY = 'ACTIVITY'
    ALPHA = 'ALPHA'
    sorts = {
        OLDEST: sorting.entity_oldest,
        NEWEST: sorting.entity_newest,
        ACTIVITY: sorting.instance_activity,
        ALPHA: sorting.delegateable_label
    }
    CONFIG_KEY = 'adhocracy.listings.instance.sorting'
    configured_sort = config.get(CONFIG_KEY, ACTIVITY)
    if configured_sort not in sorts:
        configured_sort = ACTIVITY
    return NamedPager('instances', instances, tiles.instance.row,
                      sorts={_("Oldest"): sorts[OLDEST],
                             _("Newest"): sorts[NEWEST],
                             _("Activity"): sorts[ACTIVITY],
                             _("Alphabetically"): sorts[ALPHA]},
                      default_sort=sorts[configured_sort],
                      size=20)  # FIXME: hardcoded for enquetebeteiligung


def proposals(proposals, default_sort=None, **kwargs):
    if default_sort is None:
        def_sort_id = get_def_proposal_sort_order()
        if def_sort_id is not None:
            default_sort = PROPOSAL_SORTS.by_value[def_sort_id].func

    sorts = {_("Newest"): sorting.entity_newest,
             _("Newest Comment"): sorting.delegateable_latest_comment,
             _("Most Support"): sorting.proposal_support,
             _("Mixed"): sorting.proposal_mixed,
             _("Controversy"): sorting.proposal_controversy,
             _("Alphabetically"): sorting.delegateable_label}

    if config.get_bool(u'adhocracy.proposal_pager_inline'):
        row = tiles.proposal.row_inline
    else:
        row = tiles.proposal.row

    return NamedPager('proposals', proposals, row, sorts=sorts,
                      default_sort=default_sort, **kwargs)


def help_strings():
    return {
        _("Newest"): _('Sort by proposal creation date'),
        _("Newest Comment"): _('Sort by date of the last comment'),
        _("Most Support"): _('Sort by number of votes for the proposal'),
        _("Mixed"): _('First sort by proposals with important badges, '
                      'then by the difference between number of votes '
                      'for and against and also prefer newer proposals'),
        _("Controversy"): _('Prefer proposals where the gap between votes for '
                            'and against is close, also proposals with more '
                            'absolut votes are rated slightly higher'),
        _("Alphabetically"): _('Sort by the characters of the proposal title'),
    }


def milestones(milestones, default_sort=None, **kwargs):
    if default_sort is None:
        default_sort = sorting.milestone_time
    sorts = {_("by date"): sorting.milestone_time,
             _("alphabetically"): sorting.delegateable_title}
    return NamedPager('milestones', milestones, tiles.milestone.row,
                      sorts=sorts, default_sort=default_sort, **kwargs)


def pages(pages, detail=True, default_sort=None, **kwargs):
    if default_sort is None:
        default_sort = sorting.hierarchical_title
    # Note: sorts order matters, see comment in PageController.index
    sorts = OrderedDict([
        (_("newest"), sorting.entity_newest),
        (_("most proposals"), sorting.norm_selections),
        (_("alphabetically"), sorting.delegateable_title),
        (_("hierarchical"), sorting.hierarchical_title)
    ])
    return NamedPager('pages', pages, tiles.page.row, sorts=sorts,
                      default_sort=default_sort, **kwargs)


def users(users, instance):
    activity_sorting = sorting.user_activity_factory(instance)
    sorts = {_("oldest"): sorting.entity_oldest,
             _("newest"): sorting.entity_newest,
             _("activity"): activity_sorting,
             _("alphabetically"): sorting.user_name}

    return NamedPager('users', users, tiles.user.row, sorts=sorts,
                      initial_size=20, default_sort=sorting.user_name)


def user_decisions(decisions):
    return NamedPager('decisions', decisions, tiles.decision.user_row,
                      sorts={_("oldest"): sorting.entity_oldest,
                             _("newest"): sorting.entity_newest},
                      default_sort=sorting.entity_newest)


def scope_decisions(decisions):
    return NamedPager('decisions', decisions, tiles.decision.scope_row,
                      sorts={_("oldest"): sorting.entity_oldest,
                             _("newest"): sorting.entity_newest},
                      default_sort=sorting.entity_newest)


def comments(comments):
    return NamedPager('comments', comments, tiles.comment.row,
                      sorts={_("oldest"): sorting.entity_oldest,
                             _("newest"): sorting.entity_newest},
                      default_sort=sorting.entity_newest)


def delegations(delegations):
    return NamedPager('delegations', delegations, tiles.delegation.row,
                      sorts={_("oldest"): sorting.entity_oldest,
                             _("newest"): sorting.entity_newest},
                      default_sort=sorting.entity_newest)


def events(events, pager_name='events', row_type='row', **kwargs):
    row = partial(tiles.event.event_row, row_type=row_type)
    return NamedPager(pager_name, events, row, **kwargs)


def polls(polls, default_sort=None, **kwargs):
    if default_sort is None:
        default_sort = sorting.polls_time
    return NamedPager('polls', polls, tiles.poll.row,
                      default_sort=default_sort, **kwargs)


# --[ solr pager ]----------------------------------------------------------


def entity_to_solr_token(entity):
    """ Returns the solr token string.
        For normal entities this is the (unicode) value of the reference
        attribute.
        For hierachical entities (badges only so far) it adds the parents
        reference attribute values as well making the solr path tokenizer work.
    """

    if isinstance(entity, model.Badge):
        path_seperator = u"/"
        parents = list(get_parent_badges(entity))
        parents.reverse()
        with_parents = parents + [entity]
        with_parents_values = map(model.refs.ref_attr_value, with_parents)
        token = path_seperator.join(with_parents_values)
        return token
    else:
        return model.refs.ref_attr_value(entity)


def solr_tokens_to_entities(tokens, entity_class):
    """ Returns the facet entity according to the solr token string and
        entity_class.
        For hierachical entities it supports tokens including the parents
        reference attribute values ("1/2/3").
    """
    if issubclass(entity_class, SolrFacetItem):
        return [entity_class.get_item(token) for token in tokens]
    else:
        entity_ids = [t.rpartition('/')[-1] for t in tokens]
        return model.refs.get_entities(entity_class, entity_ids)


class SolrIndexer(object):
    '''
    An indexer class to add information to the data
    which will be indexed in solr.
    '''

    @classmethod
    def add_data_to_index(cls, entity, data):
        """
        Add data from/based on *entity* to *data* which will be
        indexed in solr. Add information to it *data* or modify
        it. You don't need to return it.

        *entity*
           An :class:`adhocracy.model.meta.Indexable` object.
        *data*
           The data that will be send to solr.

        Return *None*
        """
        raise NotImplemented('has to be implemented in subclass')


class SolrFacet(SolrIndexer):
    """
    A Facet that can be used in searches.
    It's used like this:

    globally:
    >>> class SomeFacet(SolrFacet):
    ...     name = 'badge'
    ...     entity_type = Badge  # noqa
    ...     title = u'Badge'

    Only in a thread:
    >>> some_facet = SomeFacet('mypager_prefix', request)
    >>> q = solr_query()  # noqa
    >>> counts_query = q
    >>> exclusive_qs = []
    >>> # configure the queries further
    >>> q, counts_query, exclusive_qs = some_facet.add_to_queries(
    ...     q, counts_query, exclusive_qs)
    >>> response = q.execute()
    >>> counts_response = counts_query.execute()
    >>> exclusive_responses = dict(map(lambda ((k, q)): (k, q.execute()),
    ...                                exclusive_qs.iteritems()))
    >>> some_facet.update(response, counts_response, exclusive_responses)
    >>> some_facet.items
    [...]
    """

    # overwrite in subclasses
    name = None
    entity_type = None
    title = None
    description = None
    solr_field = None
    exclusive = False
    show_empty = False
    show_current_empty = True
    template = '/pager.html'
    template_def = 'facet'
    _response = None
    badge_type = None

    def __init__(self, param_prefix, request, **kwargs):
        # Translate the title and the description. We need to do that
        # during the request.
        self.title = self.title and _(self.title) or None
        self.description = self.description and _(self.description) or None
        self.param_prefix = param_prefix
        self.request = request
        self.request_key = "%s_facet" % param_prefix
        self.used = self._used(request)
        for (key, value) in kwargs.items():
            setattr(self, key, value)

    @property
    def response(self):
        if self._response is None:
            raise AssertionError('You have to .update() the facet first')
        return self._response

    @response.setter
    def response(self, response):
        self._response = response

    def get_thumbnail(self, entity):
        '''
        Returns a string with an img tag for the entity.
        Override to make use of this.
        '''
        return ''

    def add_to_queries(self, query, counts_query, exclusive_queries):
        '''
        Add the facet to the queries *query* and *counts_query*.
        The difference is that the *query* will be limited to facet values
        used in the request.

        Returns: the modified queries as a (query, counts_query) tuple
        '''
        query = query.facet_by(self.solr_field)
        counts_query = counts_query.facet_by(self.solr_field)

        if self.exclusive:
            exclusive_queries[self.solr_field] =\
                exclusive_queries[self.solr_field].facet_by(self.solr_field)

        for value in self.used:
            query = query.query(**{self.solr_field: value})

            for k, v in exclusive_queries.iteritems():
                if k != self.solr_field:
                    exclusive_queries[k] = v.query(**{self.solr_field: value})

        return query, counts_query, exclusive_queries

    def update(self, response, counts_response, exclusive_responses):
        '''
        Compute and update different attributes of the facet based
        on the solr *response* and the *base_query*.
        '''
        self.response = response
        self.counts_response = counts_response
        solr_field = self.solr_field

        # the counts in the current query which is limited to selected
        # facet values
        current_counts = response.facet_counts.facet_fields[solr_field]
        self.sorted_current_counts = sorted(current_counts,
                                            key=lambda(value, count): count,
                                            reverse=True)
        self.current_counts = dict(self.sorted_current_counts)

        # the counts in the base query which is not limited to selected
        # facet values
        facet_counts = counts_response.facet_counts.facet_fields[solr_field]
        self.sorted_facet_counts = sorted(facet_counts,
                                          key=lambda(value, count): count,
                                          reverse=True)
        self.facet_counts = dict(self.sorted_facet_counts)

        # the counts in the current query without the current query for this
        # facet if this is an exclusive (single value) facet
        if self.exclusive:
            exclusive_counts = exclusive_responses[solr_field]\
                .facet_counts.facet_fields[solr_field]
            self.sorted_exclusive_counts = sorted(
                exclusive_counts,
                key=lambda(value, count): count,
                reverse=True)
            self.exclusive_counts = dict(self.sorted_exclusive_counts)

        self.current_items = self._current_items()

    # fixme: memoize
    # fixme: this method is not used, joka
    def _facet_items(self, facet_counts):
        facet_items = []
        for (value, count) in facet_counts:
            facet_item = self._facet_item(value, count)
            if facet_item is not None:
                facet_items.append(facet_item)
        return self.sort_facet_items(facet_items)

    # fixme: this method is not used, joka
    def _facet_item(self, value, count):
        '''
        Return an item dict for the facet *value*.
        *selected_values* is list of values used in the current
        query. count is the number of entries for this value in
        the current query results.
        '''
        item = self.get_item_data(value)
        if item is None:
            return None
        item['facet_count'] = count
        item['value'] = value
        return item

    def sort_facet_items(self, items):
        '''
        hook to sort the items facet specific. This is a
        generic that works with entities and sorts by entity title,
        name or id, or by facet_count. It is only sensible if all
        entities have the same attributes.
        '''

        return sorted(items, key=sort_key_getter)

    def available(self, show_badge_admin_buttons=False):
        if show_badge_admin_buttons and self.badge_type is not None:
            return True
        if self.exclusive:
            return (len(self.sorted_facet_counts) > 0
                    and self.sorted_facet_counts[0][1] > 0)
        if not self.response:
            return False
        return bool(len(self.current_items))

    def _used(self, request):
        used = []
        for param in request.params.getall(self.request_key):
            try:
                facet, value = param.split(':')
            except ValueError:
                raise abort(404)

            if facet == self.name and value not in used:
                used.append(value)
        return used

    def _current_items(self):
        '''
        Return a list of facet items to display.
        '''

        def show_facet(current_count, token_count, show_empty,
                       show_current_empty):
            if show_empty:
                return True

            if current_count > 0 or show_current_empty:
                return True

            if token_count > 0 or show_empty:
                return True

            return False

        # get solr tokens and search counts and sort hierarchical
        token_counts = sorted(self.sorted_facet_counts, key=lambda x:
                              len(x[0].split("/")), reverse=True)

        # add the solr token (value) and search counts to the items
        facet_items = OrderedDict()
        for (token, token_count) in token_counts:
            if self.exclusive:
                current_count = self.exclusive_counts[token]
            else:
                current_count = self.current_counts[token]

            if show_facet(current_count, token_count,
                          self.show_empty, self.show_current_empty):
                facet_items[token] = {'current_count': current_count,
                                      'value': token}

        for i, e in zip(facet_items.keys(),
                        solr_tokens_to_entities(facet_items.keys(),
                                                self.entity_type)):
            facet_items[i]['entity'] = e

        # add data to display the items
        for token, item in facet_items.items():
            try:
                entity = item['entity']
            except KeyError:
                log.error(u'Cannot decode entity ref. Maybe the solr index '
                          u'contains invalid refs and needs to be dropped '
                          u'and rebuilt.')
                facet_items.pop(token)
                continue
            item['link_text'] = self.get_item_label(entity)
            item['disabled'] = (item['current_count'] == 0)
            item['selected'] = item['value'] in self.used
            item['url'] = self.get_item_url(item)
            item['visible'] = getattr(entity, 'visible', 'default')
            item['level'] = len((token).split("/"))
            item['children'] = []
            item['open'] = False
            item['hide_checkbox'] = False
            item['thumbnail'] = self.get_thumbnail(entity)

        if self.exclusive:
            lower, top = split_filter(lambda x: '/' in x, facet_items.keys())
            disable_toplevel = (len(top) == 1 and len(lower) > 0)

        for token in sorted(facet_items.keys(),
                            key=lambda x: x.count('/'),
                            reverse=True):
            item = facet_items[token]
            if item['selected']:
                item['open'] = True
            parent_token = token.rpartition('/')[0]
            if parent_token:
                parent = facet_items[parent_token]
                parent['children'].append(item)
                if item['open']:
                    parent['open'] = True
                facet_items.pop(token)
            else:
                if self.exclusive and disable_toplevel:
                    item['open'] = True
                    item['disabled'] = True
                    item['hide_checkbox'] = True

        return facet_items.values()

    def get_item_label(self, entity):
        for attribute in ['label', 'title', 'name']:
            if hasattr(entity, attribute):
                return getattr(entity, attribute)

        raise ValueError(('Could not find a label for facet '
                          '%s from entity %s') % (self.name, entity))

    def get_item_url(self, item):
        '''
        build a new url for the action when you click on it to
        select or unselect the item.
        '''
        if self.exclusive:
            if item['selected']:
                values = []
            else:
                values = [item['value']]
        else:
            values = self.used[:]
            if item['selected']:
                values.remove(item['value'])
            else:
                values.append(item['value'])
        return self.build_url(self.request, values)

    def unselect_all_link(self):
        '''
        return an url where no value for this facet is selected
        '''
        return self.build_url(self.request, [])

    def build_url(self, request, facet_values):
        '''
        Build an url from the *request* and the *facet_value*
        '''
        params = self.build_params(request, facet_values)
        url_base = base_url(url.current(qualified=False))
        if params:
            return url_base + '?' + urllib.urlencode(params)
        else:
            return url_base

    def build_params(self, request, facet_values):
        '''
        Build query parameters using the facet_values for this facet
        and the request.

        Returns: a list of (parameter, value) two-tuples
        '''
        params = MultiDict(request.params)

        # removing all ..._facet parameters and add them again
        current_facet_parameters = params.getall(self.request_key)
        if self.request_key in params:
            del params[self.request_key]

        # readd all _facet parameters not related to us
        for parameter in current_facet_parameters:
            name, value = parameter.split(':')
            if name != self.name:
                params.add(self.request_key, parameter)

        # add parameters for our facets
        facet_values = list(set(facet_values))
        for value in facet_values:
            params.add(self.request_key, "%s:%s" % (self.name, value))

        # sanitize and encode
        items = ([(str(key), unicode(value).encode('utf-8')) for
                  (key, value) in params.items()])
        return items

    def render(self):
        return render_def(self.template, self.template_def, facet=self)


class UserBadgeFacet(SolrFacet):

    name = 'userbadge'
    entity_type = model.Badge
    title = u'Badge'
    show_current_empty = False
    badge_type = 'user'

    @staticmethod
    def get_solr_field(instance):
        solr_field = 'facet.badges'
        if instance is None:
            return solr_field
        else:
            return '%s.%s' % (solr_field, instance.key)

    @property
    def solr_field(self):
        # self.instance needs to be set
        return self.get_solr_field(self.instance)

    @classmethod
    def add_data_to_index(cls, user, index):
        if not isinstance(user, model.User):
            return
        for instance in model.Instance.all(include_hidden=True):
            index[cls.get_solr_field(instance)] =\
                [entity_to_solr_token(badge)
                 for badge in user.get_badges(instance)]


class InstanceBadgeFacet(SolrFacet):

    name = 'instancebadge'
    entity_type = model.Badge
    title = lazy_ugettext(u'Badge')
    solr_field = 'facet.instance.badges'
    show_current_empty = False
    badge_type = 'instance'

    @classmethod
    def add_data_to_index(cls, instance, index):
        if not isinstance(instance, model.Instance):
            return
        d = [entity_to_solr_token(badge) for badge in instance.badges]
        index[cls.solr_field] = d


class SolrFacetItem(object):
    """
    Base class for facet items, which aren't Adhocracy entities, e.g. entity
    attribute values.
    """

    translate = False

    def __init__(self, label):
        if self.translate:
            self.label = _(label)
        else:
            self.label = label

    @classmethod
    def get_item(cls, token):
        return cls(token)


class TranslatedSolrFacetItem(SolrFacetItem):

    translate = True


class InstanceHiddenStateFacet(SolrFacet):

    name = 'instance_hidden_state'
    entity_type = TranslatedSolrFacetItem
    title = lazy_ugettext(u'Instance hidden state')
    solr_field = 'facet.instance.hidden_state'

    HIDDEN = u'hidden'
    VISIBLE = u'visible'

    # make sure these strings are extracted
    lazy_ugettext(u'hidden')
    lazy_ugettext(u'visible')

    @classmethod
    def add_data_to_index(cls, instance, index):
        if not isinstance(instance, model.Instance):
            return
        hidden_val = cls.HIDDEN if instance.hidden else cls.VISIBLE
        index[cls.solr_field] = [hidden_val]


class InstanceStateFacet(SolrFacet):

    name = 'instance_state'
    entity_type = TranslatedSolrFacetItem
    title = lazy_ugettext(u'Instance state')
    solr_field = 'facet.instance.state'

    FROZEN = u'frozen'
    OPEN = u'open'

    # make sure these strings are extracted
    lazy_ugettext(u'frozen')
    lazy_ugettext(u'open')

    @classmethod
    def add_data_to_index(cls, instance, index):
        if not isinstance(instance, model.Instance):
            return
        frozen_val = cls.FROZEN if instance.frozen else cls.OPEN
        index[cls.solr_field] = [frozen_val]


class InstanceFacet(SolrFacet):

    name = 'instance'
    entity_type = model.Instance
    title = lazy_ugettext(u'Instance')
    solr_field = 'facet.instances'

    @classmethod
    def add_data_to_index(cls, user, index):
        if not isinstance(user, model.User):
            return
        index[cls.solr_field] = [entity_to_solr_token(instance)
                                 for instance
                                 in user.get_instances(include_hidden=True)]


class DelegateableBadgeCategoryFacet(SolrFacet):
    """Index all delegateable badge categories"""

    name = 'delegateablebadgecategory'
    entity_type = model.Badge
    title = lazy_ugettext(u'Categories')
    solr_field = 'facet.delegateable.badgecategory'
    badge_type = 'category'
    exclusive = True

    @property
    def show_current_empty(self):
        return not config.get_bool(
            'adhocracy.hide_empty_categories_in_facet_list')

    @classmethod
    def add_data_to_index(cls, entity, data):
        if not isinstance(entity, model.Delegateable):
            return
        data[cls.solr_field] = [entity_to_solr_token(b)
                                for b in entity.categories]


class DelegateableBadgeThumbnailFacet(SolrFacet):
    """Index all delegateable badge thumbnails"""

    name = 'delegateablebadgethumbnail'
    entity_type = model.Badge
    title = lazy_ugettext(u'Status')
    solr_field = 'facet.delegateable.badgethumbnail'
    show_current_empty = False
    exclusive = True
    badge_type = 'thumbnail'

    def get_thumbnail(self, entity):
        return generate_thumbnail_tag(entity, 16, 16)

    @classmethod
    def add_data_to_index(cls, entity, data):
        if not isinstance(entity, model.Delegateable):
            return
        data[cls.solr_field] = [entity_to_solr_token(badge) for
                                badge in entity.thumbnails]


class DelegateableBadgeFacet(SolrFacet):
    """Index all delegateable badges"""

    name = 'delegateablebadge'
    entity_type = model.Badge
    title = lazy_ugettext(u'Badges')
    solr_field = 'facet.delegateable.badge'
    show_current_empty = False
    badge_type = 'delegateable'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if not isinstance(entity, model.Delegateable):
            return
        d = [entity_to_solr_token(badge) for badge in entity.badges]
        data[cls.solr_field] = d


class DelegateableAddedByBadgeFacet(SolrFacet):

    name = 'added_by_badge'
    entity_type = model.Badge
    title = lazy_ugettext(u'Created by')
    solr_field = 'facet.delegateable.added.by.badge'
    show_current_empty = False
    badge_type = 'user'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if not isinstance(entity, model.Delegateable):
            return
        data[cls.solr_field] = [entity_to_solr_token(badge) for
                                badge in entity.creator.badges if
                                (badge.instance is entity.instance or
                                 badge.instance is None)]


class DelegateableTags(SolrFacet):

    name = 'delegateabletags'
    entity_type = model.Tag
    title = lazy_ugettext(u'Tags')
    solr_field = 'facet.delegateable.tags'
    show_current_empty = False

    @classmethod
    def add_data_to_index(cls, entity, data):
        if not isinstance(entity, model.Delegateable):
            return
        tags = []
        for tag, count in entity.tags:
            tags.extend([entity_to_solr_token(tag)] * count)
        data[cls.solr_field] = tags


class DelegateableMilestoneFacet(SolrFacet):

    name = 'delegateablemilestone'
    entity_type = model.Milestone
    title = lazy_ugettext(u'Milestones')
    solr_field = 'facet.delegateable.milestones'
    show_current_empty = False

    @classmethod
    def add_data_to_index(cls, entity, data):
        if not isinstance(entity, model.Delegateable):
            return
        if entity.milestone is not None:
            data[cls.solr_field] = [entity.milestone.id]
        else:
            return []


class DelegateableFrozenIndexer(SolrIndexer):

    solr_field = 'facet.delegateable.frozen'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Delegateable):
            data[cls.solr_field] = entity.frozen


class CommentOrderIndexer(SolrIndexer):

    solr_field = 'order.comment.order'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Comment):
            data[cls.solr_field] = sorting.comment_order_key(entity)


class CommentScoreIndexer(SolrIndexer):

    solr_field = 'order.comment.score'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Comment):
            data[cls.solr_field] = entity.poll.tally.score


class NormNumSelectionsIndexer(SolrIndexer):

    solr_field = 'order.norm.num_selections'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if (isinstance(entity, model.Page) and
                entity.function == model.Page.NORM):
            data[cls.solr_field] = len(entity.selections)


class NormNumVariantsIndexer(SolrIndexer):

    solr_field = 'order.norm.selections'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if (isinstance(entity, model.Page) and
                entity.function == model.Page.NORM):
            data[cls.solr_field] = len(entity.selections)


class ProposalNumCommentsIndexer(SolrIndexer):

    solr_field = 'order.proposal.comments'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Delegateable):
            data[cls.solr_field] = len(entity.comments)


class ProposalNewestCommentsIndexer(SolrIndexer):

    solr_field = 'order.newestcomment'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            if entity.comment_count() > 0:
                commenttime = entity.find_latest_comment_time()
                value = time.mktime(commenttime.timetuple())
                data[cls.solr_field] = value


class ProposalSupportIndexer(SolrIndexer):

    solr_field = 'order.proposal.support'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            data[cls.solr_field] = entity.rate_poll.tally.score


class ProposalVotesIndexer(SolrIndexer):

    solr_field = 'order.proposal.votes'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            tally = entity.rate_poll.tally
            data[cls.solr_field] = tally.num_for + tally.num_against


class ProposalVotesYesIndexer(SolrIndexer):

    solr_field = 'order.proposal.yesvotes'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            tally = entity.rate_poll.tally
            data[cls.solr_field] = tally.num_for


class ProposalVotesNoIndexer(SolrIndexer):

    solr_field = 'order.proposal.novotes'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            tally = entity.rate_poll.tally
            data[cls.solr_field] = tally.num_against


class ProposalMixedIndexer(SolrIndexer):

    solr_field = 'order.proposal.mixed'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            data[cls.solr_field] = sorting.proposal_mixed_key(entity)


class ProposalSupportImpactIndexer(SolrIndexer):

    solr_field = 'order.proposal.support_impact'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            data[cls.solr_field] = sorting.proposal_support_impact_key(entity)


class ProposalControversyIndexer(SolrIndexer):

    solr_field = 'order.proposal.controversy'

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.Proposal):
            data[cls.solr_field] = sorting.proposal_controversy_key(entity)


class ProposalVotedetailScoreIndexer(SolrIndexer):

    @classmethod
    def solr_field(cls, userbadge):
        field = 'order.user.votedetail.score'
        if userbadge is not None:
            field = field + '.%s' % userbadge.title
        else:
            assert False
        return field

    @classmethod
    def add_data_to_index(cls, entity, data):
        if votedetail.is_enabled()\
           and isinstance(entity, model.Proposal):

            for b, t in votedetail.calc_votedetail(entity.instance,
                                                   entity.rate_poll):
                data[cls.solr_field(b)] = t.num_for - t.num_against


class InstanceUserJoinTimeIndexer(SolrIndexer):

    @classmethod
    def solr_field(cls, instance=None):
        field = 'order.user.create_time'
        if instance is not None:
            field = field + '.%s' % instance.key
        return field

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.User):
            for instance in entity.instances:
                join_time = entity.instance_membership(instance)\
                    .create_time.strftime("%s")
                data[cls.solr_field(instance)] = join_time


class InstanceUserActivityIndexer(SolrIndexer):

    @classmethod
    def solr_field(cls, instance=None):
        field = 'order.user.activity'
        if instance is not None:
            field = field + '.%s' % instance.key
        return field

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.User):
            activity_sum = 0
            for instance in entity.instances:
                activity = user_activity(instance, entity)
                data[cls.solr_field(instance)] = activity
                activity_sum = activity_sum + activity
            data[cls.solr_field()] = activity_sum


class InstanceUserRatingIndexer(SolrIndexer):

    @classmethod
    def solr_field(cls, instance=None):
        field = 'order.user.rating'
        if instance is not None:
            field = field + '.%s' % instance.key
        return field

    @classmethod
    def add_data_to_index(cls, entity, data):
        if isinstance(entity, model.User):
            rating_sum = 0
            for instance in entity.instances:
                rating = user_rating(instance, entity)
                data[cls.solr_field(instance)] = rating
                rating_sum = rating_sum + rating
            data[cls.solr_field()] = rating_sum


class SolrPager(PagerMixin):
    """
    A pager which is compatible to :class:`adhocracy.lib.pager.NamedPager` but
    uses Solr as backend and adds Solr specific functionality.

    * If `extra_filter` is set, the key-value pairs of this dict are added
    as filters to this pager.
    * If `alternatives_filter` is set, another filter is added to the pager,
    which filters the pager items by either of the specified
    alternative_filters (OR).

    If both is specified, the combined filter is (extra_filter_1 AND
    extra_filter_2 AND ... AND (alternative_filter_1 OR alternative_filter_2
    OR ...).

    """

    def __init__(self, name, itemfunc, entity_type=None, extra_filter=None,
                 initial_size=20, size=None, sorts=None,
                 enable_sorts=True, enable_pages=True, facets=tuple(),
                 wildcard_queries=None, alternatives_filter=None):
        self.name = name
        self.itemfunc = itemfunc
        self.enable_pages = enable_pages
        self.extra_filter = extra_filter
        self.alternatives_filter = alternatives_filter
        self.facets = [Facet(self.name, request, **kwargs)
                       for Facet, kwargs in facets]
        self.wildcard_queries = wildcard_queries or {}
        self.initial_size = initial_size
        if size is not None:
            self.size = size
        elif c.user and c.user.page_size:
            self.size = c.user.page_size
        else:
            self.size = initial_size
        self.size = self._get_size()

        self.enable_sorts = enable_sorts
        self.sorts = sorts
        self.sorts.set_pager(pager=self)
        if self.sorts:
            self.selected_sort = self.sorts.selected().value

        self.page = self._get_page()

        # build the query
        query = sunburnt_query(entity_type)
        if self.extra_filter:
            query = query.filter(**self.extra_filter)
        for field, string in self.wildcard_queries.items():
            query = add_wildcard_query(query, field, string)

        if self.alternatives_filter:
            si = get_sunburnt_connection()

            # build OR-filter using sunburnt optional query terms
            q = reduce(lambda acc, (k, v): acc | si.Q(**{k: v}),
                       self.alternatives_filter.items(), si.Q())

            query = query.filter(q)

        # Add facets
        counts_query = query
        counts_query = counts_query.paginate(rows=0)

        exclusive_queries = dict((f.solr_field, counts_query)
                                 for f in self.facets if f.exclusive)

        query.faceter.update(limit='65000')
        counts_query.faceter.update(limit='65000')
        map(lambda q: q.faceter.update(limit='65000'),
            exclusive_queries.values())

        for facet in self.facets:
            query, counts_query, exclusive_queries = facet.add_to_queries(
                query, counts_query, exclusive_queries)

        # Add pagination and sorting
        if enable_pages:
            query = query.paginate(start=self.offset, rows=self.size)

        if self.selected_sort is not None:
            query = query.sort_by(self.selected_sort)

        # query solr and calculate values from it
        self.response = query.execute()
        self.counts_response = counts_query.execute()
        self.exclusive_responses = dict(map(lambda ((k, q)): (k, q.execute()),
                                            exclusive_queries.iteritems()))

        # if we are out of the page range do a permanent redirect
        # to the last page
        if (self.pages > 0) and (self.page > self.pages):
            new_url = self.build_url(page=self.pages)
            redirect(new_url, code=301)

        for facet in self.facets:
            facet.update(self.response, self.counts_response,
                         self.exclusive_responses)
        self.items = self._items_from_response(self.response)

    def total_num_items(self):
        '''
        return the total numbers of results
        '''
        return self.response.result.numFound

    def _items_from_response(self, response):
        '''
        Get model objects form the documents returned
        in the solr *response*.
        '''
        items = []
        if not response.result.numFound:
            return items

        # Don't use entity_type.find_all() cause
        # it won't preserve the order of items.
        refs = [doc['ref'] for doc in response.result.docs]
        entities = model.refs.to_entities(refs)
        return entities

    def _get_page(self):
        page = 1
        try:
            page_value = request.params.get(self.page_param)
            page = PAGE_VALIDATOR.to_python(page_value)
        finally:
            return page

    def _get_size(self):

        size = self.size
        try:
            size_value = request.params.get(self.size_param)
            size = SIZE_VALIDATOR.to_python(size_value)
        finally:
            return size

    def render_facets(self, cls=None, exclude=[]):
        '''
        render all facets
        '''
        return render_def('/pager.html', 'facets', pager=self, cls=cls,
                          exclude=exclude)


class SortOption(object):

    def __init__(self, value, label, old=None, func=None, description=None):
        self.value = value
        self.label = label
        self.old = old
        self.func = func
        self.description = description

    def __call__(self, **kwargs):
        '''
        Factory to return a modified copy of self.
        '''
        value = kwargs.get('value', self.value)
        label = kwargs.get('label', self.label)
        old = kwargs.get('old', self.old)
        func = kwargs.get('func', self.func)
        description = kwargs.get('description', self.description)
        return SortOption(value, label, old=old, func=func,
                          description=description)

    def __eq__(self, other):
        return self.value == other.value


class NamedSort(object):

    pager = None

    def __init__(self, sortoptions=tuple(), default=None,
                 template='/pager.html', mako_def="sort_dropdown"):
        '''
        *sortsoptions* (iterable)
            An list of (<groupname>, <optionslist>) tuples where
            <optionslist> itself is a list of :class:`SortOption` s.
        *default* (:class:`SortOption`)
            A :class:`SortOption` object for the default sort.
        *template* (str)
            The (mako) Template used to render the sort options.
        *mako_def* (str)
            The name of the make def to use.
        '''
        self.by_value = {}
        self.by_old = {}
        self.by_group = {}
        self.groups = []
        for (group_label, optionslist) in sortoptions:
            self.add_group(group_label, optionslist)

        # set the default
        if default is not None:
            assert default.value in self.by_value
            self._default = default.value

        self.template = template
        self.mako_def = mako_def

    @property
    def default(self):
        if self._default in self.by_value:
            return self.by_value[self._default]
        else:
            return self.by_group[self.groups[0]][0]

    @default.setter
    def default(self, default):
        assert default in self.by_value
        self._default = default

    def current_value(self):
        return request.params.get(self.pager.sort_param)

    def selected(self):
        value = self.current_value()

        if value is None:
            return self.default

        try:
            return self.by_value[value]
        except KeyError:
            try:
                new_value = self.by_old[value].value
                redirect(self.pager.build_url(sort=new_value), code=301)
            except KeyError:
                redirect(self.pager.build_url(sort=self.default.value,
                                              code=301))

    def add_group(self, label, options):
        assert (label not in self.groups), 'We do not support changing groups'
        self.groups.append(label)
        self.by_group[label] = options
        for option in options:
            assert isinstance(option, SortOption)
            assert option.value not in self.by_value
            self.by_value[option.value] = option
            if option.old is not None:
                assert option.old not in self.by_old
                self.by_old[option.old] = option

    def set_pager(self, pager):
        self.pager = pager

    def render(self):
        return render_def(self.template, self.mako_def, sorts=self)

    def grouped_options(self):
        return [(group, self.by_group[group]) for group in self.groups]

    def __len__(self):
        return len(self.by_value.keys())


OLDEST = SortOption('+create_time', L_("Oldest"))
NEWEST = SortOption('-create_time', L_("Newest"), func=sorting.entity_newest)
NEWEST_COMMENT = SortOption('-order.newestcomment', L_("Newest Comment"),
                            func=sorting.delegateable_latest_comment)
ACTIVITY = SortOption('-activity', L_("Activity"))
ALPHA = SortOption('order.title', L_("Alphabetically"),
                   func=sorting.delegateable_label)
PROPOSAL_SUPPORT = SortOption('-order.proposal.support', L_("Most Support"),
                              description=L_('Yays - nays'),
                              func=sorting.proposal_support)
PROPOSAL_VOTES = SortOption('-order.proposal.votes', L_("Most Votes"),
                            description=L_('Yays + nays'))
PROPOSAL_YES_VOTES = SortOption('-order.proposal.yesvotes', L_("Most Ayes"))
PROPOSAL_NO_VOTES = SortOption('-order.proposal.novotes', L_("Most Nays"))
PROPOSAL_SUPPORT_IMPACT = SortOption('-order.proposal.support_impact',
                                     L_("Support with impact"))
PROPOSAL_MIXED = SortOption('-order.proposal.mixed', L_('Mixed'),
                            description=L_('Age and Support'),
                            func=sorting.proposal_mixed)
PROPOSAL_CONTROVERSY = SortOption('-order.proposal.controversy',
                                  L_('Controversy'),
                                  func=sorting.proposal_controversy)


def get_user_sorts(instance=None, default='ACTIVITY'):
    activity = SortOption(
        '-%s' % InstanceUserActivityIndexer.solr_field(instance),
        L_('Activity'))

    rating = SortOption(
        '-%s' % InstanceUserRatingIndexer.solr_field(instance),
        L_('Rating'))

    if instance is None:
        oldest = OLDEST
        newest = NEWEST
    else:
        oldest = SortOption(
            '+%s' % InstanceUserJoinTimeIndexer.solr_field(instance),
            L_('Oldest'))
        newest = SortOption(
            '-%s' % InstanceUserJoinTimeIndexer.solr_field(instance),
            L_('Newest'))
    sorts = {"OLDEST": oldest,
             "NEWEST": newest,
             "ACTIVITY": activity,
             "RATING": rating,
             "ALPHA": ALPHA}

    return NamedSort([[L_('Date'), (oldest(old=1),
                                    newest(old=2))],
                      [L_('User behavior'), (activity(old=3),
                                             rating(old=4))],
                      [L_('Other'), (ALPHA(old=5),)]],
                     default=sorts.get(default, 'ACTIVITY'),
                     mako_def="sort_slidedown")


INSTANCE_SORTS = NamedSort([[None, (OLDEST(old=1),
                                    NEWEST(old=2),
                                    ACTIVITY(old=3),
                                    ALPHA(old=4))]],
                           default=ACTIVITY,
                           mako_def="sort_dropdown")


PROPOSAL_SORTS = NamedSort([[L_('Support'), (PROPOSAL_SUPPORT(old=2),
                                             PROPOSAL_VOTES,
                                             PROPOSAL_YES_VOTES,
                                             PROPOSAL_NO_VOTES,
                                             PROPOSAL_SUPPORT_IMPACT,
                                             PROPOSAL_CONTROVERSY)],
                            [L_('Date'), (NEWEST(old=1,
                                                 label=L_('Newest Proposals')),
                                          NEWEST_COMMENT)],
                            [L_('Other'), (ALPHA(old=4),
                                           PROPOSAL_MIXED(old=3))]],
                           default=PROPOSAL_MIXED,
                           mako_def="sort_slidedown")


def solr_instance_users_pager(instance, default_sorting='ACTIVITY'):
    extra_filter = {'facet.instances': instance.key}
    pager = SolrPager('users', tiles.user.row,
                      entity_type=model.User,
                      sorts=get_user_sorts(instance, default_sorting),
                      extra_filter=extra_filter,
                      facets=[(UserBadgeFacet, {'instance': instance})])
    return pager


def solr_global_users_pager(default_sorting='ACTIVITY'):
    pager = SolrPager('users', tiles.user.row,
                      entity_type=model.User,
                      sorts=get_user_sorts(None, default_sorting),
                      facets=[(UserBadgeFacet, {'instance': None}),
                              (InstanceFacet, {})]
                      )
    return pager


def solr_instance_pager(include_hidden=False):
    # override default sort
    custom_default = config.get('adhocracy.listings.instance.sorting')
    sorts = {"ALPHA": ALPHA,
             "ACTIVITY": ACTIVITY,
             "NEWEST": NEWEST,
             "OLDEST": OLDEST}
    instance_sorts = copy.copy(INSTANCE_SORTS)
    if custom_default and custom_default in sorts:
        instance_sorts._default = sorts[custom_default].value
    if include_hidden:
        extra_filter = None
        facets = [(InstanceBadgeFacet, {}),
                  (InstanceStateFacet, {}),
                  (InstanceHiddenStateFacet, {})]
    else:
        extra_filter = {'hidden': False}
        facets = [(InstanceBadgeFacet, {}),
                  (InstanceStateFacet, {})]
    # create pager
    pager = SolrPager('instances', tiles.instance.row,
                      entity_type=model.Instance,
                      sorts=instance_sorts,
                      extra_filter=extra_filter,
                      facets=facets,
                      )
    return pager


def solr_proposal_pager(instance, wildcard_queries=None, default_sorting=None,
                        extra_filter={}, alternatives_filter={}):
    extra_filter.update({'instance': instance.key})
    sorts = copy.deepcopy(PROPOSAL_SORTS)
    if default_sorting is None:
        default_sorting = get_def_proposal_sort_order()
    if default_sorting is not None:
        sorts.default = default_sorting
    if votedetail.is_enabled():
        badges = instance.votedetail_userbadges
        if badges:
            sorts.add_group(L_('Support by'), tuple([
                SortOption(
                    '-%s' % ProposalVotedetailScoreIndexer.solr_field(
                        badge), badge.title)()
                for badge in instance.votedetail_userbadges]))

    facets = [(DelegateableBadgeCategoryFacet, {}),
              (DelegateableBadgeFacet, {}),
              (DelegateableAddedByBadgeFacet, {}),
              (DelegateableTags, {})]

    if instance.allow_thumbnailbadges:
        facets.insert(3, (DelegateableBadgeThumbnailFacet, {}))

    if instance.milestones:
        facets.insert(1, (DelegateableMilestoneFacet, {}))

    if config.get_bool(u'adhocracy.proposal_pager_inline'):
        row = tiles.proposal.row_inline
    else:
        row = tiles.proposal.row

    pager = SolrPager('proposals', row,
                      entity_type=model.Proposal,
                      sorts=sorts,
                      extra_filter=extra_filter,
                      facets=facets,
                      wildcard_queries=wildcard_queries,
                      alternatives_filter=alternatives_filter)
    return pager


def get_def_proposal_sort_order():
    default_sorting = None
    if c.user and c.user.proposal_sort_order:
        default_sorting = c.user.proposal_sort_order
    if default_sorting is None:
        bso = get_behavior(c.user, 'proposal_sort_order')
        if bso:
            default_sorting = bso
    if default_sorting is None:
        default_sorting = config.get(
            'adhocracy.listings.instance_proposal.sorting')
    if default_sorting is None:
        default_sorting = '-order.proposal.mixed'
    return default_sorting


INDEX_DATA_FINDERS = [v for v in globals().values()
                      if (isclass(v) and issubclass(v, SolrIndexer) and
                          ((v is not SolrFacet) and (v is not SolrIndexer)))]

########NEW FILE########
__FILENAME__ = queue
from collections import defaultdict
import json
from logging import getLogger

from paste.deploy.converters import asbool
from redis import Redis
from rq import Queue
from rq.job import Job

from adhocracy import config
from adhocracy.model import meta
from adhocracy.model.refs import to_ref, to_entity

log = getLogger(__name__)

LISTENERS = defaultdict(list)


class async(object):
    """
    An decorator that replaces rq's `.enqueue()` method that detects
    if it is running in a worker and takes care to cleanup after the
    job. You should not call `.enqueue() directly.

    Usage::

      >>> @async
      ... def afunc(arg):
      ...     return arg


    When you call the function you get back a :class:`rq.job.Job`
    proxy object (or a :class:`FakeJob` if no queue is available).

      >>> retval = afunc.enqueue('myarg')
      >>> isinstance(retval, Job)
    """
    def __init__(self, func):
        self.func = func

    def enqueue(self, *args, **kwargs):
        '''
        Call this to guarante the function is enqueued.
        Mostly useful in a worker process where the function
        would be executed synchronously.
        '''
        queue = rq_config.queue
        if queue is None:
            return self.fake_job(*args, **kwargs)
        return queue.enqueue(self.func, *args, **kwargs)

    def fake_job(self, *args, **kwargs):
        fake_job = FakeJob()
        fake_job._result = self.func(*args, **kwargs)
        return fake_job

    def __call__(self, *args, **kwargs):
        '''
        Call this with the args and kwargs of the function you want
        to enqueue. It will queue the function and return a Job if
        a queue is available, or call the function synchronously
        and return a FakeJob if not.

        Returns:

        :class:`FakeJob`
          where `.result` will be the return value if *_force_sync*
          is True or we have no configured redis connection.
        :class:`rq.Job`
          if we do asynchronous processing.
        '''

        if rq_config.in_worker:
            try:
                log.debug('exec job from worker: %s, args: %s, kwargs: %s' % (
                    self.func.__name__, str(args), str(kwargs)))
                return self.func(*args, **kwargs)
            except:
                log.exception('exception in async job execution: %s' % (
                    self.func.__name__))
                raise
            finally:
                # cleanup the sqlalchemy session after we run the job
                # from the queue.
                meta.Session.commit()
                meta.Session.remove()
        else:
            job = self.enqueue(*args, **kwargs)
            if isinstance(job, FakeJob):
                log.debug('fake job execution: %s, args: %s, kwargs: %s'
                          % (self.func.__name__, str(args), str(kwargs)))
            else:
                log.debug('enqueuing job: %s, args: %s, kwargs: %s' % (
                    self.func.__name__, str(args), str(kwargs)))
            return job


# --[ Redis configuration ]-------------------------------------------------

# config will be set from adhocracy.config.environment
# when the pylons application is initialized.

rq_config = None


class RQConfig(object):

    in_worker = False

    def __init__(self, async, host, port, queue_name):
        self._queue = None
        if host and port and queue_name:
            self.host = host
            self.port = int(port)
            self.queue_name = queue_name
            self.use_redis = True
        else:
            self.use_redis = False

            if async:
                log.warn(('You have not configured redis for adhocracy. '
                          'You should. Current configuration values:'
                          'host: %s, port: %s, name: %s') %
                         (host, port, queue_name))

        self.force_sync = not async
        self.connection = self.new_connection()

    def new_connection(self):
        if not self.use_redis:
            return None
        return Redis(host=self.host, port=self.port)

    @property
    def queue(self):
        if self._queue is not None:
            return self._queue
        if not self.use_redis or (not self.in_worker and self.force_sync):
            return None
        self._queue = Queue(self.queue_name, connection=self.connection)
        return self._queue

    @classmethod
    def setup_from_config(cls, config):
        global rq_config
        rq_config = cls.from_config(config)

    @classmethod
    def from_config(cls, config):
        async = asbool(config.get('adhocracy.background_processing', 'true'))
        host = config.get('adhocracy.redis.host')
        port = config.get('adhocracy.redis.port')
        name = config.get('adhocracy.redis.queue')
        return cls(async, host, port, name)


# --[ async methods ]-------------------------------------------------------

def update_entity(entity, operation):
    entity_ref = to_ref(entity)
    if entity_ref is None:
        return
    data = dict(operation=operation, entity=entity_ref)
    data_json = json.dumps(data)
    return handle_update(data_json)


@async
def handle_update(message):
    data = json.loads(message)
    delay = config.get_int('adhocracy.delay_update_queue_seconds')
    if delay > 0:
        import time
        time.sleep(delay)
    entity = to_entity(data.get('entity'))
    for (clazz, operation), listeners in LISTENERS.items():
        if operation != data.get('operation') \
           or not isinstance(entity, clazz):
            continue
        for listener in listeners:
            listener(entity)


@async
def minutely():
    from adhocracy.lib import democracy
    democracy.check_adoptions()


@async
def hourly():
    return
    # nothing here yet


@async
def daily():
    return
    from adhocracy.lib import watchlist
    watchlist.clean_stale_watches()


class FakeJob(Job):
    """
    FakeJob is meant to be used in settings where no redis queue is configured.
    It fakes the signature of a rq Job, but is executed synchronously.

    rq could also do synchronous processing by passing `async=False` to the
    `Queue` constructor, but this would still needs a running Redis process,
    thus we implemented our own way to do this.
    """

    _result = None

    def __init__(self):
        """Override constructor in order to not connect to redis"""
        pass

########NEW FILE########
__FILENAME__ = recommendations
import math
import logging

log = logging.getLogger(__name__)

from pylons import tmpl_context as c


def _popular_agents(delegations, count=10):
    """
    For a given set of delegations, find at most 'count' agents that
    occur most in the set. Returns a list of tuples, (agent, occurence_count)
    """
    agents = [d.agent for d in delegations if not d.revoke_time]
    freq = {}
    for agent in agents:
        freq[agent] = freq.get(agent, 0) + 1
    popular = sorted(freq.items(), cmp=lambda a, b: b[1] - a[1])
    popular = filter(lambda (u, v): u != c.user, popular)
    return popular[0:count]


def delegateable_popular_agents(delegateable, count=10):
    return _popular_agents(delegateable.delegations, count=count)


def user_popular_agents(user, count=10):
    return _popular_agents(user.delegated, count=count)


def log_with_null(n):
    return math.log(max(1, n))


def recommend(scope, user, count=5):
    dgb_pop_users = dict(delegateable_popular_agents(scope))
    usr_pop_users = dict(user_popular_agents(user))

    # log.debug("DGB POP DICT " + repr(dgb_pop_users))
    # log.debug("USR POP DICT " + repr(usr_pop_users))

    users = set(dgb_pop_users.keys() + usr_pop_users.keys())
    recs = dict()
    for u in users:
        if u == user or not u._has_permission('vote.cast'):
            continue
        recs[u] = (log_with_null(dgb_pop_users.get(u, 0)) * 2) + \
                  (usr_pop_users.get(u, 0) * 3)
    # log.debug("RECS DICT " + repr(recs))
    rs = sorted(recs.keys(), key=lambda u: recs[u], reverse=True)[0:count]
    # log.debug("RECS SORTING " + repr(rs))
    return rs

########NEW FILE########
__FILENAME__ = requestlog
import ipaddress
import logging

import adhocracy.lib.util
import adhocracy.model


def _anonymize(ipstr):
    ipa = ipaddress.ip_address(unicode(ipstr))
    if ipa.version == 4:
        keep_bits = 24
    elif ipa.version == 6:
        if ipa.ipv4_mapped:
            keep_bits = 120
        else:
            keep_bits = 48
    else:
        raise NotImplementedError()
    intf = ipaddress.ip_interface(u'%s/%s' % (ipa, keep_bits))
    return unicode(intf.network.network_address)

ANONYMIZATION_FUNCS = {
    'dontlog': lambda ipstr: None,
    'anonymize': _anonymize,
    'none': lambda ipstr: unicode(ipstr),
}

log = logging.getLogger(__name__)


class RequestLogger(object):
    def __init__(self, app, config):
        self.app = app
        self.config = config
        afname = self.config.get('adhocracy.requestlog_ipanonymization',
                                 'dontlog')
        self.anonymization_func = ANONYMIZATION_FUNCS[afname]

    def __call__(self, environ, start_response):
        try:
            self.log_request(environ)
        except BaseException as e:
            log.error('Error while trying to log request: %r' % e)
        return self.app(environ, start_response)

    def log_request(self, environ):
        def _get_field(name):
            res_bytes = environ.get(name)
            if res_bytes is None:
                return None
            return res_bytes.decode('utf-8', 'replace')

        full_ip = adhocracy.lib.util.get_client_ip(environ, config=self.config)
        ip = self.anonymization_func(full_ip)
        url = (environ['PATH_INFO'].decode('utf-8', 'replace')
               + '?' + environ['QUERY_STRING'].decode('utf-8', 'replace'))

        adhocracy.model.RequestLog.create(
            ip, url,
            cookies=_get_field('HTTP_COOKIE'),
            user_agent=_get_field('HTTP_USER_AGENT'),
            referer=_get_field('HTTP_REFERER'),
        )
        adhocracy.model.meta.Session.commit()

########NEW FILE########
__FILENAME__ = index
import hashlib
import logging

from httplib2 import Http
from pylons import tmpl_context as c
from sunburnt import SolrInterface

from adhocracy import config
from adhocracy import model
from adhocracy.model import refs

log = logging.getLogger(__name__)
SKIP = 'skip'
ADD = 'add'
DELETE = 'delete'
IGNORE = 'ignore'


def get_sunburnt_connection():
    try:
        connection = c.sunburnt_connection
    except TypeError:
        # no tmpl_context. probably running in tests
        return make_connection()
    if not connection:
        c.sunburnt_connection = make_connection()
    return c.sunburnt_connection


def make_connection():
    solr_url = config.get_string('adhocracy.solr.url',
                                 'http://localhost:8983/solr/')
    solr_url = solr_url.strip()
    if not solr_url.endswith('/'):
        solr_url = solr_url + '/'
    kwargs = {}
    if config.get_bool('adhocracy.force_no_http_proxy'):
        kwargs['proxy_info'] = None
    http_connection = Http(**kwargs)
    return SolrInterface(solr_url,
                         http_connection=http_connection)


def gen_id(entity):
    ref = refs.to_ref(entity)
    return hashlib.sha1(ref).hexdigest()


def update(entity):
    (action, data) = get_update_information(entity)
    if action == IGNORE:
        return

    connection = get_sunburnt_connection()
    try:
        if action == ADD:
            connection.add(data)
        elif action in (DELETE, SKIP):
            connection.delete(data)
        connection.commit()
    except Exception, e:
        log.exception(e)


def get_update_information(entity):
    if not isinstance(entity, model.meta.Indexable):
        return (IGNORE, None)
    if hasattr(entity, 'is_deleted') and entity.is_deleted():
        return (DELETE, gen_id(entity))
    data = entity.to_index()
    data['id'] = gen_id(entity)
    if data.pop('skip', False):
        return (SKIP, data['id'])
    return (ADD, data)


def delete(entity):
    connection = get_sunburnt_connection()
    try:
        index_id = gen_id(entity)
        connection.delete(index_id)
        connection.commit()
    except Exception, e:
        log.exception(e)

########NEW FILE########
__FILENAME__ = query
import logging

from adhocracy.lib.search.index import get_sunburnt_connection
from adhocracy.model import refs
from adhocracy.model import Page

from pylons import tmpl_context as c


log = logging.getLogger(__name__)


def sunburnt_query(entity_type=None, excluded_entity_types=set(),
                   instance=None, connection=None):
    '''
    return a pre configured sunburnt query object. If *entity_type*
    is given, return a query object preconfigured to only fetch
    documents from solr with a matching doc_type. if instance is
    given, only documents are returned that contain the index
    key.

    *entity_type*
        An indexed model class. Indexed classes are listed
        in :data:`adhocracy.lib.search.INDEXED_CLASSES`.
    *instance*
        A :class:`adhocracy.model.Instance` object
    *connection*
        An existing sunburnt connection. Mostly useful
        in tests.
    '''
    if connection is None:
        connection = get_sunburnt_connection()
    q = connection.query()
    if entity_type:
        q = q.filter(doc_type=refs.cls_type(entity_type))
    for t in excluded_entity_types:
        q = q.filter_exclude(doc_type=refs.cls_type(t))
    if instance and c.instance:
        q = q.filter(instance=instance.key)
    return q

query = sunburnt_query


def add_wildcard_query(query, field, string, lower=True):
    '''
    add a wildcard search for all words in *string* for the solr
    *field* to the existing sunburnt *query*.

    *query*
       :class:`sunburnt.search.SolrSearch` query object
    *field*
       `str`. The name of the solr field.
    *string*
       `str` or `unicode`. The search terms as a string
    *lower*
       `boolean`. If True (default) the search terms will be lowercased.
       This is required if the search index is lowercased, which it
       probably will be.

    Returns: A :class:`sunburnt.search.SolrSearch` object
    '''
    if string is None:
        return query

    if lower:
        string = string.lower()

    for term in string.split():
        term = term.strip('*')

        # We need to search for both the term or the term
        # with an wildcard.
        term_query = query.Q(**{field: term}) | query.Q(**{field: term + '*'})

        # chain this with the rest of the query as an AND query
        query = query.query(term_query)
    return query


def run(terms, instance=None, entity_type=None, excluded_entity_types=set(),
        **kwargs):
    if instance is not None and not instance.use_norms:
        excluded_entity_types.add(Page)
    q = sunburnt_query(entity_type=entity_type,
                       excluded_entity_types=excluded_entity_types,
                       instance=instance)

    for term in terms.split():
        done = False
        if ':' in term:
            field, value = term.split(':', 1)
            try:
                q = q.query(**{field.strip(): value.strip()})
                done = True
            except ValueError:
                pass
        if not done:
            q = add_wildcard_query(q, 'text', term.strip())

    response = q.execute()

    refs_ = [doc['ref'] for doc in response.result.docs]
    if refs_:
        return refs.to_entities(refs_)
    else:
        return []

########NEW FILE########
__FILENAME__ = converter
from adhocracy.lib.crypto import sign, verify

import base64
import json
import logging
import pylons.i18n.translation


__all__ = ["SignedValueConverter"]

log = logging.getLogger(name=__name__)
_SALT = b'cookie session'


def _encode_json(o):
    def default(o):
        if isinstance(o, pylons.i18n.translation.LazyString):
            return o.eval()
        return o
    return json.dumps(o, default=default)


class SignedValueConverter(object):
    def __init__(self, secret):
        self._secret = secret

    def encode(self, value):
        byte_val = base64.b64encode(_encode_json(value))
        encoded = sign(byte_val, self._secret, _SALT)
        return encoded.decode('ascii')

    def decode(self, s):
        try:
            byte_val = verify(s.encode('ascii'), self._secret, _SALT)
            return json.loads(base64.b64decode(byte_val))
        except ValueError as e:
            log.debug(str(e))
            return None

########NEW FILE########
__FILENAME__ = middleware
from pylons import session as pylons_session

from .session import Session


class CookieSessionMiddleware(object):
    def __init__(self, app, config):
        self._app = app
        self._config = config

    def __call__(self, environ, start_response):
        session = Session(environ, self._config)

        # Copy Beaker behavior to register the session in the Session
        # StackedObjectProxy
        if environ.get('paste.registry'):
            if environ['paste.registry'].reglist:
                environ['paste.registry'].register(pylons_session, session)

        environ['adhocracy_session'] = session

        def session_start_response(status, headers, exc_info=None):
            session.set_cookies_in(headers)
            return start_response(status, headers, exc_info)

        return self._app(environ, session_start_response)

########NEW FILE########
__FILENAME__ = session
try:
    from http.cookies import SimpleCookie
except ImportError:  # Python < 3
    from Cookie import SimpleCookie
import logging
import time

from adhocracy.lib.cookie import get_cookie
from adhocracy.lib.crypto import get_secret
from adhocracy.lib.session.converter import SignedValueConverter

log = logging.getLogger(name=__name__)
COOKIE_KEY = u'adhocracy_session'


class Session(dict):
    """ Stores session specific values on the client site.
        `converter_class` instances must respond to `encode` and `decode`
        messages.
    """

    def __init__(self, environ, config, converter_class=None):
        if converter_class is None:
            converter_class = SignedValueConverter

        self._max_age = int(config.get('adhocracy.session.lifetime',
                                       60 * 60 * 24 * 365))
        self._changed = False

        secret = get_secret(config, 'adhocracy.session.secret')
        self._converter = converter_class(secret)
        self._load_from_cookie(environ)

    def __setitem__(self, key, value):
        self._changed = True
        return super(Session, self).__setitem__(key, value)

    def __delitem__(self, key):
        self._changed = True
        super(Session, self).__delitem__(key)

    def setdefault(self, *args, **kwargs):
        self._changed = True
        return super(Session, self).setdefault(*args, **kwargs)

    def pop(self, *args, **kwargs):
        self._changed = True
        return super(Session, self).pop(*args, **kwargs)

    def _load_from_cookie(self, environ):
        cookie = SimpleCookie(environ.get("HTTP_COOKIE"))
        if not cookie:
            return
        morsel = cookie.get(COOKIE_KEY)
        if not morsel:
            return

        val = self._converter.decode(morsel.value)
        if not val:
            return
        assert isinstance(val, dict)

        if val['__creation'] + self._max_age < time.time():
            # Session has expired
            val = {}

        self.clear()
        self.update(val)
        self._changed = False

    def set_cookies_in(self, headers):
        if not self._changed:
            return
        self['__creation'] = int(time.time())
        val = self._converter.encode(self)
        c = get_cookie(COOKIE_KEY, val, max_age=self._max_age)
        headers.append(c)

    def delete(self):
        self._changed = True
        self.clear()

    def save(self):
        """ This session implementation does not need this function because the
            values are saved by the client.
        """
        pass

########NEW FILE########
__FILENAME__ = settings
from collections import OrderedDict

from pylons.i18n import lazy_ugettext as L_

from pylons import tmpl_context as c
from adhocracy.lib import helpers as h
from adhocracy import model


INSTANCE_UPDATED_MSG = L_('The changes were saved.')
NO_UPDATE_REQUIRED = L_('No update required.')


def error_formatter(error):
    return '<p class="help-block">%s</p>' % error


def update_attributes(entity, form_result, attributes):
    '''
    Update the given *attributes* on the *entity* object
    with the values in *form_result* and returns if an attribute
    was updated.

    *entity* (:class:`adhocracy.model.Instance`)
       The Instance to update.
    *form_result* (dict)
       A dict, usually the result of a formencode
       validation.
    *attributes* (`list` of `str`)
       The attributes to update.

    Returns: `True` if one of the *attributes* was updated, `False`
    no attribute needed to be updated.

    Raises:

    *AttributeError*
       If the attribute does not exist on the *entity* object.
    *KeyError*
       If the *form_result* dict has no key with the name of the
       attribute.
    '''
    updated = False
    for attribute in attributes:
        new_value = form_result[attribute]
        current_value = getattr(entity, attribute)
        if new_value != current_value:
            setattr(entity, attribute, new_value)
            updated = True
    return updated


def settings_url(entity, name, force_url=None):
    full_path = 'settings/%s' % name if force_url is None else force_url
    if isinstance(entity, model.Instance):
        return h.entity_url(entity, member=full_path)
    else:
        return h.entity_url(entity, instance=c.instance, member=full_path)


class Menu(OrderedDict):
    '''Subclass so we can attach attributes'''

    @classmethod
    def create(cls, entity, current, items):
        menu = cls()
        menu.__setattr__('current', None)

        for k, v in items.iteritems():
            setting = cls._setting(entity, k, *v)
            if setting['allowed']:
                menu[k] = setting
                if k == current:
                    menu.current = setting
                    setting['active'] = True
                    setting['class'] = 'active'
                else:
                    setting['class'] = ''

        if menu.current is None:
            raise ValueError('current ("%s") is no menu item' % current)

        return menu

    @classmethod
    def _setting(cls, entity, name, label, allowed=True, force_url=None):
        return {'name': name,
                'url': settings_url(entity, name, force_url),
                'label': label,
                'allowed': allowed}

    def url_for(self, value):
        current = self.get(value)
        if current is None:
            return ValueError('No Menu item named "%s"' % value)
        else:
            return current['url']

########NEW FILE########
__FILENAME__ = sorting
# -*- coding: utf-8 -*-

from datetime import datetime
import math
import re
import unicodedata

from adhocracy.lib.util import timedelta2seconds, datetime2seconds


PREFIXES = ['die', 'der', 'das', 'the', 'a', 'le', 'la']


def _not_combining(char):
        return unicodedata.category(char) != 'Mn'


def _strip_accents(text):
    unicode_text = unicodedata.normalize('NFD', text)
    return filter(_not_combining, unicode_text)


def _human_key(key):
    keys = re.split('(\d+)', key)
    keys = map(lambda s: int(s) if s.isdigit() else s.lower(), keys)
    keys = filter(lambda s: s not in PREFIXES, keys)
    keys = map(lambda s: isinstance(s, unicode) and
               _strip_accents(s) or s, keys)
    return keys


def sortable_text(value_list, key=None):
    """ String sorting by more human rules. """
    results = list(value_list)
    results.sort(key=lambda i: _human_key(key(i)))

    return results


def delegateable_label(entities):
    return sortable_text(entities, key=lambda e: e.label)


def instance_label(entities):
    return sortable_text(entities, key=lambda e: e.label)


def delegateable_title(entities):
    return sortable_text(entities, key=lambda e: e.title)


def hierarchical_title(entities):
        return delegateable_title(entities)


def delegateable_full_title(entities):
    return sortable_text(entities, key=lambda e: e.full_title)


def delegateable_latest_comment(entities):
    return sorted(entities, key=lambda e: e.find_latest_comment_time(),
                  reverse=True)


def score_and_freshness_sorter(max_age=0):
    '''
    Factory. Returns a function that calculates a sortable 60 character
    string from a combination of *max_age* and the parameters of the
    returned function, *score* and *time*.

    Factory:

    *max_age*
       Maximal age in seconds (*int*). This configures the returned
       function to increase the returned value if the passed *time*
       is less than *max_age* seconds in the past (compared to now).

       If max_age is 0 (default) the freshness isn't taken into account.

    Returns: A function

    Returned function:

    *score*
       *int* or *float*. An int or float used to increase the value of the
       returned string.
    *time*
       A :class:`datetime.datetime` object. Usually the creation date
       of the object we calculate the string for
    *impact*
       An *int* between -10 and +10, which is used as primary sort key.

    Returns: A 60 character string.
    '''
    def _with_age(score, time, impact=0):

        if score > -1:
            age = timedelta2seconds(datetime.utcnow() - time)
            # freshness = 1 .. 5.2 if max_age == 2 days
            freshness = math.log10(max(10, max_age - age))
        else:
            freshness = 1

        # atan normalizes to -pi/2 .. +pi/2
        base = math.atan(freshness * score)

        # add impact
        assert -10 <= impact <= 10
        result = base + impact * math.pi

        str_time = "%020d" % datetime2seconds(time)
        str_score_freshness = "%029.10f" % (result)

        return str_score_freshness + str_time
    return _with_age


def proposal_mixed_key(proposal):
    max_age = 172800  # 2 days
    scorer = score_and_freshness_sorter(max_age)
    tally = proposal.rate_poll.tally

    # the badge with the highest absolute impact value wins
    impact = reduce(lambda a, b: b if abs(b) > abs(a) else a,
                    map(lambda d: d.badge.impact, proposal.delegateablebadges),
                    0)

    return scorer(tally.num_for - tally.num_against, proposal.create_time,
                  impact)


def proposal_mixed(entities):
    return sorted(entities,
                  key=lambda x: float(proposal_mixed_key(x)),
                  reverse=True)


def proposal_support_impact_key(proposal):
    scorer = score_and_freshness_sorter()
    score = proposal.rate_poll.tally.score

    # the badge with the highest absolute impact value wins
    impact = reduce(lambda a, b: b if abs(b) > abs(a) else a,
                    map(lambda d: d.badge.impact, proposal.delegateablebadges),
                    0)

    return scorer(score, proposal.create_time, impact)


def proposal_support_impact(entities):
    return sorted(entities,
                  key=lambda x: float(proposal_support_impact_key(x)),
                  reverse=True)


def proposal_controversy_calculate(num_for, num_against):
    '''
    Measure how disputed an issue is - 50 pro 50 contra should be way more
    important than an issue that ranks 99 pro 1 contra.

    Intuitively, min(pro, contra) / (pro + contra) should give the percentage
    of voters that disagree with the majority, and therefore be a good
    measurement.

    At the same time, we want issues with more absolute votes to rank slightly
    higher; 40 - 60 is way more important than 10 - 10. Therefore, we scale
    the whole sorting key by the logarithm of the total number of votes.

    See http://goo.gl/yZj2H for a plot of the function.
    '''

    if num_for + num_against == 0:
        return -1

    return (float(min(num_for, num_against))
            / (num_for + num_against)
            * math.log(num_for + num_against))


def proposal_controversy_key(proposal):
    tally = proposal.rate_poll.tally
    return proposal_controversy_calculate(tally.num_for, tally.num_against)


def proposal_controversy(entities):
    return sorted(entities, key=proposal_controversy_key, reverse=True)


def proposal_support(entities):
    return sorted(entities,
                  key=lambda p: p.rate_poll.tally.num_for, reverse=True)


def norm_selections(entities):
    return sorted(entities, key=lambda n: len(n.selections), reverse=True)


def norm_variants(entities):
    return sorted(entities, key=lambda n: len(n.variants), reverse=True)


def comment_order_key(comment):
    max_age = 43200  # 0.5 days
    scorer = score_and_freshness_sorter(max_age)
    return scorer(comment.poll.tally.score, comment.create_time)


def comment_order(comments):
    return sorted(comments, key=comment_order_key, reverse=True)


def user_name(entities):
    return sorted(entities, key=lambda e: e.name.lower())


def milestone_time(entities):
    return sorted(entities, key=lambda e: e.time)


def polls_time(entities):
    return sorted(entities, key=lambda e: e.end_time)


def entity_newest(entities):
    return sorted(entities, key=lambda e: e.create_time, reverse=True)


def entity_oldest(entities):
    return sorted(entities, key=lambda e: e.create_time, reverse=False)


def entity_stable(entities):
    return entities


def instance_activity(instances):
    from adhocracy.lib.event import stats as estats
    return sorted(instances, key=lambda i: estats.instance_activity(i),
                  reverse=True)


def user_activity(instance, users):
    from adhocracy.lib.event import stats as estats
    return sorted(users, key=lambda u: estats.user_activity(instance, u),
                  reverse=True)


def user_activity_factory(instance):
    '''
    Create an user activity sorting function that uses
    the given *instance*. If *instance* is `None`, the returned
    function will sort users by the activity across all instances.
    If instance is an :class:`adhocracy.model.Instance` object,
    it will sort the users by their activity in the given instance.

    Returns: A function that accepts a list of users and returns
    them sorted.
    '''
    def func(users):
        return user_activity(instance, users)
    return func


def comment_score(comments):
    return sorted(comments, key=lambda c: c.poll.tally.score,
                  reverse=True)


def dict_value_sorter(dict):
    def _sort(items):
        return sorted(items, key=lambda i: dict.get(i))
    return _sort


def comment_id(comments):
    return sorted(comments, key=lambda c: c.id)

########NEW FILE########
__FILENAME__ = staticpage
import logging
import re
from simplejson.scanner import JSONDecodeError

from adhocracy import config
from adhocracy import i18n
from adhocracy.lib.helpers.adhocracy_service import RESTAPI
from adhocracy.lib import util
from adhocracy.lib.auth.authorization import has
from adhocracy.lib.outgoing_link import rewrite_urls
from adhocracy.model import StaticPage
from adhocracy.model import StaticPageBase


from lxml.html import parse, tostring

log = logging.getLogger(__name__)


class FileStaticPage(StaticPageBase):

    @staticmethod
    def get(key, languages):

        for lang in languages:
            fn = key + '.' + lang + '.html'
            filename = util.get_path('page', fn)
            if filename is not None:
                try:
                    root = parse(filename)
                except IOError:
                    return None
                try:
                    body = root.find('.//body')
                    title = root.find('.//title').text
                except AttributeError:
                    log.debug(
                        u'Failed to parse static document ' + filename)
                    return None
                body.tag = 'span'
                return FileStaticPage(key, lang, tostring(body), title)
        return None


class ExternalStaticPage(StaticPageBase):

    @staticmethod
    def get(key, languages):
        api = RESTAPI()
        result = api.staticpage_get(key)
        if not result.ok:
            log.warn('Error while fetching static page "%s": %s %s'
                     % (key, result.status_code, result.reason))
            return None
        try:
            page = result.json()
        except JSONDecodeError as e:
            log.warn('Error while decoding static page "%s": %s' % (key, e))
            return None
        if page is None or 'errors' in page:
            return None
        data = {'lang': u'',
                'title': u'',
                'description': u'',
                'body': u'',
                'column_right': u'',
                'nav': u'',
                'css_classes': [],
                'private': False,
                'redirect_url': u'',
                }
        data.update(page)
        return ExternalStaticPage(key, **data)

_BACKENDS = {
    'filesystem': FileStaticPage,
    'database': StaticPage,
    'external': ExternalStaticPage,
}

STATICPAGE_KEY = re.compile(r'^[a-z0-9_\-/]+$')


def get_backend():
    backend_id = config.get('adhocracy.staticpage_backend')
    return _BACKENDS[backend_id]


def can_edit():
    if not get_backend().is_editable():
        return False
    return has('global.staticpage')


def render_body(body):
    return rewrite_urls(body)


def get_static_page(key, language=None):
    backend = get_backend()
    if language is None:
        page = backend.get(key, i18n.all_languages(include_preferences=True))
    else:
        page = backend.get(key, [language])
    if page is not None:
        page.require_permission()
    return page


def add_static_content(data, config_key, title_key=u'title',
                       body_key=u'body', css_classes_key=u'css_classes'):

    static_path = config.get(config_key)
    if static_path is not None:
        page = get_static_page(static_path)
        if page is None:
            data[title_key] = data[body_key] = None
        else:
            data[title_key] = page.title
            data[body_key] = render_body(page.body)
            data[css_classes_key] = page.css_classes
    else:
        data[title_key] = data[body_key] = None

########NEW FILE########
__FILENAME__ = templating
import rfc822
import hashlib
import logging

from pylons import request, response
import pylons.templating
from pylons.controllers.util import etag_cache
from pylons.controllers.util import abort, redirect
from pylons.i18n import _

from adhocracy import model
from adhocracy.lib.helpers import json_dumps, logo_url

import tiles
import text
import auth
import sorting
import logo

log = logging.getLogger(__name__)


OVERLAY_BIG = u'big'
OVERLAY_SMALL = u'small'


def tpl_vars():
    vars = dict()
    import adhocracy.lib
    vars['tiles'] = tiles
    vars['lib'] = adhocracy.lib
    vars['can'] = auth.can
    vars['check'] = auth.check
    vars['diff'] = text.diff
    vars['sorting'] = sorting
    vars['model'] = model
    return vars


_legacy = object()


def render(template_name, data=_legacy, overlay=False,
           overlay_size=OVERLAY_BIG):
    """ If overlay is True, the template will be rendered in a minimal template
        containing only the main content markup of the site.
        overlay_size will be included as a class on the html element."""

    if data is _legacy:
        # log.debug(u'Legacy call to render() - missing data')
        data = {}

    if overlay:
        data['overlay_size'] = overlay_size

    return render_mako(template_name, data, overlay=overlay)


def set_template_context(data):
    for k, v in data.items():
        setattr(pylons.tmpl_context, k, v)


def render_mako(template_name, data, extra_vars=None, cache_key=None,
                cache_type=None, cache_expire=None, overlay=False):
    """
    Signature matches that of pylons actual render_mako. Except
    for the *overlay* parameter. If it is *True*, the template will
    be rendered in a minimal template containing only the main content
    markup of the site.
    """
    if not extra_vars:
        extra_vars = {}

    extra_vars.update(tpl_vars())

    if overlay:
        extra_vars['root_template'] = '/overlay.html'

    set_template_context(data)

    page = pylons.templating.render_mako(template_name, extra_vars=extra_vars,
                                         cache_key=cache_key,
                                         cache_type=cache_type,
                                         cache_expire=cache_expire)
    return page


def render_def(template_name, def_name, data=_legacy, extra_vars=None,
               cache_key=None, cache_type=None, cache_expire=None, **kwargs):
    """
    Signature matches that of pylons actual render_mako_def.
    """
    # log.debug(u'Call to deprecated (Mako-specific) method render_def - call '
    #           u'render(template_name, data, only_fragment=True) instead')

    if data is _legacy:
        # log.debug(u'Legacy call to render_def() - missing data')
        data = {}

    set_template_context(data)

    if not extra_vars:
        extra_vars = {}

    extra_vars.update(tpl_vars())
    extra_vars.update(kwargs)

    return pylons.templating.render_mako_def(template_name, def_name,
                                             cache_key=cache_key,
                                             cache_type=cache_type,
                                             cache_expire=cache_expire,
                                             **extra_vars)


def ret_success(message=None, category=None, entity=None, member=None,
                code=200, format='html', force_path=None):
    return ret_status('OK', message=message, category=category, entity=entity,
                      code=code, format=format, member=member,
                      force_path=force_path)


def ret_abort(message, category=None, entity=None, member=None, code=500,
              format='html', force_path=None):
    return ret_status('ABORT', message=message, category=category,
                      entity=entity, code=code, format=format,
                      force_path=force_path)


def ret_status(type_, message, category=None, entity=None, member=None,
               code=200, format='html', force_path=None):
    import adhocracy.lib.helpers as h
    response.status_int = code
    if code != 200:
        if format == 'json':
            return ret_json_status(type_, message, code)
        request.environ['adhocracy.error_message'] = message
        abort(code, message)
    if message:
        if format == 'json':
            return ret_json_status(type_, message, code)
        h.flash(message, category)
    if force_path:  # neither None nor ''
        redirect(force_path)
    if entity is not None:
        redirect(h.entity_url(entity, format=format, member=member))
    redirect(h.base_url())


def ret_json_status(type_, message, code=200):
    data = {'type': type_,
            'message': message,
            'code': code}
    return render_json(data)


def render_json(data, filename=None, response=response):
    encoding = 'utf-8'  # RFC 4627.3
    response.content_type = 'application/json'
    response.content_encoding = encoding
    if filename is not None:
        response.content_disposition = 'attachment; filename="'\
            + filename.replace('"', '_') + '"'
    return json_dumps(data, encoding=encoding)


def render_png(io, mtime, content_type="image/png", cache_forever=False):
    response.content_type = content_type
    if not cache_forever:
        etag_cache(key=hashlib.sha1(io).hexdigest())
        del response.headers['Cache-Control']
    else:
        response.headers['Cache-Control'] = 'max-age=31556926'
    response.charset = None
    response.last_modified = rfc822.formatdate(timeval=mtime)
    response.content_length = len(io)
    response.pragma = None
    return io


def render_logo(entity, y, x=None, fallback=None):
    (x, y) = logo.validate_xy(x, y)
    try:
        (path, mtime, io) = logo.load(entity, size=(x, y),
                                      fallback=fallback)
    except logo.NoSuchSizeError:
        abort(404, _(u"The image is not avaliable in that size"))

    # always add ?t=... to URI for browser cache
    request_mtime = int(request.params.get('t', 0))
    if request_mtime != mtime:
        redirect(logo_url(entity, y, x=x))
    return render_png(io, mtime, cache_forever=True)

########NEW FILE########
__FILENAME__ = diff
import cgi
from itertools import izip_longest
from string import count

from lxml.html.diff import htmldiff

from adhocracy import model
from adhocracy.lib.cache import memoize
from adhocracy.lib.text.normalize import simple_form
from adhocracy.lib.text.render import (render, render_line_based, _line_table,
                                       linify)

LINEBREAK_TOKEN = 23
SPACE_TOKEN = 42


def _diff_html(left, right):
    return htmldiff(left, right)


def _decompose(text):
    if text is None:
        return []
    _tokens = []
    for line in text.split('\n'):
        line = line.replace('\r', '')
        for token in line.split(' '):
            if len(token):
                _tokens.append(simple_form(token))
            _tokens.append(SPACE_TOKEN)
        _tokens.pop()
        _tokens.append(LINEBREAK_TOKEN)
    return _tokens


def _compose(elems):
    lines = []
    line = ''
    for elem in elems:
        if elem == LINEBREAK_TOKEN:
            lines.append(line)
            line = ''
        elif elem == SPACE_TOKEN:
            line += ' '
        else:
            line += elem
    lines.append(line)
    return '\n'.join([cgi.escape(l) for l in lines])


def _diff_line_based(left_text, right_text, include_deletions=True,
                     include_insertions=True, replace_as_insert=False,
                     replace_as_delete=False, ratio_skip=0.7,
                     line_length=model.Text.LINE_LENGTH):
    from difflib import SequenceMatcher
    left = _decompose(left_text)
    right = _decompose(right_text)
    s = SequenceMatcher(None, left, right)

    html_match = ''
    for op, i1, i2, j1, j2 in s.get_opcodes():
        if op == 'equal':
            html_match += _compose(left[i1:i2])
        elif op == 'delete' and include_deletions:
            html_match += '<del>' + _compose(left[i1:i2]) + '</del>'
        elif op == 'insert' and include_insertions:
            html_match += '<ins>' + _compose(right[j1:j2]) + '</ins>'
        elif op == 'replace':
            if replace_as_delete:
                html_match += '<del>' + _compose(left[i1:i2]) + '</del>'
            if replace_as_insert:
                html_match += '<ins>' + _compose(right[j1:j2]) + '</ins>'
            if not (replace_as_delete or replace_as_insert):
                html_match += '<span>' + _compose(right[j1:j2]) + '</span>'

    carry = []
    lines = []
    for line in linify(html_match, line_length):
        for val in reversed(carry):
            line = val + line
        carry = []
        for tag_begin, tag_end in (('<span>', '</span>'),
                                   ('<ins>', '</ins>'),
                                   ('<del>', '</del>')):
            begin_count = count(line, tag_begin)
            end_count = count(line, tag_end)
            if begin_count > end_count:
                line = line + tag_end
                carry.append(tag_begin)
            elif begin_count < end_count:
                line = tag_begin + line
        lines.append(line)

    return lines


@memoize('rev_diff')
def comment_revisions_compare(rev_from, rev_to):
    if rev_to is None:
        return render(rev_from.text)
    return _diff_html(render(rev_to.text),
                      render(rev_from.text))


@memoize('titles_diff')
def page_titles_compare(text_from, text_to):
    if text_to is None or text_from.id == text_to.id:
        return text_from.title
    return _diff_html(text_to.title,
                      text_from.title)


def page_texts_history_compare(text_from, text_to):
    if text_from.page.function == model.Page.NORM:
        return norm_texts_history_compare(text_from, text_to)
    if text_to is None or text_from.id == text_to.id:
        return render(text_from.text)
    return _diff_html(render(text_to.text),
                      render(text_from.text))


@memoize('norms_diff')
def norm_texts_history_compare(text_from, text_to):
    '''
    Note: Inverts from and to inside. Be prepared;)
    '''
    if text_to is None or text_from.id == text_to.id:
        return render_line_based(text_from)
    lines = _diff_line_based(text_to.text,
                             text_from.text,
                             replace_as_insert=True)
    return _line_table(lines)


@memoize('norms_diff_inline')
def norm_texts_inline_compare(text_from, text_to):
    if text_to is None or text_from.id == text_to.id:
        return render_line_based(text_from)
    lines = _diff_line_based(text_from.text,
                             text_to.text,
                             replace_as_insert=True,
                             replace_as_delete=True)
    return _line_table(lines)


@memoize('normtab_diff')
def norm_texts_table_compare(text_from, text_to):
    insertions = _diff_line_based(text_from.text,
                                  text_to.text,
                                  include_insertions=True,
                                  include_deletions=False,
                                  replace_as_insert=True,
                                  ratio_skip=0.8)

    deletions = _diff_line_based(text_from.text,
                                 text_to.text,
                                 include_insertions=False,
                                 include_deletions=True,
                                 replace_as_delete=True,
                                 ratio_skip=0.8)

    llines = []
    rlines = []
    for left, right in izip_longest(deletions, insertions, fillvalue=''):
        llines.append(left)
        rlines.append(right)
    return _line_table(llines), _line_table(rlines)

########NEW FILE########
__FILENAME__ = mdx_showmore
"""Showmore extension for Markdown.

To hide something with [more...], surround the corresponding text with triple
parentheses, e.g. (((text_to_be_hidden))).

In order to show the text, you have to include the following Javascript in your
code, which depends on the availability of jquery.

    $('.showmore').each(function () {
        var self = $(this);
        self.find('.showmore_morelink').bind('click', function (event) {
            event.preventDefault();
            self.find('.showmore_morelink').css('display', 'none');
            self.find('.showmore_uncollapsed').css('display', 'inline');
        });
        self.find('.showmore_lesslink').bind('click', function (event) {
            event.preventDefault();
            self.find('.showmore_morelink').css('display', 'inline');
            self.find('.showmore_uncollapsed').css('display', 'none');
        });
    });

Additionally, you have to add the following to your css code:
    .showmore {
        display: inline;
    }
    .showmore_uncollapsed {
        /* initial state */
        display: none;
    }
    .showmore_morelink, .showmore_lesslink {
        text-transform: lowercase;
        font-variant: small-caps;
        white-space: nowrap;
    }
"""

import re
import markdown
from pylons.i18n import _


SHOWMORE_RE = re.compile(r'\({3,}(?P<text>.*?)\){3,}',
                         re.MULTILINE | re.DOTALL)

PRE_HTML = u'''
<div class="showmore">
    <a class="showmore_morelink" href="#">[%s]</a>
    <div class="showmore_uncollapsed">
'''

POST_HTML = u'''
        <a class="showmore_lesslink" href="#">[%s]</a>
    </div>
</div>
'''


class ShowmoreExtension(markdown.Extension):
    """ Showmore Extension for Python-Markdown. """

    def extendMarkdown(self, md, md_globals):
        md.registerExtension(self)
        md.preprocessors.add('showmore', ShowmorePreprocessor(md),
                             '>normalize_whitespace')


class ShowmorePreprocessor(markdown.preprocessors.Preprocessor):

    def run(self, lines):
        text = "\n".join(lines)
        while 1:
            m = SHOWMORE_RE.search(text)
            if m:

                text = '%s%s%s%s%s' % (
                    text[:m.start()],
                    self.markdown.htmlStash.store(PRE_HTML % _(u'show more'),
                                                  safe=True),
                    m.group('text'),
                    self.markdown.htmlStash.store(POST_HTML % _(u'show less'),
                                                  safe=True),
                    text[m.end():])
            else:
                break
        return text.split("\n")


def makeExtension(configs=None):
    return ShowmoreExtension(configs=configs)

########NEW FILE########
__FILENAME__ = normalize
from unicodedata import normalize, category
from adhocracy.forms import FORBIDDEN_NAMES


def chr_filter(ch, remove_space):
    """ Filter by unicode character category. """
    if ch == u'_':
        return ch
    cat = category(ch)[0].upper()
    if cat in ['Z'] and remove_space:
        return u'_'  # replace spaces
    if cat in ['P']:
        return u''  # remove punctuation
    return ch


def variant_normalize(variant, remove_space=False):
    var = escape(variant, remove_space=remove_space)
    return var


def title2alias(title, pseudo=u'page_'):
    # title = urllib.unquote(title)
    title = escape(title)
    # title = INVALID_CHARS.sub(u"", title)
    if (not len(title)) or (title.lower() in FORBIDDEN_NAMES):
        return pseudo
    try:
        tint = int(title)
        return pseudo + tint
    except:
        return title


def label2url(label):
    title = escape(label)
    return title[:40].encode('utf-8')


def simple_form(text):
    text = normalize('NFKC', text)
    return text


def escape(title, remove_space=True):
    if title is None:
        return None
    title = unicode(title).strip()
    title = normalize('NFKD', title)
    title = u''.join([chr_filter(c, remove_space) for c in title])
    title = normalize('NFKC', title)
    return title

########NEW FILE########
__FILENAME__ = render
import cgi
import re

import markdown

from adhocracy import model
from adhocracy.lib.cache.util import memoize
from adhocracy.lib.outgoing_link import rewrite_urls

SUB_USER = re.compile("@([a-zA-Z0-9_\-]{3,255})")


def user_sub(match):
    from adhocracy.lib import helpers as h
    user = model.User.find(match.group(1))
    if user is not None:
        return h.user.link(user)
    return match.group(0)


SUB_PAGE = re.compile("\[\[([^(\]\])]{3,255})\]\]", re.M)


def page_sub(match):
    from adhocracy.lib import helpers as h
    page_name = match.group(1)
    variant = model.Text.HEAD
    if '/' in page_name:
        page_name, variant = page_name.split('/', 1)
    page = model.Page.find_fuzzy(page_name, include_deleted=True)
    if page is not None:
        if page.is_deleted():
            return page_name
        return h.page.link(page, variant=variant)
    else:
        return page_name


@memoize('render')
def render(text, substitutions=True, safe_mode='escape',
           _testing_allow_user_html=None):
    '''
    Render markdown as html.

    *substitutions*
        If `True`, substitude text reference, e.g. member refs like
        @(pudo), to html.
    *safe_mode*
        This is passed directly to the markdown renderer. Possible options are
        `'escape'` (escape html tags), `'remove'` (remove html tags),
        `'adhocracy_config'` (HTML if allowed, escape otherwise).
    '''
    if text is None:
        return ""

    from adhocracy.lib.helpers.text_helper import getconf_allow_user_html
    allow_user_html = getconf_allow_user_html(_testing_allow_user_html)
    assert safe_mode in ('escape', 'remove', 'adhocracy_config')
    if safe_mode == 'adhocracy_config':
        safe_mode = False if allow_user_html else 'escape'

    text = markdown.markdown(
        text,
        extensions=[
            'adhocracy.lib.text.mdx_showmore',
        ],
        output_format='xhtml5',
        safe_mode=safe_mode,
        enable_attributes=False
    )
    if substitutions:
        text = SUB_USER.sub(user_sub, text)
        text = SUB_PAGE.sub(page_sub, text)

    if allow_user_html and not safe_mode:
        from lxml.html.clean import Cleaner
        text = Cleaner(embedded=False,
                       kill_tags=['embed', 'object']).clean_html(text)

    text = rewrite_urls(text)

    return text


def _line_table(lines):
    _out = "<table class='line_based'>"
    for num, line in enumerate(lines):
        _out += """\t<tr>
                        <td class='line_number'>%s</td>
                        <td class='line_text'>%s</td>
                     </tr>\n""" % (num + 1, line)
    _out += "</table>\n"
    return _out


@memoize('text_render')
def render_line_based(text_obj):
    if not text_obj.text:
        return ""
    return _line_table([cgi.escape(l) for l in text_obj.lines])


def truncate(text, length):
    if len(text) <= length:
        return text

    break_point = None
    in_tag = False
    count = 0
    for i, c in enumerate(text):
        if count == length:
            if break_point:
                return text[:break_point + 1]
            return text[:i]

        if c.isspace():
            break_point = i

        if c == '<':
            in_tag = True
            continue
        if c == '>':
            in_tag = False
            continue

        if not in_tag:
            count += 1

    return text


def linify(text, length):
    for in_line in text.strip().split("\n"):
        while True:
            line = truncate(in_line, length)
            yield line
            in_line = in_line[len(line):]
            if not len(in_line):
                break

########NEW FILE########
__FILENAME__ = tag
import unicodedata
import re
import math

SPLIT_CHARS = " ,;\""
SPLITTER = re.compile(r'[,;\s]*', re.U)


def tag_normalize(text):
    from adhocracy.lib import helpers as h
    text = h.url.unquote(text)
    text = unicodedata.normalize('NFKC', text)
    return text.strip(SPLIT_CHARS).lower()


def tag_split(text):
    tags = []
    for tag in SPLITTER.split(text):
        if (tag in tags) or (not len(tag)):
            continue
        try:
            int(tag)
        except ValueError:
            tags.append(tag)
    return tags


def tag_split_last(text):
    tags = tag_split(text)
    if not len(tags):
        return (text, '')
    last = tags[-1]
    if not len(last):
        return (text, '')
    return (text[:len(text) - len(last)], last)

########NEW FILE########
__FILENAME__ = truncate
"""
Truncate given HTML to a certain number of target characters while preserving
the HTML structure and whole words.

Code is taken from https://raw.github.com/enkore/typeflow/ revision d4b2f35c14,

Original: https://raw.github.com/eentzel/htmltruncate.py/master/htmltruncate.py
"""


__all__ = ["truncate"]

END = -1


class OpenTag:
    def __init__(self, tag, rest=''):
        self.tag = tag
        self.rest = rest

    def as_string(self):
        return '<' + self.tag + self.rest + '>'


class CloseTag(OpenTag):
    def as_string(self):
        return '</' + self.tag + '>'


class SelfClosingTag(OpenTag):
    pass


class Tokenizer:
    def __init__(self, input):
        self.input = input
        # points at the next unconsumed character of the input
        self.counter = 0

    def __next_char(self):
        self.counter += 1
        return self.input[self.counter]

    def next_token(self):
        try:
            char = self.input[self.counter]
            self.counter += 1
            if char == '&':
                return self.__entity()
            elif char != '<':
                return self.__word(char)
            elif self.input[self.counter] == '/':
                self.counter += 1
                return self.__close_tag()
            else:
                return self.__open_tag()
        except IndexError:
            return END

    def __word(self, char):
        word = char

        char = self.input[self.counter]
        while char not in ["<", " "]:
            word += char
            char = self.__next_char()

        return word

    def __entity(self):
        """Return a token representing an HTML character entity.
        Precondition: self.counter points at the charcter after the &
        Postcondition: self.counter points at the character after the ;
        """
        char = self.input[self.counter]
        entity = ['&']
        while char != ';':
            entity.append(char)
            char = self.__next_char()
        entity.append(';')
        self.counter += 1
        return ''.join(entity)

    def __open_tag(self):
        """Return an open/close tag token.
        Precondition: self.counter points at the first character of the tag
        name
        Postcondition: self.counter points at the character after the <tag>
        """
        char = self.input[self.counter]
        tag = []
        rest = []
        while char != '>' and char != ' ':
            tag.append(char)
            char = self.__next_char()
        while char != '>':
            rest.append(char)
            char = self.__next_char()
        if self.input[self.counter - 1] == '/':
            self.counter += 1
            return SelfClosingTag(''.join(tag), ''.join(rest))
        else:
            self.counter += 1
            return OpenTag(''.join(tag), ''.join(rest))

    def __close_tag(self):
        """Return an open/close tag token.
        Precondition: self.counter points at the first character of the tag
        name
        Postcondition: self.counter points at the character after the <tag>
        """
        char = self.input[self.counter]
        tag = []
        while char != '>':
            tag.append(char)
            char = self.__next_char()
        self.counter += 1
        return CloseTag(''.join(tag))


def truncate(str, target_len, ellipsis=''):
    """Returns a copy of str truncated to target_len words,
    preserving HTML markup (which does not count towards the length).
    Any tags that would be left open by truncation will be closed at
    the end of the returned string.  Optionally append ellipsis if
    the string was truncated."""
    # open tags are pushed on here, then popped when the matching close tag is
    # found
    stack = []
    # string to be returned
    retval = []
    # number of words (not counting markup) placed in retval so far
    length = 0
    tokens = Tokenizer(str)
    tok = tokens.next_token()

    while tok != END:
        if not length < target_len:
            retval.append(ellipsis)
            break
        if tok.__class__.__name__ == 'OpenTag':
            stack.append(tok)
            retval.append(tok.as_string())
        elif tok.__class__.__name__ == 'CloseTag':
            if len(stack) and stack[-1].tag == tok.tag:
                stack.pop()
                retval.append(tok.as_string())
        elif tok.__class__.__name__ == 'SelfClosingTag':
            retval.append(tok.as_string())
        else:
            retval.append(tok)
            if tok != " ":
                length += 1

        tok = tokens.next_token()

    while len(stack) > 0:
        tok = CloseTag(stack.pop().tag)
        retval.append(tok.as_string())

    return ''.join(retval)

########NEW FILE########
__FILENAME__ = badge_tiles
def badge(badge, force_visible=False):
    from adhocracy.lib.templating import render_def
    return render_def('/badge/tiles.html', 'badge', badge=badge,
                      force_visible=force_visible, cached=True)


def badges(badges):
    from adhocracy.lib.templating import render_def
    return render_def('/badge/tiles.html', 'badges', badges=badges,
                      cached=True)


def badge_selector(badges, field_name):
    from adhocracy.lib.templating import render_def
    return render_def('/badge/tiles.html', 'badge_selector',
                      badges=badges, field_name=field_name)


def badge_styles(instance):
    '''
    Render a <style>-block with dyamic badge styles
    '''
    from adhocracy.lib.templating import render_def
    from adhocracy.model import Badge
    badges = Badge.all(instance=instance, include_global=True)
    return render_def('/badge/tiles.html', 'badge_styles', badges=badges,
                      cached=True)

########NEW FILE########
__FILENAME__ = comment_tiles
from pylons import tmpl_context as c

from adhocracy.lib import text
from adhocracy.lib.auth import can
from adhocracy.lib.auth.csrf import token_id
from adhocracy.lib.tiles.util import render_tile, BaseTile


class CommentTile(BaseTile):

    def __init__(self, comment):
        self.comment = comment
        self.__topic_outbound = None
        self.__score = None
        self.__num_child = None

    @property
    def text(self):
        if self.comment and self.comment.latest:
            return text.render(self.comment.latest.text)
        return ""

    @property
    def show(self):
        if self.comment.is_deleted():
            if not any(CommentTile(c).show for c in self.comment.replies):
                return False
        return True

    @property
    def num_children(self):
        if self.__num_child is None:
            num = len(filter(
                lambda c: not c.delete_time, self.comment.replies))
            num += sum(map(lambda c: CommentTile(c).num_children,
                           self.comment.replies))
            self.__num_child = num
        return self.__num_child

    @property
    def score(self):
        return self.comment.poll.tally.score

    @property
    def is_low(self):
        return self.score <= -1


def row(comment):
    return render_tile('/comment/tiles.html', 'row', CommentTile(comment),
                       comment=comment)


def header(comment, tile=None, active='comment'):
    if tile is None:
        tile = CommentTile(comment)
    return render_tile('/comment/tiles.html', 'header', tile,
                       comment=comment, active=active)


def list(topic, root=None, comments=None, variant=None, recurse=True,
         came_from=''):
    cached = c.user is None
    if comments is None:
        comments = topic.comments
    return render_tile('/comment/tiles.html', 'list', tile=None,
                       comments=comments, topic=topic,
                       variant=variant, root=root, recurse=recurse,
                       cached=cached, came_from=came_from)


def show(comment, recurse=True, came_from=''):
    can_edit = can.comment.edit(comment)
    groups = sorted(c.user.groups if c.user else [])
    return render_tile('/comment/tiles.html', 'show', CommentTile(comment),
                       comment=comment, cached=True, can_edit=can_edit,
                       groups=groups, came_from=came_from, recurse=recurse,
                       cache_csrf_token=token_id())

########NEW FILE########
__FILENAME__ = decision_tiles
from pylons.i18n import _

from adhocracy.lib import helpers as h
from adhocracy.lib.tiles.util import render_tile, BaseTile


class DecisionTile(BaseTile):

    def __init__(self, decision):
        self.decision = decision
        self.poll = decision.poll

    @property
    def topic(self):
        if self.poll.action == self.poll.SELECT and self.poll.selection\
           and self.poll.variant:
            text = self.poll.selection.page.variant_head(self.poll.variant)
            variant_link = "<a href='%s'>%s</a>" % (h.text.url(text),
                                                    text.variant_html)
            page_link = h.page.link(self.poll.scope)
            return (_("variant %(variant)s of %(page)s") %
                    dict(variant=variant_link, page=page_link))
        else:
                return h.delegateable.link(self.poll.scope)


def scope_row(decision):
    return render_tile('/decision/tiles.html', 'row', DecisionTile(decision),
                       decision=decision, focus_user=True)


def user_row(decision):
    return render_tile('/decision/tiles.html', 'row', DecisionTile(decision),
                       decision=decision, focus_scope=True)

########NEW FILE########
__FILENAME__ = delegateable_tiles
from pylons import tmpl_context as c

from adhocracy.lib.tiles.util import BaseTile


from adhocracy.lib import democracy


class DelegateableTile(BaseTile):

    def __init__(self, delegateable):
        self.delegateable = delegateable
        self.__dnode = None
        self.__delegations = None
        self.__num_principals = None

    def _dnode(self):
        if not self.__dnode:
            self.__dnode = democracy.DelegationNode(c.user, self.delegateable)
        return self.__dnode

    dnode = property(_dnode)

    def _delegations(self):
        if not self.__delegations:
            self.__delegations = self.dnode.outbound()
        return self.__delegations

    delegations = property(_delegations)

    def _num_principals(self):
        if self.__num_principals is None:
            principals = set(map(lambda d: d.principal,
                                 self.dnode.transitive_inbound()))
            self.__num_principals = len(principals)
        return self.__num_principals

    num_principals = property(_num_principals)

    def _has_delegated(self):
        return len(self.delegations) > 0

    has_delegated = property(_has_delegated)

########NEW FILE########
__FILENAME__ = delegation_tiles
from pylons import tmpl_context as c

from adhocracy.lib.tiles.util import render_tile, BaseTile


class DelegationTile(BaseTile):

    def __init__(self, delegation):
        self.delegation = delegation


def inbound(delegation):
    return render_tile('/delegation/tiles.html', 'inbound',
                       DelegationTile(delegation), delegation=delegation,
                       user=c.user, cached=True)


def outbound(delegation):
    return render_tile('/delegation/tiles.html', 'outbound',
                       DelegationTile(delegation), delegation=delegation,
                       user=c.user, cached=True)


def row(delegation):
    return render_tile('/delegation/tiles.html', 'row',
                       DelegationTile(delegation), delegation=delegation)


def sidebar(delegateable, tile):
    return render_tile('/delegation/tiles.html', 'sidebar',
                       tile=tile, delegateable=delegateable,
                       user=c.user, cached=True)

########NEW FILE########
__FILENAME__ = event_tiles
from util import render_tile

from webhelpers.text import truncate
from adhocracy.lib.text import markdown_to_plain_text


class EventTile():

    def __init__(self, event):
        self.event = event
        self._text = None

    def _get_text(self):
        if self._text is None:
            text = markdown_to_plain_text(self.event.text(),
                                          safe_mode='remove')
            self._text = truncate(text, length=160,
                                  indicator="...", whole_word=True)
        return self._text

    text = property(_get_text)


def event_row(event, row_type):
    return render_tile('/event/tiles.html', row_type,
                       EventTile(event), event=event, cached=True)

########NEW FILE########
__FILENAME__ = instance_tiles
from paste.deploy.converters import asbool
from pylons import tmpl_context as c, config

from adhocracy.model import Page, Proposal
from adhocracy.model import meta
from adhocracy.lib import logo, text
from adhocracy.lib.tiles.util import render_tile, BaseTile

import logging
log = logging.getLogger(__name__)


class InstanceTile(BaseTile):

    def __init__(self, instance):
        self.instance = instance
        self.__issues = None
        self.__proposals_count = None
        self.__norms_count = None

    @property
    def description(self):
        if self.instance.description:
            return text.render(self.instance.description,
                               safe_mode='adhocracy_config')
        return ""

    @property
    def activation_delay(self):
        return self.instance.activation_delay

    @property
    def required_majority(self):
        return "%s%%" % int(self.instance.required_majority * 100)

    @property
    def num_proposals(self):
        if self.__proposals_count is None:
            query = meta.Session.query(Proposal)
            query = query.filter(Proposal.instance == self.instance)
            query = query.filter(Proposal.delete_time == None)  # noqa
            self.__proposals_count = query.count()
        return self.__proposals_count

    @property
    def num_norms(self):
        if self.__norms_count is None:
            query = meta.Session.query(Page)
            query = query.filter(Page.instance == self.instance)
            query = query.filter(Page.delete_time == None)  # noqa
            query = query.filter(Page.function == Page.NORM)
            self.__norms_count = query.count()
        return self.__norms_count

    def show_icon(self):
        show_fallback = asbool(
            config.get('adhocracy.show_instance_fallback_icons'))
        return show_fallback or logo.exists(self.instance)


def row(instance):
    return render_tile('/instance/tiles.html', 'row', InstanceTile(instance),
                       instance=instance, user=c.user, cached=True)


def header(instance, tile=None, active='issues', no_panel=False):
    if tile is None:
        tile = InstanceTile(instance)
    return render_tile('/instance/tiles.html', 'header', tile,
                       instance=instance, active=active, no_panel=no_panel)

########NEW FILE########
__FILENAME__ = milestone_tiles
from pylons import tmpl_context as c
from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import text
from adhocracy.lib.auth.authorization import has
from adhocracy.lib.tiles.util import render_tile, BaseTile


class MilestoneTile(BaseTile):

    def __init__(self, milestone):
        self.milestone = milestone

    @property
    def text(self):
        if self.milestone.text:
            return text.render(self.milestone.text,
                               safe_mode='adhocracy_config')
        return ""


def row(milestone):
    return render_tile('/milestone/tiles.html', 'row',
                       MilestoneTile(milestone),
                       milestone=milestone, cached=True)


def header(milestone, tile=None):
    if tile is None:
        tile = MilestoneTile(milestone)
    return render_tile('/milestone/tiles.html', 'header',
                       tile, milestone=milestone)


def select(selected, name='milestone'):
    options = [('--', None, _('(no milestone)'), selected is None)]

    if has('milestone.edit'):
        milestones = model.Milestone.all_q(instance=c.instance)\
            .order_by(model.Milestone.time).all()
    else:
        milestones = model.Milestone.all_future_q(instance=c.instance)\
            .order_by(model.Milestone.time).all()

        # Add the currently selected milestone if it is in the past
        # so it will be shown and won't be overwritten on save
        if (selected is not None) and (selected not in milestones):
            milestones.insert(0, selected)

    for milestone in milestones:
        options.append((milestone.id, milestone.time, milestone.title,
                        milestone == selected))

    return render_tile('/milestone/tiles.html', 'select',
                       None, options=options, name=name)


def timeline(milestones):
    return render_tile('/milestone/tiles.html', 'timeline',
                       None, milestones=milestones, cached=True)

########NEW FILE########
__FILENAME__ = page_tiles
from util import render_tile

from delegateable_tiles import DelegateableTile


class PageTile(DelegateableTile):

    def __init__(self, page):
        self.page = page
        DelegateableTile.__init__(self, page)


def row(page):
    return render_tile('/page/tiles.html', 'row', PageTile(page),
                       page=page, cached=True)


def smallrow(page):
    return render_tile('/page/tiles.html', 'smallrow', PageTile(page),
                       page=page, cached=True)


def select_page(field_name='page', select=None, exclude=[], functions=[],
                list_limit=500, allow_empty=True, include_sectionpages=False):
    return render_tile('/page/tiles.html', 'select_page', None, select=select,
                       exclude=exclude, field_name=field_name,
                       functions=functions,
                       list_limit=list_limit, allow_empty=allow_empty,
                       include_sectionpages=include_sectionpages)


def inline(page, tile=None, text=None, subpages_pager=None,
           hide_discussion=False):
    if tile is None:
        tile = PageTile(page)
    if text is None:
        text = page.head
    return render_tile('/page/tiles.html', 'inline', tile, page=page,
                       hide_discussion=hide_discussion, text=text,
                       subpages_pager=subpages_pager)


def header(page, tile=None, active='goal', text=None, variant=None):
    if tile is None:
        tile = PageTile(page)
    if text is None:
        text = page.head
    if variant is None:
        variant = text.variant
    return render_tile('/page/tiles.html', 'header', tile,
                       page=page, text=text, variant=variant, active=active)

########NEW FILE########
__FILENAME__ = poll_tiles
from pylons import tmpl_context as c
from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import democracy, helpers as h
from adhocracy.lib.auth import can
from adhocracy.lib.auth.csrf import token_id
from adhocracy.lib.tiles import comment_tiles, proposal_tiles
from adhocracy.lib.tiles.util import render_tile, BaseTile


# A mapping from (current_position, action) to (css_class, title)
# title is a lambda to defer the call of _() until we have a request
action_class = {
    (model.Vote.YES, model.Vote.YES): (
        'vote_up active disabled',
        lambda: _('Your current vote is already pro')),
    (model.Vote.YES, model.Vote.NO): (
        'vote_down', lambda: _('Click to change you vote to neutral')),
    (model.Vote.ABSTAIN, model.Vote.YES): (
        'vote_up', lambda: _('Click to vote pro')),
    (model.Vote.ABSTAIN, model.Vote.NO): (
        'vote_down', lambda: _('Click to vote con')),
    (model.Vote.NO, model.Vote.YES): (
        'vote_up', lambda: _('Click to change you vote to neutral')),
    (model.Vote.NO, model.Vote.NO): (
        'vote_down active disabled',
        lambda: _('Your current vote is already con'))}


class PollTile(BaseTile):
    '''
    A class to write poll tiles with helper methods for the template.
    '''

    def __init__(self, poll, deactivated=False, widget_class=''):
        self.__state = None
        self.__decision = None
        self.__dnode = None
        self.poll = poll
        self.deactivated = deactivated
        self.widget_size = widget_class
        self.widget_class = 'vote ' + widget_class
        self.widget_class += ' deactivated' if self.deactivated else ''
        score = poll.tally.score
        self.count_class = ('positive' if score > 0 else 'negative' if
                            score < 0 else 'neutral')
        self.display_score = u'0' if score == 0 else u"%+d" % score
        self.html_id = 'poll%s' % poll.id
        self.login_redirect_url = h.login_redirect_url(poll.scope,
                                                       anchor=self.html_id)
        self._calculate_conditions()

    def _calculate_conditions(self):
        self.has_ended = self.poll.has_ended()
        self.can_vote = can.poll.vote(self.poll)
        self.can_show = can.poll.show(self.poll)
        if self.has_ended or self.can_vote:
            self.need_auth = False
            self.need_membership = False
            self.need_else = False
        else:
            self.need_auth = (not self.can_vote and c.user is None)
            self.need_membership = (not self.need_auth and
                                    (c.instance and not
                                     c.user.is_member(c.instance)) and
                                    can.instance.join(c.instance))
            self.need_else = (not self.need_membership)

    def widget_action_attrs(self, position):
        '''
        Generate an url to rate or vote in a poll.

        *position*
            The value of the vote. +1 = Pro, 0 = Neutral, +1 = Con.
            For *type_* 'rate' it's only +1 and -1
        '''

        if position not in [model.Vote.YES, model.Vote.NO]:
            raise ValueError(('position "%s" not supported by widget. Use'
                              'model.Vote.YES or model.Vote.NO.') % position)
        title = ''
        url = ''
        klass = 'vote_up' if position == model.Vote.YES else 'vote_down'
        if self.can_vote:
            url = self._rate_url(self.poll, position)
            klass, title_func = action_class[(self.current_position, position)]
            title = title_func()
        elif self.poll.scope.is_frozen():
            url = self.votes_listing_url
            title = _('Topic is frozen. Click to view the list of votes.')
        elif self.poll.scope.instance.frozen:
            url = self.votes_listing_url
            title = _('Instance is frozen. Click to view the list of votes.')
        elif self.has_ended:
            url = self.votes_listing_url
            title = _('Voting has ended. Click to view the list of votes')
        elif self.need_auth:
            url = self.login_redirect_url
            title = _('Please login or register to vote.')
        elif self.need_membership:
            url = '#%s' % self.html_id  # FIXME: implement join and redirect?
            title = _('Please join the instance "%s" to vote.')\
                % c.instance.label
        elif self.need_else:
            # We can't figure out what to do, so no options to vote
            url = self.votes_listing_url
            title = _('Click to see the list of votes')
        else:
            raise ValueError(
                'Dunno how this could happen. A bug apparently :)')

        return {'title': title, 'url': url, 'class': klass}

    @property
    def state(self):
        if not self.__state:
            self.__state = democracy.State(self.poll.proposal, poll=self.poll)
        return self.__state

    @property
    def dnode(self):
        if not self.__dnode:
            self.__dnode = democracy.DelegationNode(c.user, self.poll.scope)
        return self.__dnode

    @property
    def decision(self):
        if not self.__decision and c.user:
            self.__decision = democracy.Decision(c.user, self.poll)
        return self.__decision

    @property
    def delegates(self):
        agents = []
        if not c.user:
            return []
        for delegation in self.dnode.outbound():
            agents.append(delegation.agent)
        return set(agents)

    def delegates_result(self, result):
        agents = []
        for agent in self.delegates:
            decision = democracy.Decision(agent, self.poll)
            if decision.is_decided() and decision.result == result:
                agents.append(agent)
        return agents

    @property
    def result_affirm(self):
        return round(self.poll.tally.rel_for * 100.0, 1)

    @property
    def result_dissent(self):
        return round(self.poll.tally.rel_against * 100.0, 1)

    @property
    def current_position(self):
        '''
        Returns: the decision of the current user
        This will be *model.Vote.YES*, *model.Vote.ABSTAIN* or
        *model.Vote.NO*. If there is no current user, it will
        return *model.Vote.ABSTAIN*.
        '''
        result = None
        decision = self.decision
        if decision:
            result = decision.result
        if result is None:
            result = model.Vote.ABSTAIN
        return result

    def _rate_url(self, poll, position):
        params = {'url': h.entity_url(poll, member='rate'),
                  'token_param': h.url_token(),
                  'position': position,
                  'cls': self.widget_size}
        return ("%(url)s?position=%(position)d&"
                "%(token_param)s&cls=%(cls)s") % params

    @property
    def votes_listing_url(self):
        return h.entity_url(self.poll, member="votes")


def booth(poll):
    return render_tile('/poll/tiles.html', 'booth',
                       PollTile(poll), poll=poll, user=c.user, cached=True)


def row(poll):
    return render_tile('/poll/tiles.html', 'row',
                       PollTile(poll), poll=poll, user=c.user, cached=True)


def widget(poll, cls='', deactivated=False, delegate_url=None):
    '''
    FIXME: fix caching. Poll objects don't change. Tallies are
    generated for every vote. Ask @pudo about this.

    Render a rating widget for an :class:`adhocracy.model.poll.Poll`.
    It is rendered based on the permission of the current user to
    vote for the poll.

    TODO: Add support for helpful tooltips for the voting buttons.

    *cls* (str)
        The type that will be rendered as css class in the widget.
        By default it is a small widget. Using 'big' will render a
        big one.
    *deactivated*
        Render the widget deactivated which does not show vote buttons
        or the current position of the user, but still the vote count.
    *delegate_url* (unicode or None)
        An URL if a delegate button should be shown beside the vote
        widget. If *None* (default) no button will be shown.
    '''
    t = PollTile(poll, deactivated, widget_class=cls)
    return render_tile('/poll/tiles.html', 'widget',
                       t, poll=poll, user=c.user, widget_class=cls,
                       delegate_url=delegate_url, deactivated=deactivated,
                       cached=True, cache_csrf_token=token_id())


def header(poll, active=''):
    if isinstance(poll.subject, model.Comment):
        return comment_tiles.header(poll.subject, active=active)
    elif isinstance(poll.scope, model.Proposal):
        return proposal_tiles.header(poll.scope, active=active)

########NEW FILE########
__FILENAME__ = proposal_tiles
from datetime import datetime, timedelta
from pylons import tmpl_context as c

from adhocracy.lib.auth import authorization
from adhocracy.lib.democracy import Decision
from adhocracy.lib.tiles.util import render_tile
from adhocracy.lib.tiles.delegateable_tiles import DelegateableTile


class ProposalTile(DelegateableTile):

    def __init__(self, proposal):
        self.proposal = proposal
        self.__poll = None
        self.__decision = None
        self.__num_principals = None
        self.__comment_tile = None
        DelegateableTile.__init__(self, proposal)

    @property
    def fresh(self):
        return ((datetime.utcnow() - self.proposal.create_time) <
                timedelta(hours=36))

    @property
    def poll(self):
        if not self.__poll:
            self.__poll = self.proposal.adopt_poll
        return self.__poll

    @property
    def delegates(self):
        agents = []
        if not c.user:
            return []
        for delegation in self.dnode.outbound():
            agents.append(delegation.agent)
        return set(agents)

    @property
    def num_principals(self):
        if self.__num_principals is None:
            principals = set(map(lambda d: d.principal,
                                 self.dnode.transitive_inbound()))
            if self.poll:
                principals = filter(
                    lambda p: not Decision(p, self.poll).is_self_decided(),
                    principals)
            self.__num_principals = len(principals)
        return self.__num_principals


def row(proposal):
    global_admin = authorization.has('global.admin')
    if not proposal:
        return ""
    return render_tile('/proposal/tiles.html', 'row', ProposalTile(proposal),
                       proposal=proposal, cached=True,
                       badgesglobal_admin=global_admin)


def row_inline(proposal):
    global_admin = authorization.has('global.admin')
    if not proposal:
        return ""
    return render_tile('/proposal/tiles.html', 'row_inline',
                       ProposalTile(proposal),
                       proposal=proposal, cached=False,
                       badgesglobal_admin=global_admin)


def header(proposal, tile=None, active='goal'):
    if tile is None:
        tile = ProposalTile(proposal)
    return render_tile('/proposal/tiles.html', 'header', tile,
                       proposal=proposal, active=active)


def panel(proposal, tile):
    return render_tile('/proposal/tiles.html', 'panel', tile,
                       proposal=proposal, cached=True)


def sidebar(proposal, tile=None):
    if tile is None:
        tile = ProposalTile(proposal)
    return render_tile('/proposal/tiles.html', 'sidebar', tile,
                       proposal=proposal)

########NEW FILE########
__FILENAME__ = revision_tiles
from adhocracy.lib.tiles.comment_tiles import CommentTile
from adhocracy.lib.tiles.util import render_tile, BaseTile


class RevisionTile(BaseTile):

    def __init__(self, revision):
        self.revision = revision
        self.comment_tile = CommentTile(revision.comment)


def row(revision):
    return render_tile('/comment/revision_tiles.html', 'row',
                       RevisionTile(revision), revision=revision)

########NEW FILE########
__FILENAME__ = selection_tiles
from pylons import tmpl_context as c

from adhocracy.lib.auth import can
from util import render_tile, BaseTile


class VariantRow(object):

    def __init__(self, tile, variant, poll):
        self.tile = tile
        self.variant = variant
        self.poll = poll
        if tile.frozen:
            freeze_time = tile.selection.proposal.adopt_poll.begin_time
            self.text = tile.selection.page.variant_at(variant, freeze_time)
        else:
            self.text = tile.selection.page.variant_head(variant)

    @property
    def selected(self):
        return self.tile.selected == self.variant

    @property
    def show(self):
        return not self.tile.frozen or self.selected

    @property
    def can_edit(self):
        return (not self.tile.frozen) and \
            can.variant.edit(self.tile.selection.page, self.variant)

    @property
    def num_comments(self):
        return len(self.tile.selection.page.variant_comments(self.variant))


class SelectionTile(BaseTile):

    def __init__(self, selection):
        self.selection = selection
        self.selected = selection.selected
        self.variant_polls = self.selection.variant_polls

    @property
    def has_variants(self):
        return len(self.selection.page.variants) < 2

    @property
    def num_variants(self):
        return len(self.selection.page.variants) - 1

    @property
    def selected_text(self):
        variant = self.selected
        if self.frozen:
            freeze_time = self.selection.proposal.adopt_poll.begin_time
            return self.selection.page.variant_at(variant, freeze_time)
        else:
            return self.selection.page.variant_head(variant)

    @property
    def selected_num_comments(self):
        return len(self.selection.page.variant_comments(self.selected))

    @property
    def frozen(self):
        return self.selection.proposal.is_adopt_polling()

    def variant_rows(self):
        for (variant, poll) in self.variant_polls:
            row = VariantRow(self, variant, poll)
            yield row

    @property
    def show_new_variant_link(self):
        if self.frozen:
            return False
        return can.norm.edit(self.selection.page, 'any')


def row(selection):
    if not selection or selection.is_deleted():
                return ""
    tile = SelectionTile(selection)
    return render_tile('/selection/tiles.html', 'row', tile,
                       selection=selection, user=c.user, cached=True)


def variants(selection, tile=None):
    if tile is None:
        tile = SelectionTile(selection)
    return render_tile('/selection/tiles.html', 'variants', tile,
                       selection=selection, user=c.user, cached=True)

########NEW FILE########
__FILENAME__ = tag_tiles
from util import render_tile, BaseTile


class TagTile(BaseTile):

    def __init__(self, tag):
        self.tag = tag


def row(tag):
    return render_tile('/tag/tiles.html', 'row', TagTile(tag),
                       tag=tag, cached=True)


def cloud(tags, plain=True, show_count=False, link_more=True):
    from adhocracy.lib.templating import render_def
    return render_def('/tag/tiles.html', 'cloud', tags=tags, plain=plain,
                      show_count=show_count, link_more=link_more, cached=True)


def sidebar(delegateable):
    from adhocracy.lib.templating import render_def
    return render_def('/tag/tiles.html', 'sidebar',
                      delegateable=delegateable, cached=True)

########NEW FILE########
__FILENAME__ = text_tiles
from adhocracy.lib.tiles.util import render_tile, BaseTile


class TextTile(BaseTile):

    def __init__(self, text):
        self.text = text


def history_row(text):
    return render_tile('/text/tiles.html', 'history_row',
                       TextTile(text), text=text)


def full(text, subpages_pager=None, hide_discussion=True):
    return render_tile('/text/tiles.html', 'full',
                       TextTile(text), text=text,
                       subpages_pager=subpages_pager,
                       hide_discussion=hide_discussion)


def minimal(text, missing_translation=None):
    return render_tile('/text/tiles.html', 'minimal',
                       TextTile(text), text=text,
                       missing_translation=missing_translation)


def descbox(this, other, options=None, field=None):
    return render_tile('/text/tiles.html', 'descbox', TextTile(this),
                       this=this, other=other, options=options, field=field)

########NEW FILE########
__FILENAME__ = user_tiles
from pylons import tmpl_context as c
from pylons.i18n import _

from adhocracy import model
from adhocracy.lib import text
from adhocracy.lib.tiles.util import render_tile, BaseTile


class UserTile(BaseTile):

    def __init__(self, user):
        self.user = user
        self.__instance_group = None
        self.__instance_roles = None

    def _bio(self):
        if self.user.bio:
            return text.render(self.user.bio)
        return ""

    bio = property(_bio)

    def _num_proposals(self):
        pred = lambda d: isinstance(d, model.Proposal) and \
            d.instance == c.instance and \
            not d.is_deleted()
        return len(filter(pred, self.user.delegateables))

    num_proposals = property(_num_proposals)

    def _num_comments(self):
        pred = lambda cm: cm.topic.instance == c.instance and \
            not cm.is_deleted()
        return len(filter(pred, self.user.comments))

    num_comments = property(_num_comments)

    def _num_instances(self):
        return len([i for i in self.user.instances if i.is_shown()])

    num_instances = property(_num_instances)

    def _instance_group(self):
        if c.instance and not self.__instance_group:
            m = self.user.instance_membership(c.instance)
            self.__instance_group = m.group if m else None
        return self.__instance_group

    instance_group = property(_instance_group)

    def _instance_roles(self):
        if c.instance and not self.__instance_roles:
            instance_roles = []
            for badge in self.user.badges:
                if badge.group and badge.display_group:
                    instance_roles.append(badge.group)
            if instance_roles:
                self.__instance_roles = instance_roles
            else:
                self.__instance_roles = [self.instance_group]

        return self.__instance_roles

    instance_roles = property(_instance_roles)

    def translated_instance_role_names(self):
        translated_names = [_(group.group_name) for group in
                            self.instance_roles]
        return ', '.join(translated_names)


def row(user):
    if not user:
        return ""
    return render_tile('/user/tiles.html', 'row', UserTile(user),
                       user=user, instance=c.instance, cached=True)


def header(user, tile=None, active='activity', show_delete_user_button=False):
    if tile is None:
        tile = UserTile(user)
    return render_tile('/user/tiles.html', 'header', tile,
                       user=user, active=active,
                       show_delete_user_button=show_delete_user_button)

########NEW FILE########
__FILENAME__ = util
import logging
from time import time

from pylons import tmpl_context as c

from adhocracy import config
from adhocracy.lib.cache import memoize

log = logging.getLogger(__name__)


class BaseTile(object):
    '''
    Base class for tiles
    '''


def render_tile(template_name, def_name, tile, cached=False, **kwargs):
    from adhocracy.lib import templating
    begin_time = time()

    def render():
        return templating.render_def(template_name, def_name,
                                     tile=tile, **kwargs)
    rendered = ""
    if cached and config.get_bool('adhocracy.cache_tiles'):
        @memoize('tile_cache' + template_name + def_name, 7 * 86400)
        def _cached(**kwargs):
            return render()
        rendered = _cached(locale=c.locale, **kwargs)
    else:
        rendered = render()

    if False:
        log.debug("Rendering tile %s:%s took %sms" % (
            template_name, def_name, (time() - begin_time) * 1000))

    return rendered

########NEW FILE########
__FILENAME__ = treatment
import itertools
import random


def _iter_assignments_by_source_badge(treatment):
    assigned_ids = [set(u.id for u in aul)
                    for aul in treatment.get_assigned_users()]

    for b in treatment.source_badges:
        current_assignment = [[] for i in range(len(assigned_ids))]
        unassigned = []
        for u in b.users:
            for uids, assignment in zip(assigned_ids, current_assignment):
                if u.id in uids:
                    assignment.append(u)
                    break
            else:
                unassigned.append(u)
        yield (b, current_assignment, unassigned)


def get_assignments_by_source_badge(treatment):
    return list(_iter_assignments_by_source_badge(treatment))


def pick_user_assignments(treatment):
    for source_badge, current_assignment, unassigned in (
            _iter_assignments_by_source_badge(treatment)):

        # Determine how often we should pick from which variants
        possible_assignments = []
        assignment_counts = list(map(len, current_assignment))
        mx = max(assignment_counts)

        for i, ac in enumerate(assignment_counts):
            possible_assignments.extend([i] * (mx - ac))

        needed_count = len(unassigned) - len(possible_assignments)
        if needed_count > 0:
            needed_rounds = needed_count // treatment.variant_count + 1
            possible_assignments.extend(range(treatment.variant_count) *
                                        needed_rounds)

        random.shuffle(possible_assignments)

        for user, variant_id in zip(unassigned, possible_assignments):
            badge = treatment.get_variant_badge(variant_id)
            yield (user, badge)


def assign_users(treatment):
    """ Assigns each unassigned user matched by the source badges a
    treatment variant badge """

    changed = False
    for user, badge in pick_user_assignments(treatment):
        changed = True
        badge.assign(user=user, creator=user)
    return changed

########NEW FILE########
__FILENAME__ = unicode
'''
helper module which provides unicode related stuff.
'''

import csv


class UnicodeCsvReader(object):
    """
    unicode aware csv.CsvReader.
    thanks to http://stackoverflow.com/a/6187936/201743
    """
    def __init__(self, f, encoding="utf-8", **kwargs):
        self.csv_reader = csv.reader(f, **kwargs)
        self.encoding = encoding

    def __iter__(self):
        return self

    def next(self):
        # read and split the csv row into fields
        row = self.csv_reader.next()
        # now decode
        return [unicode(cell, self.encoding) for cell in row]

    @property
    def line_num(self):
        return self.csv_reader.line_num


class UnicodeDictReader(csv.DictReader):
    """
    unicode aware csv.DictReader.
    thanks to http://stackoverflow.com/a/6187936/201743
    """
    def __init__(self, f, encoding="utf-8", fieldnames=None, **kwds):
        csv.DictReader.__init__(self, f, fieldnames=fieldnames,
                                restkey=u'rest', **kwds)
        self.reader = UnicodeCsvReader(f, encoding=encoding, **kwds)

########NEW FILE########
__FILENAME__ = user_import
import logging

from adhocracy import model
from adhocracy.lib.helpers import base_url, has_permission
from adhocracy.lib.mail import to_user
from adhocracy.lib.util import random_token

log = logging.getLogger(__name__)


def user_import(_users, email_subject, email_template, creator, instance,
                reinvite=False):
    names = []
    created = []
    mailed = []
    errors = False
    users = []
    for user_info in _users:
        try:
            name = user_info['user_name']
            email = user_info['email']

            try:
                display_name = user_info['display_name']
                names.append(name)
                if reinvite:
                    user = model.User.find(name)
                else:
                    user = model.User.create(name, email,
                                             display_name=display_name,
                                             autojoin=False)
                    user.activation_code = user.IMPORT_MARKER + random_token()
                password = random_token()
                user_info['password'] = password
                user.password = password

                for badge in user_info['user_badges']:
                    badge.assign(user, creator=creator)

                model.meta.Session.add(user)
                model.meta.Session.commit()
                users.append(user)
                created.append(user.user_name)
                url = base_url(
                    "/user/%s/activate?c=%s" % (user.user_name,
                                                user.activation_code),
                    instance=instance,
                    absolute=True)

                user_info['url'] = url
                body = email_template.format(*user_info.get('rest', []),
                                             **user_info)
                to_user(user, email_subject, body, decorate_body=False)
                mailed.append(user.user_name)

            except Exception, E:
                log.error('user import for user %s, email %s, exception %s' %
                          (user_info['user_name'], user_info['email'], E))
                errors = True
                continue
        except Exception, E:
            log.error('user import invalid user exception %s' % E)
            errors = True
            continue
    return {
        'users': users,
        'not_created': set(names) - set(created),
        'not_mailed': set(created) - set(mailed),
        'errors': errors
    }


def get_user_import_state():
    """user import state

    This function can be used to generate state objects for formencode.
    """

    class State(object):
        pass

    state = State()
    state.global_admin = has_permission('global.admin')

    return state

########NEW FILE########
__FILENAME__ = util
import collections
import logging
import os
import os.path
import shutil
import time
import uuid

from pylons import config
from pylons.i18n import _

log = logging.getLogger(__name__)


def timedelta2seconds(delta):
    """ Convert a given timedelta to a number of seconds """
    return ((delta.microseconds / 1000000.0) +
            delta.seconds + (delta.days * 60 * 60 * 24))


def datetime2seconds(dt):
    '''
    convert a :class:`datetime.datetime` object into seconds since
    the epoche.
    '''
    return time.mktime(dt.timetuple())


def random_token():
    """ Get a random string, the first char group of a uuid4 """
    return unicode(uuid.uuid4()).split('-').pop()


def random_username():

    import random

    vouwels = 'aeiouy'
    consonants = 'bcdfghjklmnprstvwxz'

    length = random.randint(6, 9)
    consonant = (random.randint(0, 1) == 0)

    name = u''
    for _x in range(length):
        if consonant:
            name += random.choice(consonants)
        else:
            name += random.choice(vouwels)
        consonant = not consonant

    return name


def get_entity_or_abort(cls, id, instance_filter=True, **kwargs):
    from templating import ret_abort
    """
    Return either the instance identified by the given ID or
    raise a HTTP 404 Exception within the controller.
    """
    if not hasattr(cls, 'find'):
        raise TypeError("The given class does not have a find() method")
    obj = cls.find(id, instance_filter=instance_filter, **kwargs)
    if not obj:
        ret_abort(_("Could not find the entity '%s'") % id, code=404)
    return obj


# File system related functions:

def get_site_directory(app_conf=None):
    if app_conf is None:
        app_conf = config
    rel = app_conf.get('adhocracy.site.dir',
                       os.path.join(app_conf.get('here'), 'site'))
    site_directory = os.path.abspath(rel)
    if not os.path.exists(site_directory):
        os.makedirs(site_directory)
    elif not os.path.isdir(site_directory):
        raise IOError("adhocracy.site.dir must be a directory!")
    return site_directory


def get_fallback_directory(app_conf=None):
    if app_conf is None:
        app_conf = config
    return os.path.abspath(app_conf.get('pylons.paths').get('root'))


def compose_path(basedir, *a):
    path = os.path.join(basedir, *a)
    path = os.path.abspath(path)
    if not path.startswith(basedir):
        # escape attempt
        raise IOError("Path outside scope")
    return path


def get_site_path(*a, **kwargs):
    app_conf = kwargs.get('app_conf', None)
    return compose_path(get_site_directory(app_conf=app_conf), *a)


def get_path(*a, **kwargs):
    app_conf = kwargs.get('app_conf', None)
    path = compose_path(get_site_directory(app_conf=app_conf), *a)
    if not os.path.exists(path):
        path = compose_path(get_fallback_directory(app_conf=app_conf), *a)
    if not os.path.exists(path):
        return None
    return path


def create_site_subdirectory(*a, **kwargs):
    app_conf = kwargs.get('app_conf')
    path = get_site_path(*a, app_conf=app_conf)
    if not os.path.exists(path):
        os.makedirs(path)
    return path


def replicate_fallback(*a, **kwargs):
    to_path = get_site_path(*a, **kwargs)
    if not os.path.exists(to_path):
        log.debug("Setting up site item at: %s" % to_path)
        to_dir = os.path.dirname(to_path)
        if not os.path.exists(to_dir):
            os.makedirs(to_dir)
        from_path = get_path(*a, **kwargs)
        if from_path is None:
            raise IOError("Site file does not exist.")
        if not from_path == to_path:
            shutil.copy(from_path, to_path)
    return to_path


def generate_sequence(initial=10,
                      factors=[2, 2.5, 2],
                      minimum=None,
                      maximum=None):
    factor_deque = collections.deque(factors)
    current = initial
    while maximum is None or current < maximum:
        if minimum is None or current >= minimum:
            yield int(current)
        current *= factor_deque[0]
        factor_deque.rotate(-1)
    yield int(current)


def get_client_ip(environ, config=config):
    import adhocracy.config
    if adhocracy.config.get_bool('adhocracy.behind_proxy', config=config):
        try:
            header_val = environ['HTTP_X_FORWARDED_FOR']
            return header_val.rpartition(u',')[2].strip()
        except KeyError:
            pass
    return environ['REMOTE_ADDR']


def split_filter(condition, seq):
    '''
    Splits *seq* into two lists based on *condition*, the items in the first
    list match the conditions, the items in the second list don't.
    '''
    a, b = [], []
    for item in seq:
        (a if condition(item) else b).append(item)
    return a, b

########NEW FILE########
__FILENAME__ = version
"""
Versioning for the application, especially for the UI.
"""

from pkg_resources import get_distribution


def get_version():
    """ Get a version identifier for use in the public user interface """
    return get_distribution("adhocracy").version

########NEW FILE########
__FILENAME__ = votedetail
from adhocracy import config
from adhocracy.lib.cache.util import memoize


def calc_votedetail(instance, poll):
    from adhocracy.model import User, Badge
    from adhocracy.lib.democracy import tally as _tally
    res = []
    for badge in instance.votedetail_userbadges:
        uf = lambda q: q.join(User.badges).filter(Badge.id == badge.id)
        tally = _tally.make_from_poll(_tally.SimpleTally, poll, user_filter=uf)
        res.append((badge, tally))
    return res


@memoize('votedetail')
def calc_votedetail_dict(instance, poll, badge_title_only=False):
    badge_value = lambda b: b.title if badge_title_only else b.to_dict()
    return [{'badge': badge_value(b), 'tally': t.to_dict()}
            for b, t in calc_votedetail(instance, poll)]


def is_enabled():
    return config.get_bool('adhocracy.enable_votedetail')

########NEW FILE########
__FILENAME__ = watchlist
import logging

from pylons import tmpl_context as c

from adhocracy.model import meta, Watch, Comment, Delegateable
import adhocracy.model.refs as refs


log = logging.getLogger(__name__)


def find_watch(entity):
    return Watch.find_by_entity(c.user, entity)


def make_watch(entity):
    return refs.to_url(entity)


def set_watch(entity, set_watch=True):
    """
    Make sure that the current user watches entity, if set_watch is True. Make
    sure that the current user doesn't watch entity, if set_watch is False.
    """
    has_watch = Watch.find_by_entity(c.user, entity)
    if set_watch and has_watch is None:
        Watch.create(c.user, entity)
        meta.Session.commit()
    elif not set_watch and has_watch is not None:
        has_watch.delete()
        meta.Session.commit()


def clean_stale_watches():
    log.debug("Beginning to clean up watchlist entries...")
    count = 0
    for watch in Watch.all():
        if hasattr(watch.entity, 'is_deleted') and \
                watch.entity.is_deleted():
            count += 1
            watch.delete()
    meta.Session.commit()
    if count > 0:
        log.debug("Removed %d stale watchlist entries." % count)


def traverse_watchlist(entity):
    """
    Traverse the watchlist for all affected topics. Returns only
    the most closely matching watchlist entries.
    """

    def merge(inner, outer):
        return inner + [w for w in outer if
                        w.user not in [ww.user for ww in inner]]

    watches = Watch.all_by_entity(entity)

    if isinstance(entity, Comment):
        if entity.reply is not None:
            watches = merge(watches,
                            traverse_watchlist(entity.reply))
        else:
            watches = merge(watches,
                            traverse_watchlist(entity.topic))
    elif isinstance(entity, Delegateable):
        if entity.milestone is not None and not entity.milestone.is_deleted():
            watches = merge(watches, traverse_watchlist(entity.milestone))
        if len(entity.parents):
            for parent in entity.parents:
                watches = merge(watches,
                                traverse_watchlist(parent))
        else:
            watches = merge(watches,
                            traverse_watchlist(entity.instance))
    return watches

########NEW FILE########
__FILENAME__ = 001_Initial
from datetime import datetime

from sqlalchemy import *
from migrate import *

meta = MetaData()

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime)
    )


openid_table = Table('openid', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('identifier', Unicode(255), nullable=False, index=True)
    )


oid_nonces = Table('oid_nonces', meta,
    Column('server_url', LargeBinary, nullable=False),
    Column('timestamp', Integer, primary_key=True),
    Column('salt', Unicode(40), nullable=False, index=True)
    )


oid_associations = Table('oid_associations', meta,
    Column('server_url', LargeBinary, nullable=False),
    Column('handle', Unicode(255), nullable=False, index=True),
    Column('secret', LargeBinary, nullable=False),
    Column('issued', Integer, primary_key=True),
    Column('lifetime', Integer, primary_key=True),
    Column('assoc_type', Unicode(64), nullable=False)
    )

twitter_table = Table('twitter', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('twitter_id', Integer),
    Column('key', Unicode(255), nullable=False),
    Column('secret', Unicode(255), nullable=False),
    Column('screen_name', Unicode(255), nullable=False),
    Column('priority', Integer, default=4)
    )

group_table = Table('group', meta,
    Column('id', Integer, primary_key=True),
    Column('group_name', Unicode(255), nullable=False, unique=True),
    Column('code', Unicode(255), nullable=False, unique=True),
    Column('description', Unicode(1000))
    )

group_permission_table = Table('group_permission', meta,
    Column('group_id', Integer, ForeignKey('group.id',
           onupdate="CASCADE", ondelete="CASCADE")),
    Column('permission_id', Integer, ForeignKey('permission.id',
           onupdate="CASCADE", ondelete="CASCADE"))
    )

permission_table = Table('permission', meta,
    Column('id', Integer, primary_key=True),
    Column('permission_name', Unicode(255), nullable=False, unique=True)
    )

category_graph = Table('category_graph', meta,
    Column('parent_id', Integer, ForeignKey('delegateable.id')),
    Column('child_id', Integer, ForeignKey('delegateable.id'))
    )

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

issue_table = Table('issue', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True)
    )

delegation_table = Table('delegation', meta,
    Column('id', Integer, primary_key=True),
    Column('agent_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('principal_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('revoke_time', DateTime, default=None, nullable=True)
    )

proposal_table = Table('proposal', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True)
    )

alternative_table = Table('alternative', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('left_id', Integer, ForeignKey('proposal.id'), nullable=False),
    Column('right_id', Integer, ForeignKey('proposal.id'), nullable=False)
    )

dependency_table = Table('dependency', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('proposal_id', Integer, ForeignKey('proposal.id'), nullable=False),
    Column('requirement_id', Integer, ForeignKey('proposal.id'), nullable=False)
    )

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('begin_user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('proposal_id', Integer, ForeignKey('proposal.id'), nullable=False)
    )

vote_table = Table('vote', meta,
    Column('id', Integer, primary_key=True),
    Column('orientation', Integer, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('delegation_id', Integer, ForeignKey('delegation.id'), nullable=True)
    )

revision_table = Table('revision', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('text', UnicodeText(), nullable=False),
    Column('sentiment', Integer, default=0),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=False)
    )

comment_table = Table('comment', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, default=None, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('canonical', Boolean, default=False),
    Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True)
    )

instance_table = Table('instance', meta,
    Column('id', Integer, primary_key=True),
    Column('key', Unicode(20), nullable=False, unique=True),
    Column('label', Unicode(255), nullable=False),
    Column('description', UnicodeText(), nullable=True),
    Column('required_majority', Float, nullable=False),
    Column('activation_delay', Integer, nullable=False),
    Column('create_time', DateTime, default=func.now()),
    Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True)
    )

membership_table = Table('membership', meta,
    Column('id', Integer, primary_key=True),
    Column('approved', Boolean, nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('expire_time', DateTime, nullable=True),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=True),
    Column('group_id', Integer, ForeignKey('group.id'), nullable=False)
    )

karma_table = Table('karma', meta,
    Column('id', Integer, primary_key=True),
    Column('value', Integer, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=False),
    Column('donor_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('recipient_id', Integer, ForeignKey('user.id'), nullable=False)
    )

watch_table = Table('watch', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('entity_type', Unicode(255), nullable=False, index=True),
    Column('entity_ref', Unicode(255), nullable=False, index=True)
    )

event_topic_table = Table('event_topic', meta,
    Column('event_id', Integer, ForeignKey('event.id',
           onupdate="CASCADE", ondelete="CASCADE")),
    Column('topic_id', Integer, ForeignKey('delegateable.id',
           onupdate="CASCADE", ondelete="CASCADE"))
    )


event_table = Table('event', meta,
    Column('id', Integer, primary_key=True),
    Column('event', Unicode(255), nullable=False),
    Column('time', DateTime, default=datetime.utcnow),
    Column('data', UnicodeText(), nullable=False),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=True)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    user_table.create()
    openid_table.create()
    oid_nonces.create()
    oid_associations.create()
    twitter_table.create()
    group_table.create()
    group_permission_table.create()
    permission_table.create()
    category_graph.create()
    delegateable_table.create()
    issue_table.create()
    delegation_table.create()
    proposal_table.create()
    alternative_table.create()
    dependency_table.create()
    poll_table.create()
    vote_table.create()
    revision_table.create()
    comment_table.create()
    instance_table.create()
    membership_table.create()
    karma_table.create()
    watch_table.create()
    event_topic_table.create()
    event_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 002_Remove_Dependencies
from datetime import datetime

from sqlalchemy import *
from migrate import *

meta = MetaData()

proposal_table = Table('proposal', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True)
    )

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('begin_user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('proposal_id', Integer, ForeignKey('proposal.id'), nullable=False)
    )

dependency_table = Table('dependency', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('proposal_id', Integer, ForeignKey('proposal.id'), nullable=False),
    Column('requirement_id', Integer, ForeignKey('proposal.id'), nullable=False)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    dependency_table.drop()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 003_Offline_Tally
from datetime import datetime

from sqlalchemy import *
from migrate import *

meta = MetaData()

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('begin_user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('proposal_id', Integer, ForeignKey('proposal.id'), nullable=False)
    )

vote_table = Table('vote', meta,
    Column('id', Integer, primary_key=True),
    Column('orientation', Integer, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('delegation_id', Integer, ForeignKey('delegation.id'), nullable=True)
    )

tally_table = Table('tally', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('vote_id', Integer, ForeignKey('vote.id'), nullable=True),
    Column('num_for', Integer, nullable=True),
    Column('num_against', Integer, nullable=True),
    Column('num_abstain', Integer, nullable=True)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    tally_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 004_Better_poll
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    poll_table_old = Table('poll', meta,
        Column('id', Integer, primary_key=True),
        Column('begin_time', DateTime, default=datetime.utcnow),
        Column('end_time', DateTime, nullable=True),
        Column('begin_user_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('proposal_id', Integer, ForeignKey('proposal.id'), nullable=False)
        )

    proposal_table = Table('proposal', meta,
        Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
        Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True)
        )

    adopt_poll_id = Column('adopt_poll_id', Integer, ForeignKey('poll.id'), nullable=True)
    adopt_poll_id.create(proposal_table)

    action = Column('action', Unicode(50), nullable=True, default='adopt')
    subject = Column('subject', UnicodeText(), nullable=True)
    scope_id = Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=True)
    action.create(poll_table_old)
    subject.create(poll_table_old)
    scope_id.create(poll_table_old)
    poll_table_old.c.begin_user_id.alter(name="user_id")

    q = migrate_engine.execute(poll_table_old.select())
    for (id, _, _, _, proposal_id, _, _, _) in q:
        u = poll_table_old.update(id == poll_table_old.c.id,
                                  {'scope_id': proposal_id,
                                   'subject': u"@[proposal:%s]" % proposal_id,
                                   'action': u'adopt'})
        migrate_engine.execute(u)
        q = proposal_table.update(proposal_table.c.id == proposal_id,
                                  {'adopt_poll_id': id})
        migrate_engine.execute(q)

    poll_table_old.c.proposal_id.drop()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 005_Poll_ratings
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('action', Unicode(50), nullable=False),
    Column('subject', UnicodeText(), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False)
    )

tally_table = Table('tally', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('vote_id', Integer, ForeignKey('vote.id'), nullable=True),
    Column('num_for', Integer, nullable=True),
    Column('num_against', Integer, nullable=True),
    Column('num_abstain', Integer, nullable=True)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    proposal_table = Table('proposal', meta,
        Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
        Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True)
        )

    rate_poll_id = Column('rate_poll_id', Integer, ForeignKey('poll.id'), nullable=True)
    rate_poll_id.create(proposal_table)

    for vals in migrate_engine.execute(proposal_table.select()):
        proposal_id = vals[0]
        q = poll_table.insert(values={'scope_id': proposal_id,
                                      'action': u'rate',
                                      'subject': u"@[proposal:%s]" % proposal_id,
                                      'user_id': 1,
                                      'begin_time': datetime.utcnow()})
        r = migrate_engine.execute(q)
        poll_id = r.last_inserted_ids()[-1]
        q = tally_table.insert(values={'create_time': datetime.utcnow(),
                                       'poll_id': poll_id,
                                       'num_for': 0,
                                       'num_against': 0,
                                       'num_abstain': 0})
        r = migrate_engine.execute(q)
        q = proposal_table.update(proposal_table.c.id == proposal_id,
                                  {'rate_poll_id': poll_id})
        migrate_engine.execute(q)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 006_Karma_as_poll
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('action', Unicode(50), nullable=False),
    Column('subject', UnicodeText(), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False)
    )

tally_table = Table('tally', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('vote_id', Integer, ForeignKey('vote.id'), nullable=True),
    Column('num_for', Integer, nullable=True),
    Column('num_against', Integer, nullable=True),
    Column('num_abstain', Integer, nullable=True)
    )

karma_table = Table('karma', meta,
    Column('id', Integer, primary_key=True),
    Column('value', Integer, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=False),
    Column('donor_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('recipient_id', Integer, ForeignKey('user.id'), nullable=False),
    )

vote_table = Table('vote', meta,
    Column('id', Integer, primary_key=True),
    Column('orientation', Integer, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('delegation_id', Integer, ForeignKey('delegation.id'), nullable=True)
    )

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    comment_table = Table('comment', meta,
        Column('id', Integer, primary_key=True),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('delete_time', DateTime, default=None, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
        Column('canonical', Boolean, default=False),
        Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True)
        )

    poll_id = Column('poll_id', Integer, ForeignKey('poll.id'), nullable=True)
    poll_id.create(comment_table)

    q = migrate_engine.execute(comment_table.select())
    for (comment_id, create_time,
         delete_time, creator_id,
         topic_id, _, _, _) in q:

        q = poll_table.insert(values={'scope_id': topic_id,
                                      'action': u'rate',
                                      'subject': u"@[comment:%s]" % comment_id,
                                      'user_id': creator_id,
                                      'begin_time': create_time,
                                      'end_time': delete_time})
        r = migrate_engine.execute(q)
        poll_id = r.last_inserted_ids()[-1]
        z = tally_table.insert(values={'create_time': create_time,
                                       'poll_id': poll_id,
                                       'num_for': 0,
                                       'num_against': 0,
                                       'num_abstain': 0})
        r = migrate_engine.execute(z)

        a = migrate_engine.execute(karma_table.select(karma_table.c.comment_id == comment_id))
        for (_, value, k_time, _, donor_id, _) in a:
            y = vote_table.insert(values={'create_time': k_time,
                                          'poll_id': poll_id,
                                          'user_id': donor_id,
                                          'orientation': value})
            r = migrate_engine.execute(y)

        u = comment_table.update(comment_table.c.id == comment_id, values={
            'poll_id': poll_id
            })
        migrate_engine.execute(u)

    karma_table.drop()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 007_Adopted_flag
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    proposal_table = Table('proposal', meta,
        Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
        Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True),
        Column('adopt_poll_id', Integer, ForeignKey('poll.id'), nullable=True),
        Column('rate_poll_id', Integer, ForeignKey('poll.id'), nullable=True)
        )
    adopted = Column('adopted', Boolean, default=False)
    adopted.create(proposal_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 008_add_tagging
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime)
    )

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

tag_table = Table('tag', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('name', Unicode(255), nullable=False)
    )

tagging_table = Table('tagging', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('tag_id', Integer, ForeignKey('tag.id'), nullable=False),
    Column('delegateable_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    tag_table.create()
    tagging_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 009_Make_final_polling_optional
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    instance_table = Table('instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True)
        )
    allow_adopt = Column('allow_adopt', Boolean, default=True)
    allow_adopt.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 010_Instance_toggles
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    instance_table = Table('instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True),
        Column('allow_adopt', Boolean, default=True)
        )

    allow_delegate = Column('allow_delegate', Boolean, default=True)
    allow_delegate.create(instance_table)
    allow_index = Column('allow_index', Boolean, default=True)
    allow_index.create(instance_table)
    hidden = Column('hidden', Boolean, default=False)
    hidden.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 011_Create_pages
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime)
    )


delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

page_table = Table('page', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True)
    )


text_table = Table('text', meta,
    Column('id', Integer, primary_key=True),
    Column('page_id', Integer, ForeignKey('page.id'), nullable=False),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('parent_id', Integer, ForeignKey('text.id'), nullable=True),
    Column('variant', Unicode(255), nullable=True),
    Column('title', Unicode(255), nullable=True),
    Column('text', UnicodeText(), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    page_table.create()
    text_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 012_Make_comment_wiki_option
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData(migrate_engine)

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime)
    )

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('action', Unicode(50), nullable=False),
    Column('subject', UnicodeText(), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    comment_table = Table('comment', meta,
        Column('id', Integer, primary_key=True),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('delete_time', DateTime, default=None, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
        Column('canonical', Boolean, default=False),
        Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True),
        Column('poll_id', Integer, ForeignKey('poll.id'), nullable=True)
        )
    wiki = Column('wiki', Boolean, default=False)
    wiki.create(comment_table)
    u = comment_table.update(values={
        'wiki': True
        })
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 013_Remove_issues
from datetime import datetime

from sqlalchemy import *
from migrate import *

meta = MetaData()


delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

comment_table = Table('comment', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, default=None, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('canonical', Boolean, default=False),
    Column('wiki', Boolean, default=False),
    Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=True)
    )

issue_table = Table('issue', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True)
    )

category_graph = Table('category_graph', meta,
    Column('parent_id', Integer, ForeignKey('delegateable.id')),
    Column('child_id', Integer, ForeignKey('delegateable.id'))
    )

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('action', Unicode(50), nullable=False),
    Column('subject', UnicodeText(), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    issue_table.drop()
    for vals in migrate_engine.execute(delegateable_table.select()):
        if vals[2] == 'issue':
            migrate_engine.execute(category_graph.delete(category_graph.c.parent_id == vals[0]))
            migrate_engine.execute(category_graph.delete(category_graph.c.child_id == vals[0]))
            migrate_engine.execute(comment_table.delete(comment_table.c.topic_id == vals[0]))
            migrate_engine.execute(poll_table.delete(poll_table.c.scope_id == vals[0]))
            migrate_engine.execute(delegateable_table.delete(delegateable_table.c.id == vals[0]))


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 014_Page_toggles
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    page_table = Table('page', meta,
        Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True)
        )
    has_variants = Column('has_variants', Boolean, default=True)
    has_variants.create(page_table)
    freeze = Column('freeze', Boolean, default=False)
    freeze.create(page_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 015_Page_function_types
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    page_table = Table('page', meta,
        Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
        Column('has_variants', Boolean, default=True),
        Column('freeze', Boolean, default=False)
        )
    page_table.c.has_variants.drop()
    page_table.c.freeze.drop()
    # function = Column('function', Unicode)
    # function.create(page_table)
    # u = page_table.update(values={
    #     'function': 'document'
    #     })
    print "WARNING ---- THERE IS A NON-WORKING MIGRATION PART ---- "
    print "CREATE A NEW function COLUMN ON THE page TABLE "
    # migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 016_Selection_relation
from datetime import datetime

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()

page_table = Table('page', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('part', Unicode)
    )

proposal_table = Table('proposal', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True),
    Column('adopt_poll_id', Integer, ForeignKey('poll.id'), nullable=True),
    Column('rate_poll_id', Integer, ForeignKey('poll.id'), nullable=True),
    Column('adopted', Boolean, default=False)
    )

selection_table = Table('selection', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('page_id', Integer, ForeignKey('page.id'), nullable=False),
    Column('proposal_id', Integer, ForeignKey('proposal.id'), nullable=True)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    selection_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 017_Make_proposal_description_page
from datetime import datetime
from pprint import pprint

from sqlalchemy import *
from migrate import *
import migrate.changeset

import adhocracy.lib.text as text

meta = MetaData()

category_graph = Table('category_graph', meta,
    Column('parent_id', Integer, ForeignKey('delegateable.id')),
    Column('child_id', Integer, ForeignKey('delegateable.id'))
    )

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

poll_table = Table('poll', meta,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('action', Unicode(50), nullable=False),
    Column('subject', UnicodeText(), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False)
    )

comment_table = Table('comment', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, default=None, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('canonical', Boolean, default=False),
    Column('wiki', Boolean, default=False),
    Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=True)
    )

revision_table = Table('revision', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('text', UnicodeText(), nullable=False),
    Column('sentiment', Integer, default=0),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=False)
    )

tally_table = Table('tally', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('vote_id', Integer, ForeignKey('vote.id'), nullable=True),
    Column('num_for', Integer, nullable=True),
    Column('num_against', Integer, nullable=True),
    Column('num_abstain', Integer, nullable=True)
    )

vote_table = Table('vote', meta,
    Column('id', Integer, primary_key=True),
    Column('orientation', Integer, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('delegation_id', Integer, ForeignKey('delegation.id'), nullable=True)
    )

page_table = Table('page', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('part', Unicode)
    )

text_table = Table('text', meta,
    Column('id', Integer, primary_key=True),
    Column('page_id', Integer, ForeignKey('page.id'), nullable=False),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('parent_id', Integer, ForeignKey('text.id'), nullable=True),
    Column('variant', Unicode(255), nullable=True),
    Column('title', Unicode(255), nullable=True),
    Column('text', UnicodeText(), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    proposal_table = Table('proposal', meta,
        Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
        Column('comment_id', Integer, ForeignKey('comment.id'), nullable=True),
        Column('adopt_poll_id', Integer, ForeignKey('poll.id'), nullable=True),
        Column('rate_poll_id', Integer, ForeignKey('poll.id'), nullable=True),
        Column('adopted', Boolean, default=False)
        )

    description = Column('description_id', Integer, nullable=True)  # ForeignKey('page.id'),
    if migrate_engine.url.drivername == "sqlite":
        description = Column('description_id', Integer, nullable=True)
    description.create(proposal_table)

    q1 = migrate_engine.execute(proposal_table.select())
    for (prop_id, comment_id, _, _, _, _) in q1:
        instance_id = None
        label = None
        ctime = None
        dtime = None
        q4 = migrate_engine.execute(delegateable_table.select(' delegateable.id = %d ' % prop_id))
        for (_, _label, _type, _ctime, _dtime, _, _, _instance_id) in q4:
            instance_id = _instance_id
            label = _label
            ctime = _ctime
            dtime = _dtime

        if comment_id is None:
            continue

        q2 = migrate_engine.execute(comment_table.select(' comment.id = %d ' % comment_id))
        for (_, _, _, creator_id, topic_id, _, _, _, poll_id) in q2:
            migrate_engine.execute(vote_table.delete(vote_table.c.poll_id == poll_id))
            migrate_engine.execute(tally_table.delete(tally_table.c.poll_id == poll_id))
            migrate_engine.execute(poll_table.delete(poll_table.c.id == poll_id))

            q3 = delegateable_table.insert(values={'label': text.title2alias(label),
                                          'type': u'page',
                                          'create_time': ctime,
                                          'delete_time': None,
                                          'creator_id': creator_id,
                                          'instance_id': instance_id})
            r = migrate_engine.execute(q3)
            page_id = r.last_inserted_ids()[-1]

            q5 = page_table.insert(values={'id': page_id,
                                           'function': u'description'})
            r = migrate_engine.execute(q5)

            q10 = category_graph.insert(values={'parent_id': page_id,
                                               'child_id': prop_id})
            r = migrate_engine.execute(q10)

            u4 = proposal_table.update(proposal_table.c.id == prop_id, values={
                'description_id': page_id,
                'comment_id': None
                })
            migrate_engine.execute(u4)

            q6 = migrate_engine.execute(revision_table.select(' revision.comment_id = %d ' % comment_id))
            last_id = None
            for (r_id, t_ctime, t_text, _, t_creator_id, _) in q6:
                q7 = text_table.insert(values={'title': label,
                                              'text': t_text,
                                              'create_time': t_ctime,
                                              'delete_time': None,
                                              'user_id': t_creator_id,
                                              'page_id': page_id,
                                              'variant': u'HEAD',
                                              'parent_id': last_id})
                r = migrate_engine.execute(q7)
                last_id = r.last_inserted_ids()[-1]

            def move_comment(data):
                (c_id, c_ctime, c_dtime, c_user_id, c_topic_id, c_can, c_wiki, c_reply_id, c_poll_id) = data

                if c_reply_id == comment_id:
                    u1 = comment_table.update(comment_table.c.id == c_id, values={
                        'reply_id': None
                        })
                    migrate_engine.execute(u1)

                u2 = comment_table.update(comment_table.c.id == c_id, values={
                    'topic_id': page_id
                    })
                migrate_engine.execute(u2)

                u3 = poll_table.update(poll_table.c.id == c_poll_id, values={
                    'scope_id': page_id
                    })
                migrate_engine.execute(u3)
                migrate_engine.execute(tally_table.delete(tally_table.c.poll_id == c_poll_id))

                q8 = migrate_engine.execute(comment_table.select(' comment.reply_id = %d ' % c_id))
                for d in q8:
                    move_comment(d)

            q9 = migrate_engine.execute(comment_table.select(' comment.reply_id = %d ' % comment_id))
            for d in q9:
                move_comment(d)

            migrate_engine.execute(revision_table.delete(revision_table.c.comment_id == comment_id))
            migrate_engine.execute(comment_table.delete(comment_table.c.id == comment_id))

    # proposal_table.c.comment_id.drop()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 018_Comments_on_variants
from datetime import datetime
from pprint import pprint

from sqlalchemy import *
from migrate import *
import migrate.changeset

import adhocracy.lib.text as text

meta = MetaData()


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    comment_table = Table('comment', meta,
        Column('id', Integer, primary_key=True),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('delete_time', DateTime, default=None, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
        Column('canonical', Boolean, default=False),
        Column('wiki', Boolean, default=False),
        Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True),
        Column('poll_id', Integer, ForeignKey('poll.id'), nullable=True)
        )

    variant = Column('variant', Unicode(255), nullable=True)
    variant.create(comment_table)

    u = comment_table.update(values={
        'variant': u'HEAD'
        })
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 019_Instance_locale
from datetime import datetime
from pprint import pprint

from sqlalchemy import *
from migrate import *
import migrate.changeset

import adhocracy.lib.text as text

meta = MetaData()

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime)
    )

group_table = Table('group', meta,
    Column('id', Integer, primary_key=True),
    Column('group_name', Unicode(255), nullable=False, unique=True),
    Column('code', Unicode(255), nullable=False, unique=True),
    Column('description', Unicode(1000))
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    instance_table = Table('instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True),
        Column('allow_adopt', Boolean, default=True),
        Column('allow_delegate', Boolean, default=True),
        Column('allow_index', Boolean, default=True),
        Column('hidden', Boolean, default=False)
        )
    locale = Column('locale', Unicode(7), nullable=True)
    locale.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 020_New_instance_properties
from datetime import datetime
from pprint import pprint

from sqlalchemy import *
from migrate import *
import migrate.changeset

import adhocracy.lib.text as text

meta = MetaData()

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime)
    )

group_table = Table('group', meta,
    Column('id', Integer, primary_key=True),
    Column('group_name', Unicode(255), nullable=False, unique=True),
    Column('code', Unicode(255), nullable=False, unique=True),
    Column('description', Unicode(1000))
    )

delegateable_table = Table('delegateable', meta,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

page_table = Table('page', meta,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('function', Unicode)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    instance_table = Table('instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True),
        Column('allow_adopt', Boolean, default=True),
        Column('allow_delegate', Boolean, default=True),
        Column('allow_index', Boolean, default=True),
        Column('hidden', Boolean, default=False),
        Column('locale', Unicode(7), nullable=True)
        )
    css = Column('css', UnicodeText(), nullable=True)
    css.create(instance_table)
    page_root_id = Column('main_page_id', Integer, nullable=True)
    if migrate_engine.url.drivername == "sqlite":
        page_root_id = Column('main_page_id', Integer, nullable=True)
    page_root_id.create(instance_table)
    norm_root_id = Column('norm_page_id', Integer, nullable=True)
    if migrate_engine.url.drivername == "sqlite":
        norm_root_id = Column('norm_page_id', Integer, nullable=True)
    norm_root_id.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 021_user_settings
from datetime import datetime
from pprint import pprint

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    user_table = Table('user', meta,
        Column('id', Integer, primary_key=True),
        Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
        Column('display_name', Unicode(255), nullable=True, index=True),
        Column('bio', UnicodeText(), nullable=True),
        Column('email', Unicode(255), nullable=True, unique=False),
        Column('email_priority', Integer, default=3),
        Column('activation_code', Unicode(255), nullable=True, unique=False),
        Column('reset_code', Unicode(255), nullable=True, unique=False),
        Column('password', Unicode(80), nullable=False),
        Column('locale', Unicode(7), nullable=True),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
        Column('delete_time', DateTime)
        )
    no_help = Column('no_help', Boolean, default=False, nullable=True)
    no_help.create(user_table)
    page_size = Column('page_size', Integer, default=10, nullable=True)
    page_size.create(user_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 022_titles_for_comments
from datetime import datetime
from pprint import pprint

from sqlalchemy import *
from migrate import *
import migrate.changeset

meta = MetaData()


user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow, onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True)
    )

comment_table = Table('comment', meta,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, default=None, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('canonical', Boolean, default=False),
    Column('wiki', Boolean, default=False),
    Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=True),
    Column('variant', Unicode(255), nullable=True)
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    revision_table = Table('revision', meta,
        Column('id', Integer, primary_key=True),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('text', UnicodeText(), nullable=False),
        Column('sentiment', Integer, default=0),
        Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('comment_id', Integer, ForeignKey('comment.id'), nullable=False)
        )
    title = Column('title', Unicode(255), nullable=True)
    title.create(revision_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 023_instance_norm_deactivation
from datetime import datetime
from pprint import pprint

from sqlalchemy import *
from migrate import *
import migrate.changeset

import adhocracy.lib.text as text

meta = MetaData()

user_table = Table('user', meta)

group_table = Table('group', meta)

delegateable_table = Table('delegateable', meta)

page_table = Table('page', meta)


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    instance_table = Table('instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True),
        Column('allow_adopt', Boolean, default=True),
        Column('allow_delegate', Boolean, default=True),
        Column('allow_index', Boolean, default=True),
        Column('hidden', Boolean, default=False),
        Column('locale', Unicode(7), nullable=True),
        Column('css', UnicodeText(), nullable=True)
        )
    use_norms = Column('use_norms', Boolean, nullable=True, default=True)
    use_norms.create(instance_table)
    u = instance_table.update(values={
        'use_norms': True
        })
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 024_text_gets_wiki_boolean_attr
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText

meta = MetaData()

user_table = Table('user', meta)

group_table = Table('group', meta)

delegateable_table = Table('delegateable', meta)

page_table = Table('page', meta)


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    text_table = Table(
        'text', meta,
        Column('id', Integer, primary_key=True),
        Column('page_id', Integer, ForeignKey('page.id'), nullable=False),
        Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('parent_id', Integer, ForeignKey('text.id'), nullable=True),
        Column('variant', Unicode(255), nullable=True),
        Column('title', Unicode(255), nullable=True),
        Column('text', UnicodeText(), nullable=True),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('delete_time', DateTime)
        )

    wiki = Column('wiki', Boolean, default=False)
    wiki.create(text_table)
    u = text_table.update(values={'wiki': False})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 025_instance_gets_norm_propose_option
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table, Float
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy import func, or_

meta = MetaData()

user_table = Table('user', meta)
group_table = Table('group', meta)


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    instance_table = Table('instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True),
        Column('allow_adopt', Boolean, default=True),
        Column('allow_delegate', Boolean, default=True),
        Column('allow_index', Boolean, default=True),
        Column('hidden', Boolean, default=False),
        Column('locale', Unicode(7), nullable=True),
        Column('css', UnicodeText(), nullable=True),
        Column('use_norms', Boolean, nullable=True, default=True)
    )

    propose = Column('allow_propose', Boolean, default=True)
    propose.create(instance_table)
    u = instance_table.update(values={'allow_propose': True})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 026_users_can_be_banned
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText

meta = MetaData()


group_table = Table('group', meta)


page_table = Table('page', meta)


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    user_table = Table('user', meta,
        Column('id', Integer, primary_key=True),
        Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
        Column('display_name', Unicode(255), nullable=True, index=True),
        Column('bio', UnicodeText(), nullable=True),
        Column('email', Unicode(255), nullable=True, unique=False),
        Column('email_priority', Integer, default=3),
        Column('activation_code', Unicode(255), nullable=True, unique=False),
        Column('reset_code', Unicode(255), nullable=True, unique=False),
        Column('password', Unicode(80), nullable=False),
        Column('locale', Unicode(7), nullable=True),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('access_time', DateTime, default=datetime.utcnow,
               onupdate=datetime.utcnow),
        Column('delete_time', DateTime),
        Column('no_help', Boolean, default=False, nullable=True),
        Column('page_size', Integer, default=10, nullable=True)
        )
    banned = Column('banned', Boolean, default=False)
    banned.create(user_table)
    u = user_table.update(values={'banned': False})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 027_instance_can_be_frozen
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table, Float
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy import func, or_

meta = MetaData()

user_table = Table('user', meta)
group_table = Table('group', meta)


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    instance_table = Table('instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True),
        Column('allow_adopt', Boolean, default=True),
        Column('allow_delegate', Boolean, default=True),
        Column('allow_propose', Boolean, default=True),
        Column('allow_index', Boolean, default=True),
        Column('hidden', Boolean, default=False),
        Column('locale', Unicode(7), nullable=True),
        Column('css', UnicodeText(), nullable=True),
        Column('use_norms', Boolean, nullable=True, default=True)
        )

    frozen = Column('frozen', Boolean, default=False)
    frozen.create(instance_table)
    u = instance_table.update(values={'frozen': False})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 028_milestones
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table, Float
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy import func, or_

meta = MetaData()


def upgrade(migrate_engine):
    meta.bind = migrate_engine

    user_table = Table('user', meta, autoload=True)
    instance_table = Table('instance', meta, autoload=True)
    delegateable_table = Table('delegateable', meta, autoload=True)

    milestone_table = Table('milestone', meta,
        Column('id', Integer, primary_key=True),
        Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('title', Unicode(255), nullable=True),
        Column('text', UnicodeText(), nullable=True),
        Column('time', DateTime),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('delete_time', DateTime)
        )
    milestone_table.create()
    ms_col = Column('milestone_id', Integer, ForeignKey('milestone.id'), nullable=True)
    ms_col.create(delegateable_table)

    ms_bool = Column('milestones', Boolean, default=False)
    ms_bool.create(instance_table)
    u = instance_table.update(values={'milestones': False})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 029_add_user_badges
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import DateTime, Integer, Unicode

metadata = MetaData()


badge_table = Table('badge', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('group', Integer, ForeignKey('group.id', ondelete="CASCADE")))


user_badges_table = Table('user_badges', metadata,
    Column('id', Integer, primary_key=True),
    Column('badge_id', Integer, ForeignKey('badge.id'),
           nullable=False),
    Column('user_id', Integer, ForeignKey('user.id'),
           nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False))


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    group_table = Table('group', metadata, autoload=True)
    user_table = Table('user', metadata, autoload=True)
    badge_table.create()
    user_badges_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 030_change_and_extend_badges
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode

metadata = MetaData()

badge_table = Table(
    'badge', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('group', Integer, ForeignKey('group.id', ondelete="CASCADE")))


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    group_table = Table('group', metadata, autoload=True)
    user_table = Table('user', metadata, autoload=True)

    # nullable=False does not work with sqlite even with default=...
    # and .create(populate_default=True). Alter with nullable=True
    # and change afterwards.
    description = Column('description', Unicode(255), default=u'',
                         nullable=True)
    description.create(badge_table, populate_default=True)
    description.alter(nullable=False)

    group_id = Column('group_id', Integer,
                      ForeignKey('group.id', ondelete="CASCADE"))
    group_id.create(badge_table)

    display_group = Column('display_group', Boolean, default=False)
    display_group.create(badge_table)

    q = migrate_engine.execute(badge_table.select())
    for (id, _, _, _, group_id, _, _, _) in q:
        update_statement = badge_table.update(
            badge_table.c.id == id,
            {'group_id': group_id,
             'description': '',
             'display_group': True})
        migrate_engine.execute(update_statement)

    badge_table.c.group.drop()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 031_add_delegatable_badges
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode

metadata = MetaData()

badge_table = Table(
    'badge', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    # Column('badge_delegateable', Boolean, default=False)
    )

delegateable_badge_table = Table(
    'delegateable_badges', metadata,
    Column('id', Integer, primary_key=True),
    Column('badge_id', Integer, ForeignKey('badge.id'),
           nullable=False),
    Column('delegateable_id', Integer, ForeignKey('delegateable.id'),
           nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False))


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    # setup
    group_table = Table('group', metadata, autoload=True)
    user_table = Table('user', metadata, autoload=True)
    proposal_table = Table('proposal', metadata, autoload=True)
    delegateable_table = Table('delegateable', metadata, autoload=True)

    # add column badge_delegateable to badge_table
    badge_delegateable = Column('badge_delegateable', Boolean, default=False)
    badge_delegateable.create(badge_table)

    # add new table delegateable_badge
    delegateable_badge_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 032_remove_comment_title
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import DateTime, Integer, Unicode, UnicodeText

metadata = MetaData()

old_revision_table = Table('revision', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('text', UnicodeText(), nullable=False),
    Column('sentiment', Integer, default=0),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=False),
    Column('title', Unicode(255), nullable=True)
    )


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    revisions_table = Table('revision', metadata, autoload=True)

    q = migrate_engine.execute(revisions_table.select())
    for (id, _, text, _, _, _, title) in q:
        title = title and title.strip() or ''
        if len(title) < 5:
            continue
        if title.startswith('Re: '):
            continue
        new_text = ('**%(title)s**\n'
                    '\n'
                    '%(text)s') % {'title': title,
                                   'text': text}
        update_statement = revisions_table.update(
            revisions_table.c.id == id, {'text': new_text})
        migrate_engine.execute(update_statement)

    revisions_table.c.title.drop()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 033_require_selection
from sqlalchemy import (MetaData, Boolean, Column, Float, ForeignKey, func,
                        DateTime, Integer, Table, Unicode, UnicodeText)

metadata = MetaData()

old_instance_table = Table('instance', metadata,
    Column('id', Integer, primary_key=True),
    Column('key', Unicode(20), nullable=False, unique=True),
    Column('label', Unicode(255), nullable=False),
    Column('description', UnicodeText(), nullable=True),
    Column('required_majority', Float, nullable=False),
    Column('activation_delay', Integer, nullable=False),
    Column('create_time', DateTime, default=func.now()),
    Column('access_time', DateTime, default=func.now(), onupdate=func.now()),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('default_group_id', Integer, ForeignKey('group.id'), nullable=True),
    Column('allow_adopt', Boolean, default=True),
    Column('allow_delegate', Boolean, default=True),
    Column('allow_propose', Boolean, default=True),
    Column('allow_index', Boolean, default=True),
    Column('hidden', Boolean, default=False),
    Column('locale', Unicode(7), nullable=True),
    Column('css', UnicodeText(), nullable=True),
    Column('frozen', Boolean, default=False),
    Column('milestones', Boolean, default=False),
    Column('use_norms', Boolean, nullable=True, default=True),
    )


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    new_column = Column('require_selection', Boolean, nullable=True,
                        default=False)
    new_column.create(old_instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 034_add_instance_delegatable_badges
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode

metadata = MetaData()

badge_table = Table(
    'badge', metadata,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    # badges for groups/users
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    # badges for delegateables
    Column('badge_delegateable', Boolean, default=False),
    # badges only for delegateables inside an instance (aka "category")
    # Column('badge_delegateable_category', Boolean, default=False),
    # Column('instance_id', Integer, ForeignKey('instance.id'), nullable=True))
    )


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    # setup
    group_table = Table('group', metadata, autoload=True)
    user_table = Table('user', metadata, autoload=True)
    proposal_table = Table('proposal', metadata, autoload=True)
    intance_table = Table('instance', metadata, autoload=True)

    # add new columns to badge_table
    badge_instance_delegateable = Column('badge_delegateable_category', Boolean, default=False)
    badge_instance_delegateable.create(badge_table)
    badge_instance_id = Column('instance_id', Integer, ForeignKey('instance.id'), nullable=True)
    badge_instance_id.create(badge_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 035_proposal_variant_relation_add_column
from datetime import datetime

from sqlalchemy import (MetaData, Column, ForeignKey, DateTime, Integer,
                        PickleType, Table)

metadata = MetaData()


selection_table = Table(
    'selection', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('page_id', Integer, ForeignKey('page.id',
           name='selection_page', use_alter=True), nullable=True),
    Column('proposal_id', Integer, ForeignKey('proposal.id',
           name='selection_proposal', use_alter=True), nullable=True),
    )


def are_elements_equal(x, y):
    return x == y


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    page_table = Table('page', metadata, autoload=True)
    proposal_table = Table('proposal', metadata, autoload=True)
    # delegateable_table = Table('delegateable', metadata, autoload=True)

    new_column = Column('variants', PickleType(comparator=are_elements_equal),
                        nullable=True)

    new_column.create(selection_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 036_proposal_variant_relation_migrate_values
from datetime import datetime
from logging import getLogger
from pickle import dumps, loads
import re

from sqlalchemy import (MetaData, Column, ForeignKey, DateTime, Integer,
                        PickleType, String, Table, Unicode)

metadata = MetaData()

log = getLogger(__name__)


def are_elements_equal(x, y):
    return x == y


new_selection_table = Table(
    'selection', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('page_id', Integer, ForeignKey('page.id',
           name='selection_page', use_alter=True), nullable=True),
    Column('proposal_id', Integer, ForeignKey('proposal.id',
           name='selection_proposal', use_alter=True), nullable=True),
    Column('variants', PickleType(comparator=are_elements_equal),
           nullable=True)
    )


page_table = Table('page', metadata,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('function', Unicode(20))
    )


poll_table = Table('poll', metadata,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('action', Unicode(50), nullable=False),
    Column('subject', Unicode(254), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False)
    )

category_graph = Table('category_graph', metadata,
    Column('parent_id', Integer, ForeignKey('delegateable.id')),
    Column('child_id', Integer, ForeignKey('delegateable.id'))
    )


delegateable_table = Table('delegateable', metadata,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('milestone_id', Integer, ForeignKey('milestone.id'), nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False)
    )

tally_table = Table('tally', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('vote_id', Integer, ForeignKey('vote.id'), nullable=True),
    Column('num_for', Integer, nullable=True),
    Column('num_against', Integer, nullable=True),
    Column('num_abstain', Integer, nullable=True)
    )


now = datetime.utcnow()

SEL_RE = re.compile('\[@\[selection:([^\]]*)\],"([^"]*)"\]')


def get_tally_count(migrate_engine, poll_id):
    tallies = migrate_engine.execute(
        tally_table.select('poll_id = %s' % poll_id)).fetchall()
    tallies = sorted(tallies)
    last = tallies[-1]
    (_, _, _, _, num_for, num_against, _) = last
    tally_count = num_for + num_against
    return tally_count


def collect_selection_data(selections):
    to_proposal = {}
    to_variants = {}
    for (sid, create_time, delete_time, page_id, proposal_id,
         variants) in selections:
        if delete_time is not None and delete_time < now:
            pass
        to_proposal[sid] = proposal_id
        to_variants[sid] = loads(variants)
    return to_proposal, to_variants


def collect_poll_data(migrate_engine, polls, selection_to_proposal):
    proposal_ids = []
    variant_to_selection = {}
    for (poll_id, _, end_time, _, action, subject, scope_id) in polls:
        if action != u'select':
            continue
        if end_time is not None and end_time < now:
            continue
        match = SEL_RE.match(subject)
        selection_id = int(match.group(1))
        variant = match.group(2)
        if variant == u'HEAD':
            # we handle HEAD speacially. Every Proposal has access to
            # HEAD.
            continue
        var_selections = variant_to_selection.setdefault(variant, [])
        tally_count = get_tally_count(migrate_engine, poll_id)
        var_selections.append([tally_count, selection_id, poll_id])
        try:
            proposal_ids.append(selection_to_proposal[selection_id])
        except Exception, E:
            pass
    return proposal_ids, variant_to_selection


def handle_page(migrate_engine, page_id, selections_, polls):

    (selection_to_proposal,
     selections_to_variants) = collect_selection_data(selections_)

    (proposal_ids,
     variant_to_selection) = collect_poll_data(migrate_engine, polls,
                                               selection_to_proposal)

    # if we have proposals select a winning proposal and assign
    # the variant to it

    if not len(set(proposal_ids)):
        # no proposals
        return

    for variant, tally_selections in variant_to_selection.items():
        tally_selections = sorted(tally_selections)
        count, winning_selection, poll_id = tally_selections[-1]
        try:
            selections_to_variants[winning_selection].append(variant)
            migrate_engine.execute(
                new_selection_table.update().values(
                    variants=dumps(selections_to_variants[winning_selection]))
                .where(new_selection_table.c.id == winning_selection))
        except KeyError, E:
            msg = (
                'KeyError: %s\n' % E +
                'There is no selection with the id %s \n' % E +
                'which should be the winner for ' +
                'page %s - variant %s' % (page_id, variant))
            log.error(msg)


def add_default_variant(migrate_engine):
    default_variants = [u'HEAD']
    default_variants_pickle = dumps(default_variants)
    migrate_engine.execute(
        new_selection_table.update().values(variants=default_variants_pickle))


def upgrade(migrate_engine):

    metadata.bind = migrate_engine
    page_table = Table('page', metadata, autoload=True)
    proposal_table = Table('proposal', metadata, autoload=True)

    add_default_variant(migrate_engine)

    pages = migrate_engine.execute(page_table.select())
    for (page_id, function) in pages:
        if function != u'norm':
            continue
        selections = migrate_engine.execute(
            new_selection_table.select('page_id = %s' % page_id)).fetchall()
        polls = migrate_engine.execute(
            poll_table.select('scope_id = %s' % page_id)).fetchall()
        handle_page(migrate_engine, page_id, selections, polls)

    return


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 037_proposal_variants_fix_pickle
'''
Fix an error in the previous migration where wie pickled the versions
into a string that was pickled again by sqlalchemy.
'''
from datetime import datetime
from pickle import loads

from sqlalchemy import (MetaData, Column, ForeignKey, DateTime, Integer,
                        PickleType, Table)

metadata = MetaData()


def are_elements_equal(x, y):
    return x == y


selection_table = Table(
    'selection', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('page_id', Integer, ForeignKey('page.id',
           name='selection_page', use_alter=True), nullable=True),
    Column('proposal_id', Integer, ForeignKey('proposal.id',
           name='selection_proposal', use_alter=True), nullable=True),
    Column('variants', PickleType(comparator=are_elements_equal),
           nullable=True)
    )


def upgrade(migrate_engine):

    metadata.bind = migrate_engine

    selections = migrate_engine.execute(selection_table.select())
    fixed = 0
    for (id, _, _, _, _, variants) in selections:
        try:
            # see if we can unpickle from the variants value
            variants = loads(variants)
        except TypeError:
            continue

        if not isinstance(variants, list):
            raise ValueError(
                ("Already fixed: %s. Error in selection %s. 'variants' is "
                 'double pickled, but not a list. Value: %s, type: %s') %
                (id, str(variants), type(variants)))
        fixed += 1
        migrate_engine.execute(
            selection_table.update().values(variants=variants).where(
                selection_table.c.id == id))


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 038_inheritance_for_badges
'''
Migragte badges to use different models with shared table inheritance
instead of hand made queries.
'''
from datetime import datetime

from sqlalchemy import (MetaData, Boolean, Column, ForeignKey, DateTime,
                        Integer, String, Table, Unicode)

metadata = MetaData()


def are_elements_equal(x, y):
    return x == y


badge_table = Table(
    'badge', metadata,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    # badges for groups/users
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    # badges for delegateables
    Column('badge_delegateable', Boolean, default=False),
    # badges to make categories for delegateables
    Column('badge_delegateable_category', Boolean, default=False),
    # badges only valid inside an specific instance
    Column('instance_id', Integer, ForeignKey('instance.id',
                                        ondelete="CASCADE",), nullable=True))


USER_BADGE = 'user'
DELEGATEABLE_BADGE = 'delegateable'
CATEGORY_BADGE = 'category'


def upgrade(migrate_engine):

    metadata.bind = migrate_engine

    # dummy definitions to satisfy foreign keys
    Table('instance', metadata, autoload=True)
    Table('group', metadata, autoload=True)

    # add the column for the polymorphic identity
    # we have to use 'nullable=True' cause the values are
    # null when the column is created
    type_col = Column('type', String(40), nullable=True)
    type_col.create(badge_table)

    # fill column with the right values
    select = badge_table.select().with_only_columns(
        ['id', 'title', 'badge_delegateable', 'badge_delegateable_category'])
    badges_query_result = migrate_engine.execute(select)
    for values in badges_query_result:
        (id_, title, delegateable, category) = values
        if category:
            type_ = CATEGORY_BADGE
        elif delegateable:
            type_ = DELEGATEABLE_BADGE
        else:
            type_ = USER_BADGE
        update = badge_table.update().values(type=type_).where(
            badge_table.c.id == id_)
        migrate_engine.execute(update)

    # drop the old columns
    badge_table.c.badge_delegateable.drop()
    badge_table.c.badge_delegateable_category.drop()

    type_col.alter(nullable=False)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 039_milestones_reference_categories
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table
from sqlalchemy import DateTime, Integer, Unicode, UnicodeText


meta = MetaData()

milestone_table = Table(
    'milestone', meta,
    Column('id', Integer, primary_key=True),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('title', Unicode(255), nullable=True),
    Column('text', UnicodeText(), nullable=True),
    Column('time', DateTime),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime)
)


def upgrade(migrate_engine):
    meta.bind = migrate_engine

    Table('user', meta, autoload=True)
    Table('instance', meta, autoload=True)
    Table('badge', meta, autoload=True)
    category_column = Column('category_id', Integer, ForeignKey('badge.id'),
                             nullable=True)
    category_column.create(milestone_table)
    modify_time_column = Column('modify_time', DateTime, nullable=True,
                           onupdate=datetime.utcnow)
    modify_time_column.create(milestone_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 040_authenticated_instances
from sqlalchemy import Column, ForeignKey, MetaData, Table, Float
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy import func

meta = MetaData()

user_table = Table('user', meta)
group_table = Table('group', meta)


def upgrade(migrate_engine):
    meta.bind = migrate_engine

    instance_table = Table(
        'instance', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(20), nullable=False, unique=True),
        Column('label', Unicode(255), nullable=False),
        Column('description', UnicodeText(), nullable=True),
        Column('required_majority', Float, nullable=False),
        Column('activation_delay', Integer, nullable=False),
        Column('create_time', DateTime, default=func.now()),
        Column('access_time', DateTime, default=func.now(),
               onupdate=func.now()),
        Column('delete_time', DateTime, nullable=True),
        Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('default_group_id', Integer, ForeignKey('group.id'),
               nullable=True),
        Column('allow_adopt', Boolean, default=True),
        Column('allow_delegate', Boolean, default=True),
        Column('allow_propose', Boolean, default=True),
        Column('allow_index', Boolean, default=True),
        Column('hidden', Boolean, default=False),
        Column('locale', Unicode(7), nullable=True),
        Column('css', UnicodeText(), nullable=True),
        Column('frozen', Boolean, default=False),
        Column('milestones', Boolean, default=False),
        Column('use_norms', Boolean, nullable=True, default=True),
        Column('require_selection', Boolean, nullable=True, default=False),
    )

    is_authenticated_column = Column('is_authenticated', Boolean,
                                     nullable=True, default=False)

    is_authenticated_column.create(instance_table)
    u = instance_table.update(values={'is_authenticated': False})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 041_add_instance_badges
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, String

metadata = MetaData()


badge_table = Table(
    'badge', metadata,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('type', String(40), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id',
                                              ondelete="CASCADE",),
           nullable=True),
    # attributes for UserBadges
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False))

instance_badges_table = Table(
    'instance_badges', metadata,
    Column('id', Integer, primary_key=True),
    Column('badge_id', Integer, ForeignKey('badge.id'),
           nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'),
           nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False))


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    # setup
    group_table = Table('group', metadata, autoload=True)
    user_table = Table('user', metadata, autoload=True)
    instance_table = Table('instance', metadata, autoload=True)

    # add new table instance_badge
    instance_badges_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 042_instance_hide_global_categories
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table, Float
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy import func, or_

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    instance_table = Table('instance', metadata,
          Column('id', Integer, primary_key=True),
          Column('key', Unicode(20), nullable=False, unique=True),
          Column('label', Unicode(255), nullable=False),
          Column('description', UnicodeText(), nullable=True),
          Column('required_majority', Float, nullable=False),
          Column('activation_delay', Integer, nullable=False),
          Column('create_time', DateTime, default=func.now()),
          Column('access_time', DateTime, default=func.now(),
                 onupdate=func.now()),
          Column('delete_time', DateTime, nullable=True),
          Column('creator_id', Integer, ForeignKey('user.id'),
                 nullable=False),
          Column('default_group_id', Integer, ForeignKey('group.id'),
                 nullable=True),
          Column('allow_adopt', Boolean, default=True),
          Column('allow_delegate', Boolean, default=True),
          Column('allow_propose', Boolean, default=True),
          Column('allow_index', Boolean, default=True),
          Column('hidden', Boolean, default=False),
          Column('locale', Unicode(7), nullable=True),
          Column('css', UnicodeText(), nullable=True),
          Column('frozen', Boolean, default=False),
          Column('milestones', Boolean, default=False),
          Column('use_norms', Boolean, nullable=True, default=True),
          Column('require_selection', Boolean, nullable=True, default=False),
          Column('is_authenticated', Boolean, nullable=True, default=False),
          )

    hide_categories = Column('hide_global_categories',
                             Boolean,
                             nullable=True,
                             default=False)
    hide_categories.create(instance_table)
    u = instance_table.update(values={'hide_global_categories': False})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 043_instance_editable_comments_default
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table, Float
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy import func, or_

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    instance_table = Table('instance', metadata,
          Column('id', Integer, primary_key=True),
          Column('key', Unicode(20), nullable=False, unique=True),
          Column('label', Unicode(255), nullable=False),
          Column('description', UnicodeText(), nullable=True),
          Column('required_majority', Float, nullable=False),
          Column('activation_delay', Integer, nullable=False),
          Column('create_time', DateTime, default=func.now()),
          Column('access_time', DateTime, default=func.now(),
                 onupdate=func.now()),
          Column('delete_time', DateTime, nullable=True),
          Column('creator_id', Integer, ForeignKey('user.id'),
                 nullable=False),
          Column('default_group_id', Integer, ForeignKey('group.id'),
                 nullable=True),
          Column('allow_adopt', Boolean, default=True),
          Column('allow_delegate', Boolean, default=True),
          Column('allow_propose', Boolean, default=True),
          Column('allow_index', Boolean, default=True),
          Column('hidden', Boolean, default=False),
          Column('locale', Unicode(7), nullable=True),
          Column('css', UnicodeText(), nullable=True),
          Column('frozen', Boolean, default=False),
          Column('milestones', Boolean, default=False),
          Column('use_norms', Boolean, nullable=True, default=True),
          Column('require_selection', Boolean, nullable=True, default=False),
          Column('is_authenticated', Boolean, nullable=True, default=False),
          Column('hide_global_categories', Boolean, nullable=True, default=False)
          )

    editable_comments = Column('editable_comments_default',
                               Boolean,
                               nullable=True,
                               default=True)
    editable_comments.create(instance_table)
    u = instance_table.update(values={'editable_comments_default': True})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 044_invisible_badges
from datetime import datetime

from sqlalchemy import MetaData
from sqlalchemy import Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, String

metadata = MetaData()

badge_table = Table(
    'badge', metadata,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('type', String(40), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id',
                                              ondelete="CASCADE",),
           nullable=True),
    # attributes for UserBadges
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    # Column('visible', Boolean, default=True))
    )


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    badge_state = Column('visible', Boolean, default=True)
    badge_state.create(badge_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 045_default_sorting_order
from datetime import datetime

from sqlalchemy import MetaData
from sqlalchemy import Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, String, UnicodeText

metadata = MetaData()

user_table = Table('user', metadata,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True)
    )


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    user_state = Column('proposal_sort_order', Unicode(50), default=None, nullable=True)
    user_state.create(user_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 046_fix_text_parent_child_column_naming
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText

metadata = MetaData()

user_table = Table('user', metadata,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True),
    Column('proposal_sort_order', Unicode(50), default=None, nullable=True)
    )

page_table = Table('page', metadata,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('function', Unicode(20))
    )


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    text_table = Table('text', metadata,
        Column('id', Integer, primary_key=True),
        Column('page_id', Integer, ForeignKey('page.id'), nullable=False),
        Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('parent_id', Integer, ForeignKey('text.id'), nullable=True),
        Column('variant', Unicode(255), nullable=True),
        Column('title', Unicode(255), nullable=True),
        Column('text', UnicodeText(), nullable=True),
        Column('wiki', Boolean, default=False),
        Column('create_time', DateTime, default=datetime.utcnow),
        Column('delete_time', DateTime)
        )

    text_table.c.parent_id.alter(name='child_id')


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 047_add_gender_column
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, String, UnicodeText

meta = MetaData()

user_table = Table('user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True),
    Column('proposal_sort_order', Unicode(50), default=None, nullable=True),
    )


def upgrade(migrate_engine):
    meta.bind = migrate_engine

    gender = Column('gender', Unicode(1), default=None)
    gender.create(user_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 048_add_requestlog_table
from datetime import datetime

from sqlalchemy import MetaData, Column, Table
from sqlalchemy import DateTime, Integer, Unicode, UnicodeText

meta = MetaData()

requestlog_table = Table('requestlog', meta,
    Column('id', Integer, primary_key=True),
    Column('access_time', DateTime, default=datetime.utcnow),
    Column('ip_address', Unicode(255), nullable=True),
    Column('request_url', UnicodeText()),
    Column('cookies', UnicodeText(), nullable=True),
    Column('user_agent', UnicodeText(), nullable=True),
)


def upgrade(migrate_engine):
    meta.bind = migrate_engine
    requestlog_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 049_requestlog_referer
from datetime import datetime

from sqlalchemy import MetaData, Column, Table
from sqlalchemy import DateTime, Integer, Unicode, UnicodeText

meta = MetaData()

requestlog_table = Table('requestlog', meta,
    Column('id', Integer, primary_key=True),
    Column('access_time', DateTime, default=datetime.utcnow),
    Column('ip_address', Unicode(255), nullable=True),
    Column('request_url', UnicodeText()),
    Column('cookies', UnicodeText(), nullable=True),
    Column('user_agent', UnicodeText(), nullable=True),
)


def upgrade(migrate_engine):
    meta.bind = migrate_engine

    requestlog = Column('referer', UnicodeText(), nullable=True)
    requestlog.create(requestlog_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 050_instance_require_valid_email
from sqlalchemy import Column, ForeignKey, MetaData, Table, Float
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy import func


metadata = MetaData()

instance_table = Table(
    'instance', metadata,
    Column('id', Integer, primary_key=True),
    Column('key', Unicode(20), nullable=False, unique=True),
    Column('label', Unicode(255), nullable=False),
    Column('description', UnicodeText(), nullable=True),
    Column('required_majority', Float, nullable=False),
    Column('activation_delay', Integer, nullable=False),
    Column('create_time', DateTime, default=func.now()),
    Column('access_time', DateTime, default=func.now(),
           onupdate=func.now()),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'),
           nullable=False),
    Column('default_group_id', Integer, ForeignKey('group.id'),
           nullable=True),
    Column('allow_adopt', Boolean, default=True),
    Column('allow_delegate', Boolean, default=True),
    Column('allow_propose', Boolean, default=True),
    Column('allow_index', Boolean, default=True),
    Column('hidden', Boolean, default=False),
    Column('locale', Unicode(7), nullable=True),
    Column('css', UnicodeText(), nullable=True),
    Column('frozen', Boolean, default=False),
    Column('milestones', Boolean, default=False),
    Column('use_norms', Boolean, nullable=True, default=True),
    Column('require_selection', Boolean, nullable=True, default=False),
    Column('is_authenticated', Boolean, nullable=True, default=False),
    Column('hide_global_categories', Boolean, nullable=True, default=False),
    Column('editable_comments_default', Boolean, nullable=True, default=True),
)


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    require_valid_email = Column('require_valid_email',
                                 Boolean,
                                 nullable=True,
                                 default=True)
    require_valid_email.create(instance_table)
    u = instance_table.update(values={'require_valid_email': True})
    migrate_engine.execute(u)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 051_add_page_formatting_option
from sqlalchemy import MetaData
from sqlalchemy import Column, ForeignKey, Table
from sqlalchemy import Boolean, Integer, Unicode

metadata = MetaData()


page_table = Table(
    'page', metadata,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('function', Unicode(20)),
)


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    page_formatting = Column('formatting', Boolean, default=False)
    page_formatting.create(page_table)

    from adhocracy.model import Page
    update = page_table.update().values(formatting=True).where(
        page_table.c.function == Page.DESCRIPTION)
    migrate_engine.execute(update)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 052_unique_email
from migrate.changeset.constraint import UniqueConstraint

from datetime import datetime

from sqlalchemy import MetaData
from sqlalchemy import Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, String, UnicodeText

metadata = MetaData()

user_table = Table('user', metadata,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=False),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True),
    Column('gender', Unicode(1), default=None),
    Column('proposal_sort_order', Unicode(50), default=None, nullable=True),
    )


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    cons = UniqueConstraint('email', table=user_table)
    cons.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 053_add_newsservice
from datetime import datetime

from sqlalchemy import MetaData, Column, ForeignKey, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText

metadata = MetaData()

message_table = Table(
    'message', metadata,
    Column('id', Integer, primary_key=True),
    Column('subject', Unicode(140), nullable=False),
    Column('body', UnicodeText(), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('sender_email', Unicode(255), nullable=False),
)

message_recipient_table = Table(
    'message_recipient', metadata,
    Column('id', Integer, primary_key=True),
    Column('message_id', Integer, ForeignKey('message.id'), nullable=False),
    Column('recipient_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('email_sent', Boolean, default=False),
)

user_table = Table(
    'user', metadata,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=True),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True),
    Column('proposal_sort_order', Unicode(50), default=None, nullable=True),
    Column('gender', Unicode(1), default=None),
)


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    message_table.create()
    message_recipient_table.create()

    email_messages = Column('email_messages', Boolean, default=True)
    email_messages.create(user_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 054_add_hierachical_categorybadges
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table
from sqlalchemy import Boolean, Integer, DateTime, String, Unicode, LargeBinary

metadata = MetaData()

# table to update
badge_table = Table(
    'badge', metadata,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('type', String(40), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id',
                                              ondelete="CASCADE",),
           nullable=True),
    # attributes for UserBadges
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    Column('visible', Boolean, default=True),
)


def upgrade(migrate_engine):
    # use sqlalchemy-migrate database connection
    metadata.bind = migrate_engine
    # autoload needed tables
    instance_table = Table('instance', metadata, autoload=True)
    # add hierachical columns to the table
    select_child_desc = Column('select_child_description', Unicode(255), default=u'', nullable=True)
    parent = Column('parent_id', Integer, ForeignKey('badge.id', ondelete="CASCADE"),
                    nullable=True)
    # create/recreate the table
    select_child_desc.create(badge_table)
    select_child_desc.alter(nullable=False)
    parent.create(badge_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 055_add_votedetail_table
from datetime import datetime
from sqlalchemy import MetaData, Column, Table, ForeignKey, func
from sqlalchemy import (Boolean, DateTime, Float, Integer, String, Unicode,
                        UnicodeText)

metadata = MetaData()

instance_table = Table(
    'instance', metadata,
    Column('id', Integer, primary_key=True),
    Column('key', Unicode(20), nullable=False, unique=True),
    Column('label', Unicode(255), nullable=False),
    Column('description', UnicodeText(), nullable=True),
    Column('required_majority', Float, nullable=False),
    Column('activation_delay', Integer, nullable=False),
    Column('create_time', DateTime, default=func.now()),
    Column('access_time', DateTime, default=func.now(),
           onupdate=func.now()),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'),
           nullable=False),
    Column('default_group_id', Integer, ForeignKey('group.id'),
           nullable=True),
    Column('allow_adopt', Boolean, default=True),
    Column('allow_delegate', Boolean, default=True),
    Column('allow_propose', Boolean, default=True),
    Column('allow_index', Boolean, default=True),
    Column('hidden', Boolean, default=False),
    Column('locale', Unicode(7), nullable=True),
    Column('css', UnicodeText(), nullable=True),
    Column('frozen', Boolean, default=False),
    Column('milestones', Boolean, default=False),
    Column('use_norms', Boolean, nullable=True, default=True),
    Column('require_selection', Boolean, nullable=True, default=False),
    Column('is_authenticated', Boolean, nullable=True, default=False),
    Column('hide_global_categories', Boolean, nullable=True, default=False),
    Column('editable_comments_default', Boolean, nullable=True, default=True),
    Column('require_valid_email', Boolean, nullable=True, default=True),
)

badge_table = Table(
    'badge', metadata,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('type', String(40), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id',
                                              ondelete="CASCADE",),
           nullable=True),
    # attributes for hierarchical badges (CategoryBadges)
    Column('select_child_description', Unicode(255), default=u'',
           nullable=False),
    Column('parent_id', Integer, ForeignKey('badge.id', ondelete="CASCADE"),
           nullable=True),
    # attributes for UserBadges
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    Column('visible', Boolean, default=True),
)

votedetail_table = Table(
    'votedetail', metadata,
    Column('instance_id', Integer,
           ForeignKey('instance.id', ondelete='CASCADE')),
    Column('badge_id', Integer,
           ForeignKey('badge.id', ondelete='CASCADE')),
)


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    votedetail_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 056_add_staticpage_table
from sqlalchemy import MetaData, Column, Table
from sqlalchemy import Unicode, UnicodeText

metadata = MetaData()

staticpage_table = Table(
    'staticpage', metadata,
    Column('key', Unicode(256), primary_key=True),
    Column('lang', Unicode(7), primary_key=True),
    Column('title', UnicodeText(), nullable=True),
    Column('body', UnicodeText()),
)


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    staticpage_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 057_add_welcome_code
from datetime import datetime

from sqlalchemy import MetaData, Column, Table
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText

meta = MetaData()

user_table = Table(
    'user', meta,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=True),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=False),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True),
    Column('proposal_sort_order', Unicode(50), default=None, nullable=True),
    Column('gender', Unicode(1), default=None),
    Column('email_messages', Boolean, default=True),
)


def upgrade(migrate_engine):
    meta.bind = migrate_engine

    col = Column('welcome_code', Unicode(255), nullable=True)
    col.create(user_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 058_make_password_nullable
from sqlalchemy import MetaData, Table


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    user_table = Table('user', meta, autoload=True)
    user_table.c.password.alter(nullable=True)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 059_add_thumbnail_badges
from datetime import datetime
from sqlalchemy import Column, ForeignKey, MetaData, Table
from sqlalchemy import (Boolean, Integer, DateTime, String, Unicode,
                        LargeBinary)

metadata = MetaData()

# table to update
badge_table = Table(
    'badge', metadata,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('type', String(40), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id',
                                              ondelete="CASCADE",),
           nullable=True),
    # attributes for UserBadges
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    Column('visible', Boolean, default=True),
    extend_existing=True
)


def upgrade(migrate_engine):
    # use sqlalchemy-migrate database connection
    metadata.bind = migrate_engine
    # autoload needed tables
    instance_table = Table('instance', metadata, autoload=True)
    # add thumbnail column to table
    thumbnail = Column('thumbnail', LargeBinary, default=None, nullable=True)
    # create/recreate the table
    thumbnail.create(badge_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 060_add_thumbnailbadge_settings_to_instance
from sqlalchemy import Column, ForeignKey, MetaData, Table, func
from sqlalchemy import Boolean, Integer, DateTime, Unicode,\
    UnicodeText, Float

metadata = MetaData()

# table to update
instance_table = \
    Table('instance', metadata,
          Column('id', Integer, primary_key=True),
          Column('key', Unicode(20), nullable=False, unique=True),
          Column('label', Unicode(255), nullable=False),
          Column('description', UnicodeText(), nullable=True),
          Column('required_majority', Float, nullable=False),
          Column('activation_delay', Integer, nullable=False),
          Column('create_time', DateTime, default=func.now()),
          Column('access_time', DateTime, default=func.now(),
                 onupdate=func.now()),
          Column('delete_time', DateTime, nullable=True),
          Column('creator_id', Integer, ForeignKey('user.id'),
                 nullable=False),
          Column('default_group_id', Integer, ForeignKey('group.id'),
                 nullable=True),
          Column('allow_adopt', Boolean, default=True),
          Column('allow_delegate', Boolean, default=True),
          Column('allow_propose', Boolean, default=True),
          Column('allow_index', Boolean, default=True),
          Column('hidden', Boolean, default=False),
          Column('locale', Unicode(7), nullable=True),
          Column('css', UnicodeText(), nullable=True),
          Column('frozen', Boolean, default=False),
          Column('milestones', Boolean, default=False),
          Column('use_norms', Boolean, nullable=True, default=True),
          Column('require_selection', Boolean, nullable=True, default=False),
          Column('is_authenticated', Boolean, nullable=True, default=False),
          Column('hide_global_categories', Boolean, nullable=True,
                 default=False),
          Column('editable_comments_default', Boolean, nullable=True,
                 default=True)
          )


def upgrade(migrate_engine):
    # use sqlalchemy-migrate database connection
    metadata.bind = migrate_engine
    # autoload needed tables
    user = Table('user', metadata, autoload=True)
    group = Table('group', metadata, autoload=True)
    # add thumbnailbage settings to the instance table
    allow = Column('allow_thumbnailbadges', Boolean, default=False)
    height = Column('thumbnailbadges_height', Integer, nullable=True)
    width = Column('thumbnailbadges_width', Integer, nullable=True)
    # create/recreate the table
    allow.create(instance_table)
    height.create(instance_table)
    width.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 061_optional_massmessage_footer
from sqlalchemy import MetaData, Table, Boolean, Column

from sqlalchemy import Integer


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    message_table = Table('message', meta, autoload=True)
    col = Column('include_footer', Boolean, nullable=False, default=True,
                 server_default="1")
    col.create(message_table)

########NEW FILE########
__FILENAME__ = 062_message_sender_name
from sqlalchemy import MetaData, Table, Unicode, Column


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    table = Table('message', meta, autoload=True)
    col = Column('sender_name', Unicode(255), nullable=True)
    col.create(table)

########NEW FILE########
__FILENAME__ = 063_add_shibboleth_table
from datetime import datetime
from sqlalchemy import MetaData, Column, Table, ForeignKey
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText

metadata = MetaData()

user_table = Table(
    'user', metadata,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=True),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=True),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True),
    Column('proposal_sort_order', Unicode(50), default=None, nullable=True),
    Column('gender', Unicode(1), default=None),
    Column('email_messages', Boolean, default=True),
    Column('welcome_code', Unicode(255), nullable=True),
)


shibboleth_table = Table(
    'shibboleth', metadata,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('persistent_id', Unicode(255), nullable=False, unique=True,
           index=True),
)


def upgrade(migrate_engine):
    metadata.bind = migrate_engine
    shibboleth_table.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 064_add_treatment_table
from sqlalchemy import MetaData, Column, Table, ForeignKey, Integer, Unicode


def upgrade(migrate_engine):
    meta = MetaData()
    meta.bind = migrate_engine

    badge_table = Table('badge', meta, autoload=True)

    treatment_table = Table(
        'treatment', meta,
        Column('id', Integer, primary_key=True),
        Column('key', Unicode(40), nullable=False, unique=True),
        Column('variant_count', Integer(), nullable=False),
    )

    treatment_source_badges_table = Table(
        'treatment_source_badges', meta,
        Column('treatment_id', Integer,
               ForeignKey('treatment.id', ondelete='CASCADE')),
        Column('badge_id', Integer,
               ForeignKey('badge.id', ondelete='CASCADE')),
    )

    treatment_table.create()
    treatment_source_badges_table.create()

########NEW FILE########
__FILENAME__ = 065_badge_behavior_proposal_sort
from sqlalchemy import MetaData, Table, Unicode, Column


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    table = Table('badge', meta, autoload=True)
    col = Column('behavior_proposal_sort_order', Unicode(50), nullable=True)
    col.create(table)

########NEW FILE########
__FILENAME__ = 066_show_norms_navigation
from sqlalchemy import MetaData
from sqlalchemy import Column, ForeignKey, Table, func
from sqlalchemy import Boolean, DateTime, Float, Integer, Unicode, UnicodeText

metadata = MetaData()

instance_table = Table(
    'instance', metadata,
    Column('id', Integer, primary_key=True),
    Column('key', Unicode(20), nullable=False, unique=True),
    Column('label', Unicode(255), nullable=False),
    Column('description', UnicodeText(), nullable=True),
    Column('required_majority', Float, nullable=False),
    Column('activation_delay', Integer, nullable=False),
    Column('create_time', DateTime, default=func.now()),
    Column('access_time', DateTime, default=func.now(),
           onupdate=func.now()),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'),
           nullable=False),
    Column('default_group_id', Integer, ForeignKey('group.id'),
           nullable=True),
    Column('allow_adopt', Boolean, default=False),
    Column('allow_delegate', Boolean, default=True),
    Column('allow_propose', Boolean, default=True),
    Column('allow_index', Boolean, default=True),
    Column('hidden', Boolean, default=False),
    Column('locale', Unicode(7), nullable=True),
    Column('css', UnicodeText(), nullable=True),
    Column('frozen', Boolean, default=False),
    Column('milestones', Boolean, default=False),
    Column('use_norms', Boolean, nullable=True, default=False),
    Column('require_selection', Boolean, nullable=True, default=False),
    Column('is_authenticated', Boolean, nullable=True, default=False),
    Column('hide_global_categories', Boolean, nullable=True, default=False),
    Column('editable_comments_default', Boolean, nullable=True, default=True),
    Column('require_valid_email', Boolean, nullable=True, default=True),
    Column('allow_thumbnailbadges', Boolean, default=False),
    Column('thumbnailbadges_height', Integer, nullable=True),
    Column('thumbnailbadges_width', Integer, nullable=True),
)


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    show_norms_navigation = Column('show_norms_navigation',
                                   Boolean,
                                   default=True)
    show_norms_navigation.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 067_increase_maximal_instance_key_size
from sqlalchemy import Table, MetaData
from sqlalchemy import Unicode

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    instance_table = Table('instance', metadata, autoload=True)
    key_column = instance_table.c.key

    key_column.alter(type=Unicode(63))


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 068_add_optional_user_attributes
from sqlalchemy import MetaData, Table, Column

from adhocracy.model.core import JSONEncodedDict
from adhocracy.model.core import MutationDict


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    table = Table('user', meta, autoload=True)
    col = Column('optional_attributes',
                 MutationDict.as_mutable(JSONEncodedDict))
    col.create(table)

########NEW FILE########
__FILENAME__ = 069_optional_attributes_text
from sqlalchemy import MetaData, Table

from sqlalchemy.types import TEXT


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    table = Table('user', meta, autoload=True)
    col = table.c.optional_attributes
    if col.type != TEXT:
        col.alter(type=TEXT)

########NEW FILE########
__FILENAME__ = 070_make_comment_variant_not_nullable
from sqlalchemy import MetaData, Table


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    comment_table = Table('comment', meta, autoload=True)
    comment_table.c.variant.alter(nullable=False)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 071_add_badge_impact
from sqlalchemy import MetaData, Table, Column
from sqlalchemy import Integer


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    table = Table('badge', meta, autoload=True)
    col = Column('impact', Integer, default=0, server_default=u'0',
                 nullable=False)
    col.create(table)

########NEW FILE########
__FILENAME__ = 072_add_delegateable_frozen
from sqlalchemy import MetaData, Table, Column
from sqlalchemy import Boolean


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    table = Table('delegateable', meta, autoload=True)
    col = Column('frozen', Boolean, default=False)
    col.create(table)

########NEW FILE########
__FILENAME__ = 073_add_milestone_show_all
from sqlalchemy import MetaData, Table, Column
from sqlalchemy import Boolean


def upgrade(migrate_engine):
    meta = MetaData(bind=migrate_engine)

    table = Table('milestone', meta, autoload=True)
    col = Column('show_all_proposals', Boolean, default=False)
    col.create(table)

########NEW FILE########
__FILENAME__ = 074_add_sectionpage_options
from sqlalchemy import MetaData
from sqlalchemy import Column, Table
from sqlalchemy import Boolean

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    instance_table = Table('instance', metadata, autoload=True)
    allow_propose_changes = Column('allow_propose_changes', Boolean,
                                   default=True)
    allow_propose_changes.create(instance_table)

    proposal_table = Table('proposal', metadata, autoload=True)
    is_amendment = Column('is_amendment', Boolean,
                          default=False)
    is_amendment.create(proposal_table)

    page_table = Table('page', metadata, autoload=True)

    page_sectionpage = Column('sectionpage', Boolean, default=False)
    page_allow_comment = Column('allow_comment', Boolean, default=True)
    page_allow_selection = Column('allow_selection', Boolean, default=True)
    page_always_show_original = Column('always_show_original', Boolean,
                                       default=True)

    page_sectionpage.create(page_table)
    page_allow_comment.create(page_table)
    page_allow_selection.create(page_table)
    page_always_show_original.create(page_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 075_show_proposals_navigation
from sqlalchemy import MetaData
from sqlalchemy import Column, ForeignKey, Table, func
from sqlalchemy import Boolean, DateTime, Float, Integer, Unicode, UnicodeText

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    instance_table = Table('instance', metadata, autoload=True)
    show_norms_navigation = Column('show_proposals_navigation',
                                   Boolean,
                                   default=True)
    show_norms_navigation.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 076_add_notification_table
from sqlalchemy import MetaData, Column, Table, ForeignKey, Integer, Unicode


def upgrade(migrate_engine):
    meta = MetaData()
    meta.bind = migrate_engine

    event_table = Table('event', meta, autoload=True)
    user_table = Table('user', meta, autoload=True)
    watch_table = Table('watch', meta, autoload=True)

    notification_table = Table(
        'notification', meta,
        Column('id', Integer, primary_key=True),
        Column('event_id', Integer, ForeignKey('event.id'), nullable=False),
        Column('event_type', Unicode(255), nullable=True),
        Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
        Column('watch_id', Integer, ForeignKey('watch.id'), nullable=True)
    )

    notification_table.create()

########NEW FILE########
__FILENAME__ = 077_unique_notifications
from sqlalchemy import MetaData
from migrate.changeset.constraint import UniqueConstraint
from sqlalchemy import Table

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    table = Table('notification', metadata, autoload=True)

    cons = UniqueConstraint('event_id', 'user_id', table=table)
    cons.create()


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 078_editable_proposals_default
from sqlalchemy import Column, MetaData, Table
from sqlalchemy import Boolean

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    instance_table = Table('instance', metadata, autoload=True)

    editable_proposals = Column('editable_proposals_default',
                                Boolean,
                                nullable=True,
                                default=True)
    editable_proposals.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 079_enforce_milestone_date
from sqlalchemy import MetaData, Table

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    table = Table('milestone', metadata, autoload=True)
    update = table.delete().where(table.c.time == None)  # noqa
    migrate_engine.execute(update)

    table.c.time.alter(nullable=False)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 080_add_display_category_pages
from sqlalchemy import Column, MetaData, Table
from sqlalchemy import Boolean

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    instance_table = Table('instance', metadata, autoload=True)

    display_category_pages = Column('display_category_pages',
                                    Boolean,
                                    nullable=True,
                                    default=False)
    display_category_pages.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 081_longer_badge_descriptions
from sqlalchemy import Column, MetaData, Table
from sqlalchemy import UnicodeText

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    badge_table = Table('badge', metadata, autoload=True)

    long_description = Column('long_description',
                              UnicodeText,
                              default=u'',
                              nullable=True)
    long_description.create(badge_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 082_set_thumbnail_badges_true
from sqlalchemy import MetaData, Table

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    table = Table('instance', metadata, autoload=True)
    update = table.update().values(allow_thumbnailbadges=True)
    migrate_engine.execute(update)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 083_organization_user
from sqlalchemy import Column, MetaData, Table
from sqlalchemy import Boolean

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    user_table = Table('user', metadata, autoload=True)

    _is_organization = Column('_is_organization',
                              Boolean,
                              nullable=True,
                              default=False)
    _is_organization.create(user_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = 084_add_page_index_as_tiles
from sqlalchemy import Column, MetaData, Table
from sqlalchemy import Boolean

metadata = MetaData()


def upgrade(migrate_engine):
    metadata.bind = migrate_engine

    instance_table = Table('instance', metadata, autoload=True)

    page_index_as_tiles = Column('page_index_as_tiles',
                                 Boolean,
                                 nullable=True,
                                 default=False)
    page_index_as_tiles.create(instance_table)


def downgrade(migrate_engine):
    raise NotImplementedError()

########NEW FILE########
__FILENAME__ = badge
'''
Badges for different uses (users, delegateables, categories
of delegateables). Badges use single table inheritance.
'''

from datetime import datetime
import logging

from pylons.i18n import _
from sqlalchemy import Table, Column, ForeignKey
from sqlalchemy import (Boolean, Integer, DateTime, String, Unicode,
                        LargeBinary, UnicodeText)

from adhocracy.model import meta, instance_filter as ifilter

log = logging.getLogger(__name__)
MARKER = object()


badge_table = Table(
    'badge', meta.data,
    # common attributes
    Column('id', Integer, primary_key=True),
    Column('type', String(40), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('title', Unicode(40), nullable=False),
    Column('color', Unicode(7), nullable=False),
    Column('description', Unicode(255), default=u'', nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id',
                                              ondelete="CASCADE",),
           nullable=True),
    # attributes for DelegateableBadges
    Column('impact', Integer, default=0, nullable=False),

    # attributes for hierarchical badges (CategoryBadges)
    Column('select_child_description', Unicode(255), default=u'',
           nullable=False),
    Column('parent_id', Integer, ForeignKey('badge.id', ondelete="CASCADE"),
           nullable=True),
    Column('long_description', UnicodeText, default=u'', nullable=True),
    # attributes for UserBadges
    Column('group_id', Integer, ForeignKey('group.id', ondelete="CASCADE")),
    Column('display_group', Boolean, default=False),
    Column('visible', Boolean, default=True),
    # attributes for ThumbnailBadges
    Column('thumbnail', LargeBinary, default=None, nullable=True),
    Column('behavior_proposal_sort_order', Unicode(50), nullable=True),
)


# --[ relation tables ]-----------------------------------------------------

instance_badges_table = Table(
    'instance_badges', meta.data,
    Column('id', Integer, primary_key=True),
    Column('badge_id', Integer, ForeignKey('badge.id'),
           nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'),
           nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False))


delegateable_badges_table = Table(
    'delegateable_badges', meta.data,
    Column('id', Integer, primary_key=True),
    Column('badge_id', Integer, ForeignKey('badge.id'),
           nullable=False),
    Column('delegateable_id', Integer, ForeignKey('delegateable.id'),
           nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False))


user_badges_table = Table(
    'user_badges', meta.data,
    Column('id', Integer, primary_key=True),
    Column('badge_id', Integer, ForeignKey('badge.id'),
           nullable=False),
    Column('user_id', Integer, ForeignKey('user.id'),
           nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False))


# --[ Badge base classes ]--------------------------------------------------


class Badge(object):

    def __init__(self, title, color, visible, description, impact=0,
                 instance=None):
        self.title = title
        self.description = description
        self.color = color
        self.visible = visible
        self.impact = impact
        self.instance = instance

    @classmethod
    def create(cls, title, color, visible, description, impact=0,
               instance=None):
        badge = cls(title, color, visible, description, impact, instance)
        meta.Session.add(badge)
        meta.Session.flush()
        return badge

    def __repr__(self):
        return "<%s(%s,%s)>" % (self.__class__.__name__, self.id,
                                self.title.encode('ascii', 'replace'))

    def __unicode__(self):
        return self.title

    @classmethod
    def count(cls):
        return meta.Session.query(cls).count()

    def __le__(self, other):
        return self.title >= other.title

    def __lt__(self, other):
        return self.title > other.title

    @classmethod
    def by_id(cls, id, instance_filter=True):
        try:
            q = meta.Session.query(cls)
            q = q.filter(cls.id == id)
            if ifilter.has_instance() and instance_filter:
                q = q.filter((cls.instance_id ==
                              ifilter.get_instance().id))
            return q.limit(1).first()
        except Exception, e:
            log.warn("by_id(%s): %s" % (id, e))
            return None

    @classmethod
    def find(cls, title_or_id, instance_filter=True, include_deleted=False):
        """
        Note: include_deleted doesn't have any effect, as badges can not be
        marked as deleted. This parameter is only there for coherence reasons
        with other models' find methods, as this is expected in
        `model.refs.to_entity`.
        """
        q = meta.Session.query(cls)
        try:
            q = q.filter(cls.id == int(title_or_id))
        except ValueError:
            q = q.filter(cls.title == title_or_id)
        if ifilter.has_instance() and instance_filter:
            q = q.filter(cls.instance_id == ifilter.get_instance().id)
        return q.first()

    @classmethod
    def find_by_instance(cls, title_or_id, instance=None):
        q = meta.Session.query(cls)
        try:
            q = q.filter(cls.id == int(title_or_id))
        except ValueError:
            q = q.filter(cls.title.like(title_or_id))
        if instance is not None:
            q = q.filter(cls.instance_id == instance.id)
        return q.first()

    @classmethod
    def findall_by_ids(cls, ids):
        if len(ids) == 0:
            return []
        q = meta.Session.query(cls)
        q = q.filter(cls.id.in_(ids))
        return q.all()

    @classmethod
    def all_q(cls, instance=MARKER, visible_only=False):
        '''
        A preconfigured query for all Badges ordered by title.
        If *instance* is not given all badges are given.
        If *instance* is given (either `None` or an instance object),
        only these badges are returned.
        '''
        q = meta.Session.query(cls)
        if instance is not MARKER:
            q = q.filter(cls.instance == instance)
        if visible_only:
            q = q.filter(Badge.visible == True)  # noqa
        return q

    @classmethod
    def all(cls, instance=None, include_global=False, visible_only=False):
        """
        Return all badges, orderd by title.
        Without instance it only returns badges not bound to an instance.
        With instance it only returns badges bound to that instance.
        With instance and include_global it returns both badges bound to that
        instance and badges not bound to an instance.
        """
        q = cls.all_q(instance=instance, visible_only=visible_only)
        if include_global and instance is not None:
            q = q.union(cls.all_q(instance=None))
        return q.order_by(cls.title).all()

    def to_dict(self):
        return dict(id=self.id,
                    title=self.title,
                    color=self.color,
                    visible=self.visible,
                    description=self.description,
                    instance=self.instance.id if self.instance else None)


class Badges(object):
    '''Base class for entity<->Badge relations'''

    def delete(self):
        meta.Session.delete(self)
        meta.Session.flush()

    @classmethod
    def find(cls, id):
        q = meta.Session.query(cls)
        q = q.filter(cls.id == id)
        return q.limit(1).first()


# --[ User Badges ]---------------------------------------------------------

class UserBadge(Badge):

    polymorphic_identity = 'user'

    def get_badge_type(self):
        return _(u'User badge')

    @classmethod
    def create(cls, title, color, visible, description, group=None,
               display_group=False, impact=0, instance=None):
        badge = cls(title, color, visible, description, impact, instance)
        badge.group = group
        badge.display_group = display_group
        meta.Session.add(badge)
        meta.Session.flush()
        return badge

    def assign(self, user, creator):
        UserBadges.create(user, self, creator)
        meta.Session.refresh(user)
        meta.Session.refresh(self)

    def to_dict(self):
        d = super(UserBadge, self).to_dict()
        d['group'] = self.group.code if self.group else None,
        d['users'] = [user.name for user in self.users]
        return d

    def badges(self):
        return self.user_badges

    def badged_entities(self):
        return self.users


class UserBadges(Badges):

    def __init__(self, user, badge, creator):
        self.user = user
        self.badge = badge
        self.creator = creator

    def __repr__(self):
        title = self.badge.title.encode('ascii', 'replace')
        return "<userbadges(%s, badge %s/%s for user%s/%s)>" % (
            self.id, self.badge.id, title, self.user.id, self.user.name)

    @classmethod
    def create(cls, user, badge, creator):
        assert isinstance(badge, Badge), (
            "badge has to be an :class:`adhocracy.model.badge.Badge`")
        userbadge = cls(user, badge, creator)
        meta.Session.add(userbadge)
        meta.Session.flush()
        return userbadge

    def badged_entity(self):
        return self.user


# --[ Instance Badges ]-------------------------------------------------

class InstanceBadge(Badge):

    polymorphic_identity = 'instance'

    def get_badge_type(self):
        return _(u'Instance badge')

    def assign(self, instance, creator):
        InstanceBadges.create(instance, self, creator)
        meta.Session.refresh(instance)
        meta.Session.refresh(self)

    def badges(self):
        return self.instance_badges

    def badged_entities(self):
        return self.instances


class InstanceBadges(Badges):

    def __init__(self, instance, badge, creator):
        self.instance = instance
        self.badge = badge
        self.creator = creator

    def __repr__(self):
        title = self.badge.title.encode('ascii', 'replace')
        return "<instancebadges(%s, badge %s/%s for instance%s)>" % (
            self.id, self.badge.id, title, self.instance.id)

    @classmethod
    def create(cls, instance, badge, creator):
        instancebadge = cls(instance, badge, creator)
        meta.Session.add(instancebadge)
        meta.Session.flush()
        return instancebadge

    def badged_entity(self):
        return self.instance


# --[ Delegateable Badges ]-------------------------------------------------

class DelegateableBadge(Badge):

    polymorphic_identity = 'delegateable'

    def get_badge_type(self):
        return _(u'Proposal badge')

    def assign(self, delegateable, creator):
        DelegateableBadges.create(delegateable, self, creator)
        meta.Session.refresh(delegateable)
        meta.Session.refresh(self)

    def badges(self):
        return self.delegateable_badges

    def badged_entities(self):
        return self.delegateables


class DelegateableBadges(Badges):

    def __init__(self, delegateable, badge, creator):
        self.delegateable = delegateable
        self.badge = badge
        self.creator = creator

    def __repr__(self):
        title = self.badge.title.encode('ascii', 'replace')
        return "<delegateablebadges(%s, badge %s/%s for delegateable%s)>" % (
            self.id, self.badge.id, title, self.delegateable.id)

    @classmethod
    def create(cls, delegateable, badge, creator):
        delegateablebadge = cls(delegateable, badge, creator)
        meta.Session.add(delegateablebadge)
        meta.Session.flush()
        return delegateablebadge

    def badged_entity(self):
        return self.delegateable


# --[ Category Badges ]-----------------------------------------------------


class CategoryBadge(DelegateableBadge):

    polymorphic_identity = 'category'

    def get_badge_type(self):
        return _(u'Category')

    @classmethod
    def create(cls, title, color, visible, description, impact=0,
               instance=None, parent=None, select_child_description=u'',
               long_description=u''):
        badge = cls(title, color, visible, description, impact, instance)
        badge.parent = parent
        badge.long_description = long_description
        badge.select_child_description = select_child_description
        meta.Session.add(badge)
        meta.Session.flush()
        return badge

    def to_dict(self):
        d = super(CategoryBadge, self).to_dict()
        d['parent'] = self.parent
        d['select_child_description'] = self.select_child_description
        return d

    def is_ancester(self, badge):
        """
        returns True if the given badge is an ancester of self
        """
        if self == badge:
            return True
        elif self.parent is None:
            return False
        else:
            return self.parent.is_ancester(badge)

    def get_key(self, root=None, separator=u' > '):
        if self.parent is root:
            return self.title
        else:
            return u'%s%s%s' % (
                self.parent.get_key(root, separator),
                separator,
                self.title)


# --[ Thumbnail Badges ]-----------------------------------------------------

class ThumbnailBadge(DelegateableBadge):

    polymorphic_identity = 'thumbnail'

    def get_badge_type(self):
        return _(u'Status badge')

    @classmethod
    def create(cls, title, color, visible, description, thumbnail=None,
               impact=0, instance=None):
        badge = cls(title, color, visible, description, impact, instance)
        badge.thumbnail = thumbnail
        meta.Session.add(badge)
        meta.Session.flush()
        return badge

    def __repr__(self):
        from hashlib import md5
        data_repr = (md5(self.thumbnail).hexdigest()[:8]
                     if self.thumbnail
                     else None)
        return "<%s(%s,%s,%s,%s)>" % (self.__class__.__name__,
                                      self.id,
                                      self.title.encode('ascii', 'replace'),
                                      data_repr,
                                      self.color)

    def to_dict(self):
        d = super(ThumbnailBadge, self).to_dict()
        d['thumbnail'] = self.thumbnail or ""
        return d

########NEW FILE########
__FILENAME__ = comment
from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import DateTime, Boolean, Integer, Unicode

import meta
import instance_filter as ifilter


log = logging.getLogger(__name__)


comment_table = Table(
    'comment', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, default=None, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('topic_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('wiki', Boolean, default=False),
    Column('reply_id', Integer, ForeignKey('comment.id'), nullable=True),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=True),
    Column('variant', Unicode(255), nullable=False)
)


class Comment(meta.Indexable):

    SENT_PRO = 1
    SENT_CON = -1

    def __init__(self, topic, creator, variant=None):
        self.topic = topic
        self.creator = creator

        from text import Text
        if variant is None:
            self.variant = Text.HEAD
        else:
            self.variant = variant

    def _get_latest(self):
        return self.revisions[0] if len(self.revisions) else None

    def _set_latest(self, rev):
        return self.revisions.insert(0, rev)

    latest = property(_get_latest, _set_latest)

    def root(self):
        return self if self.reply is None else self.reply.root()

    @property
    def is_root(self):
        return self.reply is None

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Comment)
            q = q.filter(Comment.id == id)
            if not include_deleted:
                q = q.filter(or_(Comment.delete_time == None,  # noqa
                                 Comment.delete_time > datetime.utcnow()))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def all_q(cls, instance_filter=True, include_deleted=False):
        from delegateable import Delegateable
        q = meta.Session.query(Comment)
        q = q.join(Delegateable)
        if ifilter.has_instance() and instance_filter:
            q = q.filter(Delegateable.instance_id == ifilter.get_instance().id)
        if not include_deleted:
            q = q.filter(or_(Comment.delete_time == None,  # noqa
                             Comment.delete_time > datetime.utcnow()))
        return q

    @classmethod
    def all(cls, instance_filter=True, include_deleted=False):
        return cls.all_q(instance_filter=instance_filter,
                         include_deleted=include_deleted).all()

    @classmethod
    def create(cls, text, user, topic, reply=None, wiki=True,
               variant=None,
               sentiment=0, with_vote=False):
        from poll import Poll
        comment = Comment(topic, user, variant)
        comment.wiki = wiki
        comment.reply = reply
        meta.Session.add(comment)
        meta.Session.flush()
        poll = Poll.create(topic, user, Poll.RATE, comment,
                           with_vote=with_vote)
        comment.poll = poll
        comment.latest = comment.create_revision(
            text, user, sentiment=sentiment,
            create_time=comment.create_time)
        return comment

    def create_revision(self, text, user, sentiment=0,
                        create_time=None):
        from revision import Revision
        rev = Revision(self, user, text)
        rev.sentiment = sentiment
        if create_time is not None:
            rev.create_time = create_time
        meta.Session.add(rev)
        self.revisions.append(rev)
        meta.Session.flush()
        return rev

    def delete(self, delete_time=None, recursive=True):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if not self.is_deleted(delete_time):
            self.delete_time = delete_time
            if recursive:
                for reply in self.replies:
                    reply.delete(delete_time=delete_time, recursive=recursive)
            if self.poll is not None:
                self.poll.end()

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time

    def is_edited(self):
        if self.is_deleted():
            return False
        return self.latest.create_time != self.create_time

    def is_mutable(self):
        return self.topic.is_mutable()

    def is_frozen(self):
        return self.topic.is_frozen()

    def _index_id(self):
        return self.id

    def to_dict(self):
        from adhocracy.lib import helpers as h
        d = dict(id=self.id,
                 create_time=self.create_time,
                 topic=self.topic_id,
                 url=h.entity_url(self, comment_page=True),
                 creator=self.creator.user_name)
        d['reply'] = self.reply_id
        d['wiki'] = self.wiki
        d['latest'] = self.latest.to_dict()
        d['revisions'] = map(lambda r: r.id, self.revisions)
        return d

    def to_index(self):
        index = super(Comment, self).to_index()
        if self.latest is not None:
            index.update(dict(
                tag=[],
                body=self.latest.text,
                user=self.creator.user_name
            ))
        if self.topic and self.topic.instance:
            index['instance'] = self.topic.instance.key
        return index

    def __repr__(self):
        return "<Comment(%d,%s,%d,%s)>" % (self.id, self.creator.user_name,
                                           self.topic_id, self.create_time)

########NEW FILE########
__FILENAME__ = core
import json

from sqlalchemy.ext.mutable import Mutable
from sqlalchemy.types import TypeDecorator, TEXT


class JSONEncodedDict(TypeDecorator):
    "Represents an immutable structure as a json-encoded string."

    impl = TEXT

    def process_bind_param(self, value, dialect):
        if value is not None:
            value = json.dumps(value)
        return value

    def process_result_value(self, value, dialect):
        if value is not None:
            value = json.loads(value)
        return value


class MutationDict(Mutable, dict):
    @classmethod
    def coerce(cls, key, value):
        "Convert plain dictionaries to MutationDict."

        if not isinstance(value, MutationDict):
            if isinstance(value, dict):
                return MutationDict(value)

            # this call will raise ValueError
            return Mutable.coerce(key, value)
        else:
            return value

    def __setitem__(self, key, value):
        "Detect dictionary set events and emit change events."

        dict.__setitem__(self, key, value)
        self.changed()

    def __delitem__(self, key):
        "Detect dictionary del events and emit change events."

        dict.__delitem__(self, key)
        self.changed()


class MutableList(Mutable, list):
    @classmethod
    def coerce(cls, key, value):
        if not isinstance(value, MutableList):
            if isinstance(value, list):
                return MutableList(value)
            value = Mutable.coerce(key, value)

        return value

    def __setitem__(self, key, value):
        old_value = list.__getitem__(self, key)
        for obj, key in self._parents.items():
            old_value._parents.pop(obj, None)

        list.__setitem__(self, key, value)
        for obj, key in self._parents.items():
            value._parents[obj] = key

        self.changed()

    def append(self, item):
        list.append(self, item)
        self.changed()

    def extend(self, iterable):
        list.extend(self, iterable)
        self.changed()

    def insert(self, index, item):
        list.insert(self, index, item)
        self.changed()

    def remove(self, value):
        list.remove(self, value)
        self.changed()

    def reverse(self):
        list.reverse(self)
        self.changed()

    def pop(self, index=-1):
        item = list.pop(self, index)
        self.changed()
        return item

    def sort(self, cmp=None, key=None, reverse=False):
        list.sort(self, cmp, key, reverse)
        self.changed()

    def __getstate__(self):
        return list(self)

    def __setstate__(self, state):
        self[:] = state

########NEW FILE########
__FILENAME__ = delegateable
"""sqlalchemy model and table shared by all modes for which a user should
be able to delegate the voting to another user (
:py:class:`adhocracy.model.comment.Comment`,
:py:class:`adhocracy.model.proposal.Proposal` and
:py:class:`adhocracy.model.page.Page`).

SQLAlchemy's `joint table inheritance` is used.
"""

from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import Boolean, DateTime, Integer, String, Unicode

import meta
import instance_filter as ifilter

log = logging.getLogger(__name__)


# REFACT: this should not be used anymore - remove?
category_graph = Table(
    'category_graph', meta.data,
    Column('parent_id', Integer, ForeignKey('delegateable.id')),
    Column('child_id', Integer, ForeignKey('delegateable.id'))
)


delegateable_table = Table(
    'delegateable', meta.data,
    Column('id', Integer, primary_key=True),
    Column('label', Unicode(255), nullable=False),
    Column('type', String(50)),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('milestone_id', Integer, ForeignKey('milestone.id'), nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False),
    Column('frozen', Boolean, default=False),
)


class Delegateable(meta.Indexable):

    def __init__(self):
        raise Exception("Make a category or a proposal instead!")

    def init_child(self, instance, label, creator):
        self.instance = instance
        self.label = label
        self.creator = creator

    def __repr__(self):
        return u"<Delegateable(%d,%s)>" % (self.id, self.instance.key)

    def is_super(self, delegateable):
        if delegateable in self.children:
            return True
        for child in self.children:
            r = child.is_super(delegateable)
            if r:
                return True
        return False

    def is_sub(self, delegateable):
        return delegateable.is_super(self)

    def is_mutable(self):
        return True

    def _get_tags(self):
        _tags = dict()
        for tagging in self.taggings:
            _tags[tagging.tag] = _tags.get(tagging.tag, 0) + 1
        return sorted(_tags.items(), key=lambda (k, v): (v, k), reverse=True)

    tags = property(_get_tags)

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Delegateable)
            q = q.filter(Delegateable.id == int(id))
            if not include_deleted:
                q = q.filter(or_(Delegateable.delete_time == None,  # noqa
                                 Delegateable.delete_time > datetime.utcnow()))
            if ifilter.has_instance() and instance_filter:
                q = q.filter((Delegateable.instance_id ==
                              ifilter.get_instance().id))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def all_q(cls, instance=None, include_deleted=False):
        q = meta.Session.query(Delegateable)
        if not include_deleted:
            q = q.filter(or_(Delegateable.delete_time == None,  # noqa
                             Delegateable.delete_time > datetime.utcnow()))
        if instance is not None:
            q = q.filter(Delegateable.instance == instance)
        return q

    @classmethod
    def all(cls, instance=None, include_deleted=False):
        return cls.all_q(instance=instance,
                         include_deleted=include_deleted).all()

    @classmethod
    def by_milestone(cls, milestone, instance=None, include_deleted=False,
                     functions=[]):
        '''
        Get delegateables related to *milestone*. The kwargs are analogue
        to the models .all_q methods. *functions* is related to Pages only.

        Returns: A list of model instances.
        '''
        # special case pages cause they have an extra kwarg functions
        from adhocracy import model
        all_q_kwargs = dict(instance=instance,
                            include_deleted=include_deleted)
        if cls is model.Page:
            all_q_kwargs['functions'] = functions

        q = cls.all_q(**all_q_kwargs)
        q = q.filter(Delegateable.milestone == milestone)
        return q.all()

    def delete(self, delete_time=None, delete_children=True):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if not self.is_deleted(delete_time):
            self.delete_time = delete_time
        if delete_children:
            for child in self.children:
                child.delete(delete_time=delete_time)
        for delegation in self.delegations:
            delegation.delete(delete_time=delete_time)
        for comment in self.comments:
            comment.delete(delete_time=delete_time)
        for poll in self.polls:
            poll.end()
        for tagging in self.taggings:
            tagging.delete()

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time

    def find_latest_comment_time(self, recursive=False):
        from revision import Revision
        from comment import Comment
        query = meta.Session.query(Revision.create_time)
        query = query.join(Comment)
        query = query.filter(Comment.topic == self)
        query = query.order_by(Revision.create_time.desc())
        query = query.limit(1)
        latest = query.first()
        if latest is None:
            t = self.create_time
        else:
            t = latest[0]

        if recursive:
            times = [c.find_latest_comment_time(recursive=True)
                     for c in self.children]
            times.append(t)
            return max(times)
        else:
            return t

    def _comment_count_query(self):
        from comment import Comment
        query = meta.Session.query(Comment)
        query = query.filter(Comment.topic_id == self.id)
        query = query.filter(or_(Comment.delete_time == None,  # noqa
                                 Comment.delete_time > datetime.utcnow()))
        return query

    def comment_count(self, reply_filter=False, recursive=False):
        '''
        Return the number of comments on the delegateable.

        *reply_id_filter* (default: `False`)
            Count only Replies to a certain comment. By default,
            all comments are counted. If `None`, only the top level
            comments are counted. If an *int* or an
            :class:`adhocracy.model.comment.Comment` is given, only replies
            this comment are counted.

        *recursive* (default: `False`)
            Also count comments to children and sum up
        '''
        from comment import Comment
        query = self._comment_count_query()
        if reply_filter is None:
            query = query.filter(Comment.reply_id == None)  # noqa
        elif reply_filter is not False:
            if isinstance(reply_filter, Comment):
                reply_filter = reply_filter.id
            assert isinstance(reply_filter, int)
            query.filter(Comment.reply_id == reply_filter)
        count = query.count()

        if recursive:
            counts = [c.comment_count(reply_filter=reply_filter,
                                      recursive=True)
                      for c in self.children]
            counts.append(count)
            return sum(counts)
        else:
            return count

    def selection_count(self, recursive=False):
        count = len(self.selections)

        if recursive:
            counts = [c.selection_count(recursive=True)
                      for c in self.children]
            counts.append(count)
            return sum(counts)
        else:
            return count

    def current_delegations(self):
        return filter(lambda d: not d.is_revoked(), self.delegations)

    @property
    def category(self):
        '''
        Getter for the category which is a many-to-many relation
        that we use as a many-to-one relation.
        '''
        if len(self.categories) > 1:
            log.error('More than 1 category on delegateable %s' % self.id)
        return self.categories[0] if self.categories else None

    def set_category(self, category, user):
        '''
        Setter for the category which is a many-to-many relation that
        we use it as a many-to-one relation.
        '''
        if not self.categories or self.categories[0] != category:
            self.categories = []
            if category:
                category.assign(self, user)

    def user_position(self, user):
        return 0

    def to_dict(self):
        from adhocracy.lib import helpers as h
        return dict(id=self.id,
                    label=self.label,
                    tags=dict([(k.name, v) for k, v in self.tags]),
                    url=h.entity_url(self),
                    instance=self.instance.key,
                    # comment=self.comment.id,
                    creator=self.creator.user_name,
                    create_time=self.create_time)

    def to_index(self):
        index = super(Delegateable, self).to_index()
        index.update(dict(
            instance=self.instance.key,
            title=self.title,
            tag=[k.name for k, v in self.tags],
            user=self.creator.user_name
        ))
        return index

########NEW FILE########
__FILENAME__ = delegation
from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import DateTime, Integer

import meta
import instance_filter as ifilter
from delegateable import Delegateable

log = logging.getLogger(__name__)


delegation_table = Table(
    'delegation', meta.data,
    Column('id', Integer, primary_key=True),
    Column('agent_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('principal_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('revoke_time', DateTime, default=None, nullable=True)
)


class Delegation(object):

    def __init__(self, principal, agent, scope):
        self.principal = principal
        self.agent = agent
        self.scope = scope

    def is_match(self, delegateable, include_deleted=False):
        if include_deleted or not self.is_revoked():
            return (self.scope == delegateable or
                    self.scope.is_super(delegateable))
        return False

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Delegation)
            q = q.filter(Delegation.id == id)
            if not include_deleted:
                q = q.filter(or_(Delegation.revoke_time == None,  # noqa
                                 Delegation.revoke_time > datetime.utcnow()))
            d = q.one()
            if ifilter.has_instance() and instance_filter:
                if d.scope.instance != ifilter.get_instance():
                    return None
            return d
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def find_by_agent_principal_scope(cls, agent, principal, scope,
                                      instance_filter=True,
                                      include_deleted=False):
        try:
            q = meta.Session.query(Delegation)
            q = q.filter(Delegation.agent == agent)
            q = q.filter(Delegation.principal == principal)
            q = q.filter(Delegation.scope == scope)
            if not include_deleted:
                q = q.filter(or_(Delegation.revoke_time == None,  # noqa
                                 Delegation.revoke_time > datetime.utcnow()))
            d = q.one()
            if ifilter.has_instance() and instance_filter:
                if d.scope.instance != ifilter.get_instance():
                    return None
            return d
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def find_by_principal(cls, principal, include_deleted=False):
        try:
            q = meta.Session.query(Delegation)
            q = q.filter(Delegation.principal == principal)
            if not include_deleted:
                q = q.filter(or_(Delegation.revoke_time == None,  # noqa
                                 Delegation.revoke_time > datetime.utcnow()))
            return q.all()
        except Exception, e:
            log.warn("find_by_principal(%s): %s" % (id, e))
            return None

    @classmethod
    def find_by_principal_in_scope(cls, principal, scope,
                                   include_deleted=False):
        principals = cls.find_by_principal(principal,
                                           include_deleted=include_deleted)
        return [d for d in principals if
                d.is_match(scope, include_deleted=include_deleted)]

    @classmethod
    def all(cls, instance=None, include_deleted=False):
        q = meta.Session.query(Delegation)
        q = q.join(Delegateable)
        if not include_deleted:
            q = q.filter(or_(Delegation.revoke_time == None,  # noqa
                             Delegation.revoke_time > datetime.utcnow()))
        if instance is not None:
            q = q.filter(Delegateable.instance == instance)
        return q.all()

    @classmethod
    def create(cls, principal, agent, scope, replay=True):
        from adhocracy.lib.democracy import Decision
        delegation = Delegation(principal, agent, scope)
        meta.Session.add(delegation)
        meta.Session.flush()
        if replay:
            log.debug("Replaying the vote for Delegation: %s" % delegation)
            Decision.replay_decisions(delegation)
        return delegation

    def revoke(self, revoke_time=None):
        if revoke_time is None:
            revoke_time = datetime.utcnow()
        if self.revoke_time is None:
            self.revoke_time = revoke_time

    def delete(self, delete_time=None):
        self.revoke(revoke_time=delete_time)

    def is_revoked(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return ((self.revoke_time is not None) and
                self.revoke_time <= at_time)

    is_deleted = is_revoked

    def to_dict(self):
        from adhocracy.lib import helpers as h
        return dict(id=self.id,
                    url=h.entity_url(self),
                    create_time=self.create_time,
                    principal=self.principal.user_name,
                    agent=self.agent.user_name,
                    scope=self.scope_id)

    def __repr__(self):
        return u"<Delegation(%s, %s->%s, %s)>" % (
            self.id,
            self.principal.user_name,
            self.agent.user_name,
            self.scope.id
        )

########NEW FILE########
__FILENAME__ = event
from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey
from sqlalchemy import DateTime, Integer, Unicode, UnicodeText
from sqlalchemy.orm import reconstructor

import json

import instance_filter as ifilter
import meta
import refs
from instance import Instance


log = logging.getLogger(__name__)


event_topic_table = Table(
    'event_topic', meta.data,
    Column('event_id', Integer, ForeignKey('event.id',
           onupdate="CASCADE", ondelete="CASCADE")),
    Column('topic_id', Integer, ForeignKey('delegateable.id',
           onupdate="CASCADE", ondelete="CASCADE"))
)


event_table = Table(
    'event', meta.data,
    Column('id', Integer, primary_key=True),
    Column('event', Unicode(255), nullable=False),
    Column('time', DateTime, default=datetime.utcnow),
    Column('data', UnicodeText(), nullable=False),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=True)
)


class Event(object):

    def __init__(self, event_type, user, data, instance=None):
        self._event = unicode(event_type)
        self.user = user
        self.instance = instance
        self.data = data

    @reconstructor
    def _reconstruct(self):
        self._ref_data = json.loads(self._data)
        self._deref_data = {}

    def __getattr__(self, attr):
        if attr in ['_ref_data', '_deref_data']:
            raise AttributeError()
        if attr not in self._deref_data:
            if attr not in self._ref_data:
                raise AttributeError()
            val = self._ref_data.get(attr)
            self._deref_data[attr] = refs.complex_to_entities(val)
        return self._deref_data.get(attr)

    def __getitem__(self, item):
        # for string formatting
        return getattr(self, item)

    def _get_data(self):
        return refs.complex_to_entities(self._ref_data)

    def _set_data(self, data):
        self._deref_data = data
        self._ref_data = refs.complex_to_refs(data)
        self._data = unicode(json.dumps(self._ref_data))

    data = property(_get_data, _set_data)

    def _get_event(self):
        try:
            import adhocracy.lib.event.types as types
            for etype in types.TYPES:
                if str(etype) == self._event:
                    return etype
            return None
        except ImportError:
            return None

    event = property(_get_event)

    @classmethod
    def all_q(cls, instance=None, include_hidden=False, event_filter=[]):
        query = meta.Session.query(Event)

        if instance is not None:
            query = query.filter(Event.instance == instance)  # noqa
        elif not include_hidden:
            # inner join+filter would remove the rows with instance=None here
            query = query.outerjoin(Instance)  # noqa
            query = query.except_(query.filter(Instance.hidden == True))  # noqa

        if event_filter:
            query = query.filter(Event.event.in_(event_filter))

        # message events should never be displayed in public
        query = query.filter(Event.event != u't_message_send') \
                     .filter(Event.event != u't_massmessage_send')  # noqa

        return query

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False,
             include_hidden=True):
        try:
            if instance_filter and ifilter.has_instance():
                instance = ifilter.get_instance()
            else:
                instance = None
            q = cls.all_q(instance=instance, include_hidden=include_hidden)
            q = q.filter(Event.id == id)
            return q.one()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def find_by_topics(cls, topics, limit=None, include_hidden=True):
        from delegateable import Delegateable
        topics = map(lambda d: d.id, topics)
        if ifilter.has_instance():
            instance = ifilter.get_instance()
        else:
            instance = None
        q = cls.all_q(instance=instance, include_hidden=include_hidden)
        q = q.join(Event.topics)
        q = q.filter(Delegateable.id.in_(topics))
        q = q.order_by(Event.time.desc())
        return q.all()

    @classmethod
    def find_by_topic(cls, topic, limit=None, include_hidden=True):
        return Event.find_by_topics([topic], limit=limit,
                                    include_hidden=include_hidden)

    @classmethod
    def find_by_instance(cls, instance, limit=50, include_hidden=True):
        q = cls.all_q(instance=instance, include_hidden=include_hidden)
        q = q.order_by(Event.time.desc())
        q = q.limit(limit)
        return q.all()

    def text(self):
        text = None
        try:
            if self.event:
                from adhocracy.lib.text import render
                text = self.event.text(self)
                text = render(text)
        except AttributeError, ae:
            log.exception("Creating event text", ae)
        if text is None or not len(text):
            text = ''
        return text

    def link(self):
        try:
            if not self.event:
                return None
            return self.event.link_path(self)
        except:
            from adhocracy.lib import helpers as h
            if self.instance:
                return h.entity_url(self.instance)
            return h.base_url(instance=None)

    def to_dict(self):
        d = dict(id=self.id,
                 time=self.time,
                 data=self.data,
                 url=self.link(),
                 user=self.user.user_name,
                 event=self._event,
                 instance=self.instance and self.instance.key or None)
        d['topics'] = map(lambda t: t.id, self.topics)
        return d

    def __repr__(self):
        return "<Event(%d,%s,%s,%s)>" % (self.id, self.event, self.time,
                                         self.user.user_name)

########NEW FILE########
__FILENAME__ = group
import logging

from sqlalchemy import Table, Column, Integer, Unicode

import meta

log = logging.getLogger(__name__)

group_table = Table(
    'group', meta.data,
    Column('id', Integer, primary_key=True),
    Column('group_name', Unicode(255), nullable=False, unique=True),
    Column('code', Unicode(255), nullable=False, unique=True),
    Column('description', Unicode(1000))
)


class Group(object):

    CODE_ANONYMOUS = u"anonymous"
    CODE_ORGANIZATION = u"organization"
    CODE_OBSERVER = u"observer"
    CODE_ADVISOR = u"advisor"
    CODE_VOTER = u"voter"
    CODE_SUPERVISOR = u"supervisor"
    CODE_MODERATOR = u"moderator"
    CODE_ADMIN = u"admin"
    CODE_DEFAULT = u"default"
    CODE_ADDRESSEE = u"addressee"

    INSTANCE_GROUPS = [CODE_OBSERVER, CODE_VOTER, CODE_SUPERVISOR,
                       CODE_ADVISOR, CODE_MODERATOR, CODE_ADDRESSEE]
    INSTANCE_DEFAULT = CODE_VOTER

    def __init__(self, group_name, code, description=None):
        self.group_name = group_name
        self.code = code
        self.description = description

    @classmethod
    def all_q(cls):
        return meta.Session.query(Group)

    @classmethod
    def all(cls, ordered=False):
        q = cls.all_q()
        if ordered:
            q = q.order_by(Group.id)
        return q.all()

    @classmethod
    def all_instance(cls):
        # todo: one query.
        return [cls.by_code(g) for g in cls.INSTANCE_GROUPS]

    @classmethod
    # @meta.session_cached
    def find(cls, group_name, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Group)
            q = q.filter(Group.group_name == group_name)
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    _index_id_attr = 'group_name'

    @classmethod
    # @meta.session_cached
    def by_id(cls, id):
        q = meta.Session.query(Group)
        q = q.filter(Group.id == id)
        return q.limit(1).first()

    @classmethod
    def by_code(cls, code):
        q = meta.Session.query(Group)
        q = q.filter(Group.code == code)
        return q.limit(1).first()

    def is_instance_group(self):
        return self.code in self.INSTANCE_GROUPS

    def __repr__(self):
        return u"<Group(%d,%s)>" % (self.id, self.code)

    def has_any_permission(self, permissions):
        return bool(set(permissions).intersection(set(self.permissions)))

########NEW FILE########
__FILENAME__ = instance
from datetime import datetime, timedelta
import logging
import math
import re

from babel import Locale

from sqlalchemy import Table, Column, ForeignKey, func, or_
from sqlalchemy import DateTime, Integer, Float, Boolean, Unicode, UnicodeText
from sqlalchemy.orm import reconstructor

from adhocracy import config
import adhocracy.model
from adhocracy.model import meta


log = logging.getLogger(__name__)


instance_table = Table(
    'instance', meta.data,
    Column('id', Integer, primary_key=True),
    Column('key', Unicode(63), nullable=False, unique=True),
    Column('label', Unicode(255), nullable=False),
    Column('description', UnicodeText(), nullable=True),
    Column('required_majority', Float, nullable=False),
    Column('activation_delay', Integer, nullable=False),
    Column('create_time', DateTime, default=func.now()),
    Column('access_time', DateTime, default=func.now(),
           onupdate=func.now()),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'),
           nullable=False),
    Column('default_group_id', Integer, ForeignKey('group.id'),
           nullable=True),
    Column('allow_adopt', Boolean, default=False),
    Column('allow_delegate', Boolean, default=True),
    Column('allow_propose', Boolean, default=True),
    Column('allow_propose_changes', Boolean, default=True),
    Column('allow_index', Boolean, default=True),
    Column('hidden', Boolean, default=False),
    Column('logo_as_background', Boolean, default=False),
    Column('locale', Unicode(7), nullable=True),
    Column('css', UnicodeText(), nullable=True),
    Column('frozen', Boolean, default=False),
    Column('milestones', Boolean, default=False),
    Column('use_norms', Boolean, nullable=True, default=False),
    Column('require_selection', Boolean, nullable=True, default=False),
    Column('is_authenticated', Boolean, nullable=True, default=False),
    Column('hide_global_categories', Boolean, nullable=True, default=False),
    Column('page_index_as_tiles', Boolean, nullable=True, default=False),
    Column('display_category_pages', Boolean, nullable=True, default=False),
    Column('editable_comments_default', Boolean, nullable=True, default=True),
    Column('editable_proposals_default', Boolean, nullable=True, default=True),
    Column('require_valid_email', Boolean, nullable=True, default=True),
    # allow_thumbnailbadges is deprecated and should always be True
    Column('allow_thumbnailbadges', Boolean, default=True),
    Column('thumbnailbadges_height', Integer, nullable=True),
    Column('thumbnailbadges_width', Integer, nullable=True),
    Column('theme', Unicode, nullable=True),
    Column('show_norms_navigation', Boolean, nullable=True, default=True),
    Column('show_proposals_navigation', Boolean, nullable=True, default=True),
)


# Instance is not a delegateable - but it should - or you cannot do
# instance wide delegation


class Instance(meta.Indexable):
    __tablename__ = 'instance'

    INSTANCE_KEY = re.compile("^[a-zA-Z][a-zA-Z0-9-]{1,63}$")

    # Special purpose instances
    SPECIAL_KEYS = [u'test', u'feedback']

    def __init__(self, key, label, creator, description=None):
        self.key = key
        self.label = label
        self.creator = creator
        self.description = description
        self.required_majority = 0.66
        self.activation_delay = 7
        self.allow_adopt = True
        self.allow_delegate = True
        self.allow_propose = True
        self.allow_index = True
        self.hidden = False
        self.frozen = False
        self.require_selection = False
        self._required_participation = None

    @reconstructor
    def _reconstruct(self):
        self._required_participation = None

    def _get_locale(self):
        if not self._locale:
            return None
        return Locale.parse(self._locale)

    def _set_locale(self, locale):
        self._locale = unicode(locale)

    locale = property(_get_locale, _set_locale)

    def current_memberships(self):
        return [m for m in self.memberships if not m.is_expired()]

    def members(self):
        '''
        return all users that are members of this instance through
        global or local membership
        '''
        from adhocracy.model.permission import Permission
        members = [membership.user for membership in
                   self.current_memberships()]
        global_membership = Permission.find('global.member')
        for group in global_membership.groups:
            for membership in group.memberships:
                if membership.instance is None and not membership.expire_time:
                    members.append(membership.user)
        return list(set(members))

    def _get_required_participation(self):
        if self._required_participation is None:
            from adhocracy.lib.democracy import Decision
            avg = Decision.average_decisions(self)
            required = int(math.ceil(max(2, avg * self.required_majority)))
            self._required_participation = required
        return self._required_participation

    required_participation = property(_get_required_participation)

    def _get_activation_timedelta(self):
        return timedelta(days=self.activation_delay)
        # return timedelta(minutes=self.activation_delay)

    activation_timedelta = property(_get_activation_timedelta)

    def _get_num_proposals(self):
        from proposal import Proposal
        q = meta.Session.query(Proposal)
        q = q.filter(Proposal.instance == self)
        q = q.filter(or_(Proposal.delete_time == None,  # noqa
                         Proposal.delete_time >= datetime.utcnow()))
        return q.count()

    num_proposals = property(_get_num_proposals)

    def _get_num_members(self):
        from membership import Membership
        q = meta.Session.query(Membership)
        q = q.filter(Membership.instance == self)
        q = q.filter(or_(Membership.expire_time == None,  # noqa
                         Membership.expire_time >= datetime.utcnow()))
        return q.count()

    num_members = property(_get_num_members)

    @classmethod
    # @meta.session_cached
    def find(cls, key, instance_filter=True, include_deleted=False):
        key = unicode(key).lower()
        try:
            q = meta.Session.query(Instance)
            try:
                q = q.filter(Instance.id == int(key))
            except ValueError:
                q = q.filter(Instance.key == unicode(key))
            if not include_deleted:
                q = q.filter(or_(Instance.delete_time == None,  # noqa
                                 Instance.delete_time > datetime.utcnow()))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (key, e))
            return None

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        for delegateable in self.delegateables:
            delegateable.delete(delete_time)
        for membership in self.memberships:
            membership.expire(delete_time)
        if not self.is_deleted(delete_time):
            self.delete_time = delete_time

    def is_shown(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return not (self.is_deleted(at_time) or self.hidden)

    _index_id_attr = 'key'

    @classmethod
    def all_q(cls):
        return meta.Session.query(Instance)

    @classmethod
    def all(cls, limit=None, include_deleted=False, include_hidden=False):
        q = cls.all_q()
        q = meta.Session.query(Instance)
        if not include_deleted:
            q = q.filter(or_(Instance.delete_time == None,  # noqa
                             Instance.delete_time > datetime.utcnow()))
        if not include_hidden:
            q = q.filter(or_(Instance.hidden == None,  # noqa
                             Instance.hidden == False))
        if limit is not None:
            q = q.limit(limit)
        q = q.order_by(Instance.label)
        return q.all()

    @classmethod
    def create(cls, key, label, user, description=None, locale=None):
        from group import Group
        from membership import Membership
        from page import Page

        instance = Instance(unicode(key).lower(), label, user)
        instance.description = description
        instance.default_group = Group.by_code(Group.INSTANCE_DEFAULT)
        if locale is not None:
            instance.locale = locale
        meta.Session.add(instance)
        supervisor_group = Group.by_code(Group.CODE_SUPERVISOR)
        membership = Membership(user, instance, supervisor_group,
                                approved=True)
        meta.Session.add(membership)
        if config.get_bool('adhocracy.create_initial_instance_page'):
            Page.create(instance, label, u"", user)

        # Autojoin the user in instances
        config_autojoin = config.get('adhocracy.instances.autojoin')
        if (config_autojoin and
                (config_autojoin == 'ALL' or
                 key in (k.strip() for k in config_autojoin.split(',')))):
            users = adhocracy.model.User.all()
            for u in users:
                autojoin_membership = Membership(u, instance,
                                                 instance.default_group)
                meta.Session.add(autojoin_membership)

        meta.Session.flush()
        return instance

    def to_dict(self):
        from adhocracy.lib import helpers as h
        d = dict(id=self.id,
                 key=self.key,
                 label=self.label,
                 creator=self.creator.user_name,
                 required_majority=self.required_majority,
                 activation_delay=self.activation_delay,
                 allow_adopt=self.allow_adopt,
                 allow_delegate=self.allow_delegate,
                 allow_propose=self.allow_propose,
                 allow_index=self.allow_index,
                 hidden=self.hidden,
                 allow_thumbnailbadges=self.allow_thumbnailbadges,
                 thumbnailbadges_height=self.thumbnailbadges_height,
                 thumbnailbadges_width=self.thumbnailbadges_width,
                 url=h.entity_url(self),
                 instance_url=h.instance.url(self),
                 default_group=self.default_group.code,
                 create_time=self.create_time)
        if self.description:
            d['description'] = self.description
        return d

    def to_index(self):
        from adhocracy.lib.event import stats as estats
        index = super(Instance, self).to_index()
        index.update(dict(
            instance=self.key,
            title=self.label,
            tags=[],
            body=self.description,
            user=self.creator.user_name,
            activity=estats.instance_activity(self),
            hidden=self.hidden,
        ))
        return index

    def __repr__(self):
        return u"<Instance(%d,%s)>" % (self.id, self.key)

    @property
    def title(self):
        return self.label

    def requires_valid_email(self):
        return (config.get_bool('adhocracy.require_email')
                and self.require_valid_email)

########NEW FILE########
__FILENAME__ = instance_filter
from beaker.util import ThreadLocal

thread_instance = ThreadLocal()


def setup_thread(instance):
    global thread_instance
    thread_instance.put(instance)


def teardown_thread():
    '''
    A counterpart for setup_thread(), probly only
    useful in test_code
    '''
    global thread_instance
    try:
        thread_instance.remove()
    except AttributeError:
        # no value saved
        pass


def has_instance():
    return thread_instance.get() is not None


def get_instance():
    return thread_instance.get()

########NEW FILE########
__FILENAME__ = membership
from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import Integer, DateTime, Boolean

import instance_filter as ifilter
import meta

log = logging.getLogger(__name__)


membership_table = Table(
    'membership', meta.data,
    Column('id', Integer, primary_key=True),
    Column('approved', Boolean, nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('expire_time', DateTime, nullable=True),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=True),
    Column('group_id', Integer, ForeignKey('group.id'), nullable=False),
)


class Membership(object):

    def __init__(self, user, instance, group, approved=True):
        self.user = user
        self.instance = instance
        self.group = group
        self.approved = approved

    @classmethod
    def all_q(cls, instance_filter=True, include_deleted=False):
        q = meta.Session.query(Membership)
        if ifilter.has_instance() and instance_filter:
            q = q.filter(Membership.instance_id == ifilter.get_instance().id)
        if not include_deleted:
            q = q.filter(or_(Membership.expire_time == None,  # noqa
                             Membership.expire_time > datetime.utcnow()))
        return q

    @classmethod
    def all(cls, instance_filter=True, include_deleted=False):
        return cls.all_q(instance_filter=instance_filter,
                         include_deleted=include_deleted).all()

    def expire(self, expire_time=None):
        if expire_time is None:
            expire_time = datetime.utcnow()
        if not self.is_expired(at_time=expire_time):
            self.expire_time = expire_time
        # if not self.user.is_member(self.instance):
        #     self.user.revoke_delegations(self.instance)

    def is_expired(self, at_time=None):
        if self.expire_time is None:
            return False
        else:
            if at_time is None:
                at_time = datetime.utcnow()
            return self.expire_time <= at_time

    def delete(self, delete_time=None):
        return self.expire(expire_time=delete_time)

    def is_deleted(self, at_time=None):
        return self.is_expired(at_time=at_time)

    def __repr__(self):
        key = self.instance and self.instance.key or "",
        return u"<Membership(%s,%s,%s,%s)>" % (str(self.id),
                                               self.user.user_name,
                                               key,
                                               self.group.code)

########NEW FILE########
__FILENAME__ = message
import logging
from datetime import datetime

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText

import meta
import instance_filter as ifilter

log = logging.getLogger(__name__)


message_table = Table(
    'message', meta.data,
    Column('id', Integer, primary_key=True),
    Column('subject', Unicode(140), nullable=False),
    Column('body', UnicodeText(), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('sender_email', Unicode(255), nullable=True),
    Column('include_footer', Boolean, default=True, nullable=False),
    Column('sender_name', Unicode(255), nullable=True),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=True)
)


class Message(meta.Indexable):

    def __init__(self, subject, body, creator, sender_email=None,
                 sender_name=None, instance=None, include_footer=True):
        self.subject = subject
        self.body = body
        self.creator = creator
        self.sender_email = sender_email
        self.sender_name = sender_name
        self.include_footer = include_footer
        self.instance = instance

    @classmethod
    def create(cls, subject, body, creator, sender_email=None,
               sender_name=None, instance=None, include_footer=True):
        message = cls(subject, body, creator, sender_email, sender_name,
                      instance, include_footer)
        meta.Session.add(message)
        meta.Session.flush()
        return message

    @classmethod
    def all_q(cls, instance=None, include_deleted=False):
        query = meta.Session.query(Message)
        if instance is not None:
            query = query.filter(Message.instance == instance)  # noqa
        if not include_deleted:
            query = query.filter(or_(Message.delete_time == None,  # noqa
                                     Message.delete_time > datetime.utcnow()))
        return query

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        if instance_filter and ifilter.has_instance():
            instance = ifilter.get_instance()
        else:
            instance = None
        query = cls.all_q(instance=instance,
                          include_deleted=include_deleted)
        query = query.filter(Message.id == id)
        return query.first()

    @classmethod
    def all(cls, instance=None, include_deleted=False):
        return cls.all_q(instance=instance,
                         include_deleted=include_deleted).all()

    @property
    def email_from(self):
        if self.sender_email:
            return self.sender_email
        elif self.creator.is_email_activated():
            return self.creator.email
        else:
            return None

    @property
    def name_from(self):
        if self.sender_name:
            return self.sender_name
        else:
            return self.creator.name

    def rendered_body(self, user):
        from adhocracy.lib.message import render_body

        return render_body(self.body, user)


message_recipient_table = Table(
    'message_recipient', meta.data,
    Column('id', Integer, primary_key=True),
    Column('message_id', Integer, ForeignKey('message.id'), nullable=False),
    Column('recipient_id', Integer, ForeignKey('user.id'), nullable=False),

    # recycled to mean 'sent' in any way, including notification
    Column('email_sent', Boolean, default=False),
)


class MessageRecipient(object):

    def __init__(self, message, recipient):
        self.message = message
        self.recipient = recipient

    @classmethod
    def create(cls, message, recipient):
        r = cls(message, recipient)
        meta.Session.add(r)
        meta.Session.flush()
        return r

########NEW FILE########
__FILENAME__ = meta
"""SQLAlchemy Metadata and Session object"""

from sqlalchemy import MetaData

__all__ = ['Session', 'data', 'engine']

# SQLAlchemy database engine.  Updated by model.init_model()
engine = None

# SQLAlchemy session manager.  Updated by model.init_model()
# REFACT: this is an instance, not a class - so it should be lowercased
Session = None

# Global metadata. If you have multiple databases with overlapping table
# names, you'll need a metadata for each database
data = MetaData()


def filter_invalid_strings(k, v):
    return (k, filter(lambda x: x not in [u'\x0b', u'\x0c'], v)
            if isinstance(v, basestring) else v)


class Indexable(object):

    def to_index(self):
        import refs
        from adhocracy.lib.pager import INDEX_DATA_FINDERS
        from adhocracy.lib.core import CustomDict
        index = CustomDict(
            filter_invalid_strings,
            ref=refs.to_ref(self),
            doc_type=refs.entity_type(self))
        if hasattr(self, 'is_deleted'):
            index['skip'] = self.is_deleted()
        if hasattr(self, 'create_time'):
            index['create_time'] = self.create_time.strftime("%s")
        for indexer in INDEX_DATA_FINDERS:
            indexer.add_data_to_index(self, index)

        return index

########NEW FILE########
__FILENAME__ = milestone
from datetime import datetime
import logging

from sqlalchemy import Column, ForeignKey, Table, or_
from sqlalchemy import Boolean, Integer, Unicode, UnicodeText, DateTime

import meta

log = logging.getLogger(__name__)

milestone_table = Table(
    'milestone', meta.data,
    Column('id', Integer, primary_key=True),
    Column('instance_id', Integer, ForeignKey('instance.id'), nullable=False),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('category_id', Integer, ForeignKey('badge.id'), nullable=True),
    Column('title', Unicode(255), nullable=True),
    Column('text', UnicodeText(), nullable=True),
    Column('time', DateTime, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('modify_time', DateTime, nullable=True, onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('show_all_proposals', Boolean, default=False),
)


class Milestone(object):

    def __init__(self, instance, creator, title, text, time, category=None):
        self.instance = instance
        self.creator = creator
        self.title = title
        self.text = text
        self.category = category
        if time is not None:
            self.time = time

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        q = meta.Session.query(Milestone)
        try:
            id = int(id)
        except ValueError:
            return None
        q = q.filter(Milestone.id == id)
        if not include_deleted:
            q = q.filter(or_(Milestone.delete_time == None,  # noqa
                             Milestone.delete_time > datetime.utcnow()))
        return q.first()

    @classmethod
    def create(cls, instance, creator, title, text, time, category=None):
        milestone = Milestone(instance, creator, title, text, time,
                              category=category)
        meta.Session.add(milestone)
        meta.Session.flush()
        return milestone

    @classmethod
    def all_q(cls, instance=None, include_deleted=False):
        q = meta.Session.query(Milestone)
        if not include_deleted:
            q = q.filter(or_(Milestone.delete_time == None,  # noqa
                             Milestone.delete_time > datetime.utcnow()))
        if instance is not None:
            q = q.filter(Milestone.instance == instance)
        return q

    @classmethod
    def all(cls, instance=None, include_deleted=False):
        return cls.all_q(instance=instance,
                         include_deleted=include_deleted).all()

    @classmethod
    def all_future_q(cls, instance=None, include_deleted=False):
        q = cls.all_q(instance, include_deleted)
        return q.filter(Milestone.time > datetime.utcnow())

    @classmethod
    def all_future(cls, instance=None, include_deleted=False):
        return cls.all_future_q(instance, include_deleted).all()

    @property
    def over(self, expire_time=None):
        if expire_time is None:
            expire_time = datetime.utcnow()
        return expire_time > self.time

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return ((self.delete_time is not None) and
                self.delete_time <= at_time)

    def to_dict(self):
        from adhocracy.lib import helpers as h
        d = dict(id=self.id,
                 title=self.title,
                 url=h.entity_url(self),
                 create_time=self.create_time,
                 text=self.text,
                 creator=self.creator.user_name,
                 instance=self.instance.key)
        return d

    def to_index(self):
        index = super(Milestone, self).to_index()
        index.update(dict(
            instance=self.instance.key,
            title=self.title,
            tags=[],
            body=self.text,
            user=self.creator.user_name
        ))
        return index

    def __repr__(self):
        title = self.title.encode('ascii', 'replace')
        return u"<Milestone(%s, %s, %s)>" % (
            self.id,
            title,
            self.time.isoformat() if self.time is not None else u'no date'
        )

########NEW FILE########
__FILENAME__ = notification
import os.path
import logging

from sqlalchemy import Table, Column, ForeignKey
from sqlalchemy import Integer, Unicode
from sqlalchemy import UniqueConstraint

from pylons.i18n import _

from adhocracy import templates
from adhocracy.model import meta

log = logging.getLogger(__name__)


notification_table = Table(
    'notification', meta.data,
    Column('id', Integer, primary_key=True),
    Column('event_id', Integer, ForeignKey('event.id'), nullable=False),
    Column('event_type', Unicode(255), nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('watch_id', Integer, ForeignKey('watch.id'), nullable=True),
    UniqueConstraint('event_id', 'user_id'),
)


class Notification(object):
    """ Notification class connects events to their recipients.

    If an event is created, Notification objects are created in the module
    functions of adhocracy.lib.event.notification.sources for various reason:
    An entity related to an event is on a user's watchlist, or has been voted
    on, etc.

    These notifications are then filtered to avoid duplicates etc. The filter
    functions are in adhocracy.lib.event.notification.filters.

    The remaining notifications are passed through a chain of sinks which
    are module functions of adhocracy.lib.event.notification.sinks. Sinks are
    notification consumers, which may either stop further propagation of the
    notification to other sinks or pass them on.

    The entire pipeline of Notification objects is defined in the notify
    function in adhocracy.lib.event.notification.

    From an ORM perspective the Notification class is somewhat special, as
    many notifications are created without ever being added to the SQLAlchemy
    session and thus never being added to the database, but merely exist as
    normal Python objects. Only some notifications will ever make it to the
    database: Those which are explictly added to the SQLAlchemy session in
    the database sink.

    In order to avoid to accidently add notifications to the database, there
    is no backref Event.notifications in the mapper definition in
    adhocracy.model.
    """

    TPL_NAME = os.path.join("", "notifications", "%s.%s.txt")

    def __init__(self, event, user, type=None, watch=None):
        self.event = event
        self._type = type
        if type is None:
            self.event_type = self.event.event.code
        else:
            self.event_type = self._type.code
        self.user = user
        self.watch = watch

    def get_type(self):
        from adhocracy.lib.event.types import TYPE_MAPPINGS
        return TYPE_MAPPINGS[self.event_type]

    type = property(get_type)

    def get_priority(self):
        return self.type.priority

    priority = property(get_priority)

    def get_id(self):
        return "n-e%s-u%s" % (self.event.id, self.user.id)

    def language_context(self):
        from adhocracy import i18n
        return i18n.user_language(self.user)

    def get_subject(self):
        from adhocracy.lib.event import formatting
        fe = formatting.FormattedEvent(self.event,
                                       lambda f, value: f.unicode(value))
        return self.type.subject() % fe

    subject = property(get_subject)

    def _get_link(self):
        try:
            return self.type.link_path(self.event, absolute=True)
        except Exception as e:
            log.error('Failed to get link to notification %r: %r' % (self, e))
            return ""

    link = property(_get_link)

    def get_body(self):
        from adhocracy import i18n
        from adhocracy.lib.templating import render
        locale = self.language_context()
        data = {'n': self, 'e': self.event, 'u': self.user, 't': self.type}

        tpl_name = self.TPL_NAME % (str(self.type), locale.language[0:2])
        tpl_path = os.path.join(templates.__path__[0], tpl_name)

        if not os.path.exists(tpl_path):
            log.warn("Notification body needs to be localized to "
                     "file %s" % (tpl_path))
            tpl_name = self.TPL_NAME % (
                str(self.type), i18n.get_default_locale().language[0:2])

        body = render(tpl_name, data).strip()
        body += _("\r\n\r\nMore info: %(url)s") % dict(url=self.link)
        return body

    body = property(get_body)

    def __repr__(self):
        return "<Notification(%s,%s,%s)>" % (self.event_type,
                                             self.user.user_name,
                                             self.priority)

########NEW FILE########
__FILENAME__ = openid
from datetime import datetime

import logging

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import DateTime, Integer, LargeBinary, Unicode
import meta

log = logging.getLogger(__name__)


openid_table = Table(
    'openid', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('identifier', Unicode(255), nullable=False, index=True)
)


oid_nonces = Table(
    'oid_nonces', meta.data,
    Column('server_url', LargeBinary, nullable=False),
    Column('timestamp', Integer, primary_key=True),
    Column('salt', Unicode(40), nullable=False, index=True)
)


oid_associations = Table(
    'oid_associations', meta.data,
    Column('server_url', LargeBinary, nullable=False),
    Column('handle', Unicode(255), nullable=False, index=True),
    Column('secret', LargeBinary, nullable=False),
    Column('issued', Integer, primary_key=True),
    Column('lifetime', Integer, primary_key=True),
    Column('assoc_type', Unicode(64), nullable=False)
)


class OpenID(object):

    def __init__(self, identifier, user):
        self.identifier = identifier
        self.user = user

    @classmethod
    def find(cls, identifier, include_deleted=False):
        try:
            q = meta.Session.query(OpenID)
            q = q.filter(OpenID.identifier == identifier)
            if not include_deleted:
                q = q.filter(or_(OpenID.delete_time == None,  # noqa
                                 OpenID.delete_time > datetime.utcnow()))
            return q.one()
        except Exception, e:
            log.warn("find(%s): %s" % (identifier, e))
            return None

    @classmethod
    def by_id(cls, id, include_deleted=False):
        try:
            q = meta.Session.query(OpenID)
            q = q.filter(OpenID.id == id)
            if not include_deleted:
                q = q.filter(or_(OpenID.delete_time == None,  # noqa
                                 OpenID.delete_time > datetime.utcnow()))
            return q.limit(1).first()
        except Exception:
            log.exception("by_id(%s)" % id)
            return None

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time

    def __repr__(self):
        return u"<OpenID(%d,%s,%s)>" % (self.id,
                                        self.identifier,
                                        self.user.user_name)

########NEW FILE########
__FILENAME__ = page
from datetime import datetime
import logging
import re

from pylons.i18n import _
from sqlalchemy import Table, Column, ForeignKey, func, or_, not_
from sqlalchemy import Integer, Unicode, Boolean

import meta
from delegateable import Delegateable
import instance_filter as ifilter

log = logging.getLogger(__name__)


page_table = Table(
    'page', meta.data,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('function', Unicode(20)),
    Column('formatting', Boolean, default=False),
    Column('sectionpage', Boolean, default=True),
    Column('allow_comment', Boolean, default=True),
    Column('allow_selection', Boolean, default=True),
    Column('always_show_original', Boolean, default=True),
    Column('abstract', Unicode(255), default=u'', nullable=True),
)


class Page(Delegateable):

    DESCRIPTION = u"description"
    NORM = u"norm"
    CONTAINER = u"container"

    FUNCTIONS = [DESCRIPTION, NORM, CONTAINER]
    PARENT_FUNCTIONS = [NORM, CONTAINER]
    WITH_VARIANTS = [NORM]  # [DESCRIPTION, NORM]
    LISTED = [NORM, CONTAINER]

    def __init__(self, instance, alias, creator, function, formatting=False,
                 sectionpage=False, allow_comment=True, allow_selection=True,
                 always_show_original=True, abstract=None):
        self.init_child(instance, alias, creator)
        self.function = function
        self.formatting = formatting
        self.sectionpage = sectionpage
        self.allow_comment = allow_comment
        self.allow_selection = allow_selection
        self.always_show_original = always_show_original
        self.abstract = abstract

    @property
    def selections(self):
        return [s for s in self._selections if not s.is_deleted()]

    @property
    def texts(self):
        return [t for t in self._texts if not t.is_deleted()]

    @classmethod
    def find_fuzzy(cls, id, instance_filter=True, include_deleted=False):
        page = cls.find(id, instance_filter=instance_filter,
                        include_deleted=include_deleted)
        if page is None:
            from text import Text
            q = meta.Session.query(Page)
            q = q.join(Text)
            q = q.filter(Text.title.like(id))
            if not include_deleted:
                q = q.filter(or_(Page.delete_time == None,  # noqa
                                 Page.delete_time > datetime.utcnow()))
            if ifilter.has_instance() and instance_filter:
                q = q.filter(Page.instance == ifilter.get_instance())
            q = q.order_by(Text.create_time.asc())
            page = q.limit(1).first()
        return page

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Page)
            try:
                id = int(id)
                q = q.filter(Page.id == id)
            except ValueError:
                # from adhocracy.lib.text import title2alias
                q = q.filter(Page.label == id)
            if not include_deleted:
                q = q.filter(or_(Page.delete_time == None,  # noqa
                                 Page.delete_time > datetime.utcnow()))
            if ifilter.has_instance() and instance_filter:
                q = q.filter(Page.instance == ifilter.get_instance())
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def all_q(cls, instance=None, functions=[], exclude=[],
              include_deleted=False):
        q = meta.Session.query(Page)
        if not include_deleted:
            q = q.filter(or_(Page.delete_time == None,  # noqa
                             Page.delete_time > datetime.utcnow()))
        if functions != []:
            q = q.filter(Page.function.in_(functions))
        if instance is not None:
            q = q.filter(Page.instance == instance)
        if exclude != []:
            q = q.filter(not_(Page.id.in_([p.id for p in exclude])))
        return q

    @classmethod
    def all(cls, include_sectionpages=True, **kwargs):
        pages = cls.all_q(**kwargs).all()
        if not include_sectionpages:
            pages = filter(lambda p: not p.is_sectionpage(), pages)
        return pages

    @classmethod
    def unused_label(cls, label, instance_filter=True, functions=None,
                    include_deleted=False):
        q = meta.Session.query(Page)\
            .filter(Page.label == label)
        if not include_deleted:
            q = q.filter(or_(Page.delete_time == None,  # noqa
                             Page.delete_time > datetime.utcnow()))
        if ifilter.has_instance() and instance_filter:
            q = q.filter(Page.instance == ifilter.get_instance())

        return not q.count()

    @classmethod
    def count(cls, **kwargs):
        return cls.all_q(**kwargs).count()

    @classmethod
    def create(cls, instance, title, text, creator, function=NORM, tags=None,
               wiki=False, formatting=False, sectionpage=False,
               allow_comment=True, allow_selection=True,
               always_show_original=True, abstract=None):
        from adhocracy.lib.text import title2alias
        from text import Text
        from tagging import Tagging
        if function not in Page.FUNCTIONS:
            raise AttributeError("Invalid page function type")
        label = title2alias(title)
        page = Page(instance, label, creator, function, formatting,
                    sectionpage, allow_comment, allow_selection,
                    always_show_original, abstract)
        meta.Session.add(page)
        meta.Session.flush()
        Text(page, Text.HEAD, creator, title, text, wiki)

        if tags is not None:
            page.taggings = Tagging.create_all(page, tags, creator)

        return page

    def establish_variant(self, variant, user):
        for selection in self.selections:
            selection.make_variant_poll(variant, user)

    def variant_polls(self, variant):
        polls = [s.variant_poll(variant) for s in self.selections]
        polls = [p for p in polls if p is not None]
        return polls

    def variant_tally(self, variant):
        from tally import Tally
        polls = self.variant_polls(variant)
        return Tally.combine_polls(polls)

    def variant_tallies(self):
        return [self.variant_tally(v) for v in self.variants]

    @property
    def proposal(self):
        if self.function == Page.DESCRIPTION:
            return self._proposal[-1]
        return None

    @property
    def parent(self):
        for d in self.parents:
            if (isinstance(d, Page) and d.function in self.LISTED and not
                    d.is_deleted()):
                return d

    @property
    def subpages(self):
        return [c for c in self.children if isinstance(c, Page) and
                c.function in self.LISTED and not c.is_deleted()]

    def sectionpage_root(self):
        """This returns the nearest ancestor sectionpage of this page.
        If non exists this returns None"""
        # I tried to avoid is_sectionpage() here as that is recursice itself
        if self.sectionpage:
            return self
        elif self.parent is not None:
            return self.parent.sectionpage_root()
        else:
            return None

    @property
    def has_variants(self):
        return self.function in Page.WITH_VARIANTS and self.allow_selection

    @property
    def variants(self):
        from text import Text
        if not self.has_variants:
            return [Text.HEAD]
        return list(set([t.variant for t in self.texts]))

    def variant_head(self, variant):
        for text in self.texts:
            if text.variant == variant:
                return text
        return None

    def variant_at(self, variant, at_time):
        for text in self.variant_history(variant):
            if text.create_time <= at_time:
                return text
        return None

    def variant_history(self, variant):
        head = self.variant_head(variant)
        if head:
            return head.history
        return []

    def variant_changes_count(self, variant):
        head = self.variant_head(variant)
        if head:
            return head.history_q().count() - 1
        return 0

    def variant_comments(self, variant):
        return [c for c in self.comments if
                ((not c.is_deleted()) and c.variant == variant)]

    def rename_variant(self, old_name, new_name):
        from text import Text
        if old_name == Text.HEAD or new_name in self.variants:
            return
        for text in self._texts:
            if text.variant == old_name:
                text.variant = new_name
        for selection in self._selections:
            poll = selection.variant_poll(old_name)
            poll.subject = selection.variant_key(new_name)

    @property
    def heads(self):
        from text import Text
        if not self.has_variants:
            return [self.variant_head(Text.HEAD)]
        return [self.variant_head(h) for h in self.variants]

    @property
    def head(self):
        from text import Text
        return self.variant_head(Text.HEAD)

    @property
    def title(self):
        if not self.head or not self.head.title:
            return _("(Untitled)")
        title = self.head.title
        if self.is_sectionpage():
            # section titles are "root_label( index)*"
            # this transforms that title into a more human-friendly one
            root = self.sectionpage_root()
            if root != self:
                match = re.match('^%s( \d+)+$' % root.label, title)

                # legacy
                if match is None:
                    match = re.match('^%s( \d+)+$' % root.title, title)

                if match is not None:
                    section_no = [unicode(int(g.strip(), 10) + 1)
                                  for g in match.groups()]
                    section_no = u'.'.join(section_no)
                    return _(u"%s (section %s)") % (root.title, section_no)
        return title

    @property
    def full_title(self):
        from adhocracy.lib.helpers import truncate
        title = truncate(self.title, length=40, whole_word=True)
        if self.parent:
            title = self.parent.full_title + " - " + title
        return title

    def render(self, variant=None, line_based=None):
        from text import Text
        if variant is None:
            # FIXME always_show_original should be used here
            variant = Text.HEAD
        if line_based is None:
            line_based = not self.formatting
        return self.variant_head(variant).render(line_based)

    def _get_parent(self):
        for parent in self.parents:
            if isinstance(parent, Page):
                return parent
        return None

    def _set_parent(self, parent):
        parents = []
        for old_parent in self.parents:
            if not isinstance(old_parent, Page):
                parents.append(old_parent)
        if parent is not None:
            parents.append(parent)
        self.parents = parents

    parent = property(_get_parent, _set_parent)

    @property
    def changing_selections(self):
        from text import Text
        selections = []
        for selection in self.selections:
            if selection.is_deleted():
                continue
            if selection.proposal.adopted:
                continue
            if selection.selected != Text.HEAD:
                selections.append(selection)
        return selections

    def is_sectionpage(self):
        if self.sectionpage:
            return True
        else:
            return self.is_section()

    def is_section(self):
        if self.parent:
            return self.parent.is_sectionpage()
        else:
            return False

    def supporting_selections(self, variant):
        selections = []
        for selection in self.selections:
            if selection.is_deleted():
                continue
            if selection.proposal.adopted:
                continue
            if selection.selected == variant:
                selections.append(selection)
        return selections

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        for selection in self.selections:
            selection.delete(delete_time=delete_time)
        super(Page, self).delete(delete_time=delete_time)

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return ((self.delete_time is not None) and
                self.delete_time <= at_time)

    def purge_variant(self, variant, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        for text in self.texts:
            if text.variant == variant:
                text.delete(delete_time=delete_time)
        for selection in self._selections:
            poll = selection.variant_poll(variant)
            poll.end()

    def is_mutable(self):
        if self.function == self.DESCRIPTION and self.proposal:
            return self.proposal.is_mutable()
        return not self.instance.frozen

    def is_frozen(self):
        if self.function == self.DESCRIPTION and self.proposal:
            return self.proposal.frozen
        else:
            return self.frozen

    def user_position(self, user):
        if self.function == self.DESCRIPTION and self.proposal:
            return self.proposal.user_position(user)
        return 0

    def _index_id(self):
        return self.id

    def contributors(self):
        from user import User
        from text import Text
        q = meta.Session.query(User)
        q = q.join(Text)
        q = q.add_column(func.count(Text.id))
        q = q.filter(Text.page == self)
        q = q.group_by(User.id)
        q = q.order_by(func.count(Text.id).desc())
        cbs = super(Page, self).contributors()
        return self._join_contributors(cbs, q.all(), second_factor=2)

    def to_dict(self, text=None):
        if text is None:
            text = self.head
        from adhocracy.lib import helpers as h
        d = dict(id=self.id,
                 url=h.entity_url(self),
                 create_time=self.create_time,
                 label=self.label,
                 title=self.title,
                 full_title=self.full_title,
                 text=text,
                 function=self.function,
                 creator=self.creator.user_name)
        if self.parent:
            d['parent'] = self.parent.id
        return d

    def to_index(self):
        index = super(Page, self).to_index()
        if self.function == self.DESCRIPTION:
            index['skip'] = True
            return index
        if self.head is not None:
            index.update(dict(
                body=self.head.text,
            ))
        return index

    def __repr__(self):
        return u"<Page(%s)>" % (self.id)

########NEW FILE########
__FILENAME__ = permission
import logging

from sqlalchemy import Table, Column, ForeignKey, Integer, Unicode

import meta

log = logging.getLogger(__name__)

group_permission_table = Table(
    'group_permission', meta.data,
    Column('group_id', Integer, ForeignKey('group.id',
           onupdate="CASCADE", ondelete="CASCADE"), primary_key=True),
    Column('permission_id', Integer, ForeignKey('permission.id',
           onupdate="CASCADE", ondelete="CASCADE"), primary_key=True)
)

permission_table = Table(
    'permission', meta.data,
    Column('id', Integer, primary_key=True),
    Column('permission_name', Unicode(255), nullable=False, unique=True)
)


class Permission(object):

    def __init__(self, permission_name):
        self.permission_name = unicode(permission_name)

    @classmethod
    def find(cls, permission_name, instance_filter=True,
             include_deleted=False):
        try:
            q = meta.Session.query(Permission)
            q = q.filter(Permission.permission_name ==
                         unicode(permission_name))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (permission_name, e))
            return None

    @classmethod
    def find_multiple(cls, permission_names):
        return meta.Session.query(Permission).filter(
            Permission.permission_name.in_(permission_names)).all()

    _index_id = 'permission_name'

    @classmethod
    def all(cls):
        return meta.Session.query(Permission).all()

    def __repr__(self):
        return u"<Permission(%d,%s)>" % (self.id, self.permission_name)

########NEW FILE########
__FILENAME__ = poll
import logging
from datetime import datetime

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import DateTime, Integer, Unicode
from sqlalchemy.orm import reconstructor, eagerload

import meta
import instance_filter as ifilter

log = logging.getLogger(__name__)


poll_table = Table(
    'poll', meta.data,
    Column('id', Integer, primary_key=True),
    Column('begin_time', DateTime, default=datetime.utcnow),
    Column('end_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('action', Unicode(50), nullable=False),
    Column('subject', Unicode(254), nullable=False),
    Column('scope_id', Integer, ForeignKey('delegateable.id'), nullable=False)
)


class NoPollException(Exception):
    pass


class Poll(object):

    ADOPT = u'adopt'
    RATE = u'rate'
    SELECT = u'select'

    ACTIONS = [ADOPT, RATE, SELECT]

    def __init__(self, scope, user, action, subject=None):
        self.scope = scope
        self.user = user
        if action not in self.ACTIONS:
            raise ValueError("Invalid action!")
        self.action = action
        if subject is None:
            subject = scope
        self._subject_entity = None
        self._tally = None
        self._stable = {}
        self._selection = None
        self.subject = subject

    @reconstructor
    def _reconstruct(self):
        self._subject_entity = None
        self._tally = None
        self._stable = {}
        self._selection = None

    def _get_subject(self):
        import refs
        if self._subject_entity is None:
            self._subject_entity = refs.to_entity(self._subject)
        return self._subject_entity

    def _set_subject(self, subject):
        import refs
        self._subject_entity = subject
        self._subject = refs.to_ref(subject)
        if self._subject is None:
            self._subject = subject

    subject = property(_get_subject, _set_subject)

    @property
    def selection(self):
        if self._selection is None:
            from selection import Selection
            self._selection = Selection.by_key(self._subject,
                                               instance_filter=False)
        return self._selection

    @property
    def variant(self):
        if self.selection is None:
            return None
        for (variant, poll) in self.selection.variant_polls:
            if poll == self:
                return variant

    @property
    def tally(self):
        if self._tally is None:
            if len(self.tallies):
                self._tally = self.tallies[0]
            else:
                from tally import Tally
                self._tally = Tally.create_from_poll(self)
        return self._tally

    def can_end(self):
        if self.has_ended():
            return False
        if self.action == self.RATE:
            return False
        if self.tally.has_majority() and self.tally.has_participation():
            return False
        return True

    def end(self, end_time=None):
        if end_time is None:
            end_time = datetime.utcnow()
        if not self.has_ended(at_time=end_time):
            self.end_time = end_time

    def has_ended(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.end_time is not None) \
            and self.end_time <= at_time

    def delete(self, delete_time=None):
        return self.end(end_time=delete_time)

    def is_deleted(self, at_time=None):
        return self.has_ended(at_time=at_time)

    def check_stable(self, at_time):
        from tally import Tally
        end = datetime.utcnow() if at_time is None else at_time
        start = end - self.scope.instance.activation_timedelta
        tallies = Tally.all_samples(self, start, end)
        if not len(tallies):
            return False
        if tallies[0].create_time > start:
            return False
        for tally in tallies:
            if not (tally.has_participation() and
                    tally.has_majority()):
                return False
        return True

    def is_stable(self, at_time=None):
        if at_time not in self._stable:
            self._stable[at_time] = self.check_stable(at_time)
        return self._stable[at_time]

    @classmethod
    def create(cls, scope, user, action, subject=None, with_vote=False):
        from tally import Tally
        from vote import Vote
        from adhocracy.lib.democracy import Decision
        poll = Poll(scope, user, action, subject=subject)
        meta.Session.add(poll)
        meta.Session.flush()
        if with_vote:
            decision = Decision(user, poll)
            decision.make(Vote.YES)
        Tally.create_from_poll(poll)
        meta.Session.flush()
        return poll

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=True):
        from delegateable import Delegateable
        try:
            q = meta.Session.query(Poll)
            q = q.filter(Poll.id == int(id))
            if not include_deleted:
                q = q.filter(or_(Poll.end_time == None,  # noqa
                                 Poll.end_time > datetime.utcnow()))
            if ifilter.has_instance() and instance_filter:
                q = q.join(Delegateable)
                q = q.filter(Delegateable.instance == ifilter.get_instance())
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def by_subjects(cls, subjects, include_deleted=True):
        try:
            q = meta.Session.query(Poll)
            q = q.filter(Poll.subject.in_(subjects))
            q = q.options(eagerload(Poll.tallies))
            if not include_deleted:
                q = q.filter(or_(Poll.end_time == None,  # noqa
                                 Poll.end_time > datetime.utcnow()))
            return q.all()
        except Exception, e:
            log.exception("by_subjects(%s): %s" % (subjects, e), e)
            return []

    @classmethod
    def within_scope(cls, scope):
        def _crawl(scope):
            l = [scope]
            [l.extend(_crawl(c)) for c in scope.children]
            return l
        scope_ids = [s.id for s in _crawl(scope)]
        q = meta.Session.query(Poll)
        q = q.filter(Poll.scope_id.in_(scope_ids))
        q = q.filter(or_(Poll.end_time == None,  # noqa
                         Poll.end_time > datetime.utcnow()))
        return q.all()

    def to_dict(self):
        from adhocracy.lib import helpers as h
        return dict(id=self.id,
                    user=self.user.user_name,
                    action=self.action,
                    begin_time=self.begin_time,
                    end_time=self.end_time,
                    tally=self.tally,
                    url=h.entity_url(self),
                    scope=self.scope,
                    subject=self.subject)

    def __repr__(self):
        return u"<Poll(%s,%s,%s,%s)>" % (self.id,
                                         self.scope_id,
                                         self.begin_time,
                                         self.end_time)

########NEW FILE########
__FILENAME__ = proposal
import logging
from datetime import datetime

from sqlalchemy import Table, Column, ForeignKey, Integer, Boolean, or_
from sqlalchemy.orm import reconstructor, eagerload

import meta
import instance_filter as ifilter

from delegateable import Delegateable

log = logging.getLogger(__name__)


proposal_table = Table(
    'proposal', meta.data,
    Column('id', Integer, ForeignKey('delegateable.id'), primary_key=True),
    Column('description_id', Integer, ForeignKey('page.id'), nullable=True),
    Column('adopt_poll_id', Integer, ForeignKey('poll.id'), nullable=True),
    Column('rate_poll_id', Integer, ForeignKey('poll.id'), nullable=True),
    Column('adopted', Boolean, default=False),
    Column('is_amendment', Boolean, default=False)
)


class Proposal(Delegateable):

    def __init__(self, instance, label, creator):
        self.init_child(instance, label, creator)
        self._current_alternatives = None

    @reconstructor
    def _reconstruct(self):
        self._current_alternatives = None

    @property
    def selections(self):
        return [s for s in self._selections if not s.is_deleted()]

    @property
    def selection(self):
        assert(self.is_amendment)
        return self._selections[0]

    @property
    def title(self):
        if self.description is None or self.description.head is None:
            return self.label
        return self.description.title

    @property
    def full_title(self):
        return self.title

    def is_adopt_polling(self):
        return (self.adopt_poll is not None) and \
            (not self.adopt_poll.has_ended())

    def is_mutable(self):
        return (not self.is_adopt_polling()) and (not self.adopted) and \
            (not self.frozen) and (not self.instance.frozen)

    def is_frozen(self):
        return self.frozen

    def has_implementation(self):
        from text import Text
        for selection in self.selections:
            selected = selection.selected
            if selected is not None and selected != Text.HEAD:
                return True
        return False

    def can_adopt(self):
        return not self.is_adopt_polling() \
            and self.instance.allow_adopt \
            and (not self.instance.use_norms or self.has_implementation()) \
            and not self.adopted

    def adopt(self, at_time=None):
        from text import Text
        if at_time is None:
            at_time = datetime.utcnow()
        if not self.is_adopt_polling():
            return
        for selection in self.selections:
            selected = selection.selected
            if selected is None or selected == Text.HEAD:
                continue
            if selected not in selection.page.variants:
                continue
            source_text = selection.page.variant_at(selected,
                                                    self.adopt_poll.begin_time)
            dest_text = Text.create(selection.page,
                                    Text.HEAD,
                                    source_text.user,
                                    selection.page.head.title,
                                    source_text.text,
                                    parent=source_text,
                                    wiki=source_text.wiki)
            dest_text.create_time = at_time
        self.adopted = True
        meta.Session.commit()
        self.adopt_poll.end(at_time)
        meta.Session.flush()

    def get_creators(self):
        return set(text.user for text in self.description.head.history)

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False, full=False):
        try:
            q = meta.Session.query(Proposal)
            id = int(unicode(id).split('-', 1)[0])
            q = q.filter(Proposal.id == id)
            if full:
                q = q.options(eagerload(Proposal.comments))
                q = q.options(eagerload(Proposal.adopt_poll))
                q = q.options(eagerload(Proposal.rate_poll))
                q = q.options(eagerload(Proposal.taggings))
                q = q.options(eagerload(Proposal.parents))
            if ifilter.has_instance() and instance_filter:
                q = q.filter(Proposal.instance_id == ifilter.get_instance().id)
            if not include_deleted:
                q = q.filter(or_(Proposal.delete_time == None,  # noqa
                                 Proposal.delete_time > datetime.utcnow()))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def find_all(cls, ids, instance_filter=True, include_deleted=False):
        q = meta.Session.query(Proposal)
        q = q.filter(Proposal.id.in_(ids))
        if ifilter.has_instance() and instance_filter:
            q = q.filter(Proposal.instance_id == ifilter.get_instance().id)
        if not include_deleted:
            q = q.filter(or_(Proposal.delete_time == None,  # noqa
                             Proposal.delete_time > datetime.utcnow()))
        return q.all()

    @classmethod
    def find_by_creator(cls, user, instance_filter=True):
        q = meta.Session.query(Proposal)
        q = q.filter(Proposal.creator == user)
        q = q.filter(or_(Proposal.delete_time == None,  # noqa
                         Proposal.delete_time > datetime.utcnow()))
        if ifilter.has_instance() and instance_filter:
            q = q.filter(Proposal.instance_id == ifilter.get_instance().id)
        return q.all()

    @classmethod
    def all_q(cls, instance=None, include_deleted=False,
              include_not_in_list=False):
        q = meta.Session.query(Proposal)
        if not include_not_in_list:
            q = q.filter(Proposal.is_amendment == False)  # noqa
        if not include_deleted:
            q = q.filter(or_(Proposal.delete_time == None,  # noqa
                             Proposal.delete_time > datetime.utcnow()))
        if instance is not None:
            q = q.filter(Proposal.instance == instance)
        return q

    @classmethod
    def all(cls, instance=None, include_deleted=False):
        return cls.all_q(instance=instance,
                         include_deleted=include_deleted).all()

    @classmethod
    def create(cls, instance, label, user, with_vote=False, tags=None,
               is_amendment=False):
        from poll import Poll
        from tagging import Tagging
        proposal = Proposal(instance, label, user)
        if is_amendment:
            proposal.is_amendment = True
        meta.Session.add(proposal)
        meta.Session.flush()
        poll = Poll.create(proposal, user, Poll.RATE,
                           with_vote=with_vote)
        proposal.rate_poll = poll
        if tags is not None:
            proposal.taggings = Tagging.create_all(proposal, tags, user)
        meta.Session.flush()
        return proposal

    @classmethod
    def filter_by_state(cls, state, proposals):
        if state:
            filtered = []
            for proposal in proposals:
                if state == u'draft' and not proposal.is_adopt_polling() \
                        and not proposal.adopted:
                    filtered.append(proposal)
                elif state == u'polling' and proposal.is_adopt_polling():
                    filtered.append(proposal)
                elif state == u'adopted' and proposal.adopted:
                    filtered.append(proposal)
            return filtered

    def delete(self, delete_time=None):
        '''
        Delete the proposal and all it's selections
        (proposal-norm(page)-relations), but not the norms.
        '''
        if delete_time is None:
            delete_time = datetime.utcnow()

        # We don't want to delete the children of this
        # Delegateable cause these are the related norms.
        Delegateable.delete(self, delete_time=delete_time,
                            delete_children=False)

        if self.description:
            self.description.delete(delete_time=delete_time)

        for selection in self.selections:
            selection.delete(delete_time=delete_time)

    def comment_count(self):
        if not self.description:
            return 0
        return self.description.comment_count()

    def find_latest_comment_time(self):
        if not self.description:
            return None
        return self.description.find_latest_comment_time()

    def user_position(self, user):
        from pylons import tmpl_context as c
        if not user:
            return 0
        if not c.proposal_pos:
            c.proposal_pos = {}
            if self.id not in c.proposal_pos:
                c.proposal_pos[self.id] = c.user.any_position_on_proposal(self)
            return c.proposal_pos[self.id]

    def to_index(self):
        index = super(Proposal, self).to_index()
        if self.is_amendment:
            index['skip'] = True
            return index
        if self.description is not None and self.description.head is not None:
            index.update(dict(
                body=self.description.head.text,
            ))
        return index

    def __repr__(self):
        return u"<Proposal(%s)>" % self.id

########NEW FILE########
__FILENAME__ = refs
'''
Printable string references for model objects.

Functions to generate string references to model objects
(`@[<entity_type>:<id>]`) and resolve them back, where
`entity_type`
  is a string identifying the model class.
`id`
  is an id uniqe for a model instance within the entity_type

The module also provides helpers to work with url encoded
references and lists or dicts of references or model objects.
'''

from inspect import isclass
import logging
import re
import base64

from pylons.i18n import _

from badge import Badge
from badge import DelegateableBadge
from badge import CategoryBadge
from badge import ThumbnailBadge
from badge import InstanceBadge
from badge import UserBadge
from comment import Comment
from delegation import Delegation
from group import Group
from instance import Instance
from page import Page
from permission import Permission
from poll import Poll
from proposal import Proposal
from revision import Revision
from selection import Selection
from tag import Tag
from tagging import Tagging
from text import Text
from user import User
from vote import Vote
from milestone import Milestone
from message import Message


log = logging.getLogger(__name__)
undef_marker = object()

FORMAT = re.compile("@\[(.*):(.*)\]")

TYPES = [Vote,
         User,
         Group,
         Permission,
         Comment,
         Revision,
         Delegation,
         Proposal,
         Poll,
         Instance,
         Tag,
         Page,
         Selection,
         Text,
         Milestone,
         Tagging,
         Badge,
         DelegateableBadge,
         CategoryBadge,
         ThumbnailBadge,
         InstanceBadge,
         UserBadge,
         Message,
         ]


def entity_type(entity):
    return cls_type(type(entity))


def cls_type(cls):
    return unicode(cls.__name__.lower())


TYPES_MAP = dict((cls_type(t), t) for t in TYPES)


def entity_ref_attr_name(entity):
    '''
    Return the name of the attribute to use in references
    '''
    return getattr(entity, '_index_id_attr', 'id')


def ref_attr_value(entity_or_cls):
    '''
    Return the value (unicode) of the reference attribute (for model
    objects) or the :class:`sqlalchemy.orm.attributes.InstrumenteAttribute`
    object (for model classes)
    '''
    id_attr = entity_ref_attr_name(entity_or_cls)
    attr_value = getattr(entity_or_cls, id_attr, undef_marker)
    if attr_value is undef_marker:
            raise KeyError('Wrong index id attribute for object/class "%s": %s'
                           % (entity_or_cls, id_attr))
    if isclass(entity_or_cls):
        return attr_value
    else:
        return unicode(attr_value)


def to_ref(entity):
    '''Generate a string reference to a model object.
    The reference has the format `@[<entity_type>:<id>]`.
    Parameters:
    `entity`
       A model object that has a method `_index_id()` which returns
       a unique id across all instances of its model class. The object
       has to be an instance of one of the model classes in
       :data:`TYPES`
    Returns a `unicode` string reference if one can be generated
    or the passed in `entity` object if not.
    '''
    for cls in TYPES:
        if isinstance(entity, cls):
            return u"@[%s:%s]" % (entity_type(entity),
                                  ref_attr_value(entity))
    return None


def to_id(ref):
    match = FORMAT.match(unicode(ref))
    return match.group(2) if match else None


def ref_type(ref):
    match = FORMAT.match(unicode(ref))
    return match.group(1) if match else None


def to_entity(ref, instance_filter=False, include_deleted=True):
    '''Resolve a model object from a reference in the format
    `@[<entity_type>:<id>]`.
    `instance_filter`
       If `True` limit the search for the model instance to the
       `current` instance. The instance is determinated by
       :module:`adhocracy.model.instance_filter`.
    `include_deleted`
       If True also resolve to model objects that are already deleted.
    '''
    match = FORMAT.match(unicode(ref))
    if not match:
        return ref
    for cls in TYPES:
        if match.group(1) == cls_type(cls):
            entity = cls.find(match.group(2),
                              instance_filter=instance_filter,
                              include_deleted=include_deleted)
            # log.debug("entityref reloaded: %s" % repr(entity))
            return entity
    log.warn("No typeformatter for: %s" % ref)
    return ref


def to_entities(refs):
    '''
    Return the entities referenced by refs (see :func:`to_ref`).
    The entities are returned in the same order as refs

    *refs' (list of strings)
        A List of references

    Returns
        A list of Entities

    Raises
        :exc:`ValueError` if the refs do not reference the same entity
        type
    '''
    ids = {}
    for ref in refs:
        match = FORMAT.match(unicode(ref))
        if not match:
            continue
        refcls = match.group(1)
        refid = match.group(2)
        ids.setdefault(refcls, []).append(refid)

    all = {}
    for cls in ids:
        entity_class = TYPES_MAP[cls]
        entities = get_entities(entity_class, ids[cls], order=False)
        for entity in entities:
            all[to_ref(entity)] = entity

    return [all[ref] for ref in refs if ref in all]


def get_entities(entity_class, ids, order=True):
    '''
    Return all entities of the type *entity_class* where id is
    in *ids*.

    *entity_class*
       An slqalchemy model class.
    *ids* (list of int)
       A list of ids.
    *order* (boolean)
       Return the entities in the same order as *ids* (default: True)
    Returns
       A list of model objects
    '''

    if ids == []:
        return []

    from meta import Session
    db_mapper_attr = ref_attr_value(entity_class)
    q = Session.query(entity_class).filter(db_mapper_attr.in_(ids))

    if not order:
        return q.all()

    # order == True: get and order the results
    all_map = dict((str(ref_attr_value(entity)), entity) for entity in q.all())
    ordered_results = []
    for id_ in ids:
        entity = all_map.get(str(id_))
        if entity is not None:
            ordered_results.append(entity)
    return ordered_results


def to_url(entity):
    '''
    Generate a reference that encodes the reference to use in urls.
    See :func:`to_ref`.
    '''
    return base64.urlsafe_b64encode(str(to_ref(entity)))


def from_url(url):
    '''
    Resolve an url friendly encoded reference (see :func:`to_url`).
    See :func:`to_entity`. Note that default parameters of
    :func:`to_entity` are used.
    '''
    return to_entity(base64.urlsafe_b64decode(str(url)))


def _ify(fun, obj):
    if isinstance(obj, type([])):
        return [_ify(fun, e) for e in obj]
    elif isinstance(obj, type({})):
        return dict([(k, _ify(fun, v)) for k, v in obj.items()])
    else:
        if obj:
            obj = fun(obj)
            if not obj:
                obj = _("(Undefined)")
        return obj


def complex_to_refs(obj):
    '''Generate string references for list or dict containing model
    objects.
    `obj`
       A single model object or a lists or dicts of model objects.
    Returns a single reference or a list or dict of references.
    For details see :func:`to_ref`
    '''
    return _ify(to_ref, obj)


def complex_to_entities(refs):
    '''Resolve model instances from a list or dict of references.
    `refs`
      A list or dict of references.
    For details see :func:`to_entity'. Note that the default values
    for the additional parameter of `to_entity` will be used.
    '''
    return _ify(to_entity, refs)

########NEW FILE########
__FILENAME__ = requestlog
import logging
from datetime import datetime
from sqlalchemy import Table, Column
from sqlalchemy import Integer, Unicode, UnicodeText, DateTime
from adhocracy.model import meta

log = logging.getLogger(__name__)

requestlog_table = Table(
    'requestlog', meta.data,
    Column('id', Integer, primary_key=True),
    Column('access_time', DateTime, default=datetime.utcnow),
    Column('ip_address', Unicode(255), nullable=True),
    Column('request_url', UnicodeText()),
    Column('cookies', UnicodeText(), nullable=True),
    Column('user_agent', UnicodeText(), nullable=True),
    Column('referer', UnicodeText(), nullable=True),
)


class RequestLog(object):
    def __init__(self, access_time, ip_address, request_url, cookies,
                 user_agent, referer):
        self.id = None
        self.access_time = access_time
        self.ip_address = ip_address
        self.request_url = request_url
        self.cookies = cookies
        self.user_agent = user_agent
        self.referer = referer

    def to_dict(self):
        return {
            'id': self.id,
            'access_time': self.access_time,
            'ip_address': self.ip_address,
            'request_url': self.request_url,
            'cookies': self.cookies,
            'user_agent': self.user_agent,
            'referer': self.referer
        }

    @classmethod
    def create(cls, ip_address, request_url, cookies, user_agent, referer):
        entry = cls(datetime.utcnow(), ip_address, request_url, cookies,
                    user_agent, referer)
        meta.Session.add(entry)
        return entry

    @classmethod
    def all(cls):
        return meta.Session.query(cls).all()

########NEW FILE########
__FILENAME__ = revision
from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey
from sqlalchemy import Integer, UnicodeText, DateTime

import meta

log = logging.getLogger(__name__)

revision_table = Table(
    'revision', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('text', UnicodeText(), nullable=False),
    Column('sentiment', Integer, default=0),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('comment_id', Integer, ForeignKey('comment.id'), nullable=False),
)


class Revision(object):

    def __init__(self, comment, user, text):
        self.comment = comment
        self.user = user
        self.text = text

    @property
    def is_earliest(self):
        return self == min(self.comment.revisions, key=lambda r: r.create_time)

    @property
    def is_latest(self):
        return self.comment.latest.id == self.id

    @property
    def is_only(self):
        return len(self.comment.revisions) == 1

    @property
    def previous(self):
        if not self.is_earliest:
            smaller = filter(lambda r: r.create_time < self.create_time,
                             self.comment.revisions)
            return max(smaller, key=lambda r: r.create_time)

    @property
    def index(self):
        return len(self.comment.revisions) - self.comment.revisions.index(self)

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Revision)
            q = q.filter(Revision.id == id)
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    def to_dict(self):
        d = dict(id=self.id,
                 comment=self.comment_id,
                 create_time=self.create_time,
                 user=self.user.user_name,
                 text=self.text)
        return d

    def _index_id(self):
        return self.id

    def __repr__(self):
        return u"<Revision(%d,%s,%s)>" % (self.id,
                                          self.user.user_name,
                                          self.comment_id)

########NEW FILE########
__FILENAME__ = selection
from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey, PickleType
from sqlalchemy import Integer, DateTime, or_
from sqlalchemy.orm import reconstructor

from adhocracy.model.core import MutableList
import meta
import instance_filter as ifilter

log = logging.getLogger(__name__)


selection_table = Table(
    'selection', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('page_id', Integer, ForeignKey('page.id',
           name='selection_page', use_alter=True), nullable=True),
    Column('proposal_id', Integer, ForeignKey('proposal.id',
           name='selection_proposal', use_alter=True), nullable=True),
    Column('variants', MutableList.as_mutable(PickleType), nullable=True),
)


class Selection(object):

    def __init__(self, page, proposal, variant=None):
        '''
        Create a new Selection.

        page (:class:`adhocracy.model.page.Page`)
            The selected page
        proposal (:class:`adhocracy.mode.page.Page`)
            The proposal from which the page is selected
        variant `str`
            The variant for which the selection is valid
        '''
        from text import Text
        self.page = page
        self.proposal = proposal
        self._polls = None
        self.variants = [Text.HEAD]
        if variant is not None:
            self.variants.append(variant)

    @reconstructor
    def _reconstruct(self):
        self._polls = None

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        from proposal import Proposal
        try:
            q = meta.Session.query(Selection)
            q = q.filter(Selection.id == id)
            if not include_deleted:
                q = q.filter(or_(Selection.delete_time == None,  # noqa
                                 Selection.delete_time > datetime.utcnow()))
            if ifilter.has_instance() and instance_filter:
                q = q.join(Proposal)
                q = q.filter(Proposal.instance == ifilter.get_instance())
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def by_page(cls, page):
        return cls.by_page_and_proposal(page, None)

    @classmethod
    def by_variant(cls, page, variant, proposal=None):
        '''
        Return a list of selections for a *variant*. If a *proposal* is
        given, only the selections related to that *proposal* are returned.

        page:
            A :class:`adhocracy.model.page.Page` object
        variant (str):
            The variant name.
        proposal:
            A :class:`adhocracy.model.proposal.Proposal` object

        Returns: A `list` of :class:`adhocracy.model.selection.Selection`
        objects.
        '''
        selections = cls.by_page_and_proposal(page, proposal)
        return [selection for selection in selections if variant in
                selection.variants]

    @classmethod
    def by_page_and_proposal(cls, page, proposal):
        try:
            q = meta.Session.query(Selection)
            q = q.filter(Selection.page == page)
            if proposal is not None:
                q = q.filter(Selection.proposal == proposal)
            q = q.filter(or_(Selection.delete_time == None,  # noqa
                             Selection.delete_time > datetime.utcnow()))
            return q.all()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def by_key(cls, key, **kwargs):
        id = int(key.split(':', 1)[1].split(']', 1)[0])
        return cls.find(id, **kwargs)

    @classmethod
    def create(cls, proposal, page, user, variant=None):
        selections = cls.by_page_and_proposal(page, proposal)
        if len(selections):
            selection = selections[0]
            if variant is not None and variant not in selection.variants:
                selection.add_variant(variant)
                selection.make_variant_poll(variant, user)
            return selection
        selection = Selection(page, proposal, variant=variant)
        meta.Session.add(selection)
        page.parents.append(proposal)
        meta.Session.flush()
        for variant in page.variants:
            selection.make_variant_poll(variant, user)
        return selection

    def make_variant_poll(self, variant, user):
        from poll import Poll
        if variant not in self.variants:
            return None
        key = self.variant_key(variant)
        for poll in self.polls:
            if poll.subject == key:
                return poll
        poll = Poll.create(self.page, user, Poll.SELECT,
                           subject=key)
        if self._polls is not None:
            self._polls.append(poll)
        return poll

    def variant_key(self, variant):
        return "[@[selection:%d],\"%s\"]" % (self.id, variant)

    def add_variant(self, variant):
        assert variant in self.page.variants
        assert not self.by_variant(self.page, variant)
        if variant is None:
            return
        if variant in self.variants:
            return
        self.variants.append(variant)

    @property
    def subjects(self):
        variants = self.variants or []
        return [self.variant_key(v) for v in self.page.variants
                if v in variants]

    @property
    def polls(self):
        from poll import Poll
        if self._polls is None:
            self._polls = Poll.by_subjects(self.subjects)
        return self._polls

    @property
    def variant_polls(self):
        pairs = []
        for poll in self.polls:
            for variant in self.page.variants:
                if self.variant_key(variant) == poll.subject:
                    pairs.append((variant, poll))
        return sorted(pairs, key=lambda (k, v): v.tally.score, reverse=True)

    def variant_poll(self, variant):
        for (_variant, poll) in self.variant_polls:
            if variant == _variant:
                return poll
        return None

    @property
    def selected(self):
        from text import Text
        variant_polls = self.variant_polls
        if not len(variant_polls):
            return Text.HEAD
        sel_var, sel_poll = variant_polls[0]
        if len(variant_polls) > 1:
            next_var, next_poll = variant_polls[1]
            if sel_poll.tally.score == next_poll.tally.score:
                return None
        return sel_var

    @property
    def changes_text(self):
        from text import Text
        selected = self.selected
        if selected is None:
            return False
        if selected == Text.HEAD:
            return False
        return True

    def to_dict(self):
        d = dict(id=self.id,
                 create_time=self.create_time,
                 page=self.page.id,
                 proposal=self.proposal.id)
        return d

    def __repr__(self):
        id_ = self.proposal.id if self.proposal else "-"
        return u"<Selection(%d,%s,%s)>" % (self.id, self.page.id, id_)

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time
        for poll in self.polls:
            poll.end(delete_time)

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return ((self.delete_time is not None) and
                self.delete_time <= at_time)

########NEW FILE########
__FILENAME__ = shibboleth
from datetime import datetime

import logging

from sqlalchemy import Table, Column, ForeignKey
from sqlalchemy import DateTime, Integer, Unicode
import meta

log = logging.getLogger(__name__)


shibboleth_table = Table(
    'shibboleth', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('persistent_id', Unicode(255), nullable=False, unique=True,
           index=True),
)


class Shibboleth(object):

    def __init__(self, persistent_id, user):
        self.persistent_id = persistent_id
        self.user = user

########NEW FILE########
__FILENAME__ = staticpage
import logging

from sqlalchemy import Table, Column
from sqlalchemy import Unicode, UnicodeText

from adhocracy.model import meta

log = logging.getLogger(__name__)


staticpage_table = Table(
    'staticpage', meta.data,
    Column('key', Unicode(256), primary_key=True),
    Column('lang', Unicode(7), primary_key=True),
    Column('title', UnicodeText(), nullable=True),
    Column('body', UnicodeText()),
)


class StaticPageBase(object):

    private = False
    nav = u''
    description = u''
    column_right = u''
    css_classes = []
    redirect_url = u''

    def __init__(self, key, lang, body, title, private=False,
                 nav=u'', description=u'', column_right=u'', css_classes=[],
                 redirect_url=u''):
        self.key = key
        self.lang = lang
        self.title = title
        self.body = body
        self.private = private
        self.nav = nav
        self.description = description
        self.column_right = column_right
        self.css_classes = css_classes
        self.redirect_url = redirect_url

    @staticmethod
    def get(key, lang):
        raise NotImplementedError()

    def commit(self):
        """ Persist changes to this object. """
        raise NotImplementedError()

    @staticmethod
    def all():
        raise NotImplementedError()

    def save(self):
        raise NotImplementedError()

    @staticmethod
    def create(key, lang, title, body):
        raise NotImplementedError()

    @staticmethod
    def is_editable():
        return False

    def require_permission(self):
        """
        Backends can add additional permission checks.
        """
        if self.private:
            from adhocracy.lib.auth import require
            require.perm('static.show_private')


class StaticPage(StaticPageBase):

    @classmethod
    def get(cls, key, languages):
        """ Get the specified static page or None if it cannot be found """
        for lang in languages:
            q = meta.Session.query(cls)
            q = q.filter(cls.key == key, cls.lang == lang)
            if q.count():
                return q.first()
        return None

    @property
    def css_classes(self):
        # FIXME: check how css_classes are going to be used with database
        # staticpage backend
        return []

    @classmethod
    def create(cls, key, lang, title, body):
        s = StaticPage(key, lang, body, title)
        meta.Session.add(s)
        meta.Session.commit()
        return s

    @classmethod
    def all(cls):
        q = meta.Session.query(cls)
        return q.all()

    @staticmethod
    def is_editable():
        return True

    def commit(self):
        """ Persist changes to this object (interface for disk + database) """
        meta.Session.add(self)
        meta.Session.commit()

    def require_permission(self):
        return False

########NEW FILE########
__FILENAME__ = tag
from datetime import datetime
import logging

from sqlalchemy import Table, Column, Integer, Unicode, DateTime, func
from sqlalchemy.orm import reconstructor, aliased

import meta
import instance_filter as ifilter

log = logging.getLogger(__name__)


tag_table = Table(
    'tag', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('name', Unicode(255), nullable=False)
)


class Tag(object):

    def __init__(self, name):
        self.name = name
        self._count = None

    @reconstructor
    def _reconstruct(self):
        self._count = None

    def __repr__(self):
        return "<Tag(%s,%s)>" % (self.id, self.name.encode('ascii', 'replace'))

    def __unicode__(self):
        return self.name

    def __len__(self):
        if self._count is None:
            from tagging import Tagging
            from delegateable import Delegateable
            q = meta.Session.query(Tagging)
            q = q.filter(Tagging.tag == self)
            if ifilter.has_instance():
                q = q.join(Delegateable)
                q = q.filter(Delegateable.instance_id ==
                             ifilter.get_instance().id)
            self._count = q.count()
        return self._count

    count = property(__len__)

    def __le__(self, other):
        return self.name >= other.name

    def __lt__(self, other):
        return self.name > other.name

    @classmethod
    def by_id(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Tag)
            q = q.filter(Tag.id == id)
            return q.limit(1).first()
        except Exception, e:
            log.warn("by_id(%s): %s" % (id, e))
            return None

    @classmethod
    def find(cls, name, instance_filter=True, include_deleted=False):
        import adhocracy.lib.text as text
        name = text.tag_normalize(name)
        try:
            q = meta.Session.query(Tag)
            try:
                id = int(name)
                q = q.filter(Tag.id == id)
            except ValueError:
                q = q.filter(Tag.name.like(name))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s): %s" % (name, e))
            return None

    @classmethod
    def all(cls):
        return cls.all_q().all()

    @classmethod
    def all_q(cls):
        return meta.Session.query(Tag)

    @classmethod
    def popular_tags(cls, limit=None):
        from tagging import Tagging
        from delegateable import Delegateable
        q = meta.Session.query(Tag)
        q = q.add_column(func.count(Tagging.id))
        q = q.join(Tagging)
        if ifilter.has_instance():
            q = q.join(Delegateable)
            q = q.filter(Delegateable.instance_id == ifilter.get_instance().id)
        q = q.group_by(Tag.id, Tag.create_time, Tag.name)
        q = q.order_by(func.count(Tagging.id).desc())
        # SQLAlchemy turns this into a fucking subquery:
        # if limit is not None:
        #     q = q.limit(limit)
        # print "QUERY", q
        tags = [(k, v) for k, v in q.all() if v > 0]
        return tags[:limit]

    @classmethod
    def similar_tags(cls, tag, limit=None):
        from tagging import Tagging
        from delegateable import Delegateable
        q = meta.Session.query(Tag)
        q = q.add_column(func.count(Tagging.id))
        fst_tagging = aliased(Tagging)
        q = q.join(fst_tagging, Tag.taggings)
        q = q.join((Delegateable, fst_tagging.delegateable))
        snd_tagging = aliased(Tagging)
        q = q.join((snd_tagging, Delegateable.taggings))
        q = q.filter(snd_tagging.tag_id == tag.id)
        q = q.filter(Tag.id != tag.id)
        # q = q.filter(func.count(Tagging.id)>0)
        if ifilter.has_instance():
            q = q.filter(Delegateable.instance_id == ifilter.get_instance().id)
        q = q.group_by(Tag.id, Tag.create_time, Tag.name)
        q = q.order_by(func.count(Tagging.id).desc())
        # SQLAlchemy turns this into a fucking subquery:
        # if limit is not None:
        #     q = q.limit(limit)
        tags = [(k, v) for k, v in q.all() if v > 0]
        return tags[:limit]

    @classmethod
    def complete(cls, prefix, limit=5, instance_filter=True):
        from tagging import Tagging
        from delegateable import Delegateable
        q = meta.Session.query(Tag)
        q = q.add_column(func.count(Tagging.id))
        q = q.join(Tagging)
        q = q.filter(func.lower(Tag.name).like(prefix.lower() + "%"))
        if ifilter.has_instance() and instance_filter:
            q = q.join(Delegateable)
            q = q.filter(Delegateable.instance_id == ifilter.get_instance().id)
        q = q.group_by(Tag.id, Tag.create_time, Tag.name)
        q = q.order_by(func.count(Tagging.id).desc())
        # SQLAlchemy turns this into a fucking subquery:
        # if limit is not None:
        #     q = q.limit(limit)
        # print "QUERY", q
        return q.all()[:limit]

    @classmethod
    def create(cls, name):
        import adhocracy.lib.text as text
        tag = Tag(text.tag_normalize(name))
        meta.Session.add(tag)
        meta.Session.flush()
        return tag

    @classmethod
    def find_or_create(cls, name):
        tag = Tag.find(name)
        if tag is None:
            tag = Tag.create(name)
        return tag

    def is_deleted(self):
        return False

    def to_dict(self):
        from adhocracy.lib import helpers as h
        return dict(id=self.id,
                    name=self.name,
                    count=self.count,
                    url=h.entity_url(self))

########NEW FILE########
__FILENAME__ = tagging
from datetime import datetime
import logging

from sqlalchemy import Table, Column, Integer, ForeignKey, DateTime

import meta


log = logging.getLogger(__name__)


tagging_table = Table(
    'tagging', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('tag_id', Integer, ForeignKey('tag.id'), nullable=False),
    Column('delegateable_id', Integer, ForeignKey('delegateable.id'),
           nullable=False),
    Column('creator_id', Integer, ForeignKey('user.id'), nullable=False),
)


class Tagging(object):

    def __init__(self, delegateable, tag, creator):
        self.delegateable = delegateable
        self.tag = tag
        self.creator = creator

    def __repr__(self):
        tag = self.tag.name.encode('ascii', 'replace')
        return "<Tagging(%s,%s,%s,%s)>" % (self.id, self.delegateable.id,
                                           tag,
                                           self.creator.user_name)

    def delete(self):
        meta.Session.delete(self)
        meta.Session.flush()

    @classmethod
    def find_by_delegateable_name_creator(cls, delegateable, name, creator):
        import adhocracy.lib.text as text
        from tag import Tag
        name = text.tag_normalize(name)
        try:
            q = meta.Session.query(Tagging)
            q = q.filter(Tagging.creator == creator)
            q = q.filter(Tagging.delegateable == delegateable)
            q = q.join(Tag)
            q = q.filter(Tag.name.like(name))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find_by_delegateable_name_creator(%s): %s" % (id, e))
            return None

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        q = meta.Session.query(Tagging)
        q = q.filter(Tagging.id == id)
        # TODO: Instance filtering
        return q.limit(1).first()

    @classmethod
    def create(cls, delegateable, tag, creator):
        from tag import Tag
        if not isinstance(tag, Tag):
            tag = Tag.find_or_create(tag)
        tagging = Tagging(delegateable, tag, creator)
        meta.Session.add(tagging)
        meta.Session.flush()
        return tagging

    @classmethod
    def create_all(cls, delegateable, tags, creator):
        import adhocracy.lib.text as text
        return [Tagging.create(delegateable, t, creator)
                for t in text.tag_split(tags)]

########NEW FILE########
__FILENAME__ = tally
from datetime import datetime
import logging
from sets import Set

from sqlalchemy import Table, Column, Integer, ForeignKey, DateTime

import meta


log = logging.getLogger(__name__)


tally_table = Table(
    'tally', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('vote_id', Integer, ForeignKey('vote.id'), nullable=True),
    Column('num_for', Integer, nullable=True),
    Column('num_against', Integer, nullable=True),
    Column('num_abstain', Integer, nullable=True)
)


class Tally(object):
    '''
    Keep track of the current the number of votes in a poll.
    There to hold denormalized data available in polls.

    TODO: Move this information to solr where we index anyway?
    '''

    def __init__(self, poll, num_for, num_against, num_abstain):
        self.poll = poll
        self.num_for = num_for
        self.num_against = num_against
        self.num_abstain = num_abstain

    def _get_rel_for(self):
        base = self.num_for + self.num_against
        if base == 0:
            return 0.5
        return self.num_for / float(max(1, base))

    rel_for = property(_get_rel_for)

    def _get_rel_against(self):
        return 1 - self.rel_for

    rel_against = property(_get_rel_against)

    def _get_score(self):
        return self.num_for - self.num_against

    score = property(_get_score)

    @classmethod
    def create_from_vote(cls, vote):
        tally = cls.find_by_vote(vote)
        if tally is None:
            tally = Tally.create_from_poll(vote.poll, vote.create_time)
            tally.vote = vote
            meta.Session.flush()
        return tally

    @classmethod
    def create_from_poll(cls, poll, at_time=None, user_filter=None):
        from adhocracy.lib.democracy.tally import make_from_poll
        tally = make_from_poll(cls, poll, at_time=at_time,
                               user_filter=user_filter)
        meta.Session.add(tally)
        meta.Session.flush()
        return tally

    @classmethod
    def combine_polls(cls, polls, at_time=None):
        from adhocracy.lib.democracy import Decision
        from vote import Vote
        if at_time is None:
            at_time = datetime.utcnow()
        voters = {Vote.YES: Set(),
                  Vote.NO: Set(),
                  Vote.ABSTAIN: Set()}

        for poll in polls:
            for decision in Decision.for_poll(poll, at_time=at_time):
                if not decision.is_decided():
                    continue
                result = decision.result
                if result is not None:
                    voters_ = voters.get(result)
                    voters_.add(decision.user)

        # Do the math. We count only non-contradictory votes.
        yes = voters[Vote.YES]
        no = voters[Vote.NO]
        abstain = voters[Vote.ABSTAIN]
        return Tally(None,
                     len(yes - no - abstain),
                     len(no - yes - abstain),
                     len(abstain - yes - no))

    @classmethod
    def find_by_vote(cls, vote):
        q = meta.Session.query(Tally)
        q = q.filter(Tally.vote == vote)
        return q.limit(1).first()

    @classmethod
    def all_samples(cls, poll, start_time, end_time):
        qp = meta.Session.query(Tally)
        qp = qp.filter(Tally.poll == poll)
        qp = qp.filter(Tally.create_time <= end_time)
        qp = qp.filter(Tally.create_time >= start_time)
        qp = qp.order_by(Tally.create_time.asc())
        qp = qp.order_by(Tally.id.asc())
        qb = meta.Session.query(Tally)
        qb = qb.filter(Tally.poll == poll)
        qb = qb.filter(Tally.create_time < start_time)
        qb = qb.order_by(Tally.create_time.desc())
        qb = qb.order_by(Tally.id.desc())
        qb = qb.limit(1)
        # TODO fix this as a union query, but that requires
        # some parantheses that SQLalchemy will not set.
        return qb.all() + qp.all()

    def has_majority(self):
        quorum = self.poll.scope.instance.required_majority
        return self.rel_for > quorum

    def has_participation(self):
        quorum = self.poll.scope.instance.required_participation
        return len(self) >= quorum

    def __len__(self):
        return self.num_for + self.num_against + self.num_abstain

    def to_dict(self):
        return dict(id=self.id,
                    poll=self.poll_id,
                    score=self.score,
                    num_for=self.num_for,
                    num_against=self.num_against,
                    num_abstain=self.num_abstain)

    def _index_id(self):
        return self.id

    def __repr__(self):
        return "<Tally(%s,%s,%s,%d,%d,%d)>" % (self.id,
                                               self.poll_id,
                                               self.vote_id,
                                               self.num_for,
                                               self.num_against,
                                               self.num_abstain)

########NEW FILE########
__FILENAME__ = text
from datetime import datetime
import logging

from pylons.i18n import _
from sqlalchemy import Column, ForeignKey, Table, or_
from sqlalchemy import Boolean, Integer, Unicode, UnicodeText, DateTime

import meta

log = logging.getLogger(__name__)


text_table = Table(
    'text', meta.data,
    Column('id', Integer, primary_key=True),
    Column('page_id', Integer, ForeignKey('page.id'), nullable=False),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('child_id', Integer, ForeignKey('text.id'), nullable=True),
    Column('variant', Unicode(255), nullable=True),
    Column('title', Unicode(255), nullable=True),
    Column('text', UnicodeText(), nullable=True),
    Column('wiki', Boolean, default=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime)
)


class Text(object):

    HEAD = u'HEAD'
    LINE_LENGTH = 60

    def __init__(self, page, variant, user, title, text, wiki=False):
        self.page = page
        self.variant = variant
        self.user = user
        self.title = title
        self.text = text
        self.wiki = wiki

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Text)
            q = q.filter(Text.id == id)
            if not include_deleted:
                q = q.filter(or_(Text.delete_time == None,  # noqa
                                 Text.delete_time > datetime.utcnow()))
            return q.first()
        except Exception, e:
            log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def create(cls, page, variant, user, title, text, parent=None, wiki=False):
        if variant is None:
            if parent is not None:
                variant = parent.variant
            else:
                variant = Text.HEAD

        variant_is_new = variant not in page.variants
        _text = Text(page, variant, user, title, text, wiki)
        if parent:
            _text.parent = parent
        meta.Session.add(_text)
        meta.Session.flush()
        if variant_is_new:
            page.establish_variant(variant, user)
        return _text

    def history_q(self, include_deleted=False):
        texts_q = meta.Session.query(Text).filter(
            Text.page_id == self.page_id, Text.variant == self.variant)
        if not include_deleted:
            texts_q = texts_q.filter(
                or_(Text.delete_time == None,  # noqa
                    Text.delete_time > datetime.now()))
        return texts_q

    @property
    def history(self, include_deleted=False):
        return self.history_q().all()

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return ((self.delete_time is not None) and
                self.delete_time <= at_time)

    def valid_parent(self):
        parent = self.parent
        if parent is not None and parent.is_deleted():
            return parent.valid_parent()
        else:
            return parent

    def valid_child(self):
        child = self.child
        if child is not None and child.is_deleted():
            return child.valid_child()
        else:
            return child

    def render(self, line_based=False):
        from adhocracy.lib import text
        if line_based:
            return text.render_line_based(self)
        else:
            return text.render(self.text)

    @property
    def lines(self):
        from webhelpers.text import truncate
        if self.text is None:
            return
        for line in self.text.strip().split("\n"):
            while len(line.rstrip()) > self.LINE_LENGTH:
                part = truncate(line, length=self.LINE_LENGTH, indicator='',
                                whole_word=True)
                line = line[len(part):]
                line = line.lstrip()
                yield part
            yield line

    @property
    def lines_text(self):
        return '\n'.join(self.lines)

    @property
    def has_text(self):
        return self.text is not None and len(self.text.strip()) > 0

    @property
    def variant_name(self):
        if self.is_head:
            return _("Status Quo")
        return self.variant

    @property
    def variant_html(self):
        import cgi
        variant_name = cgi.escape(self.variant_name)
        if self.is_head:
            return "<em class='varname status_quo'>%s</em>" % variant_name
        return"<code class='varname'>%s</code>" % variant_name

    @property
    def is_head(self):
        return self.variant == self.HEAD

    def to_dict(self):
        from adhocracy.lib import helpers as h
        d = dict(id=self.id,
                 page_id=self.page.id,
                 url=h.entity_url(self),
                 create_time=self.create_time,
                 text=self.text,
                 variant=self.variant,
                 title=self.title,
                 wiki=self.wiki,
                 user=self.user.user_name)
        if self.parent:
            d['parent'] = self.parent.id
        return d

    def __repr__(self):
        variant_str = self.variant.encode('ascii', 'replace')
        return u"<Text(%s, %s, %s)>" % (self.id, variant_str,
                                        self.user.user_name)

########NEW FILE########
__FILENAME__ = treatment
from sqlalchemy import Table, Column
from sqlalchemy import Integer, Unicode, ForeignKey
from adhocracy.model.badge import UserBadge
from adhocracy.model import meta

treatment_table = Table(
    'treatment', meta.data,
    Column('id', Integer, primary_key=True),
    Column('key', Unicode(40), nullable=False, unique=True),
    Column('variant_count', Integer, nullable=False),
)


class Treatment(object):
    def __init__(self, key, source_badges, variant_count):
        self.key = key
        self.source_badges = source_badges
        self.variant_count = variant_count

    @classmethod
    def create(cls, key, source_badges, variant_count):
        entry = cls(key, source_badges, variant_count)
        for i in range(variant_count):
            UserBadge.create(title=u'treatment-%s-%s' % (key, i),
                             color=u'', visible=False, description=u'')
        meta.Session.add(entry)
        meta.Session.flush()
        return entry

    @classmethod
    def find(cls, key):
        q = meta.Session.query(cls)
        q = q.filter(cls.key == key)
        return q.first()

    @classmethod
    def all(cls):
        q = meta.Session.query(cls)
        return sorted(q.all(), key=lambda t: t.key)

    @property
    def _variant_badges(self):
        return [self.get_variant_badge(i) for i in range(self.variant_count)]

    def get_assigned_users(self):
        """ Return a list(with one element for each variant) of the lists of
        assigned users. """
        return [vb.users for vb in self._variant_badges]

    def get_variant_badge(self, variant_id):
        return UserBadge.find('treatment-%s-%s' % (self.key, variant_id))

    def __repr__(self):
        return (u'<%s.%s(id=%r, key=%r, %r)>' %
                (self.__module__, type(self).__name__,
                 self.id, self.key, self.variant_count))


treatment_source_badges_table = Table(
    'treatment_source_badges', meta.data,
    Column('treatment_id', Integer,
           ForeignKey('treatment.id', ondelete='CASCADE')),
    Column('badge_id', Integer,
           ForeignKey('badge.id', ondelete='CASCADE')),
)

########NEW FILE########
__FILENAME__ = twitter
from datetime import datetime
import logging

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import DateTime, Integer, Unicode

import meta

log = logging.getLogger(__name__)


twitter_table = Table(
    'twitter', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('twitter_id', Integer),
    Column('key', Unicode(255), nullable=False),
    Column('secret', Unicode(255), nullable=False),
    Column('screen_name', Unicode(255), nullable=False),
    Column('priority', Integer, default=4)
)


class Twitter(object):

    def __init__(self, twitter_id, user, screen_name, key, secret):
        self.twitter_id = twitter_id
        self.user = user
        self.screen_name = screen_name
        self.key = key
        self.secret = secret

    @classmethod
    def find(cls, screen_name, include_deleted=False):
        try:
            q = meta.Session.query(Twitter)
            q = q.filter(Twitter.screen_name == screen_name)
            if not include_deleted:
                q = q.filter(or_(Twitter.delete_time == None,  # noqa
                                 Twitter.delete_time > datetime.utcnow()))
            return q.one()
        except Exception, e:
            log.warn("find(%s): %s" % (screen_name, e))
            return None

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time

    def __repr__(self):
        return u"<Twitter(%d,%d,%s,%s)>" % (self.id,
                                            self.twitter_id,
                                            self.user.user_name,
                                            self.screen_name)

########NEW FILE########
__FILENAME__ = user
from copy import copy
import hashlib
import os
import logging
from datetime import datetime

from babel import Locale
from pylons.i18n import _

from sqlalchemy import Table, Column, func, or_
from sqlalchemy import Boolean, DateTime, Integer, Unicode, UnicodeText
from sqlalchemy.orm import eagerload_all

from adhocracy import config
from adhocracy.model import meta
from adhocracy.model import instance_filter as ifilter
from adhocracy.model.core import JSONEncodedDict
from adhocracy.model.core import MutationDict
from adhocracy.model.instance import Instance

log = logging.getLogger(__name__)


user_table = Table(
    'user', meta.data,
    Column('id', Integer, primary_key=True),
    Column('user_name', Unicode(255), nullable=False, unique=True, index=True),
    Column('display_name', Unicode(255), nullable=True, index=True),
    Column('bio', UnicodeText(), nullable=True),
    Column('email', Unicode(255), nullable=True, unique=True),
    Column('email_priority', Integer, default=3),
    Column('activation_code', Unicode(255), nullable=True, unique=False),
    Column('reset_code', Unicode(255), nullable=True, unique=False),
    Column('password', Unicode(80), nullable=True),
    Column('locale', Unicode(7), nullable=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('access_time', DateTime, default=datetime.utcnow,
           onupdate=datetime.utcnow),
    Column('delete_time', DateTime),
    Column('banned', Boolean, default=False),
    Column('no_help', Boolean, default=False, nullable=True),
    Column('page_size', Integer, default=10, nullable=True),
    Column('proposal_sort_order', Unicode(50), default=None, nullable=True),
    Column('gender', Unicode(1), default=None),
    Column('_is_organization', Boolean, default=False),
    Column('email_messages', Boolean, default=True),
    Column('welcome_code', Unicode(255), nullable=True),
    Column('optional_attributes', MutationDict.as_mutable(JSONEncodedDict)),
)


class User(meta.Indexable):

    IMPORT_MARKER = 'i__'

    def __init__(self, user_name, email, password, locale, display_name=None,
                 bio=None):
        self.user_name = user_name
        self.email = email
        self.password = password
        self.locale = locale
        self.display_name = display_name
        self.bio = bio
        self.banned = False

    @property
    def name(self):
        if self.delete_time:
            return self.user_name
        if self.display_name and len(self.display_name.strip()) > 0:
            return self.display_name.strip()
        return self.user_name

    def _get_locale(self):
        if not self._locale:
            return None
        return Locale.parse(self._locale)

    def _set_locale(self, locale):
        self._locale = unicode(locale)

    locale = property(_get_locale, _set_locale)

    def _get_email(self):
        return self._email

    def _set_email(self, email):
        import adhocracy.lib.util as util
        if not self._email == email:
            self.activation_code = util.random_token()
        self._email = email

    email = property(_get_email, _set_email)

    @property
    def email_hash(self):
        return hashlib.sha1(self.email).hexdigest()

    @property
    def is_organization(self):
        allow = config.get_bool('adhocracy.allow_organization')
        return allow and self._is_organization

    def badge_groups(self):
        current_instance = ifilter.get_instance()
        groups = []
        for badge in self.badges:
            group = badge.group
            if (group is not None and group not in groups
               and badge.instance in [None, current_instance]):
                groups.append(group)
        return groups

    def get_badges(self, instance=None):
        """
        Get user badges which are appropriate in the given context.
        """
        return [b for b in self.badges if b.instance is None
                or b.instance is instance]

    def membership_groups(self):
        from membership import Membership
        current_instance = ifilter.get_instance()

        memberships_q = meta.Session.query(Membership).filter(
            Membership.user_id == self.id)

        if current_instance is None:
            memberships_q = memberships_q.filter(
                Membership.instance_id == None)  # noqa
        else:
            memberships_q = memberships_q.filter(or_(
                Membership.instance_id == None,  # noqa
                Membership.instance_id == current_instance.id
            ))

        memberships = memberships_q.all()
        return [m.group for m in memberships if not m.is_expired()]

    @property
    def groups(self):
        return list(set(self.badge_groups() + self.membership_groups()))

    def instance_groups(self):
        return filter(lambda g: g.is_instance_group(), self.groups)

    def _has_permission(self, permission_name):
        for group in self.groups:
            for perm in group.permissions:
                if perm.permission_name == permission_name:
                    return True
        return False

    def instance_membership(self, instance):
        if not instance:
            return None

        from membership import Membership
        memberships = meta.Session.query(Membership).filter(
            Membership.user_id == self.id,
            Membership.instance_id == instance.id)\
            .all()
        for membership in memberships:
            if not membership.is_expired():
                return membership
        return None

    def is_member(self, instance):
        return self.instance_membership(instance) is not None

    @property
    def instances(self):
        return self.get_instances()

    def get_instances(self, include_hidden=False):
        instances = []
        for membership in self.memberships:
            if (not membership.is_expired()) and \
                    (membership.instance is not None) and \
                    (include_hidden or not membership.instance.hidden):
                instances.append(membership.instance)
        return list(set(instances))

    def real_instances(self, exclude_current=False):
        excluded_keys = copy(Instance.SPECIAL_KEYS)
        if exclude_current:
            current_instance = ifilter.get_instance()
            if current_instance is not None:
                excluded_keys.append(ifilter.get_instance().key)
        return sorted(
            filter(lambda i: i.key not in excluded_keys, self.instances),
            key=lambda i: i.key)

    @property
    def twitter(self):
        for twitter in self.twitters:
            if not twitter.is_deleted():
                return twitter
        return None

    @property
    def openids(self):
        _ids = []
        for openid in self._openids:
            if not openid.is_deleted():
                _ids.append(openid)
        return _ids

    @property
    def velruse(self):
        _ids = []
        for velruse in self._velruse:
            if not velruse.is_deleted():
                _ids.append(velruse)
        return _ids

    @property
    def num_watches(self):
        from watch import Watch
        q = meta.Session.query(Watch)
        q = q.filter(Watch.user == self)
        q = q.filter(or_(Watch.delete_time == None,  # noqa
                         Watch.delete_time >= datetime.utcnow()))
        return q.count()

    def _set_password(self, password):
        """Hash password on the fly."""
        if isinstance(password, unicode):
            password_8bit = password.encode('ascii', 'ignore')
        else:
            password_8bit = password

        salt = hashlib.sha1(os.urandom(60))
        hash = hashlib.sha1(password_8bit + salt.hexdigest())
        hashed_password = salt.hexdigest() + hash.hexdigest()

        if not isinstance(hashed_password, unicode):
            hashed_password = hashed_password.decode('utf-8')
        self._password = hashed_password

        # Invalidate temporary password recovery codes
        self.reset_code = None
        self.welcome_code = None

    def _get_password(self):
        """Return the password hashed"""
        return self._password

    def validate_password(self, password):
        """
        Check the password against existing credentials.

        :param password: the password that was provided by the user to
            try and authenticate. This is the clear text version that we will
            need to match against the hashed one in the database.
        :type password: unicode object.
        :return: Whether the password is valid.
        :rtype: bool
        """
        if self.password is None:
            return False
        if isinstance(password, unicode):
            password_8bit = password.encode('ascii', 'ignore')
        else:
            password_8bit = password
        if self.banned or self.delete_time:
            return False
        hashed_pass = hashlib.sha1(password_8bit + self.password[:40])
        return self.password[40:] == hashed_pass.hexdigest()

    password = property(_get_password, _set_password)

    def initialize_welcome(self):
        """ Sign up the user for the welcome feature (on user import or so) """
        import adhocracy.lib.util as util
        self.welcome_code = util.random_token()
        self._password = None

    def current_agencies(self, instance_filter=True):
        ds = filter(lambda d: not d.is_revoked(), self.agencies)
        if ifilter.has_instance() and instance_filter:
            ds = filter(lambda d: d.scope.instance == ifilter.get_instance(),
                        ds)
        return ds

    def current_delegated(self, instance_filter=True):
        ds = filter(lambda d: not d.is_revoked(), self.delegated)
        if ifilter.has_instance() and instance_filter:
            ds = filter(lambda d: d.scope.instance == ifilter.get_instance(),
                        ds)
        return ds

    @classmethod
    def complete(cls, prefix, limit=5, instance_filter=True):
        q = meta.Session.query(User)
        prefix = prefix.lower()
        q = q.filter(or_(func.lower(User.user_name).like(prefix + u"%"),
                         func.lower(User.display_name).like(prefix + u"%")))
        q = q.limit(limit)
        completions = q.all()
        if ifilter.has_instance() and instance_filter:
            inst = ifilter.get_instance()
            completions = filter(lambda u: u.is_member(inst), completions)
        return completions

    @classmethod
    # @meta.session_cached
    def find(cls, user_name, instance_filter=True, include_deleted=False):
        from membership import Membership
        try:
            q = meta.Session.query(User)
            try:
                q = q.filter(User.id == int(user_name))
            except ValueError:
                q = q.filter(User.user_name == unicode(user_name))
            if not include_deleted:
                q = q.filter(or_(User.delete_time == None,  # noqa
                                 User.delete_time > datetime.utcnow()))
            if ifilter.has_instance() and instance_filter:
                q = q.join(Membership)
                q = q.filter(or_(Membership.expire_time == None,  # noqa
                                 Membership.expire_time > datetime.utcnow()))
                q = q.filter(Membership.instance == ifilter.get_instance())
            return q.limit(1).first()
        except Exception, e:
            log.debug("find(%s): %s" % (user_name, e))
            return None

    @classmethod
    def find_by_email(cls, email, include_deleted=False):
        return cls.all_q(None, include_deleted)\
            .filter(func.lower(User.email) == unicode(email).lower())\
            .limit(1).first()

    @classmethod
    def find_by_user_name(cls, user_name, include_deleted=False):
        return cls.find(user_name, include_deleted=include_deleted)

    @classmethod
    def find_by_shibboleth(cls, persistent_id, include_deleted=False):
        from shibboleth import Shibboleth
        return cls.all_q(None, include_deleted)\
            .join(Shibboleth)\
            .filter(Shibboleth.persistent_id == persistent_id)\
            .limit(1).first()

    @classmethod
    def find_all(cls, unames, instance_filter=True, include_deleted=False):
        from membership import Membership
        q = meta.Session.query(User)
        q = q.filter(User.user_name.in_(unames))
        if not include_deleted:
            q = q.filter(or_(User.delete_time == None,  # noqa
                             User.delete_time > datetime.utcnow()))
        if ifilter.has_instance() and instance_filter:
            q = q.join(Membership)
            q = q.filter(or_(Membership.expire_time == None,  # noqa
                             Membership.expire_time > datetime.utcnow()))
            q = q.filter(Membership.instance == ifilter.get_instance())
        # log.debug("QueryAll: %s" % q)
        # log.debug("LEN: %s" % len(q.all()))
        return q.all()

    _index_id_attr = 'user_name'

    @classmethod
    def all_q(cls, instance=None, include_deleted=False):
        from membership import Membership
        q = meta.Session.query(User)
        if not include_deleted:
            q = q.filter(or_(User.delete_time == None,  # noqa
                             User.delete_time > datetime.utcnow()))
        if instance:
            q = q.options(eagerload_all('memberships'))
            q = q.join(Membership)
            q = q.filter(or_(Membership.expire_time == None,  # noqa
                             Membership.expire_time > datetime.utcnow()))
            q = q.filter(Membership.instance == instance)
        return q

    @classmethod
    def all(cls, instance=None, include_deleted=False):
        return cls.all_q(instance=instance,
                         include_deleted=include_deleted).all()

    def delete(self, delete_time=None):
        from watch import Watch

        if delete_time is None:
            delete_time = datetime.utcnow()
        self.revoke_delegations()
        for twitter in self.twitters:
            twitter.delete(delete_time=delete_time)
        for openid in self.openids:
            openid.delete(delete_time=delete_time)
        for velruse in self.velruse:
            velruse.delete(delete_time=delete_time)
        for comment in self.comments:
            comment.delete(delete_time=delete_time)
        for membership in self.memberships:
            membership.delete(delete_time=delete_time)
        for watch in Watch.all_by_user(self):
            watch.delete(delete_time=delete_time)

        # for vote in self.votes:
        #     vote.delete(delete_time=delete_time)
        self.delete_time = delete_time

    def undelete(self):
        from watch import Watch

        for twitter in self.twitters:
            twitter.delete_time = None
        for openid in self.openids:
            openid.delete_time = None
        for velruse in self.velruse:
            velruse.delete_time = None
        for comment in self.comments:
            comment.delete_time = None
        for membership in self.memberships:
            membership.expire_time = None
        for watch in Watch.all_by_user(self):
            watch.delete_time = None

        self.delete_time = None

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return ((self.delete_time is not None) and
                self.delete_time <= at_time)

    def revoke_delegations(self, instance=None):
        from delegation import Delegation
        q = meta.Session.query(Delegation)
        q = q.filter(or_(Delegation.agent == self,
                         Delegation.principal == self))
        q = q.filter(or_(Delegation.revoke_time == None,  # noqa
                         Delegation.revoke_time > datetime.utcnow()))
        for delegation in q:
            if instance is None or delegation.scope.instance == instance:
                delegation.revoke()

    def is_email_activated(self):
        return self.email is not None and self.activation_code is None

    def set_email_verified(self):
        # for adhocracy, None means email is verified
        self.activation_code = None
        meta.Session.commit()

    def delegation_node(self, scope):
        from adhocracy.lib.democracy import DelegationNode
        return DelegationNode(self, scope)

    def number_of_votes_in_scope(self, scope):
        """
        May be a bit too much as multiple delegations are counted for each user
        they are delegated to. (This is the safety net delegation)
        """
        if not self._has_permission('vote.cast'):
            return 0
        return self.delegation_node(scope).number_of_delegations() + 1

    def position_on_poll(self, poll):
        from adhocracy.lib.democracy.decision import Decision
        return Decision(self, poll).result

    def any_position_on_proposal(self, proposal):
        # this is fuzzy since it includes two types of opinions
        from adhocracy.lib.democracy.decision import Decision
        if proposal.adopt_poll:
            dec = Decision(self, proposal.adopt_poll)
            if dec.is_decided():
                return dec.result
        if proposal.rate_poll:
            return Decision(self, proposal.rate_poll).result

    @classmethod
    def create(cls, user_name, email, password=None, locale=None,
               openid_identity=None, global_admin=False, display_name=None,
               autojoin=True, shibboleth_persistent_id=None):
        """
        Create a user. If user_name is None, a random user name is generated.
        """
        from group import Group
        from membership import Membership

        import adhocracy.lib.util as util
        if password is None:
            password = util.random_token()

        import adhocracy.i18n as i18n
        if locale is None:
            locale = i18n.get_default_locale()

        while user_name is None:
            # Note: This can theoretically lead to IntegrityErrors if the same
            # username is generated at the same time. This is very unlikely
            # though.
            from adhocracy.lib.util import random_username
            try_user_name = random_username()
            if cls.find(try_user_name) is None:
                user_name = try_user_name
                from adhocracy.lib import helpers as h
                h.flash(_('The random username %s has been assigned to you.') %
                        user_name, 'success')

        user = User(user_name, email, password, locale,
                    display_name=display_name)
        meta.Session.add(user)

        # Add the global default group
        default_group = Group.by_code(Group.CODE_DEFAULT)
        default_membership = Membership(user, None, default_group)
        meta.Session.add(default_membership)

        # Autojoin the user in instances
        config_autojoin = config.get('adhocracy.instances.autojoin')
        if autojoin and config_autojoin:
            instances = Instance.all(include_hidden=True)
            if config_autojoin != 'ALL':
                instance_keys = [key.strip() for key in
                                 config_autojoin.split(",")]
                instances = [instance for instance in instances
                             if instance.key in instance_keys]
            for instance in instances:
                autojoin_membership = Membership(user, instance,
                                                 instance.default_group)
                meta.Session.add(autojoin_membership)

        if global_admin:
            admin_group = Group.by_code(Group.CODE_ADMIN)
            admin_membership = Membership(user, None, admin_group)
            meta.Session.add(admin_membership)

        if openid_identity is not None:
            from adhocracy.model.openid import OpenID
            openid = OpenID(unicode(openid_identity), user)
            meta.Session.add(openid)

        if shibboleth_persistent_id is not None:
            from adhocracy.model.shibboleth import Shibboleth
            shib = Shibboleth(shibboleth_persistent_id, user)
            meta.Session.add(shib)

        meta.Session.flush()
        return user

    def to_dict(self):
        from adhocracy.lib import helpers as h
        d = dict(id=self.id,
                 user_name=self.user_name,
                 locale=self._locale,
                 url=h.entity_url(self),
                 create_time=self.create_time,
                 mbox=self.email_hash)
        if self.display_name:
            d['display_name'] = self.display_name
        if self.bio:
            d['bio'] = self.bio
        # d['memberships'] = map(lambda m: m.instance.key,
        #                        self.memberships)
        return d

    def to_index(self):
        index = super(User, self).to_index()

        index.update(dict(
            title=self.name,
            tag=[self.user_name],
            body=self.bio,
            user=self.user_name,
        ))
        return index

    def __repr__(self):
        return u"<User(%s,%s)>" % (self.id, self.user_name)

    @property
    def title(self):
        return self.name

########NEW FILE########
__FILENAME__ = velruse
from datetime import datetime

import logging

from sqlalchemy import Table, Column, ForeignKey, or_, UniqueConstraint
from sqlalchemy import DateTime, Integer, Unicode

import meta

log = logging.getLogger(__name__)


velruse_table = Table(
    'velruse', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('domain', Unicode(255), nullable=False, index=True),
    Column('domain_user', Unicode(255), nullable=False, index=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    UniqueConstraint('domain', 'domain_user', name='unique_velruse_user'),
)


def filter_deleted(q):
    return q.filter(or_(Velruse.delete_time == None,  # noqa
                    Velruse.delete_time > datetime.utcnow()))


class Velruse(object):

    def __init__(self, domain, domain_user, adhocracy_user):
        self.domain = domain
        self.domain_user = domain_user
        self.user = adhocracy_user

    @classmethod
    def find(cls, domain, domain_user, include_deleted=False):
        try:
            q = meta.Session.query(Velruse)
            q = q.filter(Velruse.domain == domain,
                         Velruse.domain_user == domain_user)
            if not include_deleted:
                q = filter_deleted(q)
            return q.one()
        except Exception as e:
            log.debug("find(%s, %s): %s" % (domain, domain_user, e))
            return None

    @classmethod
    def find_any(cls, accounts, include_deleted=False):
        for account in accounts:
            velruse_account = Velruse.find(account['domain'],
                                           account['userid'],
                                           include_deleted)
            if velruse_account is not None:
                return velruse_account

        return None

    @classmethod
    def by_id(cls, id, include_deleted=False):
        try:
            q = meta.Session.query(Velruse)
            q = q.filter(Velruse.id == id)
            if not include_deleted:
                q = filter_deleted(q)
            return q.limit(1).first()
        except Exception as e:
            log.exception("by_id(%s): %s" % (id, e))
            return None

    @classmethod
    def by_user_and_domain(cls, user, domain, include_deleted=False):
        try:
            q = meta.Session.query(Velruse)
            q = q.filter(Velruse.user_id == user.id,
                         Velruse.domain == domain)
            if not include_deleted:
                q = filter_deleted(q)
            return q.all()
        except Exception as e:
            log.exception("by_user_and_domain(%s, %s): %s" % (user, domain, e))
            return None

    @classmethod
    def by_user_and_domain_first(cls, user, domain, include_deleted=False):
        try:
            q = meta.Session.query(Velruse)
            q = q.filter(Velruse.user_id == user.id,
                         Velruse.domain == domain)
            if not include_deleted:
                q = filter_deleted(q)
            return q.limit(1).first()
        except Exception as e:
            log.exception("by_user_and_domain_first(%s, %s): %s"
                          % (user, domain, e))
            return None

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if self.delete_time is None:
            self.delete_time = delete_time

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return (self.delete_time is not None) and \
            self.delete_time <= at_time

    def delete_forever(self):
        try:
            meta.Session.delete(self)
        except Exception as e:
            log.exception("delete_forever: %s" % e)
            return None

    @classmethod
    def connect(cls, adhocracy_user, domain, domain_user,
                velruse_email, email_verified=False):
        """
        Connect existing adhocracy user to velruse.
        """

        v = Velruse(unicode(domain), unicode(domain_user), adhocracy_user)

        if email_verified and velruse_email == adhocracy_user.email:
            adhocracy_user.set_email_verified()

        meta.Session.add(v)

        return v

    def __repr__(self):
        return u"<Velruse(%d,%s,%s,%s)>" % (self.id,
                                            self.domain,
                                            self.domain_user,
                                            self.user.user_name)

########NEW FILE########
__FILENAME__ = vote
from datetime import datetime
import logging

from sqlalchemy import Table, Column, Integer, ForeignKey, DateTime

import meta
import instance_filter as ifilter


log = logging.getLogger(__name__)


vote_table = Table(
    'vote', meta.data,
    Column('id', Integer, primary_key=True),
    Column('orientation', Integer, nullable=False),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('poll_id', Integer, ForeignKey('poll.id'), nullable=False),
    Column('delegation_id', Integer, ForeignKey('delegation.id'),
           nullable=True)
)


class Vote(object):
    # REFACT: Not voted yet is expressed as None in varous places
    # Might be nice to have an explicit value for that
    YES = 1L
    NO = -1L
    ABSTAIN = 0L

    def __init__(self, user, poll, orientation, delegation=None):
        self.user = user
        self.poll = poll
        self.orientation = orientation
        self.delegation = delegation

    @classmethod
    def find(cls, id, instance_filter=True, include_deleted=False):
        try:
            q = meta.Session.query(Vote)
            q = q.filter(Vote.id == int(id))
            vote = q.first()
            if ifilter.has_instance() and instance_filter:
                vote = vote.poll.scope.instance == ifilter.get_instance() \
                    and vote or None
            return vote
        except Exception, e:
            log.exception(e)
            # log.warn("find(%s): %s" % (id, e))
            return None

    @classmethod
    def all_q(cls):
        return meta.Session.query(Vote)

    @classmethod
    def all(cls):
        return cls.all_q().all()

    def to_dict(self):
        return dict(id=self.id,
                    user=self.user_id,
                    poll=self.poll_id,
                    result=self.orientation,
                    create_time=self.create_time,
                    delegation=self.delegation_id)

    def __repr__(self):
        return "<Vote(%s,%s,%s,%s,%s)>" % (
            self.id,
            self.user.user_name,
            self.poll.id,
            self.orientation,
            self.delegation.id if self.delegation else "DIRECT")

########NEW FILE########
__FILENAME__ = votedetail
from sqlalchemy import Table, Column
from sqlalchemy import Integer, ForeignKey
from adhocracy.model import meta

votedetail_table = Table(
    'votedetail', meta.data,
    Column('instance_id', Integer,
           ForeignKey('instance.id', ondelete='CASCADE')),
    Column('badge_id', Integer,
           ForeignKey('badge.id', ondelete='CASCADE')),
)

########NEW FILE########
__FILENAME__ = watch
import logging
from datetime import datetime

from sqlalchemy import Table, Column, ForeignKey, or_
from sqlalchemy import DateTime, Integer, Unicode
from sqlalchemy.orm import reconstructor

import meta
import refs

log = logging.getLogger(__name__)


watch_table = Table(
    'watch', meta.data,
    Column('id', Integer, primary_key=True),
    Column('create_time', DateTime, default=datetime.utcnow),
    Column('delete_time', DateTime, nullable=True),
    Column('user_id', Integer, ForeignKey('user.id'), nullable=False),
    Column('entity_type', Unicode(255), nullable=False, index=True),
    Column('entity_ref', Unicode(255), nullable=False, index=True)
)


class Watch(object):

    def __init__(self, user, entity):
        self.user = user
        self._entity = None
        self.entity = entity

    @reconstructor
    def _reconstruct(self):
        self._entity = None

    def _get_entity(self):
        if self._entity is None:
            self._entity = refs.to_entity(self.entity_ref)
        return self._entity

    def _set_entity(self, entity):
        self._entity = entity
        self.entity_ref = refs.to_ref(entity)
        self.entity_type = refs.entity_type(entity)

    entity = property(_get_entity, _set_entity)

    @classmethod
    def by_id(cls, id, include_deleted=False):
        try:
            q = meta.Session.query(Watch)
            q = q.filter(Watch.id == id)
            if not include_deleted:
                q = q.filter(or_(Watch.delete_time == None,  # noqa
                                 Watch.delete_time > datetime.utcnow()))
            return q.limit(1).first()
        except:
            return None

    @classmethod
    def find_by_entity(cls, user, entity, include_deleted=False):
        return Watch.find(user, refs.to_ref(entity),
                          include_deleted=include_deleted)

    @classmethod
    def find(cls, user, ref, include_deleted=False):
        try:
            q = meta.Session.query(Watch)
            q = q.filter(Watch.user == user)
            q = q.filter(Watch.entity_ref == ref)
            if not include_deleted:
                q = q.filter(or_(Watch.delete_time == None,  # noqa
                                 Watch.delete_time > datetime.utcnow()))
            return q.limit(1).first()
        except Exception, e:
            log.warn("find(%s:%s): %s" % (user, ref, e))

    @classmethod
    def all_by_entity(self, entity):
        q = meta.Session.query(Watch)
        q = q.filter(Watch.entity_ref == refs.to_ref(entity))
        q = q.filter(or_(Watch.delete_time == None,  # noqa
                         Watch.delete_time > datetime.utcnow()))
        return q.all()

    @classmethod
    def all_by_user(self, user):
        q = meta.Session.query(Watch)
        q = q.filter(Watch.user == user)
        q = q.filter(or_(Watch.delete_time == None,  # noqa
                         Watch.delete_time > datetime.utcnow()))
        return q.all()

    @classmethod
    def all(cls, include_deleted=False):
        q = meta.Session.query(Watch)
        if not include_deleted:
            q = q.filter(or_(Watch.delete_time == None,  # noqa
                             Watch.delete_time > datetime.utcnow()))
        return q.all()

    @classmethod
    def create(cls, user, entity, check_existing=False):
        if check_existing and cls.find_by_entity(user, entity):
            raise WatchAlreadyExists()
        watch = cls(user, entity)
        meta.Session.add(watch)
        meta.Session.flush()
        return watch

    def delete(self, delete_time=None):
        if delete_time is None:
            delete_time = datetime.utcnow()
        if not self.is_deleted(delete_time):
            self.delete_time = delete_time

    def is_deleted(self, at_time=None):
        if at_time is None:
            at_time = datetime.utcnow()
        return ((self.delete_time is not None) and
                self.delete_time <= at_time)

    def __repr__(self):
        return "<Watch(%s,%s,%s)>" % (self.id, self.user.user_name,
                                      self.entity_ref)


class WatchAlreadyExists(Exception):
    pass

########NEW FILE########
__FILENAME__ = test_decision
from adhocracy.lib.democracy import Decision
from adhocracy.model import Poll, Vote

from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_get_instance
from adhocracy.tests.testtools import tt_make_proposal, tt_make_user


class TestDecisionWithoutDelegation(TestController):

    def setUp(self):
        super(TestDecisionWithoutDelegation, self).setUp()
        self.proposal = tt_make_proposal(voting=True)
        self.poll = Poll.create(self.proposal, self.proposal.creator,
                                Poll.ADOPT)
        self.decision = Decision(self.proposal.creator, self.poll)

    def test_new_decisions_have_no_votes(self):
        self.assertEqual(len(self.decision.votes), 0)
        self.assertEqual(len(self.decision.relevant_votes), 0)
        self.assertEqual(self.decision.result, None,
                         "Not voted yet == not recorded for quorum")
        # TODO: this quorum thing needs additional tests

    def test_new_decisions_are_not_decided(self):
        self.assertFalse(self.decision.is_decided())
        self.assertFalse(self.decision.is_self_decided())

    def test_can_vote_directly(self):
        self.decision.make(Vote.YES)
        self.assertEqual(self.decision.result, Vote.YES)

    def test_decision_with_a_vote_is_decided(self):
        self.decision.make(Vote.YES)
        self.assertTrue(self.decision.is_decided())
        self.assertTrue(self.decision.is_self_decided())

    def test_can_override_previous_choice(self):
        self.decision.make(Vote.YES)
        self.assertEqual(self.decision.result, Vote.YES)
        self.decision.make(Vote.ABSTAIN)
        self.assertEqual(self.decision.result, Vote.ABSTAIN)
        self.decision.make(Vote.NO)
        self.assertEqual(self.decision.result, Vote.NO)

    def test_direct_votes_always_have_only_one_relevant_vote(self):
        self.decision.make(Vote.YES)
        self.decision.make(Vote.NO)
        self.decision.make(Vote.ABSTAIN)
        self.assertEqual(len(self.decision.relevant_votes), 1)

    # History access

    def test_multiple_votes_for_one_decision_are_recorded_for_posterity(self):
        self.decision.make(Vote.YES)
        self.decision.make(Vote.YES)
        self.assertEqual(len(self.decision.votes), 2)

    def test_old_decisions_can_be_retrieved(self):
        self.decision.make(Vote.YES)
        self.decision.make(Vote.YES)
        self.decision.make(Vote.NO)
        # votes are FIFO
        self.assertEqual(self.decision.votes[0].orientation, Vote.NO)
        self.assertEqual(self.decision.votes[1].orientation, Vote.YES)
        self.assertEqual(self.decision.votes[2].orientation, Vote.YES)


class TestDecisionWithDelegation(TestController):

    def setUp(self):
        super(TestDecisionWithDelegation, self).setUp()
        self.me = tt_make_user(name='me')
        self.high_delegate = tt_make_user(name='high_delegate')
        self.low_delegate = tt_make_user(name='low_delegate')

        self.proposal = tt_make_proposal(creator=self.me, voting=True)
        self.poll = Poll.create(self.proposal, self.proposal.creator,
                                Poll.ADOPT)
        self.decision = Decision(self.me, self.poll)
        self.instance = tt_get_instance()

    def _do_delegate(self, from_user, delegatee, scope):
        from adhocracy.model.delegation import Delegation
        delegation = Delegation.create(from_user, delegatee, scope)
        return delegation

    def test_delegation_without_vote_is_no_vote(self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        self.decision.reload()
        self.assertEqual(len(self.decision.votes), 0)
        self.assertFalse(self.decision.is_decided())
        self.assertEqual(self.decision.result, None)

    def test_can_do_general_delegate_to_other_user(self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        self.assertEqual(self.decision.reload().result, Vote.YES)

    def test_delegation_can_decide_a_decision(self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        self.decision.reload()
        self.assertTrue(self.decision.is_decided())

    def test_delegated_decisions_are_not_self_decided(self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        self.decision.reload()
        self.assertFalse(self.decision.is_self_decided())

    def test_two_delegations_at_the_same_level_that_disagree_cancel_each_other(
            self):
        # This is meant as a safeguard: if I don't fully trust my delegates
        # I can delegate to n delegates, and my vote will only be autocast
        # if they all agree
        # If not, I need to decide myself
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        self._do_delegate(self.me, self.low_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        Decision(self.low_delegate, self.poll).make(Vote.NO)
        self.assertEqual(self.decision.reload().result, None,
                         "needs to cast his own vote")

    def test_two_delegations_at_the_same_level_that_agree_reinforce_each_other(
            self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        self._do_delegate(self.me, self.low_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        Decision(self.low_delegate, self.poll).make(Vote.YES)
        self.assertEqual(self.decision.reload().result, Vote.YES)

    def test_two_delegations_at_the_same_level_are_both_relevant_votes(self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        self._do_delegate(self.me, self.low_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        Decision(self.low_delegate, self.poll).make(Vote.YES)
        self.assertEqual(len(self.decision.reload().relevant_votes), 2)

    def test_own_vote_overrides_delegations(self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        self.decision.make(Vote.NO)
        self.assertEqual(self.decision.reload().result, Vote.NO)

    def test_delegation_is_recorded_as_just_another_vote(self):
        self._do_delegate(self.me, self.high_delegate, self.proposal)
        self.assertEqual(len(self.decision.reload().votes), 0)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        self.assertEqual(len(self.decision.reload().votes), 1)

    def test_delegation_is_transitive(self):
        self._do_delegate(self.me, self.low_delegate, self.proposal)
        self._do_delegate(self.low_delegate, self.high_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        self.assertEqual(self.decision.reload().result, Vote.YES)

    def test_delegation_is_transitive_across_delegation_levels(self):
        self._do_delegate(self.me, self.low_delegate, self.proposal)
        self._do_delegate(self.low_delegate, self.high_delegate, self.proposal)
        Decision(self.high_delegate, self.poll).make(Vote.YES)
        self.assertEqual(self.decision.reload().result, Vote.YES)


# TODO: can access history of delegation decisions
# TODO: test replay - this is currently in the decision -
# TODO: could go to the DelegationNode though
# TODO: can delegate on all levels

########NEW FILE########
__FILENAME__ = test_delegation_node
from adhocracy import model
from adhocracy.lib.democracy import Decision, DelegationNode
from adhocracy.model import Delegation, Group, Poll, Vote

from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_get_instance
from adhocracy.tests.testtools import tt_make_proposal, tt_make_user


class TestDelegationNode(TestController):

    def setUp(self):
        super(TestDelegationNode, self).setUp()
        self.me = tt_make_user()
        self.first = tt_make_user()
        self.second = tt_make_user()
        self.proposal = tt_make_proposal(voting=True)
        self.poll = Poll.create(self.proposal, self.proposal.creator,
                                Poll.ADOPT)
        self.instance = tt_get_instance()

    def _do_delegate(self, from_user, delegatee, scope):
        delegation = Delegation.create(from_user, delegatee, scope)
        return delegation

    def test_knows_to_whom_a_delegation_went(self):
        self._do_delegate(self.me, self.first, self.proposal)
        delegations = DelegationNode(self.me, self.proposal)
        self.assertEqual(len(delegations.outbound()), 1)

    def test_can_get_direct_delegations(self):
        self._do_delegate(self.me, self.first, self.proposal)
        delegations = DelegationNode(self.first, self.proposal)
        self.assertEqual(len(delegations.inbound()), 1)

    def test_can_get_indirect_delegations(self):
        self._do_delegate(self.me, self.first, self.proposal)
        self._do_delegate(self.first, self.second, self.proposal)
        delegations = DelegationNode(self.second, self.proposal)
        self.assertEqual(len(delegations.inbound()), 1)
        self.assertEqual(len(delegations.transitive_inbound()), 2)

    def test_mutual_delegation_is_not_counted_as_direct_delegation(self):
        self._do_delegate(self.first, self.second, self.proposal)
        self._do_delegate(self.second, self.first, self.proposal)
        delegations = DelegationNode(self.first, self.proposal)
        self.assertEqual(len(delegations.inbound()), 1)

    def test_mutual_delegation_gives_two_votes_each(self):
        self._do_delegate(self.first, self.second, self.proposal)
        self._do_delegate(self.second, self.first, self.proposal)

        delegations = DelegationNode(self.first, self.proposal)
        self.assertEqual(len(delegations.transitive_inbound()), 1)
        delegations = DelegationNode(self.second, self.proposal)
        self.assertEqual(len(delegations.transitive_inbound()), 1)

    def test_delegation_is_not_used_if_user_has_voted_directly(self):
        self._do_delegate(self.first, self.second, self.proposal)
        self._do_delegate(self.second, self.first, self.proposal)
        Decision(self.second, self.poll).make(Vote.NO)
        Decision(self.first, self.poll).make(Vote.YES)

        self.assertEqual(Decision(self.second, self.poll).is_self_decided(),
                         True)
        self.assertEqual(Decision(self.second, self.poll).result,
                         Vote.NO)

    def test_delegation_node_with_no_delegations_has_no_delegations(self):
        node = DelegationNode(self.me, self.proposal)
        self.assertEqual(node.number_of_delegations(), 0)

    def test_delegation_node_adds_direct_delegations_to_number_of_delegations(
            self):
        self._do_delegate(self.first, self.me, self.proposal)
        self._do_delegate(self.second, self.me, self.proposal)
        node = DelegationNode(self.me, self.proposal)
        self.assertEqual(node.number_of_delegations(), 2)

    def test_delegation_node_ads_indirect_delegation_to_number_of_delegations(
            self):
        self._do_delegate(self.first, self.me, self.proposal)
        self._do_delegate(self.second, self.first, self.proposal)
        node = DelegationNode(self.me, self.proposal)
        self.assertEqual(node.number_of_delegations(), 2)

    def test_if_mutual_delegation_is_broken_breaker_gets_one_delegation(self):
        self._do_delegate(self.first, self.second, self.proposal)
        self._do_delegate(self.second, self.first, self.proposal)
        Decision(self.first, self.poll).make(Vote.YES)

        node = DelegationNode(self.first, self.proposal)
        self.assertEqual(node.number_of_delegations(), 1)

    def test_if_mutual_delegation_is_broken_other_guy_has_no_delegation(self):
        self._do_delegate(self.first, self.second, self.proposal)
        self._do_delegate(self.second, self.first, self.proposal)
        Decision(self.first, self.poll).make(Vote.YES)
        node = DelegationNode(self.first, self.proposal)
        self.assertEqual(node.number_of_delegations(), 1)

    def test_if_proposal_has_no_poll_no_direct_vote_overides_delegations(self):
        proposal_without_poll = tt_make_proposal()
        self._do_delegate(self.first, self.second,
                          proposal_without_poll)
        node = DelegationNode(self.second, proposal_without_poll)
        self.assertEqual(node.number_of_delegations(), 1)


class TestInteractionOfDelegationOnDifferentLevels(TestController):

    def setUp(self):
        super(TestInteractionOfDelegationOnDifferentLevels, self).setUp()
        voter_group = Group.by_code(Group.CODE_VOTER)
        self.me = tt_make_user(instance_group=voter_group)
        self.first = tt_make_user(instance_group=voter_group)
        self.second = tt_make_user(instance_group=voter_group)
        self.proposal = tt_make_proposal(voting=True)

    def _do_delegate(self, from_user, delegatee, scope):
        delegation = Delegation.create(from_user, delegatee, scope)
        return delegation

    def test_direct_delegations_on_different_levels_can_overide_each_other(
            self):
        # FIXME: refactor this test. we don't have issues anymore
        #        Doe we have this case anymore?
        return
        self._do_delegate(self.me, self.first, self.proposal.issue)
        self._do_delegate(self.me, self.second, self.proposal)
        self.assertEqual(self.first.number_of_votes_in_scope(self.proposal), 1)

    def test_user_with_two_delegations_gets_counted_for_each_delegator(self):
        self._do_delegate(self.me, self.first, self.proposal)
        self._do_delegate(self.me, self.second, self.proposal)
        self.assertEqual(
            self.first.number_of_votes_in_scope(self.proposal), 2)
        self.assertEqual(
            self.second.number_of_votes_in_scope(self.proposal), 2)

    def test_delegations_to_different_ppl_are_counted_for_each_delegaton(self):
        self._do_delegate(self.me, self.first, self.proposal)
        self._do_delegate(self.me, self.second, self.proposal)
        self.assertEqual(
            self.first.number_of_votes_in_scope(self.proposal), 2)
        self.assertEqual(
            self.second.number_of_votes_in_scope(self.proposal), 2)

    def test_queries(self):
        proposal = tt_make_proposal(voting=True)
        user1 = tt_make_user()
        user2 = tt_make_user()
        user3 = tt_make_user()

        d1to2 = Delegation(user1, user2, proposal)
        model.meta.Session.add(d1to2)
        model.meta.Session.flush()

        dn = DelegationNode(user1, proposal)
        self.assertEqual(len(dn.outbound()), 1)

        dn = DelegationNode(user1, proposal)
        self.assertEqual(len(dn.outbound()), 1)

        dn = DelegationNode(user2, proposal)
        self.assertEqual(len(dn.inbound()), 1)

        dn = DelegationNode(user2, proposal)
        self.assertEqual(len(dn.inbound()), 1)

        d3to2 = Delegation(user3, user2, proposal)
        model.meta.Session.add(d3to2)
        model.meta.Session.flush()

        dn = DelegationNode(user2, proposal)
        self.assertEqual(len(dn.inbound()), 2)

        dn = DelegationNode(user2, proposal)
        self.assertEqual(len(dn.inbound(recurse=False)), 2)

    def test_propagate(self):
        proposal = tt_make_proposal(voting=True)
        user1 = tt_make_user()
        user2 = tt_make_user()
        user3 = tt_make_user()
        user4 = tt_make_user()
        userA = tt_make_user()

        d2to1 = Delegation(user2, user1, proposal)
        model.meta.Session.add(d2to1)

        dAto1 = Delegation(userA, user1, proposal)
        model.meta.Session.add(dAto1)

        d3to2 = Delegation(user3, user2, proposal)
        model.meta.Session.add(d3to2)

        d4to3 = Delegation(user4, user3, proposal)
        model.meta.Session.add(d4to3)
        model.meta.Session.flush()

        dn = DelegationNode(user1, proposal)
        assert len(dn.inbound()) == 2

        def inp(user, deleg, edge):
            return "foo"
        assert len(dn.propagate(inp)) == 5

    def test_detach(self):
        proposal = tt_make_proposal(voting=True)
        user1 = tt_make_user()
        user2 = tt_make_user()
        user3 = tt_make_user()

        d2to1 = Delegation(user2, user1, proposal)
        model.meta.Session.add(d2to1)

        d3to1 = Delegation(user3, user1, proposal)
        model.meta.Session.add(d3to1)
        model.meta.Session.flush()

        dn = DelegationNode(user1, proposal)
        assert len(dn.inbound()) == 2

        user1.revoke_delegations(tt_get_instance())

        dn = DelegationNode(user1, proposal)
        assert len(dn.inbound()) == 0

    def test_filter(self):
        # FIXME: refactor this test. we don't have issues anymore
        return
        proposal = tt_make_proposal(voting=True)
        user1 = tt_make_user()
        user2 = tt_make_user()
        user3 = tt_make_user()

        small = Delegation(user1, user2, proposal)
        model.meta.Session.add(small)

        large = Delegation(user1, user3, proposal.issue)
        model.meta.Session.add(large)
        model.meta.Session.flush()

        res = DelegationNode.filter_less_specific_delegations([small, large])
        assert small in res
        assert large not in res


# TODO: delegated an isue to a user and again a proposal inside that
# TODO: issue to the same user: make sure he only gets the right ammount of
# TODO: delegations
# TODO: add delegation_weight() method
# TODO: circular delegation should be handled correctly

# What I'd like to have as an api would be:
# first.vote(self.proposal).yes()
# TODO: when delegating to multiple people, how much weight do they get
# TODO: to give when they delegate? Hopefully not each +1...
# TODO: how is the split delegation handled across multiple levels?
# TODO: I think they just override each other
# when delegating on different levels, the delegation wheight of
# each delegation-target depends on the context...

# Delegation and voting are not two methods on the same object
# I guess thats the reason why it slipped that casting a vote actually
# needs to override / cancel any delegation for that user

# What happens when a user wants to retract him voting so his
# delegations do it again for him?
# May be hard right now as not having voted is imo not explicitly
# represented in the model

# TODO: user has two outgoing delegations on one level
# who gets how much votes? everybody gets the vote
# but in an actual poll this needs to be prevented

########NEW FILE########
__FILENAME__ = test_poll
from adhocracy.model import Poll, Vote

from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_proposal, tt_make_user


class TestPoll(TestController):

    def test_begin_end(self):
        proposal = tt_make_proposal(voting=False)
        poll = Poll.create(proposal, proposal.creator, Poll.ADOPT)
        poll.end()
        self.assertTrue(poll.has_ended())

    def test_vote_by_creator(self):
        from adhocracy.lib.democracy import Decision
        proposal = tt_make_proposal(voting=True)
        poll = proposal.polls[0]
        self.assertEqual(0, len(list(poll.votes)))
        decision = Decision(proposal.creator, poll)
        votes = decision.make(Vote.YES)
        self.assertEqual(len(votes), 1)
        self.assertEqual(len(decision.votes), 1)
        self.assertEqual(votes[0].orientation, Vote.YES)
        self.assertEqual(votes[0].user, proposal.creator)

    def test_second_identical_vote(self):
        from adhocracy.lib.democracy import Decision
        proposal = tt_make_proposal(voting=True)
        poll = proposal.polls[0]
        self.assertEqual(0, len(list(poll.votes)))
        decision = Decision(proposal.creator, poll)
        votes = decision.make(Vote.YES)
        self.assertEqual(len(votes), 1)
        self.assertEqual(len(decision.votes), 1)
        self.assertEqual(len(poll.votes), 1)

        # a second, identical vote by the same user
        decision = Decision(proposal.creator, poll)
        votes = decision.make(Vote.YES)
        self.assertEqual(len(votes), 1)
        self.assertEqual(len(decision.votes), 2)
        self.assertEqual(len(poll.votes), 2)

    def test_second_revised_vote(self):
        from adhocracy.lib.democracy import Decision
        proposal = tt_make_proposal(voting=True)
        poll = proposal.polls[0]
        self.assertEqual(0, len(list(poll.votes)))
        decision = Decision(proposal.creator, poll)
        votes = decision.make(Vote.YES)
        self.assertEqual(len(votes), 1)
        self.assertEqual(len(decision.votes), 1)
        self.assertEqual(len(poll.votes), 1)
        self.assertEqual(votes[0].orientation, Vote.YES)

        # a second, revised vote by the same user
        decision = Decision(proposal.creator, poll)
        votes = decision.make(Vote.NO)
        self.assertEqual(len(decision.votes), 2)
        self.assertEqual(len(poll.votes), 2)
        self.assertEqual(votes[0].orientation, Vote.NO)

    def test_vote_by_other_user(self):
        from adhocracy.lib.democracy import Decision
        proposal = tt_make_proposal(voting=True)
        poll = proposal.polls[0]
        self.assertEqual(0, len(list(poll.votes)))

        # make a new user and let him vote
        new_user = tt_make_user()
        decision = Decision(new_user, poll)
        votes = decision.make(Vote.YES)
        self.assertEqual(len(votes), 1)
        self.assertEqual(len(decision.votes), 1)
        self.assertEqual(len(poll.votes), 1)
        self.assertEqual(votes[0].orientation, Vote.YES)

# REFACT: enable the proposal to be able to have many polls in parallel

########NEW FILE########
__FILENAME__ = fanstatic_dummy_module
from fanstatic import Resource, Group, Library

library = Library('dummy', '.')
library.need = lambda: 'No, sorry, that is a Library.'

resource = Resource(library, 'fanstatic_dummy_resource.css')
resource.need = lambda: 'needed resource'

group = Group([resource])
group.need = lambda: 'needed group'

########NEW FILE########
__FILENAME__ = test_event
from adhocracy.tests import TestController


class TestEvent(TestController):

    pass

########NEW FILE########
__FILENAME__ = test_fanstatic
from unittest import TestCase


class TestFanstaticHelpers(TestCase):

    def test_resource(self):
        from adhocracy.lib.helpers.fanstatic_helper import FanstaticNeedHelper
        import fanstatic_dummy_module
        need = FanstaticNeedHelper(fanstatic_dummy_module)
        result = need.resource
        self.assertEqual(result, 'needed resource')

    def test_group(self):
        from adhocracy.lib.helpers.fanstatic_helper import FanstaticNeedHelper
        import fanstatic_dummy_module
        need = FanstaticNeedHelper(fanstatic_dummy_module)
        result = need.group
        self.assertEqual(result, 'needed group')

    def test_not_group_or_resource(self):
        from adhocracy.lib.helpers.fanstatic_helper import FanstaticNeedHelper
        import fanstatic_dummy_module
        need = FanstaticNeedHelper(fanstatic_dummy_module)
        self.assertRaises(ValueError, getattr, need, 'library')

    def test_non_existent_resource(self):
        from adhocracy.lib.helpers.fanstatic_helper import FanstaticNeedHelper
        import fanstatic_dummy_module
        need = FanstaticNeedHelper(fanstatic_dummy_module)
        self.assertRaises(AttributeError, getattr, need, 'nonexistant')

########NEW FILE########
__FILENAME__ = test_helper
# -*- coding: utf-8 -*-
from adhocracy.tests import TestController


TEST_IMAGE = (
    b'GIF89a\x10\x00\x10\x00\xd5\x00\x00\xff\xff\xff\xff\xff\xfe\xfc\xfd\xfd'
    b'\xfa\xfb\xfc\xf7\xf9\xfa\xf5\xf8\xf9\xf3\xf6\xf8\xf2\xf5\xf7\xf0\xf4\xf6'
    b'\xeb\xf1\xf3\xe5\xed\xef\xde\xe8\xeb\xdc\xe6\xea\xd9\xe4\xe8\xd7\xe2\xe6'
    b'\xd2\xdf\xe3\xd0\xdd\xe3\xcd\xdc\xe1\xcb\xda\xdf\xc9\xd9\xdf\xc8\xd8\xdd'
    b'\xc6\xd7\xdc\xc4\xd6\xdc\xc3\xd4\xda\xc2\xd3\xd9\xc1\xd3\xd9\xc0\xd2\xd9'
    b'\xbd\xd1\xd8\xbd\xd0\xd7\xbc\xcf\xd7\xbb\xcf\xd6\xbb\xce\xd5\xb9\xcd\xd4'
    b'\xb6\xcc\xd4\xb6\xcb\xd3\xb5\xcb\xd2\xb4\xca\xd1\xb2\xc8\xd0\xb1\xc7\xd0'
    b'\xb0\xc7\xcf\xaf\xc6\xce\xae\xc4\xce\xad\xc4\xcd\xab\xc3\xcc\xa9\xc2\xcb'
    b'\xa8\xc1\xca\xa6\xc0\xc9\xa4\xbe\xc8\xa2\xbd\xc7\xa0\xbb\xc5\x9e\xba\xc4'
    b'\x9b\xbf\xcc\x98\xb6\xc1\x8d\xae\xbaFgs\x00\x00\x00\x00\x00\x00\x00\x00'
    b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    b'\x00,\x00\x00\x00\x00\x10\x00\x10\x00\x00\x06z@\x80pH,\x12k\xc8$\xd2f'
    b'\x04\xd4\x84\x01\x01\xe1\xf0d\x16\x9f\x80A\x01\x91\xc0ZmL\xb0\xcd\x00V'
    b'\xd4\xc4a\x87z\xed\xb0-\x1a\xb3\xb8\x95\xbdf8\x1e\x11\xca,MoC$\x15\x18{'
    b'\x006}m\x13\x16\x1a\x1f\x83\x85}6\x17\x1b $\x83\x00\x86\x19\x1d!%)\x8c'
    b'\x866#\'+.\x8ca`\x1c`(,/1\x94B5\x19\x1e"&*-024\xacNq\xba\xbb\xb8h\xbeb'
    b'\x00A\x00;'
)


class TestBadgeHelper(TestController):

    def test_generate_thumbnail_tag_no_color_no_thumb_attr(self):
        from adhocracy.model import ThumbnailBadge
        from adhocracy.lib.helpers.badge_helper import generate_thumbnail_tag
        badge = ThumbnailBadge.create(u'testbadge0', u'', True, u'descr')
        image = generate_thumbnail_tag(badge)
        self.assert_(b'b96ZYAAAAASUVORK5CYII=' in image)

    def test_generate_thumbnail_tag_with_color_attr(self):
        from adhocracy.model import ThumbnailBadge
        from adhocracy.lib.helpers.badge_helper import generate_thumbnail_tag
        badge = ThumbnailBadge.create(u'testbadge0', u'#ccc', True, u'descr')
        image = generate_thumbnail_tag(badge)
        self.assert_(b'Afb96ZYAAAAASUVORK5CYII=' in image)

    def test_generate_thumbnail_tag_with_thumb_attr(self):
        from adhocracy.model import ThumbnailBadge
        from adhocracy.lib.helpers.badge_helper import generate_thumbnail_tag
        badge = ThumbnailBadge.create(u'testbadge0', u'#ccc', True, u'descr')
        badge.thumbnail = TEST_IMAGE
        image = generate_thumbnail_tag(badge)
        self.assert_(b'VWyKXFMAAAAASUVORK5CYII=' in image)

    def test_generate_thumbnail_tag_set_size(self):
        from adhocracy.model import ThumbnailBadge, Instance
        from adhocracy.lib.helpers.badge_helper import generate_thumbnail_tag
        instance = Instance.find(u'test')
        badge = ThumbnailBadge.create(u'testbadge0', u'', True, u'descr')
        badge.instance = instance
        image = generate_thumbnail_tag(badge)
        self.assert_(u'width="48"' in image)
        self.assert_(u'height="48"' in image)
        instance.thumbnailbadges_width = 10
        instance.thumbnailbadges_height = 12
        image = generate_thumbnail_tag(badge)
        self.assert_(u'height="12"' in image)
        self.assert_(u'width="10"' in image)
        image = generate_thumbnail_tag(badge, width=8, height=11)
        self.assert_(u'height="11"' in image)
        self.assert_(u'width="8"' in image)

    def test_generate_thumbnail_cache(self):
        from adhocracy.model import ThumbnailBadge
        from adhocracy.lib.helpers.badge_helper import generate_thumbnail_tag
        badge = ThumbnailBadge.create(u'testbadge0', u'', True, u'descr')
        image = generate_thumbnail_tag(badge)
        self.assert_(b'fb96ZYAAAAASUVORK5CYII=' in image)
        badge.thumbnail = TEST_IMAGE
        image = generate_thumbnail_tag(badge)
        self.assert_(b'VWyKXFMAAAAASUVORK5CYII=' in image)
        badge.thumbnail = "Wrong Data"
        image = generate_thumbnail_tag(badge)
        self.assert_(b'fb96ZYAAAAASUVORK5CYII=' in image)

    def test_get_parent_badges_no_hierarchy(self):
        from adhocracy.model import UserBadge
        from adhocracy.lib.helpers.badge_helper import get_parent_badges
        badge = UserBadge.create(u'testbadge', u'#ccc', True, u'description')
        result = [b.title for b in get_parent_badges(badge)]
        shouldbe = []
        self.assertEqual(result, shouldbe)

    def test_get_parent_badges_with_hierarchy(self):
        from adhocracy.model import CategoryBadge
        from adhocracy.lib.helpers.badge_helper import get_parent_badges
        badge0 = CategoryBadge.create(u'testbadge0', u'#ccc', True, u'descr')
        badge11 = CategoryBadge.create(u'testbadge11', u'#ccc', True, u'descr')
        badge12 = CategoryBadge.create(u'testbadge12', u'#ccc', True, u'descr')
        badge121 = CategoryBadge.create(u'testbadge121', u'#ccc', True,
                                        u'descr')
        badge11.parent = badge0
        badge12.parent = badge0
        badge121.parent = badge12
        result = [b.title for b in get_parent_badges(badge121)]
        shouldbe = ['testbadge12', u'testbadge0']
        self.assertEqual(result, shouldbe)


class TestSiteHelper(TestController):
    def _make_content(self):
        """Returns instance and user"""

        from adhocracy import model

        instance = model.Instance.find(u'test')
        user = model.User.create(u'user', u'user@mail.com')

        return instance, user

    def test_is_local_url_empty(self):
        from adhocracy.lib import helpers as h

        self.assert_(not h.site.is_local_url(''))
        self.assert_(not h.site.is_local_url(None))

    def test_is_local_url_domain(self):
        from adhocracy.lib import helpers as h
        from adhocracy import config

        self.assert_(h.site.is_local_url(
            '//' + config.get(u'adhocracy.domain')))
        self.assert_(not h.site.is_local_url('http://evil.com'))

    def test_is_local_url_subdomain(self):
        from adhocracy.lib import helpers as h
        from adhocracy import config

        self.assert_(h.site.relative_urls() ^ h.site.is_local_url(
            u'//subdomain.' + config.get(u'adhocracy.domain')))
        self.assert_(not h.site.is_local_url(
            u'//subsub.sub.' + config.get(u'adhocracy.domain')))

    def test_is_local_url_relative(self):
        from adhocracy.lib import helpers as h

        self.assert_(h.site.is_local_url('/i/test'))
        self.assert_(h.site.is_local_url('relative_path'))

    def test_is_local_url_entity(self):
        from adhocracy.lib import helpers as h

        instance, user = self._make_content()

        self.assert_(h.site.is_local_url(h.entity_url(user)))
        self.assert_(h.site.is_local_url(h.entity_url(instance)))

########NEW FILE########
__FILENAME__ = test_importexport
# coding: utf-8

import contextlib
import datetime
import io
import zipfile

import adhocracy.lib.importexport as importexport
from adhocracy.tests import TestController
import adhocracy.tests.testtools as testtools
from adhocracy import model


class _MockResponse(object):
    pass


class ImportExportTest(TestController):
    def setUp(self):
        super(ImportExportTest, self).setUp()
        self.u1 = testtools.tt_make_user()
        self.u1.gender = u'f'
        self.badge = model.UserBadge.create(
            title=u'importexport_badge"\'/\\',
            color=u'#ff00ff',
            visible=True,
            description=u'This badge tests',
        )
        self.u2 = testtools.tt_make_user()
        self.badge.assign(user=self.u1, creator=self.u2)
        self.instance = testtools.tt_make_instance(u'export_test',
                                                   label=u'export_test',
                                                   creator=self.u2)
        self.instance.label = u'test"\'/\\'
        self.instance.description = u'test"\'/\\'
        self.instance.required_majority = 0.42
        self.instance.activation_delay = 5
        self.instance.create_time = datetime.datetime.now()
        self.instance.access_time = datetime.datetime.now()
        self.instance.delete_time = None
        self.instance.default_group_id = 42
        self.instance.allow_adopt = False
        self.instance.allow_delegate = False
        self.instance.allow_propose = False
        self.instance.allow_index = False
        self.instance.hidden = False
        self.instance.locale = u'fr_FR'
        self.instance.css = u'test"\'/\\'
        self.instance.frozen = True
        self.instance.milestones = True
        self.instance.use_norms = False
        self.instance.require_selection = True
        self.instance.is_authenticated = True
        self.instance.hide_global_categories = True
        self.instance.editable_comments_default = False
        self.instance.editable_proposals_default = False
        self.instance.require_valid_email = False
        self.instance.allow_thumbnailbadges = True
        self.instance.thumbnailbadges_height = 42
        self.instance.thumbnailbadges_width = 42

    def test_transforms(self):
        tfs = importexport.transforms.gen_all({})
        self.assertTrue(any(tf.name.lower() == u'user' for tf in tfs))

        tfs = importexport.transforms.gen_active({})
        self.assertEqual(len(tfs), 0)

    def test_export_basic(self):
        e = importexport.export_data({})
        self.assertEqual(len(e), 1)
        self.assertEqual(e[u'metadata'][u'type'], u'normsetting-export')
        self.assertTrue(e[u'metadata'][u'version'] >= 3)

    def test_export_user(self):
        e = importexport.export_data(dict(include_user=True,
                                          user_personal=True,
                                          user_password=True))
        users = e[u'user'].values()
        self.assertTrue(len(users) >= 2)
        self.assertTrue(any(u[u'user_name'] == self.u1.user_name
                            for u in users))
        self.assertTrue(any(u[u'email'] == self.u2.email
                            for u in users))
        self.assertTrue(any(u[u'adhocracy_password'] == self.u1.password
                            for u in users))
        self.assertTrue(all(u'_' in u[u'locale'] for u in users))
        u1 = next(u for u in users if u[u'email'] == self.u1.email)
        self.assertEqual(u1[u'gender'], u'f')
        assert len(users) == len(model.User.all())

    def test_export_anonymous(self):
        e = importexport.export_data(dict(include_user=True))
        users = e[u'user']
        self.assertTrue(len(users) >= 2)
        self.assertTrue(all(len(u) == 0 for u in users.values()))
        self.assertTrue(not any(self.u1.user_name in k for k in users.keys()))
        u1 = next(iter(users))
        self.assertTrue(u'gender' not in u1)

    def test_export_instance(self):
        ed = importexport.export_data({
            u'include_instance': True,
            u'include_user': True,
            u'user_personal': True,
        })
        # Test that we don't spill non-representable objects by accident
        ex = importexport.render.render(ed, u'json', u'(title)',
                                        response=_MockResponse())
        e = importexport.parse.read_data(io.BytesIO(ex))

        self.assertTrue(u'instance' in e)
        self.assertTrue(len(e[u'instance']) >= 1)
        self.assertTrue(self.instance.key in e[u'instance'])
        idata = e[u'instance'][self.instance.key]
        self.assertEqual(idata[u'label'], self.instance.label)
        self.assertEqual(idata[u'key'], self.instance.key)

        user_id = idata[u'creator']
        assert user_id
        self.assertTrue(isinstance(user_id, (str, unicode)))
        self.assertEqual(e[u'user'][user_id][u'user_name'], self.u2.user_name)
        self.assertEqual(idata[u'adhocracy_type'], u'instance')

    def test_importexport_instance(self):
        opts = {
            u'include_instance': True
        }
        ed = importexport.export_data(opts)

        testdata = ed[u'instance'][self.instance.key]
        testdata[u'key'] += testtools.tt_make_str() + u'A'  # Test uppercase
        ed[u'instance'] = {testdata[u'key']: testdata}

        importexport.import_data(opts, ed)
        imported_instance = model.Instance.find(testdata[u'key'])
        self.assertTrue(imported_instance)

        INSTANCE_PROPS = [
            u'label', u'creator', u'description', u'required_majority',
            u'activation_delay',
            u'create_time', u'access_time', u'delete_time',
            u'default_group_id', u'allow_adopt', u'allow_delegate',
            u'allow_propose', u'allow_index', u'hidden', u'locale', u'css',
            u'frozen', u'milestones', u'use_norms', u'require_selection',
            u'is_authenticated', u'hide_global_categories',
            u'editable_comments_default', u'editable_proposals_default',
            u'require_valid_email', u'allow_thumbnailbadges',
            u'thumbnailbadges_height', u'thumbnailbadges_width',
        ]
        for p in INSTANCE_PROPS:
            imported = getattr(imported_instance, p)
            expected = getattr(self.instance, p)
            msg = (u'Instance.%s: Got %r, but expected %r' %
                   (p, imported, expected))
            self.assertEqual(expected, imported, msg)

    def test_export_proposal(self):
        p = testtools.tt_make_proposal(creator=self.u1)
        e = importexport.export_data({
            u"include_instance": True,
            u"include_instance_proposal": True,
            u"include_users": True,
        })
        idata = e[u'instance'][p.instance.key]
        self.assertTrue(u'proposals' in idata)
        pdata = idata[u'proposals'][str(p.id)]
        assert u'comments' not in pdata
        self.assertEqual(pdata[u'title'], p.title)
        self.assertEqual(pdata[u'description'], p.description)
        self.assertEqual(pdata[u'adhocracy_type'], u'proposal')

    def test_export_badge(self):
        e = importexport.export_data(dict(
            include_user=True,
            user_personal=True,
            include_badge=True
        ))
        bdata = e[u'badge']
        assert len(bdata) >= 1
        mykey, myb = next((bkey, bd) for bkey, bd in bdata.items()
                          if bd[u'title'] == self.badge.title)
        self.assertEqual(myb[u'color'], self.badge.color)
        self.assertTrue(myb[u'visible'])
        self.assertEqual(myb[u'description'], self.badge.description)
        self.assertEqual(myb[u'adhocracy_badge_type'], u'user')
        myu1 = next(u for u in e[u'user'].values()
                    if u[u'email'] == self.u1.email)
        self.assertEqual(myu1[u'badges'], [mykey])

    def test_export_comments(self):
        p = testtools.tt_make_proposal(creator=self.u1, with_description=True)
        desc1 = testtools.tt_make_str()
        desc2 = testtools.tt_make_str()
        c1 = model.Comment.create(
            text=desc1,
            user=self.u1,
            topic=p.description,
            reply=None,
            variant=u'HEAD',
            sentiment=1)
        c2 = model.Comment.create(
            text=desc2,
            user=self.u2,
            topic=p.description,
            reply=c1,
            variant=u'HEAD',
            sentiment=-1)
        assert p.description.comments

        e = importexport.export_data({
            "include_instance": True,
            "include_instance_proposal": True,
            "include_instance_proposal_comment": True,
            "include_users": True,
        })
        idata = e[u'instance'][p.instance.key]
        pdata = idata[u'proposals'][str(p.id)]
        assert u'comments' in pdata

        self.assertEqual(len(pdata[u'comments']), 1)
        cdata = next(iter(pdata[u'comments'].values()))
        self.assertEqual(cdata[u'text'], desc1)
        self.assertEqual(cdata[u'creator'], str(self.u1.id))
        self.assertEqual(cdata[u'sentiment'], 1)
        self.assertEqual(cdata[u'adhocracy_type'], u'comment')

        self.assertEqual(len(cdata[u'comments']), 1)
        cdata2 = next(iter(cdata[u'comments'].values()))
        self.assertEqual(cdata2[u'text'], desc2)
        self.assertEqual(cdata2[u'creator'], str(self.u2.id))
        self.assertEqual(cdata2[u'sentiment'], -1)
        self.assertEqual(cdata2[u'adhocracy_type'], u'comment')

    def test_rendering(self):
        e = importexport.export_data({
            u'include_user': True,
            u'user_personal': True,
            u'user_password': True,
            u'include_badge': True,
        })
        self.assertEqual(set(e.keys()), set([u'metadata', u'user', u'badge']))

        render = importexport.render.render
        parse = importexport.parse

        response = _MockResponse()
        zdata = render(e, u'zip', u'test', response=response)
        bio = io.BytesIO(zdata)
        with contextlib.closing(zipfile.ZipFile(bio, u'r')) as zf:
            expected_files = set([u'metadata.json', u'user.json',
                                  u'badge.json'])
            self.assertEqual(set(zf.namelist()), expected_files)
        zio = io.BytesIO(zdata)
        self.assertEqual(parse.detect_format(zio), u'zip')
        self.assertEqual(zio.read(), zdata)
        self.assertEqual(e, parse.read_data(io.BytesIO(zdata), u'zip'))
        self.assertEqual(e, parse.read_data(io.BytesIO(zdata), u'detect'))

        response = _MockResponse()
        jdata = render(e, u'json', u'test', response=response)
        response = _MockResponse()
        jdata_dl = render(e, u'json_download', u'test', response=response)
        self.assertEqual(jdata, jdata_dl)
        self.assertTrue(isinstance(jdata, bytes))
        jio = io.BytesIO(jdata)
        self.assertEqual(parse.detect_format(jio), u'json')
        self.assertEqual(jio.read(), jdata)
        self.assertEqual(e, parse.read_data(io.BytesIO(jdata), u'json'))
        self.assertEqual(e, parse.read_data(io.BytesIO(jdata), u'detect'))

        self.assertRaises(ValueError, render, e, u'invalid', u'test',
                          response=response)
        self.assertRaises(ValueError, parse.read_data, zdata, u'invalid')

        self.assertEqual(parse.detect_format(io.BytesIO()), u'unknown')

    def test_import_user(self):
        test_data = {
            u"user": {
                u"importexport_u1": {
                    u"user_name": u"importexport_u1",
                    u"display_name": u"Mr. Imported",
                    u"email": u"test@test_importexport.de",
                    u"bio": u"hey",
                    u"locale": u"de_DE",
                    u"adhocracy_banned": True
                }
            }
        }
        opts = dict(include_user=True, user_personal=True, user_password=False)

        importexport.import_data(opts, test_data)
        u = model.User.find_by_email(u'test@test_importexport.de')
        self.assertTrue(u)
        self.assertEqual(u.user_name, u'importexport_u1')
        self.assertEqual(u.email, u'test@test_importexport.de')
        self.assertEqual(u.display_name, u'Mr. Imported')
        self.assertEqual(u.bio, u'hey')
        self.assertEqual(str(u.locale), u'de_DE')
        self.assertTrue(not u.banned)

        opts[u'replacement_strategy'] = u'skip'
        testdata_user = test_data[u'user'][u'importexport_u1']
        testdata_user[u'display_name'] = u'Dr. Imported'
        importexport.import_data(opts, test_data)
        u = model.User.find_by_email(u'test@test_importexport.de')
        self.assertTrue(u)
        self.assertEqual(u.display_name, u'Mr. Imported')
        self.assertTrue(not u.banned)

        opts[u'replacement_strategy'] = u'update'
        opts[u'user_password'] = True
        importexport.import_data(opts, test_data)
        u = model.User.find_by_email(u'test@test_importexport.de')
        self.assertTrue(u)
        self.assertEqual(u.display_name, u'Dr. Imported')
        self.assertTrue(u.banned)

    def test_import_badge(self):
        test_data = {
            u"badge": {
                u"importexport_b1": {
                    u"title": u"importexport_b1",
                    u"color": u"mauve",
                    u"adhocracy_badge_type": u"user",
                    u"visible": False,
                    u"description": u"test badge"
                }
            }
        }
        opts = {
            u'include_badge': True
        }

        importexport.import_data(opts, test_data)
        b = model.UserBadge.find(u'importexport_b1')
        self.assertTrue(b)
        self.assertEqual(b.title, u'importexport_b1')
        self.assertEqual(b.color, u'mauve')
        self.assertEqual(b.polymorphic_identity, u'user')
        self.assertTrue(not b.visible)
        self.assertEqual(b.description, u'test badge')

    def test_legacy(self):
        # Version 2 had 'users' instead of 'user'
        v2data = {'users': {}, 'metadata': {'version': 2}}
        self.assertTrue(u'users' in importexport.convert_legacy(v2data))

    def test_time_encoding(self):
        from adhocracy.lib.importexport import transforms
        t1 = transforms.decode_time(u'2013-04-19T11:27:13Z')
        self.assertEqual(t1.microsecond, 0)
        t1_reencoded = transforms.decode_time(transforms.encode_time(t1))
        self.assertEqual(t1, t1_reencoded)

        t2 = transforms.decode_time(u'2013-04-19T11:27:23.123456')
        self.assertEqual(t2.microsecond, 123456)
        t2_reencoded = transforms.decode_time(transforms.encode_time(t2))
        self.assertEqual(t2, t2_reencoded)

########NEW FILE########
__FILENAME__ = test_outgoing_link
from adhocracy.tests import TestController

from adhocracy.lib.outgoing_link import rewrite_urls


class OutgoingLinkTest(TestController):
    def test_staticpage(self):
        from adhocracy.lib.staticpage import render_body
        r = render_body(u'<a href="http://example.com/">link</a>')
        self.assertTrue(u'href="http://example' not in r)

    def test_usercontent(self):
        from adhocracy.lib.text import render

        r = render(u'[link](http://example.com/)')
        self.assertTrue(u'href="http://example' not in r)

    def test_rewrite_urls(self):
        r = rewrite_urls(u'<a href="http://example.com/">link</a>')
        self.assertTrue(u'href="http://example' not in r)

        r = rewrite_urls(u'<a href="https://example.com/">link</a>')
        self.assertTrue(u'href="https://example' not in r)

        r = rewrite_urls(u'<a href="//example.com/">link</a>')
        self.assertTrue(u'href="//example' not in r)

        r = rewrite_urls(u'<a href="/">link</a>')
        self.assertTrue(u'href="/' in r)

        r = rewrite_urls(u'<a href="/i/foo/x/y">link</a>')
        self.assertTrue(u'href="/i/foo/x/y' in r)

        # Do not add any crap
        self.assertEqual(rewrite_urls(u''), u'')
        self.assertEqual(rewrite_urls(u'<a><img src="//example.com/i"/>x</a>'),
                         u'<a><img src="//example.com/i"/>x</a>')

########NEW FILE########
__FILENAME__ = test_pager
from unittest import TestCase


class TestVisiblePages(TestCase):
    '''
    Test the functionality of :func:`adhocracy.lib.pager.visible_pages`
    '''

    def test_few_pages(self):
        from adhocracy.lib.pager import visible_pages

        visible, seperators = visible_pages(1, 3)
        self.assertEqual(visible, [1, 2, 3])
        self.assertEqual(seperators, [])

        visible, seperators = visible_pages(2, 3)
        self.assertEqual(visible, [1, 2, 3])
        self.assertEqual(seperators, [])

        visible, seperators = visible_pages(3, 3)
        self.assertEqual(visible, [1, 2, 3])
        self.assertEqual(seperators, [])

    def test_max_displayed_pages(self):
        '''
        If we have the maximum number (11)of pages, we don't need
        seperators
        '''
        from adhocracy.lib.pager import visible_pages

        visible, seperators = visible_pages(1, 11)
        self.assertEqual(visible, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        self.assertEqual(seperators, [])

        visible, seperators = visible_pages(5, 11)
        self.assertEqual(visible, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        self.assertEqual(seperators, [])

        visible, seperators = visible_pages(11, 11)
        self.assertEqual(visible, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])
        self.assertEqual(seperators, [])

    def test_gt_max_displayed_pages(self):
        '''
        If we have the maximum number (11)of pages, we don't need
        seperators
        '''
        from adhocracy.lib.pager import visible_pages

        visible, seperators = visible_pages(1, 20)
        self.assertEqual(visible, [1, 2, 3, 4, 5, 6, 7, 8, 9, 20])
        self.assertEqual(seperators, [10])

        visible, seperators = visible_pages(7, 20)
        self.assertEqual(visible, [1, 2, 3, 4, 5, 6, 7, 8, 9, 20])
        self.assertEqual(seperators, [10])

        visible, seperators = visible_pages(11, 20)
        self.assertEqual(visible, [1, 8, 9, 10, 11, 12, 13, 14, 20])
        self.assertEqual(seperators, [2, 20])

        visible, seperators = visible_pages(12, 20)
        self.assertEqual(visible, [1, 9, 10, 11, 12, 13, 14, 15, 20])
        self.assertEqual(seperators, [2, 20])

        visible, seperators = visible_pages(13, 20)
        self.assertEqual(visible, [1, 12, 13, 14, 15, 16, 17, 18, 19, 20])
        self.assertEqual(seperators, [2])


class TestSolrTokenHelpers(TestCase):

    def test_entity_to_solr_token_with_hierachy(self):
        from adhocracy.model import CategoryBadge
        from adhocracy.lib.pager import entity_to_solr_token
        badge0 = CategoryBadge.create(u'testbadge0', u'#ccc', True, u'descr')
        badge11 = CategoryBadge.create(u'testbadge11', u'#ccc', True, u'descr')
        badge12 = CategoryBadge.create(u'testbadge12', u'#ccc', True, u'descr')
        badge121 = CategoryBadge.create(u'testbadge121', u'#ccc', True,
                                        u'descr')
        badge11.parent = badge0
        badge12.parent = badge0
        badge121.parent = badge12
        result = entity_to_solr_token(badge121)
        shouldbe = u"%s/%s/%s" % (str(badge0.id), str(badge12.id),
                                  str(badge121.id))
        self.assertEqual(result, shouldbe)

    def test_entity_to_solr_token_no_hierachy(self):
        from adhocracy.model import UserBadge
        from adhocracy.lib.pager import entity_to_solr_token
        badge = UserBadge.create(u'testbadge', u'#ccc', True, u'description')
        result = entity_to_solr_token(badge)
        shouldbe = u"%s" % str(badge.id)
        self.assertEqual(result, shouldbe)

    def test_solr_token_to_entity_with_hierachy(self):
        from adhocracy.model import CategoryBadge
        from adhocracy.lib.pager import solr_tokens_to_entities
        badge = CategoryBadge.create(u'testbadge', u'#ccc', True,
                                     u'description')
        token = u"1/2/%s" % str(badge.id)
        self.assertEqual(solr_tokens_to_entities([token], CategoryBadge),
                         [badge])

    def test_solr_token_to_entity_no_hierachy(self):
        from adhocracy.model import CategoryBadge
        from adhocracy.lib.pager import solr_tokens_to_entities
        badge = CategoryBadge.create(u'testbadge', u'#ccc', True,
                                     u'description')
        token = u"%s" % str(badge.id)
        self.assertEqual(solr_tokens_to_entities([token], CategoryBadge),
                         [badge])
        wrongtoken = "1A"
        self.assertEqual(solr_tokens_to_entities([wrongtoken], CategoryBadge),
                         [])

########NEW FILE########
__FILENAME__ = test_queue
from unittest import TestCase

from mock import MagicMock, patch


@patch('adhocracy.lib.cli.AdhocracyTimer.setup_timer', return_value=None)
@patch('adhocracy.lib.cli.AdhocracyTimer.get_lock', return_value=True)
class TimerTestCase(TestCase):

    def _make_timer(self):
        from adhocracy.lib.cli import AdhocracyTimer
        timer = AdhocracyTimer(None, 'dummy')
        task_mock = MagicMock()
        periodicals = {'testperiodical': {'delay': 1.0,
                                          'task': task_mock}}
        timer.periodicals = periodicals
        return task_mock, timer

    def test_runs_initial_periodicals_if_get_lock(self, get_lock, setup_timer):
        task_mock, timer = self._make_timer()
        run_periodicals_mock = MagicMock()
        timer.run_periodicals = run_periodicals_mock

        get_lock.return_value = True
        timer.guard()

        self.assertTrue(get_lock.called)
        self.assertTrue(run_periodicals_mock.called)
        self.assertTrue(setup_timer.called)

    def test_not_runs_periodicals_without_lock(self, get_lock, setup_timer):
        task_mock, timer = self._make_timer()
        run_periodicals_mock = MagicMock()
        timer.run_periodicals = run_periodicals_mock

        get_lock.return_value = False
        timer.guard()

        self.assertTrue(get_lock.called)
        self.assertFalse(run_periodicals_mock.called)
        # but it setups up the timer anyway
        self.assertTrue(setup_timer.called)

########NEW FILE########
__FILENAME__ = test_requestlog

from adhocracy.tests import TestController
import adhocracy.lib.requestlog


class RequestLogTest(TestController):
    def test_anonymization_trivial(self):
        no_anonymization = adhocracy.lib.requestlog.ANONYMIZATION_FUNCS['none']
        self.assertEqual(no_anonymization(u'::1'), u'::1')
        self.assertEqual(no_anonymization(u'127.8.3.2'), u'127.8.3.2')

        dontlog = adhocracy.lib.requestlog.ANONYMIZATION_FUNCS['dontlog']
        self.assertEqual(dontlog(u'::1'), None)
        self.assertEqual(dontlog(u'127.8.3.2'), None)

    def test_anonymization(self):
        af = adhocracy.lib.requestlog.ANONYMIZATION_FUNCS['anonymize']
        self.assertEqual(af(u'9.8.3.3'), u'9.8.3.0')
        self.assertEqual(af(u'12.234.122.254'), u'12.234.122.0')
        self.assertEqual(af(u'2001:6f8:1377:2a11:1:2:3:4567'),
                         u'2001:6f8:1377::')
        self.assertEqual(af(u'2001:6f8:1377:2a11:1:2::4567'),
                         u'2001:6f8:1377::')
        self.assertEqual(af(u'2001:6f8:1377:2a11::fe:1.2.3.4'),
                         u'2001:6f8:1377::')
        self.assertEqual(af(u'2001::1377:2a11:0:fe:1.2.3.4'), u'2001:0:1377::')
        self.assertEqual(af(u'::ffff:12.234.122.254'), u'::ffff:cea:7a00')

########NEW FILE########
__FILENAME__ = test_search
from unittest import TestCase
from StringIO import StringIO

from sunburnt.schema import SolrSchema
from sunburnt.search import SolrSearch


# borrowed from sunburnt.test_search
schema_string = \
    """<schema name="timetric" version="1.1">
      <types>
        <fieldType name="string" class="solr.StrField" sortMissingLast="true"
                   omitNorms="true"/>
      </types>
      <fields>
        <field name="text" required="true" type="string" multiValued="true"/>
      </fields>
      <defaultSearchField>text</defaultSearchField>
    </schema>
    """

schema = SolrSchema(StringIO(schema_string))


class MockInterface(object):
    schema = schema

interface = MockInterface


class TestSolrSearch(TestCase):

    def test_wildcard_search(self):
        from adhocracy.lib.search.query import add_wildcard_query
        search = SolrSearch(interface)
        query = add_wildcard_query(search, 'text', 'one two')
        self.assertEqual(
            query.params(),
            [('q', '(text:one OR text:one*) AND (text:two OR text:two*)')])

    def test_wildcard_search_cleaned_up(self):
        from adhocracy.lib.search.query import add_wildcard_query
        search = SolrSearch(interface)
        query = add_wildcard_query(search, 'text', 'one** two*')
        self.assertEqual(
            query.params(),
            [('q', '(text:one OR text:one*) AND (text:two OR text:two*)')])

    def test_wildcard_search_added_to_search(self):
        from adhocracy.lib.search.query import add_wildcard_query
        search = SolrSearch(interface).query(text='passedin')

        query = add_wildcard_query(search, 'text', 'wild')
        self.assertEqual(
            query.params(),
            [('q', 'text:passedin AND (text:wild OR text:wild*)')])

    def test_wildcard_search_ignore_none(self):
        from adhocracy.lib.search.query import add_wildcard_query
        search = SolrSearch(interface)

        query = add_wildcard_query(search, 'text', None)
        self.assertEqual(
            query.params(),
            [('q', '*:*')])

########NEW FILE########
__FILENAME__ = test_session
# coding: utf-8

from adhocracy.lib.session.converter import SignedValueConverter
from adhocracy.tests import TestController


class SessionTest(TestController):
    def test_basic(self):
        c = SignedValueConverter(b'shh!')
        encoded = c.encode({'x': [1]})
        decoded = c.decode(encoded)
        self.assertEqual(decoded, {'x': [1]})

        c2 = SignedValueConverter(b'shh!')
        encoded2 = c.encode({'x': [1]})
        self.assertEqual(encoded2, encoded)

    def test_invalid(self):
        c = SignedValueConverter(b'shh!')
        self.assertEqual(c.decode('aaaaaaa!e30='), None)
        self.assertEqual(c.decode('e30='), None)

    def test_umlauts(self):
        v = {u'"\'/\\': u'"\'/\\'}
        c = SignedValueConverter(u'"\'/\\'.encode('utf-8'))
        encoded = c.encode(v)
        decoded = c.decode(encoded)
        self.assertEqual(decoded, v)

    # https://github.com/hhucn/adhocracy.hhu_theme/issues/305
    def test_lazystring(self):
        from pylons.i18n import lazy_ugettext as L_

        c = SignedValueConverter(b'shh!')
        c.encode({u'str': L_(u'Date')})

########NEW FILE########
__FILENAME__ = test_sorting
# coding: utf-8

from adhocracy.tests import TestController
import adhocracy.lib.sorting


class TestSorting(TestController):

    def test_controversy(self):
        c = adhocracy.lib.sorting.proposal_controversy_calculate

        assert c(0, 0) < c(1, 0)
        assert c(1, 0) == c(0, 1)
        assert c(1, 1) < c(2, 2)
        assert c(1, 2) == c(2, 1)
        assert c(1, 2) < c(2, 2)
        assert c(1, 3) < c(2, 2)
        assert c(10, 10) < c(40, 60)
        assert c(20, 20) > c(30, 40)
        assert c(20, 20) > c(25, 15)
        assert c(25, 15) == c(15, 25)
        assert c(10, 10) > c(1, 99)
        assert c(10, 20) < c(20, 40)
        assert c(10, 20) < c(15, 25)
        assert c(10, 10) < c(40, 60)

    def test_alphabetical(self):
        k = adhocracy.lib.sorting._human_key

        assert k(u'axxx') < k(u'bxxx')
        assert k(u'A') < k(u'b')
        assert k(u'a') < k(u'B')
        assert k(u'A') < k(u'B')
        assert k(u'') < k(u'B')
        assert k(u'') < k(u'B')
        assert k(u'') < k(u'z')

########NEW FILE########
__FILENAME__ = test_text
from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_user


SANITIZE_TEST_STRING = """
<h1>Hello</h1><script>XSS</script>
<object>include_dangerous</object>
<embed>include_dangerous</embed>
<a href="javascript:bar()" onclick="javascript: alert(\'foo\')">lala</a>
<iframe class="youtube-player" type="text/html" width="640" height="385"
 src="http://www.youtube.com/embed/foo" frameborder="0">
</iframe>
"""


class TestText(TestController):

    def test_render(self):
        from adhocracy.lib.text import render
        source = ('header\n'
                  '========')
        result = render(source)
        self.assertEqual(result, u'<h1>header</h1>')

    def test_render_no_substitution(self):
        from adhocracy.lib.text import render
        tt_make_user('pudo')
        source = '@pudo'
        result = render(source, substitutions=False)
        self.assertEqual(result, u'<p>@pudo</p>')

    def test_render_user_substitution(self):
        from adhocracy.lib.text import render
        tt_make_user('pudo')
        source = '@pudo'
        result = render(source, substitutions=True)
        self.assertTrue(u'/user/pudo"' in result)

    def test_render_no_xss(self):
        from adhocracy.lib.text import render
        source = '<script>XSS</script><a></a>'
        result = render(source, substitutions=False)
        self.assertEquals(result[:3], '<p>')
        self.assertEquals(result[-4:], '</p>')
        core_result = result[3:-4]
        self.assertTrue(u'<' not in core_result)

    def test_render_no_xss_substitutions(self):
        from adhocracy.lib.text import render
        tt_make_user('<foo>')
        source = '@<foo>'
        result = render(source, substitutions=True)
        self.assertEquals(result[:3], '<p>')
        self.assertEquals(result[-4:], '</p>')
        core_result = result[3:-4]
        self.assertTrue(u'<' not in core_result)

    def test_render_markdown_vuln(self):
        from adhocracy.lib.text import render
        source = u'[XSS](javascript://%0Aalert%28\'XSS\'%29;)'
        result = render(source)
        self.assertTrue(u'javascript' not in result)

    def test_html_sanitizing(self):
        from adhocracy.lib.text import render
        result = render(SANITIZE_TEST_STRING, safe_mode='adhocracy_config',
                        _testing_allow_user_html=True)
        self.assertTrue('<script' not in result)
        self.assertTrue('<object' not in result)
        self.assertTrue('<embed' not in result)
        self.assertTrue('javascript' not in result)
        self.assertTrue('<iframe' in result)

########NEW FILE########
__FILENAME__ = test_treatment

from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_user, tt_make_str
from adhocracy.model import UserBadge, Treatment

from adhocracy.lib.treatment import (get_assignments_by_source_badge,
                                     assign_users)


class TreatmentTest(TestController):
    def test_assignment(self):
        b = UserBadge.create(u'all users - ' + tt_make_str(), u'', False, u'')

        t = Treatment.create(tt_make_str(), source_badges=[b], variant_count=2)
        sb, assignments, unassigned = get_assignments_by_source_badge(t)[0]
        assert sb == b
        ass1, ass2 = assignments
        assert len(ass1) == 0
        assert len(ass2) == 0
        assert len(unassigned) == 0

        first_users = [tt_make_user() for _ in range(5)]
        for u in first_users:
            b.assign(u, u)
        # sanity check
        assert set(u.id for u in b.users) == set(u.id for u in first_users)

        sb, assignments, unassigned = get_assignments_by_source_badge(t)[0]
        assert sb == b
        ass1, ass2 = assignments
        assert len(ass1) == 0
        assert len(ass2) == 0
        assert len(unassigned) == len(first_users)

        assert assign_users(t)
        sb, assignments, unassigned = get_assignments_by_source_badge(t)[0]
        assert sb == b
        ass1, ass2 = assignments
        assert len(ass1) + len(ass2) == len(first_users)
        assert (len(ass1) == len(ass2) - 1) or (len(ass1) == len(ass2) + 1)
        assert len(unassigned) == 0

        assert not assign_users(t)

        new_users = [tt_make_user() for _ in range(5)]
        for u in new_users:
            b.assign(u, u)
        sb, assignments, unassigned = get_assignments_by_source_badge(t)[0]
        assert sb == b
        ass1, ass2 = assignments
        assert len(ass1) + len(ass2) == len(first_users)
        assert (len(ass1) == len(ass2) - 1) or (len(ass1) == len(ass2) + 1)
        assert len(unassigned) == len(new_users)

        assert assign_users(t)
        sb, assignments, unassigned = get_assignments_by_source_badge(t)[0]
        assert sb == b
        ass1, ass2 = assignments
        assert len(ass1) + len(ass2) == len(first_users) + len(new_users)

        # The following assert is disabled as it fails non-deterministically
        # (see #601). It can be reenabled once this issue is fixed.

        # assert len(ass1) == len(ass2)

        assert len(unassigned) == 0

        assert not assign_users(t)

########NEW FILE########
__FILENAME__ = test_url
import mock

from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_proposal


class TestUrls(TestController):

    def test_append_member_and_format_full(self):
        from adhocracy.lib.helpers.url import append_member_and_format
        appended = append_member_and_format(u'http://base-url/existing',
                                            member='new', format='html')
        self.assertEqual(appended, u'http://base-url/existing/new.html')

    def test_append_member_and_format_append_member(self):
        from adhocracy.lib.helpers.url import append_member_and_format
        appended = append_member_and_format(u'http://base-url/existing',
                                            member='new')
        self.assertEqual(appended, u'http://base-url/existing/new')

    def test_append_member_and_format_append_format(self):
        from adhocracy.lib.helpers.url import append_member_and_format
        appended = append_member_and_format(u'http://base-url/existing',
                                            format='html')
        self.assertEqual(appended, u'http://base-url/existing.html')

    def test_append_member_and_format_format_is_lowercased(self):
        from adhocracy.lib.helpers.url import append_member_and_format
        appended = append_member_and_format(u'http://base-url/existing',
                                            format='HTML')
        self.assertEqual(appended, u'http://base-url/existing.html')

    def test_build_global(self):
        from adhocracy.lib.helpers.url import build
        url = build(None, 'base', 'id', query={'param': u'arg'},
                    anchor='anchor', member='member', format="html")
        self.assertEqual(
            url, u'http://test.lan/base/id/member.html?param=arg#anchor')

    def test_build_global_omit_base(self):
        from adhocracy.lib.helpers.url import build
        url = build(None, None, 'id', query={'param': u'arg'},
                    anchor='anchor', member='member', format="html")
        self.assertEqual(url,
                         u'http://test.lan/id/member.html?param=arg#anchor')
        url = build(None, '', 'id', query={'param': u'arg'},
                    anchor='anchor', member='member', format="html")
        self.assertEqual(url,
                         u'http://test.lan/id/member.html?param=arg#anchor')

    def test_build_global_omit_member_and_format(self):
        from adhocracy.lib.helpers.url import build
        url = build(None, 'base', 'id', query={'param': u'arg'},
                    anchor='anchor')
        self.assertEqual(url, u'http://test.lan/base/id?param=arg#anchor')

    def test_build_global_omit_anchor_member_and_format(self):
        from adhocracy.lib.helpers.url import build
        url = build(None, 'base', 'id', query={'param': u'arg'},
                    anchor='anchor')
        self.assertEqual(url, u'http://test.lan/base/id?param=arg#anchor')

    def test_build_global_omit_query(self):
        from adhocracy.lib.helpers.url import build
        url = build(None, 'base', 'id', anchor='anchor', member='member',
                    format="html")
        self.assertEqual(url,
                         u'http://test.lan/base/id/member.html#anchor')

    def test_build_query_is_encoded(self):
        from adhocracy.lib.helpers.url import build
        url = build(None, 'base', 'id', query={'param': u'http://a@b:x'})
        self.assertEqual(
            url, u'http://test.lan/base/id?param=http%3A%2F%2Fa%40b%3Ax')

    def test_build_global_omit_all_except_id(self):
        from adhocracy.lib.helpers.url import build
        url = build(None, None, 'id')
        self.assertEqual(url, u'http://test.lan/id')

    def test_login_redirect(self):
        from adhocracy.lib.helpers import login_redirect_url

        proposal = tt_make_proposal(title=u'testproposal')
        url = login_redirect_url(proposal)
        expected = (u'http://test.test.lan/login?came_from='
                    u'http%3A%2F%2Ftest.test.lan%2Fproposal%2F2-testproposal')
        self.assertEqual(url, expected)


class TestInstanceUrls(TestController):

    mocked_path_func = mock.patch('adhocracy.lib.logo.path_and_mtime',
                                  return_value=('/dummy/path', 1234))

    def test_icon_url_with_y(self):
        with self.mocked_path_func:
            from adhocracy.lib import helpers as h
            from adhocracy.tests.testtools import tt_get_instance
            test_instance = tt_get_instance()
            url = h.logo_url(test_instance, 48)
            self.assertEqual(
                url, 'http://test.test.lan/instance/test_48.png?t=1234')

    def test_icon_url_with_x_and_y(self):
        with self.mocked_path_func:
            from adhocracy.lib import helpers as h
            from adhocracy.tests.testtools import tt_get_instance
            test_instance = tt_get_instance()
            url = h.logo_url(test_instance, 48, x=11)
            self.assertEqual(
                url, 'http://test.test.lan/instance/test_11x48.png?t=1234')

    def test_icon_url_contains_mtime(self):
        with self.mocked_path_func:
            from adhocracy.lib import helpers as h
            from adhocracy.tests.testtools import tt_get_instance
            test_instance = tt_get_instance()
            url = h.logo_url(test_instance, 48)
            self.assertEqual(
                url, 'http://test.test.lan/instance/test_48.png?t=1234')


class TestBaseUrl(TestController):
    def test_base_url_absolute(self):
        from adhocracy.lib.helpers import base_url
        self.assertTrue(u'/' in base_url())
        self.assertTrue(base_url(absolute=True).startswith(u'http'))

########NEW FILE########
__FILENAME__ = adhocracy
import unittest
from funkload.FunkLoadTestCase import FunkLoadTestCase


class Adhocracy(FunkLoadTestCase):
    """This test uses the configuration file ADHOCRACY.conf."""

    def setUp(self):
        self.server_url = self.conf_get('main', 'url')

    def test_instance_startpage(self):
        # The description should be set in the configuration file
        server_url = self.server_url
        # begin of test ---------------------------------------------
        self.get(server_url, description='Get startpage url')
        self.get(server_url + "/instance", description='Go to instances')
        self.get(server_url + "/i/test/instance/test",
                 description='Go to test instance')
        # end of test -----------------------------------------------

if __name__ in ('main', '__main__'):
    unittest.main()

########NEW FILE########
__FILENAME__ = test_badges
# coding=utf-8
from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_user


class TestBadgeController(TestController):

    def test_we_already_have_two_userbadges(self):
        """
        Due to the setup code in `adhocracy.lib.install` and the definition
        of example user badges in `test.ini` for the Shibboleth tests, we
        already have two badges from the beginning.
        """
        from adhocracy.model import UserBadge
        self.assertEqual(len(UserBadge.all()), 2)

    def test_cannot_add_base_Badge(self):
        """
        We cannot add the base `Badge` to the database cause
        It has no polymorphic_identity and is only ment as
        a base class even if it's mapped. Kindof a reminder.
        """
        from sqlalchemy.exc import IntegrityError
        from adhocracy.model import Badge
        # add badge
        self.assertRaises(IntegrityError, Badge.create, u'badge ',
                          u'#ccc', True, u'description ')

    def test_get_all_badges(self):
        # setup
        from adhocracy.model import Badge, CategoryBadge, DelegateableBadge, \
            InstanceBadge, ThumbnailBadge
        from adhocracy.model import UserBadge, Instance
        instance = Instance.find(u'test')
        # create for each type a global scope and an instance scope badge
        InstanceBadge.create(u'badge ', u'#ccc', True, u'description ')
        InstanceBadge.create(u'badge ', u'#ccc', True, u'description ',
                             instance=instance)
        UserBadge.create(u'badge ', u'#ccc', True, u'description ')
        UserBadge.create(u'', u'#ccc', True, u'', instance=instance)
        DelegateableBadge.create(u'badge ', u'#ccc', True, u'description ')
        DelegateableBadge.create(u'badge ', u'#ccc', True, u'description ',
                                 instance=instance)
        CategoryBadge.create(u'badge ', u'#ccc', True, u"desc")
        CategoryBadge.create(u'badge ', u'#ccc', True, u"desc",
                             instance=instance)

        ThumbnailBadge.create(u'badge ', u'#ccc', True, u"desc",
                              thumbnail=b'binary')
        ThumbnailBadge.create(u'badge ', u'#ccc', True, u"desc",
                              thumbnail=b'binary', instance=instance)

        # all instance badges
        self.assertEqual(len(InstanceBadge.all()), 1)
        self.assertEqual(len(InstanceBadge.all(instance=instance)), 1)
        # all delegateable badges
        self.assertEqual(len(DelegateableBadge.all()), 1)
        self.assertEqual(len(DelegateableBadge.all(instance=instance)), 1)
        # all delegateable category badges
        self.assertEqual(len(CategoryBadge.all()), 1)
        self.assertEqual(len(CategoryBadge.all(instance=instance)), 1)
        # all delegateable thumbnail badges
        self.assertEqual(len(ThumbnailBadge.all()), 1)
        self.assertEqual(len(ThumbnailBadge.all(instance=instance)), 1)
        # all user badges
        self.assertEqual(len(UserBadge.all()), 3)
        self.assertEqual(len(UserBadge.all(instance=instance)), 1)
        # We can get all Badges by using `Badge`
        self.assertEqual(len(Badge.all()), 7)
        self.assertEqual(len(Badge.all(instance=instance)), 5)

        self.assertEqual(len(Badge.all_q().all()), 12)


class TestUserController(TestController):

    def _make_one(self):
        """Returns creator, badged user and badge"""

        from adhocracy import model
        creator = tt_make_user(u'creator')
        badged_user = tt_make_user(u'badged_user')
        badge = model.UserBadge.create(u'testbadge', u'#ccc', True,
                                       u'description')
        badge.assign(badged_user, creator)
        return creator, badged_user, badge

    def test_userbadges_created(self):
        from adhocracy.model import Badge, meta
        # the created badge
        creator, badged_user, badge = self._make_one()
        queried_badge = meta.Session.query(Badge).filter(
            Badge.title == u'testbadge').one()
        self.assertEqual(badge, queried_badge)
        self.assertEqual(queried_badge.title, u'testbadge')
        # references on the badged user
        self.assertEqual(badged_user.badges, [badge])
        self.assertEqual(badged_user.badges[0].users, [badged_user])

    def test_remove_badge_from_user(self):
        from adhocracy.model import meta, UserBadges
        creator, badged_user, badge = self._make_one()
        self.assertEqual(badged_user.badges, [badge])
        badged_user.badges.remove(badge)
        self.assertEqual(badged_user.badges, [])
        self.assertEqual(badge.users, [])
        self.assertEqual(meta.Session.query(UserBadges).count(), 0)

    def test_remove_user_from_badge(self):
        from adhocracy.model import meta, UserBadges
        creator, badged_user, badge = self._make_one()
        self.assertEqual(badge.users, [badged_user])
        badge.users.remove(badged_user)
        self.assertEqual(badge.users, [])
        self.assertEqual(badged_user.badges, [])
        self.assertEqual(meta.Session.query(UserBadges).count(), 0)

    def test_to_dict(self):
        creator, badged_user, badge = self._make_one()
        result = badge.to_dict()
        self.assertEqual(result['users'], [u'badged_user'])


class TestDelegateableController(TestController):

    def _make_content(self):
        """Returns creator, delegateable and badge"""

        from adhocracy.model import DelegateableBadge, Proposal, Instance
        instance = Instance.find(u'test')
        creator = tt_make_user(u'creator')
        delegateable = Proposal.create(instance, u"labeld", creator)
        badge = DelegateableBadge.create(u'testbadge', u'#ccc', True,
                                         u'description')

        return creator, delegateable, badge

    def test_delegateablebadges_created(self):
        # setup
        from adhocracy.model import DelegateableBadges, meta
        creator, delegateable, badge = self._make_content()
        # create the delegateable badge
        badge.assign(delegateable, creator)
        delegateablebadges = meta.Session.query(DelegateableBadges).first()
        self.assertEqual(delegateablebadges.creator, creator)
        self.assertEqual(delegateablebadges.delegateable, delegateable)
        self.assertEqual(delegateablebadges.badge, badge)
        # test the references on the badged delegateable
        self.assertEqual(delegateable.badges, [badge])
        # test the references on the badge
        self.assertEqual(delegateable.badges[0].delegateables,
                         badge.delegateables,
                         [delegateable])

    def test_remove_badge_from_delegateable(self):
        # setup
        from adhocracy.model import DelegateableBadges, meta
        creator, delegateable, badge = self._make_content()
        badge.assign(delegateable, creator)
        # remove badge from delegateable
        delegateable.badges.remove(badge)
        self.assertEqual(delegateable.badges, [])
        self.assertEqual(badge.delegateables, [])
        self.assertEqual(meta.Session.query(DelegateableBadges).count(), 0)

    def test_remove_delegateable_from_badge(self):
        # setup
        from adhocracy.model import DelegateableBadges, meta
        creator, delegateable, badge = self._make_content()
        badge.assign(delegateable, creator)
        # remove delegateable from badge
        badge.delegateables.remove(delegateable)
        self.assertEqual(badge.delegateables, [])
        self.assertEqual(delegateable.badges, [])
        self.assertEqual(meta.Session.query(DelegateableBadges).count(), 0)


class TestCategoryController(TestController):

    def _make_content(self):
        """Returns creator, delegateable and badge"""

        from adhocracy.model import CategoryBadge, Proposal, Instance
        instance = Instance.find(u'test')
        creator = tt_make_user(u'creator')
        delegateable = Proposal.create(instance, u"labeld", creator)
        badge = CategoryBadge.create(u'testbadge', u'#ccc', True,
                                     u'description')

        return creator, delegateable, badge

    def test_categorybadges_created(self):
        # setup
        from adhocracy.model import DelegateableBadges, meta
        creator, delegateable, badge = self._make_content()
        # create the delegateable badge
        badge.assign(delegateable, creator)
        delegateablebadges = meta.Session.query(DelegateableBadges).first()
        self.assertTrue(delegateablebadges.creator is creator)
        self.assertTrue(delegateablebadges.delegateable is delegateable)
        self.assertTrue(delegateablebadges.badge is badge)

    def test_categorybadges_hierarchy(self):
        # setup
        from adhocracy.model import CategoryBadge
        creator, delegateable, badge = self._make_content()
        badge_parent = CategoryBadge.create(u'badge parent', u'#ccc', True,
                                            u'description')
        badge_parent.select_child_description = u"choose child"
        # create the delegateable badge
        badge.assign(delegateable, creator)
        # add parent badge
        badge.parent = badge_parent
        self.assertEqual(badge.parent, badge_parent)
        self.assertTrue(badge in badge_parent.children)
        self.assertEqual(badge_parent.select_child_description,
                         u"choose child")
        self.assertTrue(badge_parent.parent is None)

    def test_to_dict_category(self):
        # setup
        creator, delegateable, badge = self._make_content()
        # create the delegateable badge
        badge.assign(delegateable, creator)
        # test dict
        result = badge.to_dict()
        result = sorted(result.items())
        expected = {'color': u'#ccc',
                    'description': u'description',
                    'id': 3,
                    'instance': None,
                    'title': u'testbadge',
                    'visible': True,
                    'parent': None,
                    'select_child_description': u'',
                    }
        expected = sorted(expected.items())
        self.assertEqual(result, expected)


class TestThumbnailController(TestController):

    def _make_content(self):
        """Returns creator, delegateable and badge"""

        from adhocracy.model import ThumbnailBadge, Proposal, Instance
        instance = Instance.find(u'test')
        creator = tt_make_user(u'creator')
        delegateable = Proposal.create(instance, u"labeld", creator)
        thumbnail = b'binary'
        badge = ThumbnailBadge.create(u'testbadge', u'#ccc', True,
                                      u'description', thumbnail=thumbnail)

        return creator, delegateable, badge

    def test_thumbnailbadges_repr(self):
        creator, delegateable, badge = self._make_content()
        badge.thumbnail = None
        no_thumb = "<ThumbnailBadge(3,testbadge,None,#ccc)>"
        self.assertEqual(no_thumb, badge.__repr__())
        with_thumb = "<ThumbnailBadge(3,testbadge,9d7183f1,#ccc)>"
        badge.thumbnail = b"binary"
        self.assertEqual(with_thumb, badge.__repr__())

    def test_thumbnailbadges_created(self):
        # setup
        from adhocracy.model import DelegateableBadges, meta
        creator, delegateable, badge = self._make_content()
        # create the delegateable badge
        badge.assign(delegateable, creator)
        delegateablebadges = meta.Session.query(DelegateableBadges).first()
        self.assertEqual(delegateablebadges.creator, creator)
        self.assertEqual(delegateablebadges.delegateable, delegateable)
        self.assertEqual(delegateablebadges.badge, badge)
        # test the references on the badged delegateable
        self.assertEqual(delegateable.thumbnails, [badge])
        # test the references on the badge
        self.assertEqual(delegateable.thumbnails[0].delegateables,
                         badge.delegateables,
                         [delegateable])

    def test_to_dict_thumbnail(self):
        # setup
        creator, delegateable, badge = self._make_content()
        # create the delegateable badge
        badge.assign(delegateable, creator)
        # test dict
        result = badge.to_dict()
        result = sorted(result.items())
        expected = {'color': u'#ccc',
                    'description': u'description',
                    'id': 3,
                    'instance': None,
                    'thumbnail': b'binary',
                    'title': u'testbadge',
                    'visible': True
                    }
        expected = sorted(expected.items())
        self.assertEqual(result, expected)


class TestInstanceController(TestController):

    def _make_content(self):
        """Returns creator, delegateable and badge"""

        from adhocracy.model import InstanceBadge, Instance
        creator = tt_make_user(u'creator')
        instance = Instance.create(u"instance2", u"instance2", creator)
        badge = InstanceBadge.create(u'testbadge', u'#ccc2', True,
                                     u'description')

        return creator, instance, badge

    def test_instancebadges_created(self):
        # setup
        from adhocracy.model import InstanceBadges, meta
        creator, instance, badge = self._make_content()
        # create the instance badge
        badge.assign(instance, creator)
        instancebadges = meta.Session.query(InstanceBadges).first()
        self.assertTrue(instancebadges.creator is creator)
        self.assertTrue(instancebadges.instance is instance)
        self.assertTrue(instancebadges.badge is badge)
        # test the references on the badged instance
        self.assertEqual(instance.badges, [badge])
        # test the references on the badge
        self.assertTrue(instance.badges[0].instances
                        == badge.instances
                        == [instance])

    def test_remove_badge_from_instance(self):
        # setup
        from adhocracy.model import InstanceBadges, meta
        creator, instance, badge = self._make_content()
        badge.assign(instance, creator)
        # remove badge from instance
        instance.badges.remove(badge)
        self.assertEqual(instance.badges, [])
        self.assertEqual(badge.instances, [])
        self.assertEqual(meta.Session.query(InstanceBadges).count(), 0)

    def test_remove_instance_from_badge(self):
        # setup
        from adhocracy.model import InstanceBadges, meta
        creator, instance, badge = self._make_content()
        badge.assign(instance, creator)
        # remove instance from badge
        badge.instances.remove(instance)
        self.assertEqual(badge.instances, [])
        self.assertEqual(instance.badges, [])
        self.assertEqual(meta.Session.query(InstanceBadges).count(), 0)

########NEW FILE########
__FILENAME__ = test_instances
from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_user


class TestUserController(TestController):

    def test_members(self):
        from adhocracy.model import Instance, Group
        test_instance = Instance.find('test')

        members = test_instance.members()
        self.assertEqual(len(members), 1)
        self.assertEqual(members[0].user_name, u'admin')
        voters = Group.find(u'Voter')
        tt_make_user(u'second', voters)

        members = test_instance.members()
        self.assertEqual(len(members), 2)
        self.assertEqual(sorted([member.user_name for member in
                                 test_instance.members()]),
                         ['admin', 'second'])

    def test_to_dict(self):
        from adhocracy.model import Instance
        test_instance = Instance.find('test')
        shouldbe = {'activation_delay': 7,
                    'allow_adopt': True,
                    'allow_delegate': True,
                    'allow_index': True,
                    'allow_propose': True,
                    'allow_thumbnailbadges': True,
                    'create_time': test_instance.create_time,
                    'creator': u'admin',
                    'default_group': u'voter',
                    'hidden': False,
                    'id': 1,
                    'instance_url': u'http://test.test.lan/instance/test',
                    'key': u'test',
                    'label': u'Test Instance',
                    'required_majority': 0.66,
                    'thumbnailbadges_height': None,
                    'thumbnailbadges_width': None,
                    'url': u'http://test.test.lan/instance/test'}
        result = test_instance.to_dict()
        self.assertEqual(shouldbe, result)

########NEW FILE########
__FILENAME__ = test_milestones
# coding=utf-8
from datetime import datetime

from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_instance, tt_make_user


def _make_one(title, text, creator=None, time=None):
    from adhocracy.model import Instance, Milestone
    if creator is None:
        creator = tt_make_user()
    instance = Instance.find('test')
    now = datetime.now()
    milestone = Milestone.create(instance, creator, title, text, now)
    return (milestone, creator)


class TestMilestoneController(TestController):

    def test_create_milestone(self):
        from adhocracy.model import Instance, Milestone
        now = datetime.now()
        creator = tt_make_user()
        instance = Instance.find('test')
        milestone = Milestone.create(instance, creator, u'Title', u'Text',
                                     now)
        self.assertEqual(milestone.instance, instance)
        self.assertEqual(milestone.creator, creator)
        self.assertEqual(len(Milestone.all()), 1)

    def test_create_milestone_with_category(self):
        from adhocracy.model import CategoryBadge
        milestone, creator = _make_one(u'title', u'text')
        category = CategoryBadge.create(u'Category', u'#ccc', True,
                                        u'descripiton', 0, milestone.instance)
        milestone.category = category
        self.assertEqual(milestone.category.id, category.id)
        self.assertEqual(category.milestones, [milestone])

    def test_create_milestone_with_category_that_changes_instance(self):
        from adhocracy.model import CategoryBadge, meta
        milestone, creator = _make_one(u'title', u'text')
        category = CategoryBadge.create(u'Category', u'#ccc', True,
                                        u'descripiton', 0, milestone.instance)
        milestone.category = category
        self.assertEqual(milestone.category.id, category.id)
        self.assertEqual(category.milestones, [milestone])

        # after we set another instance for the category (and refreshed
        # the objects in the Session), the milestone no longer has a category.
        other_instance = tt_make_instance(u'other', u'Other Label')
        category.instance = other_instance
        meta.Session.flush()
        meta.Session.refresh(milestone)
        meta.Session.refresh(category)
        self.assertNotEqual(category.instance, milestone.instance)
        self.assertEqual(milestone.category, None)
        self.assertEqual(category.milestones, [])

########NEW FILE########
__FILENAME__ = test_proposals
from datetime import timedelta
from datetime import datetime

from adhocracy.tests import TestController
from adhocracy.tests.testtools import (tt_get_instance, tt_make_proposal,
                                       tt_make_str, tt_make_user)

delta = timedelta(minutes=1)
now = datetime.utcnow()
before = now - delta
after = now + delta


class TestProposals(TestController):

    def _make_proposal(self, voting=False):
        creator = tt_make_user('creator')
        proposal = tt_make_proposal(creator=creator, voting=voting)
        return (proposal, creator)

    def _make_norm(self, proposal, creator):
        from adhocracy import model

        instance = tt_get_instance()
        page = model.Page.create(instance,
                                 title=tt_make_str(),
                                 text=tt_make_str(),
                                 creator=creator)
        selection = model.Selection.create(proposal, page, creator)
        selection.variant_poll(page.head)
        return page

    def test_delete_proposal(self):
        (proposal, _) = self._make_proposal()
        proposal.delete(delete_time=now)
        self.assertTrue(proposal.is_deleted())

    def test_delete_proposal_test_delete_time(self):
        (proposal, _) = self._make_proposal()
        proposal.delete(delete_time=now)
        self.assertFalse(proposal.is_deleted(before))
        self.assertTrue(proposal.is_deleted(after))

    def test_delete_deletes_selection_but_leaves_norm(self):
        (proposal, creator) = self._make_proposal()
        norm = self._make_norm(proposal, creator)
        selection = proposal.selections[0]
        self.assertEqual(proposal.children[0], norm)
        proposal.delete()
        self.assertTrue(proposal.is_deleted())
        self.assertTrue(selection.is_deleted())
        self.assertFalse(norm.is_deleted())

    def test_polls_are_annoyingly_doubled(self):
        '''
        More of a reminder test that delegateable.polls
        is not necessarily a unique list because
        of the way relationship()/backref() automatically
        populates the other side.
        '''
        (proposal, _) = self._make_proposal(voting=True)
        self.assertEqual(len(proposal.polls), 2)
        self.assertTrue(proposal.polls[0] is proposal.polls[1])

    def test_delete_deletes_polls(self):
        (proposal, _) = self._make_proposal(voting=True)
        proposal.delete()
        self.assertTrue(len(proposal.polls) > 0)
        for poll in proposal.polls:
            self.assertTrue(poll.is_deleted())

########NEW FILE########
__FILENAME__ = test_user
from adhocracy.model import Delegation, Group

from adhocracy.tests import TestController
from adhocracy.tests.testtools import (tt_get_instance, tt_make_proposal,
                                       tt_make_user)


class TestUserController(TestController):

    def test_can_delegate_via_forward_on_user(self):

        proposal = tt_make_proposal(voting=True)

        voter_group = Group.by_code(Group.CODE_VOTER)
        me = tt_make_user(instance_group=voter_group)
        delegate = tt_make_user(instance_group=voter_group)

        Delegation.create(me, delegate, proposal)
        self.assertEqual(delegate.number_of_votes_in_scope(proposal), 2)

    def test_delete_user_deletes_watches(self):
        from adhocracy.model import Watch
        voter_group = Group.by_code(Group.CODE_VOTER)
        user = tt_make_user(instance_group=voter_group)
        instance = tt_get_instance()
        watch = Watch.create(user, instance)
        self.assertFalse(watch.is_deleted())
        user.delete()
        self.assertTrue(watch.is_deleted())

########NEW FILE########
__FILENAME__ = testbrowser
"""Helper classes to allow function testing with a testbrowser"""

from lxml import etree
from lxml.cssselect import CSSSelector

from mock import patch

from pylons import config
from pylons.test import pylonsapp
from repoze.tm import TM
import zope.testbrowser.wsgi

from adhocracy.model import meta
from adhocracy.lib.search import drop_all, rebuild_all
from adhocracy import tests


adhocracy_domain = config.get('adhocracy.domain', '').strip()
app_url = "http://%s" % adhocracy_domain
instance_url = "http://test.%s" % adhocracy_domain


class Browser(zope.testbrowser.wsgi.Browser):
    """Simplify zope.testbrowser sessions"""

    REMOTE_USER_HEADER = 'REMOTE_USER'

    app_url = app_url
    instance_url = instance_url

    def dc(self, filename="/tmp/test-output.html"):
        open(filename, 'w').write(self.contents)

    def login(self, username):
        self.logout()
        # 'REMOTE_USER' will turn into HTTP_REMOTE_USER in the wsgi environ.
        self.addHeader(self.REMOTE_USER_HEADER, username)

    def logout(self):
        self.mech_browser.addheaders = [header for header in
                                        self.mech_browser.addheaders if
                                        header[0] != self.REMOTE_USER_HEADER]

    def real_login(self, username, password):
        self.real_logout()
        self.open(u'http://test.lan/login')
        form = self.getForm(name=u'login_form', index=1)
        form.getControl(name=u'login').value = username
        form.getControl(name=u'password').value = password
        form.submit()
        assert(u'dashboard' in self.contents)

    def real_logout(self):
        self.open(u'http://test.lan/logout')

    @property
    def status(self):
        return self.headers['Status']

    def etree(self):
        '''
        return an lxml.etree from the contents.
        '''
        return etree.fromstring(self.contents)

    def cssselect(self, selector):
        cssselector = CSSSelector(selector)
        return cssselector(self.etree())

    def xpath(self, selector):
        return self.etree().xpath(selector)


class AdhocracyAppLayer(zope.testbrowser.wsgi.Layer):
    """Layer to setup the WSGI app"""

    def make_wsgi_app(self):
        app = pylonsapp
        app = zope.testbrowser.wsgi.AuthorizationMiddleware(app)
        app = TM(app)
        zope.testbrowser.wsgi._allowed.add(adhocracy_domain)
        zope.testbrowser.wsgi._allowed_2nd_level.add(adhocracy_domain)
        return app

    def setUp(self, *args, **kwargs):
        # we skip this test if we don't have a full stack
        # test environment
        tests.is_integrationtest()

        connection = meta.engine.connect()
        self.trans = connection.begin()
        meta.Session.configure(bind=connection)
        # delete and reindex solr
        drop_all()
        rebuild_all()

        # mock the mail.send() function. Make sure to stop()
        # the patcher in tearDown.
        self.patcher = patch('adhocracy.lib.mail.send')
        self.mocked_mail_send = self.patcher.start()
        # TODO start solr and co

    def tearDown(self, test):
        self.trans.rollback()
        self.patcher.stop()
        meta.Session.close()


ADHOCRACY_LAYER = AdhocracyAppLayer()
ADHOCRACY_LAYER_APP = ADHOCRACY_LAYER.make_wsgi_app()

########NEW FILE########
__FILENAME__ = testtools
from datetime import datetime, timedelta
import random
import string

from adhocracy import i18n
from adhocracy import model

#  These functions should all go as convenience functions on the
#  respective models


def tt_get_admin():
    admin = model.User(tt_make_str(), u"admin@null.naught", u"password")
    model.meta.Session.add(admin)
    model.meta.Session.flush()
    return admin


def tt_get_instance():
    '''
    Return the "default" instance and set it as the current thread
    local instance for ifilter/c.instance
    '''
    instance = model.Instance.find(u"test")
    if not instance:
        tt_make_instance(u"test", u"foo schnasel")
    model.instance_filter.setup_thread(instance)
    return instance


def tt_make_instance(key, label, creator=None):
    if creator is None:
        creator = tt_make_user()
    instance = model.Instance(key, label, creator)
    model.meta.Session.add(instance)
    model.meta.Session.flush()
    # shouldn't setup_threads instance be returned if available?
    return instance


def tt_make_str(length=20):
    return u''.join([random.choice(string.letters) for i in range(length)])


def tt_make_proposal(creator=None, voting=False, title=None,
                     with_description=False):
    instance = tt_get_instance()
    creator = creator if creator is not None else tt_make_user()
    title = title if title is not None else tt_make_str()
    proposal = model.Proposal(instance, title, creator)
    model.meta.Session.add(proposal)
    model.meta.Session.flush()

    if voting:
        an_hour_ago = datetime.utcnow() - timedelta(hours=2)
        poll = model.Poll.create(proposal, creator, model.Poll.ADOPT)
        poll.begin_time = an_hour_ago
        proposal.polls.append(poll)
        model.meta.Session.flush()

    if with_description:
        description = model.Page.create(instance,
                                        tt_make_str(),
                                        tt_make_str(),
                                        creator,
                                        function=model.Page.DESCRIPTION)
        description.parents = [proposal]
        proposal.description = description
        model.meta.Session.flush()

    return proposal


def tt_make_user(name=None, instance_group=None):
    if name is not None:
        name = unicode(name)
        user = model.meta.Session.query(model.User)
        user = user.filter(model.User.user_name == name).first()
        if user:
            return user

    if name is None:
        name = tt_make_str()
    user = model.User(name, name + u'@test.de', u"test",
                      i18n.get_default_locale())

    default_group = model.Group.by_code(model.Group.CODE_DEFAULT)
    default_membership = model.Membership(user, None, default_group)
    memberships = [default_membership]
    if instance_group:
        instance = tt_get_instance()
        group_membership = model.Membership(user, instance, instance_group)
        memberships.append(group_membership)
    user.memberships = memberships
    model.meta.Session.add(user)
    # write to db and updated db generated attributes
    model.meta.Session.flush()
    return user


def tt_drop_db():
    '''
    drop the data tables and if exists the migrate_version table
    '''
    model.meta.data.drop_all(bind=model.meta.engine)
    model.meta.engine.execute("DROP TABLE IF EXISTS migrate_version")


def tt_create_db():
    '''create the database tables'''
    model.meta.data.create_all(bind=model.meta.engine)

########NEW FILE########
__FILENAME__ = test_doctest_files
from glob import glob
import doctest
from doctest import DocFileTest
from os.path import dirname

import mock

from adhocracy import model
from adhocracy.tests import testtools
from adhocracy.tests.testbrowser import ADHOCRACY_LAYER, ADHOCRACY_LAYER_APP
from adhocracy.tests.testbrowser import app_url, instance_url
from adhocracy.tests.testbrowser import Browser


def find_use_cases():
    here = dirname(__file__)
    paths = glob('{here}/use_cases/*.rst'.format(here=here))
    # we need relative paths for DocFileSuite
    pathes = [path.replace(here, '.') for path in paths]
    return pathes


def make_browser():
    return Browser(wsgi_app=ADHOCRACY_LAYER_APP)


use_cases = find_use_cases()
flags = (doctest.ELLIPSIS | doctest.NORMALIZE_WHITESPACE)
globs = {"browser": make_browser(),
         'make_browser': make_browser,
         "app": ADHOCRACY_LAYER_APP,
         'self': ADHOCRACY_LAYER,
         "app_url": app_url,
         "instance_url": instance_url,
         # imports
         'mock': mock,
         'testtools': testtools,
         'model': model,
         }


def test_doctests():
    """
    Executes doctests found in `use_cases` one after the other,
    as py.test supports generator based test cases.

    FIXME: to be replaced by proper py.test doctest discovery.
    """

    def perform_doctest(path):
        test = DocFileTest(
            path,
            # add here aditional testfiles
            setUp=ADHOCRACY_LAYER.setUp,
            tearDown=ADHOCRACY_LAYER.tearDown,
            globs=globs,
            optionflags=flags
        )
        result = test.defaultTestResult()
        test.run(result)
        for t in (result.failures + result.errors):
            raise Exception(t[1])

    for path in use_cases:
        yield (perform_doctest, path)

########NEW FILE########
__FILENAME__ = test_entity_url
#!/usr/bin/env python

from adhocracy.tests import TestController


class TestEntityUrl(TestController):
    """ at the moment these tests are limited only to those cases
    which are interesting for #607. """

    def _make_content(self):
        """Returns instance and user"""

        from adhocracy import model

        instance = model.Instance.find(u'test')
        user = model.User.create(u'user', u'user@mail.com')

        return instance, user

    def test_page_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        page = model.Page.create(instance, u'test_page', u'text', user)
        url = u'http://test.test.lan/page/test_page'

        self.assertEqual(entity_url(page), url)

    def test_page_edit_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        page = model.Page.create(instance, u'test_page', u'text', user)
        url = u'http://test.test.lan/page/test_page/edit'

        self.assertEqual(entity_url(page, member=u'edit'), url)

    def test_subpage_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        parent = model.Page.create(instance, u'test_parent', u'text', user)
        page = model.Page.create(instance, u'test_page', u'text', user)
        page.parents.append(parent)
        url = u'http://test.test.lan/page/test_page'

        self.assertEqual(entity_url(page), url)

    def test_subpage_edit_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        parent = model.Page.create(instance, u'test_parent', u'text', user)
        page = model.Page.create(instance, u'test_page', u'text', user)
        page.parents.append(parent)
        url = u'http://test.test.lan/page/test_page/edit'

        self.assertEqual(entity_url(page, member=u'edit'), url)

    def test_proposal_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        proposal = model.Proposal.create(instance, u'test_proposal', user)
        url = u'http://test.test.lan/proposal/%i-test_proposal' % proposal.id

        self.assertEqual(entity_url(proposal), url)

    def test_proposal_edit_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        proposal = model.Proposal.create(instance, u'test_proposal', user)
        url = u'http://test.test.lan/proposal/%i-test_proposal/edit' % (
            proposal.id)

        self.assertEqual(entity_url(proposal, member=u'edit'), url)

    def test_proposal_comment_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        proposal = model.Proposal.create(instance, u'test_proposal', user)
        comment = model.Comment.create(u'text', user, proposal)
        url = u'http://test.test.lan/proposal/%i-test_proposal#c%i' % (
            proposal.id, comment.id)

        self.assertEqual(entity_url(comment), url)

    def test_sectionpage_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        page = model.Page.create(instance, u'test_page', u'text', user,
                                 sectionpage=True)
        url = u'http://test.test.lan/page/test_page'

        self.assertEqual(entity_url(page), url)

    def test_sectionpage_edit_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        page = model.Page.create(instance, u'test_page', u'text', user,
                                 sectionpage=True)
        url = u'http://test.test.lan/page/test_page/edit'

        self.assertEqual(entity_url(page, member='edit'), url)

    def test_sectionpage_subpage_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        parent = model.Page.create(instance, u'test_parent', u'text', user,
                                   sectionpage=True)
        page = model.Page.create(instance, u'test_page', u'text', user)
        page.parents.append(parent)
        url = u'http://test.test.lan/page/test_parent#subpage-%i' % page.id

        self.assertEqual(entity_url(page), url)

    def test_sectionpage_subpage_edit_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        parent = model.Page.create(instance, u'test_parent', u'text', user,
                                   sectionpage=True)
        page = model.Page.create(instance, u'test_page', u'text', user)
        page.parents.append(parent)
        url = u'http://test.test.lan/page/test_page/edit'

        self.assertEqual(entity_url(page, member=u'edit'), url)

    def test_amendment_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        page = model.Page.create(instance, u'test_page', u'text', user,
                                 sectionpage=True)
        proposal = model.Proposal.create(instance, u'test_proposal', user,
                                         is_amendment=True)
        _selection = model.Selection.create(proposal, page, user)
        url = u'http://test.test.lan/page/test_page?overlay_type=' \
            u'%23overlay-url-big&overlay_path=http%3A%2F%2Ftest.test.lan' \
            u'%2Fpage%2Ftest_page%2Famendment%2F{0}.overlay' \
            .format(proposal.id)

        self.assertEqual(entity_url(proposal), url)

    def test_amendment_edit_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        page = model.Page.create(instance, u'test_page', u'text', user,
                                 sectionpage=True)
        proposal = model.Proposal.create(instance, u'test_proposal', user,
                                         is_amendment=True)
        _selection = model.Selection.create(proposal, page, user)
        url = u'http://test.test.lan/proposal/%i-test_proposal/edit' % (
            proposal.id)

        self.assertEqual(entity_url(proposal, member=u'edit'), url)

    def test_sectionpage_comment_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        instance, user = self._make_content()

        page = model.Page.create(instance, u'test_page', u'text', user,
                                 sectionpage=True)
        comment = model.Comment.create(u'text', user, page)
        url = u'http://test.test.lan/page/test_page?overlay_type=' \
            u'%23overlay-url&overlay_path=http%3A%2F%2Ftest.test.lan%2Fpage' \
            u'%2Ftest_page%2Fcomments.overlay%23c{0}' \
            .format(comment.id)

        self.assertEqual(entity_url(comment), url)

    def test_sectionpage_subpage_comment_entity_url(self):
        from adhocracy.lib.helpers import entity_url
        from adhocracy import model

        self.maxDiff = None

        instance, user = self._make_content()

        parent = model.Page.create(instance, u'test_parent', u'text', user,
                                   sectionpage=True)
        page = model.Page.create(instance, u'test_page', u'text', user)
        page.parents.append(parent)
        comment = model.Comment.create(u'text', user, page)
        url = u'http://test.test.lan/page/test_parent?overlay_type=' \
            u'%23overlay-url&overlay_path=http%3A%2F%2Ftest.test.lan%2Fpage' \
            u'%2Ftest_page%2Fcomments.overlay%23c{0}' \
            .format(comment.id, page.id)

        self.assertEqual(entity_url(comment), url)

########NEW FILE########
__FILENAME__ = test_forms
from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_get_instance, tt_make_instance


class TestValidators(TestController):

    def test_valid_user_badge(self):
        from adhocracy.forms import ValidUserBadge
        from adhocracy.model import UserBadge

        badge = UserBadge.create(u'testbadge', u'#ccc', True, u'description')
        value = ValidUserBadge.to_python(badge.id, None)
        self.assertEqual(value, badge)

    def test_invalid_user_badge(self):
        from formencode import Invalid
        from adhocracy.forms import ValidUserBadge
        from adhocracy.model import UserBadge

        badge = UserBadge.create(u'testbadge', u'#ccc', True, u'description')
        self.assertRaises(Invalid, ValidUserBadge.to_python,
                          badge.id + 1, state=None)

    def test_username_contains_char(self):
        from adhocracy.forms import ContainsChar
        validator = ContainsChar()
        value = validator.to_python(u'ba12', None)
        self.assertEqual(value, u'ba12')

    def test_username_contains_no_char(self):
        from formencode import Invalid
        from adhocracy.forms import ContainsChar
        self.assertRaises(Invalid, ContainsChar.to_python, u'1234', None)

    def test_valid_category_badge(self):
        from formencode import Invalid
        from adhocracy.forms import ValidCategoryBadge
        from adhocracy.model import CategoryBadge, instance_filter

        # the currently set instance ist the test instance. CategoryBadges from
        # the current instance are valid.
        test_instance = tt_get_instance()
        self.assertEqual(test_instance, instance_filter.get_instance())
        test_category = CategoryBadge.create(u'test_category', u'#ccc', True,
                                             u'description', 0, test_instance)
        value = ValidCategoryBadge.to_python(str(test_category.id))
        self.assertEqual(value, test_category)

        # from other instances they are not valid
        other_instance = tt_make_instance(u'other', u'Other Instance')
        other_category = CategoryBadge.create(u'other_category', u'#ccc', True,
                                              u'description', 0,
                                              other_instance)
        self.assertRaises(Invalid, ValidCategoryBadge.to_python,
                          str(other_category.id))

    def test_valid_category_badge_if_empty(self):
        from adhocracy.forms import ValidCategoryBadge
        validator = ValidCategoryBadge(if_empty=None)
        value = validator.to_python('')
        self.assertEqual(value, None)

    def test_valid_imagefile_upload(self):
        from adhocracy.forms.common import ValidImageFileUpload
        from formencode import Invalid
        from cgi import FieldStorage
        from io import BytesIO
        value = FieldStorage()
        value.file = BytesIO(b"binarydata")
        value.filename = u"test.png"
        value.name = u"thumbs"
        self.assertRaises(Invalid, ValidImageFileUpload.to_python, value)

    def test_valid_file_upload(self):
        from adhocracy.forms.common import ValidFileUpload
        from formencode import Invalid
        from cgi import FieldStorage
        from io import BytesIO
        ValidFileUpload.max_size = 1
        value = FieldStorage()
        value.file = BytesIO(b"bi")
        value.filename = u"test.png"
        value.name = u"thumbs"
        self.assertRaises(Invalid, ValidFileUpload.to_python, value)

########NEW FILE########
__FILENAME__ = test_openidauth
#!/usr/bin/env python
# coding: utf-8

import unittest

from adhocracy.controllers.openidauth import is_trusted_provider


class TestOpenIDAuth(unittest.TestCase):
    def test_is_trusted_provider(self):
        self.assertFalse(is_trusted_provider('http://evil.com/openid'))

        self.assertTrue(is_trusted_provider('http://1aA--k.myopenid.com/'))
        self.assertTrue(is_trusted_provider('https://1aA--k.myopenid.com'))
        self.assertTrue(is_trusted_provider(
            'https://www.google.com/accounts/o8/id'))
        self.assertTrue(is_trusted_provider('https://me.yahoo.com/foo'))
        self.assertTrue(is_trusted_provider('http://me.yahoo.com'))

        self.assertFalse(is_trusted_provider(
            'http://evil.com/my.myopenid.com/'))
        self.assertFalse(is_trusted_provider(
            'http://my.myopenid.com.evil.com/'))
        self.assertFalse(is_trusted_provider(
            'http://[2001::bad:1]/my.myopenid.com/'))


if __name__ == '__main__':
    unittest.main()

########NEW FILE########
__FILENAME__ = test_pep8
#!/usr/bin/env python

import os.path
import unittest

import pep8

SRC_PATH = os.path.dirname(os.path.dirname(__file__))
EXCLUDE = ['.svn', 'CVS', '.bzr', '.hg', '.git',
           'Paste-1.7.5.1-py2.6.egg', 'PasteDeploy-1.5.0-py2.6.egg', 'data']


class AdhocracyStyleGuide(pep8.StyleGuide):
    def ignore_code(self, code):
        IGNORED = [
            'E111',  # indentation is not a multiple of four
            'E121',  # continuation line indentation is not a multiple of four
            'E123',  # closing bracket does not match indentation of opening
                     # bracket
            'E124',  # closing bracket does not match visual indentation
            'E126',  # continuation line over
            'E127',  # continuation line over
            'E128',  # continuation line under
            'E501',  # line too long
        ]
        return code in IGNORED


class TestPep8(unittest.TestCase):
    def test_pep8(self):
        sg = AdhocracyStyleGuide(exclude=EXCLUDE)
        sg.input_dir(SRC_PATH)
        self.assertEqual(sg.options.report.get_count(), 0)

########NEW FILE########
__FILENAME__ = test_velruse
#!/usr/bin/env python
# coding: utf-8

from adhocracy.tests import TestController
from adhocracy.tests.testtools import tt_make_user
from adhocracy.model import meta, Velruse as VelruseModel
from adhocracy.controllers.velruse import VelruseController


class TestVelruseController(TestController,
                            VelruseController):

    def test_new_facebook_user(self):

        user, velruse_user = VelruseController._create(self,
                                                       "test_user",
                                                       "Jonny@test.de",
                                                       "facebook",
                                                       "73478347348")

        self.assertEqual(user.id, velruse_user.user_id)

    def test_existing_user_is_matched_by_email(self):

        # his email is Jonny@test.de
        user = tt_make_user("Jonny")

        user2, velruse_user = VelruseController._create(self,
                                                        "test_user",
                                                        "Jonny@test.de",
                                                        "facebook",
                                                        "392833324324")

        self.assertEqual(user, user2)

    def test_connect_existing_user_same_email(self):

        user = tt_make_user("Jonny")

        # his email is Jonny@test.de
        velruse_user = VelruseModel.connect(user,
                                            "facebook",
                                            "239857329847",
                                            "Jonny@test.de",
                                            True)

        meta.Session.commit()

        self.assertNotEqual(velruse_user, None)
        self.assertEqual(user.id, velruse_user.user_id)
        self.assertEqual(user.activation_code, None)

    def test_connect_existing_user_different_email(self):

        user = tt_make_user("Jonny")

        # his email is Jonny@test.de
        velruse_user = VelruseModel.connect(user,
                                            "facebook",
                                            "328957239052",
                                            "DifferentEmail@test.de",
                                            True)

        meta.Session.commit()

        self.assertNotEqual(velruse_user, None)
        self.assertEqual(user.id, velruse_user.user_id)
        self.assertNotEqual(user.activation_code, None)

########NEW FILE########
