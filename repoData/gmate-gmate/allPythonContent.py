__FILENAME__ = gmate
#!/usr/bin/env python
# This program is part of GMATE package
# Gmate script
# Author: Alexandre da Silva
# This scripts whants to allow users to use the gmate command (instead of gedit)
# command from a terminal and pass a directory as the first param.
# passign the directory as a parameter, gedit will open with filebrowser root
# directory pointing that
import gconf
import sys
import urllib
import os
#from optparse import OptionParser

# GConf directory for filebrowser
base = '/apps/gedit-2/plugins/filebrowser/on_load'
config = gconf.client_get_default()
config.add_dir(base, gconf.CLIENT_PRELOAD_NONE)

# Get the last option as file
path = os.path.abspath(sys.argv[-1:][0])

if len(sys.argv) > 1:
    parameters = ' '.join(sys.argv[1:-1])
    if os.path.isdir(path):
        url = "file://%s" % urllib.quote(path)
        config.set_string(os.path.join(base,'virtual_root'), url)
    else:
        parameters += ' "%s"' % path
    os.system('nohup gedit ' + parameters + ' > /dev/null 2>&1 &')
else:
    os.system('nohup gedit > /dev/null 2>&1 &')


########NEW FILE########
__FILENAME__ = bookmarks
# -*- coding: utf-8 -*-

#  Copyright (C) 2008 - Eugene Khorev
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

import pygtk
pygtk.require("2.0")
import gtk

class bookmark_list(object):
    
    def __init__(self, config):
        self._list = {}
        
        self._config = config

        # Load bookmarks from configuration
        sections = config.sections()

        if config.has_section("common"):
            index = sections.index("common")
            del sections[index]
        
        # Create an empty store for the documents that have no bookmarks yet
        self._empty_store = gtk.ListStore(int, str)
        
        for sec in sections:
            store = gtk.ListStore(int, str)
            
            self._list[sec] = {"store": store, "iters": {}}
            
            for line in config.options(sec):
                comment = config.get(sec, line)
                self._list[sec]["iters"][int(line)] = store.append([int(line), comment])
            
            # Setup sorting
            store.set_sort_func(0, self._line_sort)
            store.set_sort_column_id(0, gtk.SORT_ASCENDING)
            
    def get_store(self, uri): # Gets tree store for an uri
        try:
            return self._list[uri]["store"]
        except:
            return self._empty_store
        
    def get_iters(self, uri):
        try:
            return self._list[uri]["iters"]
        except:
            return {}
        
    def add(self, uri, line, source, comment = ""): # Adds a line for an uri (returns True on success)
        exists = self.exists(uri, line)
        
        if comment == "":
            content = source
        else:
            content = comment
        
        if not exists:
            if self._list.has_key(uri):
                self._list[uri]["iters"][line] = self._list[uri]["store"].append([line, content])
            else:
                store = gtk.ListStore(int, str)
                self._list[uri] = {"store": store, "iters": {line: store.append([line, content])}}    
                
                # Setup sorting
                store.set_sort_func(0, self._line_sort)
                store.set_sort_column_id(0, gtk.SORT_ASCENDING)

                # Create uri section in configuration
                self._config.add_section(uri)
            
            # Upadate configuration
            self._config.set(uri, str(line), comment)
        
        return not exists
        
    def delete(self, uri, line = None): # Deletes a line or an entire uri (returns True on success)
        if line:
            exists = self.exists(uri, line)
            
            if exists:
                self._list[uri]["store"].remove(self._list[uri]["iters"][line])
                del self._list[uri]["iters"][line]
                
                # Upadate configuration
                self._config.remove_option(uri, str(line))
                
            return exists
        else:
            try:
                del self._list[uri]
                
                # Upadate configuration
                self._config.remove_section(uri)
                
                return True
            except:
                return False
        
    def exists(self, uri, line): # Returns True if there is a line exists in an uri
        try:
            return self._list[uri]["iters"][line]
        except:
            return False
        
    def toggle(self, uri, line, source, comment = ""): # Adds or removes a line for an uri
        if self.exists(uri, line):
            self.delete(uri, line)
            return False
        else:
            self.add(uri, line, source, comment)
            return True

    def update(self, uri, offset, cur_line, end_line):
        if self._list.has_key(uri):
            iters = {}
            
            keys = self._list[uri]["iters"].keys()
            
            for line in keys:
                row = self._list[uri]["iters"][line]
                
                comment = self._config.get(uri, str(line))
                self._config.remove_option(uri, str(line))

                if line < cur_line:
                    self._list[uri]["store"].set_value(row, 0, line)
                    iters[line] = row
                    
                    # Upadate configuration
                    self._config.set(uri, str(line), comment)
                    
                elif (end_line < 0 and line >= cur_line) or (end_line >= 0 and line > end_line):
                    line = line-offset
                    self._list[uri]["store"].set_value(row, 0, line)
                    iters[line] = row
                    
                    # Upadate configuration
                    self._config.set(uri, str(line), comment)
                    
                else:
                    self._list[uri]["store"].remove(row)
                    
            self._list[uri]["iters"] = iters
            
            return True 
        else:
            return False

    def _line_sort(self, model, line1, line2):
        val1 = model.get_value(line1, 0)
        val2 = model.get_value(line2, 0)

        if val1 < val2:
	        return -1
        if val1 == val2:
	        return 0
        return 1
        
# ex:ts=4:et:

########NEW FILE########
__FILENAME__ = plugin
# -*- coding: utf-8 -*-

#  Copyright (C) 2008 - Eugene Khorev
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

import pygtk
pygtk.require("2.0")
import gtk
import gedit
import time
import os
import sys
import gettext
import ConfigParser
import bookmarks
import window_helper

APP_NAME = "plugin"
LOC_PATH = os.path.join(os.path.expanduser("~/.gnome2/gedit/plugins/advanced-bookmarks/lang"))

gettext.find(APP_NAME, LOC_PATH)
gettext.install(APP_NAME, LOC_PATH, True)

class AdvancedBookmarksPlugin(gedit.Plugin):

    def __init__(self):
        gedit.Plugin.__init__(self)
        
        self._instances = {}

        # Setup configuration file path
        conf_path = os.path.join(os.path.expanduser("~/.gnome2/gedit/plugins/"), "advanced-bookmarks/plugin.conf")
        
        # Check if configuration file does not exists
        if not os.path.exists(conf_path):
            # Create configuration file
            conf_file = file(conf_path, "wt")
            conf_file.close()
            
        # Create configuration dictionary
        self.read_config(conf_path)

        # Create bookmark list
        self._bookmarks = bookmarks.bookmark_list(self._config)
        
    def activate(self, window):
        # Create window helper for an instance
        self._instances[window] = window_helper.window_helper(self, window, self._bookmarks, self._config)
        
    def deactivate(self, window):
        self._instances[window].deactivate()
        del self._instances[window]
        
    def update_ui(self, window):
        self._instances[window].update_ui()
                        
    def create_configure_dialog(self):
        # Create configuration dialog
        self._dlg_config_glade = gtk.glade.XML(os.path.dirname( __file__ ) + "/config_dlg.glade")

        # Get dialog window
        self._dlg_config = self._dlg_config_glade.get_widget("config_dialog") 
        
        # Setup signals
        self._dlg_config_glade.signal_autoconnect(self)
        
        # Setup values of dialog widgets
        highlighting = self._config.getboolean("common", "highlighting")
        chk = self._dlg_config_glade.get_widget("chk_highlight")
        chk.set_active(highlighting)
        
        color = self._config.get("common", "highlight_color")
        btn = self._dlg_config_glade.get_widget("btn_color")
        try:
            btn.set_color(gtk.gdk.color_parse(color))
        except:
            btn.set_color(gtk.gdk.color_parse("#FFF0DC"))
        
        return self._dlg_config
        
    def on_btn_cancel_clicked(self, btn):
        self._dlg_config.response(gtk.RESPONSE_CANCEL)
        
    def on_btn_ok_clicked(self, btn):
        self._dlg_config.response(gtk.RESPONSE_OK)
        
    def on_config_dialog_response(self, dlg, res):
        if res == gtk.RESPONSE_OK:
            # Save configuration
            highlight = self._dlg_config_glade.get_widget("chk_highlight").get_active()
            self._config.set("common", "highlighting", highlight and "on" or "off")
            
            color = self._dlg_config_glade.get_widget("btn_color").get_color().to_string()
            self._config.set("common", "highlight_color", color)
            
            self.write_config()
            
            # Remove bookmark markup in all documents if necessary
            for window in self._instances:
                self._instances[window].setup_highlighting(highlight)
            
        dlg.hide()
            
    def read_config(self, conf_path): # Reads configuration from a file
        self._conf_file = file(conf_path, "r+")
        self._config = ConfigParser.ConfigParser()
        self._config.readfp(self._conf_file)
        
        # Check if there is no necessary options in config
        if not self._config.has_section("common"):
            self._config.add_section("common")
        
        if not self._config.has_option("common", "highlighting"):
            self._config.set("common", "highlighting", "on")
        
        if not self._config.has_option("common", "highlight_color"):
            self._config.set("common", "highlight_color", "#FFF0DC")
        
    def write_config(self): # Saves configuration to a file
        self._conf_file.truncate(0)
        self._conf_file.seek(0)

        self._config.write(self._conf_file)
        
#ex:ts=4:et:

########NEW FILE########
__FILENAME__ = toggle_dlg
# -*- coding: utf-8 -*-

#  Copyright (C) 2008 - Eugene Khorev
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

import pygtk
pygtk.require("2.0")
import gtk
import gedit
import os

class toggle_dlg(gtk.Dialog):

    def __init__(self, parent, config):
        # Create config diaog window
        title = _("Bookmark properties")
        buttons = (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OK, gtk.RESPONSE_OK)

        super(toggle_dlg, self).__init__(title, parent, 0, buttons)
        
        self.vbox.set_homogeneous(False)
        
        # Create diaog items
        self._msg = gtk.Label(_("Comment"))
        self._msg.set_property("xalign", 0.0)
        self.vbox.pack_start(self._msg, True, True, 5)
        
        self._input = gtk.Entry()
        self._input.connect("key-press-event", self._on_input_key)
        self.vbox.pack_start(self._input, True, True, 0)
        
        self._note = gtk.Label(_("(leave blank to use source line)"))
        self.vbox.pack_start(self._note, True, True, 5)
        
        self.vbox.show_all()
        
        # Setup configuration dictionary
        self._config = config
    
    def reset(self, comment = ""):#, prompt = True):
        self._input.set_text(comment)
        self._input.grab_focus()
    
    def get_comment(self):
        return self._input.get_text().strip()
    
    def _on_input_key(self, widget, event):
        if event.keyval == gtk.keysyms.Return:
            self.response(gtk.RESPONSE_OK)
    
# ex:ts=4:et:

########NEW FILE########
__FILENAME__ = window_helper
# -*- coding: utf-8 -*-

#  Copyright (C) 2008 - Eugene Khorev
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

import pygtk
pygtk.require("2.0")
import gtk
import gedit
import time
import os
import sys
import pango
import bookmarks
import toggle_dlg

class window_helper:
    def __init__(self, plugin, window, bookmarks, config):
        self._window = window
        self._plugin = plugin
        
        self._bookmarks = bookmarks
        self._config = config
        
        self._doc_lines = {}

        # Create icon
        self._icon = gtk.Image()
        self._icon.set_from_icon_name('stock_help-add-bookmark', gtk.ICON_SIZE_MENU)
        
        # Insert main menu items
        self._insert_menu()
        
        # Create bookmark toggle dialog
        self._dlg_toggle = toggle_dlg.toggle_dlg(None, self._config)
        self._dlg_toggle.connect("response", self._on_dlg_toggle_response)
        
        # Create bottom pane tree
        self._tree = gtk.TreeView()
        
        # Create line number column
        self._line_column = gtk.TreeViewColumn(_('Line'))
        self._tree.append_column(self._line_column)
        
        self._line_cell = gtk.CellRendererText()
        self._line_column.pack_start(self._line_cell, True)

        self._line_column.add_attribute(self._line_cell, 'text', 0)
        
        # Create comment column
        self._comment_column = gtk.TreeViewColumn(_('Source / Comment'))
        self._tree.append_column(self._comment_column)
        
        self._comment_cell = gtk.CellRendererText()
        self._comment_column.pack_start(self._comment_cell, True)

        self._comment_column.add_attribute(self._comment_cell, 'text', 1)
        self._comment_column.set_cell_data_func(self._comment_cell, self._render_comment_callback)
        
        # Addtitional settings
        self._tree.set_enable_tree_lines(True)
        self._tree.set_search_column(1)
        self._tree.set_rules_hint(True)
        self._tree.set_grid_lines(gtk.TREE_VIEW_GRID_LINES_BOTH)
        
        # Create bottom pane
        self._pane = gtk.ScrolledWindow()

        # Add tree to bottom pane
        self._pane.add(self._tree);
        self._tree.show()

        # Setup row selection event
        self._tree.connect("row-activated", self._on_row_activated)
        self._tree.connect("cursor-changed", self._on_row_selected)
        self._tree.connect("focus-in-event", self._on_tree_focused)

        # Create popup menu for tree
        self._popup_menu = gtk.Menu()
        
        self._pop_toggle = gtk.MenuItem(_("Toggle bookmark"))
        self._pop_toggle.connect("activate", self._on_toggle_bookmark)
        self._pop_toggle.show()
        self._popup_menu.append(self._pop_toggle)
        
        self._pop_edit = gtk.MenuItem(_("Edit bookmark"))
        self._pop_edit.set_sensitive(False)
        self._pop_edit.connect("activate", self._on_edit_clicked)
        self._pop_edit.show()
        self._popup_menu.append(self._pop_edit)
        
        self._popup_menu.attach_to_widget(self._tree, None)
        self._tree.connect("button-release-event", self._on_tree_clicked)
        
        # Create button boxes
        self._btn_hbox = gtk.HBox(False, 5)
        self._btn_vbox = gtk.VBox(False, 0)

        # Create buttons
        self._btn_toggle = gtk.Button(_("Toggle"))
        self._btn_toggle.set_focus_on_click(False)
        self._btn_toggle.connect("clicked", self._on_toggle_bookmark)
        self._btn_vbox.pack_start(self._btn_toggle, False, False, 5)
        
        self._btn_edit = gtk.Button(_("Edit"))
        self._btn_edit.set_sensitive(False)
        self._btn_edit.set_focus_on_click(False)
        self._btn_edit.connect("clicked", self._on_edit_clicked)
        self._btn_vbox.pack_start(self._btn_edit, False, False, 0)
        
        # Pack vbox into hbox
        self._btn_hbox.pack_start(self._btn_vbox, False, False, 5)
        self._btn_vbox.show_all()
        
        # Create layout table
        table = gtk.Table(2, 1)

        table.attach(self._pane,    0, 1, 0, 1)
        table.attach(self._btn_hbox, 1, 2, 0, 1, 0)

        table.show_all()

        # Install layout table into bottom pane
        pane = window.get_bottom_panel()
        pane.add_item(table, _('Bookmarks'), self._icon)

        # Setup handlers for all documents
        for doc in window.get_documents():
            doc.connect("loaded", self._on_doc_loaded)
            
        # Setup tab handlers
        window.connect("tab-added", self._on_tab_added)
        window.connect("tab-removed", self._on_tab_removed)
        window.connect("active-tab-changed", self._on_tab_changed)
    
    def deactivate(self):
        # Remove any installed menu items
        self._remove_menu()

        self._window = None
        self._plugin = None
        self._action_group = None

    def update_ui(self):
        self._action_group.set_sensitive(self._window.get_active_document() != None)
        
        # Swicth bookmark store for current document
        doc = self._window.get_active_document()
        if doc:
            uri = doc.get_uri()
            self._tree.set_model(self._bookmarks.get_store(uri))
            
    def _insert_menu(self):
        # Get UI manager
        manager = self._window.get_ui_manager()

        # Create menu actions
        self._action_group = gtk.ActionGroup("AdvancedBookmarksActions")
        
        self._act_ab = gtk.Action("AdvancedBookmarks", _("Bookmarks"), _("Bookmarks"), None)

        self._act_toggle = gtk.Action("ToggleBookmark", _("Toggle"), _("Toggle"), None)
        self._act_toggle.connect("activate", self._on_toggle_bookmark)
        
        self._act_toggle_adv = gtk.Action("ToggleBookmarkAdvanced", _("Toggle & edit"), _("Toggle & edit"), None)
        self._act_toggle_adv.connect("activate", self._on_toggle_bookmark, True)
        
        self._act_edit = gtk.Action("EditBookmark", _("Edit bookmark"), _("Edit bookmark"), None)
        self._act_edit.connect("activate", self._on_edit_clicked)
        self._act_edit.set_sensitive(False)
        
        self._act_nb = gtk.Action("NumberedBookmarks", _("Numbered bookmarks"), _("Numbered bookmarks"), None)
        hot_key = 0
        self._act_hot_key = {}
        while hot_key < 10:
            self._act_hot_key[hot_key] = gtk.Action("ToggleBookmark%d" % hot_key, _("Toggle bookmark #%s") % hot_key, _("Toggle bookmark #%s") % hot_key, None)
            self._action_group.add_action_with_accel(self._act_hot_key[hot_key], "<Ctrl><Alt>%d" % hot_key)
            hot_key += 1

        self._action_group.add_action(self._act_ab)
        self._action_group.add_action(self._act_nb)
        self._action_group.add_action_with_accel(self._act_toggle, "<Ctrl>b")
        self._action_group.add_action_with_accel(self._act_toggle_adv, "<Ctrl><Shift>b")
        self._action_group.add_action_with_accel(self._act_edit, "<Ctrl><Alt>b")

        # Insert action group
        manager.insert_action_group(self._action_group, -1)

        # Merge UI
        ui_path = os.path.join(os.path.dirname(__file__), "menu.ui.xml")
        self._ui_id = manager.add_ui_from_file(ui_path)

    def _remove_menu(self):
        # Get the GtkUIManager
        manager = self._window.get_ui_manager()

        # Remove the ui
        manager.remove_ui(self._ui_id)

        # Remove the action group
        manager.remove_action_group(self._action_group)

        # Make sure the manager updates
        manager.ensure_update()
        
    def _on_toggle_bookmark(self, action, add_comment=False, hot_key=None):
        # Get document uri
        doc = self._window.get_active_document()
        
        if doc:
        	uri = uri = doc.get_uri()
        else:
        	uri = None
        	
        if uri:
            # Get current position
            text_iter = doc.get_iter_at_mark(doc.get_insert())

            # Get current line number (strarting from 0)
            line = text_iter.get_line()

            exists = self._bookmarks.exists(uri, line+1)
            
            # Clean up comment dialog field (DO NOT MOVE THINS LINE INTO "IF" STATEMENT)
            self._dlg_toggle.reset("")
            
            if not exists and add_comment:
                res = self._dlg_toggle.run()
            else:
                res = gtk.RESPONSE_OK
            
            if res == gtk.RESPONSE_OK:
                comment = self._dlg_toggle.get_comment()
                
                # Get position of the current and the next lines
                start = doc.get_iter_at_line(line)
                end   = doc.get_iter_at_line(line+1)
                
                # Check if we are at the last line
                if start.get_offset() == end.get_offset():
                    end = doc.get_end_iter()
                
                # Get line text
                source = doc.get_text(start, end, False).strip()
                
                # Toggle bookmark
                added = self._bookmarks.toggle(uri, line+1, source, comment)
                
                # Save bookmarks
                self._plugin.write_config()

                # Update sensitivity of edit button and menu item
                self._btn_edit.set_sensitive(added)
                self._act_edit.set_sensitive(added)
                self._pop_edit.set_sensitive(added)

                # Highlight the bookmark and the line
                if added:
                    store = self._bookmarks.get_store(uri)
                    iters = self._bookmarks.get_iters(uri)
                    
                    path = store.get_path(iters[line+1])
                    
                    self._tree.set_model(store)
                    self._tree.set_cursor(path[0])

                highlight = self._config.getboolean("common", "highlighting")
                self.set_line_highlighting(doc, start, end, added and highlight)
                        
	        buf = self._window.get_active_view()
            buf.grab_focus()
        else:
            m = gtk.MessageDialog(self._window, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT, gtk.MESSAGE_INFO, gtk.BUTTONS_OK, _("You can toggle the bookmarks in the saved documents only"))
            m.connect("response", lambda dlg, res: dlg.hide())
            m.run()
                
    def _on_dlg_toggle_response(self, dlg_toggle, res): # Handles toggle dialog response
        # Hide configuration dialog
        dlg_toggle.hide()
    	
    def _on_insert_text(self, textbuffer, iter, text, length):
        # Get document uri
        doc = self._window.get_active_document()
        uri = doc.get_uri()
        
        if uri is not None:
            # Get current line number (strarting from 0)
            line = iter.get_line()            

            # Check if the cursor is placed inside a bookmark
            iters = self._bookmarks.get_iters(uri)
            if iters.has_key(line+1) and iter.get_visible_line_offset() > 0:
                line += 1

            # Get new document line count
            count = doc.get_line_count() + text.count("\n")
			
            # Update bookmarks and number of document lines
            self._update_doc_lines(doc, count, line+1)

    def _on_delete_text(self, textbuffer, start, end):
        # Get document uri
        doc = self._window.get_active_document()
        uri = doc.get_uri()
        
        if uri is not None:
            # Get start and end line numbers (strarting from 0)
            start_line = start.get_line()
            end_line = end.get_line()

            # Check if the cursor is placed at the start of the line next a bookmark
            iters = self._bookmarks.get_iters(uri)
            if iters.has_key(end_line) and end.get_visible_line_offset() == 0:
                start_line += 1
            
            # Get new document line count
            count = doc.get_line_count() - int(abs(end_line - start_line))

            # Update document line count and bookmarks
            self._update_doc_lines(doc, count, start_line+1, end_line)

    def _update_doc_lines(self, doc, line_count, line, end = -1):
        uri = doc.get_uri()
        if uri:
            # Check if there is no number of lines stored yet
            if not self._doc_lines.has_key(uri):
                self._doc_lines[uri] = doc.get_line_count()
                
            # Check if number of lines have to be changed
            if self._doc_lines[uri] != line_count:
                # Update bookmarks
                self._bookmarks.update(uri, self._doc_lines[uri] - line_count, line, end)
                
                # Setup new line count
                self._doc_lines[uri] = line_count
	
            # Save bookmarks
            self._plugin.write_config()
            
    def _on_tab_added(self, window, tab):
        # Get tab document
        doc = tab.get_document()
        
        # Setup document load handler
        doc.connect("loaded", self._on_doc_loaded)

    def _on_tab_removed(self, window, tab):
        docs = window.get_documents()

        if len(docs) <= 0:
            self._tree.set_model()
            self._btn_edit.set_sensitive(False)
            self._act_edit.set_sensitive(False)
            self._pop_edit.set_sensitive(False)
    
    def _on_tab_changed(self, window, tab):
        # Swicth bookmark store for current document
        doc = tab.get_document()
        if doc:
            uri = doc.get_uri()
            self._tree.set_model(self._bookmarks.get_store(uri))

    def _on_doc_changed(self, doc):
        uri = doc.get_uri()
        
        if uri:
            # Update number of lines of the document
            self._doc_lines[uri] = doc.get_line_count()
            
            # Refresh highlighting if needed
            highlight = self._config.getboolean("common", "highlighting")
            if highlight:
                # Cleanup highlighting
                self.setup_highlighting(False, doc)
                
                # Put highlighting back
                self.setup_highlighting(True, doc)
            
            iters = self._bookmarks.get_iters(uri)
            
            # Get current position
            text_iter = doc.get_iter_at_mark(doc.get_insert())

            # Get current line number (strarting from 0)
            line = text_iter.get_line() + 1

            if iters.has_key(line):
                it = iters[line]

                store = self._bookmarks.get_store(uri)
                
                if self._config.get(uri, str(line)) == "":
                    # Get position of the current and the next lines
                    start = doc.get_iter_at_line(line-1)
                    end   = doc.get_iter_at_line(line)
                    
                    # Check if we are at the last line
                    if start.get_offset() == end.get_offset():
                        end = doc.get_end_iter()
                    
                    # Get line text
                    source = doc.get_text(start, end, False).strip()
                    
                    store.set_value(it, 1, source.strip())

    def _on_doc_loaded(self, doc, arg, put=True, connect_signals=True):
        # Update comments
        uri = doc.get_uri()
        
        if uri:
            highlight = self._config.getboolean("common", "highlighting")
            
            store = self._bookmarks.get_store(uri)
            iters = self._bookmarks.get_iters(uri)
            
            for i in iters:
                it = iters[i]

                line = int(store.get_value(it, 0)) - 1
                
                start = doc.get_iter_at_line(line)
                end   = doc.get_iter_at_line(line+1)
                
                # Check if we are at the last line
                if start.get_offset() == end.get_offset():
                    end = doc.get_end_iter()
                
                self.set_line_highlighting(doc, start, end, put and highlight)
                    
                if store.get_value(it, 1) == "":
                    source = doc.get_text(start, end, False)
                    store.set_value(it, 1, source.strip())
            
        if connect_signals:
            # Setup update handlers
            doc.connect("insert-text",  self._on_insert_text)
            doc.connect("delete-range", self._on_delete_text)
            doc.connect("changed",      self._on_doc_changed)
            doc.connect("cursor-moved", self._on_cursor_moved)
        
    def _on_edit_clicked(self, btn):
        model = self._tree.get_model()

        cursor = self._tree.get_cursor()
        
        if cursor and cursor[0]:
            row = cursor[0][0]

            self._on_row_activated(self._tree, row, 0)

    def _on_tree_clicked(self, tree, event):
    	if event.button == 3:
	    	self._popup_menu.popup(None, None, None, event.button, event.time)
    	
    	return False

    def _on_row_selected(self, tree):
        model = tree.get_model()
        cursor = tree.get_cursor()
        
        if cursor:
            row = cursor[0][0]
            
            # Set comment button sensitivity
            self._btn_edit.set_sensitive(True)
            self._act_edit.set_sensitive(True)
            self._pop_edit.set_sensitive(True)
            
            # Get bookmark line
            bookmark = model.get_iter(row)
            line = model.get_value(bookmark, 0)
            
            # Get active document
            doc = self._window.get_active_document()
            buf = self._window.get_active_view()
            
            # Get current position
            text_iter = doc.get_iter_at_mark(doc.get_insert())

            if line != text_iter.get_line()+1:
                # Jump to bookmark
                doc.goto_line(int(line)-1)
                buf.scroll_to_cursor()
                buf.grab_focus()

    def _on_row_activated(self, tree, row, column):
        # Get document uri
        doc = self._window.get_active_document()
        uri = doc.get_uri()

        # Get bookmark line
        model = tree.get_model()
        bookmark = model.get_iter(row)
        line = model.get_value(bookmark, 0)
        
        comment = self._config.get(uri, str(line))
        
        self._dlg_toggle.reset(comment)
        res = self._dlg_toggle.run()

        if res == gtk.RESPONSE_OK:
            comment = self._dlg_toggle.get_comment()
            
            # Delete existing bookmark 
            self._bookmarks.delete(uri, line)

            # Get position of the current and the next lines
            start = doc.get_iter_at_line(line-1)
            end   = doc.get_iter_at_line(line)
            
            # Check if we are at the last line
            if start.get_offset() == end.get_offset():
                end = doc.get_end_iter()
            
            # Get line text
            source = doc.get_text(start, end, False).strip()
            
            # Add bookmark
            self._bookmarks.add(uri, line, source, comment)
            self._tree.set_model(self._bookmarks.get_store(uri))
            
            # Save bookmarks
            self._plugin.write_config()
        
    def _on_tree_focused(self, tree, direction):
        view = self._window.get_active_view()
        view.grab_focus()
        
    def _render_comment_callback(self, column, cell_renderer, tree_model, iter):
        doc = self._window.get_active_document()
        uri = doc.get_uri()
        
        if uri:
            line = tree_model.get_value(iter, 0)
            text = tree_model.get_value(iter, 1)
            
            if self._bookmarks.exists(uri, line):
                comment = self._config.get(uri, str(line))
                
                if comment != "":
                    cell_renderer.set_property("style", pango.STYLE_ITALIC)
                    cell_renderer.set_property("text", "'"+text+"'")
                else:
                    cell_renderer.set_property("style", pango.STYLE_NORMAL)
    
    def _on_cursor_moved(self, doc):
        uri = doc.get_uri()

        store = self._bookmarks.get_store(uri)
        
        # Get current position
        text_iter = doc.get_iter_at_mark(doc.get_insert())

        # Get current line number (strarting from 0)
        line = text_iter.get_line() + 1

        exists = self._bookmarks.exists(uri, line)
        
        if exists:
            iters = self._bookmarks.get_iters(uri)
            
            path = store.get_path(iters[line])
            
            self._tree.set_cursor(path[0])
        else:
            sel = self._tree.get_selection()
            sel.unselect_all()
            
            self._btn_edit.set_sensitive(False)
            self._act_edit.set_sensitive(False)
            self._pop_edit.set_sensitive(False)
    
    def set_line_highlighting(self, doc, start, end, highlight):
        tag_table = doc.get_tag_table()
        tag = tag_table.lookup("bookmark")
        
        if tag is None:
            color = self._config.get("common", "highlight_color")
            tag = doc.create_tag("bookmark", paragraph_background_gdk = gtk.gdk.color_parse(color))
        
        if highlight:
            doc.apply_tag(tag, start, end)
        else:
            doc.remove_tag(tag, start, end)
    
    def _remove_highlighting(self, doc):
        tag_table = doc.get_tag_table()
        tag = tag_table.lookup("bookmark")
        
        if tag is not None:
            start = doc.get_start_iter()
            end = doc.get_end_iter()
            doc.remove_tag(tag, start, end)
    
    def setup_highlighting(self, highlight, doc=None):
        func = highlight and (lambda doc: self._on_doc_loaded(doc, None, True, False)) or (lambda doc: self._remove_highlighting(doc))
        
        if doc is None:
            docs = self._window.get_documents()
        else:
            docs = [doc]
            
        for d in docs:
            tag_table = d.get_tag_table()
            tag = tag_table.lookup("bookmark")
            
            if tag is not None:
                tag_table.remove(tag)
                color = self._config.get("common", "highlight_color")
                tag = d.create_tag("bookmark", paragraph_background_gdk = gtk.gdk.color_parse(color))

            func(d)
    
# ex:ts=4:et:

########NEW FILE########
__FILENAME__ = align
# Copyright (C) 2006 Osmo Salomaa
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.


"""Align blocks of text into columns."""


from gettext import gettext as _
import gedit
import gtk
import gtk.glade
import os


UI = """
<ui>
  <menubar name="MenuBar">
    <menu name="EditMenu" action="Edit">
      <placeholder name="EditOps_6">
        <menuitem name="Align" action="Align"/>
      </placeholder>
    </menu>
  </menubar>
</ui>"""


class AlignDialog(object):

    """Dialog for specifying an alignment separator."""

    def __init__(self, parent):

        path = os.path.join(os.path.dirname(__file__), 'align.glade')
        glade_xml = gtk.glade.XML(path)
        self.dialog = glade_xml.get_widget('dialog')
        self.entry = glade_xml.get_widget('entry')

        self.dialog.set_transient_for(parent)
        self.dialog.set_default_response(gtk.RESPONSE_OK)

    def destroy(self):
        """Destroy the dialog."""

        return self.dialog.destroy()

    def get_separator(self):
        """Get separator."""

        return self.entry.get_text()

    def run(self):
        """Show and run the dialog."""

        self.dialog.show()
        return self.dialog.run()


class AlignPlugin(gedit.Plugin):

    """Align blocks of text into columns."""

    def __init__(self):

        gedit.Plugin.__init__(self)

        self.action_group = None
        self.ui_id = None
        self.window = None

    def activate(self, window):
        """Activate plugin."""

        self.window = window
        self.action_group = gtk.ActionGroup('AlignPluginActions')
        self.action_group.add_actions([(
            'Align',
            None,
            _('Ali_gn...'),
            None,
            _('Align the selected text to columns'),
            self.on_align_activate
        )])
        uim = window.get_ui_manager()
        uim.insert_action_group(self.action_group, -1)
        self.ui_id = uim.add_ui_from_string(UI)

    def align(self, doc, bounds, separator):
        """Align the selected text into columns."""

        splitter = separator.strip() or ' '
        lines = range(bounds[0].get_line(), bounds[1].get_line() + 1)

        # Split text to rows and columns.
        # Ignore lines that don't match splitter.
        matrix = []
        for i in reversed(range(len(lines))):
            line_start = doc.get_iter_at_line(lines[i])
            line_end = line_start.copy()
            line_end.forward_to_line_end()
            text = doc.get_text(line_start, line_end)
            if text.find(splitter) == -1:
                lines.pop(i)
                continue
            matrix.insert(0, text.split(splitter))
        for i in range(len(matrix)):
            matrix[i][0] = matrix[i][0].rstrip()
            for j in range(1, len(matrix[i])):
                matrix[i][j] = matrix[i][j].strip()

        # Find out column count and widths.
        col_count = max(list(len(x) for x in matrix))
        widths = [0] * col_count
        for row in matrix:
            for i, element in enumerate(row):
                widths[i] = max(widths[i], len(element))

        doc.begin_user_action()

        # Remove text and insert column elements.
        for i, line in enumerate(lines):
            line_start = doc.get_iter_at_line(line)
            line_end = line_start.copy()
            line_end.forward_to_line_end()
            doc.delete(line_start, line_end)
            for j, element in enumerate(matrix[i]):
                offset = sum(widths[:j])
                itr = doc.get_iter_at_line(line)
                itr.set_line_offset(offset)
                doc.insert(itr, element)
                if j < col_count - 1:
                    itr.set_line_offset(offset + len(element))
                    space = ' ' * (widths[j] - len(element))
                    doc.insert(itr, space)

        # Insert separators.
        for i, line in enumerate(lines):
            for j in reversed(range(len(matrix[i]) - 1)):
                offset = sum(widths[:j + 1])
                itr = doc.get_iter_at_line(line)
                itr.set_line_offset(offset)
                doc.insert(itr, separator)

        doc.end_user_action()

    def deactivate(self, window):
        """Deactivate plugin."""

        uim = window.get_ui_manager()
        uim.remove_ui(self.ui_id)
        uim.remove_action_group(self.action_group)
        uim.ensure_update()

        self.action_group = None
        self.ui_id = None
        self.window = None

    def on_align_activate(self, *args):
        """Align the selected text into columns."""

        doc = self.window.get_active_document()
        bounds = doc.get_selection_bounds()
        if not bounds:
            return
        dialog = AlignDialog(self.window)
        response = dialog.run()
        separator = dialog.get_separator()
        dialog.destroy()
        if response == gtk.RESPONSE_OK and separator:
            self.align(doc, bounds, separator)

    def update_ui(self, window):
        """Update sensitivity of plugin's actions."""

        doc = self.window.get_active_document()
        self.action_group.set_sensitive(doc is not None)

########NEW FILE########
__FILENAME__ = localization
# Align columns - Gedit plugin
#
# Copyright (c) 2011 Hugo Henriques Maia Vieira
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import gettext
import os

class Localization():
    """Provides a helper to easily setup l10n."""

    _initialized = False

    _domain = 'messages'
    _locale_path = os.path.join(os.path.dirname(__file__), 'locale')

    @classmethod
    def setup(cls):
        """Sets up the gettext localization."""

        if (not cls._initialized):
            gettext.install(cls._domain, cls._locale_path)
            cls._initialized = True


########NEW FILE########
__FILENAME__ = text_block
# Copyright (c) 2011 Hugo Henriques Maia Vieira
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import re

class WhiteSpacesError(Exception): pass
class DifferentNumberOfColumnsError(Exception): pass

class TextBlock(object):

    def __init__(self, text):
        text = text.decode('utf-8')
        if re.match(r'^\s*$', text): raise WhiteSpacesError

        self.lines_str = self.text_to_lines(text)

        self.columns_number = self.get_columns_number()

        self.tabulation = self.get_tabulations()
        self.lines_list = self.line_items()
        self.columns = self.size_of_columns()


    def get_columns_number(self):
        pipes_number = self.lines_str[0].count('|')
        for line in self.lines_str:
            if line.count('|') != pipes_number:
                raise DifferentNumberOfColumnsError
        columns_number = pipes_number - 1
        return columns_number



    def text_to_lines(self, text):
        lines = text.split('\n')
        white = re.compile(r'^\s*$')

        # del internal empty lines
        i=0
        while i < len(lines):
            if re.match(white, lines[i]):
                del lines[i]
            i+=1

        if re.match(white, lines[0]): lines = lines[1:] # del first empty line
        if re.match(white, lines[-1]): lines = lines[:-1] # del last empty line

        return lines

    def get_tabulations(self):
        tabulation = []
        for line in self.lines_str:
            tabulation.append(re.search(r'\s*', line).group())
        return tabulation

    def size_of_columns(self):
        number_of_columns = len(self.lines_list[0])
        columns = []
        for number in range(number_of_columns):
            columns.append(0)

        for line in self.lines_list:
            i=0
            for item in line:
                if len(item).__cmp__(columns[i]) == 1: # test if are greater than
                    columns[i] = len(item)
                i+=1
        return columns


    def line_items(self):
        line_items = []
        for line in self.lines_str:
            line = line.split('|')
            line = line[1:-1] # del first and last empty item (consequence of split)
            items=[]
            for item in line:
                i = re.search(r'(\S+([ \t]+\S+)*)+', item)
                if i:
                    items.append(i.group())
                else:
                    items.append(" ")
            line_items.append(items)
        return line_items


    def align(self):
        text = ""
        i=0
        for line in self.lines_list:
            text += self.tabulation[i]
            for index in range(len(self.columns)):
                text += '| ' + line[index] + (self.columns[index] - len(line[index]))*' ' + ' '
            text += '|\n'
            i+=1
        text = text[:-1] # del the last \n
        return text


########NEW FILE########
__FILENAME__ = window_helper
# Align columns - Gedit plugin
#
# Copyright (c) 2011 Hugo Henriques Maia Vieira
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import gtk
import os

from localization import Localization

from text_block import TextBlock, DifferentNumberOfColumnsError, WhiteSpacesError

class WindowHelper:
    """Align text blocks into columns separated by pipe ( | )"""

    _UI_FILE = os.path.join(os.path.dirname(__file__), 'align_columns_menu.ui.xml')

    def __init__(self, window):
        """Constructor."""
        self._window = window
        self._action_group = None
        Localization.setup()
        self._insert_menu()

    def deactivate(self):
        """Deactivates the plugin for a window."""
        self._remove_menu()
        self._window = None
        self._action_group = None

    def update_ui(self):
        """Reacts on user interface updates for a window."""
        self._action_group.set_sensitive(self._has_active_view())

    def _insert_menu(self):
        """Adds the menu entries."""
        manager = self._window.get_ui_manager()

        self._action_group = gtk.ActionGroup("AlignColumnsActions")

        action_align_columns = gtk.Action("AlignColumns",
                                          _("Align columns"),
                                          _("Align columns"),
                                          None)
        action_align_columns.connect('activate', self.on_align_columns_activate)

        self._action_group.add_action_with_accel(action_align_columns,
                                                 '<Shift><Alt>a')

        manager.insert_action_group(self._action_group)

        # Merge the UI
        self._ui_id = manager.add_ui_from_file(self.__class__._UI_FILE)

    def _remove_menu(self):
        """Removes the additional menu entries."""
        manager = self._window.get_ui_manager()
        manager.remove_ui(self._ui_id)
        manager.remove_action_group(self._action_group)
        manager.ensure_update()

    def on_align_columns_activate(self, action):
        """Callback to align columns on menu click or accelerator."""
        doc = self._window.get_active_document()
        bounds = doc.get_selection_bounds()

        if not doc or not bounds:
            return

        text = doc.get_text(*bounds)
        try:
            text_block = TextBlock(text)
            aligned_columns = text_block.align()
            doc.delete_interactive(*bounds, default_editable=True)
            doc.insert(bounds[0], aligned_columns)
        except WhiteSpacesError:
            return
        except DifferentNumberOfColumnsError:
            message = gtk.MessageDialog(None, 0, gtk.MESSAGE_WARNING, gtk.BUTTONS_OK,
                                        'The selection has lines with different numbers of columns.')
            message.run()
            message.destroy()

    def _has_active_view(self):
        """Returns 'true' if there is an active view."""
        return (self._window.get_active_view() != None)


########NEW FILE########
__FILENAME__ = browserwidget
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import gobject
import gedit
import options
import imagelibrary

class ClassBrowser( gtk.VBox ):
    """ A widget that resides in gedits side panel. """

    def __init__(self, geditwindow):
        """ geditwindow -- an instance of gedit.Window """
        
        imagelibrary.initialise()

        gtk.VBox.__init__(self)
        self.geditwindow = geditwindow

        try: self.encoding = gedit.encoding_get_current()
        except: self.encoding = gedit.gedit_encoding_get_current()

        self.active_timeout = False

        self.parser = None
        self.document_history = [] # contains tuple (doc,line,col)
        self.history_pos = 0
        self.previousline = 0

        self.back = gtk.ToolButton(gtk.STOCK_GO_BACK)
        self.back.connect("clicked",self.history_back)
        self.back.set_sensitive(False)
        self.forward = gtk.ToolButton(gtk.STOCK_GO_FORWARD)
        self.forward.connect("clicked",self.history_forward)
        self.forward.set_sensitive(False)

        tb = gtk.Toolbar()
        tb.add(self.back)
        tb.add(self.forward)
        #self.pack_start(tb,False,False)

        # add a treeview
        sw = gtk.ScrolledWindow()
        sw.set_policy(gtk.POLICY_AUTOMATIC, gtk.POLICY_AUTOMATIC)
        sw.set_shadow_type(gtk.SHADOW_IN)
        self.browser = gtk.TreeView()
        self.browser.set_headers_visible(False)
        sw.add(self.browser)
        self.browser.connect("button_press_event",self.__onClick)
        
        self.pack_start(sw)

        # add a text column to the treeview
        self.column = gtk.TreeViewColumn()
        self.browser.append_column(self.column)

        self.cellrendererpixbuf = gtk.CellRendererPixbuf()
        self.column.pack_start(self.cellrendererpixbuf,False)

        self.crt = gtk.CellRendererText()
        self.column.pack_start(self.crt,False)

        # connect stuff
        self.browser.connect("row-activated",self.on_row_activated)
        self.show_all()
        

    def history_back(self, widget):
        if self.history_pos == 0: return
        self.history_pos -= 1
        entry = self.document_history[self.history_pos]
        self.__openDocumentAtLine( entry[0],entry[1],entry[2],False )
        if len(self.document_history) > 1: self.forward.set_sensitive(True)
        if self.history_pos <= 0: self.back.set_sensitive(False)
            
            
    def history_forward(self, widget):
        if self.history_pos+1 > len(self.document_history): return
        self.history_pos += 1
        entry = self.document_history[self.history_pos]
        self.__openDocumentAtLine( entry[0],entry[1],entry[2],False )
        self.back.set_sensitive(True)
        if self.history_pos+1 >= len(self.document_history):
            self.forward.set_sensitive(False)


    def set_model(self, treemodel, parser=None):
        """ set the gtk.TreeModel that contains the current class tree.
        parser must be an instance of a subclass of ClassParserInterface. """
        self.browser.set_model(treemodel)
        if parser:
            self.column.set_cell_data_func(self.crt, parser.cellrenderer)
            self.column.set_cell_data_func(self.cellrendererpixbuf, parser.pixbufrenderer)
        self.parser = parser
        self.browser.queue_draw()
              
              
    def __jump_to_tag(self, path):
        try:
            path, line = self.parser.get_tag_position(self.browser.get_model(),path)
            self.__openDocumentAtLine(path, line)
        except:
            print "Classbrowser: Unable to jump to path:",path
                
                
    def on_row_activated(self, treeview, path, view_column):
        if self.parser: self.__jump_to_tag(path)


    def __onClick(self, treeview, event):
        if event.button == 2:
            if options.singleton().jumpToTagOnMiddleClick:
                x, y = int(event.x), int(event.y)
                pthinfo = treeview.get_path_at_pos(x, y)
                if pthinfo is None: return
                path, col, cellx, celly = pthinfo
                self.__jump_to_tag(path)
                return True   
        if event.button == 3:
            x, y = int(event.x), int(event.y)
            pthinfo = treeview.get_path_at_pos(x, y)
            if pthinfo is None: return
            path, col, cellx, celly = pthinfo
            #treeview.grab_focus()
            #treeview.set_cursor(path)

            menu = gtk.Menu()

            tagpos = self.parser.get_tag_position(self.browser.get_model(),path)
            if tagpos is not None:
                filename, line = tagpos
                m = gtk.ImageMenuItem(gtk.STOCK_JUMP_TO)
                menu.append(m)
                m.show()
                m.connect("activate", lambda w,p,l: self.__openDocumentAtLine(p,l), filename, line )

            # add the menu items from the parser
            menuitems = self.parser.get_menu(self.browser.get_model(),path)
            for item in menuitems:
                menu.append(item)
                item.show()
                
            m = gtk.SeparatorMenuItem()
            m.show()
            menu.append( m )
            
            
            m = gtk.CheckMenuItem("Auto-_collapse")
            menu.append(m)
            m.show()
            m.set_active( options.singleton().autocollapse )
            def setcollapse(w):
                options.singleton().autocollapse = w.get_active()
            m.connect("toggled", setcollapse )
            
            menu.popup( None, None, None, event.button, event.time)
            

    def get_current_iter(self):
       doc = self.geditwindow.get_active_document() 
       iter = None
       path = None
       if doc and self.parser:
            it = doc.get_iter_at_mark(doc.get_insert())
            line = it.get_line()            
            model = self.browser.get_model()
            path = self.parser.get_tag_at_line(model, doc, line)
            #if there is no current tag, get the root
            if path is None: 
                iter = model.get_iter_root()
                path = model.get_path(iter)
            else:
                #Get current tag
                iter = model.get_iter(path)
       return iter, path


    """ Jump to next/previous tag depending on direction (0, 1)"""
    def jump_to_tag(self, direction = 1): 
    
        #use self dince python doesn't have true closures, yuck!
        self.iter_target = None
        self.iter_next = None
        self.iter_found = False

        def get_previous(model, path, iter, path_searched):
             if path_searched is None:
                self.iter_found = True
                self.iter_target = model.get_iter_root()
             if path == path_searched:
                self.iter_found = True
                #if we are at the beginning of the tree
                if self.iter_target is None:
                    self.iter_target = model.get_iter_root()
                return True
             self.iter_target = iter
             return False


        def get_next(model,path, iter, path_searched):
            if path_searched is None:
                self.iter_found = True
                self.iter_target = model.get_iter_root()
            if self.iter_found: 
                self.iter_target = iter
                return True
            if path == path_searched:  self.iter_found = True   
            return False
        search_funcs = get_previous, get_next

        if ( 0 > direction) or (len(search_funcs) <= direction):
            print "Direction ", direction, " must be between 0 and ", len(search_funcs)
            raise ValueError, "Invalid direction"

        model = self.browser.get_model()
        iter, path = self.get_current_iter()
        model.foreach(search_funcs[direction], path)

        if not self.iter_found or not self.iter_target: 
            if options.singleton().verbose: print "No target path"
            return 
        target_path = model.get_path(self.iter_target)
        tagpos = self.parser.get_tag_position(model, target_path)
        if tagpos is not None:
            path, line = tagpos
            if options.singleton().verbose: print "jump to", path
            self.__openDocumentAtLine(path,line)

        
    def __openDocumentAtLine(self, filename, line, column=1, register_history=True):
        """ open a the file specified by filename at the given line and column
        number. Line and column numbering starts at 1. """
        
        if line == 0 or column == 0:
            raise ValueError, "line and column numbers start at 1"
        
        documents = self.geditwindow.get_documents()
        found = None
        for d in documents:
            if d.get_uri() == filename:
                found = d
                break

        # open an existing tab or create a new one
        if found is not None:
            tab = gedit.tab_get_from_document(found)
            self.geditwindow.set_active_tab(tab)
            doc = tab.get_document()
            doc.begin_user_action()
            it = doc.get_iter_at_line_offset(line-1,column-1)
            doc.place_cursor(it)
            (start, end) = doc.get_bounds()
            self.geditwindow.get_active_view().scroll_to_iter(end,0.0)
            self.geditwindow.get_active_view().scroll_to_iter(it,0.0)
            self.geditwindow.get_active_view().grab_focus()
            doc.end_user_action()
        else:
            tab = self.geditwindow.create_tab_from_uri(filename,self.encoding,line,False,False)
            self.geditwindow.set_active_tab(tab)
            found = self.geditwindow.get_active_document()

        # place mark
        #it = found.get_iter_at_line(line-1)
        #mark = found.create_marker(None,"jumped_to",it)

        if register_history:
            self.document_history.append( (filename,line,column) )
            self.back.set_sensitive(True)
            self.forward.set_sensitive(False)
            self.history_pos += 1


    def on_cursor_changed(self, *args):
        """
        I need to catch changes in the cursor position to highlight the current tag
        in the class browser. Unfortunately, there is no signal that gets emitted
        *after* the cursor has been changed, so I have to use a timeout.
        """
        if not self.active_timeout:
            gobject.timeout_add(100,self.update_cursor)
            self.active_timeout = True

    def update_cursor(self, *args):
        doc = self.geditwindow.get_active_document()
        if doc and self.parser:
            it = doc.get_iter_at_mark(doc.get_insert())
            line = it.get_line()
            if line != self.previousline:
                self.previousline = line
                if options.singleton().verbose: print "current line:",line

                # pipe the current line to the parser
                self.parser.current_line_changed(self.browser.get_model(), doc, line)

                # set cursor on the tag the cursor is pointing to
                try:
                    path = self.parser.get_tag_at_line(self.browser.get_model(),doc,line)
                    if path:
                        self.browser.realize()
                        if options.singleton().autocollapse: self.browser.collapse_all()
                        self.browser.expand_to_path(path)
                        self.browser.set_cursor(path)
                        if options.singleton().verbose: print "jump to", path

                except Exception, e:
                    if options.singleton().verbose: print "no tag at line",line

        self.active_timeout = False
        return False

########NEW FILE########
__FILENAME__ = imagelibrary
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

# The class browser pixmaps are stolen from Jesse Van Den Kieboom's
# ctags plugin (http://live.gnome.org/Gedit/PluginCodeListing)

import gtk
import sys, os

pixbufs = {
    "class" : None,
    "default" : None,
    "enum" : None,
    "enum_priv" : None,
    "enum_prot" : None,
    "field" : None,
    "field_priv" : None,
    "field_prot" : None,
    "method" : None,
    "method_priv" : None,
    "method_prot" : None,
    "namespace" : None,
    "patch" : None,
    "struct" : None,
    "struct_priv" : None,
    "struct_prot" : None,
    "variable" : None,
}

def initialise():
    for key in pixbufs:
        try:
            name = "%s.png" % key
            filename = os.path.join(sys.path[0],"classbrowser","pixmaps",name)
            if not os.path.exists(filename):
                filename = os.path.join(os.path.dirname(__file__),"pixmaps",name)
            pixbufs[key] = gtk.gdk.pixbuf_new_from_file(filename)
        except:
            print "Class browser plugin couldn't locate",filename





########NEW FILE########
__FILENAME__ = options
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gobject
import gtk
import gconf

def singleton():
    if Options.singleton is None:
        Options.singleton = Options()
    return Options.singleton

class Options(gobject.GObject):

    __gsignals__ = {
        'options-changed' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE, ()),
    }

    singleton = None

    def __init__(self):

        gobject.GObject.__init__(self)
        self.__gconfDir = "/apps/gedit-2/plugins/classbrowser"

        # default values
        self.verbose = False
        self.autocollapse = True
        self.jumpToTagOnMiddleClick = False
        self.colours = {
            "class" : gtk.gdk.Color(50000,20000,20000),
            "define": gtk.gdk.Color(60000,0,0),
            "enumerator": gtk.gdk.Color(0,0,0),
            "member" : gtk.gdk.Color(0,0,60000),
            "function" : gtk.gdk.Color(50000,0,60000),
            "namespace" : gtk.gdk.Color(0,20000,0),
        }
    
        # create gconf directory if not set yet
        client = gconf.client_get_default()        
        if not client.dir_exists(self.__gconfDir):
            client.add_dir(self.__gconfDir,gconf.CLIENT_PRELOAD_NONE)

        # get the gconf keys, or stay with default if key not set
        try:
            self.verbose = client.get_bool(self.__gconfDir+"/verbose") \
                or self.verbose 

            self.autocollapse = client.get_bool(self.__gconfDir+"/autocollapse") \
                or self.autocollapse 

            self.jumpToTagOnMiddleClick = client.get_bool(self.__gconfDir+"/jumpToTagOnMiddleClick") \
                or self.jumpToTagOnMiddleClick 

            for i in self.colours:
                col = client.get_string(self.__gconfDir+"/colour_"+i)
                if col: self.colours[i] = gtk.gdk.color_parse(col)

        except Exception, e: # catch, just in case
            print e
            
    def __del__(self):
        # write changes to gconf
        client = gconf.client_get_default()
        client.set_bool(self.__gconfDir+"/verbose", self.verbose)
        client.set_bool(self.__gconfDir+"/autocollapse", self.autocollapse)
        client.set_bool(self.__gconfDir+"/jumpToTagOnMiddleClick", self.jumpToTagOnMiddleClick)
        for i in self.colours:
            client.set_string(self.__gconfDir+"/colour_"+i, self.color_to_hex(self.colours[i]))

    def create_configure_dialog(self):
        win = gtk.Window()
        win.connect("delete-event",lambda w,e: w.destroy())
        win.set_title("Class Browser Preferences")
        win.set_position(gtk.WIN_POS_CENTER)
        win.set_type_hint(gtk.gdk.WINDOW_TYPE_HINT_DIALOG)
        win.set_border_width(6)
        vbox = gtk.VBox() 

        #--------------------------------  

        notebook = gtk.Notebook()
        notebook.set_border_width(6)
        vbox.pack_start(notebook)

        vbox2 = gtk.VBox(spacing=6)
        vbox2.set_border_width(6)
        
        box = gtk.HBox()
        autocollapse = gtk.CheckButton("Auto-_collapse symbol tree")
        autocollapse.set_active(self.autocollapse)
        box.pack_start(autocollapse,False,False,6)
        vbox2.pack_start(box,False)

        box = gtk.HBox()
        jumpToTagOnMiddleClick = gtk.CheckButton("_Jump to tag on middle click")
        jumpToTagOnMiddleClick.set_active(self.jumpToTagOnMiddleClick)
        box.pack_start(jumpToTagOnMiddleClick,False,False,6)
        vbox2.pack_start(box,False)
        
        box = gtk.HBox()
        verbose = gtk.CheckButton("Show _debug information")
        verbose.set_active(self.verbose)
        box.pack_start(verbose,False,False,6)
        vbox2.pack_start(box,False)

        notebook.append_page(vbox2,gtk.Label("General"))

        #--------------------------------       
        vbox2 = gtk.VBox(spacing=6)
        vbox2.set_border_width(6)

        button = {}
        for i in self.colours:
            box = gtk.HBox(spacing=6)
            button[i] = gtk.ColorButton()
            button[i].set_color(self.colours[i])
            box.pack_end(button[i],False)
            box.pack_start(gtk.Label(i.capitalize() + " :"), False, False, 6)
            vbox2.pack_start(box)

        notebook.append_page(vbox2,gtk.Label("Colours"))

        def setValues(w):

            # set class attributes
            self.verbose = verbose.get_active()
            self.autocollapse = autocollapse.get_active()
            self.jumpToTagOnMiddleClick = jumpToTagOnMiddleClick.get_active()
            for i in self.colours:
                self.colours[i] = button[i].get_color()
                
            # write changes to gconf
            client = gconf.client_get_default()

            client.set_bool(self.__gconfDir+"/verbose", self.verbose)
            client.set_bool(self.__gconfDir+"/autocollapse", self.autocollapse)
            client.set_bool(self.__gconfDir+"/jumpToTagOnMiddleClick", self.jumpToTagOnMiddleClick)
            for i in self.colours:
                client.set_string(self.__gconfDir+"/colour_"+i, self.color_to_hex(self.colours[i]))

            # commit changes and quit dialog
            self.emit("options-changed")
            win.destroy()

        box = gtk.HButtonBox()
        box.set_spacing(6)
        box.set_border_width(6)
        box.set_layout(gtk.BUTTONBOX_END)
        b = gtk.Button(None,gtk.STOCK_CANCEL)
        b.connect("clicked",lambda w,win: win.destroy(),win)
        box.add(b)
        b = gtk.Button(None,gtk.STOCK_OK)
        b.connect("clicked",setValues)
        box.add(b)
        vbox.pack_start(box,False)

        win.add(vbox)
        win.show_all()        
        return win

    def color_to_hex(self, color ):
        r = str(hex( color.red / 256 ))[2:]
        g = str(hex( color.green / 256 ))[2:]
        b = str(hex( color.blue / 256 ))[2:]
        return "#%s%s%s"%(r.zfill(2),g.zfill(2),b.zfill(2))

gobject.type_register(Options)

########NEW FILE########
__FILENAME__ = parserinterface
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.


class ClassParserInterface:
    """ An abstract interface for class parsers.
    
    A class parser monitors gedit documents and provides a gtk.TreeModel
    that contains the browser tree. Elements in the browser tree are reffered
    to as 'tags'.
    
    There is always only *one* active instance of each parser. They are created
    at startup (in __init__.py).
    
    The best way to implement a new parser is probably to store custom python
    objects in a gtk.treestore or gtk.liststore, and to provide a cellrenderer
    to render them.
    """
    
    #------------------------------------- methods that *have* to be implemented
    
    def parse(self, geditdoc): 
        """ Parse a gedit.Document and return a gtk.TreeModel. 
        
        geditdoc -- a gedit.Document
        """
        pass        
        
        
    def cellrenderer(self, treeviewcolumn, cellrenderertext, treemodel, it):
        """ A cell renderer callback function that controls what the text label
        in the browser tree looks like.
        See gtk.TreeViewColumn.set_cell_data_func for more information. """
        pass
        
    #------------------------------------------- methods that can be implemented
   
    def pixbufrenderer(self, treeviewcolumn, cellrendererpixbuf, treemodel, it):
        """ A cell renderer callback function that controls what the pixmap next
        to the label in the browser tree looks like.
        See gtk.TreeViewColumn.set_cell_data_func for more information. """
        cellrendererpixbuf.set_property("pixbuf",None)
        
        
    def get_tag_position(self, model, doc, path):
        """ Return the position of a tag in a file. This is used by the browser
        to jump to a symbol's position.
        
        Returns a tuple with the full file uri of the source file and the line
        number of the tag or None if the tag has no correspondance in a file.
        
        model -- a gtk.TreeModel (previously provided by parse())
        path -- a tuple containing the treepath
        """
        pass
    
        
    def get_menu(self, model, path):
        """ Return a list of gtk.Menu items for the specified tag. 
        Defaults to an empty list
        
        model -- a gtk.TreeModel (previously provided by parse())
        path -- a tuple containing the treepath
        """
        return []

    
    def current_line_changed(self, model, doc, line):
        """ Called when the cursor points to a different line in the document.
        Can be used to monitor changes in the document.
        
        model -- a gtk.TreeModel (previously provided by parse())
        doc -- a gedit document
        line -- int
        """
        pass
  
        
    def get_tag_at_line(self, model, doc, linenumber):
        """ Return a treepath to the tag at the given line number, or None if a
        tag can't be found.
        
        model -- a gtk.TreeModel (previously provided by parse())
        doc -- a gedit document
        linenumber -- int
        """
        pass
        

########NEW FILE########
__FILENAME__ = parser_cstyle
# Copyright (C) 2007 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

"""

TODO

[1]-----------------------------------------------------------------------------

    The getTokenBackwards method is crap: It will stop as soon as it finds
    certain caracters (";"), but those may be enclosed in "", in ''
    or in comments, and therefore be legitimate.

    It would be better to keep a string in __get_brackets...

[2]-----------------------------------------------------------------------------

    __get_brackets() should skip everything enclosed in "" or ''.

[3]-----------------------------------------------------------------------------

    __get_brackets() should skip comments: c and c++ style
    
[4]-----------------------------------------------------------------------------

    what about php beginnings and endings? Should skip non-php parts
    

"""

import gtk
import pango
import options
import gobject
from parserinterface import ClassParserInterface
import imagelibrary

#---------------------------------------------------------------------------
class Token:

    def __init__(self,t):
        self.type = t
        self.name = None
        self.params = None
        self.visibility = None

        self.uri = None
        self.start = None
        self.end = None

        self.parent = None
        self.children = [] # a list of nested tokens

    def append(self, child):
        child.parent = self
        self.children.append(child)
        
    def __str__(self):
        return str(self.type) +" " +str(self.name)


#---------------------------------------------------------------------------
class _DummyToken:

    def __init__(self):
        self.parent = None
        self.children = [] # a list of nested tokens
        
    def append(self, child):
        child.parent = self
        self.children.append(child)
        
        
#---------------------------------------------------------------------------    
class CStyleCodeParser( ClassParserInterface ):
    """ This clases provides the basic functionality for the new PHP parser """

    def __init__(self):
        pass
   
   
    def getTokenFromChunk(self, chunk):
        """ Subclasses should implement this """
        pass
        
        
    def getTokenBackwards(self, string, position ):
        """ Iterate a string backwards from a given position to get token
            Example: calling ("one two three",8,2) would return ["two",one"] """ 
        
        # first step: get chunk where definition must be located
        # get substring up to a key character
        i = position
        while i > 0:
            i-=1
            if string[i] in ";}{/": # "/" is for comment endings
                break;
        
        # remove dirt
        chunk = string[i:position+1].strip()
        chunk = chunk.replace("\n"," ");
        chunk = chunk.replace("\r"," ");
        chunk = chunk.replace("\t"," ");
        
        return self.getTokenFromChunk(chunk)
        
        
    def parse(self, doc):
        text = doc.get_text(*doc.get_bounds())
        root = self.__get_brackets(text,doc.get_uri())
        self.__browsermodel = gtk.TreeStore(gobject.TYPE_PYOBJECT)
        for child in root.children: self.__appendTokenToBrowser(child,None)
        return self.__browsermodel
        
        
    def get_tag_position(self, model, path):
        tok = model.get_value( model.get_iter(path), 0 )
        try: return tok.uri, tok.start+1
        except: pass


    def cellrenderer(self, column, ctr, model, it):
        """ Render the browser cell according to the token it represents. """
        tok = model.get_value(it,0)
        name = tok.name
        colour = options.singleton().colours[ "function" ]
        if tok.type == "class":
            name = "class "+tok.name
            colour = options.singleton().colours[ "class" ]
        ctr.set_property("text", name)
        ctr.set_property("foreground-gdk", colour)


    def pixbufrenderer(self, column, crp, model, it):
        tok = model.get_value(it,0)
        if tok.type == "class":
            icon = "class"
        else:
            if tok.visibility == "private": icon = "method_priv"
            elif tok.visibility == "protected": icon = "method_prot"
            else: icon = "method"
        crp.set_property("pixbuf",imagelibrary.pixbufs[icon])


    def __appendTokenToBrowser(self, token, parentit ):
        if token.__class__ == _DummyToken: return
        it = self.__browsermodel.append(parentit,(token,))
        token.path = self.__browsermodel.get_path(it)
        for child in token.children:
            self.__appendTokenToBrowser(child, it)

    def __get_brackets(self,string,uri):
        verbose = False
        root = Token("root")
        parent = root
        ident = 0
        
        if verbose: print "-"*80
        
        line = 0 # count lines
        for i in range(len(string)-1):
        
            c = string[i]
            
            if c == "{": #------------------------------------------------------
            
                # get a token from the chunk of code preceding the bracket
                token = self.getTokenBackwards( string, i )
                
                if token:
                    # assign line number and uri to the token
                    token.uri = uri
                    token.start = line
                else:
                    # dummy token for empty brackets. Will not get added to tree.
                    token = _DummyToken()
                    
                # append the token to the tree
                parent.append(token)
                parent = token

                if verbose: print ident*"  "+"{",token
                ident += 1
                
                
            elif c == "}": #----------------------------------------------------
                ident -= 1
                if parent != root:
                    parent.end = line
                    parent = parent.parent
                    
                if verbose: print ident*"  "+"}",parent
                
            elif c == "\n":
                line += 1
                
        return root



########NEW FILE########
__FILENAME__ = parser_ctags
# Copyright (C) 200-2008 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import tempfile
import os
from subprocess import *
import gnomevfs

from parserinterface import *
import imagelibrary
import options
import re



class CTagsParser( ClassParserInterface ):
    """ A class parser that uses ctags.
    
    Note that this is a very rough and hackish implementation.
    Feel free to improve it.
    
    See http://ctags.sourceforge.net for more information about exuberant ctags,
    and http://ctags.sourceforge.net/FORMAT for a description of the file format.
    """
    
    def __init__(self):
        self.model = None
        self.document = None
        self.parse_all_files = False
        self.debug = False


    def parse(self, doc):
        """ Create a gtk.TreeModel with the tags of the document.
         
        The TreeModel contains:
           token name, source file path, line in the source file, type code

        If the second str contains an empty string, it means that
        the element has no 'physical' position in a file (see get_tag_position)   """

        self.model = gtk.TreeStore(str,str,int,str) # see __parse_to_model
        self.model.set_sort_column_id(2,gtk.SORT_ASCENDING)
        self.document = doc
        
        if os.system("ctags --version >/dev/null") != 0:
            self.model.append( None, ["Please install ctags!","",0,""] )
            return self.model
        else:
            self._parse_doc_to_model()
            return self.model
        
        
    def _generate_tagfile_from_document(self, doc, options = "-n"):
        
        try:
            # make sure this is a local file (ie. not via ftp or something)
            if doc.get_uri()[:4] != "file": return None
        except: return None
    
        docpath = doc.get_uri_for_display()
	if not os.path.isfile(docpath):
	    # don't parse the file if it doesn't exist
	    return None
        path, filename = os.path.split(docpath)
        if not self.parse_all_files:
            if filename.find(".") != -1:
                arg = self.shell_escape(path + os.sep + filename[:filename.rfind(".")]) + ".*"
            else:
                arg = self.shell_escape(docpath)
        else:
            arg = self.shell_escape(path) + os.sep + "*.*"       
            
        if filename.find(".vala") != -1:
             return self._generate_tagfile(docpath, "-n --language-force=C#")                
        else:         
             return self._generate_tagfile(arg,options)
    
    
    def _generate_tagfile(self, filestr, options = "-n"):
        """ filestr is a string, could be *.* or explicit paths """

        # create tempfile
        h, tmpfile = tempfile.mkstemp()
        os.close(h)
        
        # launch ctags
        command = "ctags %s -f \"%s\" %s"%(options,tmpfile,filestr)
        os.system(command)
        
        return tmpfile

        
    def _parse_doc_to_model(self):
        """ Parse the given document and write the tags to a gtk.TreeModel.
        
        The parser uses the ctags command from the shell to create a ctags file,
        then parses the file, and finally populates a treemodel. """
        # refactoring noise    
        doc = self.document
        ls = self.model        
        ls.clear()
        tmpfile = self._generate_tagfile_from_document(doc)
        if tmpfile is None: return ls
        
        # A list of lists. Matches the order found in tag files.
        # identifier, path to file, line number, type, and then more magical things
        tokenlist = [] 
        h = open(tmpfile)
        for r in h.readlines():
            tokens = r.strip().split("\t")
            if tokens[0][:2] == "!_": continue

            # convert line numbers to an int
            tokens[2] =  int(filter( lambda x: x in '1234567890', tokens[2] ))
            
            # prepend container elements, append member elements. Do this to
            # make sure that container elements are created first.
            if self._is_container(tokens): tokenlist = [tokens] + tokenlist
            else: tokenlist.append(tokens)
        h.close()

        # add tokens to the treestore---------------------------------------
        containers = { None: None } # keep dict: token's name -> treeiter
        
        # iterate through the list of tags, 
        # Note: Originally sorted by line number, bit it did break some
        # formatting in c
        for tokens in tokenlist:
        
            # skip enums
            #if self.__get_type(tokens) in 'de': continue
        
            # append current token to parent iter, or to trunk when there is none
            parent = self._get_parent(tokens)
            
            if parent in containers: node = containers[parent]
            else:
                # create a dummy element in case the parent doesn't exist
                node = ls.append( None, [parent,"",0,""] )
                containers[parent] = node
            
            # escape blanks in file path
            tokens[1] = str( gnomevfs.get_uri_from_local_path(tokens[1]) )
            
            # make sure tokens[4] contains type code
            if len(tokens) == 3: tokens.append("")
            else: tokens[3] = self.__get_type(tokens)
            
            # append to treestore
            it = ls.append( node, tokens[:4] )
            
            # if this element was a container, remember its treeiter
            if self._is_container(tokens):
                containername = self._get_container_name(tokens)
                containers[ containername ] = it
            
        # remove temp file
        os.remove(tmpfile)
        
        
    def shell_escape(self, filename):
        return re.sub(r"([ \"'\\\$])", '\\\\\\1', filename)
    
    
    def get_tag_position(self, model, path):
        filepath = model.get_value( model.get_iter(path), 1 )
        linenumber = model.get_value( model.get_iter(path), 2 )
        if filepath == "": return None
        return filepath, linenumber


    def get_tag_at_line(self, model, doc, linenumber):
        """ Return a treepath to the tag at the given line number, or None if a
        tag can't be found.
        """

        if doc is None: return
        
        self.minline = -1
        self.tagpath = None
            
        def loopfunc(model, path, it):
            if model.get_value(it,1) != doc.get_uri(): return
            l = model.get_value(it,2)
            if l >= self.minline and l <= linenumber+1:
                self.tagpath = path
                self.minline = l
        
        # recursively loop through the treestore
        model.foreach(loopfunc)
        
        if self.tagpath is None:
            it = model.get_iter_root()
            return model.get_path(it)
        
        return self.tagpath
        
        
    def get_menu(self, model, path):
        m1 = gtk.CheckMenuItem("Parse _All Files")
        m1.set_active(self.parse_all_files)
        m1.connect("toggled", lambda w: self.__set_parse_all_files_option(w.get_active()) )
        m2 = gtk.ImageMenuItem(gtk.STOCK_REFRESH)
        m2.connect("activate", lambda w: self._parse_doc_to_model() )
        return [m1,m2]
        
        
    def __set_parse_all_files_option(self, onoff):
        self.parse_all_files = onoff
        self.__parse_doc_to_model()
        
        
    def __get_type(self, tokrow):
        """ Returns a char representing the token type or False if none were found.

        According to the ctags docs, possible types are:
            c    class name
            d    define (from #define XXX)
            e    enumerator
            f    function or method name
            F    file name
            g    enumeration name
            m    member (of structure or class data)
            p    function prototype
            s    structure name
            t    typedef
            u    union name
            v    variable        
        """
        if len(tokrow) == 3: return
        for i in tokrow[3:]:
            if len(i) == 1: return i # most common case: just one char
            elif i[:4] == "kind": return i[5:]
        return ' '  
        
        
        
    #----------------------------------------------- related to container tags
        
    def _get_container_name(self, tokrow):
        """ Usually, we can assume that the parent's name is the same
            as the name of the token. In some cases (typedefs), this
            doesn't work (see Issue 13) """
        
        if self.__get_type(tokrow) == "t":
            try:
                t = tokrow[4]
                a = t.split(":")
                return a[ len(a)-1 ]
            except:
                pass
        return tokrow[0]
    
        
    def _is_container(self, tokrow):
        """ class, enumerations, structs and unions are considerer containers.
            See Issue 13 for some issues we had with this.
        """
        if self.__get_type(tokrow) in 'cgsut': return True
        return False
        
        
    def _get_parent(self, tokrow):
        if len(tokrow) == 3: return
        # Iterate through all items in the tag.
        # TODO: Not sure if needed
        for i in tokrow[3:]: 
            a = i.split(":")
            if a[0] in ("class","struct","union","enum"): 
                return a[1]
        return None
        
        
    #----------------------------------------------- cell renderers

    def cellrenderer(self, column, ctr, model, it):
        i = model.get_value(it,0)
        ctr.set_property("text", i)
        elements = {
            "c":"class",
            "f":"function",
            "m":"member",
            "e":"enumerator",
            "d":"define",
        }
        i = model.get_value(it,3)
        try: colour = options.singleton().colours[ elements[i] ]
        except: colour = gtk.gdk.Color(0,0,0)
        ctr.set_property("foreground-gdk", colour)
        
        
    def pixbufrenderer(self, column, crp, model, it):
        elements = {
            "c":"class", #class name
            "d":"default", #define (from #define XXX)
            "e":"enum", #enumerator
            "f":"method", #function or method name
            "F":"default", #file name
            "g":"enum", #enumeration name
            "m":"default", #(of structure or class data)
            "p":"default", #function prototype
            "s":"struct", #structure name
            "t":"default", #typedef
            "u":"struct", #union name
            "v":"variable", #variable
            "n":"namespace", #namespace
        }
        try:
            i = model.get_value(it,3)
            icon = elements[i]
        except:
            icon = "default"
        crp.set_property("pixbuf",imagelibrary.pixbufs[icon])
        

########NEW FILE########
__FILENAME__ = parser_diff
# -*- coding: utf-8 -*-
# Copyright (C) 2007 Kristoffer Lundn (kristoffer.lunden@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import gobject
import pango
import os
import options
import imagelibrary
from parserinterface import ClassParserInterface

class Token:
  def __init__(self):
    self.start = 0
    self.end = 0
    self.name = None
    self.parent = None
    self.children = []
    self.type = 'changeset'

class DiffParser(ClassParserInterface):

  def parse(self, geditdoc):
    text = geditdoc.get_text(*geditdoc.get_bounds())
    linecount = -1
    current_file = None
    changeset = None
    files = []
    uri = geditdoc.get_uri()
    
    for line in text.splitlines():
      linecount += 1
      lstrip = line.lstrip()
      ln = lstrip.split()
      if len(ln) == 0: continue

      if ln[0] == '---':
        if current_file is not None:
          current_file.end = linecount - 1
        current_file = Token()
        current_file.name = ln[1]
        current_file.start = linecount
        current_file.type = 'file'
        current_file.uri = uri
        files.append(current_file)

      elif current_file == None: continue

      elif ln[0] == '@@' and ln[-1] == '@@':
        if changeset is not None:
          changeset.end = linecount
        changeset = Token()
        changeset.name = ' '.join(ln[1:-1])
        changeset.start = linecount
        changeset.uri = uri
        current_file.children.append(changeset)
        changeset.parent = current_file
                  
      # Ending line of last tokens
      if len(files) > 0:
        f =  files[-1]
        f.end = linecount + 2
        if len(f.children) > 0:
          f.children[-1].end = linecount + 2

    model = gtk.TreeStore(gobject.TYPE_PYOBJECT)
    
    pp = None

    # "Fake" common top folder, if any
    # TODO: Create hierarchy if patch applies in multiple directories
    if len(files) > 0:
      paths = map(lambda f:f.name, files)
      prefix = os.path.dirname(os.path.commonprefix(paths)) + '/'
      if len(prefix) > 1:
        parent_path = Token()
        parent_path.type = 'path'
        parent_path.name = prefix
        for f in files: f.name = f.name.replace(prefix,'',1)
        pp = model.append(None,(parent_path,))

    # Build tree
    for f in files:
      tree_iter = model.append(pp,(f,))
      for c in f.children:
         model.append(tree_iter,(c,))
    
    return model

  def cellrenderer(self, treeviewcolumn, cellrenderertext, treemodel, it):  
    token = treemodel.get_value(it,0)

    colour = options.singleton().colours["member"]

    if token.type == 'path':
      colour = options.singleton().colours["namespace"]
    elif token.type == 'file':
      colour = options.singleton().colours["class"]

    cellrenderertext.set_property("text", token.name)
    cellrenderertext.set_property("style", pango.STYLE_NORMAL)
    cellrenderertext.set_property("foreground-gdk", colour)

  def get_tag_position(self, model, path):
    tok = model.get_value(model.get_iter(path),0)
    try: return tok.uri, tok.start + 1
    except: return None

  def get_tag_at_line(self, model, doc, linenumber):

    def find_path(model, path, iter, data):
      line = data[0]
      token = model.get_value(iter, 0)
      if token.start <= line and token.end > line:
        print path
        data[1].append(path)
        #return True
      return False

    path_found = []
    model.foreach(find_path, (linenumber, path_found))

    if len(path_found) > 0:
      return path_found[-1]
    return None

  def pixbufrenderer(self, treeviewcolumn, cellrendererpixbuf, treemodel, it):
    token = treemodel.get_value(it,0)
    if token.type == 'path':
      cellrendererpixbuf.set_property("stock-id", gtk.STOCK_DIRECTORY)
    elif token.type == 'file':
      cellrendererpixbuf.set_property("stock-id", gtk.STOCK_FILE)
    else:
      cellrendererpixbuf.set_property("pixbuf",imagelibrary.pixbufs['patch'])

# -*- coding: utf-8 -*-
# Copyright (C) 2007 Kristoffer Lundn (kristoffer.lunden@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import gobject
import pango
import os
import options
import imagelibrary
from parserinterface import ClassParserInterface

class Token:
  def __init__(self):
    self.start = 0
    self.end = 0
    self.name = None
    self.parent = None
    self.children = []
    self.type = 'changeset'

class DiffParser(ClassParserInterface):

  def parse(self, geditdoc):
    text = geditdoc.get_text(*geditdoc.get_bounds())
    linecount = -1
    current_file = None
    changeset = None
    files = []
    uri = geditdoc.get_uri()
    
    for line in text.splitlines():
      linecount += 1
      lstrip = line.lstrip()
      ln = lstrip.split()
      if len(ln) == 0: continue

      if ln[0] == '---':
        if current_file is not None:
          current_file.end = linecount - 1
        current_file = Token()
        current_file.name = ln[1]
        current_file.start = linecount
        current_file.type = 'file'
        current_file.uri = uri
        files.append(current_file)

      elif current_file == None: continue

      elif ln[0] == '@@' and ln[-1] == '@@':
        if changeset is not None:
          changeset.end = linecount
        changeset = Token()
        changeset.name = ' '.join(ln[1:-1])
        changeset.start = linecount
        changeset.uri = uri
        current_file.children.append(changeset)
        changeset.parent = current_file
                  
      # Ending line of last tokens
      if len(files) > 0:
        f =  files[-1]
        f.end = linecount + 2
        if len(f.children) > 0:
          f.children[-1].end = linecount + 2

    model = gtk.TreeStore(gobject.TYPE_PYOBJECT)
    
    pp = None

    # "Fake" common top folder, if any
    # TODO: Create hierarchy if patch applies in multiple directories
    if len(files) > 0:
      paths = map(lambda f:f.name, files)
      prefix = os.path.dirname(os.path.commonprefix(paths)) + '/'
      if len(prefix) > 1:
        parent_path = Token()
        parent_path.type = 'path'
        parent_path.name = prefix
        for f in files: f.name = f.name.replace(prefix,'',1)
        pp = model.append(None,(parent_path,))

    # Build tree
    for f in files:
      tree_iter = model.append(pp,(f,))
      for c in f.children:
         model.append(tree_iter,(c,))
    
    return model

  def cellrenderer(self, treeviewcolumn, cellrenderertext, treemodel, it):  
    token = treemodel.get_value(it,0)

    colour = options.singleton().colours["member"]

    if token.type == 'path':
      colour = options.singleton().colours["namespace"]
    elif token.type == 'file':
      colour = options.singleton().colours["class"]

    cellrenderertext.set_property("text", token.name)
    cellrenderertext.set_property("style", pango.STYLE_NORMAL)
    cellrenderertext.set_property("foreground-gdk", colour)

  def get_tag_position(self, model, path):
    tok = model.get_value(model.get_iter(path),0)
    try: return tok.uri, tok.start + 1
    except: return None

  def get_tag_at_line(self, model, doc, linenumber):

    def find_path(model, path, iter, data):
      line = data[0]
      token = model.get_value(iter, 0)
      if token.start <= line and token.end > line:
        print path
        data[1].append(path)
        #return True
      return False

    path_found = []
    model.foreach(find_path, (linenumber, path_found))

    if len(path_found) > 0:
      return path_found[-1]
    return None

  def pixbufrenderer(self, treeviewcolumn, cellrendererpixbuf, treemodel, it):
    token = treemodel.get_value(it,0)
    if token.type == 'path':
      cellrendererpixbuf.set_property("stock-id", gtk.STOCK_DIRECTORY)
    elif token.type == 'file':
      cellrendererpixbuf.set_property("stock-id", gtk.STOCK_FILE)
    else:
      cellrendererpixbuf.set_property("pixbuf",imagelibrary.pixbufs['patch'])


########NEW FILE########
__FILENAME__ = parser_etags
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.


from parser_ctags import *
import re



class ETagsParser( CTagsParser ):
    """ A class parser that uses ctags in etags mode.
    
    See http://ctags.sourceforge.net for more information about exuberant ctags,
    and http://ctags.sourceforge.net/FORMAT for a description of the file format.
    """
    
    def __init__(self):
        CTagsParser.__init__(self)



    def _get_type(self, string):
        """ Returns a char representing the token type or False if none were found.
        
        According to the ctags docs, possible types are:
		c	class name
		d	define (from #define XXX)
		e	enumerator
		f	function or method name
		F	file name
		g	enumeration name
		m	member (of structure or class data)
		p	function prototype
		s	structure name
		t	typedef
		u	union name
		v	variable        
        """

        return "v"


    def _parse_doc_to_model(self):
        
        # refactoring noise    
        doc = self.document
        ls = self.model        
        ls.clear()
        
        #tmpfile = self._generate_tagfile("/var/planissimo.de/include/class.*","-n -e")
        tmpfile = self._generate_tagfile_from_document(doc,"-e")
        h = open(tmpfile)
        
        
        #h = open("/var/planissimo.de/include/tags_e")
        
        next_line_contains_filename = False
        filename = None
        parent_indentations = { 0: None }
        last_indent = 0
        for r in h.readlines():
        
            if next_line_contains_filename:
                filename,size = r.split(",")
                next_line_contains_filename = False
                continue
        
            if r[0] == u'\u000c':
                next_line_contains_filename = True
                continue
            
            indent = len(r) - len(r.lstrip())

            # Row contains: extracted source[007F]name of the tag[0001]linenumber,char_offset
            a = r[0:r.find(u'\u007f')].strip()
            b = r[r.find(u'\u007f')+1:r.find(u'\u0001')]
            c = r[r.find(u'\u0001')+1:-1]
            
            linenumber,char_offset = c.split(",")
            
            # Tokens of the ctags parser are constructed as follows:
            # name, file uri, line number, type code (as used in ctags, see _get_type)
            if filename != None and not filename.startswith("file://"):
                try: filename = str(gnomevfs.get_uri_from_local_path(filename))
                except: pass
            token = [b,str(filename),int(linenumber),self._get_type(a)]
            
            parent = None # Indentation is arbitrary
            i = indent-1
            while i > 0:
                try: parent = parent_indentations[i-1]
                except: pass
                if parent: i=0
                i -= 1
            
            #print parent_indentations
            #print indent,parent,token[0]
            #print
            
            newnode = ls.append( parent, token )
            parent_indentations[indent] = newnode
            
            last_indent = indent

        
        h.close()
        os.remove(tmpfile)
        
        
class ETagsParserPHP( ETagsParser ):
    """ This parser is able to recognise php symbols like class, static, etc """
    
    def _get_type(self, string):
        """ Returns a char representing the token type or False if none were found.
        
        According to the ctags docs, possible types are:
		c	class name
		d	define (from #define XXX)
		e	enumerator
		f	function or method name
		F	file name
		g	enumeration name
		m	member (of structure or class data)
		p	function prototype
		s	structure name
		t	typedef
		u	union name
		v	variable        
        """

        # squeeze
        s = re.sub(' +', ' ', string)
        
        
        if s.find("class") >= 0: return "c"
        if s.find("public function") >= 0: return "m"
        if re.search("private(.*)function",s): return "m_priv"
        if re.search("protected(.*)function",s): return "m_prot"
        if re.search("var(.*)\$",s): return "v_pubvar"
        if re.search("private(.*)\$",s): return "v_privvar"
        if re.search("protected(.*)\$",s): return "v_protvar"
        
        if s.find("function") >= 0: return "f"
        return "v"
        
        
    def cellrenderer(self, column, ctr, model, it):
        i = model.get_value(it,0)
        ctr.set_property("text", i)
        
        elements = {
            "c":"class",
            "f":"function",
            "m":"member",
            "e":"enumerator",
            "d":"define",
        }

        i = model.get_value(it,3)
        try: colour = options.singleton().colours[ elements[i[0]] ]
        except: colour = gtk.gdk.Color(0,0,0)
        ctr.set_property("foreground-gdk", colour)
        
        
    def pixbufrenderer(self, column, crp, model, it):
        
        elements = {
            "c":"class", #class name
            "d":"define", #define (from #define XXX)
            "e":"enum", #enumerator
            "f":"method", #function or method name
            "F":"default", #file name
            "g":"enum", #enumeration name
            "m":"default", #(of structure or class data)
        	"p":"default", #function prototype
		    "s":"struct", #structure name
		    "t":"default", #typedef
		    "u":"struct", #union name
		    "v":"variable", #variable,
		    
		    "v_privvar":"field_priv",
		    "v_protvar":"field_prot",
		    "v_pubvar":"field",
		    "m_prot":"method_prot",
		    "m_priv":"method_priv",
        }

        try:
            i = model.get_value(it,3)
            icon = elements[i]
        except:
            icon = "default"

        crp.set_property("pixbuf",imagelibrary.pixbufs[icon])   
        

########NEW FILE########
__FILENAME__ = parser_html
from parserinterface import ClassParserInterface
from HTMLParser import HTMLParser, HTMLParseError
import gtk
import options

#=================================================================================================

class customParser(HTMLParser):

    def __init__(self):
        HTMLParser.__init__(self)
        # id, description, line, offset, [pixbuf]
        self.ls = gtk.TreeStore( str, str, int, int )
        self.currenttag = None
        
    def handle_starttag(self, tag, attrs):
        
        # construct tagstring 
        tagstring = "<"+tag
        for name, value in attrs:
            if name in ["id","name"]: # append only certain attributes 
                tagstring += " %s=%s"%(name,value)
        tagstring += ">"
        #print tagstring
        
        lineno, offset = self.getpos()
        it = self.ls.append( self.currenttag,(tag,tagstring,lineno,0) )
        if options.singleton().verbose:
            print (tag,tagstring,lineno,0)
        self.currenttag = it
        
                  
    def handle_endtag(self, tag):
        
        if self.currenttag:
            t = self.ls.get_value(self.currenttag,0)
            if tag == t:
                #print "</%s>"%tag
                self.currenttag = self.ls.iter_parent(self.currenttag)

#=================================================================================================

class geditHTMLParser( ClassParserInterface ):


    def parse(self, d): 
        parser = customParser()
        try:
            parser.feed(d.get_text(*d.get_bounds()))
        except HTMLParseError, e:
            if options.singleton().verbose:
                print e, e.lineno, e.offset
            
        return parser.ls  
        
    def cellrenderer(self, treeviewcolumn, ctr, treemodel, it):
        name = treemodel.get_value(it,1)
        ctr.set_property("text", name)
        
    #------------------------------------------- methods that can be implemented
   
    def pixbufrenderer(self, treeviewcolumn, cellrendererpixbuf, treemodel, it):
        """ A cell renderer callback function that controls what the pixmap next
        to the label in the browser tree looks like.
        See gtk.TreeViewColumn.set_cell_data_func for more information. """
        cellrendererpixbuf.set_property("pixbuf",None)
        
        
    def get_tag_position(self, model, path):
        """ Return the position of a tag in a file. This is used by the browser
        to jump to a symbol's position.
        
        Returns a tuple with the full file uri of the source file and the line
        number of the tag or None if the tag has no correspondance in a file.
        
        model -- a gtk.TreeModel (previously provided by parse())
        path -- a tuple containing the treepath
        """
        
        return
    
        
    def get_menu(self, model, path):
        """ Return a list of gtk.Menu items for the specified tag. 
        Defaults to an empty list
        
        model -- a gtk.TreeModel (previously provided by parse())
        path -- a tuple containing the treepath
        """
        return []

    
    def current_line_changed(self, model, doc, line):
        """ Called when the cursor points to a different line in the document.
        Can be used to monitor changes in the document.
        
        model -- a gtk.TreeModel (previously provided by parse())
        doc -- a gedit document
        line -- int
        """
        pass
  
        
    def get_tag_at_line(self, model, doc, linenumber):
        """ Return a treepath to the tag at the given line number, or None if a
        tag can't be found.
        
        model -- a gtk.TreeModel (previously provided by parse())
        doc -- a gedit document
        linenumber -- int
        """
        
        #print "="*80
        
        self.lastit = None
        def iterate(model, path, it):
            #print model.get_value(it,2)
            line = model.get_value(it,2)
            if line > linenumber: return True # exit, lastpath contains tag
            self.lastit = it
        
        model.foreach(iterate)
        #print self.lastit, "-----"*20
        return model.get_path(self.lastit)
        
        
        

########NEW FILE########
__FILENAME__ = parser_php
# Copyright (C) 2007 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import gobject
from parser_cstyle import Token, CStyleCodeParser
import re


e = r".*?" # anything, but *not greedy*
e+= "(?:(private|protected) +)?" # visibility
e+= "function +(\w+)(\(.*\))" # function declaration
e+= " *\{$" # the tail
RE_FUNCTION = re.compile(e)
RE_CLASS = re.compile(r".*class +(\w+)(?: +extends +(\w+))? *\{$")
        
        
class PHPParser( CStyleCodeParser ):

    def __init__(self):
        pass


    def getTokenFromChunk(self, chunk):
        if chunk.find("function")>-1 or chunk.find("class")>-1:
            
            # third step: perform regular expression to get a token
            match = re.match(RE_FUNCTION,chunk)
            if match:
                t = Token("function")
                t.visibility, t.name, t.params = match.groups()
                #print match.groups()
                return t
                
            else:
                match = re.match(RE_CLASS,chunk)
                if match:
                    t = Token("class")
                    t.name, t.params = match.groups()
                    return t

                else:
                
                    # last step: alert user if a chunk could not be parsed
                    #print "Could not resolve PHP function or class in the following string:"
                    #print chunk
                    
                    pass

        return None
        



########NEW FILE########
__FILENAME__ = parser_python
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import gobject
import pango
import os
import re
import options
from parserinterface import ClassParserInterface
import imagelibrary

#===============================================================================

def functionTokenFromString(string):
    """ Parse a string containing a function or class definition and return
        a tuple containing information about the function, or None if the
        parsing failed.

        Example: 
            "#def foo(bar):" would return :
            {'comment':True,'type':"def",'name':"foo",'params':"bar" } """

    try:
        e = r"([# ]*?)([a-zA-Z0-9_]+)( +)([a-zA-Z0-9_]+)(.*)"
        r = re.match(e,string).groups()
        token = Token()
        token.comment = '#' in r[0]
        token.type = r[1]
        token.name = r[3]
        token.params = r[4]
        token.original = string
        return token
    except: return None # return None to skip if unable to parse


#===============================================================================

class Token:
    """ Rules: 
            type "attribute" may only be nested to "class"
    """

    def __init__(self):
        self.type = None # "attribute", "class" or "function"
        self.original = None # the line in the file, unparsed

        self.indent = 0
        self.name = None
        self.comment = False # if true, the token is commented, ie. inactive
        self.params = None   # string containing additional info
        self.expanded = False

        # start and end points (line number)
        self.start = 0
        self.end = 0

        self.pythonfile = None
        self.path = None # save the position in the browser

        self.parent = None
        self.children = [] # a list of nested tokens
        self.attributes = [] # a list of class attributes
        

    def get_endline(self):
        """ Get the line number where this token's declaration, including all
            its children, finishes. Use it for copy operations."""
        if len(self.children) > 0:
            return self.children[-1].get_endline()
        return self.end

        def test_nested():
            pass
            
    def get_toplevel_class(self):
        """ Try to get the class a token is in. """
            
        if self.type == "class":
            return self    

        if self.parent is not None:
            tc = self.parent.get_toplevel_class()
            if tc is None or tc.type == "file": return self #hack
            else: return tc
                
        return None

    def printout(self):
        for r in range(self.indent): print "",
        print self.name,
        if self.parent: print " (parent: ",self.parent.name       
        else: print
        for tok in self.children: tok.printout()

#===============================================================================

class PythonFile(Token):
    """ A class that represents a python file.
        Manages "tokens", ie. classes and functions."""

    def __init__(self, doc):
        Token.__init__(self)
        self.doc = doc
        self.uri = doc.get_uri()
        self.linestotal = 0 # total line count
        self.type = "file"
        if self.uri:
            self.name = os.path.basename(self.uri)
        self.tokens = []

    def getTokenAtLine(self, line):
        """ get the token at the specified line number """
        for token in self.tokens:
            if token.start <= line and token.end > line:
                return token
        return None          

    def parse(self, verbose=True):

        #if verbose: print "parse ----------------------------------------------"
        newtokenlist = []

        indent = 0
        lastElement = None

        self.children = []

        lastToken = None
        indentDictionary = { 0: self, } # indentation level: token

        self.linestotal = self.doc.get_line_count()

        text = self.doc.get_text(*self.doc.get_bounds())
        linecount = -1
        for line in text.splitlines():
            linecount += 1
            lstrip = line.lstrip()
            ln = lstrip.split()
            if len(ln) == 0: continue

            if ln[0] in ("class","def","#class","#def"):

                token = functionTokenFromString(lstrip)
                if token is None: continue
                token.indent = len(line)-len(lstrip) 
                token.pythonfile = self
                
                token.original = line

                # set start and end line of a token. The end line will get set
                # when the next token is parsed.
                token.start = linecount
                if lastToken: lastToken.end = linecount
                newtokenlist.append(token)

                #if verbose: print "appending",token.name,
                if token.indent == indent:
                    # as deep as the last row: append the last e's parent
                    #if verbose: print "(%i == %i)"%(token.indent,indent),
                    if lastToken: p = lastToken.parent
                    else: p = self
                    p.children.append(token)
                    token.parent = p
                    indentDictionary[ token.indent ] = token

                elif token.indent > indent:
                    # this row is deeper than the last, use last e as parent
                    #if verbose: print "(%i > %i)"%(token.indent,indent),
                    if lastToken: p = lastToken
                    else: p = self
                    p.children.append(token)
                    token.parent = p
                    indentDictionary[ token.indent ] = token

                elif token.indent < indent:
                    # this row is shallower than the last
                    #if verbose: print "(%i < %i)"%(token.indent,indent),
                    if token.indent in indentDictionary.keys():
                        p = indentDictionary[ token.indent ].parent
                    else: p = self
                    if p == None: p = self # might happen with try blocks
                    p.children.append(token)
                    token.parent = p

                #if verbose: print "to",token.parent.name
                idx = len(newtokenlist) - 1
                if idx < len(self.tokens):
                    if newtokenlist[idx].original == self.tokens[idx].original:
                        newtokenlist[idx].expanded = self.tokens[idx].expanded
                lastToken = token
                indent = token.indent

            # not a class or function definition
            else: 
                
                # check for class attributes, append to last class in last token
                try:
                    # must match "self.* ="
                    if ln[0][:5] == "self." and ln[1] == "=":
                    
                        # make sure there is only one dot in the declaration
                        # -> attribute is direct descendant of the class
                        if lastToken and ln[0].count(".") == 1:
                            attr = ln[0].split(".")[1]
                            self.__appendClassAttribute(lastToken,attr,linecount)
                        
                except IndexError: pass

        # set the ending line of the last token
        if len(newtokenlist) > 0:
            newtokenlist[ len(newtokenlist)-1 ].end = linecount + 2 # don't ask

        # set new token list
        self.tokens = newtokenlist
        return True

    def __appendClassAttribute(self, token, attrName, linenumber):
        """ Append a class attribute to the class a given token belongs to. """
        
        # get next parent class
        while token.type != "class":
            token = token.parent
            if not token: return   
            
        # make sure attribute is not set yet
        for i in token.attributes:
            if i.name == attrName: return
                     
        # append a new attribute
        attr = Token()
        attr.type = "attribute"
        attr.name = attrName
        attr.start = linenumber
        attr.end = linenumber
        attr.pythonfile = self
        token.attributes.append(attr)
        
#===============================================================================

class PythonParser( ClassParserInterface ):
    """ A class parser that uses ctags.
    
    Note that this is a very rough and hackish implementation.
    Feel free to improve it.
    
    See http://ctags.sourceforge.net for more information about exuberant ctags,
    and http://ctags.sourceforge.net/FORMAT for a description of the file format.
    """
    
    def __init__(self, geditwindow):
        self.geditwindow = geditwindow
        self.pythonfile = None


    def appendTokenToBrowser(self, token, parentit ):
        it = self.__browsermodel.append(parentit,(token,))
        token.path = self.__browsermodel.get_path(it)
        
        # add special subtree for attributes
        if len(token.attributes) > 0:
        
            holder = Token()
            holder.name = "Attributes"
            holder.type = "attribute"
            it2 = self.__browsermodel.append(it,(holder,))
            
            for child in token.attributes   :
                self.__browsermodel.append(it2,(child,))
        
        #if token.parent:
        #    if token.parent.expanded:
        #        self.browser.expand_row(token.parent.path,False)
        #        pass
        
        for child in token.children:
            self.appendTokenToBrowser(child, it)


    def get_menu(self, model, path):
        """ The context menu is expanded if the python tools plugin and
            bicyclerepairman are available. """
    
        menuitems = []
    
        try: tok = model.get_value( model.get_iter(path), 0 )
        except: tok = None
        pt = self.geditwindow.get_data("PythonToolsPlugin")
        tagposition = self.get_tag_position(model,path)
        
        if pt and tok and tagposition:
        
            filename, line = tagposition # unpack the location of the token
            if tok.type in ["def","class"] and filename[:7] == "file://":
            
                print tok.original
            
                # trunkate to local filename
                filename = filename[7:]
                column = tok.original.find(tok.name) # find beginning of function definition
                print filename, line, column
                
                item = gtk.MenuItem("Find References")
                menuitems.append(item)
                item.connect("activate",lambda w: pt.brm.findReferencesDialog(filename,line,column))
            
        return menuitems


    def parse(self, doc):
        """ 
        Create a gtk.TreeModel with the class elements of the document
        
        The parser uses the ctags command from the shell to create a ctags file,
        then parses the file, and finally populates a treemodel.
        """
    
        self.pythonfile = PythonFile(doc)
        self.pythonfile.parse(options.singleton().verbose)
        self.__browsermodel = gtk.TreeStore(gobject.TYPE_PYOBJECT)
        for child in self.pythonfile.children:
            self.appendTokenToBrowser(child,None)
        return self.__browsermodel
        

    def get_tag_position(self, model, path):
        tok = model.get_value( model.get_iter(path), 0 )
        try: return tok.pythonfile.uri, tok.start+1
        except: return None


    def current_line_changed(self, model, doc, line):

        # parse again if line count changed
        if abs(self.pythonfile.linestotal - doc.get_line_count()) > 0:
            if abs(self.pythonfile.linestotal - doc.get_line_count()) > 5:
                if options.singleton().verbose:
                    print "PythonParser: refresh because line dif > 5"
                self.pythonfile.parse()
            else:
                it = doc.get_iter_at_line(line)
                a = it.copy(); b = it.copy()
                a.backward_line(); a.backward_line()
                b.forward_line(); b.forward_line()

                t = doc.get_text(a,b)
                if t.find("class") >= 0 or t.find("def") >= 0:
                    if options.singleton().verbose:
                        print "PythonParser: refresh because line cound changed near keyword"
                    self.pythonfile.parse()
 

    def get_tag_at_line(self, model, doc, linenumber):
        t = self.pythonfile.getTokenAtLine(linenumber)
        #print linenumber,t
        if t: return t.path


    def cellrenderer(self, column, ctr, model, it):

        """ Render the browser cell according to the token it represents. """
        tok = model.get_value(it,0)

        weight = 400
        style = pango.STYLE_NORMAL
        name = tok.name#+tok.params
        colour = options.singleton().colours[ "function" ]

        # set label and colour
        if tok.type == "class":
            name = "class "+name+tok.params
            colour = options.singleton().colours[ "class" ]
            weight = 600
        if tok.comment: name = "#"+name
        if tok.parent:
            if tok.parent.type == "class":
                colour = options.singleton().colours[ "member" ]

        # assing properties
        ctr.set_property("text", name)
        ctr.set_property("style", style)
        ctr.set_property("foreground-gdk", colour)


    def pixbufrenderer(self, column, crp, model, it):
        tok = model.get_value(it,0)

        icon = "method" # for normal defs

        if tok.type == "class":
            icon = "class"
        elif tok.type == "attribute":
            if tok.name[:2] == "__": icon = "field_priv"
            else: icon = "field"
        elif tok.parent:

            if tok.parent.type == "class":
                icon = "method"
                if tok.name[:2] == "__":
                    icon = "method_priv"


        crp.set_property("pixbuf",imagelibrary.pixbufs[icon])

        

########NEW FILE########
__FILENAME__ = parser_ruby
# -*- coding: utf-8 -*-
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
# Copyright (C) 2007 Kristoffer Lundn (kristoffer.lunden@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import gobject
import pango
import os
import re
import options
from parserinterface import ClassParserInterface
import imagelibrary

#===============================================================================

def tokenFromString(string):
    """ Parse a string containing a function or class definition and return
        a tuple containing information about the function, or None if the
        parsing failed.

        Example: 
            "#def foo(bar):" would return :
            {'comment':True,'type':"def",'name':"foo",'params':"bar" } """

    try:
        e = r"([# ]*?)([a-zA-Z0-9_]+)( +)([a-zA-Z0-9_\?\!<>\+=\.]+)(.*)"
        r = re.match(e,string).groups()
        token = Token()
        token.comment = '#' in r[0]
        token.type = r[1]
        token.name = r[3]
        token.params = r[4]
        token.original = string
        return token
    except: return None # return None to skip if unable to parse
    
    def test():
        pass

#===============================================================================

class Token:
    def __init__(self):
        self.type = None
        self.original = None # the line in the file, unparsed

        self.indent = 0
        self.name = None
        self.comment = False # if true, the token is commented, ie. inactive
        self.params = None   # string containing additional info
        self.expanded = False

        self.access = "public"

        # start and end points
        self.start = 0
        self.end = 0

        self.rubyfile = None
        self.path = None # save the position in the browser

        self.parent = None
        self.children = []

    def get_endline(self):
        """ Get the line number where this token's declaration, including all
            its children, finishes. Use it for copy operations."""
        if len(self.children) > 0:
            return self.children[-1].get_endline()
        return self.end

        def test_nested():
            pass
            
    def get_toplevel_class(self):
        """ Try to get the class a token is in. """
            
        if self.type == "class":
            return self    

        if self.parent is not None:
            tc = self.parent.get_toplevel_class()
            if tc is None or tc.type == "file": return self #hack
            else: return tc
                
        return None

    def printout(self):
        for r in range(self.indent): print "",
        print self.name,
        if self.parent: print " (parent: ",self.parent.name       
        else: print
        for tok in self.children: tok.printout()

#===============================================================================

class RubyFile(Token):
    """ A class that represents a ruby file.
        Manages "tokens", ie. classes and functions."""

    def __init__(self, doc):
        Token.__init__(self)
        self.doc = doc
        self.uri = doc.get_uri()
        self.linestotal = 0 # total line count
        self.type = "file"
        if self.uri:
            self.name = os.path.basename(self.uri)
        self.tokens = []


    def getTokenAtLine(self, line):
        """ get the token at the specified line number """
        for token in self.tokens:
            if token.start <= line and token.end > line:
                return self.__findInnermostTokenAtLine(token, line)
        return None

    def __findInnermostTokenAtLine(self, token, line):
        """" ruby is parsed as nested, unlike python """
        for child in token.children:
            if child.start <= line and child.end > line:
                return self.__findInnermostTokenAtLine(child, line)
        return token


    def parse(self, verbose=True):

        #if verbose: print "parse ----------------------------------------------"
        newtokenlist = []

        self.children = []

        currentParent = self

        self.linestotal = self.doc.get_line_count()

        text = self.doc.get_text(*self.doc.get_bounds())
        linecount = -1
        ends_to_skip = 0
        
        access = "public"
        
        for line in text.splitlines():
            linecount += 1
            lstrip = line.lstrip()
            ln = lstrip.split()
            if len(ln) == 0: continue
            if ln[0] == '#': continue
            
            if ln[0] in ("class","module","def"):
                token = tokenFromString(lstrip)
                if token is None: continue
                token.rubyfile = self
                token.start = linecount

                if token.type in ("class", "module"):
                    access = "public"

                if token.type == "def":
                    token.access = access
                    
                #print "line",linecount
                #print "name", token.name
                #print "type",token.type
                #print "access",token.access
                #print "to",currentParent.name
                
                currentParent.children.append(token)
                token.parent = currentParent
                currentParent = token
                newtokenlist.append(token)
                
                
                idx = len(newtokenlist) - 1
                if idx < len(self.tokens):
                    if newtokenlist[idx].original == self.tokens[idx].original:
                        newtokenlist[idx].expanded = self.tokens[idx].expanded
                
            elif ln[0] in("begin","while","until","case","if","unless","for"):
                    ends_to_skip += 1
                    
            elif ln[0] in ("attr_reader","attr_writer","attr_accessor"):
                for attr in ln:
                    m = re.match(r":(\w+)",attr)
                    if m:
                        token = Token()
                        token.rubyfile = self
                        token.type = 'def'
                        token.name = m.group(1)
                        token.start = linecount
                        token.end = linecount
                        token.original = lstrip
                        currentParent.children.append(token)
                        token.parent = currentParent
                        newtokenlist.append(token)
            
            elif re.search(r"\sdo(\s+\|.*?\|)?\s*(#|$)", line):
                #print "do",line

                # Support for new style RSpec
                if re.match(r"^(describe|it|before|after)\b", ln[0]):
                    token = Token()
                    token.rubyfile = self
                    token.start = linecount
                    
                    if currentParent.type == "describe":                    
                        if ln[0] == "it":
                            token.name = " ".join(ln[1:-1])
                        else:
                            token.name = ln[0]
                        token.type = "def"
                    elif ln[0] == "describe":
                        token.type = "describe"
                        token.name = " ".join(ln[1:-1])
                    else:
                        continue
                    currentParent.children.append(token)
                    token.parent = currentParent
                    currentParent = token
                    newtokenlist.append(token)

                # Deprectated support for old style RSpec, will be removed later
                elif ln[0] in ("context","specify","setup","teardown","context_setup","context_teardown"):
                    token = Token()
                    token.rubyfile = self
                    token.start = linecount
                    
                    if currentParent.type == "context":                    
                        if ln[0] == "specify":
                            token.name = " ".join(ln[1:-1])
                        else:
                            token.name = ln[0]
                        token.type = "def"
                    elif ln[0] == "context":
                        token.type = "context"
                        token.name = " ".join(ln[1:-1])
                    else:
                        continue
                    currentParent.children.append(token)
                    token.parent = currentParent
                    currentParent = token
                    newtokenlist.append(token)
                else:
                    ends_to_skip += 1
                
            elif ln[0] in ("public","private","protected"):
                if len(ln) == 1:
                    access = ln[0]
                    
	    if re.search(r";?\s*end(\.|,|&|\||\s|$)", line):
                if ends_to_skip > 0:
                    ends_to_skip -= 1
                else:
                    token = currentParent
                    #print "end",currentParent.name
                    token.end = linecount
                    if token.parent:
                        currentParent = token.parent
                

        # set new token list
        self.tokens = newtokenlist
        return True


#===============================================================================

class RubyParser( ClassParserInterface ):
    
    def __init__(self):
        self.rubyfile = None


    def appendTokenToBrowser(self, token, parentit ):
        it = self.__browsermodel.append(parentit,(token,))
        token.path = self.__browsermodel.get_path(it)
        #print token.path
        #if token.parent:
        #    if token.parent.expanded:
        #        self.browser.expand_row(token.parent.path,False)
        #        pass
        for child in token.children:
            self.appendTokenToBrowser(child, it)


    def parse(self, doc):
        """ 
        Create a gtk.TreeModel with the class elements of the document
        
        The parser uses the ctags command from the shell to create a ctags file,
        then parses the file, and finally populates a treemodel.
        """
    
        self.rubyfile = RubyFile(doc)
        self.rubyfile.parse(options.singleton().verbose)
        self.__browsermodel = gtk.TreeStore(gobject.TYPE_PYOBJECT)
        for child in self.rubyfile.children:
            self.appendTokenToBrowser(child,None)
        return self.__browsermodel

        
    def __private_test_method(self):
        pass


    def get_tag_position(self, model, path):
        tok = model.get_value( model.get_iter(path), 0 )
        try: return tok.rubyfile.uri, tok.start+1
        except: return None


    def current_line_changed(self, model, doc, line):

        # parse again if line count changed
        if abs(self.rubyfile.linestotal - doc.get_line_count()) > 0:
            if abs(self.rubyfile.linestotal - doc.get_line_count()) > 5:
                if options.singleton().verbose:
                    print "RubyParser: refresh because line dif > 5"
                self.rubyfile.parse()
            else:
                it = doc.get_iter_at_line(line)
                a = it.copy(); b = it.copy()
                a.backward_line(); a.backward_line()
                b.forward_line(); b.forward_line()

                t = doc.get_text(a,b)
                if t.find("class") >= 0 or t.find("def") >= 0:
                    if options.singleton().verbose:
                        print "RubyParser: refresh because line cound changed near keyword"
                    self.rubyfile.parse()
 

    def get_tag_at_line(self, model, doc, linenumber):
        t = self.rubyfile.getTokenAtLine(linenumber)
        #print linenumber,t
        if t: return t.path


    def cellrenderer(self, column, ctr, model, it):

        """ Render the browser cell according to the token it represents. """
        tok = model.get_value(it,0)

        weight = 400
        style = pango.STYLE_NORMAL
        name = tok.name#+tok.params
        colour = options.singleton().colours[ "function" ]

        # set label and colour
        if tok.type == "class":
            name = "class "+name
            colour = options.singleton().colours[ "class" ]
            weight = 600
            
        elif tok.type == "module":
            name = "module "+name
            colour = options.singleton().colours[ "namespace" ]
            weight = 600
            
        # new style RSpec
        elif tok.type == "describe":
            name = "describe "+name
            colour = options.singleton().colours[ "namespace" ]
            weight = 600
        
        # Old style RSpec, deprecated    
        elif tok.type == "context":
            name = "context "+name
            colour = options.singleton().colours[ "namespace" ]
            weight = 600
            
        elif tok.type == "def":
            colour = options.singleton().colours[ "member" ]
            
        if tok.comment: name = "#"+name

        # assing properties
        ctr.set_property("text", name)
        ctr.set_property("style", style)
        ctr.set_property("foreground-gdk", colour)


    def pixbufrenderer(self, column, crp, model, it):
        tok = model.get_value(it,0)

        icon = "default"

        if tok.type == "class":
            icon = "class"
        elif tok.type == "module":
            icon = "namespace"
        elif tok.type == "describe":
            icon = "namespace"
        elif tok.type == "context":
            icon = "namespace"
        elif tok.type == "def":
            if tok.access == "public":
                icon = "method"
            elif tok.access == "protected":
                icon = "method_prot"
            elif tok.access == "private":
                icon = "method_priv"
                
        crp.set_property("pixbuf",imagelibrary.pixbufs[icon])

        
    def __str_ends_with(self, string, w):
        return string[-len(w):] == w
        
    def get_menu(self, model, path):
        tok = model.get_value( model.get_iter(path), 0 )
        if tok and tok.rubyfile.uri:
            path, filename = os.path.split(tok.rubyfile.uri);
            parentpath = os.path.split(path);
            
            # 1) see if the path of the current file indicates if this is a controller,
            #    a helper or a model
            
            # the current file is a controller?
            if self.__str_ends_with(path,"/app/controllers") and self.__str_ends_with(filename,"controller.rb"):
                 print "is a controller"
                 
            
        return []
        

########NEW FILE########
__FILENAME__ = tabwatch
# Copyright (C) 2006 Frederic Back (fredericback@gmail.com)
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, 
# Boston, MA 02111-1307, USA.

import gtk
import options

#-------------------------------------------------------------------------------        
class TabWatch:
    """ Monitor the tabs in gedit to find out when documents get opened or
        changed. """

    def __init__(self, window, classbrowser):
        self.browser = classbrowser   
        self.geditwindow = window
        self.geditwindow.connect("tab_added",self.__tab_added_or_activated)
        self.geditwindow.connect("tab_removed",self.__tab_removed)
        self.geditwindow.connect("active_tab_changed",self.__tab_added_or_activated)
        
        self.openfiles = []
        self.currentDoc = None
        self.languageParsers = {}
        self.defaultparser = None
    
    def register_parser(self, mimetype, parser):
        """ register a new class parser to use with a certain mime type.
            language -- a string (see gtksourceview languages for reference)
            parser -- an instance of ClassParserInterface """
        self.languageParsers[mimetype] = parser  
    
    def __tab_added_or_activated(self, window, tab):
        self.__register(tab.get_document(),tab)
        doc = self.geditwindow.get_active_document()
        if doc != self.currentDoc: self.__update()

    def __tab_removed(self, window, tab):
        self.__unregister(tab.get_document())

        doc = self.geditwindow.get_active_document()
        if doc != self.currentDoc: self.__update()

    def __register(self, doc, tab):
        if doc is None: return
        uri = doc.get_uri()
        if uri in self.openfiles: return
        self.openfiles.append(uri)
        tab.get_view().connect_after("notify",self.browser.on_cursor_changed)
        tab.get_view().connect_after("move-cursor",self.browser.update_cursor)

        #doc.set_modified(True)
        doc.connect("modified-changed",self.__update)
        if options.singleton().verbose: print "added:",uri

    def __unregister(self, doc):
        if doc is None: return
        uri = doc.get_uri()
        if uri not in self.openfiles: return
        self.openfiles.remove(uri)  
        #if options.singleton().verbose: print "removed:",uri

    def __update(self, *args):
        doc = self.geditwindow.get_active_document()
        if doc:
                
            lang = doc.get_language()
            parser = self.defaultparser
            if lang:
                m = lang.get_name()
                if m in self.languageParsers: parser = self.languageParsers[m]

            if options.singleton().verbose:
                print "parse %s (%s)"%(doc.get_uri(),parser.__class__.__name__)
            model = parser.parse(doc)
            self.browser.set_model(model, parser)
            self.currentDoc = doc

        else:
            self.browser.set_model(None)

########NEW FILE########
__FILENAME__ = click_config
# -*- coding: utf8 -*-
#  Click Config  plugin for Gedit
#
#  Copyright (C) 2010 Derek Veit
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module provides the plugin object that Gedit interacts with.

Classes:
ClickConfigPlugin       -- object is loaded once by an instance of Gedit
ClickConfigWindowHelper -- object is constructed for each Gedit window

Each time the same Gedit instance makes a new window, Gedit calls the
plugin's activate method.  Each time ClickConfigPlugin is so activated,
it constructs a ClickConfigWindowHelper object to handle the new window.

Settings common to all Gedit windows are attributes of ClickConfigPlugin.
Settings specific to one window are attributes of ClickConfigWindowHelper.

"""

import itertools
import os
import re
import sys
import time

import gedit
import gtk
import gtksourceview2

from .data import SelectionOp, ConfigSet, Config
from .ui import ConfigUI
from .logger import Logger
LOGGER = Logger(level=('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')[2])

class ClickConfigPlugin(gedit.Plugin):
    
    """
    An object of this class is loaded once by a Gedit instance.
    
    It establishes and maintains the configuration data, and it creates
    a ClickConfigWindowHelper object for each Gedit main window.
    
    Public methods:
    activate                -- Gedit calls this to start the plugin.
    deactivate              -- Gedit calls this to stop the plugin.
    update_ui               -- Gedit calls this at certain times when
                               the ui changes.
    is_configurable         -- Gedit calls this to check if the plugin
                               is configurable.
    create_configure_dialog -- Gedit calls this when "Configure" is
                               selected in the Preferences Plugins tab.
                               Also, ClickConfigWindowHelper calls this
                               when Edit > Click Config > Configure is
                               selected.
    update_configuration    -- The ConfigUI object calls this when Apply
                               or OK is clicked on the configuration
                               window.
    open_config_dir         -- Opens a Nautilus window of the
                               configuration file's directory.  This is
                               called by the ConfigUI object when the
                               Browse button is clicked.
    get_gedit_window        -- Returns the current Gedit window.
    
    """
    
    def __init__(self):
        """Initialize plugin attributes."""
        LOGGER.log()
        
        gedit.Plugin.__init__(self)
        
        self._instances = {}
        """Each Gedit window will get a ClickConfigWindowHelper instance."""
        
        self.plugin_path = None
        """The directory path of this file and the configuration file."""
        
        self.config_ui = None
        """This will identify the (singular) ConfigUI object."""
        
        self.conf = None
        """This object contains all the settings."""
    
    def activate(self, window):
        """Start a ClickConfigWindowHelper instance for this Gedit window."""
        LOGGER.log()
        if not self._instances:
            LOGGER.log('Click Config activating.')
            self.conf = Config(self)
            self.set_conf_defaults()
            self.plugin_path = os.path.dirname(os.path.realpath(__file__))
            self.conf.filename = os.path.join(self.plugin_path,
                                                 'click_config_configs')
            if os.path.exists(self.conf.filename):
                self.conf.load()
            self.conf.check_language_configsets()
        self._instances[window] = ClickConfigWindowHelper(self, window)
        self._instances[window].activate()
    
    def deactivate(self, window):
        """End the ClickConfigWindowHelper instance for this Gedit window."""
        LOGGER.log()
        self._instances[window].deactivate()
        self._instances.pop(window)
        if not self._instances:
            self.conf = None
            self.config_ui = None
            self.plugin_path = None
            LOGGER.log('Click Config deactivated.')
    
    def update_ui(self, window):
        """Forward Gedit's update_ui command for this window."""
        LOGGER.log()
        self._instances[window].update_ui()
    
    def is_configurable(self):
        """Identify for Gedit that Click Config is configurable."""
        LOGGER.log()
        return True
    
    def create_configure_dialog(self):
        """Produce the configuration window and provide it to Gedit."""
        LOGGER.log()
        if self.config_ui:
            self.config_ui.window.present()
        else:
            self.config_ui = ConfigUI(self)
        return self.config_ui.window
    
    def set_conf_defaults(self):
        """
        Set the configuration to initial default values.
        These values get replaced if there is a configuration file.
        """
        LOGGER.log()
        self.conf.ops = [
            SelectionOp('None',
                preserved=True),
            SelectionOp('Gedit word',
                pattern='[a-zA-Z]+|[0-9]+|[^a-zA-Z0-9]+',
                preserved=True),
            SelectionOp('GNOME Terminal default',
                pattern='[-A-Za-z0-9,./?%&#:_]+'),
            SelectionOp('Line',
                pattern='.*',
                preserved=True),
            SelectionOp('Line+',
                pattern='^.*\\n',
                flags=re.M,
                preserved=True),
            SelectionOp('Python name',
                pattern='[_a-zA-Z][_a-zA-Z0-9]*',
                preserved=True),
            SelectionOp('Paragraph',
                pattern=('(?: ^ (?:  [ \\t]*  \\S+  [ \\t]*  )  +  \\n  )+'
                 '  # \xe2\x9c\x94X allows comment'),
                flags=(re.M + re.X)),
            SelectionOp('Paragraph+',
                pattern='(?:^(?:[ \\t]*\\S+[ \\t]*)+\\n)+(?:[ \\t]*\\n)?',
                flags=re.M,
                preserved=True),
            SelectionOp('Python name 2',
                pattern='[_a-z][_.a-z0-9]*',
                flags=re.I),
            ]
        self.conf.configsets = [
            ConfigSet('Gedit built-in',
                op_names=[
                    'None',
                    'Gedit word',
                    'Line',
                    'None',
                    'None',
                    ],
                preserved=True),
            ConfigSet('Click Config default',
                op_names=[
                    'None',
                    'Gedit word',
                    'Python name',
                    'Line+',
                    'Paragraph+',
                    ],
                preserved=True),
            ConfigSet('Custom',
                op_names=[
                    'None',
                    'Gedit word',
                    'Python name',
                    'Line+',
                    'Paragraph+',
                    ]),
            ]
        self.conf.current_configset_name = 'Custom'
        self.conf.current_op_name = 'None'
        self.conf.languages = {
            '-None-': 'Click Config default',
            'Python': 'Custom',
            }
        self.conf.is_set_by_language = False
    
    def update_configuration(self, conf):
        """Adopt the provided configuration and save it."""
        LOGGER.log()
        self.conf = conf
        self.conf.save()
        for window in self._instances:
            self._instances[window].update_menu()
        LOGGER.log('Configuration updated.')
    
    def open_config_dir(self):
        """Open a Nautilus window of the configuration file's directory."""
        LOGGER.log()
        import subprocess
        directory = os.path.dirname(self.conf.filename)
        args = ['nautilus', directory]
        subprocess.Popen(args, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    
    def get_gedit_window(self):
        """
        Return the current Gedit window.
        ConfigUI uses this to identify its parent window.
        """
        LOGGER.log()
        return gedit.app_get_default().get_active_window()
    
    def _get_languages(self):
        """Return a list of the languages known to Gedit."""
        LOGGER.log()
        gtk_lang_mgr = gtksourceview2.language_manager_get_default()
        language_ids = gtk_lang_mgr.get_language_ids()
        language_names = []
        for language_id in language_ids:
            language = gtk_lang_mgr.get_language(language_id)
            language_names.append(language.get_name())
        language_names.sort(lambda a, b:
                                cmp(a.lower(), b.lower()))
        return language_names
    
    def _get_languages_by_section(self):
        """Return a dictionary of the languages known to Gedit, grouped."""
        LOGGER.log()
        gtk_lang_mgr = gtksourceview2.language_manager_get_default()
        language_ids = gtk_lang_mgr.get_language_ids()
        languages_by_section = {}
        for language_id in language_ids:
            language = gtk_lang_mgr.get_language(language_id)
            section = language.get_section()
            name = language.get_name()
            if section in languages_by_section:
                languages_by_section[section].append(name)
            else:
                languages_by_section[section] = [name]
        for section in languages_by_section:
            languages_by_section[section].sort(lambda a, b:
                                                cmp(a.lower(), b.lower()))
        return languages_by_section

class ClickConfigWindowHelper(object):
    
    """
    ClickConfigPlugin creates a ClickConfigWindowHelper object for each
    Gedit window.  This object receives mouse and menu inputs from the
    Gedit window and responds by selecting text, or if the menu item is
    for Configuration, it calls the plugin's method to open the
    configuration window.
    
    Public methods:
    deactivate         -- ClickConfigPlugin calls this when Gedit calls
                          deactivate for this window.
    open_config_window -- calls ClickConfigPlugin method to open the
                          configuration window.
    update_ui          -- ClickConfigPlugin calls this when Gedit calls
                          update_ui for this window.  It activates the
                          menu for the Gedit window and connects the
                          mouse event handler to the current View.
                          Also, ClickConfigWindowHelper.__init_ calls
                          this.
    on_scrollwin_add   -- update_ui connects this to the 'add' event of
                          a new ScrolledWindow it finds in order to find
                          out about a new Viewport created by the Split
                          View plugin.
    on_viewport_add    -- on_scrollwin_add connects this to the 'add'
                          event of a new Viewport it finds in order to
                          find out about new views created by the Split
                          View plugin.  When called, it calls update_ui
                          to connect the mouse event handler to both
                          views.
    
    """
    
    def __init__(self, plugin, window):
        """Initialize values of this Click Config instance."""
        LOGGER.log()
        
        self._window = window
        """The window this ClickConfigWindowHelper runs on."""
        self._plugin = plugin
        """The ClickConfigPlugin that spawned this ClickConfigWindowHelper."""
        
        LOGGER.log('Started for %s' % self._window)
        
        self._ui_id = None
        """The menu's UI identity, saved for removal."""
        self._action_group = None
        """The menu's action group, saved for removal."""
        
        self._time_of_last_click = [None, 0, 0, 0, 0, 0]
        """Times of the most recent clicks for each of the five click types."""
        
        gtk_settings = gtk.settings_get_default()
        gtk_doubleclick_ms = gtk_settings.get_property('gtk-double-click-time')
        self._double_click_time = float(gtk_doubleclick_ms)/1000
        """Maximum time between consecutive clicks in a multiple click."""
        
        self._mouse_handler_ids_per_view = {}
        """The mouse handler id for each of the window's views."""
        
        self._key_handler_ids_per_view = {}
        """The key_press handler id for each of the window's views."""
        
        self._handlers_per_scrollwin = {}
        """A special 'add' signal handler for each ScrolledWindow found."""
        self._handlers_per_viewport = {}
        """A special 'add' signal handler for each Viewport found."""
        
        self._drag_handler_ids = ()
        """Motion and button-release handlers for drag selecting."""
        
        # These attributes are used for extending the selection for click-drag.
        self._word_re = None
        """The compiled regular expression object of the current click."""
        self._boundaries = None
        """All start and end positions of matches of the current click."""
        self._click_start_iter = None
        """Start iter of the clicked selection."""
        self._click_end_iter = None
        """End iter of the clicked selection."""
    
    def _insert_menu(self):
        """Create the Click Config submenu under the Edit menu."""
        LOGGER.log()
        
        actions = []
        
        name = 'ClickConfig'
        stock_id = None
        label = 'Click Config'
        actions.append((name, stock_id, label))
        
        name = 'Configure'
        stock_id = None
        label = 'Configure'
        accelerator = '<Control>b'
        tooltip = 'Configure Click Config'
        callback = lambda action: self.open_config_window()
        actions.append((name, stock_id, label, accelerator, tooltip, callback))
        
        op_menuitems = ''
        for op_name in self._plugin.conf.get_op_names()[1:]:
            # Iterating get_op_names ensures that the names are sorted.
            op = self._plugin.conf.get_op(op_name=op_name)
            name = op.name
            stock_id = None
            label = op.name
            accelerator = ''
            flag_text =  ' I' * bool(op.flags & re.I)
            flag_text += ' M' * bool(op.flags & re.M)
            flag_text += ' S' * bool(op.flags & re.S)
            flag_text += ' X' * bool(op.flags & re.X)
            flag_text = flag_text or '(None)'
            tooltip = ('Select text at the cursor location: '
                    'pattern = %s, flags = %s' % (repr(op.pattern), flag_text))
            callback = lambda action: self._select_op(
                        self._plugin.conf.get_op(op_name=action.get_name()))
            action = (name, stock_id, label, accelerator, tooltip, callback)
            actions.append(action)
            op_menuitems += '\n' + ' ' * 22 + '<menuitem action="%s"/>' % name
        
        self._action_group = gtk.ActionGroup("ClickConfigPluginActions")
        self._action_group.add_actions(actions)
        manager = self._window.get_ui_manager()
        manager.insert_action_group(self._action_group, -1)
        
        ui_str = """
            <ui>
              <menubar name="MenuBar">
                <menu name="EditMenu" action="Edit">
                  <placeholder name="EditOps_6">
                    <menu action="ClickConfig">
                      <menuitem action="Configure"/>
                      <separator/>%s
                    </menu>
                  </placeholder>
                </menu>
              </menubar>
            </ui>
            """ % op_menuitems
        self._ui_id = manager.add_ui_from_string(ui_str)
    
        LOGGER.log('Menu added for %s' % self._window)
    
    def _remove_menu(self):
        """Remove the Click Config submenu."""
        LOGGER.log()
        manager = self._window.get_ui_manager()
        manager.remove_ui(self._ui_id)
        manager.remove_action_group(self._action_group)
        self._action_group = None
        manager.ensure_update()
        LOGGER.log('Menu removed for %s' % self._window)
    
    def update_menu(self):
        """Update the menu (in case the SelectionOp list has changed)."""
        LOGGER.log()
        self._remove_menu()
        self._insert_menu()
    
    def activate(self):
        """End this instance of Click Config"""
        LOGGER.log()
        LOGGER.log('Click Config activating for %s' % self._window)
        self._insert_menu()
        self.update_ui()
    
    def deactivate(self):
        """End this instance of Click Config"""
        LOGGER.log()
        self._disconnect_mouse_handlers()
        self._disconnect_scrollwin_handlers()
        self._disconnect_viewport_handlers()
        self._remove_menu()
        self._time_of_last_click = None
        self._double_click_time = None
        self._plugin = None
        LOGGER.log('Click Config deactivated for %s' % self._window)
        self._window = None
    
    def open_config_window(self):
        """Open the Click Config plugin configuration window."""
        LOGGER.log()
        self._plugin.create_configure_dialog()
        self._plugin.config_ui.window.show()
    
    def get_doc_language(self):
        """Return the programming language of the current document."""
        LOGGER.log()
        doc = self._window.get_active_document()
        doc_language = doc.get_language()
        if doc_language:
            doc_language_name = doc_language.get_name()
        else:
            doc_language_name = '-None-'
        return doc_language_name
    
    def update_ui(self):
        """
        Identify the document and connect the menu and mouse handling.
        
        A mouse handler connection must be made for each view.
        
        The Split View 2 plugin creates two views in each tab, and
        GeditWindow.get_active_view() only gets the first one.  So it's
        necessary to get the active tab and then drill down to get its
        view(s), so that a mouse handler can be attached to each.
        """
        LOGGER.log()
        doc = self._window.get_active_document()
        tab = self._window.get_active_tab()
        current_view = self._window.get_active_view()
        if doc and current_view and current_view.get_editable():
            if self._plugin.conf.is_set_by_language:
                language = self.get_doc_language()
                LOGGER.log('Language detected: %s' % language)
                if language in self._plugin.conf.languages:
                    configset_name = self._plugin.conf.languages[language]
                    self._plugin.conf.current_configset_name = configset_name
                    LOGGER.log('ConfigSet selected: %s' %
                                             configset_name)
            self._action_group.set_sensitive(True)
            scrollwin = tab.get_children()[0]
            if scrollwin not in self._handlers_per_scrollwin:
                """Prepare to catch new Split View views."""
                self._handlers_per_scrollwin[scrollwin] = \
                    scrollwin.connect('add',
                                      self.on_scrollwin_add, self._window)
            child = scrollwin.get_child()
            if type(child).__name__ == 'View':
                """Connect to the view within the normal GUI structure."""
                view = child
                self._connect_view(view)
            elif type(child).__name__ == 'Viewport':
                """Connect to views within Split View's GUI structure."""
                viewport = child
                vbox = viewport.get_child()
                if vbox:
                    vpaned = vbox.get_children()[1]
                    scrolled_window_1 = vpaned.get_child1()
                    scrolled_window_2 = vpaned.get_child2()
                    view_1 = scrolled_window_1.get_child()
                    view_2 = scrolled_window_2.get_child()
                    LOGGER.log('Split View 1: %s' % repr(view_1))
                    LOGGER.log('Split View 2: %s' % repr(view_2))
                    self._connect_view(view_1)
                    self._connect_view(view_2)
    
    def on_scrollwin_add(self, scrollwin, widget, window):
        """Call update_ui to add any new view added by Split View"""
        LOGGER.log()
        #scrollwin.disconnect(self._handlers_per_scrollwin[scrollwin])
        #self._handlers_per_scrollwin[scrollwin] = None
        if type(widget).__name__ == 'Viewport':
            viewport = widget
            vbox = viewport.get_child()
            if vbox:
                # Have update_ui hook up the views in the Vbox.
                self.update_ui()
            else:
                # Tell on_viewport_add when the Vbox has been added.
                self._handlers_per_viewport[viewport] = \
                    viewport.connect('add', self.on_viewport_add, window)
        # If it's not a Viewport, then it's probably just the normal View.
        return False
    
    def on_viewport_add(self, viewport, widget, window):
        """Call update_ui to add any new view added by Split View"""
        LOGGER.log()
        viewport.disconnect(self._handlers_per_viewport.pop(viewport))
        # The Vbox is there, so have update_ui hook up the views in it.
        # (This is presuming the Hpaned or Vpaned and Views within it
        # are reliably already in the Vbox.  Otherwise, another event
        # handler step or two might be needed.  But, so far, they seem
        # to always be ready.)
        self.update_ui()
        return False
    
    def _connect_view(self, view):
        """Connect the mouse handler to the view."""
        LOGGER.log()
        LOGGER.log(var='view')
        if view not in self._mouse_handler_ids_per_view:
            self._connect_mouse_handler(view)
            LOGGER.log('Connected to: %s' % repr(view))
    
    def _connect_mouse_handler(self, view):
        """Connect the handler for the view's button_press_event."""
        LOGGER.log()
        self._mouse_handler_ids_per_view[view] = \
            view.connect("button_press_event", self._handle_button_press)
    
    def _connect_drag_handler(self, view):
        """
        Connect handlers for the view's motion_notify_event
                                    and button_release_event.
        The motion events will be used to trigger multiple-click
        drag-selecting and the release event will be used to end it.
        """
        LOGGER.log()
        self._drag_handler_ids = (
            view.connect("motion_notify_event", self._drag_select),
            view.connect_after("button_release_event",
                               self._disconnect_drag_handler)
            )
    
    def _drag_select(self, widget, event):
        """
        Extend the text selection to include a selection at the current pointer
        position.
        """
        LOGGER.log()
        view = widget
        
        # Scroll if dragging beyond top or bottom of the view.
        (visible_left_x, visible_top_y,
            view_width, view_height) = view.get_visible_rect()
        visible_bottom_y = visible_top_y + view_height
        if event.y < 0:
            top_line_iter, top_line_y = \
                view.get_line_at_y(visible_top_y)
            if (view.backward_display_line(top_line_iter) or
                    top_line_y < visible_top_y):
                view.scroll_to_iter(top_line_iter, within_margin=0.0)
        if event.y > view_height:
            bottom_line_iter, bottom_line_y = \
                view.get_line_at_y(visible_bottom_y)
            bottom_line_height = view.get_line_yrange(bottom_line_iter)[1]
            if (view.forward_display_line(bottom_line_iter) or
                    bottom_line_y > visible_bottom_y - bottom_line_height):
                view.scroll_to_iter(bottom_line_iter, within_margin=0.0)
        
        drag_iter = self._get_click_iter(view, event)
        
        # self._word_re will be used
        self._select_regex(drag_iter, word_re=None, extend=True)
    
    def _disconnect_drag_handler(self, widget, event=None):
        """Disconnect the event handlers for drag selecting."""
        LOGGER.log()
        view = widget
        for handler_id in self._drag_handler_ids:
            view.disconnect(handler_id)
        # Clear the match data of the click.
        self._word_re = None
        self._boundaries = None
        self._click_start_iter = None
        self._click_end_iter = None
    
    def _disconnect_scrollwin_handlers(self):
        """Disconnect any remaining ScrolledWindow event handlers."""
        LOGGER.log()
        for scrollwin in self._handlers_per_scrollwin.keys():
            handler_id = self._handlers_per_scrollwin.pop(scrollwin)
            if scrollwin.handler_is_connected(handler_id):
                scrollwin.disconnect(handler_id)
    
    def _disconnect_viewport_handlers(self):
        """Disconnect any remaining Viewport event handlers."""
        LOGGER.log()
        for viewport in self._handlers_per_viewport.keys():
            handler_id = self._handlers_per_viewport.pop(viewport)
            if viewport.handler_is_connected(handler_id):
                viewport.disconnect(handler_id)
    
    def _disconnect_mouse_handlers(self):
        """Disconnect from mouse signals from all views in the window."""
        LOGGER.log()
        for view in self._mouse_handler_ids_per_view.keys():
            handler_id = self._mouse_handler_ids_per_view.pop(view)
            if view.handler_is_connected(handler_id):
                view.disconnect(handler_id)
    
    def _handle_button_press(self, view, event):
        """
        Evaluate mouse click and call for text selection as appropriate.
        Return False if the click should still be handled afterwards.
        """
        LOGGER.log()
        handled = False
        if event.button == 1:
            now = time.time()
            handlers_by_type = {
                gtk.gdk.BUTTON_PRESS: self._handle_1button_press,
                gtk.gdk._2BUTTON_PRESS: self._handle_2button_press,
                gtk.gdk._3BUTTON_PRESS: self._handle_3button_press,
                }
            handled, click = handlers_by_type[event.type](now)
            if click:
                click_iter = self._get_click_iter(view, event)
                handled = self._make_assigned_selection(click, click_iter)
                if handled:
                    self._connect_drag_handler(view)
        return handled
    
    def _handle_1button_press(self, now):
        """Detect 5-click, 4-click, or 1-click. Otherwise eat the signal."""
        LOGGER.log()
        handled = False
        click = None
        if now - self._time_of_last_click[4] < self._double_click_time:
            LOGGER.log('Quintuple-click.')
            # QUINTUPLE-CLICKS are handled here.
            self._time_of_last_click[5] = now
            click = 5
        elif now - self._time_of_last_click[3] < self._double_click_time:
            LOGGER.log('Quadruple-click.')
            # QUADRUPLE-CLICKS are handled here.
            self._time_of_last_click[4] = now
            click = 4
        elif now - self._time_of_last_click[2] < self._double_click_time:
            LOGGER.log('(3rd click of a triple-click.)', level='debug')
            # Ignore and consume it.  Triple-clicks are not handled here.
            handled = True
        elif now - self._time_of_last_click[1] < self._double_click_time:
            LOGGER.log('(2nd click of a double-click.)', level='debug')
            # Ignore and consume it.  Double-clicks are not handled here.
            handled = True
        else:
            LOGGER.log('Single-click.')
            # SINGLE-CLICKS are handled here.
            self._time_of_last_click[1] = now
            click = 1
        return handled, click
    
    def _handle_2button_press(self, now):
        """Detect 2-click. Otherwise eat the signal."""
        LOGGER.log()
        handled = False
        click = None
        if (now - self._time_of_last_click[4]) < self._double_click_time:
            LOGGER.log('(4th & 5th of a quintuple-click.)', level='debug')
            # Ignore and consume it.  Quintuple-clicks are not handled here.
            handled = True
        else:
            LOGGER.log('Double-click.')
            # DOUBLE-CLICKS are handled here.
            self._time_of_last_click[2] = now
            click = 2
        return handled, click
    
    def _handle_3button_press(self, now):
        """Detect 3-click. Otherwise eat the signal."""
        LOGGER.log()
        handled = False
        click = None
        if (now - self._time_of_last_click[5]) < self._double_click_time:
            LOGGER.log('(4th-6th of a sextuple-click.)', level='debug')
            # Ignore and consume it.  Sextuple-clicks are not handled here.
            handled = True
        else:
            LOGGER.log('Triple-click.')
            # TRIPLE-CLICKS are handled here.
            self._time_of_last_click[3] = now
            click = 3
        return handled, click
    
    def _get_click_iter(self, view, event):
        """Return the current cursor location based on the click location."""
        LOGGER.log()
        buffer_x, buffer_y = view.window_to_buffer_coords(
                        view.get_window_type(event.window),
                        int(event.x),
                        int(event.y))
        event_iter = view.get_iter_at_location(buffer_x, buffer_y)
        return event_iter
    
    def _get_insert_iter(self):
        """Return the current cursor location based on the insert mark."""
        LOGGER.log()
        doc = self._window.get_active_document()
        insert_mark = doc.get_insert()
        insert_iter = doc.get_iter_at_mark(insert_mark)
        return insert_iter
    
    def _make_assigned_selection(self, click, click_iter):
        """Select text based on the click type and location."""
        LOGGER.log()
        acted = False
        op = self._plugin.conf.get_op(click=click)
        if op.name != 'None':
            acted = self._select_op(op, click_iter=click_iter)
        return acted
    
    # Text selection functions:
    
    def _select_op(self, op, click_iter=None):
        """Finds first regex match that includes the click position."""
        LOGGER.log()
        
        char_spec = op.pattern
        flags = op.flags
        
        LOGGER.log('Selection name: %s' % op.name)
        
        if not click_iter:
            click_iter = self._get_insert_iter()
        
        word_re = re.compile(char_spec, flags)
        
        did_select = self._select_regex(click_iter, word_re)
        return did_select
    
    def _select_regex(self, click_iter, word_re, extend=False):
        """
        Select text in the document matching word_re and containing click_iter.
        """
        LOGGER.log()
        if word_re is None:
            word_re = self._word_re
        else:
            self._word_re = word_re
        doc = self._window.get_active_document()
        multiline = bool(word_re.flags & re.M)
        if multiline:
            source_start_iter, source_end_iter = doc.get_bounds()
            pick_pos = click_iter.get_offset()
        else:
            source_start_iter, source_end_iter = \
                self._get_line_iter_pair(click_iter)
            pick_pos = click_iter.get_line_offset()
        source_text = source_start_iter.get_slice(source_end_iter)
        # There is nothing to select in an empty text.
        if source_text == "":
            return False
        match_start, match_end = self._find_text(source_text, pick_pos, word_re)
        target_start_iter = click_iter.copy()
        target_end_iter = click_iter.copy()
        if multiline:
            target_start_iter.set_offset(match_start)
            target_end_iter.set_offset(match_end)
        else:
            target_start_iter.set_line_offset(match_start)
            target_end_iter.set_line_offset(match_end)
        if extend:
            target_start_iter = min((self._click_start_iter,
                                    target_start_iter),
                                    key=lambda i: i.get_offset())
            #extended_back = target_start_iter != self._click_start_iter
            target_end_iter = max((self._click_end_iter,
                                  target_end_iter),
                                  key=lambda i: i.get_offset())
            #extended_forward = target_end_iter != self._click_end_iter
        else:
            self._click_start_iter = target_start_iter
            self._click_end_iter = target_end_iter
        doc.select_range(target_start_iter, target_end_iter)
        # These two lines will activate search highlighting on the text:
#        found_text = doc.get_text(target_start_iter, target_end_iter)
#        doc.set_search_text(found_text, 1)
        return True
    
    def _find_text(self, source_text, pick_pos, word_re):
        """
        Finds the range of the match, or the range between matches, for regex
        word_re within source_text that includes the position pick_pos.
        If there is no match, then the whole document is selected as being
        between matches.
        """
        LOGGER.log()
        
        # self._boundaries is set by a click selection,
        # remains available for a click-drag selection,
        # and then is set to None by self._disconnect_drag_handler().
        if not self._boundaries:
            self._find_boundaries(source_text, word_re)
        
        after = next((p for p in self._boundaries if p > pick_pos),
                     len(source_text))
        after_index = self._boundaries.index(after)
        before = self._boundaries[after_index - 1]
        
        # For single-line regexes, the boundaries
        # need to be determined each time.
        if not word_re.flags & re.M:
            self._boundaries = None
        
        return before, after
    
    def _find_boundaries(self, source_text, word_re):
        """Find the offsets of all match starting and ending positions."""
        LOGGER.log()
        
        spans = ((m.start(), m.end()) for m in word_re.finditer(source_text))
        boundaries = list(itertools.chain.from_iterable(spans))
        
        source_start = 0
        source_end = len(source_text)
        
        if boundaries:
            if boundaries[0] != source_start:
                boundaries.insert(0, source_start)
            if boundaries[-1] != source_end:
                boundaries.append(source_end)
        else:
            boundaries = [source_start, source_end]
        
        self._boundaries = boundaries
    
    def _get_line_iter_pair(self, a_text_iter):
        """Return iters for the start and end of this iter's line."""
        LOGGER.log()
        left_iter = a_text_iter.copy()
        right_iter = a_text_iter.copy()
        left_iter.set_line_offset(0)
        if not right_iter.ends_line():
            right_iter.forward_to_line_end()
        return left_iter, right_iter


########NEW FILE########
__FILENAME__ = data
# -*- coding: utf8 -*-
#  Click_Config plugin for Gedit
#
#  Copyright (C) 2010 Derek Veit
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module provides objects for storing and changing the configuration data in
the Click_Config plugin for Gedit.

Classes:
SelectionOp -- a text selection operation
ConfigSet -- a set of SelectionOp names, one for each type of click
Config -- the whole store of configuration data for Click_Config

"""

import copy
import os
import shutil
import sys

from .dictfile import read_dict_from_file, write_dict_to_file
from .logger import Logger
LOGGER = Logger(level=('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')[2])

class SelectionOp(object):
    
    """
    Stores a named regex expression and flags for selecting text.
    
    Usage:
    
    select_op = SelectionOp(
        name='Gedit word',
        pattern=r"[a-zA-Z]+|[0-9]+|[^a-zA-Z0-9]+",
        flags=0
        preserved=True)
    
    """
    
    def __init__(self, name_or_dict=None, pattern='', flags=0, preserved=0):
        """
        Define a new SelectionOp from a name, a regex pattern, and regex flags
        or from a dictionary with keys 'name', 'pattern', and 'flags'.
        """
        LOGGER.log()
        
        self.name = ''
        """Name of the SelectionOp."""
        
        self.pattern = ''
        """Pattern suitable as an argument to re.compile."""
        
        self.flags = 0
        """Regular expression flags (based on Python re module constants)."""
        
        self.preserved = False
        """Read-only flag for ConfigUI to check before modifying.)."""
        
        if isinstance(name_or_dict, dict):
            dictionary = name_or_dict
            self.from_dict(dictionary)
        else:
            name = name_or_dict or 'None'
            self.name = name
            self.pattern = pattern
            self.flags = flags
            self.preserved = preserved
    
    def copy_as(self, name):
        """Return a copy of the SelectionOp with a new name."""
        LOGGER.log()
        new = self.copy()
        new.name = name
        new.preserved = False
        return new
    
    def copy(self, memo=None):
        """Return a deep copy of the SelectionOp."""
        LOGGER.log()
        return SelectionOp(
            self.name,
            self.pattern,
            self.flags,
            self.preserved
            )
    
    def __copy__(self):
        """Return a copy. (For use by the copy module.)"""
        LOGGER.log()
        return self.copy()
    
    def __deepcopy__(self, memo=None):
        """Return a deep copy. (For use by the copy module.)"""
        LOGGER.log()
        return self.copy(memo)
    
    def __str__(self):
        """Return a string representation of this object."""
        LOGGER.log()
        return self.__repr__()
    
    def __repr__(self):
        """Return a string representation of this object."""
        LOGGER.log()
        return repr(self.to_dict())
    
    def __eq__(self, op):
        """Return True if equal to the other SelectionOp."""
        LOGGER.log()
        is_equal = (
            self.name == op.name and
            self.pattern == op.pattern and
            self.flags == op.flags and
            self.preserved == op.preserved
            )
        return is_equal
    
    def __ne__(self, op):
        """Return True if not equal to the other SelectionOp."""
        LOGGER.log()
        return not self.__eq__(op)
    
    def to_dict(self):
        """Return a dictionary representing this object."""
        LOGGER.log()
        return {
            'name': self.name,
            'pattern': self.pattern,
            'flags': self.flags,
            'preserved': self.preserved,
            }
    
    def from_dict(self, dictionary):
        """Read from a dictionary representing this object."""
        LOGGER.log()
        self.name = dictionary['name']
        self.pattern = dictionary['pattern']
        self.flags = dictionary['flags']
        self.preserved = dictionary['preserved']

class ConfigSet(object):
    
    """
    Stores a named set of SelectionOp names, one for each of five click types.
    
    Usage:
    
    configset = ConfigSet(
        name='Gedit built-in',
        op_names=['None', 'Gedit word', 'Line', 'None', 'None'])
        #    single, double, triple, quadrulpe, quintuple
    
    """
    
    def __init__(self, name_or_dict=None, op_names=None, preserved=0):
        """
        Define a new ConfigSet from a name and a list of SelectionOp names
        or from a dictionary with keys 'name' and 'op_names'.
        """
        LOGGER.log()
        self.name = ''
        """Name of the ConfigSet."""
        
        self.op_names = []
        """A SelectionOp name for each click type."""
        
        self.preserved = False
        """Read-only flag for ConfigUI to check before modifying.)."""
        
        if isinstance(name_or_dict, dict):
            dictionary = name_or_dict
            self.from_dict(dictionary)
        else:
            name = name_or_dict
            self.name = name
            self.op_names = op_names
            self.preserved = preserved
        
    def copy_as(self, name):
        """Return a copy of the ConfigSet with a new name."""
        LOGGER.log()
        new = self.copy()
        new.name = name
        new.preserved = False
        return new
    
    def copy(self, memo=None):
        """Return a deep copy of the ConfigSet."""
        LOGGER.log()
        return ConfigSet(
            self.name,
            self.op_names[:],
            self.preserved
            )
    
    def __copy__(self):
        """Return a copy. (For use by the copy module.)"""
        LOGGER.log()
        return self.copy()
    
    def __deepcopy__(self, memo=None):
        """Return a deep copy. (For use by the copy module.)"""
        LOGGER.log()
        return self.copy(memo)
    
    def __str__(self):
        """Return a string representation of this object."""
        LOGGER.log()
        return self.__repr__()
    
    def __repr__(self):
        """Return a string representation of this object."""
        LOGGER.log()
        return repr(self.to_dict())
    
    def __eq__(self, configset):
        """Return True if equal to the other ConfigSet."""
        LOGGER.log()
        is_equal = (
            self.name == configset.name and
            self.op_names == configset.op_names and
            self.preserved == configset.preserved
            )
        return is_equal
    
    def __ne__(self, configset):
        """Return True if not equal to the other ConfigSet."""
        LOGGER.log()
        return not self.__eq__(configset)
    
    def to_dict(self):
        """Return a dictionary representing this object."""
        LOGGER.log()
        return {
            'name': self.name,
            'op_names': self.op_names,
            'preserved': self.preserved,
            }
    
    def from_dict(self, dictionary):
        """Read from a dictionary representing this object."""
        LOGGER.log()
        self.name = dictionary['name']
        self.op_names = dictionary['op_names']
        self.preserved = dictionary['preserved']

class Config(object):
    
    """
    Main data store for Click_Config.
    
    Usage:
    
    conf = Config()
    conf.filename = '/home/[user]/.gnome2/gedit/plugins/configfile'
    conf.load()
    
    for configset in conf.configsets:
        print(configset.name)
        for op_name in configset.op_names:
            print('    %s' % op_name)
    
    """
    
    def __init__(self, plugin):
        """Start empty configuration."""
        LOGGER.log()
        
        self._plugin = plugin
        
        self.current_configset_name = ''
        """Name of the current ConfigSet."""
        
        self.current_op_name = ''
        """Name of the current SelectionOp (for the Define section)."""
        
        self.configsets = []
        """List of ConfigSet objects (not just the names)."""
        
        self.ops = []
        """List of SelectionOp objects (not just the names)."""
        
        self.languages = {}
        """
        When 'Configure by language' is active, Click_Config will automatically
        use a ConfigSet assigned to the SourceView language of the document.
        
        This dictionary maps ConfigSets to langauges. E.g.:
            '-None-': 'Click_Config default',
            'Python': 'Click_Config default',
        '-None-' is for no language detected.
        """
        
        self.is_set_by_language = False
        """Whether to switch to a ConfigSet based on the document language."""
        
        self.filename = ''
        """Full path and filename for configuration file."""
        
        self.window_width = 0
        """Width of configuration window."""
        
        self.window_height_short = 0
        """Height of configuration window without langauge frame."""
    
        self.window_height_tall = 0
        """Height of configuration window with langauge frame."""
    
    def copy(self, memo=None):
        """Return a (deep) copy of the Config."""
        LOGGER.log()
        # cannot return copy.deepcopy(self)
        # because copy.deepcopy cannot deepcopy the plugin reference.
        new = Config(self._plugin)
        new.current_configset_name = self.current_configset_name
        new.current_op_name = self.current_op_name
        new.configsets = copy.deepcopy(self.configsets, memo)
        new.ops = copy.deepcopy(self.ops, memo)
        new.languages = self.languages.copy()
        new.is_set_by_language = self.is_set_by_language
        new.filename = self.filename
        new.window_width = self.window_width
        new.window_height_short = self.window_height_short
        new.window_height_tall = self.window_height_tall
        return new
    
    def __copy__(self):
        """Return a copy. (For use by the copy module.)"""
        LOGGER.log()
        return self.copy()
    
    def __deepcopy__(self, memo=None):
        """Return a deep copy. (For use by the copy module.)"""
        LOGGER.log()
        return self.copy(memo)
    
    def __str__(self):
        """Return a string representation of this object."""
        LOGGER.log()
        return self.__repr__()
    
    def __repr__(self):
        """Return a string representation of this object."""
        LOGGER.log()
        return repr(self.to_dict())
    
    def __eq__(self, config):
        """Return True if equal to the other Config."""
        LOGGER.log()
        if len(self.ops) != len(config.ops):
            return False
        for i in range(len(self.ops)):
            if self.ops[i] != config.ops[i]:
                return False
        if len(self.configsets) != len(config.configsets):
            return False
        for i in range(len(self.configsets)):
            if self.configsets[i] != config.configsets[i]:
                return False
        is_equal = (
            self.current_configset_name == config.current_configset_name and
            self.current_op_name == config.current_op_name and
            self.languages == config.languages and
            self.is_set_by_language == config.is_set_by_language
            )
        return is_equal
    
    def __ne__(self, config):
        """Return True if not equal to the other Config."""
        LOGGER.log()
        return not self.__eq__(config)
    
    def to_dict(self):
        """Return a dictionary representing this object."""
        LOGGER.log()
        return {
            'current_configset_name': self.current_configset_name,
            'current_op_name': self.current_op_name,
            'configsets': [item.to_dict() for item in self.configsets],
            'ops': [item.to_dict() for item in self.ops],
            'languages': self.languages,
            'is_set_by_language': self.is_set_by_language,
            'window_width': self.window_width,
            'window_height_short': self.window_height_short,
            'window_height_tall': self.window_height_tall,
            }
    
    def from_dict(self, dictionary):
        """Read from a dictionary representing this object."""
        LOGGER.log()
        self.current_configset_name = dictionary['current_configset_name']
        self.current_op_name = dictionary['current_op_name']
        self.configsets = \
            [ConfigSet(dict_) for dict_ in dictionary['configsets']]
        self.ops = \
            [SelectionOp(dict_) for dict_ in dictionary['ops']]
        # The following are conditional because they would not be in
        # Click_Config a config file from before version 1.1.
        if 'languages' in dictionary:
            self.languages = dictionary['languages']
        if 'is_set_by_language' in dictionary:
            self.is_set_by_language = dictionary['is_set_by_language']
        if 'window_width' in dictionary:
            self.window_width = dictionary['window_width']
        if 'window_height_short' in dictionary:
            self.window_height_short = dictionary['window_height_short']
        if 'window_height_tall' in dictionary:
            self.window_height_tall = dictionary['window_height_tall']
    
    def partial_from_dict(self, dictionary):
        """Read from a dictionary representing this object."""
        LOGGER.log()
        if 'configsets' in dictionary:
            for dict_ in dictionary['configsets']:
                configset = ConfigSet(dict_)
                self.add_configset(configset)
        if 'ops' in dictionary:
            for dict_ in dictionary['ops']:
                op = SelectionOp(dict_)
                self.add_op(op)
#        if 'languages' in dictionary:
#            self.languages.update(dictionary['languages'])
    
    def check_language_configsets(self):
        """
        If any languages are assigned to a non-existent ConfigSet, assign them
        to the default ConfigSet.
        """
        LOGGER.log()
        default_configset_name = 'Click_Config default'
        # Make sure we have all of the languages.
        for language in self._plugin._get_languages():
            if language not in self.languages:
                self.languages[language] = default_configset_name
        # Make sure each langauge is assigned to an existing ConfigSet.
        configset_names = self.get_configset_names()
        for language in self.languages:
            configset_name = self.languages[language]
            if configset_name not in configset_names:
                self.languages[language] = default_configset_name
    
    # ConfigSet access
    
    def add_configset(self, configset):
        """Add a ConfigSet to the configsets."""
        LOGGER.log()
        configset_name = configset.name
        configset_names = [item.name for item in self.configsets]
        if configset_name in configset_names:
            index = configset_names.index(configset_name)
            self.configsets[index] = configset
        else:
            self.configsets.append(configset)
    
    def remove_configset(self, configset):
        """Remove a ConfigSet from the configsets."""
        LOGGER.log()
        self.configsets.remove(configset)
    
    def get_configset(self, configset_name=None):
        """
        Return the ConfigSet with this name,
        or return the current ConfigSet if no name is given.
        """
        LOGGER.log()
        configset_name = configset_name or self.current_configset_name
        for item in self.configsets:
            if item.name == configset_name:
                configset = item
                break
        return configset
    
    def set_configset(self, configset=None, configset_name=None):
        """
        Add the ConfigSet if provided as an object.
        Set the ConfigSet name as current.
        Required argument:
                configset
            or  configset_name
        """
        LOGGER.log()
        if configset:
            self.add_configset(configset)
            configset_name = configset.name
        self.current_configset_name = configset_name
    
    def get_configset_names(self):
        """Return a list of the ConfigSet names."""
        LOGGER.log()
        configset_names = [item.name for item in self.configsets]
        configset_names = configset_names[0:2] + sorted(configset_names[2:])
        return configset_names
    
    # SelectionOp access
    
    def add_op(self, op):
        """Add a SelectionOp to the ops."""
        LOGGER.log()
        op_name = op.name
        op_names = [item.name for item in self.ops]
        if op_name in op_names:
            index = op_names.index(op_name)
            self.ops[index] = op
        else:
            self.ops.append(op)
    
    def remove_op(self, op_or_op_name):
        """Remove a SelectionOp from the ops."""
        LOGGER.log()
        if isinstance(op_or_op_name, str):
            op_name = op_or_op_name
            op = self.get_op(op_name=op_name)
        else:
            op = op_or_op_name
        self.ops.remove(op)
    
    def get_op(self,
        op_name=None,
        click=None,
        configset_name=None,
        configset=None
        ):
        """
        Return the SelectionOp associated with given criteria.
        Arguments can be: op_name
                      or  configset and click
                      or  configset_name and click
                      or  click (will use current ConfigSet)
        Otherwise, returns the current SelectionOp (of the Define section).
        """
        LOGGER.log()
        if not op_name:
            if click:
                configset = (configset or
                            self.get_configset(configset_name))
                op_name = configset.op_names[click - 1]
            else:
                op_name = self.current_op_name
        for op in self.ops:
            if op.name == op_name:
                return op
    
    def set_op(self,
        op=None,
        op_name=None,
        click=None,
        configset_name=None,
        configset=None
        ):
        """
        Set the SelectionOp associated with given criteria.
        Required argument:
                op
            or  op_name
        Optional arguments:
                configset and click
            or  configset_name and click
            or  click (will use current ConfigSet)
        Otherwise, sets the current SelectionOp (of the Define section).
        """
        LOGGER.log()
        if op:
            self.add_op(op)
            op_name = op.name
        if click:
            configset = (configset or
                        self.get_configset(configset_name))
            index = self.configsets.index(configset)
            self.configsets[index].op_names[click - 1] = op_name
        else:
            self.current_op_name = op_name
    
    def get_op_names(self):
        """Return a list of the SelectionOp names."""
        LOGGER.log()
        op_names = [op.name for op in self.ops]
        op_names = op_names[0:1] + sorted(op_names[1:])
        return op_names
    
    # SelectionOp attribute access
    
    def get_pattern(self,
        op=None,
        op_name=None,
        click=None,
        configset_name=None,
        configset=None
        ):
        """
        Return the regex pattern associated with given criteria.
        Optional arguments:
                op
            or  op_name
            or  configset and click
            or  configset_name and click
            or  click (will use current ConfigSet)
        Otherwise, returns pattern from the current op (of the Define section).
        """
        LOGGER.log()
        op = op or self.get_op(op_name, click, configset_name, configset)
        pattern = op.pattern
        return pattern
    
    def get_flags(self,
        op=None,
        op_name=None,
        click=None,
        configset_name=None,
        configset=None
        ):
        """
        Return the regex flags associated with given criteria.
        Optional arguments:
                op
            or  op_name
            or  configset and click
            or  configset_name and click
            or  click (will use current ConfigSet)
        Otherwise, returns flags from the current op (of the Define section).
        """
        LOGGER.log()
        op = op or self.get_op(op_name, click, configset_name, configset)
        flags = op.flags
        return flags
    
    def set_pattern(self,
        pattern,
        op=None,
        op_name=None,
        click=None,
        configset_name=None,
        configset=None
        ):
        """
        Sets the regex pattern for the given criteria.
        Required argument:
                pattern
        Optional arguments:
                op
            or  op_name
            or  configset and click
            or  configset_name and click
            or  click (will use current ConfigSet)
        Otherwise, sets the pattern for the current op (of the Define section).
        """
        LOGGER.log()
        op = op or self.get_op(op_name, click, configset_name, configset)
        index = self.ops.index(op)
        self.ops[index].pattern = pattern
    
    def set_flags(self,
        flags,
        op=None,
        op_name=None,
        click=None,
        configset_name=None,
        configset=None
        ):
        """
        Sets the regex flags for the given criteria.
        Required argument:
                flags
        Optional arguments:
                op
            or  op_name
            or  configset and click
            or  configset_name and click
            or  click (will use current ConfigSet)
        Otherwise, sets the flags for the current op (of the Define section).
        """
        LOGGER.log()
        op = op or self.get_op(op_name, click, configset_name, configset)
        index = self.ops.index(op)
        self.ops[index].flags = flags
    
    # File access
    
    def load(self):
        """Load the configuration."""
        LOGGER.log()
        config_dict = read_dict_from_file(self.filename)
        self.from_dict(config_dict)
    
    def save(self):
        """Save the configuration."""
        LOGGER.log()
        config_dict = self.to_dict()
        if os.path.exists(self.filename):
            shutil.copy2(self.filename, self.filename + '~')
        write_dict_to_file(config_dict, self.filename)
    
    def import_file(self, filename):
        """Import from a configuration file."""
        LOGGER.log()
        config_dict = read_dict_from_file(filename)
        self.partial_from_dict(config_dict)
    


########NEW FILE########
__FILENAME__ = dictfile
# -*- coding: utf8 -*-
#  Click_Config plugin for Gedit
#
#  Copyright (C) 2010 Derek Veit
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module provides functions for writing and reading Python dictionaries as
text files, formatted for readability.

Usage:
from dictfile import write_dict_to_file, read_dict_from_file
dictionary = {...}
filename = '/path/to/new/file'
write_dict_to_file(dictionary, filename)
dictionary = read_dict_from_file(filename)

"""

def write_dict_to_file(dictionary, filename):
    """Write a dictionary to a text file."""
    file_handle = open(filename, 'w')
    dict_string = format_dict(dictionary)
    file_handle.writelines(dict_string)
    file_handle.close()

def format_dict(dictionary, level=0):
    """Format a dictionary as a readable multiline string."""
    brace_indent = '    ' * level
    level += 1
    item_indent = '    ' * level
    string = '{\n'
    for key in sorted(dictionary.keys()):
        value = dictionary[key]
        string += item_indent + repr(key) + ': ' + format_value(value, level)
    string += brace_indent + '}'
    return string

def format_list(list_, level=0):
    """Format a list as a readable multiline string."""
    brace_indent = '    ' * level
    level += 1
    item_indent = '    ' * level
    string = '[\n'
    for value in list_:
        string += item_indent + format_value(value, level)
    string += brace_indent + ']'
    return string

def format_value(value, level):
    """Format a value for readability as dict, list, or other type."""
    if isinstance(value, dict):
        string = format_dict(value, level)
    elif isinstance(value, list):
        string = format_list(value, level)
    else:
        string = repr(value)
    return string + ',\n'

def read_dict_from_file(filename):
    """Read a text file as a dictionary."""
    file_handle = open(filename, 'r')
    dict_string = file_handle.read().strip()
    file_handle.close()
    if dict_string.startswith('{') and dict_string.endswith('}'):
        dictionary = eval(dict_string)
    else:
        raise TypeError(
            'File does not contain a Python dictionary representation.')
        dictionary = None
    return dictionary


########NEW FILE########
__FILENAME__ = logger
#!/usr/bin/env python
# -*- coding: utf8 -*-
#
#  logger module
#
#  Copyright (C) 2010 Derek Veit
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
2010-06-18

This just wraps some of the standard logging module functionality for
the way I like to use it.

All messages are just sent to stdout, but it can be modified otherwise.
See http://docs.python.org/library/logging.html#useful-handlers
"""

DEFAULT_LOGGING_LEVEL = ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')[0]

import datetime
import logging
import os
import sys

class Logger(object):
    """
    This class provides a log function.
    
    Usage in any given module:
        from logger import Logger
        LOGGER = Logger()
        
        LOGGER.log()
        LOGGER.log('Log this message')
        LOGGER.log('Log this message', level='error')
        LOGGER.log(var='var_name')
    
    """
    
    def __init__(self, level=DEFAULT_LOGGING_LEVEL):
        """Set up logging (to stdout)."""
        filename = sys._getframe(1).f_code.co_filename
        timestamp = str(datetime.datetime.now())
        logger_id = filename + timestamp
        self.logger = logging.getLogger(logger_id)
        handler = logging.StreamHandler(sys.stdout)
        log_format = "%(levelname)s - %(message)s"
        #log_format = "%(asctime)s - %(levelname)s - %(message)s"
        formatter = logging.Formatter(log_format)
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        logging_level = getattr(logging, level)
        self.logger.setLevel(logging_level)
        self.log(('Logging started for %s' % filename).ljust(72, '-'))
    
    def log(self, message=None, level='info', var=None):
        """Log the message or log the calling function."""
        if message:
            logger = {'debug': self.logger.debug,
                      'info': self.logger.info,
                      'warning': self.logger.warning,
                      'error': self.logger.error,
                      'critical': self.logger.critical}[level]
            logger(message)
        elif var:
            self.logger.debug('%s: %r' % (var, sys._getframe(1).f_locals[var]))
        else:
            self.logger.debug(whoami())

def whoami():
    """Identify the calling function for logging."""
    filename = os.path.basename(sys._getframe(2).f_code.co_filename)
    line = sys._getframe(2).f_lineno
    if 'self' in sys._getframe(2).f_locals:
        class_name = sys._getframe(2).f_locals['self'].__class__.__name__
    else:
        class_name = '(No class)'
    function_name = sys._getframe(2).f_code.co_name
    return '%s Line %s %s.%s' % (filename, line, class_name, function_name)

def test():
    """Execute logger.py at the command line to run this self test."""
    test_var = [1, 'a']
    for logger_level in ('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'):
        print('\nTesting for level: %s' % logger_level)
        LOGGER = Logger(level=logger_level)
        LOGGER.log('Log this message')
        LOGGER.log(var='test_var')
        LOGGER.log()
        for level in ('debug', 'info', 'warning', 'error', 'critical'):
            LOGGER.log('Log this %s message' % level, level=level)

if __name__ == '__main__':
    test()


########NEW FILE########
__FILENAME__ = treeviewdv
# -*- coding: utf8 -*-
#  TreeViewDV
#
#  Copyright (C) 2010 Derek Veit
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module provides a subclass of a GTK TreeView with improved behavior for
drag-and-drop of multiple selections.

Problem:    When multiple rows are selected in a TreeView and a row is clicked
            (without the Shift key) to start dragging them, the row clicked is
            selected individually and the rest of the selection is deselected.
            The multiple selection can sometimes be dragged by holding down the
            Shift key while dragging, but the results are unpredictable in many
            cases because clicking with the Shift will still cause a select
            action.  And dragging a multiple-row selection that has a
            non-continuous set of rows, i.e. a selection made using the Control
            key, is not even possible because of this.

Solution:   Make selection happen on button releases instead of button presses,
            and if the mouse has moved while the button is pressed, allow for
            dragging (for drag-and-drop) or rubberbanding (drag selecting)
            depending on whether the clicked row is already selected.
            1.  Use TreeSelection.set_select_function() to make the select
                action subject to a boolean instance attribute, 'selectable'.
            2.  Connect a handler to the TreeView's button-press-event signal.
            3.  If a (left) button-press-event happens, use the 'selectable'
                    attribute to prevent the default selection action, connect
                    a handler to the button-release-event signal, and...
                a.  If the clicked row is selected, connect a handler to the
                    drag-begin signal.
                b.  If the clicked row is not selected, connect a handler to
                    the motion-notify-event signal.
            4.  If a button-release-event happens, normal selecting is
                intended, so re-enable normal selecting, disconnect any event
                handlers and select rows as appropriate for the click.
            5.  If a drag-begin happens, the unwanted selecting has been
                avoided, so re-enable normal selecting and disconnect any
                event handlers.
            6.  If a motion-notify-event happens, rubberbanding may start, so
                re-enable normal selecting and disconnect any event handlers.

Additionally, in a drag-and-drop, gtk.TreeView only shows a drag icon
representing the clicked row, even if the selection is of multiple rows.  This
subclass replaces the default single-row drag icon with a multiple-row icon.

Classes:
TreeViewDV -- This can be used in place of a gtk.TreeView.

"""

import logging
import os
import sys

import gtk

class TreeViewDV(gtk.TreeView):
    
    """
    This can be used in place of a gtk.TreeView.
    
    Usage:
        from treeviewdv import TreeViewDV
        treeview = TreeViewDV()
      or
        treeview = TreeViewDV(model)
    
    """
    
    def __init__(self, model=None):
        """
        """
        gtk.TreeView.__init__(self, model)
        
        instance_id = repr(self)
        self.logger = logging.getLogger('Logger of ' + instance_id)
        handler = logging.StreamHandler(sys.stdout)
        log_format = "%(levelname)s - %(message)s"
        #log_format = "%(asctime)s - %(levelname)s - %(message)s"
        formatter = logging.Formatter(log_format)
        handler.setFormatter(formatter)
        self.logger.addHandler(handler)
        self.logger.setLevel(logging.WARNING)
        self.log('TreeViewDV logging started. '.ljust(72, '-'))
        self.log(self.logger.name)
        self.log()

        self.selectable = True
        """If False, GTK will not select rows in response to clicks."""
        
        self.anchor_path = None
        """Identifies the row at the start of a multiple-row selection."""
        
        self.button_release_handlerid = None
        """The handler id for the button-release-event handler."""
        
        self.drag_begin_handlerid = None
        """The handler id for the drag-begin handler."""
        
        self.motion_notify_handlerid = None
        """The handler id for the motion-notify-event handler."""
        
        self.press_x = 0
        """Pointer x location (in tree coordinates) at button press."""
        
        self.press_y = 0
        """Pointer y location (in tree coordinates) at button press."""
        
        treeselection = self.get_selection()
        treeselection.set_select_function(lambda info: self.selectable)
        
        self.connect('button-press-event', self.on_button_press)
        
        self.connect_after('drag-begin', self.after_drag_begin)
    
    # Event handlers
    
    def on_button_press(self, widget, event):
        """
        1.  If the Shift key is not pressed, set the anchor for any future
            multiple-row selections with the Shift key.
        2.  Allow either for dragging or for rubberbanding.
        """
        self.log()
        if event.button == 1:
            path = self._get_path_of_event(event)
            if not path:
                return
            # 1. Set the anchor for future multiple-row selections.
            state = event.get_state()
            with_shift = state & gtk.gdk.SHIFT_MASK
            if not with_shift:
                self.anchor_path = path
            # 2. Allow either for dragging or for rubberbanding.
            treeselection = self.get_selection()
            is_selected = treeselection.path_is_selected(path)
            self._disable_gtk_selecting()
            if is_selected:
                self._set_press_coords(event)
                self._prepare_for_dragging()
            else:
                self._prepare_for_rubberbanding()
    
    def _set_press_coords(self, event):
        widget_x, widget_y = event.get_coords()
        self.press_x, self.press_y = \
            self.convert_widget_to_tree_coords(int(widget_x), int(widget_y))
    
    def on_button_release(self, widget, event):
        """Allow normal GTK selecting and make the selection for the click."""
        self.log()
        self._enable_gtk_selecting()
        self._select_with_event(event)
    
    def on_drag_begin(self, widget, drag_context):
        """Allow normal GTK selecting again after this drag."""
        self.log()
        self._enable_gtk_selecting()
    
    def after_drag_begin(self, widget, drag_context):
        """Allow normal GTK selecting again after this drag."""
        self.log()
        self._set_drag_icon(drag_context)
    
    def _set_drag_icon(self, drag_context):
        self.log()
        treeselection = self.get_selection()
        if not treeselection.count_selected_rows():
            return
        pixmap = self._create_rows_drag_icon()
        width, height = pixmap.get_size()
        hot_x, hot_y = self.press_x, self.press_y
        pixbuf = gtk.gdk.Pixbuf(
            colorspace=gtk.gdk.COLORSPACE_RGB,
            has_alpha=False,
            bits_per_sample=8,
            width=width,
            height=height)
        pixbuf.get_from_drawable(
            src=pixmap,
            cmap=pixmap.get_colormap(),
            src_x=0,
            src_y=0,
            dest_x=0,
            dest_y=0,
            width=width,
            height=height)
        pixbuf = pixbuf.add_alpha(
            substitute_color=True,
            r=chr(1),
            g=chr(1),
            b=chr(1))
        drag_context.set_icon_pixbuf(pixbuf=pixbuf, hot_x=hot_x, hot_y=hot_y)
    
    def on_motion_notify(self, widget, event):
        """Allow normal GTK selecting again after this drag."""
        self.log()
        self._enable_gtk_selecting()
        self._select_with_event(event)
    
    # Event handler control methods (modes)
    
    def _enable_gtk_selecting(self):
        self.log()
        """Allow normal GTK selecting."""
        if self.button_release_handlerid:
            self.disconnect(self.button_release_handlerid)
            self.button_release_handlerid = None
        if self.drag_begin_handlerid:
            self.disconnect(self.drag_begin_handlerid)
            self.drag_begin_handlerid = None
        if self.motion_notify_handlerid:
            self.disconnect(self.motion_notify_handlerid)
            self.motion_notify_handlerid = None
        self.selectable = True
    
    def _disable_gtk_selecting(self):
        """Prevent normal GTK selecting and prepare for button release."""
        self.log()
        if not self.button_release_handlerid:
            self.button_release_handlerid = self.connect(
                'button-release-event', self.on_button_release)
        self.selectable = False
    
    def _prepare_for_dragging(self):
        """Allow for dragging of multiple-row selections."""
        self.log()
        if not self.drag_begin_handlerid:
            self.drag_begin_handlerid = self.connect(
                'drag-begin', self.on_drag_begin)
    
    def _prepare_for_rubberbanding(self):
        """Allow for dragging of multiple-row selections."""
        self.log()
        if not self.motion_notify_handlerid:
            self.motion_notify_handlerid = self.connect(
                'motion-notify-event', self.on_motion_notify)
    
    # Selection methods
    
    def _get_path_of_event(self, event):
        """Return the path (row) where the event (mouse click) occurred."""
        x, y = event.get_coords()
        path_etc = self.get_path_at_pos(int(x), int(y))
        if path_etc:
            path = path_etc[0]
            return path
    
    def _select_with_event(self, event):
        """Select and deselect rows based on the click event."""
        self.log()
        treeselection = self.get_selection()
        path = self._get_path_of_event(event)
        if not path:
            return
        is_selected = treeselection.path_is_selected(path)
        state = event.get_state()
        with_shift = state & gtk.gdk.SHIFT_MASK
        with_control = state & gtk.gdk.CONTROL_MASK
        if with_control:
            if with_shift:
                treeselection.select_range(self.anchor_path, path)
            else:
                if is_selected:
                    treeselection.unselect_path(path)
                else:
                    treeselection.select_path(path)
        else:
            if with_shift:
                treeselection.unselect_all()
                treeselection.select_range(self.anchor_path, path)
            else:
                treeselection.unselect_all()
                treeselection.select_path(path)
    
    # Miscellaneous methods
    
    def log(self, message=None, level='debug'):
        """Log the message or log the calling function."""
        if message:
            logger = {'debug': self.logger.debug,
                      'info': self.logger.info,
                      'warning': self.logger.warning,
                      'error': self.logger.error,
                      'critical': self.logger.critical}[level]
            logger(message)
        else:
            self.logger.debug(self._whoami())
    
    def _whoami(self):
        """Identify the calling function for logging."""
        filename = os.path.basename(sys._getframe(2).f_code.co_filename)
        line = sys._getframe(2).f_lineno
        class_name = sys._getframe(2).f_locals['self'].__class__.__name__
        function_name = sys._getframe(2).f_code.co_name
        return '%s Line %s %s.%s' % (filename, line, class_name, function_name)
    
    def _create_rows_drag_icon(self):
        """Create a multiple-row drag icon."""
        self.log()
        treeselection = self.get_selection()
        paths = [row[0] for row in treeselection.get_selected_rows()[1]]
        row_pixmaps = [self.create_row_drag_icon(path)
                       for path in paths]
        first_pixmap = row_pixmaps[0]
        row_width, row_height = first_pixmap.get_size()
        width = row_width
        height = (self._get_row_y(paths[-1]) -
                  self._get_row_y(paths[0]) +
                  row_height)
        pixmap = gtk.gdk.Pixmap(first_pixmap, width, height)
        pixmap_gc = gtk.gdk.GC(first_pixmap)
        # Clear the new Pixmap before drawing on it:
        pixmap_gc.set_rgb_fg_color(gtk.gdk.Color(256, 256, 256))
        pixmap_gc.set_function(gtk.gdk.COPY)
        pixmap.draw_rectangle(
            gc=pixmap_gc,
            filled=True,
            x=0,
            y=0,
            width=width,
            height=height)
        for index, row_pixmap in enumerate(row_pixmaps):
            # Copy the row icon onto the full image
            ydest = self._get_row_y(paths[index]) - self._get_row_y(paths[0])
            pixmap_gc.set_function(gtk.gdk.COPY)
            pixmap.draw_drawable(
                gc=pixmap_gc,
                src=row_pixmap,
                xsrc=0,
                ysrc=0,
                xdest=0,
                ydest=ydest,
                width=row_width,
                height=row_height)
        self.press_y -= self._get_row_y(paths[0])
        return pixmap
    
    def _get_row_y(self, path):
        """Return y tree coordinate of the top of cell at path."""
        column = self.get_column(0)
        cell_area = self.get_cell_area(path, column)
        x, y = self.convert_widget_to_tree_coords(cell_area.x, cell_area.y)
        return y
    
    # Public methods
    
    def remove_from_treeview(treeview, row):
        """Remove the row from the TreeView."""
        treemodel = treeview.get_model()
        treemodel_list = self._get_list_from_liststore(liststore)
        path = liststore_list.index(value)
        iter_ = liststore.get_iter(path)
        liststore.remove(iter_)
        if len(liststore) == 0:
            treeview.set_property('can-focus', False)
    
    def add_to_treeview(treeview, row):
        """Add the row to the TreeView."""
        liststore = treeview.get_model()
        liststore_list = self._get_list_from_liststore(liststore)
        liststore_list.append(value)
        liststore_list.sort()
        path = liststore_list.index(value)
        if path == len(liststore):
            liststore.append([value])
        else:
            iter_ = liststore.get_iter(path)
            liststore.insert_before(iter_, row=[value])
        treeview.set_property('can-focus', True)
    


########NEW FILE########
__FILENAME__ = ui
# -*- coding: utf8 -*-
#  Click_Config plugin for Gedit
#
#  Copyright (C) 2010 Derek Veit
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
This module provides a GUI window for configuring the Click_Config plugin for
Gedit.

The ConfigUI object is constructed with a reference to the ClickConfigPlugin
object through which it accesses the plugin's configuration and logging.

Classes:
ConfigUI -- The Click_Config plugin creates one object of this class when the
            configuration window is opened.  The object removes its own
            reference from the plugin when the configuration window is closed.

In addition to the imported modules, this module requires:
Click_Config.xml -- configuration GUI layout converted from Click_Config.glade

2010-05-26  for Click Config version 1.1.2
    Fixed Issue #4 in ConfigUI._update_config_display.

"""

import os
import re
import sys

import gtk

from treeviewdv import TreeViewDV
from .logger import Logger
LOGGER = Logger(level=('DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL')[2])

class ConfigUI(object):
    
    """
    The configuration window for Click_Config.
    
    Usage:
    config_ui = ConfigUI()
    config_ui.window.show()
    
    See:
    click_config.py ClickConfigPlugin.create_configure_dialog()
    
    """
    
    def __init__(self, plugin):
        """
        1. Create the window.
        2. Make a temporary copy of the configuration.
        3. Update the window's widgets to reflect the configuration.
        4. Connect the event handlers.
        """
        self._plugin = plugin
        LOGGER.log()
        
        # 1. Create the window.
        glade_file = os.path.join(self._plugin.plugin_path, 'Click_Config.xml')
        self.builder = gtk.Builder()
        self.builder.add_from_file(glade_file)
        self.window = self.builder.get_object("config_window")
        gedit_window = self._plugin.get_gedit_window()
        self.window.set_transient_for(gedit_window)
        self.window.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        
        # 2. Make a temporary copy of the configuration.
        self._mod_conf = self._plugin.conf.copy()
        self.preserved_sets = [item.name for item in
            self._mod_conf.configsets if item.preserved]
        self.preserved_ops = [item.name for item in
            self._mod_conf.ops if item.preserved]
        
        # 3. Update the window's widgets to reflect the configuration.
        width = self._mod_conf.window_width
        height = (self._mod_conf.window_height_tall if
                       self._mod_conf.is_set_by_language else
                       self._mod_conf.window_height_short)
        if width and height:
            self.window.set_default_size(width, height)
        self._update_config_combobox()
        self._update_config_display()
        self._update_lang_checkbutton()
        self._update_define_combobox()
        self._update_define_display()
        self._update_language_frame()
        self._update_apply_button()
    
        # 4. Connect the event handlers.
        signals_to_actions = {
            'on_config_window_destroy':
                self.on_config_window_destroy,
            'on_config_combobox_entry_changed':
                self.on_config_combobox_entry_changed,
            'on_comboboxentryentry1_key_press_event':
                self.on_comboboxentryentry1_key_press_event,
            'on_config_add_button_clicked':
                self.on_config_add_button_clicked,
            'on_config_remove_button_clicked':
                self.on_config_remove_button_clicked,
            'on_lang_checkbutton_toggled':
                self.on_lang_checkbutton_toggled,
            'on_combobox_changed':
                self.on_combobox_changed,
            'on_define_comboboxentry_changed':
                self.on_define_comboboxentry_changed,
            'on_define_name_entry_key_press_event':
                self.on_define_entry_key_press_event,
            'on_define_regex_entry_changed':
                self.on_define_changed,
            'on_define_regex_entry_key_press_event':
                self.on_define_entry_key_press_event,
            'on_define_i_checkbutton_toggled':
                self.on_define_changed,
            'on_define_m_checkbutton_toggled':
                self.on_define_changed,
            'on_define_s_checkbutton_toggled':
                self.on_define_changed,
            'on_define_x_checkbutton_toggled':
                self.on_define_changed,
            'on_define_add_button_clicked':
                self.on_define_add_button_clicked,
            'on_define_remove_button_clicked':
                self.on_define_remove_button_clicked,
            'on_OK_button_clicked':
                self.on_OK_button_clicked,
            'on_Apply_button_clicked':
                self.on_Apply_button_clicked,
            'on_Cancel_button_clicked':
                self.on_Cancel_button_clicked,
            'on_Browse_button_clicked':
                self.on_Browse_button_clicked,
            'on_Import_button_clicked':
                self.on_Import_button_clicked,
            }
        self.builder.connect_signals(signals_to_actions)
        self.on_config_window_configure_handler_id = self.window.connect(
            'configure-event',
            self.on_config_window_configure_event)
        
        LOGGER.log('Configuration window opened.')
        
        
    ### 1 - General configure window
    
    # 1.1 - Event handlers
    
    def on_config_window_configure_event(self, widget, event):
        """
        Set configuration window height and sizing constraint.
        This event handler is connected by on_lang_checkbutton_toggled.
        """
        LOGGER.log()
        window = widget
        window.disconnect(self.on_config_window_configure_handler_id)
        width, height = window.get_size()
        if self._mod_conf.is_set_by_language:
            window.set_geometry_hints(height_inc=-1)
            height = self._mod_conf.window_height_tall or height
        else:
            height = self._mod_conf.window_height_short or height
            unlikely_height_inc = height * 100
            window.set_geometry_hints(height_inc=unlikely_height_inc)
        self.window.resize(width, height)
    
    def on_config_window_destroy(self, event):
        """Let the ClickConfigPlugin know that the ConfigUI is gone."""
        LOGGER.log()
        LOGGER.log('Configuration window closed.')
        self._plugin.config_ui = None
        return False
    
    def on_OK_button_clicked(self, button):
        """
        Give the ClickConfigPlugin the modified configuration, then close.
        """
        LOGGER.log()
        width, height = self.window.get_size()
        self._mod_conf.window_width = width
        if self._mod_conf.is_set_by_language:
            self._mod_conf.window_height_tall = height
        else:
            self._mod_conf.window_height_short = height
        self._plugin.update_configuration(self._mod_conf.copy())
        self._plugin.update_ui(self._plugin.get_gedit_window())
        self.window.destroy()
    
    def on_Apply_button_clicked(self, button):
        """Give the ClickConfigPlugin the modified configuration."""
        LOGGER.log()
        self._plugin.update_configuration(self._mod_conf.copy())
        self._update_apply_button()
    
    def on_Cancel_button_clicked(self, button):
        """Close without giving ClickConfigPlugin the modified configuration."""
        LOGGER.log()
        self.window.destroy()
    
    def on_Browse_button_clicked(self, button):
        """Browse to the configuration file."""
        LOGGER.log()
        self._plugin.open_config_dir()
    
    def on_Import_button_clicked(self, button):
        """Import ConfigSets and SelectionOps from another configuration file."""
        LOGGER.log()
        filename = self._filechooser_dialog(
            title='Import from a Click_Config configuration file')
        if filename:
            self._mod_conf.import_file(filename)
        self._update_config_combobox()
        self._update_config_display()
        self._update_define_combobox()
        self._update_define_display()
        self._update_language_frame()
        self._update_apply_button()
    
    # 1.2 - Support functions
    
    def _update_apply_button(self):
        """Correct the Apply button's sensitivity."""
        LOGGER.log()
        apply_button = self.builder.get_object('Apply_button')
        has_changes = self._mod_conf != self._plugin.conf
        LOGGER.log(var='has_changes')
        apply_button.set_sensitive(has_changes)
    
    def _filechooser_dialog(self, title='Open'):
        """
        Provide file selection dialog to user and return the selected filename.
        """
        LOGGER.log()
        dialog = gtk.FileChooserDialog(
            title=title,
            parent=self.window,
            action=gtk.FILE_CHOOSER_ACTION_OPEN,
            buttons=(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL,
                gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        dialog.set_default_response(gtk.RESPONSE_OK)
        file_filter = gtk.FileFilter()
        file_filter.set_name("All files")
        file_filter.add_pattern("*")
        dialog.add_filter(file_filter)
        text_file_filter = gtk.FileFilter()
        text_file_filter.set_name("Text files")
        text_file_filter.add_mime_type("text/plain")
        dialog.add_filter(text_file_filter)
        dialog.set_filter(text_file_filter)
        response = dialog.run()
        if response == gtk.RESPONSE_OK:
            filename = dialog.get_filename()
        else:
            filename = ''
        dialog.destroy()
        return filename
    
    ### 2 - ConfigSet name section
    
    # 2.1 - Event handlers
    
    def on_config_combobox_entry_changed(self, combobox):
        """Update the configuration and interface based on the selection."""
        LOGGER.log()
        # Get objects
        config_combobox_entry = combobox
        config_add_button = self.builder.get_object("config_add_button")
        config_remove_button = self.builder.get_object("config_remove_button")
        # Get circumstance
        config_name = config_combobox_entry.get_active_text().strip()
        is_addable = self._is_config_name_addable(config_name)
        is_removable = self._is_config_name_removable(config_name)
        is_existing = config_name in self._mod_conf.get_configset_names()
        # Update configuration
        if is_existing:
            self._mod_conf.current_configset_name = config_name
        # Update interface
            self._update_config_display()
        config_add_button.set_sensitive(is_addable)
        config_remove_button.set_sensitive(is_removable)
    
    def on_comboboxentryentry1_key_press_event(self, widget, event):
        """React to the Enter key here the same as for the Add button."""
        LOGGER.log()
        keyval = event.keyval
        keyval_name = gtk.gdk.keyval_name(keyval)
        if keyval_name in ('Return', 'KP_Enter'):
            self._add_config()
    
    def on_config_add_button_clicked(self, button):
        """Call function to add the configuration."""
        LOGGER.log()
        self._add_config()

    def on_config_remove_button_clicked(self, button):
        """Call function to remove the configuration."""
        LOGGER.log()
        self._remove_config()
    
    def on_lang_checkbutton_toggled(self, togglebutton):
        """Update is_set_by_language setting and interface."""
        LOGGER.log()
        # Get objects
        lang_checkbutton = togglebutton
        # Get circumstance
        is_checked = lang_checkbutton.get_active()
        # Update configuration
        self._mod_conf.is_set_by_language = is_checked
        width, height = self.window.get_size()
        if is_checked:
            self._mod_conf.window_height_short = height
        else:
            self._mod_conf.window_height_tall = height
        # Update interface
        self._update_language_frame()
        self.on_config_window_configure_handler_id = self.window.connect(
            'configure-event',
            self.on_config_window_configure_event)
    
    # 2.2 - Support functions
    
    def _update_lang_checkbutton(self):
        """Make the 'Configure by language' checkbox match its setting."""
        LOGGER.log()
        # Get objects
        lang_checkbutton = self.builder.get_object("lang_checkbutton")
        # Update interface
        lang_checkbutton.set_active(self._mod_conf.is_set_by_language)
    
    def _update_config_combobox(self):
        """Reflect the ConfigSets and current ConfigSet in the interface."""
        LOGGER.log()
        configset_names = self._mod_conf.get_configset_names()
        combobox_list = configset_names[0:2] + [' - '] + configset_names[2:]
        config_combobox_entry = \
            self.builder.get_object('config_combobox_entry')
        config_combobox_entry.set_row_separator_func(self._row_separator_func)
        self._fill_comboboxentry(config_combobox_entry, combobox_list)
        index = combobox_list.index(self._mod_conf.current_configset_name)
        config_combobox_entry.set_active(index)
        config_add_button = self.builder.get_object('config_add_button')
        config_add_button.set_sensitive(False)
    
    def _fill_comboboxentry(self, comboboxentry, items):
        """Put a list of the ConfigSet names in the combobox."""
        LOGGER.log()
        comboboxentry_liststore = gtk.ListStore(str, str)
        for item in items:
            comboboxentry_liststore.append(['', item])
        comboboxentry.set_model(comboboxentry_liststore)
        comboboxentry.set_text_column(1)
        #GtkWarning: gtk_combo_box_entry_set_text_column: assertion
        # `entry_box->priv->text_column == -1' failed
    
    def _row_separator_func(self, model, iter_):
        """Identify what item represents a separator."""
        LOGGER.log()
        row_is_a_separator = model.get_value(iter_, 1) == ' - '
        return row_is_a_separator

    def _get_configset_names(self):
        """Return a list of the ConfigSet names."""
        LOGGER.log()
        configset_names = [item.name for item in self._mod_conf.configsets]
        configset_names = configset_names[0:2] + sorted(configset_names[2:])
        return configset_names
    
    def _add_config(self):
        """Add the configuration."""
        LOGGER.log()
        # Get objects
        config_combobox_entry = \
            self.builder.get_object("config_combobox_entry")
        # Get circumstance
        config_name = config_combobox_entry.get_active_text().strip()
        is_addable = self._is_config_name_addable(config_name)
        # Update configuration
        if is_addable:
            new_configset = self._mod_conf.get_configset().copy_as(config_name)
            self._mod_conf.add_configset(new_configset)
            self._mod_conf.current_configset_name = config_name
        # Update interface
            self._update_config_combobox()
            self._update_config_display()
            self._update_language_frame()
            LOGGER.log('ConfigSet added: %s.' % config_name)
    
    def _remove_config(self):
        """Remove the configuration."""
        LOGGER.log()
        # Get objects
        config_combobox_entry = \
            self.builder.get_object("config_combobox_entry")
        # Get circumstance
        config_name = config_combobox_entry.get_active_text().strip()
        config_names = self._mod_conf.get_configset_names()
        is_removable = self._is_config_name_removable(config_name)
        # Update configuration
        if is_removable:
            # Switch to preceding config set
            config_name_index = config_names.index(config_name)
            preceding_config_name = config_names[config_name_index - 1]
            self._mod_conf.current_configset_name = preceding_config_name
            # Remove the config set
            old_configset = self._mod_conf.get_configset(config_name)
            self._mod_conf.remove_configset(old_configset)
            self._mod_conf.check_language_configsets()
        # Update interface
            self._update_config_combobox()
            self._update_config_display()
            self._update_language_frame()
            LOGGER.log('ConfigSet removed: %s.' % config_name)
    
    def _is_config_name_addable(self, config_name):
        """Check if ConfigSet of this name can be added."""
        LOGGER.log()
        return config_name not in self._mod_conf.get_configset_names()
    
    def _is_config_name_removable(self, config_name):
        """Check if ConfigSet of this name can be removed."""
        LOGGER.log()
        return (config_name in self._mod_conf.get_configset_names() and
                     config_name not in self.preserved_sets)
    
    ### 3 - ConfigSet settings section
    
    # 3.1 - Event handlers
    
    def on_combobox_changed(self, combobox):
        """
        Update the configuration and interface to reflect the SelectionOp name.
        """
        LOGGER.log()
        # Get objects
        config_combobox_entry = \
            self.builder.get_object("config_combobox_entry")
        # Get circumstance
        op_name = combobox.get_active_text()
        click_number = combobox.get_name()[8:]
        click = int(click_number)
        entry_config_name = config_combobox_entry.get_active_text().strip()
        # Update configuration
        self._mod_conf.set_op(op_name=op_name, click=click)
        # Update interface
        self._set_combobox_op(combobox, op_name)
        self._update_apply_button()
        # Make sure a typed-but-not-added config name isn't showing
        if entry_config_name != self._mod_conf.current_configset_name:
            self._update_config_combobox()
    
    # 3.2 - Support functions
    
    def _fill_combobox(self, combobox, items):
        """Put a list of the SelectionOp names in the combobox."""
        LOGGER.log()
        combobox_liststore = gtk.ListStore(str)
        for item in items:
            combobox_liststore.append([item])
        combobox.set_model(combobox_liststore)
    
    def _update_config_display(self):
        """
        Reflect the five SelectionOps of the current ConfigSet in the widgets.
        """
        LOGGER.log()
        op_names = self._mod_conf.get_op_names()
        for click in range(1, 6):
            combobox = self.builder.get_object('combobox%d' % click)
            # As of GTK+ 2.20, the widget name does not automatically equal the
            # widget id, so I have to set it here to let it work as before.
            combobox.set_name('combobox%d' % click)
            self._fill_combobox(combobox, op_names)
            op_name = self._mod_conf.get_op(click=click).name
            self._set_combobox_op(combobox, op_name)
        self._update_apply_button()

    def _set_combobox_op(self, combobox, op_name):
        """Reflect the SelectionOp in the widgets for the click."""
        LOGGER.log()
        # Get objects
        objects = {}
        objects['combobox'] = combobox
        combobox_name = objects['combobox'].get_name()
        click_number = combobox_name[8:]
        entry_name = "entry" + click_number
        objects['entry'] = self.builder.get_object(entry_name)
        objects['i'] = self.builder.get_object('i_checkbutton' + click_number)
        objects['m'] = self.builder.get_object('m_checkbutton' + click_number)
        objects['s'] = self.builder.get_object('s_checkbutton' + click_number)
        objects['x'] = self.builder.get_object('x_checkbutton' + click_number)
        # Get circumstance
        op_names = self._mod_conf.get_op_names()
        is_editable = not self._mod_conf.get_configset().preserved
        op = self._mod_conf.get_op(op_name=op_name)
        pattern = op.pattern
        flags = op.flags
        index = op_names.index(op_name)
        # Update interface
        objects['combobox'].set_active(index)
        objects['combobox'].set_sensitive(is_editable)
        objects['entry'].set_text(pattern)
        objects['entry'].set_sensitive(False)
        objects['i'].set_active(flags & re.I)
        objects['m'].set_active(flags & re.M)
        objects['s'].set_active(flags & re.S)
        objects['x'].set_active(flags & re.X)
        objects['i'].set_sensitive(False)
        objects['m'].set_sensitive(False)
        objects['s'].set_sensitive(False)
        objects['x'].set_sensitive(False)
        
    ### 4 - Define section
    
    # 4.1 - Event handlers
    
    def on_define_comboboxentry_changed(self, combobox):
        """Update the configuration and interface for the SelectionOp name."""
        LOGGER.log()
        op_name = combobox.get_active_text().strip()
        op_names = self._mod_conf.get_op_names()
        if op_name in op_names:
            self._mod_conf.current_op_name = op_name
            self._update_apply_button()
        self._update_define_display()
    
    def on_define_changed(self, editable):
        """Call function to update the Add button."""
        LOGGER.log()
        self._update_define_add_button()
    
    def on_define_entry_key_press_event(self, widget, event):
        """React to the Enter key here the same as for the Add button."""
        LOGGER.log()
        keyval = event.keyval
        keyval_name = gtk.gdk.keyval_name(keyval)
        if keyval_name in ('Return', 'KP_Enter'):
            self._add_define()
    
    def on_define_add_button_clicked(self, button):
        """Call function to update the SelectionOp for the changed pattern."""
        LOGGER.log()
        self._add_define()
    
    def on_define_remove_button_clicked(self, button):
        """Call function to remove the current SelectionOp."""
        LOGGER.log()
        self._remove_define()
    
    # 4.2 - Support functions
    
    def _update_define_combobox(self):
        """Reflect the SelectionOps and current SelectionOp in the combobox."""
        LOGGER.log()
        define_comboboxentry = self.builder.get_object('define_comboboxentry')
        op_names = self._mod_conf.get_op_names()
        self._fill_comboboxentry(define_comboboxentry, op_names)
        op_name = self._mod_conf.current_op_name
        index = op_names.index(op_name)
        define_comboboxentry.set_active(index)
    
    def _update_define_display(self):
        """Reflect the current SelectionOp in the interface."""
        LOGGER.log()
        # Get objects
        objects = {}
        objects['combobox'] = self.builder.get_object('define_comboboxentry')
        objects['pattern'] = self.builder.get_object('define_regex_entry')
        objects['i'] = self.builder.get_object('define_i_checkbutton')
        objects['m'] = self.builder.get_object('define_m_checkbutton')
        objects['s'] = self.builder.get_object('define_s_checkbutton')
        objects['x'] = self.builder.get_object('define_x_checkbutton')
        objects['add'] = self.builder.get_object("define_add_button")
        objects['remove'] = self.builder.get_object("define_remove_button")
        # Get circumstance
        op_name = objects['combobox'].get_active_text().strip()
        op_names = self._mod_conf.get_op_names()
        is_existing_name = op_name in op_names
        is_preserved_op = op_name in self.preserved_ops
        is_editable = not is_preserved_op
        is_addable = not is_existing_name
        is_removable = is_existing_name and not is_preserved_op
        # Update interface
        if is_existing_name:
            op = self._mod_conf.get_op(op_name=op_name)
            objects['pattern'].set_text(op.pattern)
            objects['i'].set_active(op.flags & re.I)
            objects['m'].set_active(op.flags & re.M)
            objects['s'].set_active(op.flags & re.S)
            objects['x'].set_active(op.flags & re.X)
        objects['pattern'].set_sensitive(is_editable)
        objects['i'].set_sensitive(is_editable)
        objects['m'].set_sensitive(is_editable)
        objects['s'].set_sensitive(is_editable)
        objects['x'].set_sensitive(is_editable)
        objects['add'].set_sensitive(is_addable)
        objects['remove'].set_sensitive(is_removable)
    
    def _update_define_add_button(self):
        """Correct the Add button's sensitivity for the pattern and flags."""
        LOGGER.log()
        # Get objects
        objects = {}
        objects['combobox'] = self.builder.get_object('define_comboboxentry')
        objects['pattern'] = self.builder.get_object('define_regex_entry')
        objects['i'] = self.builder.get_object('define_i_checkbutton')
        objects['m'] = self.builder.get_object('define_m_checkbutton')
        objects['s'] = self.builder.get_object('define_s_checkbutton')
        objects['x'] = self.builder.get_object('define_x_checkbutton')
        objects['add'] = self.builder.get_object("define_add_button")
        # Get circumstance
        op_name = objects['combobox'].get_active_text().strip()
        pattern = objects['pattern'].get_text()
        flags = (objects['i'].get_active() * re.I +
                 objects['m'].get_active() * re.M +
                 objects['s'].get_active() * re.S +
                 objects['x'].get_active() * re.X)
        current_op = self._mod_conf.get_op()
        op_names = self._mod_conf.get_op_names()
        has_new_op_name = op_name not in op_names
        has_new_pattern = pattern != current_op.pattern
        has_new_flags = flags != current_op.flags
        has_changes = (has_new_op_name or 
                       has_new_pattern or
                       has_new_flags)
        is_preserved_op = op_name in self.preserved_ops
        # Update interface
        objects['add'].set_sensitive(has_changes and not is_preserved_op)
    
    def _add_define(self):
        """Add or update the SelectionOp."""
        LOGGER.log()
        # Get objects
        objects = {}
        objects['combobox'] = self.builder.get_object('define_comboboxentry')
        objects['pattern'] = self.builder.get_object('define_regex_entry')
        objects['i'] = self.builder.get_object('define_i_checkbutton')
        objects['m'] = self.builder.get_object('define_m_checkbutton')
        objects['s'] = self.builder.get_object('define_s_checkbutton')
        objects['x'] = self.builder.get_object('define_x_checkbutton')
        # Get circumstance
        op_name = objects['combobox'].get_active_text().strip()
        is_preserved_op = op_name in self.preserved_ops
        pattern = objects['pattern'].get_text()
        flags = (objects['i'].get_active() * re.I +
                 objects['m'].get_active() * re.M +
                 objects['s'].get_active() * re.S +
                 objects['x'].get_active() * re.X)
        is_valid_re = self._is_valid_re(pattern, flags)
        # Record new definition
        if is_valid_re and not is_preserved_op:
            new_op = self._mod_conf.get_op().copy_as(op_name)
            new_op.pattern = pattern
            new_op.flags = flags
            self._mod_conf.add_op(new_op)
            self._mod_conf.current_op_name = op_name
        # Update interface
            self._update_config_display()
            self._update_define_combobox()
            LOGGER.log('SelectionOp added: %s.' % op_name)
    
    def _is_valid_re(self, pattern, flags):
        """
        Check the validity of the regular expression and
        inform the user if it fails.
        """
        LOGGER.log()
        try:
            is_valid = bool(re.compile(pattern, flags))
        except re.error, re_error:
            is_valid = False
            title = "Click_Config: error in input"
            flag_text =  '\n    I (IGNORECASE)' * bool(flags & re.I)
            flag_text += '\n    M (MULTILINE)'  * bool(flags & re.M)
            flag_text += '\n    S (DOTALL)'     * bool(flags & re.S)
            flag_text += '\n    X (VERBOSE)'    * bool(flags & re.X)
            flag_text = flag_text or '\n    (None)'
            message = ("Invalid regular expression pattern."
                       "\n\nError:\n    %s"
                       "\n\nPattern:\n    %s"
                       "\n\nFlags:%s"
                       % (re_error.message, pattern, flag_text))
            self._show_message(title, message, gtk.MESSAGE_ERROR)
        return is_valid
    
    def _show_message(self, title, message, gtk_message_type):
        """Display a simple dialog box with a message and an OK button."""
        LOGGER.log()
        dialog = gtk.MessageDialog(None, gtk.DIALOG_MODAL,
                                   gtk_message_type,
                                   gtk.BUTTONS_OK, message)
        dialog.set_title(title)
        dialog.set_transient_for(self.window)
        dialog.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
        dialog.run()
        dialog.destroy()
    
    def _remove_define(self):
        """Select the preceding SelectionOp and remove the current one."""
        LOGGER.log()
        # Get objects
        combobox = self.builder.get_object("define_comboboxentry")
        # Get circumstance
        op_name = combobox.get_active_text().strip()
        is_preserved_op = op_name in self.preserved_ops
        op_names = self._mod_conf.get_op_names()
        op_index = op_names.index(op_name)
        preceding_op_name = op_names[op_index - 1]
        # Remove definition
        if not is_preserved_op:
            # Remove the select operation from configurations
            for configset in self._mod_conf.configsets:
                for i in range(5):
                    if configset.op_names[i] == op_name:
                        configset.op_names[i] = preceding_op_name
            # Remove it from select operations set
            self._mod_conf.remove_op(op_name)
            self._mod_conf.current_op_name = preceding_op_name
        # Update interface
            self._update_config_display()
            self._update_define_combobox()
            LOGGER.log('SelectionOp removed: %s.' % op_name)
    
    ### 5 - Language section
    
    def on_drag_data_get(self, widget, drag_context,
                          selection_data, info, timestamp):
        """Provide list of languages to drag-and-drop operation."""
        LOGGER.log()
        treeview = widget
        treeselection = treeview.get_selection()
        languages = self._get_list_from_treeselection(treeselection)
        selection_data.set('list of languages', 8, repr(languages))
    
    def _get_list_from_treeselection(self, treeselection):
        """Return a list of the selected values."""
        LOGGER.log()
        list_ = []
        treeselection.selected_foreach(self._append_text_from_model, list_)
        return list_
    
    def _append_text_from_model(self, treemodel, path, iter_, list_):
        """Append first-column value of the specified row to the list."""
        LOGGER.log()
        text = treemodel.get_value(iter_, 0)
        list_.append(text)
    
    def on_drag_data_received(self, widget, drag_context, x, y,
                               selection_data, info, timestamp):
        """
        Assign languages from drag-and-drop operation to ConfigSet name of the
        receiving ScrolledWindow.
        """
        LOGGER.log()
        scrolledwindow = widget
        # Get the languages from the drag data
        text = selection_data.data
        if text:
            languages = eval(text)
            # Determine source and destination
            source_configset_name = self._mod_conf.languages[languages[0]]
            dest_configset_name = scrolledwindow.name[3:]
            if source_configset_name == dest_configset_name:
                return
            source_treeview_name = 'tv_' + source_configset_name
            source_treeview = self._get_widget_by_name(
                scrolledwindow.get_parent(), source_treeview_name)
            dest_treeview = scrolledwindow.get_child()
            # Move and re-assign the languages
            for language in languages:
                self._remove_from_treeview(source_treeview, language)
                self._mod_conf.languages[language] = dest_configset_name
                self._add_to_treeview(dest_treeview, language)
            self._select_languages(dest_treeview, languages)
            dest_treeview.grab_focus()
    
    def _get_widget_by_name(self, container, name):
        """Recursively search to return the named child widget."""
        LOGGER.log()
        children = container.get_children()
        for child in children:
            if child.name == name:
                return child
            if isinstance(child, gtk.Container):
                found_child = self._get_widget_by_name(child, name)
                if found_child:
                    return found_child
    
    def _remove_from_treeview(self, treeview, value):
        """Remove the language name from the TreeView."""
        LOGGER.log()
        liststore = treeview.get_model()
        liststore_list = self._get_list_from_liststore(liststore)
        path = liststore_list.index(value)
        iter_ = liststore.get_iter(path)
        liststore.remove(iter_)
        if len(liststore) == 0:
            treeview.set_property('can-focus', False)
    
    def _add_to_treeview(self, treeview, value):
        """Add the language name to the TreeView."""
        LOGGER.log()
        liststore = treeview.get_model()
        liststore_list = self._get_list_from_liststore(liststore)
        liststore_list.append(value)
        liststore_list.sort()
        path = liststore_list.index(value)
        if path == len(liststore):
            liststore.append([value])
        else:
            iter_ = liststore.get_iter(path)
            liststore.insert_before(iter_, row=[value])
        treeview.set_property('can-focus', True)
    
    def _select_languages(self, treeview, languages):
        """Select rows in the treeview corresponding to languages."""
        LOGGER.log()
        liststore = treeview.get_model()
        liststore_list = self._get_list_from_liststore(liststore)
        treeselection = treeview.get_selection()
        for language in languages:
            path = liststore_list.index(language)
            treeselection.select_path(path)
    
    def _get_list_from_liststore(self, liststore):
        """Return a list of the first-column treeview row values."""
        LOGGER.log()
        return [liststore.get_value(liststore.get_iter(i), 0)
                 for i in range(len(liststore))]
    
    def _update_language_frame(self):
        """Show or hide the language frame as appropriate."""
        LOGGER.log()
        # Get objects
        language_frame = self.builder.get_object("frame3")
        # Update interface
        if self._mod_conf.is_set_by_language:
            self._build_lang_table()
            language_frame.show()
        else:
            language_frame.hide()
            self.window.present()
    
    def _build_lang_table(self):
        """Replace the language table with one matching the configuration."""
        LOGGER.log()
        lang_vbox = self.builder.get_object("lang_vbox")
        # Get the old Table
        old_table = lang_vbox.get_children()[1]
        # Make a new Table for the ConfigSets and their assigned languages
        new_table = gtk.Table(
            rows=2,
            columns=len(self._mod_conf.configsets),
            homogeneous=False)
        new_table.set_col_spacings(5)
        # Add to the Table a Label and ScrolledWindow for each ConfigSet
        for index, configset in enumerate(self._mod_conf.configsets):
            # Make a Label of the ConfigSet's name
            label = gtk.Label(configset.name)
            # Add the Label to the Table
            new_table.attach(
                label, 
                left_attach=index,
                right_attach=index+1,
                top_attach=0,
                bottom_attach=1, 
                xoptions=gtk.EXPAND|gtk.FILL,
                yoptions=gtk.FILL,
                xpadding=0,
                ypadding=0)
            # Make a ScrolledWindow of the ConfigSet's assigned languages
            scrolledwindow = self._make_scrolledwindow(configset)
            # Add the ScrolledWindow to the Table
            new_table.attach(
                scrolledwindow, 
                left_attach=index,
                right_attach=index+1,
                top_attach=1,
                bottom_attach=2, 
                xoptions=gtk.EXPAND|gtk.FILL,
                yoptions=gtk.EXPAND|gtk.FILL,
                xpadding=0,
                ypadding=0)
        # Replace the old Table with the new Table
        lang_vbox.remove(old_table)
        lang_vbox.pack_start(new_table, expand=True, fill=True, padding=0)
        lang_vbox.show_all()
    
    def _make_scrolledwindow(self, configset):
        """Return a ScrolledWindow of the ConfigSet's assigned languages."""
        LOGGER.log()
        # Make a TreeView of the ConfigSet's assigned languages
        treeview = self._make_treeview(configset)
        # Configure the TreeView for being dragged from
        treeview.enable_model_drag_source(
            start_button_mask=gtk.gdk.BUTTON1_MASK,
            targets=[('list of languages', gtk.TARGET_SAME_APP, 0)],
            actions=gtk.gdk.ACTION_DEFAULT | gtk.gdk.ACTION_COPY)
        treeview.connect("drag-data-get", self.on_drag_data_get)
        # Make a ScrolledWindow of the TreeView
        scrolledwindow = gtk.ScrolledWindow()
        scrolledwindow.set_policy(hscrollbar_policy=gtk.POLICY_AUTOMATIC,
                                  vscrollbar_policy=gtk.POLICY_AUTOMATIC)
        scrolledwindow.set_shadow_type(gtk.SHADOW_IN)
        scrolledwindow.add(treeview)
        # Configure the ScrolledWindow for being dropped on
        scrolledwindow.set_name('sw_%s' % configset.name)
        scrolledwindow.drag_dest_set(
            flags=gtk.DEST_DEFAULT_ALL,
            targets=[('list of languages', gtk.TARGET_SAME_APP, 0)],
            actions=gtk.gdk.ACTION_DEFAULT | gtk.gdk.ACTION_COPY)
        scrolledwindow.connect('drag-data-received',
                               self.on_drag_data_received)
        return scrolledwindow
    
    def _make_treeview(self, configset):
        """Return a TreeView of the ConfigSet's assigned languages."""
        LOGGER.log()
        # Make a ListStore of the ConfigSet's assigned languages
        liststore = self._make_liststore(configset)
        # Make a TreeView of the ListStore
        treeview = TreeViewDV(liststore)
        # Configure the TreeView
        tvcolumn = gtk.TreeViewColumn('Languages')
        treeview.append_column(tvcolumn)
        cell = gtk.CellRendererText()
        tvcolumn.pack_start(cell, True)
        tvcolumn.add_attribute(cell, 'text', 0)
        treeview.set_search_column(0)
        tvcolumn.set_sort_column_id(0)
        treeview.set_reorderable(False)
        treeview.set_headers_visible(False)
        treeview.set_name('tv_%s' % configset.name)
        treeselection = treeview.get_selection()
        treeselection.set_mode(gtk.SELECTION_MULTIPLE)
        treeview.set_rubber_banding(True)
        if len(liststore) == 0:
            treeview.set_property('can-focus', False)
        return treeview
    
    def _make_liststore(self, configset):
        """Return a ListStore of the ConfigSet's assigned languages."""
        LOGGER.log()
        liststore = gtk.ListStore(str)
        langauge_assignments = sorted(self._mod_conf.languages.items())
        for language, configset_name in langauge_assignments:
            if configset_name == configset.name:
                liststore.append([language])
        return liststore
    


########NEW FILE########
__FILENAME__ = completion
# Copyright (C) 2006-2008 Osmo Salomaa
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

"""Complete words with the tab key.

This plugin provides a 'stupid' word completion plugin, one that is aware of
all words in all open documents, but knows nothing of any context or syntax.
This plugin can be used to speed up writing and to avoid spelling errors in
either regular text documents or in programming documents if no programming
language -aware completion is available.

Words are automatically scanned at regular intervals. Once you have typed a
word and the interval has passed, the word is available in the completion
system. A completion window listing possible completions is shown and updated
as you type. You can complete to the topmost word in the window with the Tab
key, or choose another completion with the arrow keys and complete with the Tab
key. The keybindinds are configurable only by editing the source code.
"""

import gedit
import gobject
import gtk
import pango
import re
from lib import sgconf # gmate lib

class CompletionWindow(gtk.Window):

    """Window for displaying a list of words to complete to.

    This is a popup window merely to display words. This window is not meant
    to receive or handle input from the user, rather the various methods should
    be called to chang the list of words and which one of them is selected.
    """

    def __init__(self, parent):

        gtk.Window.__init__(self, gtk.WINDOW_POPUP)
        self._store = None
        self._view = None
        self._moved = False
        self.set_transient_for(parent)
        self._init_view()
        self._init_containers()

    def _init_containers(self):
        """Initialize the frame and the scrolled window."""

        scroller = gtk.ScrolledWindow()
        scroller.set_policy(*((gtk.POLICY_NEVER,) * 2))
        scroller.add(self._view)
        frame = gtk.Frame()
        frame.set_shadow_type(gtk.SHADOW_OUT)
        frame.add(scroller)
        self.add(frame)

    def _init_view(self):
        """Initialize the tree view listing the complete words."""

        self._store = gtk.ListStore(gobject.TYPE_STRING)
        self._view = gtk.TreeView(self._store)
        renderer = gtk.CellRendererText()
        renderer.xpad = renderer.ypad = 6
        column = gtk.TreeViewColumn("", renderer, text=0)
        self._view.append_column(column)
        self._view.set_enable_search(False)
        self._view.set_headers_visible(False)
        self._view.set_rules_hint(True)
        selection = self._view.get_selection()
        selection.set_mode(gtk.SELECTION_SINGLE)

    def get_selected(self):
        """Return the index of the selected row."""

        selection = self._view.get_selection()
        self._moved = False
        return selection.get_selected_rows()[1][0][0]

    def select_next(self):
        """Select the next complete word."""

        row = min(self.get_selected() + 1, len(self._store) - 1)
        selection = self._view.get_selection()
        selection.unselect_all()
        selection.select_path(row)
        self._moved = True
        self._view.scroll_to_cell(row)

    def select_previous(self):
        """Select the previous complete word."""

        row = max(self.get_selected() - 1, 0)
        selection = self._view.get_selection()
        selection.unselect_all()
        selection.select_path(row)
        self._moved = True
        self._view.scroll_to_cell(row)

    def set_completions(self, completions):
        """Set the completions to display."""

        # 'gtk.Window.resize' followed later by 'gtk.TreeView.columns_autosize'
        # will allow the window to either grow or shrink to fit the new data.
        self.resize(1, 1)
        self._store.clear()
        for word in completions:
            self._store.append((word,))
        self._view.columns_autosize()
        self._view.get_selection().select_path(0)

    def set_font_description(self, font_desc):
        """Set the font description used in the view."""

        self._view.modify_font(font_desc)

class Settings(sgconf.Options):
    _uri = u"/apps/gedit-2/plugins/completion"

    max_completions_show = sgconf.IntOption(6)
    enter_behaviour_mode = sgconf.StringOption('complete')

class CompletionConfigDialog(gtk.Dialog):
    Title = 'Completion plugin settings'
    MaxCompletionsShow = 'Maximum suggestions for show:'
    # two variants of completion works:
    OnEnterComplete = ('Completion on enter, new line on <mod> + enter', 'complete')
    OnEnterNewLine =  ('Completion after select suggestion in popup menu', 'newline')
    EnterBehaviourKey = 'behaviour'
    EnterBehaviourFrameText = "<b>Behaviour for key 'enter':</b>"

    def __init__(self, settings):
        gtk.Dialog.__init__(self, self.Title, None, gtk.DIALOG_DESTROY_WITH_PARENT)
        self._settings = settings
        self.set_resizable(False)
        mainbox = gtk.VBox()
        mainbox.set_border_width(10)
        mainbox.set_spacing(10)
        
        close_button = self.add_button(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
        close_button.grab_default()
        close_button.connect('clicked', self.on_close, None)
        
        # Enter Behaviour frame
        frame = gtk.Frame(self.EnterBehaviourFrameText)
        frame.set_shadow_type(gtk.SHADOW_NONE)
        frame.get_label_widget().set_use_markup(True)

        scope_box = gtk.VBox(False, 0)
        scope_box.set_border_width(5)
        def entermode_radio(text, mode, group=None):
            btn = gtk.RadioButton(group, text)
            btn.set_data(self.EnterBehaviourKey, mode)
            btn.connect('toggled', self.enter_mode_change)
            btn.set_active(self._settings.enter_behaviour_mode == mode)
            scope_box.pack_start(btn)
            return btn
        btn1 = entermode_radio(*self.OnEnterComplete)
        btn2 = entermode_radio(*(self.OnEnterNewLine +  (btn1, )))
        frame.add(scope_box)
        mainbox.pack_start(frame)
        
        # Max Completions frame
        frame = gtk.Frame()
        frame.set_shadow_type(gtk.SHADOW_NONE)
        hbox = gtk.HBox()
        hbox.set_spacing(10)
        label = gtk.Label(self.MaxCompletionsShow)
        label.set_use_markup(True)

        # gtk.Adjustment(value=0, lower=0, upper=0, step_incr=0, page_incr=0,
        # page_size=0)
        adj = gtk.Adjustment(self._settings.max_completions_show, 1, 60, 1, 5)
        self._max_compl_show = gtk.SpinButton(adj)

        hbox.pack_start(label)
        hbox.pack_start(self._max_compl_show)
        frame.add(hbox)
        mainbox.pack_start(frame)

        # Show
        self.vbox.pack_start(mainbox)
        self.vbox.show_all()
        self.show()

    def on_close(self, widget, data=None):
        self._settings.max_completions_show = self._max_compl_show.get_value_as_int()
        gtk.Widget.destroy(self)

    def enter_mode_change(self, widget):
        mode = widget.get_data(self.EnterBehaviourKey)
        if mode is not None and mode in ('complete', 'newline'):
            self._settings.enter_behaviour_mode = mode


class CompletionPlugin(gedit.Plugin):

    """Complete words with the tab key.

    Instance variables are as follows. '_completion_windows' is a dictionary
    mapping 'gedit.Windows' to 'CompletionWindows'.

    '_all_words' is a dictionary mapping documents to a frozen set containing
    all words in the document. '_favorite_words' is a dictionary mapping
    documents to a set of words that the user has completed to. Favorites are
    thus always document-specific and there are no degrees to favoritism. These
    favorites will be displayed at the top of the completion window. As
    '_all_words' and '_favorite_words' are both sets, the exact order in which
    the words are listed in the completion window is unpredictable.

    '_completions' is a list of the currently active complete words, shown in
    the completion window, that the user can complete to. Similarly '_remains'
    is a list of the untyped parts the _completions, i.e. the part that will be
    inserted when the user presses the Tab key. '_completions' and '_remains'
    always contain words for the gedit window, document and text view that has
    input focus.

    '_font_ascent' is the ascent of the font used in gedit's text view as
    reported by pango. It is needed to be able to properly place the completion
    window right below the caret regardless of the font and font size used.
    """

    # Unlike gedit itself, consider underscores alphanumeric characters
    # allowing completion of identifier names in many programming languages.
    _re_alpha = re.compile(r"\w+", re.UNICODE | re.MULTILINE)
    _re_non_alpha = re.compile(r"\W+", re.UNICODE | re.MULTILINE)

    # TODO: Are these sane defaults?
    _scan_frequency = 10000 # ms

    def __init__(self):

        gedit.Plugin.__init__(self)
        self._all_words = {}
        self._completion_windows = {}
        self._completions = []
        self._favorite_words = {}
        self._font_ascent = 0
        self._remains = []
        self._settings = Settings()

    def is_configurable(self):
        return True

    def create_configure_dialog(self):
        self._config_dialog = CompletionConfigDialog(self._settings)
        return self._config_dialog

    def _complete_current(self):
        """Complete the current word."""

        window = gedit.app_get_default().get_active_window()
        doc = window.get_active_document()
        index = self._completion_windows[window].get_selected()
        doc.insert_at_cursor(self._remains[index])
        words = self._favorite_words.setdefault(doc, set(()))
        words.add(self._completions[index])
        self._terminate_completion()

    def _connect_document(self, doc):
        """Connect to document's 'loaded' signal."""

        callback = lambda doc, x, self: self._scan_document(doc)
        handler_id = doc.connect("loaded", callback, self)
        doc.set_data(self.__class__.__name__, (handler_id,))

    def _connect_view(self, view, window):
        """Connect to view's editing signals."""

        callback = lambda x, y, self: self._terminate_completion()
        id_1 = view.connect("focus-out-event", callback, self)
        callback = self._on_view_key_press_event
        id_2 = view.connect("key-press-event", callback, window)
        view.set_data(self.__class__.__name__, (id_1, id_2))

    def _display_completions(self, view, event):
        """Find completions and display them in the completion window."""

        doc = view.get_buffer()
        insert = doc.get_iter_at_mark(doc.get_insert())
        start = insert.copy()
        while start.backward_char():
            char = unicode(start.get_char())
            if not self._re_alpha.match(char):
                start.forward_char()
                break
        incomplete = unicode(doc.get_text(start, insert))
        incomplete += unicode(event.string)
        if incomplete.isdigit():
            # Usually completing numbers is not a good idea.
            return self._terminate_completion()
        self._find_completions(doc, incomplete)
        if not self._completions:
            return self._terminate_completion()
        self._show_completion_window(view, insert)

    def _find_completions(self, doc, incomplete):
        """Find completions for incomplete word and save them."""

        self._completions = []
        self._remains = []
        favorites = self._favorite_words.get(doc, ())
        _all_words = set(())
        for words in self._all_words.itervalues():
            _all_words.update(words)
        limit = self._settings.max_completions_show
        for sequence in (favorites, _all_words):
            for word in sequence:
                if not word.startswith(incomplete): continue
                if word == incomplete: continue
                if word in self._completions: continue
                self._completions.append(word)
                self._remains.append(word[len(incomplete):])
                if len(self._remains) >= limit: break

    def _check_by_completion_moved(self, moved):
        if self._settings.enter_behaviour_mode == 'newline':
            return moved
        return True

    def _on_view_key_press_event(self, view, event, window):
        """Manage actions for completions and the completion window."""

        if event.state & gtk.gdk.CONTROL_MASK:
            return self._terminate_completion()
        if event.state & gtk.gdk.SUPER_MASK:
            return self._terminate_completion()
        if event.state & gtk.gdk.MOD1_MASK:
            return self._terminate_completion()

        completion_window = self._completion_windows[window]
        if (event.keyval == gtk.keysyms.Return) and self._remains and \
                self._check_by_completion_moved(completion_window._moved):
            return not self._complete_current()
        
        if (event.keyval == gtk.keysyms.Up) and self._remains:
            return not completion_window.select_previous()
        if (event.keyval == gtk.keysyms.Down) and self._remains:
            return not completion_window.select_next()
        string = unicode(event.string)
        if len(string) != 1:
            # Do not suggest completions after pasting text.
            return self._terminate_completion()
        if self._re_alpha.match(string) is None:
            return self._terminate_completion()
        doc = view.get_buffer()
        insert = doc.get_iter_at_mark(doc.get_insert())
        if self._re_alpha.match(unicode(insert.get_char())):
            # Do not suggest completions in the middle of a word.
            return self._terminate_completion()
        return self._display_completions(view, event)

    def _on_window_tab_added(self, window, tab):
        """Connect to signals of the document and view in tab."""

        self._update_fonts(tab.get_view())
        name = self.__class__.__name__
        doc = tab.get_document()
        handler_id = doc.get_data(name)
        if handler_id is None:
            self._connect_document(doc)
        view = tab.get_view()
        handler_id = view.get_data(name)
        if handler_id is None:
            self._connect_view(view, window)

    def _on_window_tab_removed(self, window, tab):
        """Remove closed document's word and favorite sets."""

        doc = tab.get_document()
        self._all_words.pop(doc, None)
        self._favorite_words.pop(doc, None)

    def _scan_active_document(self, window):
        """Scan all the words in the active document in window."""

        # Return False to not scan again.
        if window is None: return False
        doc = window.get_active_document()
        if doc is not None:
            self._scan_document(doc)
        return True

    def _scan_document(self, doc):
        """Scan and save all words in document."""

        text = unicode(doc.get_text(*doc.get_bounds()))
        self._all_words[doc] = frozenset(self._re_non_alpha.split(text))

    def _show_completion_window(self, view, itr):
        """Show the completion window below the caret."""

        text_window = gtk.TEXT_WINDOW_WIDGET
        rect = view.get_iter_location(itr)
        x, y = view.buffer_to_window_coords(text_window, rect.x, rect.y)
        window = gedit.app_get_default().get_active_window()
        x, y = view.translate_coordinates(window, x, y)
        x += window.get_position()[0] + self._font_ascent
        # Use 24 pixels as an estimate height for window title bar.
        # TODO: There must be a better way than a hardcoded pixel value.
        y += window.get_position()[1] + 24 + (2 * self._font_ascent)
        completion_window = self._completion_windows[window]
        completion_window.set_completions(self._completions)
        completion_window.move(int(x), int(y))
        completion_window.show_all()

    def _terminate_completion(self):
        """Hide the completion window and cancel completions."""

        window = gedit.app_get_default().get_active_window()
        self._completion_windows[window].hide()
        self._completions = []
        self._remains = []

    def _update_fonts(self, view):
        """Update font descriptions and ascent metrics."""

        context = view.get_pango_context()
        font_desc = context.get_font_description()
        if self._font_ascent == 0:
            # Acquiring pango metrics is a bit slow,
            # so do this only when absolutely needed.
            metrics = context.get_metrics(font_desc, None)
            self._font_ascent = metrics.get_ascent() / pango.SCALE
        for completion_window in self._completion_windows.itervalues():
            completion_window.set_font_description(font_desc)

    def activate(self, window):
        """Activate plugin."""

        callback = self._on_window_tab_added
        id_1 = window.connect("tab-added", callback)
        callback = self._on_window_tab_removed
        id_2 = window.connect("tab-removed", callback)
        window.set_data(self.__class__.__name__, (id_1, id_2))
        for doc in window.get_documents():
            self._connect_document(doc)
            self._scan_document(doc)
        views = window.get_views()
        for view in views:
            self._connect_view(view, window)
        if views: self._update_fonts(views[0])
        self._completion_windows[window] = CompletionWindow(window)
        # Scan the active document in window if it has input focus
        # for new words at constant intervals.
        def scan(self, window):
            if not window.is_active(): return True
            return self._scan_active_document(window)
        freq = self._scan_frequency
        priority = gobject.PRIORITY_LOW
        gobject.timeout_add(freq, scan, self, window, priority=priority)

    def deactivate(self, window):
        """Deactivate plugin."""

        widgets = [window]
        widgets.extend(window.get_views())
        widgets.extend(window.get_documents())
        name = self.__class__.__name__
        for widget in widgets:
            for handler_id in widget.get_data(name):
                widget.disconnect(handler_id)
            widget.set_data(name, None)
        self._terminate_completion()
        self._completion_windows.pop(window)
        for doc in window.get_documents():
            self._all_words.pop(doc, None)
            self._favorite_words.pop(doc, None)

########NEW FILE########
__FILENAME__ = accelmap
import gedit
import gtk
import gtk.glade
import os.path
import re

from gettext import gettext as _

# Menu-definition
ui_str = """<ui>
    <menubar name="MenuBar">
        <menu name="ToolsMenu" action="Tools">  
            <placeholder name="ToolsOps_2">
                <menuitem name="EditShortcuts" action="EditShortcuts"/>
            </placeholder>
        </menu>
    </menubar>
</ui>"""



# Plugin-class
class AccelPlugin(gedit.Plugin):
    def __init__(self):
        gedit.Plugin.__init__(self)
        self._instances = dict()
    

    def activate(self, window):
        self._instances[window] = AccelPluginWindowHelper(window)
        
        
    def deactivate(self, window):
        self._instances[window].deactivate()
        del self._instances[window]
        
        
    def update_ui(self, window):
        self._instances[window].update_ui()
        
        
        
        
# Plugin-class per window-instance:        
class AccelPluginWindowHelper:
    """ This class registers a menu-item and action to show the accelerator
        -dialog """
    def __init__(self, window):
        self._window = window
        manager = self._window.get_ui_manager()

        self._action_group = gtk.ActionGroup("EditShortcutsPluginActions")
        self._action_group.add_actions([("EditShortcuts", None, 
                                         _("Edit Shortcuts"), None, 
                                         _("Edit keyboard-shortcuts"),
                                         self._on_assign_accelerators)])
        
        manager.insert_action_group(self._action_group, -1)
        self._ui_id = manager.add_ui_from_string(ui_str)


    def deactivate(self):
        manager = self._window.get_ui_manager()
        manager.remove_ui(self._ui_id)
        manager.remove_action_group(self._action_group)
        manager.ensure_update()


    def update_ui(self):
        pass

    def _on_assign_accelerators(self, action):
        dlg = AccelDialog()
        dlg.run()




# Dialog-Class (impl. controller)
class AccelDialog:
    """ This class implements the accelerator-dialog """
    def __init__(self):
        # load glade-file
        glade_file = os.path.join(os.path.dirname(__file__),"accelmap.glade")
        self.__xml = gtk.glade.XML(glade_file, "AccelDialog")
        
        # and get some widgets
        self.__dialog = self.__xml.get_widget("AccelDialog")
        self.__tree = self.__xml.get_widget("ActionTree")

        # add colums to treeview
        self.__tree.append_column(gtk.TreeViewColumn(_("Action"), gtk.CellRendererText(), markup=0))
        self.__tree.append_column(gtk.TreeViewColumn(_("Shortcut"), gtk.CellRendererText(), text=1))

        # create and fill treemodel
        self.__model_iters = dict()
        self.__model = gtk.TreeStore(str, str, str)
        self.__my_accel_map = dict()
        gtk.accel_map_foreach(self.populate_tree)
        self.__model.set_sort_column_id(0, gtk.SORT_ASCENDING)
        self.__tree.set_model(self.__model)

        # connect event-handler
        self.__tree.connect("row-activated", self.on_double_click)
        self.__xml.get_widget("cancel").connect('clicked', self.on_cancel_clicked)
        self.__xml.get_widget("apply").connect('clicked', self.on_apply_clicked)



    def populate_tree(self, path, key, mode, changed):
        """ Internal used method to fill tree. """
        m = re.match("^<Actions>/(.+)/(.+)$", path)
        if not m: 
            print "Warning: action \"%s\" doesn't match re!"%path
            return
      
        grp, act = m.group(1), m.group(2)
        
        # if new group -> create one
        if not grp in self.__model_iters:
            self.__model_iters[grp] = self.__model.append(None, ["<b>%s</b>"%grp, "", ""])
        
        # assign action to group 
        self.__model.append(self.__model_iters[grp], [act, gtk.accelerator_get_label(key,mode), path])
        self.__my_accel_map[path] = (key, mode)        


    def on_double_click(self, view, path, column):
        """ If a action was double-clicked. """
        iter = self.__model.get_iter(path)
        if not self.__model[iter][2]: return True

        # show key-chooser-dialog
        dlg = KeyChooser()
        if dlg.run() == gtk.RESPONSE_DELETE_EVENT: return True 
        
        # get keys: 
        (key, modi) = dlg.keys

        # if backspace with no modifier -> delete accelerator:
        if key == 65288 and modi==0:
            self.__model[iter][1] = ""
            self.__my_accel_map[self.__model[iter][2]] = (0,0)
            return True

        # set keys to table (tree)
        self.__model[iter][1] = gtk.accelerator_get_label(key, modi)
        self.__my_accel_map[self.__model[iter][2]] = (key, modi) 


    def on_cancel_clicked(self, button):
        self.__dialog.response(gtk.RESPONSE_CANCEL)

    
    def on_apply_clicked(self, button):
        self.__dialog.response(gtk.RESPONSE_APPLY)
        self.apply_changes_to_accel(self.__model.get_iter_root())


    def run(self):
        ret = self.__dialog.run()
        self.__dialog.destroy()
    
        
    def apply_changes_to_accel(self, iter):
        """ Recursively saves accelerators from tree to gtk.AccelMap. """
        if not iter: return

        if self.__model[iter][2]:
            path        = self.__model[iter][2]
            (key, mods) = self.__my_accel_map[path]
            gtk.accel_map_change_entry(path, key, mods, False)                    

        if self.__model.iter_has_child(iter):
            self.apply_changes_to_accel(self.__model.iter_children(iter))

        self.apply_changes_to_accel(self.__model.iter_next(iter))




class KeyChooser:
    """ A small dialog to catch keyboard. """
    def __init__(self):
        glade_file = os.path.join(os.path.dirname(__file__),"accelmap.glade")
        self.__xml = gtk.glade.XML(glade_file, "KeyDialog")
    
        self.__dialog = self.__xml.get_widget("KeyDialog")
        self.__dialog.connect("key-release-event", self.on_key)
        self.__label  = self.__xml.get_widget("message")

        self.keys = None


    def on_key(self, widget, event):
        self.keys = event.keyval, event.state

        if not gtk.accelerator_valid(event.keyval, event.state):
            self.__label.set_markup("<b>%s</b> - invalid accelerator!"%gtk.accelerator_get_label(event.keyval, event.state))
            return

        action = self.accel_is_used(event.keyval, event.state)
        if action:
            self.__label.set_markup("<b>%s</b> - accelerator used by action:\n \"%s\"!"%(gtk.accelerator_get_label(event.keyval, event.state), action))
            return

        self.__dialog.response(gtk.RESPONSE_APPLY)   
   
 
    def run(self):
        ret = self.__dialog.run()
        self.__dialog.destroy()
        return ret


    def accel_is_used(self, key, modi):
        def _accel_cb(path, mkey, mmodi, changed, udata):
            if key==mkey and modi==mmodi: 
                 udata[0] = str(path)
        
        udata = ['']
        gtk.accel_map_foreach(_accel_cb, udata)
           
        m = re.match("^<Actions>(.+)$", udata[0])
        if not m: return udata[0]
        return m.group(1)

########NEW FILE########
__FILENAME__ = encodingpy
# -*- coding: utf-8 -*-
#  Open the document in a different encoding
#  Dependence: python >=2.5, pygtk
# 
#  Install: copy encoding.gedit-plugin and encodingpy.py to ~/.gnome2/gedit/plugins/
# 
#  Copyright (C) 2008 Vladislav Gorbunov
#   
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#   
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#   
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

# TODO:
# fix document_loaded: assertion `(tab->priv->state == GEDIT_TAB_STATE_LOADING) || (tab->priv->state == GEDIT_TAB_STATE_REVERTING)' failed

from gettext import gettext as _

import gtk
import gedit
import functools
import gconf

# All encodings names
enclist_func = lambda i=0: [gedit.encoding_get_from_index(i)] + enclist_func(i+1) if gedit.encoding_get_from_index(i) else []

shown_enc = gconf.client_get_default().get("/apps/gedit-2/preferences/encodings/shown_in_menu")
# show the full list of encodings if not they not configured in the Open/Save Dialog
enclist = sorted(([gedit.encoding_get_from_charset(enc.to_string()) for enc in shown_enc.get_list()]
                 if shown_enc else enclist_func())
                  + [gedit.encoding_get_utf8()], key=lambda enc: enc.to_string())

ui_str = """<ui>
          <menubar name="MenuBar">
            <menu name="FileMenu" action="File">
              <placeholder name="FileOps_2">
                <menu name="FileEncodingMenu" action="FileEncoding">
                  <placeholder name="EncodingListHolder"/>
                  <separator/>
%s
                </menu>
              </placeholder>
            </menu>
          </menubar>
</ui>
""" % "\n".join(["<menuitem name=\"Encoding%i\" action=\"Encoding%i\"/>" % (i, i) for i in range(len(enclist))])

class EncodingWindowHelper:
    def __init__(self, plugin, window):
        self._window = window
        self._plugin = plugin
        self._insert_menu()

    def deactivate(self):
        self._remove_menu()
        self._window = None
        self._plugin = None
        self._action_group = None

    def _insert_menu(self):
        manager = self._window.get_ui_manager()
        self._action_group = gtk.ActionGroup("EncodingPyPluginActions")
        self._action_group.add_actions([("FileEncoding", None, _("Encoding"))] + \
                                       [("Encoding%i" % i, None, enclist[i].to_string(), None, 
                                         _("Reopen the document in")+" "+enclist[i].to_string(),
                                         functools.partial(self.reopen_document, enc=enclist[i])) \
                                         for i in range(len(enclist))])
        manager.insert_action_group(self._action_group, -1)
        self._ui_id = manager.add_ui_from_string(ui_str)

    def _remove_menu(self):
        manager = self._window.get_ui_manager()
        manager.remove_ui(self._ui_id)
        manager.remove_action_group(self._action_group)
        manager.ensure_update()

    def update_ui(self):
        self._action_group.set_sensitive(self._window.get_active_document() != None)

    
    def reopen_document(self, action, enc):
        doc = self._window.get_active_document()
        if doc and doc.get_uri():
            line_pos = doc.get_iter_at_mark(doc.get_insert()).get_line()
            uri = doc.get_uri()
            doc.load(uri, enc, line_pos+1, False)
            # Can fix the 'document_loaded: assertion' if replace doc.load() to this two lines:
            #self._window.close_tab(self._window.get_active_tab())
            #self._window.create_tab_from_uri(uri, enc, line_pos+1, False, True)
    

class EncodingPlugin(gedit.Plugin):
    def __init__(self):
        gedit.Plugin.__init__(self)
        self._instances = {}

    def activate(self, window):
        self._instances[window] = EncodingWindowHelper(self, window)

    def deactivate(self, window):
        self._instances[window].deactivate()
        del self._instances[window]

    def update_ui(self, window):
        self._instances[window].update_ui()

########NEW FILE########
__FILENAME__ = searcher
#    Gedit file search plugin
#    Copyright (C) 2008-2011  Oliver Gerlich <oliver.gerlich@gmx.de>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# Search functionality classes:
# - LineSplitter (accumulates incoming strings and splits them into lines)
# - RunCommand (runs a shell command and passes the output to LineSplitter)
# - GrepProcess (uses RunCommand to run Grep, parses its output, and passes that to the result window)
# - SearchProcess (uses RunCommand to run Find, parses its output, and starts GrepProcess)
#


import os
import gobject
import fcntl
import subprocess
import re
import errno


class LineSplitter:
    "Split incoming text into lines which are passed to the resultHandler object"
    def __init__ (self, resultHandler):
        self.buf = ""
        self.cancelled = False
        self.resultHandler = resultHandler

    def cancel (self):
        self.cancelled = True

    def parseFragment (self, text):
        if self.cancelled:
            return

        self.buf = self.buf + text

        while '\n' in self.buf:
            pos = self.buf.index('\n')
            line = self.buf[:pos]
            self.buf = self.buf[pos + 1:]
            self.resultHandler.handleLine(line)

    def finish (self):
        self.parseFragment("")
        if self.buf != "":
            self.resultHandler.handleLine(self.buf)
        self.resultHandler.handleFinished()


class RunCommand:
    "Run a command in background, passing all of its stdout output to a LineSplitter"
    def __init__ (self, cmd, resultHandler, prio=gobject.PRIORITY_LOW):
        self.lineSplitter = LineSplitter(resultHandler)

        #print "executing command: %s" % cmd
        self.proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, close_fds=True)
        self.pipe = self.proc.stdout

        # make pipe non-blocking:
        fl = fcntl.fcntl(self.pipe, fcntl.F_GETFL)
        fcntl.fcntl(self.pipe, fcntl.F_SETFL, fl | os.O_NONBLOCK)

        #print "(add watch)"
        gobject.io_add_watch(self.pipe, gobject.IO_IN | gobject.IO_ERR | gobject.IO_HUP,
            self.onPipeReadable, priority=prio)

    def onPipeReadable (self, fd, cond):
        #print "condition: %s" % cond
        if (cond & gobject.IO_IN):
            readText = self.pipe.read(4000)
            #print "(read %d bytes)" % len(readText)
            if self.lineSplitter:
                self.lineSplitter.parseFragment(readText)
            return True
        else:
            # read all remaining data from pipe
            while True:
                readText = self.pipe.read(4000)
                #print "(read %d bytes before finish)" % len(readText)
                if len(readText) <= 0:
                    break
                if self.lineSplitter:
                    self.lineSplitter.parseFragment(readText)

            #print "(closing pipe)"
            self.pipe.close()
            self.proc.wait()
            if self.lineSplitter:
                self.lineSplitter.finish()
                self.lineSplitter = None
            return False

    def cancel (self):
        #print "(cancelling command)"
        pid = self.proc.pid
        #print "pid: %d" % pid
        try:
            os.kill(pid, 15)
        except OSError, e:
            if e.errno != errno.ESRCH:
                print "error killing PID %d: %s" % (pid, e)
        self.lineSplitter.cancel()


def buildQueryRE (queryText, caseSensitive, wholeWord):
    "returns a RegEx pattern for searching for the given queryText"

    # word detection etc. cannot be done on an encoding-less string:
    assert(type(queryText) == unicode)

    pattern = re.escape(queryText)
    if wholeWord:
        if re.search('^\w', queryText, re.UNICODE):
            pattern = '\\b' + pattern
        if re.search('\w$', queryText, re.UNICODE):
            pattern = pattern + '\\b'

    flags = re.UNICODE
    if not(caseSensitive):
        flags |= re.IGNORECASE
    return re.compile(pattern, flags)


class GrepProcess:
    def __init__ (self, query, resultCb, finishedCb):
        self.query = query
        self.resultCb = resultCb
        self.finishedCb = finishedCb

        # Assume all file contents are in UTF-8 encoding (AFAIK grep will just search for byte sequences, it doesn't care about encodings):
        self.queryText = query.text.encode("utf-8")

        self.fileNames = []
        self.cmdRunner = None
        self.cancelled = False
        self.numGreps = 0
        self.inputFinished = False

        self.postSearchPattern = None
        if query.wholeWord:
            self.postSearchPattern = buildQueryRE(self.query.text, query.caseSensitive, True)

    def cancel (self):
        self.cancelled = True
        if self.cmdRunner:
            self.cmdRunner.cancel()
            self.cmdRunner = None
        pass

    def addFilename (self, filename):
        self.fileNames.append(filename)
        self.runGrep()

    def handleInputFinished (self):
        "Called when there will be no more input files added"
        self.inputFinished = True
        if not(self.cmdRunner):
            # this can happen if no files at all are found
            self.finishedCb()

    def runGrep (self):
        if self.cmdRunner or len(self.fileNames) == 0 or self.cancelled:
            return

        # run Grep on many files at once:
        maxGrepFiles = 5000
        maxGrepLine = 3800
        fileNameList = []

        i = 0
        numChars = 0
        for f in self.fileNames:
            fileNameList += [f]
            i+=1
            numChars += len(f)
            if i > maxGrepFiles or numChars > maxGrepLine:
                break
        self.fileNames = self.fileNames[i:]

        self.numGreps += 1
        #if self.numGreps % 100 == 0:
            #print "ran %d greps so far" % self.numGreps

        grepCmd = ["grep", "-H", "-I", "-n", "-s", "-Z"]
        if not(self.query.caseSensitive):
            grepCmd += ["-i"]
        if not(self.query.isRegExp):
            grepCmd += ["-F"]

        grepCmd += ["-e", self.queryText]
        grepCmd += fileNameList

        self.cmdRunner = RunCommand(grepCmd, self)

    def handleLine (self, line):
        filename = None
        lineno = None
        linetext = ""
        if '\0' in line:
            [filename, end] = line.split('\0', 1)
            if ':' in end:
                [lineno, linetext] = end.split(':', 1)
                lineno = int(lineno)

        if lineno == None:
            #print "(ignoring invalid line)"
            pass
        else:
            # Assume that grep output is in UTF8 encoding, and convert it to
            # a Unicode string. Also, sanitize non-UTF8 characters.
            # TODO: what's the actual encoding of grep's output?
            linetext = unicode(linetext, 'utf8', 'replace')
            #print "file: '%s'; line: %d; text: '%s'" % (filename, lineno, linetext)
            linetext = linetext.rstrip("\n\r")

            # do some manual grep'ing on each line (for whole-word search):
            if self.postSearchPattern is not None and \
                self.postSearchPattern.search(linetext) is None:
                return

            self.resultCb(filename, lineno, linetext)

    def handleFinished (self):
        #print "grep finished"
        self.cmdRunner = None
        if len(self.fileNames) > 0 and not(self.cancelled):
            self.runGrep()
        else:
            if self.inputFinished:
                #print "ran %d greps" % self.numGreps
                self.finishedCb()


class SearchProcess:
    def __init__ (self, query, resultHandler):
        self.resultHandler = resultHandler
        self.cancelled = False
        self.files = []

        self.grepProcess = GrepProcess(query, self.handleGrepResult, self.handleGrepFinished)

        findCmd = ["find", query.directory]
        if not(query.includeSubfolders):
            findCmd += ["-maxdepth", "1"]
        if query.excludeHidden:
            findCmd += ["(", "!", "-path", "%s*/.*" % query.directory, ")"]
            findCmd += ["(", "!", "-path", "%s.*" % query.directory, ")"]
        if query.excludeBackup:
            findCmd += ["(", "!", "-name", "*~", "!", "-name", ".#*.*", ")"]
        if query.excludeVCS:
            findCmd += ["(", "!", "-path", "*/CVS/*", "!", "-path", "*/.svn/*", "!", "-path", "*/.git/*", "!", "-path", "*/RCS/*", "!", "-path", "*/.bzr/*", ")"]
        if query.selectFileTypes:
            fileTypeList = query.parseFileTypeString()
            if fileTypeList:
                findCmd += ["("]
                for t in fileTypeList:
                    findCmd += ["-name", t, "-o"]
                findCmd.pop()
                findCmd += [")"]
        findCmd += ["-xtype", "f", "-print"]

        self.cmdRunner = RunCommand(findCmd, self, gobject.PRIORITY_DEFAULT_IDLE)

    def cancel (self):
        self.cancelled = True
        if self.cmdRunner:
            self.cmdRunner.cancel()
            self.cmdRunner = None
        if self.grepProcess:
            self.grepProcess.cancel()

    def destroy (self):
        self.cancel()

    def handleLine (self, line):
        #print "find result line: '%s' (type: %s)" % (line, type(line))

        # Note: we don't assume anything about the encoding of output from `find`
        # but just treat it as encoding-less byte sequence.

        self.files.append(line)

    def handleFinished (self):
        #print "find finished (%d files found)" % len(self.files)
        self.cmdRunner = None

        if self.cancelled:
            self.resultHandler.handleFinished()
            self.files = []
            return

        self.files.sort(pathCompare)

        for f in self.files:
            self.grepProcess.addFilename(f)
        self.files = []
        self.grepProcess.handleInputFinished()

    def handleGrepResult (self, filename, lineno, linetext):
        self.resultHandler.handleResult(filename, lineno, linetext)

    def handleGrepFinished (self):
        self.resultHandler.handleFinished()
        self.grepProcess = None

def pathCompare (p1, p2):
    "Sort path names (files before directories; alphabetically)"
    s1 = os.path.split(p1)
    s2 = os.path.split(p2)
    return cmp(s1, s2)

########NEW FILE########
__FILENAME__ = ui
#    Gedit file search plugin
#    Copyright (C) 2008-2011  Oliver Gerlich <oliver.gerlich@gmx.de>
#    Copyright (C) 2011  Jean-Philippe Fleury <contact@jpfleury.net>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.


#
# Main classes:
# - FileSearchWindowHelper (is instantiated by FileSearchPlugin for every window, and holds the search dialog)
# - FileSearcher (is instantiated by FileSearchWindowHelper for every search, and holds the result tab)
#
# Helper classes:
# - RecentList (holds list of recently-selected search directories, for search dialog)
# - SearchQuery (holds all parameters for a search; also, can read and write these from/to GConf)
#

import os
import gedit
import gtk
import gtk.glade
import gobject
import urllib
import gconf
import pango
import dircache
from gettext import gettext, translation

# translation
APP_NAME = 'file-search'
LOCALE_PATH = os.path.dirname(__file__) + '/locale'
t = translation(APP_NAME, LOCALE_PATH, fallback=True)
_ = t.ugettext
ngettext = t.ungettext
gtk.glade.bindtextdomain(APP_NAME, LOCALE_PATH)

from searcher import SearchProcess, buildQueryRE

# only display remote directories in file chooser if GIO is available:
onlyLocalPathes = False
try:
    import gio
except ImportError:
    onlyLocalPathes = True


ui_str = """<ui>
  <menubar name="MenuBar">
    <menu name="SearchMenu" action="Search">
      <placeholder name="SearchOps_2">
        <menuitem name="FileSearch" action="FileSearch"/>
      </placeholder>
    </menu>
  </menubar>
</ui>
"""

gconfBase = '/apps/gedit-2/plugins/file-search'


class RecentList:
    """
    Encapsulates a gtk.ListStore that stores a generic list of "most recently used entries"
    """
    def __init__ (self, gclient, confKey, maxEntries = 10):
        self.gclient = gclient
        self.confKey = gconfBase + "/" + confKey
        self.store = gtk.ListStore(str)
        self._maxEntries = maxEntries

        entries = self.gclient.get_list(self.confKey, gconf.VALUE_STRING)
        entries.reverse()
        for e in entries:
            if e and len(e) > 0:
                decodedName = urllib.unquote(e)
                self.add(decodedName, False)

        # TODO: also listen for gconf changes, and reload the list then

    def add (self, entrytext, doStore=True):
        "Add an entry that was just used."

        for row in self.store:
            if row[0] == entrytext:
                it = self.store.get_iter(row.path)
                self.store.remove(it)

        self.store.prepend([entrytext])

        if len(self.store) > self._maxEntries:
            it = self.store.get_iter(self.store[-1].path)
            self.store.remove(it)

        if doStore:
            entries = []
            for e in self.store:
                encodedName = urllib.quote(e[0])
                entries.append(encodedName)
            self.gclient.set_list(self.confKey, gconf.VALUE_STRING, entries)

    def isEmpty (self):
        return (len(self.store) == 0)

    def topEntry (self):
        if self.isEmpty():
            return None
        else:
            return self.store[0][0]


class SearchQuery:
    """
    Contains all parameters for a single search action.
    """
    def __init__ (self):
        self.text = ''
        self.directory = ''
        self.caseSensitive = True
        self.wholeWord = False
        self.isRegExp = False
        self.includeSubfolders = True
        self.excludeHidden = True
        self.excludeBackup = True
        self.excludeVCS = True
        self.selectFileTypes = False
        self.fileTypeString = ''

    def parseFileTypeString (self):
        "Returns a list with the separate file globs from fileTypeString"
        return self.fileTypeString.split()

    def loadDefaults (self, gclient):
        try:
            self.caseSensitive = gclient.get_without_default(gconfBase+"/case_sensitive").get_bool()
        except:
            self.caseSensitive = True

        try:
            self.wholeWord = gclient.get_without_default(gconfBase+"/whole_word").get_bool()
        except:
            self.wholeWord = False

        try:
            self.isRegExp = gclient.get_without_default(gconfBase+"/is_reg_exp").get_bool()
        except:
            self.isRegExp = False

        try:
            self.includeSubfolders = gclient.get_without_default(gconfBase+"/include_subfolders").get_bool()
        except:
            self.includeSubfolders = True

        try:
            self.excludeHidden = gclient.get_without_default(gconfBase+"/exclude_hidden").get_bool()
        except:
            self.excludeHidden = True

        try:
            self.excludeBackup = gclient.get_without_default(gconfBase+"/exclude_backup").get_bool()
        except:
            self.excludeBackup = True

        try:
            self.excludeVCS = gclient.get_without_default(gconfBase+"/exclude_vcs").get_bool()
        except:
            self.excludeVCS = True

        try:
            self.selectFileTypes = gclient.get_without_default(gconfBase+"/select_file_types").get_bool()
        except:
            self.selectFileTypes = False

    def storeDefaults (self, gclient):
        gclient.set_bool(gconfBase+"/case_sensitive", self.caseSensitive)
        gclient.set_bool(gconfBase+"/whole_word", self.wholeWord)
        gclient.set_bool(gconfBase+"/is_reg_exp", self.isRegExp)
        gclient.set_bool(gconfBase+"/include_subfolders", self.includeSubfolders)
        gclient.set_bool(gconfBase+"/exclude_hidden", self.excludeHidden)
        gclient.set_bool(gconfBase+"/exclude_backup", self.excludeBackup)
        gclient.set_bool(gconfBase+"/exclude_vcs", self.excludeVCS)
        gclient.set_bool(gconfBase+"/select_file_types", self.selectFileTypes)


class FileSearchWindowHelper:
    def __init__(self, plugin, window):
        #print "file-search: plugin created for", window
        self._window = window
        self._plugin = plugin
        self._dialog = None
        self._bus = None
        self.searchers = [] # list of existing SearchProcess instances

        self.gclient = gconf.client_get_default()
        self.gclient.add_dir(gconfBase, gconf.CLIENT_PRELOAD_NONE)

        self._lastSearchTerms = RecentList(self.gclient, "recent_search_terms")
        self._lastDirs = RecentList(self.gclient, "recent_dirs")
        self._lastTypes = RecentList(self.gclient, "recent_types")

        if self._lastTypes.isEmpty():
            # add some default file types
            self._lastTypes.add('*.C *.cpp *.cxx *.h *.hpp')
            self._lastTypes.add('*.c *.h')
            self._lastTypes.add('*.py')
            self._lastTypes.add('*')

        self._lastDir = None
        self._autoCompleteList = None

        self._lastClickIter = None # TextIter at position of last right-click or last popup menu

        self._insert_menu()
        self._addFileBrowserMenuItem()

        self._window.connect_object("destroy", FileSearchWindowHelper.destroy, self)
        self._window.connect_object("tab-added", FileSearchWindowHelper.onTabAdded, self)
        self._window.connect_object("tab-removed", FileSearchWindowHelper.onTabRemoved, self)

    def deactivate(self):
        #print "file-search: plugin stopped for", self._window
        self.destroy()

    def destroy (self):
        #print "have to destroy %d existing searchers" % len(self.searchers)
        for s in self.searchers[:]:
            s.destroy()
        self._window = None
        self._plugin = None

    def update_ui(self):
        # Called whenever the window has been updated (active tab
        # changed, etc.)
        #print "file-search: plugin update for", self._window
        pass

    def onTabAdded (self, tab):
        handlerIds = []
        handlerIds.append( tab.get_view().connect_object("button-press-event", FileSearchWindowHelper.onButtonPress, self, tab) )
        handlerIds.append( tab.get_view().connect_object("popup-menu", FileSearchWindowHelper.onPopupMenu, self, tab) )
        handlerIds.append( tab.get_view().connect_object("populate-popup", FileSearchWindowHelper.onPopulatePopup, self, tab) )
        tab.set_data("file-search-handlers", handlerIds) # store list of handler IDs so we can later remove the handlers again

    def onTabRemoved (self, tab):
        handlerIds = tab.get_data("file-search-handlers")
        if handlerIds:
            for h in handlerIds:
                tab.get_view().handler_disconnect(h)
            tab.set_data("file-search-handlers", None)

    def onButtonPress (self, event, tab):
        if event.button == 3:
            (bufX, bufY) = tab.get_view().window_to_buffer_coords(gtk.TEXT_WINDOW_TEXT, int(event.x), int(event.y))
            self._lastClickIter = tab.get_view().get_iter_at_location(bufX, bufY)

    def onPopupMenu (self, tab):
        insertMark = tab.get_document().get_insert()
        self._lastClickIter = tab.get_document().get_iter_at_mark(insertMark)

    def onPopulatePopup (self, menu, tab):
        # add separator:
        sepMi = gtk.MenuItem()
        sepMi.show()
        menu.prepend(sepMi)

        # first check if user has selected some text:
        selText = ""
        currDoc = tab.get_document()
        selectionIters = currDoc.get_selection_bounds()
        if selectionIters and len(selectionIters) == 2:
            # Only use selected text if it doesn't span multiple lines:
            if selectionIters[0].get_line() == selectionIters[1].get_line():
                selText = selectionIters[0].get_text(selectionIters[1])

        # if no text is selected, use current word under cursor:
        if not(selText) and self._lastClickIter:
            startIter = self._lastClickIter.copy()
            if not(startIter.starts_word()):
                startIter.backward_word_start()
            endIter = startIter.copy()
            if endIter.inside_word():
                endIter.forward_word_end()
            selText = startIter.get_text(endIter)

        # add actual menu item:
        if selText:
            menuText = _('Search files for "%s"') % selText
        else:
            menuText = _('Search files...')
        mi = gtk.MenuItem(menuText, use_underline=False)
        mi.connect_object("activate", FileSearchWindowHelper.onMenuItemActivate, self, selText)
        mi.show()
        menu.prepend(mi)

    def onMenuItemActivate (self, searchText):
        self.openSearchDialog(searchText)

    def _addFileBrowserMenuItem (self):
        if hasattr(self._window, 'get_message_bus') and gedit.version >= (2,27,4):
            self._bus = self._window.get_message_bus()

            fbAction = gtk.Action('search-files-plugin', _("Search files..."), _("Search in all files in a directory"), None)
            try:
                self._bus.send_sync('/plugins/filebrowser', 'add_context_item',
                    {'action':fbAction, 'path':'/FilePopup/FilePopup_Opt3'})
            except StandardError, e:
                return
            fbAction.connect('activate', self.onFbMenuItemActivate)

    def onFbMenuItemActivate (self, action):
        responseMsg = self._bus.send_sync('/plugins/filebrowser', 'get_view')
        fbView = responseMsg.get_value('view')
        (model, rowPathes) = fbView.get_selection().get_selected_rows()

        selectedUri = None
        for rowPath in rowPathes:
            fileFlags = model[rowPath][3]
            isDirectory = bool(fileFlags & 1)
            if isDirectory:
                selectedUri = model[rowPath][2]
                break

        if selectedUri is None:
            msg = self._bus.send_sync('/plugins/filebrowser', 'get_root')
            selectedUri = msg.get_value('uri')

        fileObj = gio.File(selectedUri)
        selectedDir = fileObj.get_path()

        self.openSearchDialog(searchDirectory=selectedDir)

    def registerSearcher (self, searcher):
        self.searchers.append(searcher)

    def unregisterSearcher (self, searcher):
        self.searchers.remove(searcher)

    def _insert_menu(self):
        # Get the GtkUIManager
        manager = self._window.get_ui_manager()

        # Create a new action group
        self._action_group = gtk.ActionGroup("FileSearchPluginActions")
        self._action_group.add_actions([("FileSearch", "gtk-find", _("Search files..."),
                                         "<control><shift>F", _("Search in all files in a directory"),
                                         self.on_search_files_activate)])

        # Insert the action group
        manager.insert_action_group(self._action_group, -1)

        # Merge the UI
        self._ui_id = manager.add_ui_from_string(ui_str)

    def on_cboSearchTextEntry_changed (self, textEntry):
        """
        Is called when the search text entry is modified;
        disables the Search button whenever no search text is entered.
        """
        if textEntry.get_text() == "":
            self.tree.get_widget('btnSearch').set_sensitive(False)
        else:
            self.tree.get_widget('btnSearch').set_sensitive(True)

    def on_cbSelectFileTypes_toggled (self, checkbox):
        self.tree.get_widget('cboFileTypeList').set_sensitive( checkbox.get_active() )

    def on_cboSearchDirectoryEntry_changed (self, entry):
        text = entry.get_text()
        if text and self._autoCompleteList != None:
            path = os.path.dirname(text)
            start = os.path.basename(text)

            self._autoCompleteList.clear()
            try:
                files = dircache.listdir(path)[:]
            except OSError:
                return
            dircache.annotate(path, files)
            for f in files:
                if f.startswith(".") and not(start.startswith(".")):
                    # show hidden dirs only if explicitly requested by user
                    continue
                if f.startswith(start) and f.endswith("/"):
                    if path == "/":
                        match = path + f
                    else:
                        match = path + os.sep + f
                    self._autoCompleteList.append([match])

    def on_btnBrowse_clicked (self, button):
        fileChooser = gtk.FileChooserDialog(title=_("Select Directory"),
            parent=self._dialog,
            action=gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER,
            buttons = (gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_OK))
        fileChooser.set_default_response(gtk.RESPONSE_OK)
        fileChooser.set_local_only(onlyLocalPathes)
        fileChooser.set_filename( self.tree.get_widget('cboSearchDirectoryEntry').get_text() )

        response = fileChooser.run()
        if response == gtk.RESPONSE_OK:
            selectedDir = os.path.normpath( fileChooser.get_filename() ) + "/"
            self.tree.get_widget('cboSearchDirectoryEntry').set_text(selectedDir)
        fileChooser.destroy()

    def on_search_files_activate(self, action):
        self.openSearchDialog()

    def openSearchDialog (self, searchText = None, searchDirectory = None):
        gladeFile = os.path.join(os.path.dirname(__file__), "file-search.glade")
        self.tree = gtk.glade.XML(gladeFile, domain = APP_NAME)
        self.tree.signal_autoconnect(self)

        self._dialog = self.tree.get_widget('searchDialog')
        self._dialog.set_transient_for(self._window)

        #
        # set initial values for search dialog widgets
        #

        # find a nice default value for the search directory:
        searchDir = os.getcwdu()
        if self._lastDir != None:
            # if possible, use same directory as in last search:
            searchDir = self._lastDir
        else:
            # this is the first search since opening this Gedit window...
            if self._window.get_active_tab():
                # if ProjectMarker plugin has set a valid project root for the current file, use that:
                projectMarkerRootDir = self._window.get_active_tab().get_view().get_data("root_dir")
                if projectMarkerRootDir:
                    if projectMarkerRootDir.endswith("\n"):
                        projectMarkerRootDir = projectMarkerRootDir[:-1]
                    searchDir = projectMarkerRootDir
                else:
                    # otherwise, try to use directory of that file
                    currFilePath = self._window.get_active_tab().get_document().get_uri()
                    if currFilePath != None:
                        if onlyLocalPathes:
                            if currFilePath.startswith("file:///"):
                                searchDir = urllib.unquote(os.path.dirname(currFilePath[7:]))
                        else:
                            gFilePath = gio.File(currFilePath)
                            searchDir = gFilePath.get_parent().get_path()
            else:
                # there's no file open => fall back to Gedit's current working dir
                pass

        if searchDirectory is not None:
            searchDir = searchDirectory

        searchDir = os.path.normpath(searchDir) + "/"

        # ... and display that in the text field:
        self.tree.get_widget('cboSearchDirectoryEntry').set_text(searchDir)

        # Set up autocompletion for search directory:
        completion = gtk.EntryCompletion()
        self.tree.get_widget('cboSearchDirectoryEntry').set_completion(completion)
        self._autoCompleteList = gtk.ListStore(str)
        completion.set_model(self._autoCompleteList)
        completion.set_text_column(0)

        # Fill the drop-down part of the text field with recent dirs:
        cboLastDirs = self.tree.get_widget('cboSearchDirectoryList')
        cboLastDirs.set_model(self._lastDirs.store)
        cboLastDirs.set_text_column(0)

        # TODO: the algorithm to select a good default search dir could probably be improved...

        if searchText == None:
            searchText = ""
            if self._window.get_active_tab():
                currDoc = self._window.get_active_document()
                selectionIters = currDoc.get_selection_bounds()
                if selectionIters and len(selectionIters) == 2:
                    # Only use selected text if it doesn't span multiple lines:
                    if selectionIters[0].get_line() == selectionIters[1].get_line():
                        searchText = selectionIters[0].get_text(selectionIters[1])
        self.tree.get_widget('cboSearchTextEntry').set_text(searchText)

        cboLastSearches = self.tree.get_widget('cboSearchTextList')
        cboLastSearches.set_model(self._lastSearchTerms.store)
        cboLastSearches.set_text_column(0)

        # Fill list of file types:
        cboLastTypes = self.tree.get_widget('cboFileTypeList')
        cboLastTypes.set_model(self._lastTypes.store)
        cboLastTypes.set_text_column(0)

        if not(self._lastTypes.isEmpty()):
            typeListString = self._lastTypes.topEntry()
            self.tree.get_widget('cboFileTypeEntry').set_text(typeListString)


        # get default values for other controls from GConf:
        query = SearchQuery()
        query.loadDefaults(self.gclient)
        self.tree.get_widget('cbCaseSensitive').set_active(query.caseSensitive)
        self.tree.get_widget('cbRegExp').set_active(query.isRegExp)
        self.tree.get_widget('cbWholeWord').set_active(query.wholeWord)
        self.tree.get_widget('cbIncludeSubfolders').set_active(query.includeSubfolders)
        self.tree.get_widget('cbExcludeHidden').set_active(query.excludeHidden)
        self.tree.get_widget('cbExcludeBackups').set_active(query.excludeBackup)
        self.tree.get_widget('cbExcludeVCS').set_active(query.excludeVCS)
        self.tree.get_widget('cbSelectFileTypes').set_active(query.selectFileTypes)
        self.tree.get_widget('cboFileTypeList').set_sensitive( query.selectFileTypes )

        inputValid = False
        while not(inputValid):
            # display and run the search dialog (in a loop until all fields are correctly entered)
            result = self._dialog.run()
            if result != 1:
                self._dialog.destroy()
                return

            searchText = unicode(self.tree.get_widget('cboSearchTextEntry').get_text())
            searchDir = self.tree.get_widget('cboSearchDirectoryEntry').get_text()
            typeListString = self.tree.get_widget('cboFileTypeEntry').get_text()

            searchDir = os.path.expanduser(searchDir)
            searchDir = os.path.normpath(searchDir) + "/"

            if searchText == "":
                print "internal error: search text is empty!"
            elif not(os.path.exists(searchDir)):
                msgDialog = gtk.MessageDialog(self._dialog, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                    gtk.MESSAGE_ERROR, gtk.BUTTONS_OK, _("Directory does not exist"))
                msgDialog.format_secondary_text(_("The specified directory does not exist."))
                msgDialog.run()
                msgDialog.destroy()
            else:
                inputValid = True

        query.text = searchText
        query.directory = searchDir
        query.caseSensitive = self.tree.get_widget('cbCaseSensitive').get_active()
        query.isRegExp = self.tree.get_widget('cbRegExp').get_active()
        query.wholeWord = self.tree.get_widget('cbWholeWord').get_active()
        query.includeSubfolders = self.tree.get_widget('cbIncludeSubfolders').get_active()
        query.excludeHidden = self.tree.get_widget('cbExcludeHidden').get_active()
        query.excludeBackup = self.tree.get_widget('cbExcludeBackups').get_active()
        query.excludeVCS = self.tree.get_widget('cbExcludeVCS').get_active()
        query.selectFileTypes = self.tree.get_widget('cbSelectFileTypes').get_active()
        query.fileTypeString = typeListString

        self._dialog.destroy()

        #print "searching for '%s' in '%s'" % (searchText, searchDir)

        self._lastSearchTerms.add(searchText)
        self._lastDirs.add(searchDir)
        self._lastTypes.add(typeListString)
        query.storeDefaults(self.gclient)
        self._lastDir = searchDir

        searcher = FileSearcher(self._window, self, query)

class FileSearcher:
    """
    Gets a search query (and related info) and then handles everything related
    to that single file search:
    - creating a result window
    - starting grep (through SearchProcess)
    - displaying matches
    A FileSearcher object lives until its result panel is closed.
    """
    def __init__ (self, window, pluginHelper, query):
        self._window = window
        self.pluginHelper = pluginHelper
        self.pluginHelper.registerSearcher(self)
        self.query = query
        self.files = {}
        self.numMatches = 0
        self.numLines = 0
        self.wasCancelled = False
        self.searchProcess = None
        self._collapseAll = False # if true, new nodes will be displayed collapsed

        self._createResultPanel()
        self._updateSummary()

        #searchSummary = "<span size=\"smaller\" foreground=\"#585858\">searching for </span><span size=\"smaller\"><i>%s</i></span><span size=\"smaller\" foreground=\"#585858\"> in </span><span size=\"smaller\"><i>%s</i></span>" % (query.text, query.directory)
        searchSummary = "<span size=\"smaller\">" + _("searching for <i>%(keywords)s</i> in <i>%(folder)s</i>") % {'keywords': escapeMarkup(query.text), 'folder': escapeMarkup(gobject.filename_display_name(query.directory))} + "</span>"
        self.treeStore.append(None, [searchSummary, '', 0])

        self.searchProcess = SearchProcess(query, self)
        self._updateSummary()

    def handleResult (self, file, lineno, linetext):
        expandRow = False
        if not(self.files.has_key(file)):
            it = self._addResultFile(file)
            self.files[file] = it
            expandRow = True
        else:
            it = self.files[file]
        if self._collapseAll:
            expandRow = False
        self._addResultLine(it, lineno, linetext)
        if expandRow:
            path = self.treeStore.get_path(it)
            self.treeView.expand_row(path, False)
        self._updateSummary()

    def handleFinished (self):
        #print "(finished)"
        if not(self.tree):
            return

        self.searchProcess = None
        editBtn = self.tree.get_widget("btnModifyFileSearch")
        editBtn.hide()
        editBtn.set_label("gtk-edit")

        self._updateSummary()

        if self.wasCancelled:
            line = "<i><span foreground=\"red\">" + _("(search was cancelled)") + "</span></i>"
        elif self.numMatches == 0:
            line = "<i>" + _("(no matching files found)") + "</i>"
        else:
            line = "<i>" + ngettext("found %d match", "found %d matches", self.numMatches) % self.numMatches
            line += ngettext(" (%d line)", " (%d lines)", self.numLines) % self.numLines
            line += ngettext(" in %d file", " in %d files", len(self.files)) % len(self.files) + "</i>"
        self.treeStore.append(None, [line, '', 0])

    def _updateSummary (self):
        summary = ngettext("<b>%d</b> match", "<b>%d</b> matches", self.numMatches) % self.numMatches
        summary += "\n" + ngettext("in %d file", "in %d files", len(self.files)) % len(self.files)
        if self.searchProcess:
            summary += u"\u2026" # ellipsis character
        self.tree.get_widget("lblNumMatches").set_label(summary)


    def _createResultPanel (self):
        gladeFile = os.path.join(os.path.dirname(__file__), "file-search.glade")
        self.tree = gtk.glade.XML(gladeFile, 'hbxFileSearchResult', domain = APP_NAME)
        self.tree.signal_autoconnect(self)
        resultContainer = self.tree.get_widget('hbxFileSearchResult')

        resultContainer.set_data("filesearcher", self)

        tabTitle = self.query.text
        if len(tabTitle) > 30:
            tabTitle = tabTitle[:30] + u"\u2026" # ellipsis character 
        panel = self._window.get_bottom_panel()
        panel.add_item(resultContainer, tabTitle, "gtk-find")
        panel.activate_item(resultContainer)

        editBtn = self.tree.get_widget("btnModifyFileSearch")
        editBtn.set_label("gtk-stop")

        panel.set_property("visible", True)


        self.treeStore = gtk.TreeStore(str, str, int)
        self.treeView = self.tree.get_widget('tvFileSearchResult')
        self.treeView.set_model(self.treeStore)

        self.treeView.set_search_equal_func(resultSearchCb)

        tc = gtk.TreeViewColumn("File", gtk.CellRendererText(), markup=0)
        self.treeView.append_column(tc)

    def _addResultFile (self, filename):
        dispFilename = filename
        # remove leading search directory part if present:
        if dispFilename.startswith(self.query.directory):
            dispFilename = dispFilename[ len(self.query.directory): ]
            dispFilename.lstrip("/")
        dispFilename = gobject.filename_display_name(dispFilename)

        (directory, file) = os.path.split( dispFilename )
        if directory:
            directory = os.path.normpath(directory) + "/"

        line = "%s<b>%s</b>" % (escapeMarkup(directory), escapeMarkup(file))
        it = self.treeStore.append(None, [line, filename, 0])
        return it

    def _addResultLine (self, it, lineno, linetext):
        addTruncationMarker = False
        if len(linetext) > 1000:
            linetext = linetext[:1000]
            addTruncationMarker = True

        if not(self.query.isRegExp):
            (linetext, numLineMatches) = escapeAndHighlight(linetext, self.query.text, self.query.caseSensitive, self.query.wholeWord)
            self.numMatches += numLineMatches
        else:
            linetext = escapeMarkup(linetext)
            self.numMatches += 1
        self.numLines += 1

        if addTruncationMarker:
            linetext += "</span><span size=\"smaller\"><i> [...]</i>"
        line = "<b>%d:</b> <span foreground=\"blue\">%s</span>" % (lineno, linetext)
        self.treeStore.append(it, [line, None, lineno])

    def on_row_activated (self, widget, path, col):
        selectedIter = self.treeStore.get_iter(path)
        parentIter = self.treeStore.iter_parent(selectedIter)
        lineno = 0
        if parentIter == None:
            file = self.treeStore.get_value(selectedIter, 1)
        else:
            file = self.treeStore.get_value(parentIter, 1)
            lineno = self.treeStore.get_value(selectedIter, 2)

        if not(file):
            return

        uri="file://%s" % urllib.quote(file)
        gedit.commands.load_uri(window=self._window, uri=uri, line_pos=lineno)
        if lineno > 0: # this is necessary for Gedit 2.17.4 and older (see gbo #401219)
            currDoc = self._window.get_active_document()
            currDoc.goto_line(lineno - 1) # -1 required to work around gbo #503665
            currView = gedit.tab_get_from_document(currDoc).get_view()
            currView.scroll_to_cursor()

        # use an Idle handler so the document has time to load:  
        gobject.idle_add(self.onDocumentOpenedCb, (lineno > 0))

    def on_btnClose_clicked (self, button):
        self.destroy()

    def destroy (self):
        if self.searchProcess:
            self.searchProcess.destroy()
            self.searchProcess = None

        panel = self._window.get_bottom_panel()
        resultContainer = self.tree.get_widget('hbxFileSearchResult')
        resultContainer.set_data("filesearcher", None)
        panel.remove_item(resultContainer)
        self.treeStore = None
        self.treeView = None
        self._window = None
        self.files = {}
        self.tree = None
        self.pluginHelper.unregisterSearcher(self)

    def on_btnModify_clicked (self, button):
        if not(self.searchProcess):
            # edit search params
            pass
        else:
            # cancel search
            self.searchProcess.cancel()
            self.wasCancelled = True

    def on_tvFileSearchResult_button_press_event (self, treeview, event):
        if event.button == 3:
            path = treeview.get_path_at_pos(int(event.x), int(event.y))
            if path != None:
                treeview.grab_focus()
                treeview.set_cursor(path[0], path[1], False)

                menu = gtk.Menu()
                mi = gtk.ImageMenuItem("gtk-copy")
                mi.connect_object("activate", FileSearcher.onCopyActivate, self, treeview, path[0])
                mi.show()
                menu.append(mi)

                mi = gtk.SeparatorMenuItem()
                mi.show()
                menu.append(mi)

                mi = gtk.MenuItem(_("Expand All"))
                mi.connect_object("activate", FileSearcher.onExpandAllActivate, self, treeview)
                mi.show()
                menu.append(mi)

                mi = gtk.MenuItem(_("Collapse All"))
                mi.connect_object("activate", FileSearcher.onCollapseAllActivate, self, treeview)
                mi.show()
                menu.append(mi)

                menu.popup(None, None, None, event.button, event.time)
                return True
        else:
            return False

    def onCopyActivate (self, treeview, path):
        it = treeview.get_model().get_iter(path)
        markupText = treeview.get_model().get_value(it, 0)
        plainText = pango.parse_markup(markupText, u'\x00')[1]

        clipboard = gtk.clipboard_get()
        clipboard.set_text(plainText)
        clipboard.store()

    def onExpandAllActivate (self, treeview):
        self._collapseAll = False
        treeview.expand_all()

    def onCollapseAllActivate (self, treeview):
        self._collapseAll = True
        treeview.collapse_all()

    def onDocumentOpenedCb (self, doScroll):
        currDoc = self._window.get_active_document()

        if doScroll:
            # workaround to scroll to cursor position when opening file into window of "Unnamed Document":
            currView = gedit.tab_get_from_document(currDoc).get_view()
            currView.scroll_to_cursor()

        # highlight matches in opened document:
        flags = 0
        if self.query.caseSensitive:
            flags |= 4
        if self.query.wholeWord:
            flags |= 2

        currDoc.set_search_text(self.query.text, flags)
        return False


def resultSearchCb (model, column, key, it):
    """Callback function for searching in result list"""
    lineText = model.get_value(it, column)
    plainText = pango.parse_markup(lineText, u'\x00')[1] # remove Pango markup

    # for file names, add a leading slash before matching:
    parentIter = model.iter_parent(it)
    if parentIter == None and not(plainText.startswith("/")):
        plainText = "/" + plainText

    # if search text contains only lower-case characters, do case-insensitive matching:
    if key.islower():
        plainText = plainText.lower()

    # if the line contains the search text, it matches:
    if plainText.find(key) >= 0:
        return False

    # line doesn't match:
    return True


def escapeMarkup (origText):
    "Replaces Pango markup special characters with their escaped replacements"
    text = origText
    text = text.replace('&', '&amp;')
    text = text.replace('<', '&lt;')
    text = text.replace('>', '&gt;')
    return text

def escapeAndHighlight (origText, searchText, caseSensitive, wholeWord):
    """
    Replaces Pango markup special characters, and adds highlighting markup
    around text fragments that match searchText.
    """

    # split origText by searchText; the resulting list will contain normal text
    # and matching text interleaved (if two matches are adjacent in origText,
    # they will be separated by an empty string in the resulting list).
    matchLen = len(searchText)
    fragments = []
    startPos = 0
    text = origText[:]
    pattern = buildQueryRE(searchText, caseSensitive, wholeWord)
    while True:
        m = pattern.search(text, startPos)
        if m is None:
            break
        pos = m.start()

        preStr = origText[startPos:pos]
        matchStr = origText[pos:pos+matchLen]
        fragments.append(preStr)
        fragments.append(matchStr)
        startPos = pos+matchLen
    fragments.append(text[startPos:])

    numMatches = (len(fragments) - 1) / 2

    if len(fragments) < 3:
        print "too few fragments (got only %d)" % len(fragments)
        print "text: '%s'" % origText.encode("utf8", "replace")
        numMatches += 1
    #assert(len(fragments) > 2)

    # join fragments again, adding markup around matches:
    retText = ""
    highLight = False
    for f in fragments:
        f = escapeMarkup(f)
        if highLight:
            retText += "<span background=\"#FFFF00\">%s</span>" % f
        else:
            retText += f
        highLight = not(highLight)
    return (retText, numMatches)

########NEW FILE########
__FILENAME__ = FindInFiles
import gedit
import gtk
import os
import gconf

class ResultsView(gtk.VBox):
    def __init__(self, geditwindow):
        gtk.VBox.__init__(self)

        # We have to use .geditwindow specifically here (self.window won't work)
        self.geditwindow = geditwindow

        # Save the document's encoding in a variable for later use (when opening new tabs)
        try: self.encoding = gedit.encoding_get_current()
        except: self.encoding = gedit.gedit_encoding_get_current()

        # Preferences (we'll control them with toggled checkboxes)
        self.ignore_comments = False
        self.case_sensitive = False
        self.scan_logs = False

        # We save the grep search result data in a ListStore
        # Format:  ID (COUNT)  |  FILE (without path)  |  LINE  |  FILE (with path)
        #    Note: We use the full-path version when opening new tabs (when necessary)
        self.search_data = gtk.ListStore(str, str, str, str)

        # Create a list (a "tree view" without children) to display the results
        self.results_list = gtk.TreeView(self.search_data)

        # Get the selection attribute of the results_list and assign a couple of properties
        tree_selection = self.results_list.get_selection()

        # Properties...
        tree_selection.set_mode(gtk.SELECTION_SINGLE)
        tree_selection.connect("changed", self.view_result)

        # Create the cells for our results list treeview
        #   Note:  We don't need to create a cell or text renderer
        #          for the full-path filename variable because we
        #          won't actually be displaying that information.
        cell_id = gtk.TreeViewColumn("#")
        cell_line_number = gtk.TreeViewColumn("Line")
        cell_filename = gtk.TreeViewColumn("File")

        # Now add the cell objects to the results_list treeview object
        self.results_list.append_column(cell_id)
        self.results_list.append_column(cell_line_number)
        self.results_list.append_column(cell_filename)

        # Create text-rendering objects so that we can actually
        # see the data that we'll put into the objects
        text_renderer_id = gtk.CellRendererText()
        text_renderer_filename = gtk.CellRendererText()
        text_renderer_line_number = gtk.CellRendererText()

        # Pack the text renderer objects into the cell objects we created
        cell_id.pack_start(text_renderer_id, True)
        cell_filename.pack_start(text_renderer_filename, True)
        cell_line_number.pack_start(text_renderer_line_number, True)

        # Now set the IDs to each of the text renderer objects and set them to "text" mode
        cell_id.add_attribute(text_renderer_id, "text", 0)
        cell_filename.add_attribute(text_renderer_filename, "text", 1)
        cell_line_number.add_attribute(text_renderer_line_number, "text", 2)

        # Create a scrolling window object and add our results_list treeview object to it
        scrolled_window = gtk.ScrolledWindow()
        scrolled_window.add(self.results_list)

        # Pack in the scrolled window object
        self.pack_start(scrolled_window)

        # Create a "Find" button; we'll pack it into an HBox in a moment...
        button_find = gtk.Button("Find")
        button_find.connect("clicked", self.button_press)
        # Create a "search bar" to type the search string into; we'll pack it
        # into the HBox as well...
        self.search_form = gtk.Entry()
        self.search_form.connect("activate", self.button_press)

        # Here's the HBox I mentioned...
        search_box = gtk.HBox(False, 0)
        search_box.pack_start(self.search_form, False, False)
        search_box.pack_start(button_find, False, False)

        # Pack the search box (search bar + Find button) into the side panel
        self.pack_start(search_box, False, False)

        # Create a check box to decide whether or not to ignore comments
        self.check_ignore = gtk.CheckButton("Ignore comments")
        self.check_ignore.connect("toggled", self.toggle_ignore)
        # Pack it in...
        self.pack_start(self.check_ignore, False, False)

        # Create a check box to determine whether to pay attention to case
        self.check_case = gtk.CheckButton("Case Sensitive")
        self.check_case.connect("toggled", self.toggle_case)
        # Pack it in...
        self.pack_start(self.check_case, False, False)

        # Create a check box to determine whether to pay attention to case
        self.check_logs = gtk.CheckButton("Scan log/bak files")
        self.check_logs.connect("toggled", self.toggle_logs)
        # Pack it in...
        self.pack_start(self.check_logs, False, False)

        # Show all UI elements
        self.show_all()

    # A click of the "Ignore comments" check box calls to this function
    def toggle_ignore(self, widget):
        self.ignore_comments = not self.ignore_comments

    # A click of the "Case sensitive" check box calls to this function
    def toggle_case(self, widget):
        self.case_sensitive = not self.case_sensitive

    # A click of the "Scan log/bak files" check box calls to this function
    def toggle_logs(self, widget):
        self.scan_logs = not self.scan_logs

    # A call goes to view_result whenever the user clicks on
    # one of the results after a search.  In response to the
    # click, we'll go to that file's tab (or open it in a
    # new tab if they since closed that tab) and scroll to
    # the line that the result appears in.
    def view_result(self, widget):
        # Get the selection object
        tree_selection = self.results_list.get_selection()

        # Get the model and iterator for the row selected
        (model, iterator) = tree_selection.get_selected()

        if (iterator):
            # Get the absolute path of the file
            absolute_path = model.get_value(iterator, 3)

            # Get the line number
            line_number = int(model.get_value(iterator, 2)) - 1

            # Get all open tabs
            documents = self.geditwindow.get_documents()

            # Loop through the tabs until we find which one matches the file
            # If we don't find it, we'll create it in a new tab afterwards.
            for each in documents:

                if (each.get_uri().replace("file://", "") == absolute_path):
                    # This sets the active tab to "each"
                    self.geditwindow.set_active_tab(gedit.tab_get_from_document(each))
                    each.goto_line(line_number)

                    # Get the bounds of the document
                    (start, end) = each.get_bounds()

                    self.geditwindow.get_active_view().scroll_to_iter(end, 0.0)

                    x = each.get_iter_at_line_offset(line_number, 0)
                    self.geditwindow.get_active_view().scroll_to_iter(x, 0.0)

                    return

            # If we got this far, then we didn't find the file open in a tab.
            # Thus, we'll want to go ahead and open it...
            self.geditwindow.create_tab_from_uri("file://" + absolute_path, self.encoding, int(model.get_value(iterator, 2)), False, True)

    # Clicking the "Find" button or hitting return in the search area calls button_press.
    # This function, of course, searches each open document for the search query and
    # displays the results in the side panel.
    def button_press(self, widget):
        # Get all open tabs
        documents = self.geditwindow.get_documents()

        # Make sure there are documents to search...
        if (len(documents) == 0):
            return # Can't search nothing.  :P

        # Let's also make sure the user entered a search string
        if (len(self.search_form.get_text()) <= 0):
            return

        # Create a string that will hold all of the filenames;
        # we'll append it to the grep command string.
        string = ""

        fbroot = self.get_filebrowser_root()
        if fbroot != "" and fbroot is not None:
          location = fbroot.replace("file://", "")
        else:
          return


        #if (not)
        #" -type f -not -regex '.*/.svn.*'"
        #" -type f -not -regex '.*/(.svn|.log|.bak).*'"
        search_filter = ' -type f | egrep -v ".*(\.svn.*|\.git.*)"'
        if (not self.scan_logs):
            search_filter = ' -type f | egrep -v ".*(\.svn.*|\.git.*|\.log|\.bak)"'

        hooray = os.popen ("find " + location + search_filter).readlines()
        for hip in hooray:
          string += " '%s'" % hip[:-1]

        # str_case_operator will hold the "case insensitive" command if necessary
        str_case_operator = ""
        if (not self.case_sensitive):
            str_case_operator = " -i"

        # Create a pipe and call the grep command, then read it
        pipe = os.popen("grep -n -H" + str_case_operator + " %s %s" % (self.search_form.get_text(), string))
        data = pipe.read()
        results = data.split("\n")

        # Clear any current results from the side panel
        self.search_data.clear()

        # Process each result...
        for each in results:
            # Each result will look like this:
            #   FILE (absolute path):Line number:string
            #
            #   ... where string is the line that the search data was found in.
            pieces = each.split(":", 2)

            if (len(pieces) == 3):
                line_number = pieces[1]
                filename = os.path.basename(pieces[0]) # We just want the filename, not the path
                string = pieces[2].lstrip(" ") # Remove leading whitespace

                # If we want to ignore comments, then we'll make sure it doesn't start with # or //
                if (self.ignore_comments):
                    if (not string.startswith("#") and not string.startswith("//")):
                        self.search_data.append( ("%d" % (len(self.search_data) + 1), filename, line_number, pieces[0]) )
                else:
                    self.search_data.append( ("%d" % (len(self.search_data) + 1), filename, line_number, pieces[0]) )

    def get_filebrowser_root(self):
        base = u'/apps/gedit-2/plugins/filebrowser/on_load'
        client = gconf.client_get_default()
        client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
        path = os.path.join(base, u'virtual_root')
        val = client.get(path)
        if val is not None:
          #also read hidden files setting
          base = u'/apps/gedit-2/plugins/filebrowser'
          client = gconf.client_get_default()
          client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
          path = os.path.join(base, u'filter_mode')
          try:
            fbfilter = client.get(path).get_string()
          except AttributeError:
            fbfilter = "hidden"
          if fbfilter.find("hidden") == -1:
            self._show_hidden = True
          else:
            self._show_hidden = False
          return val.get_string()

class PluginHelper:
    def __init__(self, plugin, window):
        self.window = window
        self.plugin = plugin

        self.ui_id = None

        self.add_panel(window)

    def deactivate(self):
        self.remove_menu_item()

        self.window = None
        self.plugin = None

    def update_ui(self):
        pass

    def add_panel(self, window):
        panel = self.window.get_side_panel()

        self.results_view = ResultsView(window)

        image = gtk.Image()
        image.set_from_stock(gtk.STOCK_DND_MULTIPLE, gtk.ICON_SIZE_BUTTON)
        self.ui_id = panel.add_item(self.results_view, "Find in Open Documents", image)

    def remove_menu_item(self):
        panel = self.window.get_side_panel()

        panel.remove_item(self.results_view)

class FindInDocumentsPlugin(gedit.Plugin):
    def __init__(self):
        gedit.Plugin.__init__(self)
        self.instances = {}

    def activate(self, window):
        self.instances[window] = PluginHelper(self, window)

    def deactivate(self, window):
        self.instances[window].deactivate()

    def update_ui(self, window):
        self.instances[window].update_ui()


########NEW FILE########
__FILENAME__ = FindInProject
import gtk
from FindInProjectWindow import FindInProjectWindow

ui_str="""<ui>
<menubar name="MenuBar">
  <menu name="SearchMenu" action="Search">
    <placeholder name="SearchOps_0">
      <menuitem name="FindInProject" action="FindInProject"/>
    </placeholder>
  </menu>
</menubar>
</ui>
"""
class FindInProjectPluginInstance:
    def __init__(self, window):
        self._window = window
        self._search_window = FindInProjectWindow(self._window)
        self.add_menu()

    def deactivate(self):
        self.window = None
        self.plugin = None
        self.remove_menu()

    def add_menu(self):
        self._action_group = gtk.ActionGroup("FindInProjectActions")
        self._action_group.add_actions([('FindInProject', gtk.STOCK_EDIT, 'Find in project...', '<Ctrl><Shift>f', 'Search in the project', self.show_window)])
        self.manager = self._window.get_ui_manager()
        self.manager.insert_action_group(self._action_group, -1)
        self._ui_id = self.manager.add_ui_from_string(ui_str)

    def remove_menu(self):
        manager = self._window.get_ui_manager()
        manager.remove_ui(self._ui_id)
        manager.remove_action_group(self._action_group)
        manager.ensure_update()

    def show_window(self, window):
        self._search_window.init()


########NEW FILE########
__FILENAME__ = FindInProjectParser
"""
    Parse the result of ack into html
"""

import os
import subprocess
import cgi
import re

class FindInProjectParser:

    def __init__(self, query, path, context=True, regex=False, ignorecase=False, filetype=None):
        if filetype:
            filetype = filetype.replace(' ', '').split(',')
        ack = ""
        if os.popen("which ack-grep").readlines():
            ack = "ack-grep"
        elif os.popen("which ack").readlines():
            ack = "ack"

        if ack:
            arg = [ack, '--color', '--color-filename=reset', '--color-match=yellow', query]
            if context:
                arg.extend(['-C', '2'])
            if not regex:
                arg.append('-Q')
            if ignorecase:
                arg.append('-i')
            if filetype:
                filetype = ['.' + f for f in filetype]
                arg.extend(['--type-set', 'custom=%s' % ','.join(filetype), '--type=custom'])
            process = subprocess.Popen(arg, stdout=subprocess.PIPE, cwd=path)
            self.raw = cgi.escape(process.communicate()[0])
            self.raw = self.raw.replace('\x1b[0m\x1b[K','')
        else:
            arg = ['grep', '-R', '-n', '-H', '-I', query, '.', '--color=force']
            if context:
                arg.extend(['-C', '2'])
            if regex:
                arg.append('-E')
            if ignorecase:
                arg.append('-i')
            if filetype:
                arg.extend(['--include=*.%s' % t for t in filetype])
            process = subprocess.Popen(arg, stdout=subprocess.PIPE, cwd=path,env={"GREP_COLORS": "ms=33:mc=01;31:sl=:cx=:fn=0:ln=:bn=32:se="})
            self.raw = cgi.escape(process.communicate()[0])
            self.raw = self.raw.replace('\x1b[K', '')
        self.filelist = []
        self.matches = 0

    def status(self):
        return (self.matches, len(self.filelist))

    def html(self):
        blocks = self.__tuple()
        result = ""
        if not blocks or len(blocks[0]) == 0:
            return result
        for block in blocks:
            table = """
<table>
    <colgroup class="line-number"></colgroup>
    <colgroup class="code"></colgroup>
    <thead onclick="javascript:toggle(this)">
        <tr>
            <td class="filename" colspan="2"><span class="open">&#9660;</span>&nbsp;%s</td>
        </tr>
    </thead>
    <tbody>
            """ % os.path.normpath(block[0][0])
            for line in block:
                matchclass = ""
                if line[2]:
                    matchclass = ' match'
                table += """
        <tr onclick="javascript:goto('%s', %s)">
            <td class="line-number%s">%s</td>
            <td class="code%s">%s</td>
        </tr>
                """ % (line[0], line[1], matchclass, line[1], matchclass, line[3])
            table += """
    </tbody>
</table>
            """
            result += table
        return result

    def __tuple(self):
        #\x1b[0mew\x1b[0m-64-
        #\x1b[0mew\x1b[0m-65-
        #\x1b[0mew\x1b[0m:66:if __name__ == "\x1b[33m__main__\x1b[0m":\x1b[0m\x1b[K
        #\x1b[0mew\x1b[0m-67-    Eastwind()
        #\x1b[0mew\x1b[0m-68-

        groups = re.split('(?<=\n)--\n', self.raw)
        if groups and len(groups) == 1:
            filename_hash = {}
            for l in groups[0].split('\n'):
                if not l:
                    continue
                meta = self.__metadata(l)
                if meta[0] in filename_hash:
                    filename_hash[meta[0]].append(meta)
                else:
                    filename_hash[meta[0]] = [meta]
            return [filename_hash[k] for k in filename_hash.keys()]
        else:
            return [[self.__metadata(l) for l in g.split('\n') if l != ''] for g in groups]

    def __metadata(self, line):
        match = re.match("^\\x1b\[0m(.*?)\\x1b\[0?m[:-](\d+)([:-])(.*)", line)
        matched = (match.group(3) == ':')
        clear = match.group(4).replace(' ', '&nbsp;')
        clear = re.sub("\\x1b\[33m(.*?)\\x1b\[0?m", '<span class="highlight">\\1</span>', clear)
        if matched:
            self.matches = self.matches + 1
        if not match.group(1) in self.filelist:
            self.filelist.append(match.group(1))
        return (match.group(1), match.group(2), matched, clear)


########NEW FILE########
__FILENAME__ = FindInProjectUtil
"""
    Utility functions for find in project
"""

import gconf
import os

def filebrowser_root():
    base = u'/apps/gedit-2/plugins/filebrowser/on_load'
    client = gconf.client_get_default()
    client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
    path = os.path.join(base, u'virtual_root')
    val = client.get(path)
    if val is not None:
        return val.get_string()


########NEW FILE########
__FILENAME__ = FindInProjectWindow
import gtk, gedit
import gobject
import webkit
import pygtk
import os
import re
from urllib import url2pathname
from FindInProjectParser import FindInProjectParser
from FindInProjectUtil import filebrowser_root

style_str="""<style>
.match {
  color: black;
}
tbody {
  font-family: Consolas, Monospace,"Courier New", courier, monospace;
  color: #a0a0a0;
  word-wrap: break-word;
}
table {
  margin: 10px;
  width: 97%;
  table-layout: fixed;
  border-collapse: collapse;
}
.filename {
  background-color: #D2D2D2;
  font-weight: bold;
}
.highlight {
  background-color: #yellow;
}
thead td {
  padding: 6px 10px;
  text-overflow: ellipsis;
  overflow: hidden;
}
tbody tr, thead {
  cursor: hand;
}
.line-number{
  width: 43px;
  background: #D2D2D2;
  text-align:right;
  padding: 4px 6px;
}
tbody tr:nth-child(even) td:nth-child(2){
  background: #efefef;
}
</style>
<script type="text/javascript">
function goto(file, line) {
  window.location = "gedit:///" + file + "?line=" + line;
}
function toggle(dom) {
  triangle = dom.getElementsByTagName('span')[0];
  if(triangle.className == 'open') {
    dom.parentNode.tBodies[0].style.display = 'none';
    triangle.innerHTML = '&#9654;';
    triangle.className = 'close';
  } else {
    dom.parentNode.tBodies[0].style.display = '';
    triangle.innerHTML = '&#9660;';
    triangle.className = 'open';
  }
}
</script>"""

class FindInProjectBrowser(webkit.WebView):
    def __init__(self):
        webkit.WebView.__init__(self)

class FindInProjectWindow:
    protocol = re.compile(r'(?P<protocol>^gedit:\/\/)(?P<file>.*?)\?line=(?P<line>.*?)$')

    def __init__(self, gedit_window):
        self._gedit_window = gedit_window
        self._builder = gtk.Builder()
        self._builder.add_from_file(os.path.join(os.path.dirname( __file__ ), "window.glade"))
        self._window = self._builder.get_object("find-in-project")
        self._browser = FindInProjectBrowser()
        self._browser.connect("navigation-requested", self.goto_file)
        self._window.connect("delete_event", self._window.hide_on_delete)
        self._window.connect("key-release-event", self.window_key)
        self._searchbox = self._builder.get_object("searchbox")
        self._searchbox.connect("key-release-event", self.box_key)
        self._searchbox.connect("icon-release", self.box_clear)
        self._builder.get_object("search-button").connect("clicked", self.search)
        self._builder.get_object("placeholder").add(self._browser)
        self._history = gtk.ListStore(gobject.TYPE_STRING)
        self._completion = gtk.EntryCompletion()
        self._completion.set_model(self._history)
        self._searchbox.set_completion(self._completion)
        self._completion.set_text_column(0)
        self._message = self._builder.get_object("message")
        self._ignore_case = self._builder.get_object("ignore-case")
        self._show_context = self._builder.get_object("show-context")
        self._use_regex = self._builder.get_object("use-regex")
        self._extbox = self._builder.get_object("extbox")
        self._extbox.connect("icon-release", self.box_clear)
        self._extbox.connect("key-release-event", self.box_key)
        self._spinner = self._builder.get_object("spinner")
        self._searched = []

    def init(self):
        self._window.deiconify()
        self._window.show_all()
        self._searchbox.grab_focus()
        self._spinner.hide()

    def goto_file(self, page, frame, request):
        match = self.protocol.search(request.get_uri())
        if match:
            file_uri = self._path + match.group('file')
            line_number = match.group('line')
            gedit.commands.load_uri(self._gedit_window, file_uri, gedit.encoding_get_current(), int(line_number))
            # dirty fix to make the file roll to a certain line
            gedit.commands.load_uri(self._gedit_window, file_uri, gedit.encoding_get_current(), int(line_number))
            self._window.hide()
            return True

    def window_key(self, widget, event):
        if event.keyval == gtk.keysyms.Escape:
            self._window.hide()

    def box_clear(self, widget, event, nid):
        widget.set_text('')
        widget.grab_focus()

    def box_key(self, widget, event):
        if event.keyval == gtk.keysyms.Return:
            self._builder.get_object("search-button").grab_focus()
            self.search(event)

    def search(self, event):
        query = self._searchbox.get_text()
        if not query:
            return True
        self._message.set_text('Loading...')
        self._spinner.show()
        self._spinner.start()
        gtk.gdk.window_process_all_updates()
        self._path = filebrowser_root()
        if not query in self._searched:
            self._history.set(self._history.append(), 0, query)
            self._searched.append(query)
        parser = FindInProjectParser(query, url2pathname(self._path)[7:], context=self._show_context.get_active(), regex=self._use_regex.get_active(), ignorecase=self._ignore_case.get_active(), filetype=self._extbox.get_text())
        self._browser.load_string(style_str + parser.html(), "text/html", "utf-8", "about:")
        self._message.set_text('%d line(s) matched in %d file(s)' % parser.status())
        self._spinner.stop()
        self._spinner.hide()


########NEW FILE########
__FILENAME__ = folding
# -*- coding: utf-8 -*-
import gtk
import gedit

ui_str = """<ui>
	<menubar name="MenuBar">
		<menu name="ToolsMenu" action="Tools">
			<placeholder name="ToolsOps_2">
				<menuitem name="Folding" action="FoldingPy"/>
			</placeholder>
		</menu>
	</menubar>
</ui>
"""
	
class FoldingPyWindowHelper():
	def __init__(self, plugin, window):
		self._window = window
		self._plugin = plugin
		self._insert_menu()
		self.update_ui()

	def deactivate(self):
		self._remove_menu()
		self._window = None
		self._plugin = None
		self._action_group = None

	def _insert_menu(self):
		manager = self._window.get_ui_manager()
		self._action_group = gtk.ActionGroup("FoldingPyPluginActions")
		self._action_group.add_actions(
			[
				(
					"FoldingPy", None, "Fold",
					"<Alt>Z", "Fold",
					self.fold
				)
			],
		)
		manager.insert_action_group(self._action_group, -1)
		self._ui_id = manager.add_ui_from_string(ui_str)

	def _remove_menu(self):
		manager = self._window.get_ui_manager()
		manager.remove_ui(self._ui_id)
		manager.remove_action_group(self._action_group)
		manager.ensure_update()

	def update_ui(self):
		self._action_group.set_sensitive(self._window.get_active_document() != None)
		self.doc=self._window.get_active_document()
		if self.doc:
			self.view=self._window.get_active_view()
			self.view.connect('key-press-event', self.fold_off)
			
			table=self.doc.get_tag_table()
			self.fld=table.lookup('fld')
			if self.fld==None:
				self.fld=self.doc.create_tag('fld',foreground="#333333",paragraph_background="#aadc5c")
			self.inv=table.lookup('inv')
			if self.inv==None:
				self.inv=self.doc.create_tag('inv',invisible=True)

	def detect_sps(self,sps):
		sps_lstrip=sps.lstrip()
		i=sps.index(sps_lstrip)
		sps=sps[:i]
		return sps.count(' ')+sps.count('\t')*self.view.get_tab_width()

	def fold_off(self,widget,e=None):
		if e.hardware_keycode==53 and self.keycode==64:
			s,e=self.doc.get_bounds()
			self.doc.remove_tag(self.fld,s,e)
			self.doc.remove_tag(self.inv,s,e)
			self.keycode=53
			print "SimpleFolding plugin: remove all fold"
		else:
			self.keycode=e.hardware_keycode

	def fold(self, action):
		a=self.doc.get_iter_at_mark(self.doc.get_insert())
		if a.has_tag(self.fld):
			try:
				a.set_line_offset(0)
				b=a.copy()
				b.forward_line()
				self.doc.remove_tag(self.fld,a,b)
				a.forward_to_tag_toggle(self.inv)
				b.forward_to_tag_toggle(self.inv)
				self.doc.remove_tag(self.inv,a,b)
				print "SimpleFolding plugin: remove one fold"
			except:
				pass

		elif len(self.doc.get_selection_bounds())==2:
			a,c=self.doc.get_selection_bounds()
			b=a.copy()
			a.set_line_offset(0)
			b.forward_line()
			c.forward_line()
			self.doc.apply_tag(self.fld,a,b)
			self.doc.remove_tag(self.fld,b,c)
			self.doc.remove_tag(self.inv,b,c)
			self.doc.apply_tag(self.inv,b,c)
			print "SimpleFolding plugin: create fold by selection"

		else:
			s=a.copy()
			s.set_line_offset(0)
			line = s.get_line()
			e=s.copy()
			e.forward_line()
			t=s.get_text(e)
			if t.strip()!="":
				main_indent = self.detect_sps(s.get_text(e))
				ns=s.copy()
				fin=ns.copy()
				while 1==1:
					if ns.forward_line():
						ne=ns.copy()
						if ne.get_char()=="\n":
							continue
						ne.forward_to_line_end()
						text=ns.get_text(ne)
						if text.strip()=="":
							continue
						child_indent=self.detect_sps(text)
						if child_indent <= main_indent:
							break
						else:
							line=ns.get_line()
						fin=ns.copy()
						fin.set_line(line)
						fin.forward_line()
					else:
						fin=ne.copy()
						fin.forward_to_end()
						line=fin.get_line()
						break
				
				if s.get_line()<line:
					self.doc.apply_tag(self.fld,s,e)
					self.doc.remove_tag(self.fld,e,fin)
					self.doc.remove_tag(self.inv,e,fin)
					self.doc.apply_tag(self.inv,e,fin)
					print "SimpleFolding plugin: create fold by indent"


class FoldingPyPlugin(gedit.Plugin):
	def __init__(self):
		gedit.Plugin.__init__(self)
		self._instances = {}
	def activate(self, window):
		self._instances[window] = FoldingPyWindowHelper(self, window)
	def deactivate(self, window):
		self._instances[window].deactivate()
		del self._instances[window]
	def update_ui(self, window):
		self._instances[window].update_ui()

########NEW FILE########
__FILENAME__ = config
import gconf
import pygtk, gtk, os
import util
pygtk.require('2.0')

class FuzzyOpenConfigWindow:
  def __init__(self):
    self._builder = gtk.Builder()
    self._builder.add_from_file(os.path.join(os.path.dirname( __file__ ), "config.glade"))
    self._window = self._builder.get_object('configwindow')
    self._use_git = self._builder.get_object('use-git')
    self._ignore_ext = self._builder.get_object('ignore-ext')
    self._ignore_case = self._builder.get_object('ignore-case')
    self._ignore_space = self._builder.get_object('ignore-space')
    self._ignore_ext.set_text(util.config('ignore_ext'))
    self._use_git.set_active(util.config('use_git'))
    self._ignore_case.set_active(util.config('ignore_case'))
    self._ignore_space.set_active(util.config('ignore_space'))
    self._ignore_ext.connect('key-release-event', self.on_ignore_ext)
    self._use_git.connect('toggled', self.on_use_git)
    self._ignore_case.connect('toggled', self.on_ignore_case)
    self._ignore_space.connect('toggled', self.on_ignore_space)
    self._builder.get_object('done').connect('clicked', self.on_click)
    self._window.show_all()

  def on_click(self, widget):
    self._window.emit('destroy')

  def on_ignore_ext(self, widget, event):
    util.config('ignore_ext', self._ignore_ext.get_text())

  def on_use_git(self, widget):
    util.config('use_git', self._use_git.get_active())

  def on_ignore_case(self, widget):
    util.config('ignore_case', self._ignore_case.get_active())

  def on_ignore_space(self, widget):
    util.config('ignore_space', self._ignore_space.get_active())


########NEW FILE########
__FILENAME__ = fuzzyopen
import gedit, gtk, gio
import gconf
import pygtk
pygtk.require('2.0')
import os, os.path, gobject
from urllib import pathname2url, url2pathname
from suggestion import FuzzySuggestion
from util import debug
import util

app_string = "Fuzzy open"

ui_str="""<ui>
<menubar name="MenuBar">
  <menu name="FileMenu" action="File">
    <placeholder name="FileOps_2">
      <menuitem name="FuzzyOpen" action="FuzzyOpenAction"/>
    </placeholder>
  </menu>
</menubar>
</ui>
"""

# essential interface
class FuzzyOpenPluginInstance:
  def __init__( self, plugin, window ):
    self._window = window
    self._plugin = plugin
    self._encoding = gedit.encoding_get_current()
    self._rootpath = os.getcwd()
    self._rootdir = "file://" + self._rootpath
    self._show_hidden = False
    self._suggestion = None
    self._git = False
    self._liststore = None
    self._last_pattern = ""
    self._init_glade()
    self._insert_menu()

  def deactivate( self ):
    self._remove_menu()
    self._action_group = None
    self._window = None
    self._plugin = None
    self._liststore = None;

  def update_ui( self ):
    return

  # MENU STUFF
  def _insert_menu( self ):
    manager = self._window.get_ui_manager()
    self._action_group = gtk.ActionGroup( "FuzzyOpenPluginActions" )
    fuzzyopen_menu_action = gtk.Action( name="FuzzyOpenMenuAction", label="Fuzzy", tooltip="Fuzzy tools", stock_id=None )
    self._action_group.add_action( fuzzyopen_menu_action )
    fuzzyopen_action = gtk.Action( name="FuzzyOpenAction", label="Fuzzy Open...\t", tooltip="Open file by autocomplete...", stock_id=gtk.STOCK_JUMP_TO )
    fuzzyopen_action.connect( "activate", lambda a: self.on_fuzzyopen_action() )
    self._action_group.add_action_with_accel( fuzzyopen_action, "<Ctrl><Shift>o" )
    manager.insert_action_group( self._action_group, 0 )
    self._ui_id = manager.new_merge_id()
    manager.add_ui_from_string( ui_str )
    manager.ensure_update()

  def _remove_menu( self ):
    manager = self._window.get_ui_manager()
    manager.remove_ui( self._ui_id )
    manager.remove_action_group( self._action_group )

  # UI DIALOGUES
  def _init_glade( self ):
    self._fuzzyopen_glade = gtk.Builder()
    self._fuzzyopen_glade.add_from_file(os.path.join(os.path.dirname( __file__ ), "window.glade"))
    #setup window
    self._fuzzyopen_window = self._fuzzyopen_glade.get_object( "FuzzyOpenWindow" )
    self._fuzzyopen_window.connect("key-release-event", self.on_window_key)
    self._fuzzyopen_window.connect("delete_event", self._fuzzyopen_window.hide_on_delete)
    self._fuzzyopen_window.set_transient_for(self._window)
    #setup buttons
    self._fuzzyopen_glade.get_object( "ok_button" ).connect( "clicked", self.open_selected_item )
    self._fuzzyopen_glade.get_object( "cancel_button" ).connect( "clicked", lambda a: self._fuzzyopen_window.hide())
    #setup entry field
    self._glade_entry_name = self._fuzzyopen_glade.get_object( "entry_name" )
    self._glade_entry_name.connect("key-release-event", self.on_pattern_entry)
    #setup list field
    self._hit_list = self._fuzzyopen_glade.get_object( "hit_list" )
    self._hit_list.connect("select-cursor-row", self.on_select_from_list)
    self._hit_list.connect("button_press_event", self.on_list_mouse)
    self._liststore = gtk.ListStore(gtk.gdk.Pixbuf, str, str)
    self._hit_list.set_model(self._liststore)
    column0 = gtk.TreeViewColumn("Icon", gtk.CellRendererPixbuf(), pixbuf=0)
    column0.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
    column1 = gtk.TreeViewColumn("File", gtk.CellRendererText(), markup=1)
    column1.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)
    self._hit_list.append_column(column0)
    self._hit_list.append_column(column1)
    self._hit_list.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

  #mouse event on list
  def on_list_mouse( self, widget, event ):
    if event.type == gtk.gdk._2BUTTON_PRESS:
      self.open_selected_item( event )

  #key selects from list (passthrough 3 args)
  def on_select_from_list(self, widget, event):
    self.open_selected_item(event)

  #keyboard event on entry field
  def on_pattern_entry( self, widget, event ):
    oldtitle = self._fuzzyopen_window.get_title().replace(" * too many hits", "")
    if event.keyval == gtk.keysyms.Return:
      self.open_selected_item( event )
      return
    pattern = self._glade_entry_name.get_text()
    if pattern == self._last_pattern:
      return
    self._last_pattern = pattern
    suggestions = self._suggestion.suggest(pattern)
    self._liststore.clear()
    for suggestion in suggestions:
      self._liststore.append(suggestion)
    self._fuzzyopen_window.set_title(oldtitle)
    selected = []
    self._hit_list.get_selection().selected_foreach(self.foreach, selected)

    if len(selected) == 0:
      iter = self._liststore.get_iter_first()
      if iter != None:
        self._hit_list.get_selection().select_iter(iter)

  #on menuitem activation (incl. shortcut)
  def on_fuzzyopen_action( self ):
    fbroot = util.filebrowser_root()
    if fbroot[0] != "" and fbroot[0] is not None:
      self._rootdir = fbroot[0]
      self._show_hidden = fbroot[1]
      self._fuzzyopen_window.set_title(app_string + " (File Browser root)")
    else:
      eddtroot = util.eddt_root()
      if eddtroot != "" and eddtroot is not None:
        self._rootdir = eddtroot
        self._fuzzyopen_window.set_title(app_string + " (EDDT integration)")
      else:
        self._fuzzyopen_window.set_title(app_string + " (Working dir): " + self._rootdir)
    # Get rid of file://
    debug("Rootdir = " + self._rootdir)
    self._rootpath = url2pathname(self._rootdir)[7:]
    debug("Rootpath = "+ self._rootpath)
    self._git = self.check_git(self._rootpath)
    debug("Use Git = " + str(self._git))
    self._suggestion = FuzzySuggestion( self._rootpath, self._show_hidden, self._git )
    self._fuzzyopen_window.show()
    self._glade_entry_name.select_region(0,-1)
    self._glade_entry_name.grab_focus()

  #check if it is a git repository
  def check_git( self, path ):
    block = os.path.join(path, '').split('/')
    for i in range(0, len(block)):
      current_path = '/'.join(block[:i])
      if os.path.exists(os.path.join(current_path, '.git')):
        return True
    return False

  #on any keyboard event in main window
  def on_window_key( self, widget, event ):
    if event.keyval == gtk.keysyms.Escape:
      self._fuzzyopen_window.hide()

  def foreach(self, model, path, iter, selected):
    selected.append(model.get_value(iter, 2))

  #open file in selection and hide window
  def open_selected_item( self, event ):
    selected = []
    self._hit_list.get_selection().selected_foreach(self.foreach, selected)
    for selected_file in  selected:
      self._open_file ( selected_file )
    self._fuzzyopen_window.hide()

  #opens (or switches to) the given file
  def _open_file( self, filename ):
    uri = self._rootdir + "/" + pathname2url(filename)
    gedit.commands.load_uri(self._window, uri, self._encoding)


########NEW FILE########
__FILENAME__ = suggestion
"""
    Class for suggestions
"""

import os
import subprocess
import gio, gtk
from util import debug
import util

max_result = 15

class FuzzySuggestion:
  def __init__( self, filepath, show_hidden=False, git=False ):
    self._filepath = filepath
    self._show_hidden = show_hidden
    self._git = git and util.config('use_git')
    self._excluded = util.config('ignore_ext').split(',')
    self._ignore_case = util.config('ignore_case')
    self._ignore_space = util.config('ignore_space')
    if self._git:
      self._load_git()
    self._load_file()

  def _load_file( self ):
    self._fileset = []
    for dirname, dirnames, filenames in os.walk( self._filepath ):
      if not self._show_hidden:
        for d in dirnames[:]:
          if d[0] == '.':
            dirnames.remove(d)
      path = os.path.relpath( dirname, self._filepath )
      for filename in filenames:
        if (self._show_hidden or filename[0] != '.'):
          if os.path.splitext( filename )[-1][1:] not in self._excluded:
            self._fileset.append( os.path.normpath(os.path.join( path, filename ) ) )
    self._fileset = sorted( self._fileset )
    debug("Loaded files count = %d" % len(self._fileset))

  def _load_git( self ):
    self._git_with_diff = subprocess.Popen(["git", "diff", "--numstat", "--relative"], cwd=self._filepath, stdout=subprocess.PIPE).communicate()[0].split('\n')[:-1]
    debug("Git file path: %s" % self._filepath)
    self._git_with_diff = [ s.strip().split('\t') for s in self._git_with_diff ]
    self._git_files = [ s[2] for s in self._git_with_diff ]

  def suggest( self, sub ):
    if self._ignore_space:
      sub = sub.replace(' ', '')
    suggestion = []
    for f in self._fileset:
      highlight, score = self._match_score( sub, f )
      if score >= len(sub):
        suggestion.append((highlight, f, score))
    suggestion = sorted(suggestion, key=lambda x: x[2], reverse=True)[:max_result]
    debug("Suggestion count = %d" % len(suggestion))
    return [ self._metadata(s) for s in suggestion ]

  def _metadata( self, suggestion ):
    target = os.path.join(self._filepath, suggestion[1])
    time_string = util.relative_time(os.stat(target).st_mtime)
    highlight = "<span size='x-large'>" + suggestion[0] + "</span>\n" + self._token_string( suggestion[1] ) + "MODIFY " + time_string
    if self._git and (suggestion[1] in self._git_files):
      index = self._git_files.index(suggestion[1])
      highlight += self._git_string(index)
    file_icon = gio.File(os.path.join(self._filepath, suggestion[1])).query_info('standard::icon').get_icon()
    icon = gtk.icon_theme_get_default().lookup_by_gicon(file_icon, 40, gtk.ICON_LOOKUP_USE_BUILTIN)
    return (icon and icon.load_icon(), highlight, suggestion[1])

  def _token_string( self, file ):
    token = os.path.splitext(file)[-1]
    if token != '':
      token = token[1:]
    else:
      token = '.'
    return "<span variant='smallcaps' foreground='#FFFFFF' background='#B2B2B2'><b> " + token.upper() + ' </b></span> '

  def _git_string( self, line_id ):
    add = int(self._git_with_diff[line_id][0])
    delete = int(self._git_with_diff[line_id][1])
    if add != 0 or delete != 0:
      return "  GIT <tt><span foreground='green'>" + ('+' * add) + "</span><span foreground='red'>" + ('-' * delete) + "</span></tt>"
    else:
      return ""

  def _match_score( self, sub, str ):
    result, score, pos, git, orig_length, highlight = 0, 0, 0, 0, len(str), ''
    for c in sub:
      while str != '' and not self._match(str[0], c):
        score = 0
        highlight += str[0]
        str = str[1:]
      if str == '':
        return (highlight, 0)
      score += 1
      result += score
      pos += len(str)
      highlight += "<b>" + str[0] + "</b>"
      str = str[1:]
    highlight += str
    if len(sub) != 0 and orig_length > 1:
      pos = float(pos-1) / ((float(orig_length)-1.0) * float(len(sub)))
    else:
      pos = 0.0
    if self._git and (str in self._git_files):
      git = 1
    return (highlight, float(result) + pos + git)

  def _match(self, a, b):
    if self._ignore_case:
      return a.lower() == b.lower()
    else:
      return a == b


########NEW FILE########
__FILENAME__ = util
"""
    Utility functions
"""

from datetime import datetime
import gconf
import os

def config(name, value=None):
  base = lambda x: u'/apps/gedit-2/plugins/fuzzyopen/%s' % x
  client = gconf.client_get_default()
  key = ['use_git', 'ignore_case', 'ignore_space', 'ignore_ext']
  lambda_set = [client.set_bool, client.set_bool, client.set_bool, client.set_string]
  lambda_get = [client.get_bool, client.get_bool, client.get_bool, client.get_string]
  default = [True, True, True, "jpg,jpeg,gif,png,tif,psd,pyc"]

  val = client.get(base(name))
  index = key.index(name)
  if value != None:
    lambda_set[index](base(name), value)
  if val == None:
    lambda_set[index](base(name), default[index])
  return lambda_get[index](base(name))

# EDDT integration
def eddt_root():
  base = u'/apps/gedit-2/plugins/eddt'
  client = gconf.client_get_default()
  client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
  path = os.path.join(base, u'repository')
  val = client.get(path)
  if val is not None:
    return val.get_string()

# FILEBROWSER integration
def filebrowser_root():
  base = u'/apps/gedit-2/plugins/filebrowser/on_load'
  client = gconf.client_get_default()
  client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
  path = os.path.join(base, u'virtual_root')
  val = client.get(path)
  if val is not None:
    #also read hidden files setting
    base = u'/apps/gedit-2/plugins/filebrowser'
    client = gconf.client_get_default()
    client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
    path = os.path.join(base, u'filter_mode')
    try:
      fbfilter = client.get(path).get_string()
    except AttributeError:
      fbfilter = "hidden"
    return (val.get_string(), (fbfilter.find("hidden") == -1))

def debug(string):
    #print "[DEBUG]: " + string
    pass

# from http://odondo.wordpress.com/2007/07/05/python-relative-datetime-formatting/
def relative_time(date, now = None):
  if not now:
    now = datetime.now()
  date = datetime.fromtimestamp(date)
  diff = date.date() - now.date()
  if diff.days == 0:                                        # Today
    return 'at ' + date.strftime("%I:%M %p")                ## at 05:45 PM
  elif diff.days == 1:                                      # Yesterday
    return 'at ' + date.strftime("%I:%M %p") + ' Yesterday' ## at 05:45 PM Yesterday
  elif diff.days == 1:                                      # Tomorrow
    return 'at ' + date.strftime("%I:%M %p") + ' Tomorrow'  ## at 05:45 PM Tomorrow
  elif diff.days < 7:                                       # Within one week back
    return 'at ' + date.strftime("%I:%M %p %A")             ## at 05:45 PM Tuesday
  else:
    return 'on ' + date.strftime("%b, %d, %Y")              ## on Jan, 3, 2010


########NEW FILE########
__FILENAME__ = configuration
from lib import sgconf

class Configuration(sgconf.Options):
    _uri = u"/apps/gedit-2/plugins/openfiles"

    exclude_list = sgconf.ListOption(['*pyc', '*.class', '*.swp', '.svn', '.git', '*.gif', '*.png', '*.jpg', '*.jpeg', '*.ico'])
    static_root_path = sgconf.StringOption('/')
    use_filebrowser = sgconf.BoolOption(True)


########NEW FILE########
__FILENAME__ = db_wrapper
"""
Provides the DBWrapper Class which currently wraps sqlite in order to provide
some abstractions an multithreading support.
"""
import os
import sqlite3
from logger import log
from threading import Thread
from Queue import Queue

# Register string handler
def adapt_str(s):
    return s.decode("iso-8859-1")

sqlite3.register_adapter(str, adapt_str)

class DBWrapper(Thread):
    """
    Class to wrap the python sqlite3 module to support multithreading
    """

    def __init__(self):
        # Create Database and a queue
        Thread.__init__(self)
        self._queue = Queue()
        self.start()

    def run(self):
        self._create_db()
        while True:
            try:
                sql, params, result = self._queue.get()
                if sql == '__CLOSE__':
                    self._db.close()
                    break
                log.info("[DBWrapper] QUERY: %s" % sql)
                log.info("[DBWrapper] PARAMS: %s" % str(params))
                log.info("[DBWrapper] RESULT: " + str(result))
                cursor = self._db.cursor()
                if params:
                    cursor.execute(sql, params)
                else:
                    cursor.execute(sql)
            except sqlite3.OperationalError, e:
                log.error("[DBWrapper] OperationalError : %s" % e)

            if result:
                log.info("[DBWrapper] Putting Results")
                for row in cursor.fetchall():
                    result.put(row)
                result.put("__END__")

            self._db.commit()

    def execute(self, sql, params=None, result=None):
        self._queue.put((sql, params, result))

    def select(self, sql, params=None):
        list_result = []
        result = Queue()
        self.execute(sql, params, result=result)

        while True:
            row = result.get()
            if row == '__END__':
                break
            list_result.append(row)
        log.info("[DBWrapper] SELECT RESULT COUNT: " + str(len(list_result)))
        return list_result

    def search(self, input):
        log.info("[DBWrapper] select_on_filename method")
        params = input.replace(" ", "%")+"%"
        result = self.select("SELECT DISTINCT name, path FROM files " +
            "WHERE path LIKE ? ORDER BY open_count DESC, path ASC LIMIT 20", (params, ))
        return result

    def add_file(self, path, name):
        path = os.path.join(path, name)
        log.debug("[DBWrapper] Adding File: " + path)
        self.execute("INSERT INTO files (name, path) VALUES (?, ?)",
            (name, path))

    def remove_file(self, path, name):
        path = os.path.join(path, name)
        log.debug("[DBWrapper] Removing File: " + path)
        self.execute("DELETE FROM files where path = ?", (path, ))

    def remove_directory(self, path):
        log.debug("[DBWrapper] Remove Directory: " + path)
        self.execute("DELETE FROM files WHERE path like ?", (path+"%", ))

    def increment_file_open_count(self, path):
        log.debug("[DBWrapper] increment_file_open_count: " + path)
        self.execute("UPDATE files SET open_count =(open_count + 1) WHERE path = ?", (path, ))

    def close(self):
        self._queue.put(("__CLOSE__", "__CLOSE__", "__CLOSE__"))

    def clear_database(self):
        log.debug("[DBWrapper] Clearing Databases")
        self.execute("DELETE FROM files")

    @property
    def count(self):
        res = self.select("SELECT COUNT(*) FROM files")
        return res[0][0]

    def _create_db(self):
        self._db = sqlite3.connect(":memory:")
        self.execute("CREATE TABLE files ( id AUTO_INCREMENT PRIMARY KEY, " +
            "path VARCHAR(255), name VARCHAR(255), " +
            "open_count INTEGER DEFAULT 0)")



########NEW FILE########
__FILENAME__ = filesystem_monitor
"""
File Monitor Contains
- FileMonitor Class
-- Keeps track of files with in a give tree

- WalkDirectoryThread
-- Thread to walk through the tree and store the file paths to a DBWrapper
"""
import os
import stat
import re
import urllib
from logger import log
from pyinotify import WatchManager, Notifier, ThreadedNotifier, EventsCodes, ProcessEvent
from threading import Thread
from threadpool import ThreadPool

THREAD_POOL_WORKS = 4

try:
    # Supports < pyinotify 0.8.6
    EVENT_MASK = EventsCodes.IN_DELETE | EventsCodes.IN_CREATE | EventsCodes.IN_MOVED_TO | EventsCodes.IN_MOVED_FROM # watched events
except AttributeError:
    # Support for pyinotify 0.8.6
    from pyinotify import IN_DELETE, IN_CREATE, IN_MOVED_FROM, IN_MOVED_TO
    EVENT_MASK = IN_DELETE | IN_CREATE | IN_MOVED_TO | IN_MOVED_FROM


class FileProcessEvent(ProcessEvent):

    def __init__(self, file_monitor):
        self._file_monitor = file_monitor

    def is_dir(self, event):
        if hasattr(event, "dir"):
            return event.dir
        else:
            return event.is_dir

    def process_IN_CREATE(self, event):
        path = os.path.join(event.path, event.name)

        if self.is_dir(event):
            log.info("[FileProcessEvent] CREATED DIRECTORY: " + path)
            self._file_monitor.add_directory(path)
        else:
            log.info("[FileProcessEvent] CREATED FILE: " + path)
            self._file_monitor.add_file(event.path, event.name)

    def process_IN_DELETE(self, event):
        path = os.path.join(event.path, event.name)
        if self.is_dir(event):
            log.info("[FileProcessEvent] DELETED DIRECTORY: " + path)
            self._file_monitor.remove_directory(path)
        else:
            log.info("[FileProcessEvent] DELETED FILE: " + path)
            self._file_monitor.remove_file(event.path, event.name)

    def process_IN_MOVED_FROM(self, event):
        path = os.path.join(event.path, event.name)
        log.info("[FileProcessEvent] MOVED_FROM: " + path)
        self.process_IN_DELETE(event)

    def process_IN_MOVED_TO(self, event):
        path = os.path.join(event.path, event.name)
        log.info("[FileProcessEvent] MOVED_TO: " + path)
        self.process_IN_CREATE(event)


class FilesystemMonitor(object):
    """
    FileMonitor Class keeps track of all files down a tree starting at the root
    """

    def __init__(self, searcher):
        self.searcher = searcher

        self._thread_pool = ThreadPool(THREAD_POOL_WORKS)

        # Add a watch to the root of the dir
        self.watch_manager = WatchManager()
        self.notifier = ThreadedNotifier(self.watch_manager, FileProcessEvent(self))
        self.notifier.start()

        self._build_exclude_list()


    def _build_exclude_list(self):
        log.info("[FileMonitor] Set Regexs for Ignore List")

        self._exclude_regexs = []
        # Complie Ignore list in to a list of regexs
        for ignore in self.searcher.configuration.exclude_list:
            ignore = ignore.strip()
            ignore = ignore.replace(".", "\.")
            ignore = ignore.replace("*", ".*")
            ignore = "^"+ignore+"$"
            log.debug("[FileMonitor] Ignore Regex = %s" % ignore)
            self._exclude_regexs.append(re.compile(ignore))

    def change_root(self, previous_root):
        self._thread_pool.clearTasks()

        wd = self.watch_manager.get_wd(previous_root)
        if wd:
          self.watch_manager.rm_watch(wd, rec=True)

        self.searcher.clear_database()
        self.add_directory(self.searcher.current_root)

    def add_directory(self, path):
        """
        Starts a WalkDirectoryThread to add the directory
        """
        basename = os.path.basename(path)
        if self.validate(basename):
            self.watch_manager.add_watch(path, EVENT_MASK)
            self._thread_pool.queueTask(self.walk_directory, path)

    def add_file(self, path, name):
        """
        Add a single file to the databse
        """
        if self.validate(name):
            self.searcher.add_file(path, name)

    def remove_file(self, path, name):
        self.searcher.remove_file(path, name)

    def remove_directory(self, path):
        self.searcher.remove_directory(path)

    def walk_directory(self, root):
        """
        From a give root of a tree this method will walk through ever branch
        and return a generator.
        """
        if os.path.isdir(root):
            names = os.listdir(root)
            for name in names:
                try:
                    file_stat = os.lstat(os.path.join(root, name))
                except os.error:
                    continue

                if stat.S_ISDIR(file_stat.st_mode):
                    self.add_directory(os.path.join(root, name))
                else:
                    if not stat.S_ISLNK(file_stat.st_mode):
                        self.add_file(root, name)
    def finish(self):
        wd = self.watch_manager.get_wd(self.searcher.current_root)
        self.watch_manager.rm_watch(wd, rec=True)
        self.notifier.stop()
        self._thread_pool.joinAll(waitForTasks=False)

    def validate(self, name):
         # Check to make sure the file not in the ignore list
        for ignore_re in self._exclude_regexs:
            if ignore_re.match(name):
                log.debug("[WalkDirectoryThread] ##### Ignored %s #####", name)
                return False
        log.debug("[WalkDirectoryThread] # Passed %s", name)
        return True


########NEW FILE########
__FILENAME__ = filesystem_searcher
import urllib

from db_wrapper import DBWrapper
from filesystem_monitor import FilesystemMonitor
from file_wrapper import FileWrapper
from logger import log


class FilesystemSearcher(object):
    """
    Public API to be used by the UI to ask for files.

    TODO: Do we want to include hidden files should ask the file browserstop
    """

    def __init__(self, plugin, window):
        """
        Window handle setting up the database and file system monitor.
        """
        # defaults
        self._root = "."

        # Setup
        self._window = window
        self._plugin = plugin
        self._message_bus = self._window.get_message_bus()

        self._db = DBWrapper()
        self._monitor = None

        self._message_bus.connect('/plugins/filebrowser', 'root_changed', self.root_changed)

    def root_changed(self, *args, **kwargs):
        root = kwargs.get('root', None)
        previous_root = self._root

        if not root:
            if len(args) == 2:
                msg = args[1]
                root = self._get_uri_from_msg(msg)
        self._root = root.replace("file://", "") # FIXME: HACK

        if not self._monitor:
            self._monitor = FilesystemMonitor(self)
        self._monitor.change_root(previous_root)

        log.debug("changing root from %s -> %s" % (previous_root, self._root))


    @property
    def current_root(self):
        """
        Returns the current root location of the window.
        """
        if self.configuration.use_filebrowser:
            return urllib.unquote(self._root)
        else:
            return urllib.unquote(self.configuration.static_root_path)

    @property
    def filebrowser_current_root(self):
        return self._get_uri_from_msg(self._message_bus.send_sync('/plugins/filebrowser', 'get_root'))

    @property
    def configuration(self):
        return self._plugin._configuration

    def add_file(self, path, file_name):
        self._db.add_file(path, file_name)

    def remove_directory(self, path):
        self._db.remove_directory(path)

    def remove_file(self, path, name):
        self._db.remove_file(path, name)

    def increment_uri_open_count(self, uri):
        self._db.increment_file_open_count(uri.replace("file://", ""))

    def clear_database(self):
        self._db.clear_database()

    def build_exclude_list(self):
        self._monitor._build_exclude_list()

    def search(self, input):
        query = self.current_root + "%" + input
        filewrappers = []
        for row in self._db.search(query):
            # FIXME: Set data in variables so you can tell what data is returned.
            filewrappers.append(FileWrapper(input, self.current_root, row[0], row[1]))
        return filewrappers

    def cleanup(self):
        if self._monitor:
            self._monitor.finish()
        self._db.close() # FIXME: Fix db clean up

    def _get_uri_from_msg(self, msg):
        if hasattr(msg, 'uri'):
            return msg.uri
        else:
            return msg.get_value('uri')


########NEW FILE########
__FILENAME__ = file_wrapper
import urllib

from logger import log


class FileWrapper(object):
    """
    A file wrapper.
    """
    def __init__(self, query_input, root, name, path):
        self._path = path
        self._name = name
        self._query_input = query_input
        self._root = root

    @property
    def path(self):
        return self._path

    @property
    def uri(self):
        uri = "file://" + urllib.quote(self._path)
        return uri

    @property
    def display_path(self):
        return self.highlight_pattern(self.path)

    def highlight_pattern(self, path):
        path = path.replace(self._root + "/", "") # Relative path
        log.debug("[FileWrapper] path = " + path)
        query_list = self._query_input.lower().split(" ")

        last_postion = 0
        for word in query_list:
            location = path.lower().find(word, last_postion)
            log.debug("[FileWrapper] Found Postion = " + str(location))
            if location > -1:
                last_postion = (location + len(word) + 3)
                a_path = list(path)
                a_path.insert(location, "<b>")
                a_path.insert(location + len(word) + 1, "</b>")
                path = "".join(a_path)

        log.debug("[FileWrapper] Markup Path = " + path)
        return path

########NEW FILE########
__FILENAME__ = gedit_open_files
from gedit import Plugin

from gedit_open_files_ui import GeditOpenFilesUi
from configuration import Configuration
from filesystem_searcher import FilesystemSearcher

class GeditOpenFiles(Plugin):
    def __init__(self):
        super(GeditOpenFiles, self).__init__()

        # Get the configuration, this is global for the entire application
        self._configuration = Configuration()

    def activate(self, window):
        """
        Called when a new window is created.
        """
        window.searcher = FilesystemSearcher(self, window)

        # Setup UI for the plugin
        GeditOpenFilesUi(window)

    def deactivate(self, window):
        window.searcher.cleanup()

    @property
    def configuration(self):
        return self._configuration

########NEW FILE########
__FILENAME__ = gedit_open_files_ui
import gtk
import os
from logger import log
import gedit
import urllib

menu_str="""
<ui>
    <menubar name="MenuBar">
        <menu name="FileMenu" action="File">
            <placeholder name="FileOps_1">
                <menuitem name="Open File" action="GeditOpenFileMenuAction"/>
           </placeholder>
        </menu>
    </menubar>
</ui>
"""


class GeditOpenFilesUi(object):

    def __init__(self, window):
        self._window = window
        self.searcher = window.searcher

        # Get Builder and get xml file
        self._builder = gtk.Builder()
        self._builder.add_from_file(os.path.join(os.path.dirname(__file__),
             "gui", "geditopenfiles_gtk.xml"))

        #setup window
        self._plugin_window = self._builder.get_object("gedit_openfiles_window")
        self._plugin_window.set_transient_for(self._window)
        self._notebook = self._builder.get_object('notebook')

        # Callbacks
        self._plugin_window.connect("key-release-event", self._on_window_release)
        self._plugin_window.connect("delete_event", self._plugin_window_delete_event)

        #setup buttons
        self._builder.get_object("open_button").connect("clicked",
            self._open_selected_item)
        self._builder.get_object("cancel_button").connect("clicked",
            lambda a: self._plugin_window.hide())

        # Setup entry field
        self._file_query = self._builder.get_object("file_query")
        self._file_query.connect("key-release-event", self._on_query_entry)

        # Get File TreeView
        self._file_list = self._builder.get_object("file_list")

        # Connect Action on TreeView
        self._file_list.connect("select-cursor-row", self._on_select_from_list)
        self._file_list.connect("button_press_event", self._on_list_mouse)

        # Setup File TreeView
        self._liststore = gtk.ListStore(str, str)
        self._file_list.set_model(self._liststore)

        # Path Column
        column1 = gtk.TreeViewColumn("Path", gtk.CellRendererText(), markup=0)
        column1.set_sizing(gtk.TREE_VIEW_COLUMN_AUTOSIZE)

        self._file_list.append_column(column1)
        self._file_list.get_selection().set_mode(gtk.SELECTION_MULTIPLE)

#        # Add Animation icon for building data
#        building_data_spinner = self._builder.get_object('spinner')
#        building_data_spinner.set_from_animation(gtk.gdk.PixbufAnimation(
#            os.path.join(os.path.dirname(__file__), "gui", "progress.gif")))
#        self._building_data_spinner_box = self._builder.get_object('spinner_box')

        # Setup Configuration Tab
        self._notebook = self._builder.get_object("notebook")
        self._file_browser_checkbox = self._builder.get_object("file_browser_checkbox")
        self._file_browser_checkbox.connect("toggled", self._file_browser_checkbox_event)
        self._open_root_hbox = self._builder.get_object("open_root_hbox")

        # Setup Callback for root path
        self._open_root_path = self._builder.get_object("open_root_path")
        self._open_root_path.set_current_folder(self.searcher.configuration.static_root_path)

        self._config_ignore_input = self._builder.get_object("config_ignore_input")

        self._reset_config()

        # Connect the OK Button the config tab
        self._builder.get_object("config_save_button").connect("clicked", self._save_config_event)
        self._builder.get_object("config_cancel_button").connect("clicked", self._cancel_config_event)
        self._builder.get_object("config_refresh_button").connect("clicked", self._refresh_data)

        use_file_browser = self.searcher.configuration.use_filebrowser
        if use_file_browser == True or use_file_browser == None: # Defualt
            self._open_root_hbox.set_sensitive(False)
        else:
            self._open_root_hbox.set_sensitive(True)

        # Set encoding
        self._encoding = gedit.encoding_get_current()
        self._insert_menu()

    def _refresh_data(self, event):
        if self.searcher.configuration.use_filebrowser:
            self.searcher.root_changed(root=self.searcher.filebrowser_current_root)
        else:
            self.searcher.root_changed(root=self.searcher.configuration.static_root_path)
        self._plugin_window.hide()

    def _reset_config(self):
        if self.searcher.configuration.use_filebrowser:
            self._file_browser_checkbox.set_active(True)
        else:
            self._file_browser_checkbox.set_active(False)
        log.debug("[GeditOpenFileGui] EXCLUDE_LIST = " + str(self.searcher.configuration.exclude_list))
        self._config_ignore_input.set_text(", ".join(self.searcher.configuration.exclude_list))

    def _cancel_config_event(self, event):
        self._reset_config()
        self._plugin_window.hide()

    def _save_config_event(self, event):
        self.searcher.configuration.use_filebrowser = self._file_browser_checkbox.get_active()
        log.debug("[GeditOpenFileGui] : STATIC_ROOT_PATH = %s" % self._open_root_path.get_current_folder())
        self.searcher.configuration.static_root_path = self._open_root_path.get_current_folder()

        ignored_list = [s.strip() for s in self._config_ignore_input.get_text().split(",")]
        log.debug("[GeditOpenFileGui] ignored_list = " + str(ignored_list))
        self.searcher.configuration.exclude_list = ignored_list
        self.searcher.build_exclude_list()
        self._refresh_data(event)

    def _file_browser_checkbox_event(self, widget):
        if widget.get_active():
            self._open_root_hbox.set_sensitive(False)
        else:
            self._open_root_hbox.set_sensitive(True)

    def _plugin_window_delete_event(self, window, event):
        """
        Method used to is trigger when the x is click on the window, it will not
        destroy the window only hide it.
        """
        self._plugin_window.hide()
        return True

    def _insert_menu(self):
        #TODO refactor and reivew code. To make sure its not doing more work then is needed.
        manager = self._window.get_ui_manager()
        self._action_group = gtk.ActionGroup("GeditOpenFileAction")
        plugin_menu_action = gtk.Action(name="GeditOpenFileAction",
            label="Open", tooltip="Gedit Open File(s) tools", stock_id=None)
        self._action_group.add_action(plugin_menu_action)

        geditopenfiles_action = gtk.Action(name="GeditOpenFileMenuAction",
            label="Open File(s)...\t", tooltip="Open a file(s)",
            stock_id=gtk.STOCK_OPEN)
        geditopenfiles_action.connect("activate",
            lambda a: self._on_geditopen_action())
        self._action_group.add_action_with_accel(geditopenfiles_action,
            "<Ctrl><Alt>o")
        manager.insert_action_group(self._action_group, 0)

        self._ui_id = manager.new_merge_id()

        manager.add_ui_from_string(menu_str)
        manager.ensure_update()

    def _on_window_release(self, widget, event):
        if event.keyval == gtk.keysyms.Escape:
            self._plugin_window.hide()

    def _on_query_entry(self, widget, event):
        # Check to see if key pressed is Return if so open first file
        if event.keyval == gtk.keysyms.Return:
            self._on_select_from_list(None, event)
            return

        self._clear_treeveiw() # Remove all

        input_query = widget.get_text()
        log.debug("[GeditOpenFileGui] input_query : %s" % input_query)

        if input_query:
            # Query database based on input
            results = self.searcher.search(input_query)
            self._insert_into_treeview(results)

            # Select the first one on the list
            iter = self._liststore.get_iter_first()
            if iter != None:
                self._file_list.get_selection().select_iter(iter)

    def _insert_into_treeview(self, file_list):
        for file in file_list:
            self._liststore.append([file.display_path, file.uri])

    def _clear_treeveiw(self):
        self._liststore.clear()

    def _open_file(self, uri):
        log.debug("[GeditOpenFileGui] uri to open : %s" % uri)
        # Check to make sure file is not allready opened
        tab = self._window.get_tab_from_uri(uri)
        if not tab:
            # if not createa tab.
            self.searcher.increment_uri_open_count(uri)
            tab = self._window.create_tab_from_uri(uri, self._encoding, 0,
                False, False)
        self._window.set_active_tab(tab)

    def _foreach(self, model, path, iter, selected):
        """
        Populates selected list
        """
        selected.append(model.get_value(iter, 1))

    def _on_select_from_list(self, widget, event):
        # Populate the list of file paths
        selected = []
        self._file_list.get_selection().selected_foreach(self._foreach, selected)
        for selected_file in selected:
            # Open File
            self._open_file(selected_file)

        # Hide the window
        self._plugin_window.hide()

    def _on_list_mouse(self, widget, event):
        if event.type == gtk.gdk._2BUTTON_PRESS:
            self._on_select_from_list(None, event)

    def _on_geditopen_action(self):
        self._plugin_window.show()
        self._notebook.set_current_page(0) # Set back to the search page
        self._file_query.grab_focus()
#        self._file_monitor.change_root(self.searcher.configuration.root_path())
#        self._reset_config()

    def _open_selected_item(self, event):
        self._on_select_from_list(None, event)


########NEW FILE########
__FILENAME__ = logger
import logging

LEVEL = logging.ERROR
#  Setup
log = logging.getLogger("GeditOpenFiles")
log.setLevel(LEVEL)

#create console handler and set level to debug
ch = logging.StreamHandler()
ch.setLevel(LEVEL)

#create formatter
formatter = logging.Formatter("%(asctime)s - %(name)s -" +
    " %(levelname)s - %(message)s")

#add formatter to ch
ch.setFormatter(formatter)

#add ch to log
log.addHandler(ch)

########NEW FILE########
__FILENAME__ = threadpool
import threading
from time import sleep

class ThreadPool:

    """Flexible thread pool class.  Creates a pool of threads, then
    accepts tasks that will be dispatched to the next available
    thread."""
    
    def __init__(self, numThreads):

        """Initialize the thread pool with numThreads workers."""
        
        self.__threads = []
        self.__resizeLock = threading.Condition(threading.Lock())
        self.__taskLock = threading.Condition(threading.Lock())
        self.__tasks = []
        self.__isJoining = False
        self.setThreadCount(numThreads)

    def setThreadCount(self, newNumThreads):

        """ External method to set the current pool size.  Acquires
        the resizing lock, then calls the internal version to do real
        work."""
        
        # Can't change the thread count if we're shutting down the pool!
        if self.__isJoining:
            return False
        
        self.__resizeLock.acquire()
        try:
            self.__setThreadCountNolock(newNumThreads)
        finally:
            self.__resizeLock.release()
        return True

    def __setThreadCountNolock(self, newNumThreads):
        
        """Set the current pool size, spawning or terminating threads
        if necessary.  Internal use only; assumes the resizing lock is
        held."""
        
        # If we need to grow the pool, do so
        while newNumThreads > len(self.__threads):
            newThread = ThreadPoolThread(self)
            self.__threads.append(newThread)
            newThread.start()
        # If we need to shrink the pool, do so
        while newNumThreads < len(self.__threads):
            self.__threads[0].goAway()
            del self.__threads[0]

    def getThreadCount(self):

        """Return the number of threads in the pool."""
        
        self.__resizeLock.acquire()
        try:
            return len(self.__threads)
        finally:
            self.__resizeLock.release()

    def queueTask(self, task, args=None, taskCallback=None):

        """Insert a task into the queue.  task must be callable;
        args and taskCallback can be None."""
        
        if self.__isJoining == True:
            return False
        if not callable(task):
            return False
        
        self.__taskLock.acquire()
        try:
            self.__tasks.append((task, args, taskCallback))
            return True
        finally:
            self.__taskLock.release()

    def clearTasks(self):

        """ Removes all task that need to be removed. """
        
        self.__taskLock.acquire()
        try:
            self.__tasks = []
        finally:
            self.__taskLock.release()

    def getNextTask(self):

        """ Retrieve the next task from the task queue.  For use
        only by ThreadPoolThread objects contained in the pool."""
        
        self.__taskLock.acquire()
        try:
            if self.__tasks == []:
                return (None, None, None)
            else:
                return self.__tasks.pop(0)
        finally:
            self.__taskLock.release()
    
    def joinAll(self, waitForTasks = True, waitForThreads = True):

        """ Clear the task queue and terminate all pooled threads,
        optionally allowing the tasks and threads to finish."""

        # Mark the pool as joining to prevent any more task queueing
        self.__isJoining = True

        # Wait for tasks to finish
        if waitForTasks:
            while self.__tasks != []:
                sleep(0.1)

        # Tell all the threads to quit
        self.__resizeLock.acquire()
        try:
            # Wait until all threads have exited
            if waitForThreads:
                for t in self.__threads:
                    t.goAway()
                for t in self.__threads:
                    t.join()
                    # print t,"joined"
                    del t
            self.__setThreadCountNolock(0)
            self.__isJoining = True

            # Reset the pool for potential reuse
            self.__isJoining = False
        finally:
            self.__resizeLock.release()



        
class ThreadPoolThread(threading.Thread):

    """ Pooled thread class. """
    
    threadSleepTime = 0.1

    def __init__(self, pool):

        """ Initialize the thread and remember the pool. """
        
        threading.Thread.__init__(self)
        self.__pool = pool
        self.__isDying = False
        
    def run(self):

        """ Until told to quit, retrieve the next task and execute
        it, calling the callback if any.  """
        
        while self.__isDying == False:
            cmd, args, callback = self.__pool.getNextTask()
            # If there's nothing to do, just sleep a bit
            if cmd is None:
                sleep(ThreadPoolThread.threadSleepTime)
            elif callback is None:
                cmd(args)
            else:
                callback(cmd(args))
    
    def goAway(self):

        """ Exit the run loop next time through."""
        
        self.__isDying = True

# Usage example
if __name__ == "__main__":

    from random import randrange

    # Sample task 1: given a start and end value, shuffle integers,
    # then sort them
    
    def sortTask(data):
        print "SortTask starting for ", data
        numbers = range(data[0], data[1])
        for a in numbers:
            rnd = randrange(0, len(numbers) - 1)
            a, numbers[rnd] = numbers[rnd], a
        print "SortTask sorting for ", data
        numbers.sort()
        print "SortTask done for ", data
        return "Sorter ", data

    # Sample task 2: just sleep for a number of seconds.

    def waitTask(data):
        print "WaitTask starting for ", data
        print "WaitTask sleeping for %d seconds" % data
        sleep(data)
        return "Waiter", data

    # Both tasks use the same callback

    def taskCallback(data):
        print "Callback called for", data

    # Create a pool with three worker threads

    pool = ThreadPool(3)

    # Insert tasks into the queue and let them run
    pool.queueTask(sortTask, (1000, 100000), taskCallback)
    pool.queueTask(waitTask, 5, taskCallback)
    pool.queueTask(sortTask, (200, 200000), taskCallback)
    pool.queueTask(waitTask, 2, taskCallback)
    pool.queueTask(sortTask, (3, 30000), taskCallback)
    pool.queueTask(waitTask, 7, taskCallback)

    # When all tasks are finished, allow the threads to terminate
    pool.joinAll()


########NEW FILE########
__FILENAME__ = gemini
#        Gedit gemini plugin
#        Copyright (C) 2005-2006    Gary Haran <gary.haran@gmail.com>
#
#        This program is free software; you can redistribute it and/or modify
#        it under the terms of the GNU General Public License as published by
#        the Free Software Foundation; either version 2 of the License, or
#        (at your option) any later version.
#
#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
#        GNU General Public License for more details.
#
#        You should have received a copy of the GNU General Public License
#        along with this program; if not, write to the Free Software
#        Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
#        02110-1301  USA

import gedit
import gtk
import gobject
import re

class GeminiPlugin( gedit.Plugin):
    handler_ids = []

    def __init__(self):
        gedit.Plugin.__init__(self)

    def activate(self, window):
        view = window.get_active_view()
        self.setup_gemini (view)

    def deactivate(self, window):
        for (handler_id, view) in self.handler_ids:
            if view.handler_is_connected(handler_id):
                view.disconnect(handler_id)

    def update_ui(self, window):
        view = window.get_active_view()
        self.setup_gemini(view)


    # Starts auto completion for a given view
    def setup_gemini(self, view):
        if type(view) == gedit.View:
            if getattr(view, 'gemini_instance', False) == False:
                setattr(view, 'gemini_instance',Gemini())
                handler_id = view.connect ('key-press-event', view.gemini_instance.key_press_handler)
                self.handler_ids.append((handler_id, view))

class Gemini:
    start_keyvals = [34, 39, 96, 40, 91, 123]
    end_keyvals   = [34, 39, 96, 41, 93, 125]
    twin_start    = ['"',"'",'`','(','[','{']
    twin_end      = ['"',"'",'`',')',']','}']

    def __init__(self):
        return

    def key_press_handler(self, view, event):
        buf = view.get_buffer()
        cursor_mark = buf.get_insert()
        cursor_iter = buf.get_iter_at_mark(cursor_mark)

        if event.keyval in self.start_keyvals or event.keyval in self.end_keyvals or event.keyval in (65288, 65293):

            back_iter = cursor_iter.copy()
            back_char = back_iter.backward_char()
            back_char = buf.get_text(back_iter, cursor_iter)
            forward_iter = cursor_iter.copy()
            forward_char = forward_iter.forward_char()
            forward_char = buf.get_text(cursor_iter, forward_iter)

            if event.keyval in self.start_keyvals:
                index = self.start_keyvals.index(event.keyval)
                start_str = self.twin_start[index]
                end_str = self.twin_end[index]
            else:
                index = -1
                start_str, end_str = None, None

            # Here is the meat of the logic
            if buf.get_has_selection() and event.keyval not in (65288, 65535):
                # pad the selected text with twins
                start_iter, end_iter = buf.get_selection_bounds()
                selected_text = start_iter.get_text(end_iter)
                buf.delete(start_iter, end_iter)
                buf.insert_at_cursor(start_str + selected_text + end_str)
                return True
            elif index >= 0 and start_str == self.twin_start[index]:
                # insert the twin that matches your typed twin
                buf.insert(cursor_iter, end_str)
                if cursor_iter.backward_char():
                    buf.place_cursor (cursor_iter)
            elif event.keyval == 65288 and back_char in self.twin_start and forward_char in self.twin_end:
                # delete twins when backspacing starting char next to ending char
                if self.twin_start.index(back_char) == self.twin_end.index(forward_char):
                    buf.delete(cursor_iter, forward_iter)
            elif event.keyval in self.end_keyvals:
                # stop people from closing an already closed pair
                index = self.end_keyvals.index(event.keyval)
                if self.twin_end[index] == forward_char :
                    buf.delete(cursor_iter, forward_iter)
            elif event.keyval == 65293 and forward_char == '}':
                # add proper indentation when hitting before a closing bracket
                cursor_iter = buf.get_iter_at_mark(buf.get_insert ())
                line_start_iter = cursor_iter.copy()
                view.backward_display_line_start(line_start_iter)

                line = buf.get_text(line_start_iter, cursor_iter)
                preceding_white_space_pattern = re.compile(r'^(\s*)')
                groups = preceding_white_space_pattern.search(line).groups()
                preceding_white_space = groups[0]
                plen = len(preceding_white_space)

                buf.insert_at_cursor('\n')
                buf.insert_at_cursor(preceding_white_space)
                buf.insert_at_cursor('\n')

                cursor_mark = buf.get_insert()
                cursor_iter = buf.get_iter_at_mark(cursor_mark)

                buf.insert_at_cursor(preceding_white_space)

                cursor_mark = buf.get_insert()
                cursor_iter = buf.get_iter_at_mark(cursor_mark)

                for i in range(plen + 1):
                    if cursor_iter.backward_char():
                        buf.place_cursor(cursor_iter)
                if view.get_insert_spaces_instead_of_tabs():
                    buf.insert_at_cursor(' ' * view.get_tab_width())
                else:
                    buf.insert_at_cursor('\t')
                return True


########NEW FILE########
__FILENAME__ = highlight_edited_lines
import gtk
import gconf
import gedit
import copy

version = "0.1"

Xpm_Data = [
  "16 16 2 1",
  "       c None",
  "X      c %s",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     ",
  "          XX     "
  ]

CONFROOT = '/apps/gedit-2/plugins/highlight_edited_lines/'

PREFS = {
  'show_line_marks': True,
  'line_marks_color': '#ff0000',
  'highlight': True,
  'highlight_bg_color': '#282828',
}

def new_pixbuf(color):
  xpm = copy.copy(Xpm_Data)
  xpm[2] = xpm[2]%color
  return gtk.gdk.pixbuf_new_from_xpm_data(xpm)
  
def colorstr_from_gdkcolor(c):
  s = c.to_string()
  return '#'+s[1:3]+s[5:7]+s[9:11]
  
class PreferencesDialog(gtk.Dialog):

  def __init__(M, window):
    gtk.Dialog.__init__(M, parent=window)
    M.view = window.get_active_view()
    M.init_dialog(window)
    
    M.conf = gconf.client_get_default()

    T = gtk.Table(2,3)
    T.set_row_spacings(3)
    T.set_col_spacings(3)
    
    # line marks
    if 1:
    
      # label
      if 1:
        T.attach(gtk.Label("Line Marks:"),0,1,0,1)
      
      # checkbox
      if 1:
        cbut = gtk.CheckButton()
        cbut.set_active(PREFS['show_line_marks'])
        cbut.show()
        cbut.connect("toggled", M.on_show_line_marks_toggled)
        T.attach(cbut,1,2,0,1)
        
      # color button
      if 1:
        M.line_marks_WDGT = gtk.ColorButton(gtk.gdk.Color(PREFS['line_marks_color']))
        M.line_marks_WDGT.set_sensitive(PREFS['show_line_marks'])
        M.line_marks_WDGT.connect("color-set",M.on_line_marks_color_set)
        T.attach(M.line_marks_WDGT,2,3,0,1)
        
    # highlight
    if 1:
      
      # label
      if 1:
        al = gtk.Alignment(1,.5,0,0)
        al.add(gtk.Label("Background:"))
        T.attach(al,0,1,1,2)
        
      # checkbox
      if 1:
        w = gtk.CheckButton()
        w.set_active(PREFS['highlight'])
        w.show()
        w.connect('toggled', M.on_highlight_bg_toggled)
        T.attach(w,1,2,1,2)
        
      # color button
      if 1:
        M.highlight_bg_WDGT = gtk.ColorButton(gtk.gdk.Color(PREFS['highlight_bg_color']))
        M.highlight_bg_WDGT.set_sensitive(PREFS['highlight'])
        M.highlight_bg_WDGT.connect('color-set',M.on_highlight_bg_color_set)
        T.attach(M.highlight_bg_WDGT,2,3,1,2)
        
    vbox = M.get_child()
    vbox.add(T)
    vbox.show_all()
  
  def on_highlight_bg_color_set(M, widget):
    color = widget.get_color()
    M.conf.set_string(CONFROOT+'highlight_bg_color',colorstr_from_gdkcolor(color))

  def on_highlight_bg_toggled(M, widget):
    flag = widget.get_active()
    M.conf.set_bool(CONFROOT+'highlight',flag)
    M.highlight_bg_WDGT.set_sensitive(flag)
    
  def on_line_marks_color_set(M, widget):
    color = widget.get_color()
    M.conf.set_string(CONFROOT+'line_marks_color',colorstr_from_gdkcolor(color))
    
  def on_show_line_marks_toggled(M,cbut):
    flag = cbut.get_active()
    M.conf.set_bool(CONFROOT+'show_line_marks',flag)
    M.line_marks_WDGT.set_sensitive(flag)
    
  def init_dialog(M, window):
    M.set_title("Highlight Edited Lines Preferences")
    M.add_button(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
    M.set_default_response(gtk.RESPONSE_CLOSE)
    M.set_has_separator(False)
    M.set_transient_for(window)
    M.set_resizable(False)
    M.set_border_width(6)
    M.set_modal(True)
    on_response = lambda M, response: M.destroy()
    M.connect("response", on_response)
    
class WinAttachedObject:
  def __init__(M, win):
    M.win            = win
    M.connected_docs = []
    M.win.connect("tab-added",M.on_win_tab_added)
    
  def getdoc(M):
    tab = M.win.get_active_tab()
    if not tab:
      return
    return tab.get_document()
    
  def getview(M): return M.win.get_active_view()
        
  def on_win_tab_added(M, win, tab):
    #print 'tab added'
    view = tab.get_view()
    # create mark
    view.set_mark_category_priority('EDITED',10)
    # line mark
    if PREFS['show_line_marks']:
      view.set_show_line_marks(True)
      view.set_mark_category_icon_from_pixbuf('EDITED',new_pixbuf(PREFS['line_marks_color']))
    if PREFS['highlight']:
      map = view.get_colormap()
      view.set_mark_category_background('EDITED',map.alloc_color(PREFS['highlight_bg_color']))
  def on_doc_loaded(M, doc, unused):
    # the initial insertion of the entire text left a spurious mark
    doc.remove_source_marks(doc.get_start_iter(),doc.get_end_iter())

  def on_doc_insert_text(M, doc, loc, text, N):
    N        = text.count('\n') + 1
    nextchar = loc.get_char()
    itr      = loc.copy()
    if text[0]=='\n' and nextchar=='\n':
      # we inserted a \n at end of line, leave that line alone
      N -= 1
    for i in range(N):
      doc.create_source_mark(None,'EDITED',itr)
      itr.backward_line()
      
  def on_doc_delete_range(M, doc, start, end):
    if not start.ends_line():
      doc.create_source_mark(None,'EDITED',start)
    else:
      doc.remove_source_marks(start, end, 'EDITED')

  def update_ui(M):
    doc = M.getdoc()
    if not doc:
      return
    if id(doc) in M.connected_docs:
      return
    
    # insert id() so that the doc is not kept alive by this list
    M.connected_docs.append(id(doc)) 
    
    doc.connect("loaded", M.on_doc_loaded)
    doc.connect_after("insert-text", M.on_doc_insert_text)
    doc.connect("delete-range", M.on_doc_delete_range)
    
  def deactivate(M):
    #print 'deactivate called'
    # ?? turn off EDITED line mark
    M.win.disconnect_by_func(M.on_win_tab_added)
    for doc in M.win.get_documents():
      if id(doc) in M.connected_docs:
        doc.disconnect_by_func(M.on_doc_loaded)
        doc.disconnect_by_func(M.on_doc_insert_text)
      doc.disconnect_by_func(M.on_doc_delete_range)
    M.connected_docs = []
    

class HighlightEditedLinesPlugin(gedit.Plugin):
  def __init__(M):
    gedit.Plugin.__init__(M)
    conf=gconf.client_get_default()
    
    M.children = {}
    
    # read in preferences. if absent, set them
    # register handler for their change
    for key,get,set in (('show_line_marks',    conf.get_bool,   conf.set_bool),
                        ('line_marks_color',   conf.get_string, conf.set_string),
                        ('highlight',          conf.get_bool,   conf.set_bool),
                        ('highlight_bg_color', conf.get_string, conf.set_string),):
      if conf.get(CONFROOT+key) is None:
        set(CONFROOT+key,PREFS[key])
      else:
        PREFS[key]=get(CONFROOT+key)
      # ?? disconnect notification somewhere
      conf.notify_add(CONFROOT+key, M.on_gconf_client_notify)
    
  def on_gconf_client_notify(M, conf, gconf_id, entry, data):
    
    key = entry.get_key().rsplit('/')[-1]
    
    if key == 'show_line_marks':
    
      PREFS['show_line_marks']=conf.get_bool(CONFROOT+key)
      if PREFS['show_line_marks']:
        pixbuf = new_pixbuf(PREFS['line_marks_color'])
      else:
        pixbuf = None
      for win in M.children.keys():
        for view in win.get_views():
          if pixbuf:
            view.set_show_line_marks(True)
          view.set_mark_category_icon_from_pixbuf('EDITED',pixbuf)
          
    elif key == 'line_marks_color':
    
      PREFS['line_marks_color']=conf.get_string(CONFROOT+key)
      # not showing line marks anyway, doesn't matter if the color changed
      if not PREFS['show_line_marks']:
        return
      for win in M.children.keys():
        for view in win.get_views():
          view.set_mark_category_icon_from_pixbuf('EDITED',new_pixbuf(PREFS['line_marks_color']))
    
    elif key == 'highlight':
    
      PREFS['highlight'] = conf.get_bool(CONFROOT+key)        
      for win in M.children:
        for view in win.get_views():   
          if PREFS['highlight']:
            map = view.get_colormap()           
            view.set_mark_category_background('EDITED',map.alloc_color(PREFS['highlight_bg_color']))
          else:
            view.set_mark_category_background('EDITED',None)
            
    elif key == 'highlight_bg_color':

      PREFS['highlight_bg_color']=conf.get_string(CONFROOT+key)
      if not PREFS['highlight']:
        return
      for win in M.children:
        for view in win.get_views():
          map = view.get_colormap()
          view.set_mark_category_background('EDITED',map.alloc_color(PREFS['highlight_bg_color']))
                  
  def activate(M, win):
    M.children[win] = WinAttachedObject(win)

  def create_configure_dialog(M):
    window = gedit.app_get_default().get_active_window()
    return PreferencesDialog(window)
        
  def deactivate(M, win):
    M.children[win].deactivate()

  def update_ui(M, win):
    # Called whenever the win has been updated (active tab changed, etc.)
    M.children[win].update_ui()
  

########NEW FILE########
__FILENAME__ = lastdocs
# -*- coding: utf-8 -*-
#  A Diolog that contains the last opened documents
# 
#  Copyright (C) 2008 Marco Laspe <macco@gmx.net>
#   
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#   
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#   
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.


# IMPROVE highlight first entry
import gedit, gtk
#from gettext import gettext as _

# Menu item example, insert a new item in the Tools menu
ui_str = """<ui>
  <menubar name="MenuBar">
    <menu name="ToolsMenu" action="Tools">
      <placeholder name="ToolsOps_2">
        <menuitem name="Lastdocs" action="Lastdocs"/>
      </placeholder>
    </menu>
  </menubar>
</ui>
"""

class LastdocsPluginInstance:
  def __init__(self, plugin, window):
    self._window = window
    self._plugin = plugin
    # Insert menu items
    self._insert_menu()
    # get recent_manager
    self.load_recent_manager()
    self.create_dialog()
    # Recent Limit
    self.__recent_limit = 9 #IMPROVE set __recent_limit via configuration dialog

  def stop(self):
    # Remove any installed menu items
    self._remove_menu()

    self._window = None
    self._plugin = None
    self._action_group = None

  def _insert_menu(self):
    # Get the GtkUIManager
    manager = self._window.get_ui_manager()

    # Create a new action group
    self._action_group = gtk.ActionGroup("LastdocsPluginActions")
    self._action_group.add_actions([("Lastdocs", None, _("Lastdocs"), "<Ctrl><Shift>o", _("Example menu item"), lambda a: self.on_example_menu_item_activate())])
    # Insert the action group
    manager.insert_action_group(self._action_group, -1)

    # Merge the UI
    self._ui_id = manager.add_ui_from_string(ui_str)

  def _remove_menu(self):
    # Get the GtkUIManager
    manager = self._window.get_ui_manager()

    # Remove the ui
    manager.remove_ui(self._ui_id)

    # Remove the action group
    manager.remove_action_group(self._action_group)

    # Make sure the manager updates
    manager.ensure_update()

  def update(self):
    pass
    # Called whenever the window has been updated (active tab
    # changed, etc.)


  # Menu activate handlers
  def on_example_menu_item_activate(self):
    self.dialog.show_all()
    self.dialog.grab_focus()
    
    #uris = dialog.get_uris()
    #dialog.select_uri(uris[0])
    #info2.grab_focus()
        
    if self.dialog.run() == gtk.RESPONSE_ACCEPT:
      info = self.dialog.get_current_item()      
      print info.get_uri()
      self._open_file(info.get_uri())
      #gedit.document.load(info.get_uri(), None, 1, False)
    self.dialog.hide()
    return
    
  def _sort_recent(self):
    pass
  
  def load_recent_manager(self):
    self.recent_manager = gtk.recent_manager_get_default()

  def create_dialog(self):
    self.dialog = gtk.RecentChooserDialog("Recent Documents", self._window, self.recent_manager,(gtk.STOCK_CANCEL, gtk.RESPONSE_CANCEL, gtk.STOCK_OPEN, gtk.RESPONSE_ACCEPT))
    #dialog.set_sort_func(_sort_recent(),None)
    self.dialog.set_sort_type(gtk.RECENT_SORT_MRU)
    self.dialog.set_filter(self.__create_filter())
    #dialog.set_limit(self.__recent_limit)
    self.dialog.set_local_only(False)    
    #dialog.set_select_multiple(False)
    self.dialog.set_show_not_found(False)
    self.dialog.set_position(gtk.WIN_POS_CENTER_ON_PARENT)
    
  def __create_filter(self):
		"""
		Create a filter for the recent menu.

		@param self: Reference to the RecentMenu instance.
		@type self: A RecentMenu object.

		@return: A filter for the recent menu.
		@rtype: A gtk.RecentFilter object.
		"""
		recent_filter = gtk.RecentFilter()
		recent_filter.add_application("gedit")
		return recent_filter    
  #opens (or switches to) the given file
  
  def _open_file( self, filename ):
    #uri = self._rootdir + "/" + filename
    uri = filename
    tab = self._window.get_tab_from_uri(uri) 
    if tab == None:
      tab = self._window.create_tab_from_uri( uri,gedit.encoding_get_current(), 0, False, False )
    self._window.set_active_tab( tab )

class LastdocsPlugin(gedit.Plugin):
  DATA_TAG = "LastdocsPluginInstance"

  def __init__(self):
    gedit.Plugin.__init__(self)

  def _get_instance(self, window):
    return window.get_data(self.DATA_TAG)

  def _set_instance(self, window, instance):
    window.set_data(self.DATA_TAG, instance)

  def activate(self, window):
    self._set_instance(window, LastdocsPluginInstance(self, window))

  def deactivate(self, window):
    self._get_instance(window).stop()
    self._set_instance(window, None)

  def update_ui(self, window):
    self._get_instance(window).update()

########NEW FILE########
__FILENAME__ = mterminal
# -*- coding: utf8 -*-

# terminal.py - Embeded VTE terminal for gedit
# This file is part of gedit
#
# Copyright (C) 2005-2006 - Paolo Borelli
#
# gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# gedit is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with gedit; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, 
# Boston, MA  02110-1301  USA

import gedit
import gedit.utils
import pango
import gtk
import gobject
import vte
import gconf
import gettext
import gnomevfs
import os
from gpdefs import *

try:
    gettext.bindtextdomain(GETTEXT_PACKAGE, GP_LOCALEDIR)
    _ = lambda s: gettext.dgettext(GETTEXT_PACKAGE, s);
except:
    _ = lambda s: s

class GeditTerminal(gtk.HBox):
    """VTE terminal which follows gnome-terminal default profile options"""

    __gsignals__ = {
        "populate-popup": (
            gobject.SIGNAL_RUN_LAST,
            None,
            (gobject.TYPE_OBJECT,)
        )
    }

    GCONF_PROFILE_DIR = "/apps/gnome-terminal/profiles/Default"
    
    defaults = {
        'allow_bold'            : True,
        'audible_bell'          : False,
        'background'            : None,
        'background_color'      : '#000000',
        'backspace_binding'     : 'ascii-del',
        'cursor_blinks'         : False,
        'emulation'             : 'xterm',
        'font_name'             : 'Monospace 10',
        'foreground_color'      : '#AAAAAA',
        'scroll_on_keystroke'   : False,
        'scroll_on_output'      : False,
        'scrollback_lines'      : 100,
        'visible_bell'          : False,
        'word_chars'            : '-A-Za-z0-9,./?%&#:_'
    }

    def __init__(self):
        gtk.HBox.__init__(self, False, 4)

        gconf_client.add_dir(self.GCONF_PROFILE_DIR,
                             gconf.CLIENT_PRELOAD_RECURSIVE)

        self._vte = vte.Terminal()
        self.reconfigure_vte()
        self._vte.set_size(self._vte.get_column_count(), 5)
        self._vte.set_size_request(200, 50)
        self._vte.show()
        self.pack_start(self._vte)
        
        self._scrollbar = gtk.VScrollbar(self._vte.get_adjustment())
        self._scrollbar.show()
        self.pack_start(self._scrollbar, False, False, 0)
        
        gconf_client.notify_add(self.GCONF_PROFILE_DIR,
                                self.on_gconf_notification)
        
        self._vte.connect("key-press-event", self.on_vte_key_press)
        self._vte.connect("button-press-event", self.on_vte_button_press)
        self._vte.connect("popup-menu", self.on_vte_popup_menu)
        self._vte.connect("child-exited", lambda term: term.fork_command())

        self._vte.fork_command()

    def reconfigure_vte(self):
        # Fonts
        if gconf_get_bool(self.GCONF_PROFILE_DIR + "/use_system_font"):
            font_name = gconf_get_str("/desktop/gnome/interface/monospace_font",
                                      self.defaults['font_name'])
        else:
            font_name = gconf_get_str(self.GCONF_PROFILE_DIR + "/font",
                                      self.defaults['font_name'])

        try:
            self._vte.set_font(pango.FontDescription(font_name))
        except:
            pass

        # colors
        fg_color = gconf_get_str(self.GCONF_PROFILE_DIR + "/foreground_color",
                                 self.defaults['foreground_color'])
        bg_color = gconf_get_str(self.GCONF_PROFILE_DIR + "/background_color",
                                 self.defaults['background_color'])
        self._vte.set_colors(gtk.gdk.color_parse (fg_color),
                             gtk.gdk.color_parse (bg_color),
                             [])

        self._vte.set_cursor_blinks(gconf_get_bool(self.GCONF_PROFILE_DIR + "/cursor_blinks",
                                                   self.defaults['cursor_blinks']))

        self._vte.set_audible_bell(not gconf_get_bool(self.GCONF_PROFILE_DIR + "/silent_bell",
                                                      not self.defaults['audible_bell']))

        self._vte.set_scrollback_lines(gconf_get_int(self.GCONF_PROFILE_DIR + "/scrollback_lines",
                                                     self.defaults['scrollback_lines']))
        
        self._vte.set_allow_bold(gconf_get_bool(self.GCONF_PROFILE_DIR + "/allow_bold",
                                                self.defaults['allow_bold']))

        self._vte.set_scroll_on_keystroke(gconf_get_bool(self.GCONF_PROFILE_DIR + "/scroll_on_keystroke",
                                                         self.defaults['scroll_on_keystroke']))

        self._vte.set_scroll_on_output(gconf_get_bool(self.GCONF_PROFILE_DIR + "/scroll_on_output",
                                                      self.defaults['scroll_on_output']))

        self._vte.set_word_chars(gconf_get_str(self.GCONF_PROFILE_DIR + "/word_chars",
                                               self.defaults['word_chars']))

        self._vte.set_emulation(self.defaults['emulation'])
        self._vte.set_visible_bell(self.defaults['visible_bell'])

    def on_gconf_notification(self, client, cnxn_id, entry, what):
        self.reconfigure_vte()

    def on_vte_key_press(self, term, event):
        modifiers = event.state & gtk.accelerator_get_default_mod_mask()
        if event.keyval in (gtk.keysyms.Tab, gtk.keysyms.KP_Tab, gtk.keysyms.ISO_Left_Tab):
            if modifiers == gtk.gdk.CONTROL_MASK:
                self.get_toplevel().child_focus(gtk.DIR_TAB_FORWARD)
                return True
            elif modifiers == gtk.gdk.CONTROL_MASK | gtk.gdk.SHIFT_MASK:
                self.get_toplevel().child_focus(gtk.DIR_TAB_BACKWARD)
                return True
        return False

    def on_vte_button_press(self, term, event):
        if event.button == 3:
            self.do_popup(event)
            return True

    def on_vte_popup_menu(self, term):
        self.do_popup()

    def create_popup_menu(self):
        menu = gtk.Menu()

        item = gtk.ImageMenuItem(gtk.STOCK_COPY)
        item.connect("activate", lambda menu_item: self._vte.copy_clipboard())
        item.set_sensitive(self._vte.get_has_selection())
        menu.append(item)

        item = gtk.ImageMenuItem(gtk.STOCK_PASTE)
        item.connect("activate", lambda menu_item: self._vte.paste_clipboard())
        menu.append(item)
        
        self.emit("populate-popup", menu)
        menu.show_all()
        return menu

    def do_popup(self, event = None):
        menu = self.create_popup_menu()
   
        if event is not None:
	        menu.popup(None, None, None, event.button, event.time)
        else:
            menu.popup(None, None,
                       lambda m: gedit.utils.menu_position_under_widget(m, self),
                       0, gtk.get_current_event_time())
            menu.select_first(False)        

    def change_directory(self, path):
        path = path.replace('\\', '\\\\').replace('"', '\\"')
        self._vte.feed_child('cd "%s"\n' % path)

    def add_terminal(self, terminal, panel):
        bottom = terminal._window.get_bottom_panel()
        term = GeditTerminal()
        term.connect("populate-popup", terminal.on_panel_populate_popup)
        term.show()

        image = gtk.Image()
        image.set_from_icon_name("utilities-terminal", gtk.ICON_SIZE_MENU)

        bottom.add_item(term, _("Terminal"), image)
        terminal._terminals.insert(0,term)

    def remove_terminal(self, terminal, panel):
        if len(terminal._terminals) <= 1:
          return
        bottom = terminal._window.get_bottom_panel()  
        bottom.remove_item(panel)
        terminal._terminals.remove(panel)

class TerminalWindowHelper(object):
    def __init__(self, window):
        
        self._terminals = []
        self._window = window

        term = GeditTerminal()
        term.connect("populate-popup", self.on_panel_populate_popup)
        term.show()

        image = gtk.Image()
        image.set_from_icon_name("utilities-terminal", gtk.ICON_SIZE_MENU)

        bottom = window.get_bottom_panel()
        bottom.add_item(term, _("Terminal"), image)
        self._terminals.insert(0,term)

    def deactivate(self):
        bottom = self._window.get_bottom_panel()
        for term in range(len(self._terminals)):
            bottom.remove_item(self._terminals[term])
        self._terminals = []
    def update_ui(self):
        pass

    def get_active_document_directory(self):
        doc = self._window.get_active_document()
        if doc is None:
            return None
        uri = doc.get_uri()
        if uri is not None and gedit.utils.uri_has_file_scheme(uri):
            return os.path.dirname(gnomevfs.get_local_path_from_uri(uri))
        return None

    def on_panel_populate_popup(self, panel, menu):
        menu.prepend(gtk.SeparatorMenuItem())
        path = self.get_active_document_directory()
        item = gtk.MenuItem(_("C_hange Directory"))
        item.connect("activate", lambda menu_item: panel.change_directory(path))
        item.set_sensitive(path is not None)
        menu.prepend(item)
        
        menu.prepend(gtk.SeparatorMenuItem())

        add = gtk.MenuItem(_("Remove Terminal"))
        add.connect("activate", lambda menu_item: panel.remove_terminal(self, panel))
        menu.prepend(add)
        
        add = gtk.MenuItem(_("New Terminal"))
        add.connect("activate", lambda menu_item: panel.add_terminal(self,panel))
        menu.prepend(add)
        

class TerminalPlugin(gedit.Plugin):
    WINDOW_DATA_KEY = "TerminalPluginWindowData"

    def __init__(self):
        gedit.Plugin.__init__(self)

    def activate(self, window):
        helper = TerminalWindowHelper(window)
        window.set_data(self.WINDOW_DATA_KEY, helper)

    def deactivate(self, window):
        window.get_data(self.WINDOW_DATA_KEY).deactivate()
        window.set_data(self.WINDOW_DATA_KEY, None)

    def update_ui(self, window):
        window.get_data(self.WINDOW_DATA_KEY).update_ui()

gconf_client = gconf.client_get_default()
def gconf_get_bool(key, default = False):
    val = gconf_client.get(key)
    
    if val is not None and val.type == gconf.VALUE_BOOL:
        return val.get_bool()
    else:
        return default

def gconf_get_str(key, default = ""):
    val = gconf_client.get(key)
    
    if val is not None and val.type == gconf.VALUE_STRING:
        return val.get_string()
    else:
        return default

def gconf_get_int(key, default = 0):
    val = gconf_client.get(key)
    
    if val is not None and val.type == gconf.VALUE_INT:
        return val.get_int()
    else:
        return default


# ex:ts=4:et: Let's conform to PEP8

########NEW FILE########
__FILENAME__ = me_config
"""
    Multi-edit - Gedit plugin
    Copyright (C) 2009 Jonathan Walsh
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os

import gtk
import gtk.glade

class ConfigDialog:
    """ Plugin config window instance """
    
    def __init__(self, plugin):
        self._plugin = plugin
        glade_file = os.path.join(os.path.dirname(__file__), 'config.glade')
        self._ui = gtk.glade.XML(glade_file, 'settings_dialog')
        
        # Widgets
        self._dialog = self._ui.get_widget('settings_dialog')
        self._auto_incr_field = self._ui.get_widget('auto_incr').get_buffer()
        self._columns_checkbox = self._ui.get_widget('columns_always_avail')
        
        # auto_incr_field style
        self._auto_incr_field.create_tag('monospace', family='monospace')
        self._auto_incr_field.connect('changed', self._style_auto_incr)
        
        # Load settings
        self._auto_incr_field.set_text(self._plugin._sc_auto_incr_str)
        self._columns_checkbox.set_active(self._plugin._columns_always_avail)
        
        self._dialog.connect('response', self._button_event)
    
    def _button_event(self, dialog, resp_id):
        """ Button event handler. """
        resp = {'default':1, 'cancel':2, 'apply':3}
        
        if resp_id == resp['default']:
            self._auto_incr_field.set_text(self._plugin._sc_auto_incr_def)
        
        elif resp_id == resp['apply']:
            # Save to vars
            start = self._auto_incr_field.get_start_iter()
            end = self._auto_incr_field.get_end_iter()
            self._plugin._sc_auto_incr_str = self._auto_incr_field.get_text(start, end)
            self._plugin._columns_always_avail = self._columns_checkbox.get_active()
            
            # Save to gconf
            self._plugin._save_settings()
            
            # Translate to keyvals
            self._plugin._set_shortcut_keyvals()
        
        if resp_id in (resp['cancel'], resp['apply']):
            self._destroy()
    
    def _style_auto_incr(self, *args):
        """ Ensure the auto-incr field stays monospace. """
        text = self._auto_incr_field
        text.apply_tag_by_name('monospace', text.get_start_iter(), text.get_end_iter())
    
    def _destroy(self):
        self._dialog.destroy()
        self._plugin._config_instance = None


########NEW FILE########
__FILENAME__ = me_window
"""
    Multi-edit - Gedit plugin
    Copyright (C) 2009 Jonathan Walsh
    
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
    
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
    
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""

import os
import string
import csv

import gtk
import gtk.glade

class WindowInstance:
    """ A window's multi-edit instance """
    
    # ============================================================ Event handlers
    def __init__(self, plugin, window):
        self._plugin = plugin
        self._window = window
        self._tab = None
        # Tab change handler
        self._tab_event = self._window.connect('active-tab-changed', self._tab_change)
        # Load the currently active tab
        self._tab_change(self._window, self._window.get_active_tab())
    
    def deactivate(self):
        """ Handle window deactivation. """
        self._destroy_settings()
        self._window.disconnect(self._tab_event)
    
    def _tab_change(self, window, tab):
        """ Handle tab changes and reassign all references to the new tab. """
        # Destroy previous tab references
        if self._tab is not None:
            self._destroy_settings()
        
        # Note: _tab, _view, _buffer: all refer to different parts of the currently active tab
        self._tab = tab
        if tab is not None:
            self._view = tab.get_view()
            self._buffer = tab.get_document()
            
            # Event handlers
            self._view_event = self._view.connect('event', self._event_wrapper)
            self._text_change = self._buffer.connect('changed', self._text_changed)
            self._mark_move = self._buffer.connect('mark-set', self._mark_moved)
            
            # Mark related
            self._marks = []
            self._mark_i = 0
            self._line_offset_mem = None
            self._vert_mark_mem = None  # Filled format = (line_num, smart_nav)
            
            # Event trackers
            self._mouse_event = {'current':False, 'followup':False}
            self._change_supported = False
            self._cursor_move_supported = [False, False]  # [insert, selection_bound]
    
    def _destroy_settings(self):
        """ Exit multi-edit mode and carefully remove previous tab references. """
        # Remove textbuffer markers
        self._clear_marks()
        
        # Disconnect event handlers
        self._view.disconnect(self._view_event)
        self._buffer.disconnect(self._text_change)
        self._buffer.disconnect(self._mark_move)
        
        # Destroy references to previous tab
        del self._tab
        del self._view
        del self._buffer
    
    def _event_wrapper(self, dont_use, event):
        """ Wrapper for all TextView events.
        
        Used instead of more specific signals, to gain priority over other plugins.
        Appropriate given that Multi-edit will still pass on events if in single-edit mode.
        """
        if event.type == gtk.gdk.KEY_PRESS:
            result = self._keyboard_handler(event)
            # Ensure cursor remains visible during text modifications
            # Only scroll if multi-edit is managing the event
            if result:
                self._view.scroll_mark_onscreen(self._buffer.get_insert())
            return result
        
        if event.type == gtk.gdk.BUTTON_PRESS:
            return self._mouse_handler(event, 'press')
        
        if event.type == gtk.gdk.BUTTON_RELEASE:
            return self._mouse_handler(event, 'release')
        
        return False
    
    def _mark_moved(self, textbuffer, textiter, mark):
        """ Track cursor movement and exit if unsupported. """
        if mark.get_name() == 'insert':
            if self._cursor_move_supported[0]:
                self._cursor_move_supported[0] = False
            else:
                self._clear_marks()
        elif mark.get_name() == 'selection_bound':
            if self._cursor_move_supported[1]:
                self._cursor_move_supported[1] = False
            else:
                self._clear_marks()
        return False
    
    def _text_changed(self, *args):
        """ Check text changes and exit multi-edit mode if unsupported. """
        if self._change_supported:
            self._change_supported = False
        else:
            self._clear_marks()
        return False
    
    def _mouse_handler(self, event, type_):
        """ Handle mouse button events.
        
        Return value: True kills the event, False passes it on
        """
        # Modifier checks
        ctrl_on = event.state & gtk.gdk.CONTROL_MASK
        shift_on = event.state & gtk.gdk.SHIFT_MASK
        alt_on = event.state & gtk.gdk.MOD1_MASK
        
        # Clear line/offset memory
        self._line_offset_mem = None
        self._vert_mark_mem = None
        
        # Requirements
        if (type_ == 'press' and not ctrl_on) or alt_on or event.button not in (1, 3):
            return False
        
        # ---------------------------------------- Mark actions
        
        # Add marks [cursor movement]
        if type_ == 'press':
            self._mouse_event = {'current':False}  # to be safe
            
            # Get pos
            win_type = self._view.get_window_type(event.window)
            pos = self._view.window_to_buffer_coords(win_type, int(event.x), int(event.y))
            pos = self._view.get_iter_at_location(pos[0], pos[1])
            
            # Multiple mark placement
            if shift_on:
                old_pos = self._buffer.get_iter_at_mark(self._buffer.get_insert())
                dif = pos.get_line() - old_pos.get_line()
                down = abs(dif) == dif
                smart_nav = event.button == 3
                for i in range(abs(dif)):
                    self._vertical_cursor_nav(down, smart_nav)
                self._mouse_event = {'current':True, 'followup':False}
                return True
            
            # Single mark placement
            elif event.button == 1:
                self._cursor_move_supported = [True, True]
                self._buffer.place_cursor(pos)
                self._add_remove_mark()
                self._mouse_event = {'current':True, 'followup':True}
                return True
        
        # Finish multi-edit events
        elif self._mouse_event['current']:
            if type_ == 'release':
                #if self._mouse_event['followup']:
                #    pass
                self._mouse_event = {'current':False}
            else:
                # Drag event
                pass
            return True
        
        return False
    
    def _keyboard_handler(self, event):
        """ Handle keyboard events.
        
        Return value: True kills the event, False passes it on
        Note: Unsupported events will exit multi-edit mode (for safety reasons)
        """
        
        # Modifier checks
        ctrl_on = event.state & gtk.gdk.CONTROL_MASK
        shift_on = event.state & gtk.gdk.SHIFT_MASK
        alt_on = event.state & gtk.gdk.MOD1_MASK
        caps_on = event.state & gtk.gdk.LOCK_MASK
        
        # Undo caps lock for shortcuts
        if caps_on and ctrl_on:
            if shift_on:
                event.keyval = int(gtk.gdk.keyval_to_upper(event.keyval))
            else:
                event.keyval = int(gtk.gdk.keyval_to_lower(event.keyval))
        
        #print event.keyval  # dev use
        
        # Ignore safe keys (to prevent them affecting the offset mems)
        # Note: safe keys are keys that do nothing by themselves
        safe_keys = (
            gtk.keysyms.Shift_L,
            gtk.keysyms.Shift_R,
            gtk.keysyms.Control_L,
            gtk.keysyms.Control_R,
            gtk.keysyms.Alt_L,
            gtk.keysyms.Alt_R,
        )
        if event.keyval in safe_keys:
            return False
        
        # ---------------------------------------- Vertical movement memory
        # Reset vertical mark memory
        vert_mark_mem_backup = self._vert_mark_mem
        self._vert_mark_mem = None
        
        # Reset line offset
        line_offset_mem_backup = self._line_offset_mem
        self._line_offset_mem = None
        
        # ---------------------------------------- Mark actions
        if ctrl_on:
            # Add mark
            keyval, shift_req = self._plugin._sc_add_mark
            if event.keyval == keyval and (shift_req is None or shift_req == shift_on):
                self._add_remove_mark()
                return True
            
            # Add marks vertically
            for sc in self._plugin._sc_mark_vert:
                keyval, shift_req = self._plugin._sc_mark_vert[sc]
                if event.keyval == keyval and (shift_req is None or shift_req == shift_on) \
                   and (len(self._marks) != 0 or self._plugin._columns_always_avail):
                    # Recover vertical move mems, regardless if needed
                    # (since _vertical_cursor_nav() will handle it)
                    self._vert_mark_mem = vert_mark_mem_backup
                    self._line_offset_mem = line_offset_mem_backup
                    # Get values based on key
                    down = sc[-2:] != 'up'
                    smart_nav = sc[:2] == 'sm'
                    self._vertical_cursor_nav(down, smart_nav)
                    return True
        
        # ---------------------------------------- Edit actions
        if len(self._marks) != 0:
            
            # Multi-modifier support (so far just tab)
            if not ctrl_on:
                if event.keyval == gtk.keysyms.ISO_Left_Tab and not alt_on:
                    self._multi_edit('left_tab')
                    return True
                if event.keyval == gtk.keysyms.Tab:
                    if self._view.get_insert_spaces_instead_of_tabs() and not alt_on:
                        self._multi_edit('space_tab')
                    else:
                        self._multi_edit('insert', '\t')
                    return True
            
            # Alt support drop
            if alt_on:
                return False
            
            # Shortcuts
            if ctrl_on:
                
                # Temp auto-increment
                keyval, shift_req = self._plugin._sc_temp_incr
                if event.keyval == keyval and (shift_req is None or shift_req == shift_on):
                    self._auto_incr_dialog()
                    return True
                
                # Paste clipboard
                if event.keyval == gtk.keysyms.v:
                    self._multi_edit('insert', gtk.clipboard_get().wait_for_text())
                    return True
                
                # Auto-increment
                if event.keyval in self._plugin._sc_auto_incr:
                    entry = self._plugin._sc_auto_incr[event.keyval]
                    if entry['shift_req'] is None or entry['shift_req'] == shift_on:
                        values = self._auto_increment(entry)
                        self._multi_edit('increment', values)
                        return True
                
                # Level marks
                keyval, shift_req = self._plugin._sc_level_marks
                if event.keyval == keyval and (shift_req is None or shift_req == shift_on):
                        self._multi_edit('level')
                        return True
                
                # Preserve marks
                if event.keyval in (gtk.keysyms.Up, gtk.keysyms.Down):
                    self._line_offset_mem = line_offset_mem_backup  # Recover line offset mem
                    down = event.keyval == gtk.keysyms.Down
                    self._vertical_cursor_nav(down, False, False)
                    return True
                
                if event.keyval in (gtk.keysyms.Left, gtk.keysyms.Right):
                    pos = self._buffer.get_iter_at_mark(self._buffer.get_insert())
                    if event.keyval == gtk.keysyms.Left:
                        pos.backward_cursor_position()
                    else:
                        pos.forward_cursor_position()
                    self._cursor_move_supported = [True, True]
                    self._buffer.place_cursor(pos)
                    return True
            
            # Regular key values
            if not ctrl_on:
                
                # Preserve identation (regular newlines handled below, as printable chars)
                if self._view.get_auto_indent() and event.keyval == gtk.keysyms.Return and \
                  not shift_on:
                    self._multi_edit('indent_nl')
                    return True
                
                if event.keyval == gtk.keysyms.BackSpace:
                    self._multi_edit('delete', -1)
                    return True
                
                if event.keyval == gtk.keysyms.Delete:
                    if not shift_on:  # to be consistent with gedit
                        self._multi_edit('delete', 1)
                        return True
                
                if event.keyval == gtk.keysyms.Escape:
                    # Prevent printing the unicode Escape char
                    return False
                
                # Printable chars
                if event.string != '':
                    self._multi_edit('insert', event.string)
                    return True
                
        return False
    
    # ============================================================ Text modifiers
    
    def _single_edit(self, start, insert, value,  start_is_iter=False):
        """ Insert or delete text at the given position.
        
        Important: Multi-edit text modifications must never occur anywhere but here.
                   And only "_multi_edit" may call this function.
        
        Arguments:
            start: A mark or iter (depending on "start_is_iter")
            insert: True for insert, False for delete
            value: String for insert, length for delete (+: forward deletion, -: backward deletion)
        """
        self._change_supported = True
        if not start_is_iter:
            start = self._buffer.get_iter_at_mark(start)
        if insert:
            self._buffer.insert_interactive(start, str(value), True)
        else:
            end = start.copy()
            if value > 0:
                end.forward_cursor_positions(value)
            else:
                start.forward_cursor_positions(value)
            self._buffer.delete_interactive(start, end, True)
            self._cleanup_marks()
    
    def _multi_edit(self, mode, value=None):
        """ Make mode dependant text modifications at all multi-edit marks.
        
        "value" is mode dependant.
        
        Modes:
            insert: normal text insertion
            delete: normal (backward or forward) text deletion
            increment: incrementing text insertion (numerical or alphabetical)
            tab: emulate gedit (indent)
            shift_tab: emulate gedit (preceding indentation deletion for lines)
        """
        self._buffer.begin_user_action()
        
        if mode == 'insert':
            # value = string
            for mark in self._marks:
                self._single_edit(mark, True, value)
        
        elif mode == 'delete':
            # value = length
            for mark in self._marks:
                self._single_edit(mark, False, value)
        
        elif mode == 'increment' and len(value) != 0:
            # value = list
            i = 0
            for mark in self._marks:
                self._single_edit(mark, True, value[i])
                i += 1
                if not i < len(value):
                    i = 0
        
        elif mode == 'space_tab':
            # value = not used
            tab_width = self._view.get_tab_width()
            for mark in self._marks:
                offset = self._get_physical_line_offset(mark)
                tab_string = ' ' * (tab_width - (offset % tab_width))
                self._single_edit(mark, True, tab_string)
        
        elif mode == 'left_tab':
            # value not used
            for mark in self._marks:
                pos = self._buffer.get_iter_at_mark(mark)
                pos.set_line_offset(0)
                i = 1
                while i < 4:
                    if pos.get_char() == ' ':
                        pass
                    elif pos.get_char() == '\t':
                        break
                    else:
                        i -= 1
                        break
                    pos.forward_char()
                    i += 1
                pos.set_line_offset(0)
                self._single_edit(pos, False, i, True)
        
        elif mode == 'indent_nl':
            # value not used
            for mark in self._marks:
                i = self._buffer.get_iter_at_mark(mark)
                offset = i.get_line_offset()
                i.set_line_offset(0)
                indent_str = '\n'
                while i.get_line_offset() < offset:
                    if i.get_char() in (' ', '\t'):
                        indent_str += i.get_char()
                    else:
                        break
                    i.forward_char()
                self._single_edit(mark, True, indent_str)
        
        elif mode == 'level':
            # value not used
            lines = {}
            max_offsets = {0:0}  # {column:max_offset}
            tabs = not self._view.get_insert_spaces_instead_of_tabs()
            tab_width = self._view.get_tab_width()
            
            # Sort marks into lines
            for mark in self._marks:
                line = self._buffer.get_iter_at_mark(mark).get_line()
                new_item = [mark, self._get_physical_line_offset(mark)]
                if line not in lines:
                    lines[line] = [new_item]
                else:
                    for i, item in enumerate(lines[line]):
                        if new_item[1] <= item[1]:
                            lines[line].insert(i, new_item)
                            break
                        elif i == len(lines[line]) - 1:
                            lines[line].append(new_item)
                            break
                    if len(lines[line]) > len(max_offsets):
                        # New column detected
                        max_offsets[len(max_offsets)] = 0
            
            # Get first column's max offset
            # Note: Succeeding columns' max offsets are detected during their
            # preceding column's process
            for line in lines:
                if lines[line][0][1] > max_offsets[0]:
                    max_offsets[0] = lines[line][0][1]
            
            # Process
            for column in max_offsets:
                next_column = column + 1
                
                # Tabs
                if tabs:
                    remainder = max_offsets[column] % tab_width
                    if remainder != 0:
                        max_offsets[column] += tab_width - remainder
                    
                for line in lines:
                    if len(lines[line]) - 1 < column:
                        continue
                    dif = max_offsets[column] - lines[line][column][1]
                    if dif > 0:
                        if tabs:
                            insert = '\t' * (dif / tab_width)
                            if dif % tab_width != 0:
                                insert += '\t'
                        else:
                            insert = ' ' * dif
                        self._single_edit(lines[line][column][0], True, insert)
                        # Update succeeding offets in same line
                        for i in range(len(lines[line]) - next_column):
                            lines[line][next_column + i][1] += dif
                    # Update the succeeding max offset
                    if len(lines[line]) > next_column and \
                      lines[line][next_column][1] > max_offsets[next_column]:
                        max_offsets[next_column] = lines[line][next_column][1]
        
        self._buffer.end_user_action()
    
    def _get_physical_line_offset(self, mark):
        """ Get the physical line offset of a mark.
        
        Basically just the character offset with tab support.
        Physical, in the sense that it corresponds with a physical width (e.g. pixels),
        rather than a logical one (bytes or chars).
        """
        pos = self._buffer.get_iter_at_mark(mark)
        i = pos.copy()
        i.set_line_offset(0)
        offset = 0
        tab_width = self._view.get_tab_width()
        while not i.equal(pos):
            if i.get_char() == '\t':
                offset += tab_width - (offset % tab_width)
            else:
                offset += 1
            i.forward_char()
        return offset
    
    def _get_logical_line_offset(self, pos, phy_offset):
        """ Convert a physical line offset to a logical one. """
        # pos is simply a text iter in the line
        # (does not mark the actual offset which is phy_offset)
        pos = pos.copy()
        pos.set_line_offset(0)
        phy_i = 0
        tab_width = self._view.get_tab_width()
        phy_amount = 0
        while phy_i < phy_offset and not pos.ends_line():
            if pos.get_char() == '\t':
                phy_amount = tab_width - (phy_i % tab_width)
            else:
                phy_amount = 1
            phy_i += phy_amount
            pos.forward_char()
        # Round mid-tab offset
        if phy_i != phy_offset and phy_i - phy_offset > phy_amount / 2:
            pos.backward_char()
        return pos.get_line_offset()
    
    def _auto_increment(self, entry):
        """ Parse an auto-incr command and return the list of values. """
        
        # Number
        if entry['type'] == 'num' and len(entry['args']) == 2:
            i = float(entry['args'][0])
            result = []
            for mark in self._marks:
                str_i = str(i)
                if str_i[-2:] == '.0':
                    str_i = str_i[:-2]
                result.append(str_i)
                i += float(entry['args'][1])
            return result
        
        # Alphabet
        elif entry['type'] == 'abc' and len(entry['args']) == 1:
            start = entry['args'][0]
            if start not in ('a', 'A', 'z', 'Z'):
                return ()
            if start.islower():
                letters = list(string.ascii_lowercase)
            else:
                letters = list(string.ascii_uppercase)
            if start.lower() == 'z':
                letters.reverse()
            return letters
        
        # Custom list
        elif entry['type'] == 'list':
            return entry['args']
        
        # Invalid type
        return ()
    
    def _auto_incr_dialog(self):
        """ One-time auto-incr dialog """
        glade_file = os.path.join(os.path.dirname(__file__), 'auto_incr.glade')
        ui = gtk.glade.XML(glade_file, 'auto_incr_dialog')
        dialog = ui.get_widget('auto_incr_dialog')
        dialog.set_transient_for(self._window)
        
        type_field = ui.get_widget('type')
        type_field.set_active(0)
        args_field = ui.get_widget('arguments')
        apply_btn = ui.get_widget('apply')
        
        def apply_command(button):
            args = args_field.get_text()
            args = csv.reader([args]).next()
            incr_cmd = {
                'type': type_field.get_active_text(),
                'args': args,
            }
            self._multi_edit('increment', self._auto_increment(incr_cmd))
            dialog.destroy()
        
        apply_btn.connect('clicked', apply_command)
        args_field.connect('activate', apply_command)
    
    # ============================================================ Multi-edit Marks

    def _add_remove_mark(self, dont_remove=False):
        """ Add or remove a mark at the cursors position. """
        pos = self._buffer.get_iter_at_mark(self._buffer.get_insert())
        pos_marks = pos.get_marks()
        deleted = 0
        
        # Deselect the current selection (if there is one)
        self._cursor_move_supported = [False, True]
        self._buffer.move_mark_by_name('selection_bound', pos)
        
        for mark in pos_marks:
            # Note: Marks may be present that are not associated with multi-edit
            if mark in self._marks:
                mark.set_visible(False)
                self._buffer.delete_mark_by_name(mark.get_name())
                self._marks.remove(mark)
                deleted += 1
        
        # Check included to watch for "mark leaking"
        if deleted > 1:
            print 'Multi-edit plugin: Mark leak detected'
        
        if deleted != 0 and not dont_remove:
            return
        
        # Add the mark
        self._marks.append(self._buffer.create_mark('multi-edit' + str(self._mark_i), pos, False))
        self._marks[len(self._marks) - 1].set_visible(True)
        self._mark_i += 1
    
    def _vertical_cursor_nav(self, down, smart_nav=False, edit_marks=True):
        """ Emulate normal vertical cursor movement.
        
        Main role is to overide the default action created by shift or ctrl.
        Marks are placed by default.
        
        Smart Nav: Navigates lines based on words instead of chars,
            but also sticks to end-of-lines when met.
        """
        pos = self._buffer.get_iter_at_mark(self._buffer.get_insert())
        start_of_line = pos.starts_line()
        end_of_line = pos.ends_line()
        seperators = string.whitespace + string.punctuation.replace('_', '')
        
        # Vertical mark memory (vertical)
        if edit_marks and (self._vert_mark_mem is None or self._vert_mark_mem[1] != smart_nav):
            self._vert_mark_mem = (pos.get_line(), smart_nav)
        
        # Initial mark edit
        if edit_marks:
            if (down and self._vert_mark_mem[0] > pos.get_line()) or \
               (not down and self._vert_mark_mem[0] < pos.get_line()):
                self._add_remove_mark()
            else:
                self._add_remove_mark(True)
        
        # Line offset memory (horizontal)
        if self._line_offset_mem is None or smart_nav != self._line_offset_mem["smart_nav"]:
            if not smart_nav:
                self._line_offset_mem = {
                    "smart_nav": False,
                    "data": self._get_physical_line_offset(self._buffer.get_insert()),
                }
            else:
                # Smart nav placement calculation
                if start_of_line or end_of_line:
                    word_offset = 0
                    char_offset = 0
                    end_gravity = None
                    mid_seperators = None
                else:
                    start_iter = pos.copy()
                    start_iter.set_line_offset(0)
                    text = start_iter.get_text(pos)
                    
                    end_gravity = text[-1:] not in seperators and pos.get_char() in seperators
                    mid_seperators = text[-1:] in seperators and pos.get_char() in seperators
                    end_gravity = end_gravity or mid_seperators
                    mid_word = text[-1:] not in seperators and pos.get_char() not in seperators
                    
                    # Convert seperators to spaces (to use split())
                    words = ''
                    for i, char in enumerate(text):
                        if char in seperators:
                            words += ' '
                        else:
                            words += char
                    words = words.split()
                    word_offset = len(words)
                    
                    # Account for leading seperators
                    if text[0] in seperators and not (mid_seperators and word_offset == 0):
                        word_offset += 1
                    
                    # Account for mid word
                    if mid_word:
                        word_offset -= 1
                    
                    char_offset = 0
                    if mid_word:
                        char_offset = len(words[-1])
                    elif mid_seperators:
                        text_iter = pos.copy()
                        text_iter.backward_char()
                        while text_iter.get_char() in seperators:
                            char_offset += 1
                            if text_iter.starts_line():
                                break
                            text_iter.backward_char()
                
                # Save values
                self._line_offset_mem = {
                    "smart_nav": True,
                    "data": {
                        "word_offset": word_offset,
                        "char_offset": char_offset,
                        "end_gravity": end_gravity,
                        "mid_seperators": mid_seperators,
                        "end_of_line": end_of_line,
                    },
                }
        
        # Line change
        if down:
            pos.forward_line()
        else:
            pos.backward_line()
        
        # Handle positioning for the new line
        if smart_nav:
            data = self._line_offset_mem["data"]
            if not pos.ends_line():
                if data["end_of_line"]:
                    pos.forward_to_line_end()
                else:
                    # Word offset
                    for i in range(data["word_offset"]):
                        # Forward till end of word
                        while pos.get_char() not in seperators and not pos.ends_line():
                            pos.forward_char()
                        # Stop at the word end if end_gravity and the last word offset
                        if data["end_gravity"] and i == data["word_offset"] - 1:
                            break
                        # Forward till next word
                        while pos.get_char() in seperators and not pos.ends_line():
                            pos.forward_char()
                    # Char offset
                    for i in range(data["char_offset"]):
                        # Stop if EOL or end of seperators if mid_seperators
                        if pos.ends_line() or (data["mid_seperators"] and \
                          pos.get_char() not in seperators):
                            break
                        pos.forward_char()
        else:
            log_offset = self._get_logical_line_offset(pos, self._line_offset_mem["data"])
            if pos.get_chars_in_line() <= log_offset:
                if not pos.ends_line():
                    pos.forward_to_line_end()
            else:
                pos.set_visible_line_offset(log_offset)
        
        # Place the cursor/mark
        self._cursor_move_supported = [True, True]
        self._buffer.place_cursor(pos)
        if edit_marks:
            self._add_remove_mark(True)
        else:
            # Reset the vert_mark_mem since it will now be invalid
            self._vert_mark_mem = None
    
    def _cleanup_marks(self):
        """ Remove any duplicate marks caused by text deletion. """
        offsets = []
        for mark in self._marks[:]:
            offset = self._buffer.get_iter_at_mark(mark).get_offset()
            if offset in offsets:
                self._buffer.delete_mark(mark)
                self._marks.remove(mark)
            else:
                offsets.append(offset)
    
    def _clear_marks(self):
        """ Exit multi-edit mode by removing any marks. """
        for mark in self._marks:
            mark.set_visible(False)  # Convenient way of redrawing just that mark's area
            self._buffer.delete_mark(mark)
        self._marks = []
        self._mark_i = 0


########NEW FILE########
__FILENAME__ = pair_char_completion
# -*- coding: utf-8 -*-
#
# Gedit plugin that does automatic pair character completion.
#
# Copyright  2010, Kevin McGuinness <kevin.mcguinness@gmail.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
# 

__version__ = '1.0.5'
__author__ = 'Kevin McGuinness'

import gedit
import gtk
import sys
import os

# Defaults
DEFAULT_STMT_TERMINATOR = ';'
LANG_META_STMT_TERMINATOR_KEY = 'statement-terminator'
NEWLINE_CHAR = '\n'

# Map from language identifiers to (opening parens, closing parens) pairs
language_parens = {}

def add_language_parenthesis(name, spec):
  """Add parenthesis for the given language. The spec should be a string in 
     which each pair of characters represents a pair of parenthesis for the 
     language, eg. "(){}[]".
  """
  parens = [], []
  for i in range(0, len(spec), 2):
    parens[0].append(spec[i+0])
    parens[1].append(spec[i+1])
  language_parens[name] = parens

def to_char(keyval_or_char):
  """Convert a event keyval or character to a character"""
  if isinstance(keyval_or_char, str):
    return keyval_or_char
  return chr(keyval_or_char) if 0 < keyval_or_char < 128 else None

class PairCompletionPlugin(gedit.Plugin):
  """Automatic pair character completion for gedit"""
  
  ViewHandlerName = 'pair_char_completion_handler'
 
  def __init__(self):
    gedit.Plugin.__init__(self)
    self.ctrl_enter_enabled = True
    self.language_id = 'plain'
    self.opening_parens = language_parens['default'][0]
    self.closing_parens = language_parens['default'][1]
 
  def activate(self, window):
    self.update_ui(window)
    
  def deactivate(self, window):
    for view in window.get_views():
      handler_id = getattr(view, self.ViewHandlerName, None)
      if handler_id is not None:
        view.disconnect(handler_id)
      setattr(view, self.ViewHandlerName, None)
    
  def update_ui(self, window):
    view = window.get_active_view()
    doc = window.get_active_document()
    if isinstance(view, gedit.View) and doc:
      if getattr(view, self.ViewHandlerName, None) is None:
        handler_id = view.connect('key-press-event', self.on_key_press, doc)
        setattr(view, self.ViewHandlerName, handler_id)
  
  def is_opening_paren(self,char):
    return char in self.opening_parens

  def is_closing_paren(self,char):
    return char in self.closing_parens

  def get_matching_opening_paren(self,closer):
    try:
      return self.opening_parens[self.closing_parens.index(closer)]
    except ValueError:
      return None

  def get_matching_closing_paren(self,opener):
    try:
      return self.closing_parens[self.opening_parens.index(opener)]
    except ValueError:
      return None

  def would_balance_parens(self, doc, closing_paren):
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    opening_paren = self.get_matching_opening_paren(closing_paren)
    balance = 1
    while balance != 0 and not iter1.is_start():
      iter1.backward_char()
      if iter1.get_char() == opening_paren:
        balance -= 1
      elif iter1.get_char() == closing_paren:
        balance += 1
    return balance == 0
  
  def compare_marks(self, doc, mark1, mark2):
    return doc.get_iter_at_mark(mark1).compare(doc.get_iter_at_mark(mark2))
  
  def enclose_selection(self, doc, opening_paren):
    closing_paren = self.get_matching_closing_paren(opening_paren)
    doc.begin_user_action()
    mark1 = doc.get_insert()
    mark2 = doc.get_selection_bound()
    if self.compare_marks(doc, mark1, mark2) > 0:
      mark1, mark2 = mark2, mark1
    doc.insert(doc.get_iter_at_mark(mark1), opening_paren)
    doc.insert(doc.get_iter_at_mark(mark2), closing_paren)
    iter1 = doc.get_iter_at_mark(mark2)
    doc.place_cursor(iter1)
    doc.end_user_action()
    return True
  
  def auto_close_paren(self, doc, opening_paren):
    closing_paren = self.get_matching_closing_paren(opening_paren)
    doc.begin_user_action()
    doc.insert_at_cursor(opening_paren+closing_paren)
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    iter1.backward_char()
    doc.place_cursor(iter1)
    doc.end_user_action()
    return True
  
  def move_cursor_forward(self, doc):
    doc.begin_user_action()
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    iter1.forward_char()
    doc.place_cursor(iter1)
    doc.end_user_action()
    return True

  def move_to_end_of_line_and_insert(self, doc, text):
    doc.begin_user_action()
    mark = doc.get_insert()
    iter1 = doc.get_iter_at_mark(mark)
    iter1.set_line_offset(0)
    iter1.forward_to_line_end()
    doc.place_cursor(iter1)
    doc.insert_at_cursor(text)
    doc.end_user_action()
    return True
    
  def insert_two_lines(self, doc, text):
    doc.begin_user_action()
    mark = doc.get_insert()
    iter1 = doc.get_iter_at_mark(mark)
    doc.place_cursor(iter1)
    doc.insert_at_cursor(text)
    doc.insert_at_cursor(text)
    mark = doc.get_insert()
    iter2 = doc.get_iter_at_mark(mark)
    iter2.backward_chars(len(text))
    doc.place_cursor(iter2)
    doc.end_user_action()
    return True
    
  def delete_both_parens(self, doc):
    doc.begin_user_action()
    start_iter = doc.get_iter_at_mark(doc.get_insert())
    end_iter = start_iter.copy()
    start_iter.backward_char()
    end_iter.forward_char()
    doc.delete(start_iter, end_iter)
    doc.end_user_action()
    return True
    
  def get_char_under_cursor(self, doc):
    return doc.get_iter_at_mark(doc.get_insert()).get_char()
    
  def get_stmt_terminator(self, doc):
    terminator = DEFAULT_STMT_TERMINATOR
    lang = doc.get_language()
    if lang is not None:
      # Allow this to be changed by the language definition
      lang_terminator = lang.get_metadata(LANG_META_STMT_TERMINATOR_KEY) 
      if lang_terminator is not None:
        terminator = lang_terminator
    return terminator
  
  def get_current_line_indent(self, doc):
    it_start = doc.get_iter_at_mark(doc.get_insert())
    it_start.set_line_offset(0)
    it_end = it_start.copy()
    it_end.forward_to_line_end()
    indentation = []
    while it_start.compare(it_end) < 0:
      char = it_start.get_char()
      if char == ' ' or char == '\t':
        indentation.append(char)
      else:
        break
      it_start.forward_char()
    return ''.join(indentation)
  
  def is_ctrl_enter(self, event):
    return (self.ctrl_enter_enabled and 
      event.keyval == gtk.keysyms.Return and
      event.state & gtk.gdk.CONTROL_MASK)
  
  def should_auto_close_paren(self, doc):
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    if iter1.is_end() or iter1.ends_line():
      return True
    char = iter1.get_char()
    return not (char.isalnum() or char == '_') 
  
  def update_language(self, doc):
    lang = doc.get_language()
    lang_id = lang.get_id() if lang is not None else 'plain'
    if lang_id != self.language_id:
      parens = language_parens.get(lang_id, language_parens['default'])
      self.opening_parens = parens[0]
      self.closing_parens = parens[1]
      self.language_id = lang_id
  
  def should_delete_both_parens(self, doc, event):
    if event.keyval == gtk.keysyms.BackSpace:
      it = doc.get_iter_at_mark(doc.get_insert())
      current_char = it.get_char()
      if self.is_closing_paren(current_char):
        it.backward_char()
        previous_char = it.get_char()
        matching_paren = self.get_matching_opening_paren(current_char) 
        return previous_char == matching_paren
    return False
  
  def on_key_press(self, view, event, doc):
    handled = False
    self.update_language(doc)
    ch = to_char(event.keyval)
    if self.is_closing_paren(ch):
      # Skip over closing parenthesis if doing so would mean that the 
      # preceeding parenthesis are correctly balanced
      if (self.get_char_under_cursor(doc) == ch and 
          self.would_balance_parens(doc, ch)):
        handled = self.move_cursor_forward(doc)
    if not handled and self.is_opening_paren(ch):
      if doc.get_has_selection():
        # Enclose selection in parenthesis or quotes
        handled = self.enclose_selection(doc, ch)
      elif self.should_auto_close_paren(doc): 
        # Insert matching closing parenthesis and move cursor back one 
        handled = self.auto_close_paren(doc, ch)
    if not handled and self.is_ctrl_enter(event):
      # Handle Ctrl+Return and Ctrl+Shift+Return
      text_to_insert = NEWLINE_CHAR + self.get_current_line_indent(doc)
      if event.state & gtk.gdk.SHIFT_MASK:
        text_to_insert = self.get_stmt_terminator(doc) + text_to_insert
      self.move_to_end_of_line_and_insert(doc, text_to_insert)
      view.scroll_mark_onscreen(doc.get_insert())
      handled = True
    if not handled and event.keyval in (gtk.keysyms.Return, gtk.keysyms.KP_Enter):
      # Enter was just pressed
      char_under_cursor = self.get_char_under_cursor(doc)
      if (self.is_closing_paren(char_under_cursor) and
        self.would_balance_parens(doc, char_under_cursor)):
        # If the character under the cursor would balance parenthesis
        text_to_insert = NEWLINE_CHAR + self.get_current_line_indent(doc)
        handled = self.insert_two_lines(doc, text_to_insert)
    if not handled and self.should_delete_both_parens(doc, event):
      # Delete parenthesis in front of cursor when one behind is deleted
      handled = self.delete_both_parens(doc)
    return handled

# Load language parenthesis
for path in sys.path:
  fn = os.path.join(path, 'pair_char_lang.py')
  if os.path.isfile(fn):
    execfile(fn, {'lang': add_language_parenthesis})
    break

########NEW FILE########
__FILENAME__ = pair_char_lang
# -*- coding: utf-8 -*-
#
# Programming language pair char support
#
# The default set is used if the language is not specified below. The plain
# set is used for plain text, or when the document has no specified language.
#
lang('default',    '(){}[]""\'\'``')
lang('changelog',  '(){}[]""<>')
lang('html',       '(){}[]""<>')
lang('ruby',       '(){}[]""\'\'``||')
lang('xml',        '(){}[]""<>')
lang('php',        '(){}[]""<>')
lang('plain',      '(){}[]""')
lang('latex',      '(){}[]""$$`\'')

########NEW FILE########
__FILENAME__ = config
import os
import pastie
import gtk
import gtk.glade

CONFIG_FILE = os.path.dirname( __file__ ) + '/config.pur'

LINKS = ['Clipboard', 'Window']
PRIVATES = ['True', 'False']
SYNTAXES = list(pastie.LANGS) 

class NoConfig(Exception): pass

class ConfigDialog():
    def __init__(self):
        self._glade = gtk.glade.XML( os.path.dirname( __file__ ) + "/Config.glade" )
        self.window = self._glade.get_widget("dialog")
        self._syntax = self._glade.get_widget("syntax")
        self._link = self._glade.get_widget("link")
        self._ok_button = self._glade.get_widget("ok_button")
        self._cancel_button = self._glade.get_widget("cancel_button")
        self._private = self._glade.get_widget("private")
        self.set_syntaxes()
        self.set_links()
        
        self._cancel_button.connect("clicked", self.hide)
    
    def set_syntaxes(self):
        for syntax in SYNTAXES:
            self._syntax.append_text(syntax)
    
    def set_links(self):
        for link in LINKS:
            self._link.append_text(link)
     
    def set_private(self, private):
        if private == "True":
            to_set = True
        else:
            to_set = False
        
        self._private.set_active(to_set)
        
    def set_syntax(self, syntax):
        self._syntax.set_active(SYNTAXES.index(syntax))
    
    def set_link(self, link):
        self._link.set_active(LINKS.index(link))
            
    def get_link(self):
        return self._link.get_model()[self._link.get_active()][0]
    
    def get_syntax(self):
        return self._syntax.get_model()[self._syntax.get_active()][0]

    def get_private(self):
        return self._private.get_active()
    
    def hide(self, widget=None, event=None):
        self.window.hide()
        self.reset()
        return True

    def connect_ok(self, func):
        self._ok_button.connect("clicked", lambda a: func())
    
        
class Configuration():

    def __init__(self):
        self._config_exists = os.access(CONFIG_FILE, os.R_OK)
        self.window = ConfigDialog()
        self.window.connect_ok(self.ok)
        try:
            self.read()
        except NoConfig:
            self.new()
        self.window_set()
        self.window.reset = self.window_set
        self.call_when_configuration_changes = None
        
    def error_dialog(self):
        dialog = gtk.MessageDialog(message_format="Error reading/writing configuration file!", 
                                   buttons = gtk.BUTTONS_OK,
                                   type = gtk.MESSAGE_ERROR )
        dialog.set_title("Error!")
        dialog.connect("response", lambda x, y: dialog.destroy())
        dialog.run()
    
    def read(self):
        if self._config_exists:
            try:
                f = open(CONFIG_FILE, 'rb')
            except:
                self.error_dialog()
            else:
                self.data = f.read()
                self.parse()
            finally:
                f.close()
        else:
            raise NoConfig
           
    def new(self):
        self.syntax = "Plain Text"
        self.link = "Window"
        self.private = "True"
        self.save()
        
    def parse(self):
        array = self.data.split("\n")
        if len(array) < 3:
            self.new()
        else:
          self.syntax = array[0]
          self.link = array[1]
          self.private = array[2]
        try:
            LINKS.index(self.link)
            PRIVATES.index(self.private)
            SYNTAXES.index(self.syntax) 
        except ValueError:
            self.new()
            
    def window_set(self):
        self.window.set_link(self.link)
        self.window.set_syntax(self.syntax)
        self.window.set_private(self.private)
        
    def ok(self):
        self.syntax = self.window.get_syntax()
        self.link = self.window.get_link()
        if self.window.get_private():
            self.private = "True"
        else:
            self.private = "False"
        self.save()
        self.window.hide()
        if self.call_when_configuration_changes:
            self.call_when_configuration_changes()
        
    def save(self):
        try:
            f = open(CONFIG_FILE, 'w')
        except:
            self.error_dialog()
        else:
            f.write("\n".join([self.syntax, self.link, self.private])+"\n")
        finally:
            f.close()
        

########NEW FILE########
__FILENAME__ = pastie
import urllib2
import urllib

PASTES = {
    'Ruby (on Rails)':'ruby_on_rails',
    'Ruby':'ruby',
    'Python':'python',
    'Plain Text':'plain_text',
    'ActionScript':'actionscript',
    'C/C++':'c++',
    'CSS':'css',
    'Diff':'diff',
    'HTML (Rails)':'html_rails',
    'HTML / XML':'html',
    'Java':'java',
    'JavaScript':'javascript',
    'Objective C/C++':'objective-c++',
    'PHP':'php',
    'SQL':'sql',
    'Shell Script':'shell-unix-generic'
}
#because dictionaries don't store order
LANGS = ('Ruby (on Rails)', 'Ruby', 'Python', 'Plain Text', 'ActionScript', 'C/C++', 'CSS', 'Diff', 'HTML (Rails)', 'HTML / XML', 'Java', 'JavaScript', 'Objective C/C++', 'PHP', 'SQL', 'Shell Script')
         
URL = 'http://pastie.org/pastes'

class Pastie:

    def __init__(self, text='', syntax='Plain Text', private=False):
        self.text = text
        self.syntax = syntax
        self.private = private

    def paste(self):
        if not PASTES.has_key(self.syntax):
            return 'Wrong syntax.'
        
        opener = urllib2.build_opener()
        params = {
                  'paste[body]':self.text,
                  'paste[parser]':PASTES[self.syntax],
                  'paste[authorization]':'burger' #pastie protecion against general spam bots
                  }
        if self.private:
            params['paste[restricted]'] = '1'
        else:
            params['paste[restricted]'] = '0'
            
        data = urllib.urlencode(params)
        request = urllib2.Request(URL, data)
        request.add_header('User-Agent', 'PastiePythonClass/1.0 +http://hiler.pl/')
        try:
            firstdatastream = opener.open(request)
        except:
            return 'We are sorry but something went wrong. Maybe pastie is down?'
        else:
            return firstdatastream.url
            

########NEW FILE########
__FILENAME__ = windows
import os
import pastie
import config
import gtk
import gtk.glade

class Window():

    def __init__(self, gladefile):
        self._glade = gtk.glade.XML( os.path.dirname( __file__ ) + "/" + gladefile )
        self._window = self._glade.get_widget("window")
        self._window.connect("delete_event", self._hide)
        
    def _hide(self, widget, event):
        widget.hide()
        return True
    
    def show(self, dummy=None):
        self._window.show()
        

class PastieWindow(Window):

    def __init__(self,):
        Window.__init__(self, "PasteWindow.glade")
       
        for lang in pastie.LANGS:
            self._glade.get_widget("syntax").append_text(lang)
        
        self._glade.get_widget("syntax").set_active(0) #sets active posision in syntax list
        self._glade.get_widget("ok_button").connect("clicked", self._ok_button)
        self._glade.get_widget("cancel_button").connect("clicked", lambda a: self._window.hide())
        
        self.inform = Inform()
        self.config = config.Configuration()
        
        self.set_from_defaults()
        self.config.call_when_configuration_changes = self.set_from_defaults
     
    def set_from_defaults(self):
        self._glade.get_widget("syntax").set_active(config.SYNTAXES.index(self.config.syntax))
        
        if self.config.private == "True":
            to_set = True
        else:
            to_set = False
        
        self._glade.get_widget("private").set_active(to_set)
        
        
    def _ok_button(self, event=None):
        text = self.get_text()
        combox = self._glade.get_widget("syntax")
        model = combox.get_model()
        active = combox.get_active()
        syntax = model[active][0]
        priv = self._glade.get_widget("private").get_active()
        self._window.hide()
        self._paste(syntax, priv, text, self.config.link)
        
    def paste_defaults(self, bla):
        if self.config.private == "True":
            private = True
        else:
            private = False
            
        self._paste(self.config.syntax, private, self.get_text(), self.config.link)
        
        
    def _paste(self, syntax, priv, text, link):
        "pastes selected text and displays window with link"
        p = pastie.Pastie(text, syntax, priv)
        paste = p.paste()
        if link == "Window":
            self.inform.entry.set_text("please wait")
            self.inform.show() #shows window
            self.inform.entry.set_text(paste)
        else:
            clipboard = gtk.clipboard_get('CLIPBOARD')
            clipboard.set_text(paste)
            clipboard.store()

class Inform(Window):

    def __init__(self):
        Window.__init__(self, "Inform.glade")
        self.entry = self._glade.get_widget("link")
        self._glade.get_widget("ok_button").connect("clicked", lambda a: self._window.hide())


########NEW FILE########
__FILENAME__ = rails_extract_partial
# -*- coding: utf8 -*-
# vim: ts=4 nowrap expandtab textwidth=80
# Rails Extract Partial Plugin
# Copyright  2008 Alexandre da Silva / Carlos Antonio da Silva
#
# This file is part of Gmate.
#
# See LICENTE.TXT for licence information

import gedit
import gtk
import gnomevfs
import os.path

class ExtractPartialPlugin(gedit.Plugin):

    ui_str = """
    <ui>
      <menubar name="MenuBar">
        <menu name="EditMenu" action="Edit">
          <placeholder name="EditOps_6">
              <menuitem action="ExtractPartial"/>
          </placeholder>
        </menu>
      </menubar>
    </ui>
    """
    #

    bookmarks = {}

    def __init__(self):
        gedit.Plugin.__init__(self)

    def activate(self, window):
        self.__window = window
        actions = [('ExtractPartial', None, 'Extract Partial',
                    '<Alt><Control>p', 'Extract select text to a partial',
                    self.extract_partial)]
        windowdata = dict()
        window.set_data("ExtractPartialPluginWindowDataKey", windowdata)
        windowdata["action_group"] = gtk.ActionGroup("GeditExtractPartialPluginActions")
        windowdata["action_group"].add_actions(actions, window)
        manager = window.get_ui_manager()
        manager.insert_action_group(windowdata["action_group"], -1)
        windowdata["ui_id"] = manager.add_ui_from_string(self.ui_str)
        window.set_data("ExtractPartialPluginInfo", windowdata)

    def deactivate(self, window):
        windowdata = window.get_data("ExtractPartialPluginWindowDataKey")
        manager = window.get_ui_manager()
        manager.remove_ui(windowdata["ui_id"])
        manager.remove_action_group(windowdata["action_group"])

    def update_ui(self, window):
        view = window.get_active_view()

        windowdata = window.get_data("ExtractPartialPluginWindowDataKey")
        windowdata["action_group"].set_sensitive(bool(view and view.get_editable()))

    def create_file(self, window, file_uri, text):
        window.create_tab_from_uri(str(file_uri),
                                        gedit.encoding_get_current(),
                                        0, True, True)
        view = window.get_active_view()
        buf = view.get_buffer()
        doc = window.get_active_document()
        doc.begin_user_action()
        buf.insert_interactive_at_cursor(text, True)
        doc.end_user_action()

    def extract_partial(self, action, window):
        doc = window.get_active_document()
        view = window.get_active_view()
        buf = view.get_buffer()
        language = buf.get_language()
        # Only RHTML
        if language.get_id() != 'rhtml' and language.get_id() != 'haml': return
        str_uri = doc.get_uri()
        if buf.get_has_selection():
            if str_uri:
                uri = gnomevfs.URI(str_uri)
                if uri:
                    path = uri.scheme + '://' + uri.dirname
                    dialog = gtk.Dialog("Enter partial Name",
                             window, gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                             (gtk.STOCK_CANCEL, gtk.RESPONSE_REJECT,
                             gtk.STOCK_OK, gtk.RESPONSE_ACCEPT))
                    dialog.set_alternative_button_order([gtk.RESPONSE_ACCEPT, gtk.RESPONSE_CANCEL])
                    dialog.vbox.pack_start(gtk.Label("Don't use _ nor extension(html.erb/erb/rhtml)"))
                    entry = gtk.Entry()
                    entry.connect('key-press-event', self.__dialog_key_press, dialog)
                    dialog.vbox.pack_start(entry)
                    dialog.show_all()
                    response = dialog.run()
                    if response == gtk.RESPONSE_ACCEPT:
                        partial_name = entry.get_text()
                        doc_name = doc.get_short_name_for_display()
                        extension = self.__get_file_extension(doc_name)
                        itstart, itend = doc.get_selection_bounds()
                        partial_text = doc.get_slice(itstart, itend, True)
                        if language.get_id() == 'haml':
                            partial_render = '= render :partial => "%s"' % partial_name
                        else:
                            partial_render = '<%%= render :partial => "%s" %%>' % partial_name
                        doc.begin_user_action()
                        doc.delete(itstart, itend)
                        doc.insert_interactive(itstart, partial_render, True)
                        doc.end_user_action()
                        file_name = "%s/_%s%s" % (path, partial_name, extension)
                        self.create_file(window, file_name, partial_text)
                    dialog.destroy()
        else: return

    def __get_file_extension(self, doc_name):
        name, ext = os.path.splitext(doc_name)
        if ext == '.rhtml':
            return ext
        if ext == '.erb':
            name, ext = os.path.splitext(name)
            return "%s.erb" % ext
        if ext == '.haml':
            name, ext = os.path.splitext(name)
            return "%s.haml" % ext
        return '.html.erb'

    def __dialog_key_press(self, widget, event, dialog):
        if event.keyval == 65293:
            dialog.response(gtk.RESPONSE_ACCEPT)

########NEW FILE########
__FILENAME__ = terminal
# -*- coding: utf-8 -*-

# Rails Hot Commands Gedit Plugin
#
# Copyright (C) 2007 - Tiago Bastos
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
# Thanks for: Nando Vieira - http://simplesideias.com.br/ (get_rails_root method)

import gtk
import gedit
import os
import os.path
from vte import Terminal
import gconf
import gnomevfs

class TerminaldWidget():
    def __init__(self, window):
        self.window = window

        self.bottom = window.get_bottom_panel()

        self.uri = window.get_active_document().get_uri_for_display()
        self.term = Terminal()
        self.term.set_emulation("xterm")
        self.term.set_audible_bell(False)
        self.term.set_scrollback_lines(150)
        self.term.set_size_request(10,100)
        self.term.fork_command('bash')

        self.term_scrollbar = gtk.VScrollbar()
        self.term_scrollbar.set_adjustment(self.term.get_adjustment())

        self.term_box = gtk.HBox()
        self.term_box.pack_start(self.term, True, True, 0)
        self.term_box.pack_end(self.term_scrollbar, False, False, 0)

        self.close_bt = gtk.Button("Close")
        self.close_bt.connect("clicked", self.close_bt_action, "Exit!")

        self.container = gtk.VBox(False)

       # self.term.connect("child-exited", lambda term: term.fork_command('irb'))
        self.term.connect("child-exited", self.close_term_action_child_exited)

        self.table = gtk.Table(2,1,False)
        self.table.attach(self.term_box,0,1,0,1)
        self.table.attach(self.close_bt,0,1,1,2,gtk.FILL|gtk.SHRINK,gtk.FILL|gtk.SHRINK, 0, 0)
        self.container.pack_start(self.table)
        self.close_bt.show()
        self.table.show()
        self.term_box.show_all()

    def close_bt_action(self, widget, data=None):
      self.close()

    def close_term_action_child_exited(self, term):
      self.close()

    def close(self):
        self.bottom.remove_item(self.container)
        self.bottom.hide()
        self.container.destroy()

    def run(self,command=''):
        self.rails_root = self.get_rails_root(self.uri)

        if self.rails_root=='':
             self.rails_root = self.get_filebrowser_root()

        if self.rails_root=='':
            os.popen("notify-send -t 1600 -i gtk-dialog-info 'Alert!' 'This is not a rails project file!'")
        elif command.strip()=='':
            os.popen("notify-send -t 1600 -i gtk-dialog-info 'Alert!' 'Hey, type something!'")
        else:
            self.term.feed_child("cd "+self.rails_root+" \n")
            self.term.feed_child(command+"\n")

            self.bottom.show()

            self.image = gtk.Image()
            self.image.set_from_icon_name('gnome-mime-application-x-shellscript', gtk.ICON_SIZE_MENU)

            self.bottom.add_item(self.container, _('Run Rails Command: '+command), self.image)
            self.window.set_data('RubyTerminalPluginInfo', self.container)
            self.bottom.activate_item(self.container)
            self.term.grab_focus()
        self.close_bt_action()

    def get_rails_root(self, uri):
        base_dir = os.path.dirname(uri)
        depth = 10
        rails_root = ''

        while depth > 0:
            depth -= 1
            app_dir = os.path.join(base_dir, 'app')
            config_dir = os.path.join(base_dir, 'config')
            if os.path.isdir(app_dir) and os.path.isdir(config_dir):
                rails_root = base_dir
                break
            else:
                base_dir = os.path.abspath(os.path.join(base_dir, '..'))
        return rails_root


    # FileBrowser Integration
    def get_filebrowser_root(self):
       base = u'/apps/gedit-2/plugins/filebrowser/on_load'
       client = gconf.client_get_default()
       client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
       path = os.path.join(base, u'virtual_root')
       val = client.get(path)
       if val is not None:
          return gnomevfs.get_local_path_from_uri(val.get_string())
       else:
          return ''

########NEW FILE########
__FILENAME__ = regexsearchinstance
import gedit
from gettext import gettext as _
import gtk
import gtk.glade
import os
import re

ui_str = """
<ui>
    <menubar name="MenuBar">
        <menu name="ToolsMenu" action="Tools">
            <placeholder name="ToolsOps_3">
                <menuitem name="Regex Search and Replace" action="RegexSearch"/>
            </placeholder>
        </menu>
    </menubar>
</ui>
"""

GLADE_FILE = os.path.join(os.path.dirname(__file__), "regexsearch.glade")

class RegexSearchInstance:

    ###
    # Object initialization
    def __init__(self, window):
        self._window = window
        self.create_menu_item()
        self.load_dialog()


    ###
    # Create menu item
    # Create our menu item in "Tools" menu.
    def create_menu_item(self):
        manager = self._window.get_ui_manager()
        self._action_group = gtk.ActionGroup("RegexSearchActions")
        regexreplace_action = gtk.Action("RegexSearch", _("Regex Search & Replace"), _("Search using regular expressions"), gtk.STOCK_FIND_AND_REPLACE)
        regexreplace_action.connect("activate", self.on_open_regex_dialog)
        self._action_group.add_action_with_accel( regexreplace_action, "<Ctrl><Alt>h" )
        manager.insert_action_group( self._action_group, -1)
        manager.add_ui_from_string(ui_str)
        manager.ensure_update()

    ###
    # Load dialog.
    #   - Load dialog from its Glade file
    #   - Connect widget signals
    #   - Put needed widgets in object variables.
    def load_dialog(self):
        glade_xml = gtk.glade.XML(GLADE_FILE)

        self._search_dialog = glade_xml.get_widget("search_dialog")
        self._search_dialog.hide()
        self._search_dialog.set_transient_for(self._window)
        self._search_dialog.set_destroy_with_parent(True)
        self._search_dialog.connect("delete_event", self._search_dialog.hide_on_delete)

        self._find_button = glade_xml.get_widget("find_button")
        self._find_button.connect("clicked", self.on_find_button_clicked)

        self._replace_button = glade_xml.get_widget("replace_button")
        self._replace_button.connect("clicked", self.on_replace_button_clicked)
        self._replace_all_button = glade_xml.get_widget("replace_all_button")
        self._replace_all_button.connect("clicked", self.on_replace_all_button_clicked)

#        close_button = glade_xml.get_widget("close_button")
#        close_button.connect("clicked", self.on_close_button_clicked)

        self._search_text_box = glade_xml.get_widget("search_text")
        self._search_text_box.connect("changed", self.on_search_text_changed)

        self._replace_text_box = glade_xml.get_widget("replace_text")
        self._replace_text_box.connect("changed", self.on_replace_text_changed)

        self._wrap_around_check = glade_xml.get_widget("wrap_around_check")
        self._use_backreferences_check = glade_xml.get_widget("use_backreferences_check")
        self._case_sensitive_check = glade_xml.get_widget("case_sensitive_check")


    ###
    # Called when the "Find" button is clicked.
    def on_find_button_clicked(self, find_button):
        self.search_document()

    ###
    # Called when the "Replace" button is clicked.
    def on_replace_button_clicked(self, replace_button):
        self.search_document(button = 'replace')

    # Called when the "Replace All" button is clicked.
    def on_replace_all_button_clicked(self, replace_button):
        document = self._window.get_active_document()
        start_iter = document.get_start_iter()
        end_iter = document.get_end_iter()
        alltext = unicode(document.get_text(start_iter, end_iter, False), "utf-8")

        regex = self.create_regex()
        if regex==None: return

        replace_string = self._replace_text_box.get_text()
        if not self._use_backreferences_check.get_active():
            replace_string = replace_string.replace('\\','\\\\') # turn \ into \\ so that backreferences are not done.

        new_string, n_replacements = regex.subn(replace_string, alltext)

        selection_bound_mark = document.get_mark("selection_bound")
        document.place_cursor(start_iter)
        document.move_mark(selection_bound_mark, end_iter)
        document.delete_selection(False, False)
        document.insert_at_cursor(new_string)

        self.show_alert_dialog(u"%d replacement(s)." % (n_replacements))

    ###
#    # Called when the "Close" button is clicked.
#    def on_close_button_clicked(self, close_button):
#        self._search_dialog.hide()

    def create_regex(self):
        try:
            # note multi-line flag, and dot does not match newline.
            if self._case_sensitive_check.get_active():
                regex = re.compile( unicode(self._search_text_box.get_text(), "utf-8"), re.MULTILINE)
            else:
                regex = re.compile( unicode(self._search_text_box.get_text(), "utf-8"), re.MULTILINE | re.IGNORECASE)
        except:
            self.show_alert_dialog(u"Invalid regular expression.")
            return None
        return regex

    ###
    # Called when the text to be searched is changed. We enable the fields once. (still want to be able to replace '')
    def on_search_text_changed(self, search_text_entry):
        search_text  = search_text_entry.get_text()
        replace_text_entry = self._replace_text_box

        if len(search_text) > 0:
            self._find_button.set_sensitive(True)
        else:
            self._find_button.set_sensitive(False)

        self.on_replace_text_changed(replace_text_entry)

    ###
    # Called when the text to be replaced is changed.
    def on_replace_text_changed(self, replace_text_entry):
        if not self.enable_replace:
            replace_text = replace_text_entry.get_text()
            search_text  =  self._search_text_box.get_text()

            if len(search_text) > 0 and len(replace_text) > 0:
                self._replace_button.set_sensitive(True)
                self._replace_all_button.set_sensitive(True)
                self.enable_replace = True

    ###
    # To update plugin's user interface
    def update_ui(self):
        pass


    ###
    # Called to open the Regex Search dialog.
    def on_open_regex_dialog (self, action = None):
        self.enable_replace = False
        self._search_dialog.show()


    ###
    # Search the document.
    #
    # The search begins from the current cursor position.
    def search_document(self, start_iter = None, wrapped_around = False, button = 'search'):
        document = self._window.get_active_document()

        if start_iter is None:
            start_iter = document.get_iter_at_mark(document.get_insert())

        end_iter = document.get_end_iter()

        regex = self.create_regex()
        if regex==None: return

        text = unicode(document.get_text(start_iter, end_iter, False), "utf-8")
        result = regex.search(text)

        if result != None:
            # There is a match

            self.handle_search_result(result, document, start_iter, wrapped_around, button)
        else:
            # No match found

            if self._wrap_around_check.get_active() and not wrapped_around and start_iter.get_offset() > 0:
                # Let's wrap around, searching the whole document
                self.search_document(document.get_start_iter(), True,button)
            else:
                # We've already wrapped around. There's no match in the whole document.
                self.show_alert_dialog(u"No match found for regular expression \"%s\"." % self._search_text_box.get_text())



    def show_alert_dialog(self, s):
        dlg = gtk.MessageDialog(self._window,
                                gtk.DIALOG_MODAL | gtk.DIALOG_DESTROY_WITH_PARENT,
                                gtk.MESSAGE_INFO,
                                gtk.BUTTONS_CLOSE,
                                _(s))
        dlg.run()
        dlg.hide()

    ###
    # Handle search's result.
    # If the result is already selected, we search for the next match.
    # Otherwise we show it.
    #
    # The parameter "result" should contain the match result of a regex search.
    def handle_search_result(self, result, document, start_iter, wrapped_around = False,button='search'):
        curr_iter = document.get_iter_at_mark(document.get_insert())

        selection_bound_mark = document.get_mark("selection_bound")
        selection_bound_iter = document.get_iter_at_mark(selection_bound_mark)

        if button=='search':
            # If our result is already selected, we will search again starting from the end of
            # of the current result.
            if start_iter.get_offset() + result.start() == curr_iter.get_offset() and \
               start_iter.get_offset() + result.end() == selection_bound_iter.get_offset():

                start_iter.forward_chars(result.end()+1) # To the first char after the current selection/match.

                # fixed bug- no wrapping when match at end of document, used to be get_offset() < document
                if start_iter.get_offset() <= document.get_end_iter().get_offset() and not wrapped_around:
                    self.search_document(start_iter,False,button)
            else:
                self.show_search_result(result, document, start_iter, button)
        else:
            # If we are replacing, and there is a selection that matches, we want to replace the selection.
            # don't advance the cursor
            self.show_search_result(result, document, start_iter, button)

    ###
    # Show search's result.
    # i.e.: Select the search result text, scroll to that position, etc.
    #
    # The parameter "result" should contain the match result of a regex search.
    def show_search_result(self, result, document, start_iter,button):

        selection_bound_mark = document.get_mark("selection_bound")

        result_start_iter = document.get_iter_at_offset(start_iter.get_offset() + result.start())
        result_end_iter = document.get_iter_at_offset(start_iter.get_offset() + result.end())

        document.place_cursor(result_start_iter)
        document.move_mark(selection_bound_mark, result_end_iter)

        if (button == 'replace'):
            replace_text = self._replace_text_box.get_text()
            self.replace_text(document,replace_text, result)

        view = self._window.get_active_view()
        view.scroll_to_cursor()

    def replace_text(self,document,replace_string, result):
        if not self._use_backreferences_check.get_active():
            replace_text = replace_string
        else:
            replace_text = result.expand(replace_string) # perform backslash expansion, like \1
        document.delete_selection(False, False)
        document.insert_at_cursor(replace_text)

        #now select the text that was replaced


########NEW FILE########
__FILENAME__ = plugin
# -*- coding: utf-8 -*-

#  Copyright (C) 2008 - Eugene Khorev
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

import pygtk
pygtk.require("2.0")
import gtk
import gedit
import time
import os
import sys
import getopt
import ConfigParser
import gettext

APP_NAME = "plugin"
LOC_PATH = os.path.join(os.path.expanduser("~/.gnome2/gedit/plugins/reopen-tabs/lang"))

gettext.find(APP_NAME, LOC_PATH)
gettext.install(APP_NAME, LOC_PATH, True)

RELOADER_STATE_READY        = "ready"
RELOADER_STATE_INIT         = "init"
RELOADER_STATE_RELOADING    = "reloading"
RELOADER_STATE_DONE         = "done"
RELOADER_STATE_CLOSING      = "closing"

def log(msg):
	print '\033[32m' + msg + '\033[0m'


class ReopenTabsPlugin(gedit.Plugin):


	def __init__(self):
		gedit.Plugin.__init__(self)
		
		self._config = None
		
		self._state = RELOADER_STATE_INIT


	def activate(self, window):
		log('Event: app activated')
		self.read_config()

		window.connect("active-tab-changed", self._on_active_tab_changed)
		window.connect("active-tab-state-changed", self._on_active_tab_state_changed)
		window.connect("tabs-reordered", self._on_tabs_reordered)
		window.connect("tab-removed", self._on_tab_removed)

		# Register signal handler to ask a user to save tabs on exit
		window.connect("delete_event", self._on_destroy)
		

	def deactivate(self, window):
		log('Event: app deactivate')
		pass


	def read_config(self): # Reads configuration from a file
		# Get configuration dictionary
		self._conf_path = os.path.join(os.path.expanduser("~/.gnome2/gedit/plugins/"), "reopen-tabs/plugin.conf")

		# Check if configuration file does not exists
		if not os.path.exists(self._conf_path):
			# Create configuration file
			conf_file = file(self._conf_path, "wt")
			conf_file.close()

		self._conf_file = file(self._conf_path, "r+")
		self._config = ConfigParser.ConfigParser()
		self._config.readfp(self._conf_file)
		self._conf_file.close()

		# Setup default configuration if needed
		if not self._config.has_section("common"):
			self._config.add_section("common")

		if not self._config.has_option("common", "active_document"):
			self._config.set("common", "active_document", "")

		if not self._config.has_section("documents"):
			self._config.add_section("documents")

	def write_config(self): # Saves configuration to a file
		self._conf_file = file(self._conf_path, "r+")
		self._conf_file.truncate(0)
		self._config.write(self._conf_file)
		self._conf_file.close()
	
	def _on_tabs_reordered(self, window):
		log('Event: tabs reordered')
		if self._state == RELOADER_STATE_DONE:
			self._save_tabs()


	def _on_tab_removed(self, window, data):
		log('Event: tab removed (%s, %s)' % (self._state, window.get_state()))
		if self._state == RELOADER_STATE_DONE:
			self._save_tabs()


	def _on_active_tab_changed(self, window, tab):
		log('Event: active tab changed')
		if self._state == RELOADER_STATE_INIT:
			self._state = RELOADER_STATE_READY
			self._on_active_tab_state_changed(window)


	def _on_active_tab_state_changed(self, window):
		log('Event: active state tab changed: ' + str(window.get_active_tab().get_state()))
		log('Event: active state tab changed: ' + str(window.get_state()))
		# Check if we are not reloading and did not finished yet
		if self._state in (RELOADER_STATE_READY, RELOADER_STATE_DONE):
			# Get active tab
			tab = window.get_active_tab()
			# Check if we are ready to reload
			if tab and tab.get_state() == gedit.TAB_STATE_NORMAL:
				if self._state == RELOADER_STATE_READY:
					self._state = RELOADER_STATE_RELOADING
					self._reopen_tabs(window)
					self._state = RELOADER_STATE_DONE
				else:
					self._save_tabs()


	def update_ui(self, window):
		pass


	def _on_destroy(self, widget, event): # Handles window destory (saves tabs if required)
		log('Event: app destroy')
		self._state = RELOADER_STATE_CLOSING
	
	import time

	def _save_tabs(self): # Save opened tabs in configuration file
		log('ACTION save tabs')
		start = time.time()
		# Clear old document list
		self._config.remove_section("documents")

		# Get document URI list
		app = gedit.app_get_default()
		win = app.get_active_window()
		
		# Return list of documents which having URI's
		docs = [d.get_uri() for d in win.get_documents() if d.get_uri()]
		
		# Check if there is anything to save
		if len(docs) > 0:
			self._config.add_section("documents")
			self._config.remove_option("common", "active_document")
	
			cur_doc = win.get_active_document()
			if cur_doc: cur_uri = cur_doc.get_uri()
			else: cur_uri = None
			cur_doc = None
		
			# Create new document list
			n = 1
			for uri in docs:
				# Setup option name
				name = "document" + str(n).rjust(3).replace(" ", "0")
		
				# Check if current document is active
				if uri == cur_uri:
					cur_doc = name

				self._config.set("documents", name, uri)
				n = n + 1

			# Remeber active document
			if cur_doc:
				self._config.set("common", "active_document", cur_doc)

		self.write_config()
		end = time.time()
		
		if self._config.has_section("documents"):
			log(str(self._config.options("documents")))
		else:
			log('[]')
		log('>>> %0.3fms' % (1000 * (end - start)))
		
	def _reopen_tabs(self, window):
		log('ACTION load tabs')
		# Get list of open documents
		open_docs = [d.get_uri() for d in window.get_documents() if d.get_uri()]
		
		# Get saved active document
		active = self._config.get("common", "active_document")
	
		# Get document list
		docs = self._config.options("documents")
		log(str(docs))

		empty_tab = None
		active_tab = None

		# Check if active document is untitled (there is empty tab)
		if window.get_active_document().is_untitled():
			# Remember empty tab to close it later
			empty_tab = window.get_active_tab()

		# Check if document list is not empty
		if len(docs) > 0:
			
			# Process the rest documents
			for d in docs:
				# Get document uri
				uri = self._config.get("documents", d)
				
				# Check if document is not already opened
				if open_docs.count(uri) > 0: continue

				# Check if document exists
				if not os.path.exists(uri.replace('file://', '', 1)): continue

				# Create new tab
				tab = window.create_tab_from_uri(uri, None, 0, True, False)
		
				# Check if document was active (and there is NOT file in command line)
				if d == active and empty_tab != None:
					active_tab = tab

		# Connect handler that switches saved active document tab
		log('empty tab: ' + str(empty_tab))
		log('activ tab: ' + str(active_tab))
		if active_tab:
			def on_doc_loaded(doc, arg):
				window.set_active_tab(active_tab)
				if empty_tab:
					_state = self._state
					self._state = RELOADER_STATE_CLOSING
					window.close_tab(empty_tab)
					self._state = _state

			active_tab.get_document().connect("loaded", on_doc_loaded)
		if empty_tab == None:
			self._save_tabs()


########NEW FILE########
__FILENAME__ = rubyonrailsloader
# Copyright (C) 2009 Alexandre da Silva
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

"""Automatically detects if file resides in a ruby on rails application and set the properly language."""

import gedit, os

class RubyOnRailsLoader(gedit.Plugin):

    """Automatically strip all trailing whitespace before saving."""

    def activate(self, window):
        """Activate plugin."""
        self.window = window
        handler_id = window.connect("tab-added", self.on_window_tab_added)
        window.set_data(self.__class__.__name__, handler_id)
        for doc in window.get_documents():
            self.connect_document(doc)

    def connect_document(self, doc):
        """Connect to document's 'load' signal."""

        handler_id = doc.connect("loaded", self.on_document_load)
        doc.set_data(self.__class__.__name__, handler_id)


    def deactivate(self, window):
        """Deactivate plugin."""

        name = self.__class__.__name__
        handler_id = window.get_data(name)
        window.disconnect(handler_id)
        window.set_data(name, None)


    def on_window_tab_added(self, window, tab):
        """Connect the document in tab."""
        doc = tab.get_document()
        self.connect_document(doc)


    def on_document_load(self, doc, *args):
        language = doc.get_language()
        if language:
            lang = language.get_id()
            if lang == 'ruby':
                uri = doc.get_uri_for_display()
                if self.get_in_rails(uri):
                    lang = gedit.get_language_manager().get_language('rubyonrails')
                    doc.set_language(lang)
                    # Uggly workarroud to call update_ui
                    view = gedit.tab_get_from_document(doc).get_view()
                    editable = view.get_editable()
                    view.set_editable(not editable)
                    view.set_editable(editable)



    def get_in_rails(self, uri):
        rails_root = self.get_data('RailsLoaderRoot')
        if rails_root:
            return rails_root
        base_dir = os.path.dirname(uri)
        depth = 10
        while depth > 0:
            depth -= 1
            app_dir = os.path.join(base_dir, 'app')
            config_dir = os.path.join(base_dir, 'config')
            environment_file = os.path.join(base_dir, 'config', 'environment.rb')
            if os.path.isdir(app_dir) and os.path.isdir(config_dir) and os.path.isfile(environment_file):
                rails_root = base_dir
                break
            else:
                base_dir = os.path.abspath(os.path.join(base_dir, '..'))
        if rails_root:
            self.set_data('RailsLoaderRoot', rails_root)
            return True
        return False


    def set_data(self, name, value):
        self.window.get_active_tab().get_view().set_data(name, value)


    def get_data(self, name):
        return self.window.get_active_tab().get_view().get_data(name)


########NEW FILE########
__FILENAME__ = tabswitch
# -*- coding: utf-8 -*-

VERSION = "0.1"

import gedit, gtk
from gettext import gettext as _
import cPickle, os

class TabSwitchPlugin(gedit.Plugin):
    
    def __init__(self):
        gedit.Plugin.__init__(self)
        
        self.id_name = 'TabSwitchPluginID'
    
    def activate(self, window):
        self.window = window
        
        l_ids = []
        for signal in ('key-press-event',):
            method = getattr(self, 'on_window_' + signal.replace('-', '_'))
            l_ids.append(window.connect(signal, method))
        window.set_data(self.id_name, l_ids)
    
    def deactivate(self, window):
        l_ids = window.get_data(self.id_name)
        
        for l_id in l_ids:
            window.disconnect(l_id)
    
    def on_window_key_press_event(self, window, event):
        key = gtk.gdk.keyval_name(event.keyval)
       
        if event.state & gtk.gdk.CONTROL_MASK and key in ('Tab', 'ISO_Left_Tab'):
            atab = window.get_active_tab()
            tabs = atab.parent.get_children()
            tlen = len(tabs)
            i = 0
            tab = atab
            
            for tab in tabs:
                i += 1
                if tab == atab:
                    break
            
            if key == 'ISO_Left_Tab':
                i -= 2
            
            if i < 0:
                tab = tabs[tlen-1]
            elif i >= tlen:
                tab = tabs[0]
            else:
                tab = tabs[i]
            
            window.set_active_tab(tab)
            
            return True


########NEW FILE########
__FILENAME__ = textmap
# Copyright 2011, Dan Gindikin <dgindikin@gmail.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

import gtk
import time
import gobject
import gedit
import sys
import math
import cairo
import re
import copy
import platform

version = "0.2 beta"

# ------------------------------------------------------------------------------
# These regular expressions are applied in sequence ot each line, to determine
# whether it is a section start or not

SectionREs = (
  re.compile('def\s*(\w+)\s*\('),                          # python method
  re.compile('class\s*(\w+)\s*'),                          # python/java class
  
  re.compile('cdef\s*class\s*(\w+)\s*[(:]'),               # cython class
  re.compile('cdef\s*(?:[\w\.]*?\**\s*)?(\w+)\s*\('),      # cython method
  
  re.compile('^(\w*)\s*\('),                               # C method
  re.compile('^\w+[\w\s\*]*?(\w*)\s*\('),                  # C method
  
  re.compile('^function\s*(\w+)\s*\('),                    # javascript method
  
  re.compile('\w+[\w\s]*?class (\w*)'),                    # java class
)

SubsectionREs = (
  re.compile('\s+def\s*(\w+)\s*\('),                       # python class method
  
  re.compile('\s+cdef\s*(?:[\w\.]*?\**\s*)?(\w+)\s*\('),   # cython class method
  
  re.compile('\s+(?:public|static|private|final)[\w\s]*?(\w+)\s*\('), # java method
)

# ------------------------------------------------------------------------------

class struct:pass

class TimeRec:
  def __init__(M):
    M.tot = M.N = M.childtot = M.heretot = 0
    M.start_ = None
    
class Timer:
  'L == label'
  def __init__(M):
    M.dat = {}
    M.stack = []
  def push(M,L):
    assert L not in M.stack,(L,M.stack)
    M.stack.append(L)
    tmrec = M.dat.setdefault(L,TimeRec())
    tmrec.start_=time.time()
  def pop(M,L):
    assert M.stack[-1]==L,(L,M.stack)
    M.stack.pop()
    tmrec = M.dat[L]
    dur = time.time()-tmrec.start_
    tmrec.start_ = None
    tmrec.tot += dur
    tmrec.N += 1
    #for parent in M.stack:
    #  M.dat[parent].childtot += dur
    if M.stack <> []:
      M.dat[M.stack[-1]].childtot += dur
  def print_(M):
    for tmrec in M.dat.values():
      tmrec.heretot = tmrec.tot-tmrec.childtot
    R = sorted(M.dat.items(),lambda x,y:-cmp(x[1].heretot,y[1].heretot))
    print '%7s %7s %5s' % ('Tm Here', 'Tm Avg', 'Count')
    for L,tmrec in R:
      print '%7s %7s %5d %s' % ('%.3f'%tmrec.heretot, '%.3f'%(tmrec.heretot/float(tmrec.N)), tmrec.N, L)
    print
      
#TIMER = Timer()
TIMER = None
   
def indent(s):
  x = 0
  for c in s:
    if c == ' ':
      x += 1
    elif c == '\t':
      x += 8
    else:
      break
  return x
  
def probj(ob,*substrs):
  meths = dir(ob)
  meths.sort()
  print ob,type(ob)
  for m in meths:
    doprint=True
    if substrs:
      doprint=False
      for s in substrs:
        if s in m:
          doprint=True
          break
    if doprint:
      print '%40s'%m
      
def match_RE_list(str, REs):
  for r in REs:
    m = r.match(str)
    if m:
      return m.groups()[0]
  return None

def document_lines(document):
  if not document:
    return None
  #print 'document_lines',document
  STR = document.get_property('text')
  lines = STR.split('\n')
  ans = []
  for i,each in enumerate(lines):
    x = struct()
    x.i = i
    x.len = len(each)
    x.indent = indent(each)
    x.raw = each
    x.section = match_RE_list(x.raw,SectionREs)
    x.subsection = None
    x.search_match = False
    if not x.section:
      x.subsection = match_RE_list(x.raw,SubsectionREs)
    if x.section or x.subsection:
      match = Split_Off_Indent_Pattern.match(x.raw)
      x.indentSTR = None
      x.justextSTR = None
      if match:
        groups = match.groups()
        if len(groups) == 2:
          x.indentSTR, x.justextSTR = groups
    ans.append(x)
  return ans
  
def lines_add_section_len(lines):
  line_prevsection = None
  counter = 0
  for i, line in enumerate(lines):
    if line.section:
      if line_prevsection:
        line_prevsection.section_len = counter
      line_prevsection = line
      counter = 0
    counter += 1
  if line_prevsection:
    line_prevsection.section_len = counter
  return lines

def lines_mark_changed_sections(lines):
  sec = None
  subsec = None
  for line in lines:
    if line.section:
      line.sectionchanged = False
      sec = line
      subsec = None
    if line.subsection:
      line.subsectionchanged = False
      subsec = line
    if line.changed:
      if sec is not None:
        sec.sectionchanged = True
      if subsec is not None:
        subsec.subsectionchanged = True
  return lines
  
BUG_MASK = 0

BUG_CAIRO_MAC_FONT_REF  = 1
BUG_CAIRO_TEXT_EXTENTS  = 2
BUG_DOC_GET_SEARCH_TEXT = 4

if platform.system() == 'Darwin':
  BUG_MASK |= BUG_CAIRO_MAC_FONT_REF  # extra decref causes aborts, use less font ops

major,minor,patch = gedit.version
if major<=2 and minor<28:
  BUG_MASK |= BUG_CAIRO_TEXT_EXTENTS  # some reference problem
  BUG_MASK |= BUG_DOC_GET_SEARCH_TEXT # missing INCREF then
  
def text_extents(str,cr):
  "code around bug in older cairo"
  
  if BUG_MASK & BUG_CAIRO_TEXT_EXTENTS:  
    if str:
      x, y = cr.get_current_point()
      cr.move_to(0,-5)
      cr.show_text(str)
      nx,ny = cr.get_current_point()
      cr.move_to(x,y)
    else:
      nx = 0
      ny = 0

    #print repr(str),x,nx,y,ny
    ascent, descent, height, max_x_advance, max_y_advance = cr.font_extents()
    
    return nx, height
  
  else:
  
    x_bearing, y_bearing, width, height, x_advance, y_advance = cr.text_extents(str)
    return width, height
    
def pr_text_extents(s,cr):
  x_bearing, y_bearing, width, height, x_advance, y_advance = cr.text_extents(s)
  print repr(s),':','x_bearing',x_bearing,'y_bearing',y_bearing,'width',width,'height',height,'x_advance',x_advance,'y_advance',y_advance
  
def show_section_label(str, fg, bg, cr):
  tw,th = text_extents(str,cr)
  x,y = cr.get_current_point()
  cr.set_source_rgba(bg[0],bg[1],bg[2],.75)
  cr.rectangle(x,y-th+3,tw,th)
  cr.fill()
  cr.move_to(x,y)
  cr.set_source_rgb(*fg)
  cr.show_text(str)
    
def fit_text(str, w, h, fg, bg, cr):
  moved_down = False
  originalx,_ = cr.get_current_point()
  sofarH = 0
  rn = []
  if dark(*bg):
    bg_rect_C = lighten(.1,*bg)
  else:
    bg_rect_C = darken(.1,*bg)
    
  while 1:
    # find the next chunk of the string that fits
    for i in range(len(str)):
      tw, th = text_extents(str[:i],cr)
      if tw > w:
        break
    disp = str[:i+1]
    str = str[i+1:]
    tw, th = text_extents(disp,cr)
    
    sofarH += th
    if sofarH > h:
      return rn
    if not moved_down:
      moved_down = True
      cr.rel_move_to(0, th)
      
    # bg rectangle
    x,y = cr.get_current_point()
    #cr.set_source_rgba(46/256.,52/256.,54/256.,.75)
    cr.set_source_rgba(bg_rect_C[0],bg_rect_C[1],bg_rect_C[2],.75)
    if str:
      cr.rectangle(x,y-th+2,tw,th+3)
    else: # last line does not need a very big rectangle
      cr.rectangle(x,y-th+2,tw,th)    
    cr.fill()
    cr.move_to(x,y)
    
    # actually display
    cr.set_source_rgb(*fg)
    cr.show_text(disp)
    
    # remember
    rec = struct()
    rec.x = x
    rec.y = y
    rec.th = th
    rec.tw = tw
    rn.append(rec)
    
    cr.rel_move_to(0,th+3)
    x,y = cr.get_current_point()
    cr.move_to(originalx,y)
    
    if not str:
      break
  return rn
      
def downsample_lines(lines, h, min_scale, max_scale):
  n = len(lines)
  
  # pick scale
  for scale in range(max_scale,min_scale-1,-1): 
    maxlines_ = h/(.85*scale)
    if n < 2*maxlines_:
      break
      
  if n <= maxlines_:
    downsampled = False
    return lines, scale, downsampled
    
  # need to downsample
  lines[0].score = sys.maxint # keep the first line
  for i in range(1, len(lines)):
    if lines[i].section:  # keep sections
      lines[i].score = sys.maxint
    elif lines[i].subsection:
      lines[i].score = sys.maxint/2
    elif lines[i].changed or lines[i].search_match:
      lines[i].score = sys.maxint/2
    else:
      if 0: # get rid of lines that are very different
        lines[i].score = abs(lines[i].indent-lines[i-1].indent) \
                         + abs(len(lines[i].raw)-len(lines[i-1].raw))
      if 1: # get rid of lines randomly
        lines[i].score = hash(lines[i].raw)
        if lines[i].score > sys.maxint/2:
          lines[i].score -= sys.maxint/2
                     
  scoresorted = sorted(lines, lambda x,y: cmp(x.score,y.score))
  erasures_ = int(math.ceil(n - maxlines_))
  #print 'erasures_',erasures_
  scoresorted[0:erasures_]=[]
    
  downsampled = True
  
  return sorted(scoresorted, lambda x,y:cmp(x.i,y.i)), scale, downsampled
      
def visible_lines_top_bottom(geditwin):
  view = geditwin.get_active_view()
  rect = view.get_visible_rect()
  topiter = view.get_line_at_y(rect.y)[0]
  botiter = view.get_line_at_y(rect.y+rect.height)[0]
  return topiter.get_line(), botiter.get_line()
      
def dark(r,g,b):
  "return whether the color is light or dark"
  if r+g+b < 1.5:
    return True
  else:
    return False
    
def darken(fraction,r,g,b):
  return r-fraction*r,g-fraction*g,b-fraction*b
  
def lighten(fraction,r,g,b):
  return r+(1-r)*fraction,g+(1-g)*fraction,b+(1-b)*fraction
  
def scrollbar(lines,topI,botI,w,h,bg,cr,scrollbarW=10):
  "top and bot a passed as line indices"
  # figure out location
  topY = None
  botY = None
  for line in lines:
    if not topY:
      if line.i >= topI:
        topY = line.y
    if not botY:
      if line.i >= botI:
        botY = line.y
  
  if topY is None:
    topY = 0
  if botY is None:
    botY = lines[-1].y

  if 0: # bg rectangle     
    cr.set_source_rgba(.1,.1,.1,.35)
    cr.rectangle(w-scrollbarW,0,scrollbarW,topY)
    cr.fill()
    cr.rectangle(w-scrollbarW,botY,scrollbarW,h-botY)
    cr.fill()
    
  if 0: # scheme 1
    cr.set_line_width(1)
    #cr.set_source_rgb(0,0,0)
    #cr.set_source_rgb(1,1,1)
    cr.set_source_rgb(0xd3/256.,0xd7/256.,0xcf/256.)
    if 0: # big down line
      cr.set_source_rgb(0xd3/256.,0xd7/256.,0xcf/256.)
      cr.move_to(w-scrollbarW/2.,0)
      cr.line_to(w-scrollbarW/2.,topY)
      cr.stroke()
      cr.move_to(w-scrollbarW/2.,botY)
      cr.line_to(w-scrollbarW/2.,h)
      cr.stroke()
    if 0:
      cr.rectangle(w-scrollbarW,topY,scrollbarW-1,botY-topY)
      cr.stroke()
    if 1: # bottom lines
      #cr.set_line_width(2)
      #cr.move_to(w-scrollbarW,topY)
      cr.move_to(0,topY)
      cr.line_to(w,topY)
      cr.stroke()
      cr.move_to(0,botY)
      cr.line_to(w,botY)
      cr.stroke()
    if 0: # rect
      cr.set_source_rgba(.5,.5,.5,.1)
      #cr.set_source_rgba(.1,.1,.1,.35)
      #cr.rectangle(w-scrollbarW,topY,scrollbarW,botY-topY)
      cr.rectangle(0,topY,w,botY-topY)
      cr.fill()

  if 0: # scheme 2
    cr.set_line_width(3)
    cr.set_source_rgb(0xd3/256.,0xd7/256.,0xcf/256.)
    if 1: # bottom lines
      cr.move_to(0,topY)
      cr.line_to(w,topY)
      cr.stroke()
      cr.move_to(0,botY)
      cr.line_to(w,botY)
      cr.stroke()
    if 1: # side lines
      cr.set_line_width(2)
      len = (botY-topY)/8
      margin = 1
      if 0: # left
        cr.move_to(margin,topY)
        cr.line_to(margin,topY+len)
        cr.stroke()
        cr.move_to(margin,botY-len)
        cr.line_to(margin,botY)
        cr.stroke()
      if 1: # right
        cr.move_to(w-margin,topY)
        cr.line_to(w-margin,topY+len)
        cr.stroke()
        cr.move_to(w-margin,botY-len)
        cr.line_to(w-margin,botY)
        cr.stroke()
    if 0: # center
      len = (botY-topY)/5
      cx = w/2
      cy = topY+(botY-topY)/2
      if 1: # vert
        for x in (cx,):#(cx-len/2,cx,cx+len/2):
          cr.move_to(x,cy-len/2)
          cr.line_to(x,cy+len/2)
          cr.stroke()
      if 0: # horiz
        cr.move_to(cx-len/2,cy)
        cr.line_to(cx+len/2,cy)
        cr.stroke()
    
  if 0: # view indicator  
    cr.set_source_rgba(.5,.5,.5,.5)
    #cr.set_source_rgba(.1,.1,.1,.35)
    cr.rectangle(w-scrollbarW,topY,scrollbarW,botY-topY)
    cr.fill()
    cr.rectangle(w-scrollbarW,topY,scrollbarW-1,botY-topY)
    cr.set_line_width(.5)
    cr.set_source_rgb(1,1,1)
    #cr.set_source_rgb(0,0,0)
    cr.stroke()
  
  if 0: # lines
    cr.set_source_rgb(1,1,1)
    cr.move_to(w,0)
    cr.line_to(w-scrollbarW,topY)
    cr.line_to(w-scrollbarW,botY)
    cr.line_to(w,h)
    cr.stroke()
    
  if 0: # scheme 3
  
    if 1: # black lines
      cr.set_line_width(2)
      cr.set_source_rgb(0,0,0)
      cr.move_to(0,topY)
      cr.line_to(w,topY)
      cr.stroke()
      cr.move_to(0,botY)
      cr.line_to(w,botY)
      cr.stroke() 
      
    if 1: # white lines
      cr.set_line_width(2)
      cr.set_dash([1,2])
      cr.set_source_rgb(1,1,1)
      cr.move_to(0,topY)
      cr.line_to(w,topY)
      cr.stroke()
      cr.move_to(0,botY)
      cr.line_to(w,botY)
      cr.stroke()   
  
  if 0: # scheme 4
    pat = cairo.LinearGradient(0,topY-10,0,topY)
    pat.add_color_stop_rgba(0, 1, 1, 1,1)
    pat.add_color_stop_rgba(1, .2,.2,.2,1)
    pat.add_color_stop_rgba(2, 0, 0, 0,1)
    cr.rectangle(0,topY-10,w,10)
    cr.set_source(pat)
    cr.fill()
    
  if 0: # triangle right
    # triangle
    size=12
    midY = topY+(botY-topY)/2
    cr.set_line_width(2)
    cr.set_source_rgb(1,1,1)
    cr.move_to(w-size-1,midY)
    cr.line_to(w-1,midY-size/2)
    #cr.stroke_preserve()
    cr.line_to(w-1,midY+size/2)
    #cr.stroke_preserve()
    cr.line_to(w-size-1,midY)
    cr.fill()
    # line
    cr.move_to(w-2,topY+2)
    cr.line_to(w-2,botY-2)
    cr.stroke()
    
  if dark(*bg):
    color = (1,1,1)
  else:
    color = (0,0,0)
    
  if 0: # triangle left
    # triangle
    size=12
    midY = topY+(botY-topY)/2
    cr.set_line_width(2)
    cr.set_source_rgb(*color)
    cr.move_to(size+1,midY)
    cr.line_to(1,midY-size/2)
    #cr.stroke_preserve()
    cr.line_to(1,midY+size/2)
    #cr.stroke_preserve()
    cr.line_to(size+1,midY)
    cr.fill()
    # line
    #cr.move_to(2,topY+2)
    #cr.line_to(2,botY-2)
    #cr.stroke()
    
  if 1: # dashed lines
    cr.set_line_width(2)
    cr.set_source_rgb(*color)
    cr.set_dash([8,8])
    #cr.rectangle(2,topY,w-4,botY-topY)
    cr.move_to(4,topY); cr.line_to(w,topY)
    cr.stroke()
    cr.move_to(4,botY); cr.line_to(w,botY)
    cr.stroke()
        
def queue_refresh(textmapview):
  try:
    win = textmapview.darea.get_window()
  except AttributeError:
    win = textmapview.darea.window
  if win:
    w,h = win.get_size()
    textmapview.darea.queue_draw_area(0,0,w,h)
    
def str2rgb(s):
  assert s.startswith('#') and len(s)==7,('not a color string',s)
  r = int(s[1:3],16)/256.
  g = int(s[3:5],16)/256.
  b = int(s[5:7],16)/256.
  return r,g,b
  
def init_original_lines_info(doc,lines):
  rn = []
  # now we insert marks at the end of every line
  iter = doc.get_start_iter()
  n = 0
  while 1:
    if n>=len(lines):
      break
    more_left = iter.forward_line()
    rec = struct()
    lines[n].mark = doc.create_mark(None,iter,False) 
    n+=1
    if not more_left:
      break
  assert n>=len(lines)-1,(n,len(lines),'something off with our iterator logic')
  if n==len(lines)-1:
    lines[-1].mark=doc.create_mark(None,doc.get_end_iter(),False)
  return lines
  
def mark_changed_lines(doc,original,current):
  'unfortunate choice of name, has nothing to do with GtkTextBuffer marks'

  # presume all current lines are changed
  for line in current:
    line.changed = True
  
  # mark any original lines we find as unchanged
  start = doc.get_start_iter()
  c=0
  for oline in original:
    end = doc.get_iter_at_mark(oline.mark)
    slice = doc.get_slice(start,end)
    # see if the first line between the marks is the original line
    if slice.split('\n',1)[0] == oline.raw:
      current[c].changed = False
    # forward through all the slice lines
    c += slice.count('\n')

    start = end

  return current
      
def lines_mark_search_matches(lines,docrec):
  for line in lines:
    if docrec.search_text and docrec.search_text in line.raw:
      line.search_match = True
    else:
      line.search_match = False
  return lines
  
Split_Off_Indent_Pattern = re.compile('(\s*)(.*)$')
      
class TextmapView(gtk.VBox):
  def __init__(me, geditwin):
    gtk.VBox.__init__(me)
    
    me.geditwin = geditwin
    
    darea = gtk.DrawingArea()
    darea.connect("expose-event", me.expose)
    
    darea.add_events(gtk.gdk.BUTTON_PRESS_MASK)
    darea.connect("button-press-event", me.button_press)
    darea.connect("scroll-event", me.on_darea_scroll_event)
    darea.add_events(gtk.gdk.ENTER_NOTIFY_MASK)
    darea.connect("enter-notify-event", me.on_darea_enter_notify_event)
    darea.add_events(gtk.gdk.LEAVE_NOTIFY_MASK)
    darea.connect("leave-notify-event", me.on_darea_leave_notify_event)
    darea.add_events(gtk.gdk.POINTER_MOTION_MASK)
    darea.connect("motion-notify-event", me.on_darea_motion_notify_event)
    
    
    me.pack_start(darea, True, True)
    
    me.darea = darea
    #probj(me.darea)

    me.connected = {}
    me.draw_scrollbar_only = False
    me.draw_sections = False
    me.topL = None
    me.surface_textmap = None
    
    me.line_count = 0
    
    me.doc_attached_data = {}
    
    me.show_all()
    
    # need this bc of a cairo bug, keep references to all our font faces
    me.font_face_keepalive = None
    
     #'''
     #   gtk.gdk.SCROLL_UP, 
     #  gtk.gdk.SCROLL_DOWN, 
     #  gtk.gdk.SCROLL_LEFT, 
     #  gtk.gdk.SCROLL_RIGHT
   #
     #Example:
   #
     #  def on_button_scroll_event(button, event):
     #    if event.direction == gtk.gdk.SCROLL_UP:
     #       print "You scrolled up"
     #       
     #event = gtk.gdk.Event(gtk.gdk.EXPOSE)
     #
     #      def motion_notify(ruler, event):
     #          return ruler.emit("motion_notify_event", event)
     #      self.area.connect_object("motion_notify_event", motion_notify,
     #                               self.hruler)
     #      self.area.connect_object("motion_notify_event", motion_notify,
     #                               self.vruler)
     #'''
  
  def on_darea_motion_notify_event(me, widget, event):
    #probj(event)
    #print event.type
    if event.state & gtk.gdk.BUTTON1_MASK:
      me.scroll_from_y_mouse_pos(event.y)
      
  def on_darea_enter_notify_event(me, widget, event):
    if event.mode.value_name == 'GDK_CROSSING_GTK_UNGRAB':
      return
    #print 'in here enter'
    me.draw_sections = True
    queue_refresh(me)
    
  def on_darea_leave_notify_event(me, widget, event):
    #print 'in here leaving'
    me.draw_sections = False
    queue_refresh(me)
    
  def on_darea_scroll_event(me, widget, event):
    pass
    #print 'XXX on_darea_scroll_event'
    
    # this scheme does not work
    # somehow pass this on, scroll the document/view
    #print type(widget),widget,type(event),event
    #probj(event)
    #view = me.geditwin.get_active_view()
    #if not view:
    #  return
    #return view.emit('scroll-event',event)

    # the following crashes
    #pagesize = 12
    #topI,botI = visible_lines_top_bottom(me.geditwin)
    #if event.direction == gtk.gdk.SCROLL_UP:
    #  newI = topI - pagesize
    #elif event.direction == gtk.gdk.SCROLL_DOWN:
    #  newI = botI + pagesize
    #else:
    #  return
    #  
    #view = me.geditwin.get_active_view()
    #doc  = me.geditwin.get_active_tab().get_document()
    #view.scroll_to_iter(doc.get_iter_at_line_index(newI,0),0,False,0,0)
    #
    #queue_refresh(me)
    
  def on_doc_cursor_moved(me, doc):
    #new_line_count = doc.get_line_count()
    #print 'new_line_count',new_line_count
    topL = visible_lines_top_bottom(me.geditwin)[0]
    if topL <> me.topL:
      queue_refresh(me)
      me.draw_scrollbar_only = True
    
  def on_insert_text(me, doc, piter, text, len):
    pass
    #if len < 20 and '\n' in text:
    #  print 'piter',piter,'text',repr(text),'len',len
    
  def scroll_from_y_mouse_pos(me,y):
    for line in me.lines:
      if line.y > y:
        break
    #print line.i, repr(line.raw)
    view = me.geditwin.get_active_view()
    doc = me.geditwin.get_active_tab().get_document()
    
    #doc.place_cursor(doc.get_iter_at_line_index(line.i,0))
    #view.scroll_to_cursor()
    #print view
    
    view.scroll_to_iter(doc.get_iter_at_line_index(line.i,0),0,True,0,.5)
    
    queue_refresh(me)
        
  def button_press(me, widget, event):
    me.scroll_from_y_mouse_pos(event.y)
    
  def on_scroll_finished(me):
    #print 'in here',me.last_scroll_time,time.time()-me.last_scroll_time
    if time.time()-me.last_scroll_time > .47:
      if me.draw_sections:
        me.draw_sections = False
        me.draw_scrollbar_only = False
        queue_refresh(me)
    return False
    
  def on_scroll_event(me,view,event):
    me.last_scroll_time = time.time()
    if me.draw_sections: # we are in the middle of scrolling
      me.draw_scrollbar_only = True
    else:
      me.draw_sections = True # for the first scroll, turn on section names
    gobject.timeout_add(500,me.on_scroll_finished) # this will fade out sections
    queue_refresh(me)
    
  def on_search_highlight_updated(me,doc,t,u):
    #print 'on_search_highlight_updated:',repr(doc.get_search_text())
    docrec = me.doc_attached_data[id(doc)]
    s = doc.get_search_text()[0]
    if s <> docrec.search_text:
      docrec.search_text = s
      queue_refresh(me)    
    
  def test_event(me, ob, event):
    print 'here',ob
    
  def save_refs_to_all_font_faces(me, cr, *scales):
    me.font_face_keepalive = []
    for each in scales:
      cr.set_font_size(each)
      me.font_face_keepalive.append(cr.get_font_face())
    
  def expose(me, widget, event):
    doc = me.geditwin.get_active_tab().get_document()
    if not doc:   # nothing open yet
      return
    
    if id(doc) not in me.connected:
      me.connected[id(doc)] = True
      doc.connect("cursor-moved", me.on_doc_cursor_moved)
      doc.connect("insert-text", me.on_insert_text)
      doc.connect("search-highlight-updated", me.on_search_highlight_updated)
      
    view = me.geditwin.get_active_view()
    if not view:
      return
    
    if TIMER: TIMER.push('expose')
    
    if id(view) not in me.connected:
      me.connected[id(view)] = True
      view.connect("scroll-event", me.on_scroll_event)
      #view.connect("start-interactive-goto-line", me.test_event)
      #view.connect("start-interactive-search", me.test_event)
      #view.connect("reset-searched-text", me.test_event)
      
    bg = (0,0,0)
    fg = (1,1,1)
    try:
      style = doc.get_style_scheme().get_style('text')
      if style is None: # there is a style scheme, but it does not specify default
        bg = (1,1,1)
        fg = (0,0,0)
      else:
        fg,bg = map(str2rgb, style.get_properties('foreground','background'))  
    except Exception,e:
      pass  # probably an older version of gedit, no style schemes yet
    
    changeCLR = (1,0,1)
    
    #search_match_style = None
    #try:
    #  search_match_style = doc.get_style_scheme().get_style('search-match')
    #except:
    #  pass
    #if search_match_style is None:
    #  searchFG = fg
    #  searchBG = (0,1,0)
    #else:
    #  searchFG,searchBG = map(str2rgb, style.get_properties('foreground','background'))
    searchFG = fg
    searchBG = (0,1,0)
      
    
    #print doc
       
    try:
      win = widget.get_window()
    except AttributeError:
      win = widget.window
    w,h = map(float,win.get_size())
    cr = widget.window.cairo_create()
    
    #probj(cr,'rgb')
    
    # Are we drawing everything, or just the scrollbar?
    fontfamily = 'sans-serif'
    cr.select_font_face('monospace', cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            
    if me.surface_textmap is None or not me.draw_scrollbar_only:
    
      if TIMER: TIMER.push('document_lines')

      lines = document_lines(doc)
      
      if TIMER: TIMER.pop('document_lines')
      
      if TIMER: TIMER.push('draw textmap')
      
      if id(doc) not in me.doc_attached_data:
        docrec = struct()
        me.doc_attached_data[id(doc)] = docrec
        docrec.original_lines_info = None # we skip the first one, its empty
        docrec.search_text = None
        for l in lines:
          l.changed = False
      else:
        docrec = me.doc_attached_data[id(doc)]
        if docrec.original_lines_info == None:
          docrec.original_lines_info = init_original_lines_info(doc,lines)
        lines = mark_changed_lines(doc, docrec.original_lines_info, lines)
        
      if BUG_MASK & BUG_DOC_GET_SEARCH_TEXT:
        pass
      else:
        docrec.search_text = doc.get_search_text()[0]
        lines = lines_mark_search_matches(lines,docrec)
     
      cr.push_group()
      
      # bg
      if 1:
        #cr.set_source_rgb(46/256.,52/256.,54/256.)
        cr.set_source_rgb(*bg)
        cr.move_to(0,0)
        cr.rectangle(0,0,w,h)
        cr.fill()
        cr.move_to(0,0)
      
      if not lines:
        return
        
      # translate everthing in
      margin = 3
      cr.translate(margin,0)
      w -= margin # an d here
            
      if TIMER: TIMER.push('downsample')
      max_scale = 3
      lines, scale, downsampled = downsample_lines(lines, h, 2, max_scale)
      if TIMER: TIMER.pop('downsample')
      
      smooshed = False
      if downsampled or scale < max_scale:
        smooshed = True
      
      if TIMER: TIMER.push('lines_add_section_len')
      lines = lines_add_section_len(lines)
      if TIMER: TIMER.pop('lines_add_section_len')
      
      if TIMER: TIMER.push('lines_mark_changed_sections')
      lines = lines_mark_changed_sections(lines)
      if TIMER: TIMER.pop('lines_mark_changed_sections')

      n = len(lines)
      lineH = h/n
      
      #print 'doc',doc.get_uri(), lines[0].raw
      
      if BUG_MASK & BUG_CAIRO_MAC_FONT_REF and me.font_face_keepalive is None:
        me.save_refs_to_all_font_faces(cr,scale,scale+3,10,12)
      
      cr.set_font_size(scale)
      whitespaceW = text_extents('.',cr)[0]
      #print pr_text_extents(' ',cr)
      #print pr_text_extents('.',cr)
      #print pr_text_extents(' .',cr)
      
      # ------------------------ display text silhouette -----------------------
      if TIMER: TIMER.push('draw silhouette')
      
      if dark(*fg):
        faded_fg = lighten(.5,*fg)
      else:
        faded_fg = darken(.5,*fg)
          
      rectH = h/float(len(lines))
      sofarH= 0
      sections = []
      for i, line in enumerate(lines):
      
        line.y = sofarH
        lastH = sofarH
        cr.set_font_size(scale)
        
        if line.raw.strip(): # there is some text here
            
          tw,th = text_extents(line.raw,cr)
        
          if line.search_match:
            cr.set_source_rgb(*searchBG)
          elif line.changed:
            cr.set_source_rgb(*changeCLR)
          elif me.draw_sections:
            cr.set_source_rgb(*faded_fg)
          else:
            cr.set_source_rgb(*fg)
            
          if line.section or line.subsection:
            #cr.select_font_face(fontfamily, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_BOLD)
            cr.set_font_size(scale+3)
            if line.justextSTR:
              x,y = cr.get_current_point()
              cr.move_to(whitespaceW*line.indent,y)
              cr.show_text(line.justextSTR)
            else:
              cr.show_text(line.raw)
          else:
            #cr.select_font_face(fontfamily, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
            cr.set_font_size(scale)
            cr.show_text(line.raw)
          
          if smooshed:
            sofarH += lineH
          else:
            sofarH += th
        else: # empty line
          if smooshed:
            sofarH += lineH
          else:
            sofarH += scale-1
          
        if line.section:
          sections.append((line, lastH))
          
        cr.move_to(0, sofarH)
        
      if TIMER: TIMER.pop('draw silhouette')
          
      # ------------------- display sections and subsections labels  ------------------

      if me.draw_sections:
        # Subsections
        
        if TIMER: TIMER.push('draw subsections')
        
        if dark(*bg):
          bg_rect_C = lighten(.1,*bg)
        else:
          bg_rect_C = darken(.1,*bg)
          
        if 0: # - blot out the background -
          cr.set_source_rgba(bg_rect_C[0],bg_rect_C[1],bg_rect_C[2],.5)
          cr.rectangle(0,0,w,h)
          cr.fill()
        
        cr.new_path()
        cr.set_line_width(1.5)
        subsW = 10
        subsmargin = 10
        cr.set_font_size(10)
        for line in lines:
          if line.subsection:
            if 0:
              cr.move_to(subsmargin,line.y)
              cr.line_to(subsmargin+subsW,line.y)
            #if line.subsectionchanged:
            #  cr.set_source_rgb(*changeCLR)
            #else:
            #  cr.set_source_rgb(*fg)
            if 0:
              cr.set_source_rgb(*fg)
              cr.arc(subsmargin,line.y+3,2,0,6.28)
              cr.stroke()
            if 1:
              #cr.move_to(20,line.y)
              cr.set_source_rgb(*fg)
              #cr.show_text(line.subsection)
              cr.move_to(whitespaceW*line.indent,line.y)
              #cr.move_to(10,line.y)
              #fit_text(line.subsection, 10000, 10000, fg, bg, cr)
              show_section_label(line.subsection, fg, bg_rect_C, cr)
              
        if TIMER: TIMER.pop('draw subsections')
        
        # Sections
        
        if TIMER: TIMER.push('draw sections')
        cr.set_font_size(12)
        for line, lastH in sections:
        
          if 0: # section lines
            cr.move_to(0, lastH)
            cr.set_line_width(1)
            cr.set_source_rgb(*fg)
            cr.line_to(w,lastH)
            cr.stroke()
          
          if 1: # section heading
            cr.move_to(0,lastH)
            #if line.sectionchanged:
            #  cr.set_source_rgb(*changeCLR)
            #else:
            #  cr.set_source_rgb(*fg)
            cr.set_source_rgb(*fg)         
            #dispnfo = fit_text(line.section,4*w/5,line.section_len*rectH,fg,bg,cr)
            show_section_label(line.section, fg, bg_rect_C, cr)
            
          if 0 and dispnfo: # section hatches
            cr.set_line_width(1)
            r=dispnfo[0] # first line
            cr.move_to(r.x+r.tw+2,r.y-r.th/2+2)
            cr.line_to(w,r.y-r.th/2+2)
            cr.stroke()
            
        if TIMER: TIMER.pop('draw sections')
          
      # ------------------ translate back for the scroll bar -------------------
      
      cr.translate(-margin,0)
      w += margin

      # -------------------------- mark lines markers --------------------------
            
      if TIMER: TIMER.push('draw line markers')
      for line in lines:
        if line.search_match:
          clr = searchBG
        elif line.changed:
          clr = changeCLR
        else:
          continue # nothing interesting has happened with this line
        cr.set_source_rgb(*clr)      
        cr.rectangle(w-3,line.y-2,2,5)
        cr.fill()
      if TIMER: TIMER.pop('draw line markers')
        
      if TIMER: TIMER.pop('draw textmap')
      
      # save
      me.surface_textmap = cr.pop_group() # everything but the scrollbar
      me.lines = lines

    if TIMER: TIMER.push('surface_textmap')
    cr.set_source(me.surface_textmap)
    cr.rectangle(0,0,w,h)
    cr.fill()
    if TIMER: TIMER.pop('surface_textmap')
        
    # ------------------------------- scrollbar -------------------------------

    if TIMER: TIMER.push('scrollbar')
    
    topL,botL = visible_lines_top_bottom(me.geditwin)
    
    if topL==0 and botL==doc.get_end_iter().get_line():
      pass # everything is visible, don't draw scrollbar
    else:
      scrollbar(me.lines,topL,botL,w,h,bg,cr)
    
    if TIMER: TIMER.pop('scrollbar')
    
    me.topL = topL
    me.draw_scrollbar_only = False
    
    if TIMER: TIMER.pop('expose')
    if TIMER: TIMER.print_()
      
        
class TextmapWindowHelper:
  def __init__(me, plugin, window):
    me.window = window
    me.plugin = plugin

    panel = me.window.get_side_panel()
    image = gtk.Image()
    image.set_from_stock(gtk.STOCK_DND_MULTIPLE, gtk.ICON_SIZE_BUTTON)
    me.textmapview = TextmapView(me.window)
    me.ui_id = panel.add_item(me.textmapview, "TextMap", image)
    
    me.panel = panel

  def deactivate(me):
    me.window = None
    me.plugin = None
    me.textmapview = None

  def update_ui(me):
    queue_refresh(me.textmapview)
    
class TextmapPlugin(gedit.Plugin):
  def __init__(me):
    gedit.Plugin.__init__(me)
    me._instances = {}

  def activate(me, window):
    me._instances[window] = TextmapWindowHelper(me, window)

  def deactivate(me, window):
    if window in me._instances:
      me._instances[window].deactivate()

  def update_ui(me, window):
    # Called whenever the window has been updated (active tab
    # changed, etc.)
    #print 'plugin.update_ui'
    if window in me._instances:
      me._instances[window].update_ui()
      #window.do_expose_event()

########NEW FILE########
__FILENAME__ = constants
# -*- coding: utf-8 -*-
#
#  constants.py - Constants
#
#  Copyright (C) 2010 - Jesse van den Kieboom
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

DOCUMENT_HELPER_KEY = 'GeditTextSizePluginDocumentHelperKey'

# ex:ts=4:et:

########NEW FILE########
__FILENAME__ = documenthelper
# -*- coding: utf-8 -*-
#
#  documenthelper.py - Document helper
#
#  Copyright (C) 2010 - Jesse van den Kieboom
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

from signals import Signals
import constants
import pango
import gtk

class DocumentHelper(Signals):
    def __init__(self, view):
        Signals.__init__(self)

        self._view = view

        self.connect_signal(self._view, 'scroll-event', self.on_scroll_event)
        self.connect_signal(self._view, 'button-press-event', self.on_button_press_event)

        self._view.set_data(constants.DOCUMENT_HELPER_KEY, self)

        self._default_font = None
        self._last_font = None
        self._font_tags = {}

    def stop(self):
        if self._default_font:
            self._view.modify_font(self._default_font)

        self.remove_font_tags()
        self.disconnect_signals(self._view)

    def remove_font_tags(self):
        buf = self._view.get_buffer()
        table = buf.get_tag_table()

        # Remove all the font tags
        for size in self._font_tags:
            tag = self._font_tags[size]
            table.remove(tag)

        self._font_tags = {}

    def update_default_font(self):
        description = self._view.get_style().font_desc

        if not self._last_font or description.hash() != self._last_font.hash():
            self._default_font = description.copy()

    def get_font_tags(self, start, end):
        tags = set()

        # Check all the know font tags
        for size in self._font_tags:
            tag = self._font_tags[size]

            if start.has_tag(tag):
                tags.add(tag)
            else:
                cp = start.copy()

                if cp.forward_to_tag_toggle(tag) and cp.compare(end) < 0:
                    tags.add(tag)

        return list(tags)

    def set_font_size(self, amount):
        self.update_default_font()

        description = self._view.get_style().font_desc

        buf = self._view.get_buffer()
        bounds = buf.get_selection_bounds()
        size = description.get_size() / pango.SCALE

        if not bounds:
            description.set_size(max(1, (size + amount)) * pango.SCALE)

            self._view.modify_font(description)
            self._last_font = description
        else:
            start = bounds[0]
            end = bounds[1]

            tags = self.get_font_tags(start, end)

            if not tags:
                # Simply use the overall font size as the base
                newsize = size + amount
            elif len(tags) == 1:
                newsize = tags[0].props.font_desc.get_size() / pango.SCALE + amount
            else:
                newsize = 0

                for tag in tags:
                    newsize += tag.props.font_desc.get_size() / pango.SCALE

                newsize = round(newsize / len(tags))

            newsize = int(max(1, newsize))

            if not newsize in self._font_tags:
                newtag = buf.create_tag(None)

                desc = description.copy()
                desc.set_size(newsize * pango.SCALE)

                newtag.props.font_desc = desc
                self._font_tags[newsize] = newtag
            else:
                newtag = self._font_tags[newsize]

            # Remove all the previous mix of tags
            for tag in tags:
                buf.remove_tag(tag, start, end)

            buf.apply_tag(newtag, start, end)

    def increase_font_size(self):
        self.set_font_size(1)

    def decrease_font_size(self):
        self.set_font_size(-1)

    def reset_font_size(self):
        self.update_default_font()

        buf = self._view.get_buffer()
        bounds = buf.get_selection_bounds()

        if not bounds:
            self.remove_font_tags()

            self._view.modify_font(self._default_font)
            self._last_font = self._default_font
        else:
            tags = self.get_font_tags(bounds[0], bounds[1])

            for tag in tags:
                buf.remove_tag(tag, bounds[0], bounds[1])

    def on_scroll_event(self, view, event):
        state = event.state & gtk.accelerator_get_default_mod_mask()

        if state != gtk.gdk.CONTROL_MASK:
            return False

        if event.direction == gtk.gdk.SCROLL_UP:
            self.increase_font_size()
            return True
        elif event.direction == gtk.gdk.SCROLL_DOWN:
            self.decrease_font_size()
            return True

        return False

    def on_button_press_event(self, view, event):
        state = event.state & gtk.accelerator_get_default_mod_mask()

        if state == gtk.gdk.CONTROL_MASK and event.button == 2:
            self.reset_font_size()
            return True
        else:
            return False

# ex:ts=4:et:

########NEW FILE########
__FILENAME__ = signals
# -*- coding: utf-8 -*-
#
#  signals.py - Multi Edit
#
#  Copyright (C) 2009 - Jesse van den Kieboom
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

class Signals:
    def __init__(self):
        self._signals = {}

    def _connect(self, obj, name, handler, connector):
        ret = self._signals.setdefault(obj, {})

        hid = connector(name, handler)
        ret.setdefault(name, []).append(hid)

        return hid

    def connect_signal(self, obj, name, handler):
        return self._connect(obj, name, handler, obj.connect)

    def connect_signal_after(self, obj, name, handler):
        return self._connect(obj, name, handler, obj.connect_after)

    def disconnect_signals(self, obj):
        if not obj in self._signals:
            return False

        for name in self._signals[obj]:
            for hid in self._signals[obj][name]:
                obj.disconnect(hid)

        del self._signals[obj]
        return True

    def block_signal(self, obj, name):
        if not obj in self._signals:
            return False

        if not name in self._signals[obj]:
            return False

        for hid in self._signals[obj][name]:
            obj.handler_block(hid)

        return True

    def unblock_signal(self, obj, name):
        if not obj in self._signals:
            return False

        if not name in self._signals[obj]:
            return False

        for hid in self._signals[obj][name]:
            obj.handler_unblock(hid)

        return True

    def disconnect_signal(self, obj, name):
        if not obj in self._signals:
            return False

        if not name in self._signals[obj]:
            return False

        for hid in self._signals[obj][name]:
            obj.disconnect(hid)

        del self._signals[obj][name]

        if len(self._signals[obj]) == 0:
            del self._signals[obj]

        return True

# ex:ts=4:et:

########NEW FILE########
__FILENAME__ = windowhelper
# -*- coding: utf-8 -*-
#
#  textsize.py - Change text size plugin
#
#  Copyright (C) 2008 - Konstantin Mikhaylov <jtraub.devel@gmail.com>
#  Copyright (C) 2009 - Wouter Bolsterlee <wbolster@gnome.org>
#  Copyright (C) 2010 - Ignacio Casal Quinteiro <icq@gnome.org>
#  Copyright (C) 2010 - Jesse van den Kieboom <jessevdk@gnome.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330,
#  Boston, MA 02111-1307, USA.

import gtk
from gettext import gettext as _
import constants
from documenthelper import DocumentHelper
from signals import Signals

# UI manager snippet to add menu items to the View menu
ui_str = """
<ui>
  <menubar name="MenuBar">
    <menu name="ViewMenu" action="View">
      <placeholder name="ViewOps_2">
        <menuitem name="IncreaseFontSize" action="IncreaseFontSizeAction"/>
        <menuitem name="DecreaseFontSize" action="DecreaseFontSizeAction"/>
        <menuitem name="ResetFontSize" action="ResetFontSizeAction"/>
      </placeholder>
    </menu>
  </menubar>
</ui>
"""

class WindowHelper(Signals):
    def __init__(self, plugin, window):
        Signals.__init__(self)

        self._window = window
        self._plugin = plugin
        self._views  = {}

        # Insert menu items
        self._insert_menu()

        # Insert document helpers
        for view in window.get_views():
            self.add_document_helper(view)

        self.connect_signal(window, 'tab-added', self.on_tab_added)
        self.connect_signal(window, 'tab-removed', self.on_tab_removed)

        self._accel_group = gtk.AccelGroup()
        self._window.add_accel_group(self._accel_group)

        self._proxy_callback_map = {
            'IncreaseFontSizeAction': self.on_increase_font_accel,
            'DecreaseFontSizeAction': self.on_decrease_font_accel,
            'ResetFontSizeAction': self.on_reset_font_accel
        }

        self._proxy_mapping = {}
        self._init_proxy_accels()
        self._accel_map_handler_id = gtk.accel_map_get().connect('changed', self.on_accel_map_changed)

    def _install_proxy(self, action):
        if not isinstance(action, gtk.Action):
            action = self._action_group.get_action(str(action))

        if not action:
            return

        entry = gtk.accel_map_lookup_entry(action.get_accel_path())

        if not entry:
            return

        mapping = {
            gtk.keysyms.plus: gtk.keysyms.KP_Add,
            gtk.keysyms.KP_Add: gtk.keysyms.plus,
            gtk.keysyms.minus: gtk.keysyms.KP_Subtract,
            gtk.keysyms.KP_Subtract: gtk.keysyms.minus,
            gtk.keysyms._0: gtk.keysyms.KP_0,
            gtk.keysyms.KP_0: gtk.keysyms._0
        }

        if entry[0] in mapping:
            key = mapping[entry[0]]
            mod = entry[1]

            callback = self._proxy_callback_map[action.get_name()]

            self._accel_group.connect_group(key, mod, gtk.ACCEL_LOCKED, callback)
            self._proxy_mapping[action] = (key, mod)

    def _init_proxy_accels(self):
        self._install_proxy('IncreaseFontSizeAction')
        self._install_proxy('DecreaseFontSizeAction')
        self._install_proxy('ResetFontSizeAction')

    def deactivate(self):
        # Remove any installed menu items
        self._remove_menu()

        for view in self._window.get_views():
            self.remove_document_helper(view)

        self._window.remove_accel_group(self._accel_group)

        gtk.accel_map_get().disconnect(self._accel_map_handler_id)

        self._window = None
        self._plugin = None
        self._accel_group = None
        self._action_group = None

    def _insert_menu(self):
        # Get the GtkUIManager
        manager = self._window.get_ui_manager()

        # Create a new action group
        self._action_group = gtk.ActionGroup("TextSizePluginActions")
        self._action_group.add_actions([("IncreaseFontSizeAction", None, _("_Increase font size"),
                                         "<Ctrl>plus", None,
                                         self.on_increase_font_size_activate),
                                         ("DecreaseFontSizeAction", None, _("_Decrease font size"),
                                         "<Ctrl>minus", None,
                                         self.on_decrease_font_size_activate),
                                         ("ResetFontSizeAction", None, _("_Reset font size"),
                                         "<Ctrl>0", None,
                                         self.on_reset_font_size_activate)])

        # Insert the action group
        manager.insert_action_group(self._action_group, -1)

        # Merge the UI
        self._ui_id = manager.add_ui_from_string(ui_str)

    def _remove_menu(self):
        # Get the GtkUIManager
        manager = self._window.get_ui_manager()

        # Remove the ui
        manager.remove_ui(self._ui_id)

        # Remove the action group
        manager.remove_action_group(self._action_group)

        # Make sure the manager updates
        manager.ensure_update()

    def update_ui(self):
        self._action_group.set_sensitive(self._window.get_active_document() != None)

    def get_helper(self, view):
        return view.get_data(constants.DOCUMENT_HELPER_KEY)

    def add_document_helper(self, view):
        if self.get_helper(view) != None:
            return

        DocumentHelper(view)

    def remove_document_helper(self, view):
        helper = self.get_helper(view)

        if helper != None:
            helper.stop()

    def call_helper(self, cb):
        view = self._window.get_active_view()

        if view:
            cb(self.get_helper(view))

    # Menu activate handlers
    def on_increase_font_size_activate(self, action):
        self.call_helper(lambda helper: helper.increase_font_size())

    def on_decrease_font_size_activate(self, action):
        self.call_helper(lambda helper: helper.decrease_font_size())

    def on_reset_font_size_activate(self, action):
        self.call_helper(lambda helper: helper.reset_font_size())

    def on_increase_font_accel(self, group, accel, key, mod):
        self.call_helper(lambda helper: helper.increase_font_size())

    def on_decrease_font_accel(self, group, accel, key, mod):
        self.call_helper(lambda helper: helper.decrease_font_size())

    def on_reset_font_accel(self, group, accel, key, mod):
        self.call_helper(lambda helper: helper.reset_font_size())

    def on_tab_added(self, window, tab):
        self.add_document_helper(tab.get_view())

    def on_tab_removed(self, window, tab):
        self.remove_document_helper(tab.get_view())

    def _remap_proxy(self, action):
        # Remove previous proxy

        if action in self._proxy_mapping:
            item = self._proxy_mapping[action]
            self._accel_group.disconnect_key(item[0], item[1])

        self._install_proxy(action)

    def on_accel_map_changed(self, accelmap, path, key, mod):
        for action in self._action_group.list_actions():
            if action.get_accel_path() == path:
                self._remap_proxy(action)
                return

# ex:ts=4:et:

########NEW FILE########
__FILENAME__ = tm_autocomplete
# -*- coding: utf-8 -*-
#
# Gedit Plugin for TextMate style autocompletion. Tap Esc to cycle through 
# completions.
#
# Copyright  2010, Kevin McGuinness <kevin.mcguinness@gmail.com>
#
# Thanks to Dan Gindikin <dgindikin@gmail.com> for the proximity based search 
# code, and most recent match promotion
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
# 
#

__version__ = '1.0.4'
__author__ = 'Kevin McGuinness'

import gedit
import gtk
import re
import gconf

# The default trigger: a (keyval, mod) pair
DEFAULT_TRIGGER = (gtk.keysyms.Escape, 0)

def uniq_order_preserved(v):
  z, s = [], set()
  for x in v:
    if x not in s:
      s.add(x)
      z.append(x)
  return z

def zip_no_truncation(v,w):
  z = []
  for i in range(max(len(v),len(w))):
    if i < len(v):
      z.append(v[i])
    if i < len(w):
      z.append(w[i])
  return z

class AutoCompleter(object):
  """Class that actually does the autocompletion"""

  IgnoreUnderscore = True
  ValidScopes = ('document', 'window', 'application')
  ValidOrders = ('alphabetical', 'proximity')
  LastAcceptedMatch = None

  __slots__ = (
    'doc',       # The document autocomplete was initiated on
    'word',      # Word being completed
    'matches',   # List of potential autocompletions
    'index',     # Index of the next autocompletion to suggest
    'iter_s',    # GtkTextIterator pointing to the start of word being completed
    'iter_i',    # GtkTextIterator pointing to insertion point
    'iter_e',    # GtkTextIterator pointing to end of last insertion
    'scope',     # Search scope (document|application|window)
    'order',     # Result list ordering (proximity|alphabetical)
    'promote',   # Promote last accepted match
  )

  def __init__(self, doc, scope='document', order='alphabetical', 
    promote=False):
    """Create an autocompleter for the document. Indexes the words in the 
       current scope and builds a list of matches for the current cursor 
       position. Calling insert_next_completion will cycle through the matches,
       replacing the last match inserted (if any).

       If order is 'alphabetical' then the autocompletion list is ordered 
       alphabetically. If order is 'proximity' then the autocompletion list
       is ordered based on distance from the cursor in the current document,
       with the other open documents being ordered alphabetcially.
    """
    self.scope = scope
    self.order = order
    self.promote = promote
    self.reindex(doc)

  def _get_iter_for_beginning_of_word_at(self, iter1):
    """Returns a GtkTextIter pointing to the start of the current word"""
    if not self.IgnoreUnderscore:
      # Just use pango's word start facility
      result = iter1.copy()
      result.backward_word_start()
    else:
      # Including underscores in the words
      i = iter1.copy()
      while not i.starts_sentence() and i.backward_char():
        ch = i.get_char()
        if ch.isalpha() or ch == '_':
          continue
        else:
          i.forward_char()
          break
      result = i 
    return result

  def _can_autocomplete_at(self, iter1):
    """Returns true if autocompletion can be done at the given iterator"""
    if iter1.ends_word() or iter1.inside_word():
      return True
    if self.IgnoreUnderscore:
      i = iter1.copy()
      if not i.starts_sentence() and i.backward_char() and i.get_char() == '_':
        return True
    return False

  def _get_current_doc_words_sorted_by_proximity(self, regex):
    """Returns the words in the current document sorted by distance from 
       cursor.
    """
    fwd_text = self.doc.get_text(self.iter_i, self.doc.get_end_iter())
    bck_text = self.doc.get_text(self.doc.get_start_iter(), self.iter_s)
    fwd_words = regex.findall(fwd_text)
    bck_words = regex.findall(bck_text)
    bck_words.reverse()
    all_words = zip_no_truncation(bck_words, fwd_words)
    return uniq_order_preserved(all_words)

  def _get_current_doc_words(self, regex):
    """Returns an unsorted list of words in the current document. The given 
       regex is used to match the words.
    """
    iter1 = self.doc.get_start_iter()
    iter2 = self.doc.get_end_iter()
    text = self.doc.get_text(iter1, iter2)
    words = set(regex.findall(text))
    return list(words)

  def _get_other_doc_words(self, regex):
    """Returns an unsorted list of words in the non-current document based
       on the selected scope. The given regex is used to match the words.
    """
    if self.scope == 'application':
      # Index all documents open in any gedit window
      docs = gedit.app_get_default().get_documents()
    elif self.scope == 'window':
      # Index all documents in this gedit window
      docs = gedit.app_get_default().get_active_window().get_documents()
    else:
      # No other documents in use
      docs = []
    words = set()
    for doc in docs:
      if doc != self.doc:
        text = doc.get_text(doc.get_start_iter(), doc.get_end_iter())
        words.update(regex.findall(text))
    return list(words)

  def _create_regex_for_prefix(self, prefix):
    """Compiles a regular expression that matches words beginning with the 
       given prefix. If the prefix is empty, a match-any-word regular 
       expression is created.
    """
    return re.compile(r'\b' + prefix + r'\w+\b')

  def _get_candidate_matches(self, doc, prefix):
    """Returns all words in the document that match the given word"""
    regex = self._create_regex_for_prefix(prefix)
    if self.order == 'alphabetical':
      # Alphabetical sort
      words = self._get_current_doc_words(regex)
      other = self._get_other_doc_words(regex) 
      words.extend(other)
      words.sort()
    else:
      # Proximity sort in current doc, alphabetical in others
      words = self._get_current_doc_words_sorted_by_proximity(regex)
      other = self._get_other_doc_words(regex) 
      other.sort()
      words.extend(other)
    return uniq_order_preserved(words)

  def _should_promote_last_accepted(self, prefix):
    last = AutoCompleter.LastAcceptedMatch
    return (last is not None and self.promote and
      len(prefix) > len(last) and last.startswith(prefix))

  def reindex(self, doc):
    """Compile a list of candidate words for autocompletion"""
    self.doc = doc
    self.word = None
    self.matches = []
    self.index = 0
    self.iter_e = None
    self.iter_i = doc.get_iter_at_mark(doc.get_insert())
    if self._can_autocomplete_at(self.iter_i):
      self.iter_s = self._get_iter_for_beginning_of_word_at(self.iter_i)
      self.iter_e = self.iter_i.copy()
      self.word = doc.get_text(self.iter_s, self.iter_i)
      self.matches = self._get_candidate_matches(doc, self.word)
      if self._should_promote_last_accepted(self.word):
        self.matches.remove(self.LastAcceptedMatch)
        self.matches.insert(0, self.LastAcceptedMatch)
    return len(self.matches) > 0

  def has_completions(self):
    """Returns true if we can do autocompletion"""
    return 0 <= self.index < len(self.matches)

  def insert_next_completion(self):
    """Insert the next autocompletion into the document and move the cursor
       to the end of the completion. The previous autocompletion is removed.
    """
    insert_ok = self.has_completions()
    if insert_ok:
      self.doc.begin_user_action()
      
      # Store insertion offset
      insertion_point = self.iter_i.get_offset()
      
      # Remove previous completions
      if not self.iter_i.equal(self.iter_e):
        self.doc.delete(self.iter_i, self.iter_e)
        self.iter_i = self.doc.get_iter_at_offset(insertion_point)
      
      # Insert new completion
      match = self.matches[self.index]
      completion = match[len(self.word):]
      self.doc.insert(self.iter_i, completion, len(completion))
      AutoCompleter.LastAcceptedMatch = match
      
      # Update iterators
      self.iter_i = self.doc.get_iter_at_offset(insertion_point)
      self.iter_e = self.iter_i.copy()
      self.iter_s = self.iter_i.copy()
      self.iter_e.forward_chars(len(completion))
      self.iter_s.backward_chars(len(match))
      
      # Move cursor
      self.doc.place_cursor(self.iter_e)
      
      # Next completion
      self.index = self.index + 1 if self.index + 1 < len(self.matches) else 0
      self.doc.end_user_action()
    
    return insert_ok


class AutoCompletionPlugin(gedit.Plugin):
  """TextMate style autocompletion plugin for Gedit"""

  # Where our configuration data is held
  ConfigRoot = '/apps/gedit-2/plugins/tm_autocomplete'

  def __init__(self):
    self.autocompleter = None
    self.trigger = DEFAULT_TRIGGER
    self.scope = 'document'
    self.order = 'proximity'
    self.promote_last_accepted = True
    gedit.Plugin.__init__(self)

  def activate(self, window):
    self.gconf_activate()
    self.update_ui(window)

  def deactivate(self, window):
    for view in window.get_views():
      for handler_id in getattr(view, 'autocomplete_handlers', []):
        view.disconnect(handler_id)
      setattr(view, 'autocomplete_handlers_attached', False)
    self.autocompleter = None   
    self.gconf_deactivate()

  def update_ui(self, window):
    view = window.get_active_view()
    doc = window.get_active_document()
    if isinstance(view, gedit.View) and doc:
      if not getattr(view, 'autocomplete_handlers_attached', False):
        setattr(view, 'autocomplete_handlers_attached', True)
        self.autocompleter = None
        id1 = view.connect('key-press-event', self.on_key_press, doc)
        id2 = view.connect('button-press-event', self.on_button_press, doc)
        setattr(view, 'autocomplete_handlers', (id1, id2))

  def is_autocomplete_trigger(self, event):
    keyval, modifiers = self.trigger
    if modifiers and (modifiers & event.state) == 0:
      # Required modifiers not depressed
      return False
    return event.keyval == keyval

  def on_key_press(self, view, event, doc):
    if self.is_autocomplete_trigger(event):
      if not self.autocompleter:
        self.autocompleter = AutoCompleter(doc, self.scope, self.order,
          self.promote_last_accepted)
      if self.autocompleter and self.autocompleter.has_completions():
        self.autocompleter.insert_next_completion()
      else:
        self.autocompleter = None
      return True
    elif self.autocompleter:
      self.autocompleter = None
    return False

  def on_button_press(self, view, event, doc):
    if self.autocompleter:
      self.autocompleter = None
    return False

  def set_scope(self, scope):
    if scope != self.scope and scope in AutoCompleter.ValidScopes:
      self.scope = scope
      self.autocompleter = None
      return True
    return False

  def set_order(self, order):
    if order != self.order and order in AutoCompleter.ValidOrders:
      self.order = order
      self.autocompleter = None
      return True
    return False

  def set_promote_last_accepted(self, promote_last_accepted):
    if self.promote_last_accepted != promote_last_accepted:
      self.promote_last_accepted = promote_last_accepted
      self.autocompleter = None
      return True
    return False

  def set_trigger(self, trigger):
    if isinstance(trigger, str):
      try:
        self.trigger = gtk.accelerator_parse(trigger)
      except:
        self.trigger = DEFAULT_TRIGGER
    elif isinstance(trigger, tuple):
      self.trigger = trigger
    else:
      self.trigger = DEFAULT_TRIGGER

  def get_trigger_name(self):
    keyval, modifiers = self.trigger
    return gtk.accelerator_name(keyval, modifiers or 0)

  def gconf_activate(self):
    self.gconf_client = gconf.client_get_default()
    self.gconf_client.add_dir(self.ConfigRoot, gconf.CLIENT_PRELOAD_NONE)
    self.notify_id = self.gconf_client.notify_add(
      self.ConfigRoot, self.gconf_event)
    self.gconf_set_defaults(self.gconf_client)
    self.gconf_configure(self.gconf_client)

  def gconf_deactivate(self):
    self.gconf_client.notify_remove(self.notify_id)
    del self.notify_id
    del self.gconf_client

  def gconf_key_for(self, name):
    return '/'.join([self.ConfigRoot, name])

  def gconf_set_defaults(self, client):
    def set_string_default(name, value):
      key = self.gconf_key_for(name)
      if client.get(key) is None:
        client.set_string(key, value)
    def set_bool_default(name, value):
      key = self.gconf_key_for(name)
      if client.get(key) is None:
        client.set_bool(key, value)
    set_string_default('scope', self.scope)
    set_string_default('order', self.order)
    set_string_default('trigger', self.get_trigger_name())
    set_bool_default('promote', self.promote_last_accepted)
    client.suggest_sync()

  def gconf_configure(self, client):
    def get_string(name, default=None):
      value = client.get_string(self.gconf_key_for(name))
      return value if value is not None else default
    def get_bool(name):
      return client.get_bool(self.gconf_key_for(name))
    self.set_scope(get_string('scope'))
    self.set_order(get_string('order'))
    self.set_trigger(get_string('trigger'))
    self.set_promote_last_accepted(get_bool('promote'))

  def gconf_event(self, client, cnxn_id, entry, user_data):
    key, value = entry.get_key(), entry.get_value()
    name = key.split('/')[-1]
    if name == 'scope' and value is not None:
      self.set_scope(value.get_string())
    elif name == 'order' and value is not None:
      self.set_order(value.get_string())
    elif name == 'promote' and value is not None:
      self.set_promote_last_accepted(value.get_bool())
    elif name == 'trigger' and value is not None:
      self.set_trigger(value.get_string())

  def is_configurable(self):
    return True

  def create_configure_dialog(self):
    dialog = ConfigurationDialog(self.gconf_client,self.ConfigRoot)
    return dialog


class ConfigurationDialog(gtk.Dialog):
  Title = 'Autocompletion settings'
  TriggerKey = 'trigger'
  TriggerText = '<b>Autocompletion trigger:</b>'
  ScopeKey = 'scope'
  ScopeFrameText = '<b>Autocomplete using words from:</b>'
  ScopeDocText = 'The current document only'
  ScopeWinText = 'All open documents in the current window'
  ScopeAppText = 'All open documents in the application'
  OrderKey = 'order'
  OrderFrameText = '<b>Sort autocompletion list:</b>'
  OrderAlphaText = 'In alphabetical order'
  OrderProximityText = 'Based on distance from cursor'
  PromoteKey = 'promote'
  PromoteLastText = 'Promote last accepted match'

  def __init__(self, gconf_client, config_root):
    gtk.Dialog.__init__(self, self.Title, None, gtk.DIALOG_DESTROY_WITH_PARENT)
    self.gconf_client = gconf_client
    self.config_root = config_root
    self.set_resizable(False)
    mainbox = gtk.VBox()
    mainbox.set_border_width(10)
    mainbox.set_spacing(10)
    close_button = self.add_button(gtk.STOCK_CLOSE, gtk.RESPONSE_CLOSE)
    close_button.grab_default()
    close_button.connect('clicked', self.on_close, None)
    # Scope configuration
    frame = gtk.Frame(self.ScopeFrameText)
    frame.set_shadow_type(gtk.SHADOW_NONE)
    frame.get_label_widget().set_use_markup(True)
    scope_box = gtk.VBox(False, 0)
    scope_box.set_border_width(5)
    def scope_radio(text, scope, group=None):
      btn = gtk.RadioButton(group, text)
      btn.set_data(self.ScopeKey, scope)
      btn.connect('toggled', self.scope_configuration_change, gconf_client)
      btn.set_active(self._gconf_get_string(self.ScopeKey) == scope)
      scope_box.pack_start(btn)
      return btn
    btn1 = scope_radio(self.ScopeDocText, 'document')
    btn2 = scope_radio(self.ScopeWinText, 'window', btn1)
    btn3 = scope_radio(self.ScopeAppText, 'application', btn2)
    frame.add(scope_box)
    mainbox.pack_start(frame)
    # Order configuration
    frame = gtk.Frame(self.OrderFrameText)
    frame.set_shadow_type(gtk.SHADOW_NONE)
    frame.get_label_widget().set_use_markup(True)
    order_box = gtk.VBox(False, 0)
    order_box.set_border_width(5)
    def order_radio(text, order, group=None):
      btn = gtk.RadioButton(group, text)
      btn.set_data(self.OrderKey, order)
      btn.connect('toggled', self.order_configuration_change, gconf_client)
      btn.set_active(self._gconf_get_string(self.OrderKey) == order)
      order_box.pack_start(btn)
      return btn
    btn1 = order_radio(self.OrderAlphaText, 'alphabetical')
    btn2 = order_radio(self.OrderProximityText, 'proximity', btn1)
    btn3 = gtk.CheckButton(self.PromoteLastText)
    btn3.connect('toggled', self.promote_configuration_change, gconf_client)
    btn3.set_active(self._gconf_get_bool(self.PromoteKey))
    order_box.pack_start(btn3)
    frame.add(order_box)
    mainbox.pack_start(frame)
    # Autocompletion trigger
    frame = gtk.Frame()
    frame.set_shadow_type(gtk.SHADOW_NONE)
    hbox = gtk.HBox()
    hbox.set_spacing(10)
    label = gtk.Label(self.TriggerText)
    label.set_use_markup(True)
    try:
      accel = self._gconf_get_string(self.TriggerKey, 'Escape')
      self.trigger = gtk.accelerator_parse(accel)
    except:
      self.trigger = DEFAULT_TRIGGER
    entry = gtk.Entry()
    entry.set_text(self.get_trigger_display_text())
    entry.connect('key-press-event', self.on_trigger_entry_key_press)
    entry.connect('focus-in-event', self.on_trigger_entry_focus_in)
    entry.connect('focus-out-event', self.on_trigger_entry_focus_out)
    hbox.pack_start(label)
    hbox.pack_start(entry)
    frame.add(hbox)
    mainbox.pack_start(frame)
    # Show
    self.vbox.pack_start(mainbox)
    self.vbox.show_all()
    self.show()

  def on_close(self, widget, data=None):
    self.gconf_client.suggest_sync()
    gtk.Widget.destroy(self)

  def on_trigger_entry_focus_in(self, entry, event):
    entry.set_text('Type a new shortcut')

  def on_trigger_entry_key_press(self, entry, event):
    if event.keyval in (gtk.keysyms.Delete, gtk.keysyms.BackSpace):
      entry.set_text('')
      self.set_trigger(DEFAULT_TRIGGER)
    elif self.is_valid_trigger(event.keyval, event.state):
      modifiers = event.state & gtk.accelerator_get_default_mod_mask() 
      self.set_trigger((event.keyval, modifiers))
      entry.set_text(self.get_trigger_display_text())
    elif event.keyval == gtk.keysyms.Tab:
      return False
    return True

  def on_trigger_entry_focus_out(self, entry, event):
    entry.set_text(self.get_trigger_display_text())

  def is_valid_trigger(self, keyval, mod):
    mod &= gtk.accelerator_get_default_mod_mask()
    if keyval == gtk.keysyms.Escape:
      return True
    if mod and gtk.gdk.keyval_to_unicode(keyval):
      return True
    valid_keysyms = [
      gtk.keysyms.Return,
      gtk.keysyms.Tab,
      gtk.keysyms.Left,
      gtk.keysyms.Right,
      gtk.keysyms.Up,
      gtk.keysyms.Down ]
    valid_keysyms.extend(range(gtk.keysyms.F1, gtk.keysyms.F12 + 1))
    return mod and keyval in valid_keysyms

  def set_trigger(self, trigger):
    if self.trigger != trigger:
      self.trigger = keyval, modifiers = trigger
      accelerator = gtk.accelerator_name(keyval, modifiers or 0)
      self._gconf_set_string(self.TriggerKey, accelerator)

  def get_trigger_display_text(self):
    display_text = None
    if self.trigger is not None:
      keyval, modifiers = self.trigger
      display_text = gtk.accelerator_get_label(keyval, modifiers or 0)
    return display_text or ''

  def _gconf_set_string(self, name, value):
    key = '/'.join((self.config_root, name))
    if self.gconf_client.get_string(key) != value:
      self.gconf_client.set_string(key, value)
      return True
    return False

  def _gconf_get_string(self, name, default=None):
    key = '/'.join((self.config_root, name))
    value = self.gconf_client.get_string(key)
    return value if value is not None else default

  def _gconf_set_bool(self, name, value):
    key = '/'.join((self.config_root, name))
    if self.gconf_client.get_bool(key) != value:
      self.gconf_client.set_bool(key, value)
      return True
    return False

  def _gconf_get_bool(self, name, default=None):
    key = '/'.join((self.config_root, name))
    value = self.gconf_client.get_bool(key)
    return value if value is not None else default

  def scope_configuration_change(self, widget, data=None):
    scope = widget.get_data(self.ScopeKey)
    if scope is not None and scope in AutoCompleter.ValidScopes:
      self._gconf_set_string(self.ScopeKey, scope)

  def order_configuration_change(self, widget, data=None):
    order = widget.get_data(self.OrderKey)
    if order is not None and order in AutoCompleter.ValidOrders:
      self._gconf_set_string(self.OrderKey, order)

  def promote_configuration_change(self, widget, data=None):
    self._gconf_set_bool(self.PromoteKey, widget.get_active())

# ex:ts=2:sw=2:et:

########NEW FILE########
__FILENAME__ = todo
# -*- coding: utf-8 -*-
#
# Copyright (C) 2007 - Alexandre da Silva
#
# Inspired in Nando Vieira's todo.rb source code
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#

import os, sys, operator
from stat import *
from string import Template
import re

def parse_directory(root):

    home_folder = os.path.expanduser('~')

    # TODO: Look first for a config file present in /etc to facility configuration
    # Config FileName
    config_file = os.path.join(os.path.dirname(__file__), "todo.conf")

    # Configs read regular expression
    cfg_rx = re.compile(r"(ALLOWED_EXTENSIONS|SKIPED_DIRS|KNOWN_MARKS|SKIPED_FILES|SHOW_EMPTY_MARKS|REQUIRE_COLON|MARK_COLORS)=+(.*?)$")

    # Get Configuration Info
    cfg_file = open(config_file,'r')
    cfg_data = cfg_file.read().split('\n')

    configs = {'ALLOWED_EXTENSIONS':'','SKIPED_DIRS':'','KNOWN_MARKS':'',\
            'SKIPED_FILES':'','SHOW_EMPTY_MARKS':'0','REQUIRE_COLON':'1','MARK_COLORS': ''}

    for cfg_line in cfg_data:
        cfg_match = cfg_rx.search(cfg_line)
        if cfg_match:
            configs[cfg_match.group(1)] = cfg_match.group(2)

    def make_regex(config_str):
        return "|".join([re.escape(k) for k in configs[config_str].split(';')])

    allowed_extensions_regex = make_regex('ALLOWED_EXTENSIONS')
    skiped_dirs_regex = make_regex('SKIPED_DIRS')
    known_marks_regex = make_regex('KNOWN_MARKS')
    skiped_files_regex = make_regex('SKIPED_FILES')

    known_marks_list = known_marks_regex.split('|')

    # Initial Setup
    allowed_types = re.compile(r'.*\.\b(%s)\b$' % allowed_extensions_regex)
    skiped_dirs = re.compile(r'.*(%s)$' % skiped_dirs_regex)
    # Enable os disable colons
    if configs["REQUIRE_COLON"] == "1":
        known_marks = re.compile(r'\b(%s)\b\s?: +(.*?)$' % known_marks_regex)
    else:
        known_marks = re.compile(r'\b(%s)\b\s?:? +(.*?)$' % known_marks_regex)
    skiped_files = re.compile(r"("+skiped_files_regex+")$")

    total_marks = 0

    # Helper Functions
    def file_link(file, line=0):
        return "gedit:///%s?line=%d" % (file,line-1)

    # Escape possible tags from comments as HTML
    def escape(str_):
        lt = re.compile(r'<')
        gt = re.compile(r'>')
        return lt.sub("&lt;",gt.sub("&gt;",str_))

    # Todo Header image pattern
    def todo_header():
        return "file://" + os.path.join(os.path.dirname(__file__), "todo_header.png")

    # Todo Gear Image
    def todo_gears():
        return "file://" + os.path.join(os.path.dirname(__file__), "todo_gears.png")

    # Initialize the values list
    values = []

    # Markup Label Counter
    labels = {}

    for label in known_marks_list:
        labels[label]=0


    # walk over directory tree
    def walktree(top, callback):
        '''recursively descend the directory tree rooted at top,
           calling the callback function for each regular file'''

        for f in os.listdir(top):
            pathname = os.path.join(top, f)
            try:
                mode = os.stat(pathname)[ST_MODE]
                if S_ISDIR(mode):
                    # It's a directory, recurse into it
                    if not skiped_dirs.match(pathname):
                        walktree(pathname, callback)
                elif S_ISREG(mode):
                    # It's a file, call the callback function
                    if not skiped_files.match(pathname):
                        callback(pathname)
                else:
                    # Unknown file type, pass
                    pass
            except OSError:
                continue

    # Test File Callback function
    def test_file(file):
        """ Parse the file passed as argument searching for TODO Tags"""
        if allowed_types.match(file):
            try:
                file_search = open(file, 'r')
            except IOError:
                sys.exit(2)

            data = file_search.read()
            data = data.split('\n')

            # Line Number
            ln = 0
            for line in data:
                ln = ln + 1
                a_match = known_marks.search(line)
                if (a_match):
                    pt, fl = os.path.split(file)
                    labels[a_match.group(1)] += 1
                    result = [file,fl,ln,a_match.group(1),a_match.group(2)]
                    values.append(result)

    # Search Directories for files matching
    walktree(root, test_file)

    html = '<div id="todo_list">\n'

    # Make the Menu
    menu = '<ul id="navigation">\n'
    for label in labels:
        total_marks += labels[label]
        if configs['SHOW_EMPTY_MARKS'] == '1' or labels[label]:
            menu += '   <li class="%s"><a href="#%s-title">%s</a>: %d</li>\n' % (label.lower(), label.lower(), label, labels[label])

    menu += '<li class="total">Total: %d</li></ul>\n' % total_marks

    table_pattern = Template(\
    """\
        <h2 id=\"${label}-title\">${labelU}</h2>
        <table id="${label}">
        <thead>
            <tr>
                <th class="file">File</th>
                <th class="comment">Comment</th>
            </tr>
        </thead>
        <tbody>
    """
    )

    tables = {}

    for label_ in known_marks_list:
        tables[label_]= table_pattern.substitute(dict(label=label_.lower(),labelU=label_.upper()))

    table_row_pattern = '        <tr class="%s"><td><a href="%s"  title="%s">%s</a> <span>(%s)</span></td><td>%s</td>\n'

    def format_row(value_):
        return table_row_pattern % (css, file_link(value_[0], value_[2]), value_[0], value_[1], value_[2], value_[4])

    for ix, value in enumerate(sorted(values,key=operator.itemgetter(3))):
        css = 'odd'
        if ix % 2 == 0:
            css = 'even'
        for table_value in tables:
            if value[3] == table_value:
                tables[table_value] += format_row(value)

    for table_value in tables:
        tables[table_value] += '    </tbody></table>\n'

    html += menu

    for label in labels:
        if labels[label]:
            html += tables[label]

    html += '   <a href="#todo_list" id="toplink"> top</a>\n  </div>'

    todo_links_css_pattern = \
    """
        #${label}-title {
            color: ${color};
        }
        li.${label} {
            background: ${color};
        }
    """

    todo_links_css = ''

    color_rx = re.compile(r'^(.*)(#[0-9a-fA-F]{6})$')

    todo_links_template = Template(todo_links_css_pattern)

    for markcolor in configs['MARK_COLORS'].split(';'):
        c_match = color_rx.search(markcolor)
        if c_match:
            mark,mcolor = c_match.group(1), c_match.group(2)
            todo_links_css += todo_links_template.substitute(label=mark.lower(),color=mcolor)
    # TODO: load this template pattern from a file.
    html_pattern = \
    """
    <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
        "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
    <html>
    <head>
        <meta http-equiv="Content-type" content="text/html; charset=utf-8" />
        <title>TODO-List</title>
        <style type="text/css">
        * {
            color: #333;
        }

        body {
            font-size: 12px;
            font-family: "bitstream vera sans mono", "sans-serif";
            padding: 0;
            margin: 0;
            width: 700px;
            height: 500px;
        }

        th {
            text-align: left;
        }

        td {
            vertical-align: top;
        }

        ${labelcss}

        th, a {
            color: #0D2681;
        }

        .odd td {
            background: #f0f0f0;
        }

        table {
            border-collapse: collapse;
            width: 650px;
        }

        td,th {
            padding: 3px;
        }

        th {
            border-bottom: 1px solid #999;
        }

        th.file {
            width: 30%;
        }

        #toplink {
            position: fixed;
            bottom: 10px;
            right: 40px;
        }

        h1 {
            color: #fff;
            padding: 20px 5px 18px 5px;
            margin: 0;
        }

        h2 {
            font-size: 16px;
            margin: 0 0 10px;
            padding-top: 30px;
        }

        #page {
            overflow: auto;
            height: 406px;
            padding: 0 15px 20px 15px;
            position: relative;
        }

        #root {
            position: absolute;
            top: 28px;
            right: 23px;
            color: #fff;
        }

        #navigation {
            margin: 0;
            padding: 0;
            border-left: 1px solid #000;
        }

        #navigation * {
            color: #fff;
        }

        li.total {
            background: #000000;
            font-weight: bold
        }

        #navigation li {
            float: left;
            list-style: none;
            text-align: center;
            padding: 7px 10px;
            margin: 0;
            border: 1px solid #000;
            border-left: none;
            font-weight: bold
        }

        #navigation:after {
            content: ".";
            display: block;
            height: 0;
            clear: both;
            visibility: hidden;
        }

        #todo_list {
            padding-top: 30px;
        }

        #container {
            position: relative;
            background: url(${todo_header}) repeat-x;
        }

        #gears {
            float : right;
            margin : 0 0 0 0;
        }

        </style>
    </head>
    <body>
    <div id="container">
    <img src="${todo_gears}" id="gears" />
    <h1>TODO List</h1>
    <p id="root">${root}</p>
    <div id="page">
        ${html}
    </div>
    </div>
    </body>
    </html>
    """

    markup = Template(html_pattern)

    markup_out = markup.substitute(todo_header=todo_header(), \
        todo_gears=todo_gears(),root=escape(root), html=html, \
        labelcss=todo_links_css)
    return markup_out


########NEW FILE########
__FILENAME__ = trailsave
# Copyright (C) 2006-2008 Osmo Salomaa
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

"""Automatically strip all trailing whitespace before saving."""

import gedit
import os
import gconf

from smart_indent import get_crop_spaces_eol, get_insert_newline_eof, get_remove_blanklines_eof


class SaveWithoutTrailingSpacePlugin(gedit.Plugin):

    """Automatically strip all trailing whitespace before saving."""

    def activate(self, window):
        """Activate plugin."""

        handler_id = window.connect("tab-added", self.on_window_tab_added)
        window.set_data(self.__class__.__name__, handler_id)
        for doc in window.get_documents():
            self.connect_document(doc)


    def connect_document(self, doc):
        """Connect to document's 'saving' signal."""

        handler_id = doc.connect("saving", self.on_document_saving)
        doc.set_data(self.__class__.__name__, handler_id)


    def deactivate(self, window):
        """Deactivate plugin."""

        name = self.__class__.__name__
        handler_id = window.get_data(name)
        window.disconnect(handler_id)
        window.set_data(name, None)
        for doc in window.get_documents():
            handler_id = doc.get_data(name)
            doc.disconnect(handler_id)
            doc.set_data(name, None)


    def on_document_saving(self, doc, *args):
        """Strip trailing spaces in document."""

#        cursor = doc.get_iter_at_mark(doc.get_insert())
#        line = cursor.get_line()
#        offset = cursor.get_line_offset()
#        doc.begin_user_action()
        self.strip_trailing_spaces_on_lines(doc)
        self.strip_trailing_blank_lines(doc)
#        doc.end_user_action()
#        try:
#            doc.go_to_line(line)
#        except:
#            pass
        return


    def on_window_tab_added(self, window, tab):
        """Connect the document in tab."""

        name = self.__class__.__name__
        doc = tab.get_document()
        handler_id = doc.get_data(name)
        if handler_id is None:
            self.connect_document(doc)


    def get_language_id(self, doc):
        language = doc.get_language()
        if language is None:
            return 'plain_text'
        return language.get_id()


    def strip_trailing_blank_lines(self, doc):
        """Delete trailing space at the end of the document but let the line"""
        lng = self.get_language_id(doc)

        if get_remove_blanklines_eof(lng):
            buffer_end = doc.get_end_iter()
            if buffer_end.starts_line():
                itr = buffer_end.copy()
                while itr.backward_line():
                    if not itr.ends_line():
                        itr.forward_to_line_end()
                        #itr.forward_char()
                        break
                doc.delete(itr, buffer_end)

        if get_insert_newline_eof(lng):
            buffer_end = doc.get_end_iter()
            itr = buffer_end.copy()
            if itr.backward_char():
                if not itr.get_text(buffer_end) == "\n":
                    doc.insert(buffer_end, "\n")


    def strip_trailing_spaces_on_lines(self, doc):
        """Delete trailing space at the end of each line."""
        lng = self.get_language_id(doc)
        if get_crop_spaces_eol(lng):
            buffer_end = doc.get_end_iter()
            for line in range(buffer_end.get_line() + 1):
                line_end = doc.get_iter_at_line(line)
                line_end.forward_to_line_end()
                itr = line_end.copy()
                while itr.backward_char():
                    if not itr.get_char() in (" ", "\t"):
                        itr.forward_char()
                        break
                doc.delete(itr, line_end)


########NEW FILE########
__FILENAME__ = comment
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Comment important tags (with 'id' and 'class' attributes)
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
from zencoding import zen_core as zen_coding

alias = 'c'
"Filter name alias (if not defined, ZC will use module name)"

def add_comments(node, i):
	
	"""
	Add comments to tag
	@type node: ZenNode
	@type i: int
	"""
	id_attr = node.get_attribute('id')
	class_attr = node.get_attribute('class')
	nl = zen_coding.get_newline()
		
	if id_attr or class_attr:
		comment_str = ''
		padding = node.parent and node.parent.padding or ''
		if id_attr: comment_str += '#' + id_attr
		if class_attr: comment_str += '.' + class_attr
		
		node.start = node.start.replace('<', '<!-- ' + comment_str + ' -->' + nl + padding + '<', 1)
		node.end = node.end.replace('>', '>' + nl + padding + '<!-- /' + comment_str + ' -->', 1)
		
		# replace counters
		node.start = zen_coding.replace_counter(node.start, i + 1)
		node.end = zen_coding.replace_counter(node.end, i + 1)

def process(tree, profile):
	if profile['tag_nl'] is False:
		return tree
		
	for i, item in enumerate(tree.children):
		if item.is_block():
			add_comments(item, i)
		process(item, profile)
	
	return tree
########NEW FILE########
__FILENAME__ = escape
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter for escaping unsafe XML characters: <, >, &
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
import re

alias = 'e'
"Filter name alias (if not defined, ZC will use module name)"

char_map = {
	'<': '&lt;',
	'>': '&gt;',
	'&': '&amp;'
}

re_chars = re.compile(r'[<>&]')

def escape_chars(text):
	return re_chars.sub(lambda m: char_map[m.group(0)], text)

def process(tree, profile=None):
	for item in tree.children:
		item.start = escape_chars(item.start)
		item.end = escape_chars(item.end)
		
		process(item)
	
	return tree
########NEW FILE########
__FILENAME__ = format-css
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Format CSS properties: add space after property name:
padding:0; -> padding: 0;
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
import re

alias = 'fc'
"Filter name alias (if not defined, ZC will use module name)"

re_css_prop = re.compile(r'([\w\-]+\s*:)\s*')

def process(tree, profile):
	for item in tree.children:
		# CSS properties are always snippets 
		if item.type == 'snippet':
			item.start = re_css_prop.sub(r'\1 ', item.start)
		
		process(item, profile)
		
	return tree
########NEW FILE########
__FILENAME__ = format
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Generic formatting filter: creates proper indentation for each tree node,
placing "%s" placeholder where the actual output should be. You can use
this filter to preformat tree and then replace %s placeholder to whatever you
need. This filter should't be called directly from editor as a part 
of abbreviation.
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
"""
import re
from zencoding import zen_core as zen_coding

alias = '_format'
"Filter name alias (if not defined, ZC will use module name)"

child_token = '${child}'
placeholder = '%s'

def get_newline():
	return zen_coding.get_newline()


def get_indentation():
	return zen_coding.get_indentation()

def has_block_sibling(item):
	"""
	Test if passed node has block-level sibling element
	@type item: ZenNode
	@return: bool
	"""
	return item.parent and item.parent.has_block_children()

def is_very_first_child(item):
	"""
	Test if passed itrem is very first child of the whole tree
	@type tree: ZenNode
	"""
	return item.parent and not item.parent.parent and not item.previous_sibling

def should_break_line(node, profile):
	"""
	Need to add line break before element
	@type node: ZenNode
	@type profile: dict
	@return: bool
	"""
	if not profile['inline_break']:
		return False
		
	# find toppest non-inline sibling
	while node.previous_sibling and node.previous_sibling.is_inline():
		node = node.previous_sibling
	
	if not node.is_inline():
		return False
		
	# calculate how many inline siblings we have
	node_count = 1
	node = node.next_sibling
	while node:
		if node.is_inline():
			node_count += 1
		else:
			break
		node = node.next_sibling
	
	return node_count >= profile['inline_break']

def should_break_child(node, profile):
	"""
	 Need to add newline because <code>item</code> has too many inline children
	 @type node: ZenNode
	 @type profile: dict
	 @return: bool
	"""
	# we need to test only one child element, because 
	# has_block_children() method will do the rest
	return node.children and should_break_line(node.children[0], profile)

def process_snippet(item, profile, level=0):
	"""
	Processes element with <code>snippet</code> type
	@type item: ZenNode
	@type profile: dict
	@param level: Depth level
	@type level: int
	"""
	data = item.source.value;
		
	if not data:
		# snippet wasn't found, process it as tag
		return process_tag(item, profile, level)
		
	item.start = placeholder
	item.end = placeholder
	
	padding = item.parent.padding if item.parent else get_indentation() * level 
	
	if not is_very_first_child(item):
		item.start = get_newline() + padding + item.start
	
	# adjust item formatting according to last line of <code>start</code> property
	parts = data.split(child_token)
	lines = zen_coding.split_by_lines(parts[0] or '')
	padding_delta = get_indentation()
		
	if len(lines) > 1:
		m = re.match(r'^(\s+)', lines[-1])
		if m:
			padding_delta = m.group(1)
	
	item.padding = padding + padding_delta
	
	return item

def process_tag(item, profile, level=0):
	"""
	Processes element with <code>tag</code> type
	@type item: ZenNode
	@type profile: dict
	@param level: Depth level
	@type level: int
	"""
	if not item.name:
		# looks like it's a root element
		return item
	
	item.start = placeholder
	item.end = placeholder
	
	is_unary = item.is_unary() and not item.children
		
	# formatting output
	if profile['tag_nl'] is not False:
		padding = item.parent.padding if item.parent else get_indentation() * level
		force_nl = profile['tag_nl'] is True
		should_break = should_break_line(item, profile)
		
		# formatting block-level elements
		if ((item.is_block() or should_break) and item.parent) or force_nl:
			# snippet children should take different formatting
			if not item.parent or (item.parent.type != 'snippet' and not is_very_first_child(item)):
				item.start = get_newline() + padding + item.start
				
			if item.has_block_children() or should_break_child(item, profile) or (force_nl and not is_unary):
				item.end = get_newline() + padding + item.end
				
			if item.has_tags_in_content() or (force_nl and not item.has_children() and not is_unary):
				item.start += get_newline() + padding + get_indentation()
			
		elif item.is_inline() and has_block_sibling(item) and not is_very_first_child(item):
			item.start = get_newline() + padding + item.start
		
		item.padding = padding + get_indentation()
	
	return item

def process(tree, profile, level=0):
	"""
	Processes simplified tree, making it suitable for output as HTML structure
	@type item: ZenNode
	@type profile: dict
	@param level: Depth level
	@type level: int
	"""
	
	for item in tree.children:
		if item.type == 'tag':
			item = process_tag(item, profile, level)
		else:
			item = process_snippet(item, profile, level)
		
		if item.content:
			item.content = zen_coding.pad_string(item.content, item.padding)
			
		process(item, profile, level + 1)
	
	return tree
########NEW FILE########
__FILENAME__ = haml
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter that produces HAML tree
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
from zencoding import zen_core as zen_coding

child_token = '${child}'
	
def make_attributes_string(tag, profile):
	"""
	 Creates HTML attributes string from tag according to profile settings
	 @type tag: ZenNode
	 @type profile: dict
	"""
	# make attribute string
	attrs = ''
	attr_quote = profile['attr_quotes'] == 'single' and "'" or '"'
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
		
	# use short notation for ID and CLASS attributes
	for a in tag.attributes:
		name_lower = a['name'].lower()
		if name_lower == 'id':
			attrs += '#' + (a['value'] or cursor)
		elif name_lower == 'class':
			attrs += '.' + (a['value'] or cursor)
			
	other_attrs = []
	
	# process other attributes
	for a in tag.attributes:
		name_lower = a['name'].lower()
		if name_lower != 'id' and name_lower != 'class':
			attr_name = profile['attr_case'] == 'upper' and a['name'].upper() or name_lower
			other_attrs.append(':' + attr_name + ' => ' + attr_quote + (a['value'] or cursor) + attr_quote)
		
	if other_attrs:
		attrs += '{' + ', '.join(other_attrs) + '}'
	
	return attrs

def _replace(placeholder, value):
	if placeholder:
		return placeholder % value
	else:
		return value		

def process_snippet(item, profile, level=0):
	"""
	Processes element with <code>snippet</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	data = item.source.value
		
	if not data:
		# snippet wasn't found, process it as tag
		return process_tag(item, profile, level)
		
	tokens = data.split(child_token)
	if len(tokens) < 2:
		start = tokens[0]
		end = ''
	else:
		start, end = tokens
	
	padding = item.parent and item.parent.padding or ''
		
	item.start = _replace(item.start, zen_coding.pad_string(start, padding))
	item.end = _replace(item.end, zen_coding.pad_string(end, padding))
	
	return item

def has_block_sibling(item):
	"""
	Test if passed node has block-level sibling element
	@type item: ZenNode
	@return: bool
	"""
	return item.parent and item.parent.has_block_children()

def process_tag(item, profile, level=0):
	"""
	Processes element with <code>tag</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	if not item.name:
		# looks like it's root element
		return item
	
	attrs = make_attributes_string(item, profile) 
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
	self_closing = ''
	is_unary = item.is_unary() and not item.children
	
	if profile['self_closing_tag'] and is_unary:
		self_closing = '/'
		
	# define tag name
	tag_name = '%' + (profile['tag_case'] == 'upper' and item.name.upper() or item.name.lower())
					
	if tag_name.lower() == '%div' and '{' not in attrs:
		# omit div tag
		tag_name = ''
		
	item.end = ''
	item.start = _replace(item.start, tag_name + attrs + self_closing)
	
	if not item.children and not is_unary:
		item.start += cursor
	
	return item

def process(tree, profile, level=0):
	"""
	Processes simplified tree, making it suitable for output as HTML structure
	@type tree: ZenNode
	@type profile: dict
	@type level: int
	"""
	if level == 0:
		# preformat tree
		tree = zen_coding.run_filters(tree, profile, '_format')
		
	for i, item in enumerate(tree.children):
		if item.type == 'tag':
			process_tag(item, profile, level)
		else:
			process_snippet(item, profile, level)
	
		# replace counters
		item.start = zen_coding.unescape_text(zen_coding.replace_counter(item.start, item.counter))
		item.end = zen_coding.unescape_text(zen_coding.replace_counter(item.end, item.counter))
		process(item, profile, level + 1)
		
	return tree

########NEW FILE########
__FILENAME__ = html
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter that produces HTML tree
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
from zencoding import zen_core as zen_coding

child_token = '${child}'

def make_attributes_string(tag, profile):
	"""
	Creates HTML attributes string from tag according to profile settings
	@type tag: ZenNode
	@type profile: dict
	"""
	# make attribute string
	attrs = ''
	attr_quote = profile['attr_quotes'] == 'single' and "'" or '"'
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
	
	# process other attributes
	for a in tag.attributes:
		attr_name = profile['attr_case'] == 'upper' and a['name'].upper() or a['name'].lower()
		attrs += ' ' + attr_name + '=' + attr_quote + (a['value'] or cursor) + attr_quote
		
	return attrs

def _replace(placeholder, value):
	if placeholder:
		return placeholder % value
	else:
		return value

def process_snippet(item, profile, level):
	"""
	Processes element with <code>snippet</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	data = item.source.value;
		
	if not data:
		# snippet wasn't found, process it as tag
		return process_tag(item, profile, level)
		
	tokens = data.split(child_token)
	if len(tokens) < 2:
		start = tokens[0]
		end = ''
	else:
		start, end = tokens
		
	padding = item.parent and item.parent.padding or ''
		
	item.start = _replace(item.start, zen_coding.pad_string(start, padding))
	item.end = _replace(item.end, zen_coding.pad_string(end, padding))
	
	return item


def has_block_sibling(item):
	"""
	Test if passed node has block-level sibling element
	@type item: ZenNode
	@return: bool
	"""
	return item.parent and item.parent.has_block_children()

def process_tag(item, profile, level):
	"""
	Processes element with <code>tag</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	if not item.name:
		# looks like it's root element
		return item
	
	attrs = make_attributes_string(item, profile) 
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
	self_closing = ''
	is_unary = item.is_unary() and not item.children
	start= ''
	end = ''
	
	if profile['self_closing_tag'] == 'xhtml':
		self_closing = ' /'
	elif profile['self_closing_tag'] is True:
		self_closing = '/'
		
	# define opening and closing tags
	tag_name = profile['tag_case'] == 'upper' and item.name.upper() or item.name.lower()
	if is_unary:
		start = '<' + tag_name + attrs + self_closing + '>'
		item.end = ''
	else:
		start = '<' + tag_name + attrs + '>'
		end = '</' + tag_name + '>'
	
	item.start = _replace(item.start, start)
	item.end = _replace(item.end, end)
	
	if not item.children and not is_unary:
		item.start += cursor
	
	return item

def process(tree, profile, level=0):
	"""
	Processes simplified tree, making it suitable for output as HTML structure
	@type tree: ZenNode
	@type profile: dict
	@type level: int
	"""
	if level == 0:
		# preformat tree
		tree = zen_coding.run_filters(tree, profile, '_format')
		zen_coding.max_tabstop = 0
		
	for item in tree.children:
		if item.type == 'tag':
			process_tag(item, profile, level)
		else:
			process_snippet(item, profile, level)
	
		# replace counters
		item.start = zen_coding.unescape_text(zen_coding.replace_counter(item.start, item.counter))
		item.end = zen_coding.unescape_text(zen_coding.replace_counter(item.end, item.counter))
		zen_coding.upgrade_tabstops(item)
		
		process(item, profile, level + 1)
		
	return tree

########NEW FILE########
__FILENAME__ = xsl
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter for trimming "select" attributes from some tags that contains
child elements
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
import re

tags = {
	'xsl:variable': 1,
	'xsl:with-param': 1
}

re_attr = re.compile(r'\s+select\s*=\s*([\'"]).*?\1')

def trim_attribute(node):
	"""
	Removes "select" attribute from node
	@type node: ZenNode
	"""
	node.start = re_attr.sub('', node.start)

def process(tree, profile):
	for item in tree.children:
		if item.type == 'tag' and item.name.lower() in tags and item.children:
			trim_attribute(item)
		
		process(item, profile)
########NEW FILE########
__FILENAME__ = html_matcher
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Context-independent xHTML pair matcher
Use method <code>match(html, start_ix)</code> to find matching pair.
If pair was found, this function returns a list of indexes where tag pair 
starts and ends. If pair wasn't found, <code>None</code> will be returned.

The last matched (or unmatched) result is saved in <code>last_match</code> 
dictionary for later use.

@author: Sergey Chikuyonok (serge.che@gmail.com)
'''
import re

start_tag = r'<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>\s]+))?)*)\s*(\/?)>'
end_tag = r'<\/([\w\:\-]+)[^>]*>'
attr = r'([\w\-:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:\'((?:\\.|[^\'])*)\')|([^>\s]+)))?'

"Last matched HTML pair"
last_match = {
	'opening_tag': None, # Tag() or Comment() object
	'closing_tag': None, # Tag() or Comment() object
	'start_ix': -1,
	'end_ix': -1
}

cur_mode = 'xhtml'
"Current matching mode"

def set_mode(new_mode):
	global cur_mode
	if new_mode != 'html': new_mode = 'xhtml'
	cur_mode = new_mode

def make_map(elems):
	"""
	Create dictionary of elements for faster searching
	@param elems: Elements, separated by comma
	@type elems: str
	"""
	obj = {}
	for elem in elems.split(','):
			obj[elem] = True

	return obj

# Empty Elements - HTML 4.01
empty = make_map("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed");

# Block Elements - HTML 4.01
block = make_map("address,applet,blockquote,button,center,dd,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,isindex,li,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul");

# Inline Elements - HTML 4.01
inline = make_map("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");

# Elements that you can, intentionally, leave open
# (and which close themselves)
close_self = make_map("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

# Attributes that have their values filled in disabled="disabled"
fill_attrs = make_map("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");

#Special Elements (can contain anything)
# serge.che: parsing data inside <scipt> elements is a "feature"
special = make_map("style");

class Tag():
	"""Matched tag"""
	def __init__(self, match, ix):
		"""
		@type match: MatchObject
		@param match: Matched HTML tag
		@type ix: int
		@param ix: Tag's position
		"""
		global cur_mode
		
		name = match.group(1).lower()
		self.name = name
		self.full_tag = match.group(0)
		self.start = ix
		self.end = ix + len(self.full_tag)
		self.unary = ( len(match.groups()) > 2 and bool(match.group(3)) ) or (name in empty and cur_mode == 'html')
		self.type = 'tag'
		self.close_self = (name in close_self and cur_mode == 'html')

class Comment():
	"Matched comment"
	def __init__(self, start, end):
		self.start = start
		self.end = end
		self.type = 'comment'

def make_range(opening_tag=None, closing_tag=None, ix=0):
	"""
	Makes selection ranges for matched tag pair
	@type opening_tag: Tag
    @type closing_tag: Tag
    @type ix: int
    @return list
	"""
	start_ix, end_ix = -1, -1
	
	if opening_tag and not closing_tag: # unary element
		start_ix = opening_tag.start
		end_ix = opening_tag.end
	elif opening_tag and closing_tag: # complete element
		if (opening_tag.start < ix and opening_tag.end > ix) or (closing_tag.start <= ix and closing_tag.end > ix):
			start_ix = opening_tag.start
			end_ix = closing_tag.end;
		else:
			start_ix = opening_tag.end
			end_ix = closing_tag.start
	
	return start_ix, end_ix

def save_match(opening_tag=None, closing_tag=None, ix=0):
	"""
	Save matched tag for later use and return found indexes
    @type opening_tag: Tag
    @type closing_tag: Tag
    @type ix: int
    @return list
	"""
	last_match['opening_tag'] = opening_tag; 
	last_match['closing_tag'] = closing_tag;
	
	last_match['start_ix'], last_match['end_ix'] = make_range(opening_tag, closing_tag, ix)
	
	return last_match['start_ix'] != -1 and (last_match['start_ix'], last_match['end_ix']) or (None, None)

def match(html, start_ix, mode='xhtml'):
	"""
	Search for matching tags in <code>html</code>, starting from
	<code>start_ix</code> position. The result is automatically saved
	in <code>last_match</code> property
	"""
	return _find_pair(html, start_ix, mode, save_match)

def find(html, start_ix, mode='xhtml'):
	"""
	Search for matching tags in <code>html</code>, starting from
	<code>start_ix</code> position.
	"""
	return _find_pair(html, start_ix, mode)

def get_tags(html, start_ix, mode='xhtml'):
	"""
	Search for matching tags in <code>html</code>, starting from 
	<code>start_ix</code> position. The difference between 
	<code>match</code> function itself is that <code>get_tags</code> 
	method doesn't save matched result in <code>last_match</code> property 
	and returns array of opening and closing tags
	This method is generally used for lookups
	"""
	return _find_pair(html, start_ix, mode, lambda op, cl=None, ix=0: (op, cl) if op and op.type == 'tag' else None)


def _find_pair(html, start_ix, mode='xhtml', action=make_range):
	"""
	Search for matching tags in <code>html</code>, starting from
	<code>start_ix</code> position
	
	@param html: Code to search
	@type html: str
	
	@param start_ix: Character index where to start searching pair
	(commonly, current caret position)
	@type start_ix: int
	
	@param action: Function that creates selection range
	@type action: function
	
	@return: list
	"""

	forward_stack = []
	backward_stack = []
	opening_tag = None
	closing_tag = None
	html_len = len(html)
	
	set_mode(mode)

	def has_match(substr, start=None):
		if start is None:
			start = ix

		return html.find(substr, start) == start


	def find_comment_start(start_pos):
		while start_pos:
			if html[start_pos] == '<' and has_match('<!--', start_pos):
				break

			start_pos -= 1

		return start_pos

#    find opening tag
	ix = start_ix - 1
	while ix >= 0:
		ch = html[ix]
		if ch == '<':
			check_str = html[ix:]
			m = re.match(end_tag, check_str)
			if m:  # found closing tag
				tmp_tag = Tag(m, ix)
				if tmp_tag.start < start_ix and tmp_tag.end > start_ix: # direct hit on searched closing tag
					closing_tag = tmp_tag
				else:
					backward_stack.append(tmp_tag)
			else:
				m = re.match(start_tag, check_str)
				if m: # found opening tag
					tmp_tag = Tag(m, ix);
					if tmp_tag.unary:
						if tmp_tag.start < start_ix and tmp_tag.end > start_ix: # exact match
							return action(tmp_tag, None, start_ix)
					elif backward_stack and backward_stack[-1].name == tmp_tag.name:
						backward_stack.pop()
					else: # found nearest unclosed tag
						opening_tag = tmp_tag
						break
				elif check_str.startswith('<!--'): # found comment start
					end_ix = check_str.find('-->') + ix + 3;
					if ix < start_ix and end_ix >= start_ix:
						return action(Comment(ix, end_ix))
		elif ch == '-' and has_match('-->'): # found comment end
			# search left until comment start is reached
			ix = find_comment_start(ix)

		ix -= 1
		
	if not opening_tag:
		return action(None)
	
	# find closing tag
	if not closing_tag:
		ix = start_ix
		while ix < html_len:
			ch = html[ix]
			if ch == '<':
				check_str = html[ix:]
				m = re.match(start_tag, check_str)
				if m: # found opening tag
					tmp_tag = Tag(m, ix);
					if not tmp_tag.unary:
						forward_stack.append(tmp_tag)
				else:
					m = re.match(end_tag, check_str)
					if m:   #found closing tag
						tmp_tag = Tag(m, ix);
						if forward_stack and forward_stack[-1].name == tmp_tag.name:
							forward_stack.pop()
						else:  # found matched closing tag
							closing_tag = tmp_tag;
							break
					elif has_match('<!--'): # found comment
						ix += check_str.find('-->') + 3
						continue
			elif ch == '-' and has_match('-->'):
				# looks like cursor was inside comment with invalid HTML
				if not forward_stack or forward_stack[-1].type != 'comment':
					end_ix = ix + 3
					return action(Comment( find_comment_start(ix), end_ix ))
				
			ix += 1
	
	return action(opening_tag, closing_tag, start_ix)

########NEW FILE########
__FILENAME__ = plugin
# @file plugin.py
#
# Connect Zen Coding to Gedit.
#
# Author Franck Marcia (franck.marcia@gmail.com)
#

import gedit, gobject, gtk, os

from zen_editor import ZenEditor

zencoding_ui_str = """
<ui>
  <menubar name="MenuBar">
    <menu name="EditMenu" action="Edit">
      <placeholder name="EditOps_5">
        <menu action="ZenCodingMenuAction">
          <menuitem name="ZenCodingExpand"   action="ZenCodingExpandAction"/>
          <menuitem name="ZenCodingExpandW"  action="ZenCodingExpandWAction"/>
          <menuitem name="ZenCodingWrap"     action="ZenCodingWrapAction"/>
          <separator/>
          <menuitem name="ZenCodingInward"   action="ZenCodingInwardAction"/>
          <menuitem name="ZenCodingOutward"  action="ZenCodingOutwardAction"/>
          <menuitem name="ZenCodingMerge"    action="ZenCodingMergeAction"/>
          <separator/>
          <menuitem name="ZenCodingPrev"     action="ZenCodingPrevAction"/>
          <menuitem name="ZenCodingNext"     action="ZenCodingNextAction"/>
          <separator/>
          <menuitem name="ZenCodingRemove"   action="ZenCodingRemoveAction"/>
          <menuitem name="ZenCodingSplit"    action="ZenCodingSplitAction"/>
          <menuitem name="ZenCodingComment"  action="ZenCodingCommentAction"/>
        </menu>
      </placeholder>
    </menu>
  </menubar>
</ui>
"""

class ZenCodingPlugin(gedit.Plugin):
    """A Gedit plugin to implement Zen Coding's HTML and CSS shorthand expander."""

    def activate(self, window):
        actions = [
          ('ZenCodingMenuAction',     None, '_Zen Coding',                  None,            "Zen Coding tools",                            None),
          ('ZenCodingExpandAction',   None, '_Expand abbreviation',         '<Ctrl>E',        "Expand abbreviation to raw HTML/CSS",         self.expand_abbreviation),
          ('ZenCodingExpandWAction',  None, 'E_xpand dynamic abbreviation...', '<Ctrl><Alt>E',   "Dynamically expand abbreviation as you type",           self.expand_with_abbreviation),
          ('ZenCodingWrapAction',     None, '_Wrap with abbreviation...',   '<Ctrl><Shift>E', "Wrap with code expanded from abbreviation",   self.wrap_with_abbreviation),
          ('ZenCodingInwardAction',   None, 'Balance tag _inward',          '<Ctrl><Alt>I',   "Select inner tag's content",                  self.match_pair_inward),
          ('ZenCodingOutwardAction',  None, 'Balance tag _outward',         '<Ctrl><Alt>O',   "Select outer tag's content",                  self.match_pair_outward),
          ('ZenCodingMergeAction',    None, '_Merge lines',                 '<Ctrl><Alt>M',   "Merge all lines of the current selection",    self.merge_lines),
          ('ZenCodingPrevAction',     None, '_Previous edit point',         '<Alt>Left',      "Place the cursor at the previous edit point", self.prev_edit_point),
          ('ZenCodingNextAction',     None, '_Next edit point',             '<Alt>Right',     "Place the cursor at the next edit point",     self.next_edit_point),
          ('ZenCodingRemoveAction',   None, '_Remove tag',                  '<Ctrl><Alt>R',   "Remove a tag",                                self.remove_tag),
          ('ZenCodingSplitAction',    None, 'Split or _join tag',           '<Ctrl><Alt>J',   "Toggle between single and double tag",        self.split_join_tag),
          ('ZenCodingCommentAction',  None, 'Toggle _comment',              '<Ctrl><Alt>C',   "Toggle an XML or HTML comment",               self.toggle_comment)
        ]
        windowdata = dict()
        window.set_data("ZenCodingPluginDataKey", windowdata)
        windowdata["action_group"] = gtk.ActionGroup("GeditZenCodingPluginActions")
        windowdata["action_group"].add_actions(actions, window)
        manager = window.get_ui_manager()
        manager.insert_action_group(windowdata["action_group"], -1)
        windowdata["ui_id"] = manager.add_ui_from_string(zencoding_ui_str)
        window.set_data("ZenCodingPluginInfo", windowdata)
        self.editor = ZenEditor()
        error = self.editor.get_user_settings_error()
        if error:
            md = gtk.MessageDialog(window, gtk.DIALOG_MODAL, gtk.MESSAGE_ERROR,
                gtk.BUTTONS_CLOSE, "There is an error in user settings:")
            message = "{0} on line {1} at character {2}\n\nUser settings will not be available."
            md.set_title("Zen Coding error")
            md.format_secondary_text(message.format(error['msg'], error['lineno'], error['offset']))
            md.run()
            md.destroy()


    def deactivate(self, window):
        windowdata = window.get_data("ZenCodingPluginDataKey")
        manager = window.get_ui_manager()
        manager.remove_ui(windowdata["ui_id"])
        manager.remove_action_group(windowdata["action_group"])

    def update_ui(self, window):
        view = window.get_active_view()
        windowdata = window.get_data("ZenCodingPluginDataKey")
        windowdata["action_group"].set_sensitive(bool(view and view.get_editable()))

    def expand_abbreviation(self, action, window):
        self.editor.expand_abbreviation(window)
        
    def expand_with_abbreviation(self, action, window):
        self.editor.expand_with_abbreviation(window)

    def wrap_with_abbreviation(self, action, window):
        self.editor.wrap_with_abbreviation(window)

    def match_pair_inward(self, action, window):
        self.editor.match_pair_inward(window)

    def match_pair_outward(self, action, window):
        self.editor.match_pair_outward(window)

    def merge_lines(self, action, window):
        self.editor.merge_lines(window)

    def prev_edit_point(self, action, window):
        self.editor.prev_edit_point(window)

    def next_edit_point(self, action, window):
        self.editor.next_edit_point(window)

    def remove_tag(self, action, window):
        self.editor.remove_tag(window)

    def split_join_tag(self, action, window):
        self.editor.split_join_tag(window)

    def toggle_comment(self, action, window):
        self.editor.toggle_comment(window)

########NEW FILE########
__FILENAME__ = stparser
'''
Zen Coding's settings parser
Created on Jun 14, 2009

@author: Sergey Chikuyonok (http://chikuyonok.ru)
'''
from copy import deepcopy

import re
import types
from zen_settings import zen_settings

_original_settings = deepcopy(zen_settings)

TYPE_ABBREVIATION = 'zen-tag',
TYPE_EXPANDO = 'zen-expando',
TYPE_REFERENCE = 'zen-reference';
""" Reference to another abbreviation or tag """

re_tag = r'^<([\w\-]+(?:\:[\w\-]+)?)((?:\s+[\w\-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>\s]+))?)*)\s*(\/?)>'
"Regular expression for XML tag matching"
	
re_attrs = r'([\w\-]+)\s*=\s*([\'"])(.*?)\2'
"Regular expression for matching XML attributes"

class Entry:
	"""
	Unified object for parsed data
	"""
	def __init__(self, entry_type, key, value):
		"""
		@type entry_type: str
		@type key: str
		@type value: dict
		"""
		self.type = entry_type
		self.key = key
		self.value = value

def _make_expando(key, value):
	"""
	Make expando from string
	@type key: str
	@type value: str
	@return: Entry
	"""
	return Entry(TYPE_EXPANDO, key, value)

def _make_abbreviation(key, tag_name, attrs, is_empty=False):
	"""
	Make abbreviation from string
	@param key: Abbreviation key
	@type key: str
	@param tag_name: Expanded element's tag name
	@type tag_name: str
	@param attrs: Expanded element's attributes
	@type attrs: str
	@param is_empty: Is expanded element empty or not
	@type is_empty: bool
	@return: dict
	"""
	result = {
		'name': tag_name,
		'is_empty': is_empty
	};
	
	if attrs:
		result['attributes'] = [];
		for m in re.findall(re_attrs, attrs):
			result['attributes'].append({
				'name': m[0],
				'value': m[2]
			})
			
	return Entry(TYPE_ABBREVIATION, key, result)

def _parse_abbreviations(obj):
	"""
	Parses all abbreviations inside dictionary
 	@param obj: dict
	"""
	for key, value in obj.items():
		key = key.strip()
		if key[-1] == '+':
#			this is expando, leave 'value' as is
			obj[key] = _make_expando(key, value)
		else:
			m = re.search(re_tag, value)
			if m:
				obj[key] = _make_abbreviation(key, m.group(1), m.group(2), (m.group(3) == '/'))
			else:
#				assume it's reference to another abbreviation
				obj[key] = Entry(TYPE_REFERENCE, key, value)

def parse(settings):
	"""
	Parse user's settings. This function must be called *before* any activity
	in zen coding (for example, expanding abbreviation)
 	@type settings: dict
	"""
	for p, value in settings.items():
		if p == 'abbreviations':
			_parse_abbreviations(value)
		elif p == 'extends':
			settings[p] = [v.strip() for v in value.split(',')]
		elif type(value) == types.DictType:
			parse(value)


def extend(parent, child):
	"""
	Recursevly extends parent dictionary with children's keys. Used for merging
	default settings with user's
	@type parent: dict
	@type child: dict
	"""
	for p, value in child.items():
		if type(value) == types.DictType:
			if p not in parent:
				parent[p] = {}
			extend(parent[p], value)
		else:
			parent[p] = value
				


def create_maps(obj):
	"""
	Create hash maps on certain string properties of zen settings
	@type obj: dict
	"""
	for p, value in obj.items():
		if p == 'element_types':
			for k, v in value.items():
				if isinstance(v, str):
					value[k] = [el.strip() for el in v.split(',')]
		elif type(value) == types.DictType:
			create_maps(value)


if __name__ == '__main__':
	pass

def get_settings(user_settings=None):
	"""
	Main function that gather all settings and returns parsed dictionary
	@param user_settings: A dictionary of user-defined settings
	"""
	settings = deepcopy(_original_settings)
	create_maps(settings)
	
	if user_settings:
		user_settings = deepcopy(user_settings)
		create_maps(user_settings)
		extend(settings, user_settings)
	
	# now we need to parse final set of settings
	parse(settings)
	
	return settings
	

########NEW FILE########
__FILENAME__ = zen_actions
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Middleware layer that communicates between editor and Zen Coding.
This layer describes all available Zen Coding actions, like 
"Expand Abbreviation".
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
"""
from zencoding import zen_core as zen_coding
from zencoding import html_matcher
import re
from zen_core import char_at

def find_abbreviation(editor):
	"""
	Search for abbreviation in editor from current caret position
	@param editor: Editor instance
	@type editor: ZenEditor
	@return: str
	"""
	start, end = editor.get_selection_range()
	if start != end:
		# abbreviation is selected by user
		return editor.get_content()[start:end]
	
	# search for new abbreviation from current caret position
	cur_line_start, cur_line_end = editor.get_current_line_range()
	return zen_coding.extract_abbreviation(editor.get_content()[cur_line_start:start])

def expand_abbreviation(editor, syntax=None, profile_name=None):
	"""
	Find from current caret position and expand abbreviation in editor
	@param editor: Editor instance
	@type editor: ZenEditor
	@param syntax: Syntax type (html, css, etc.)
	@type syntax: str
	@param profile_name: Output profile name (html, xml, xhtml)
	@type profile_name: str
	@return: True if abbreviation was expanded successfully
	"""
	if syntax is None: syntax = editor.get_syntax()
	if profile_name is None: profile_name = editor.get_profile_name()
	
	range_start, caret_pos = editor.get_selection_range()
	abbr = find_abbreviation(editor)
	content = ''
		
	if abbr:
		content = zen_coding.expand_abbreviation(abbr, syntax, profile_name)
		if content:
			editor.replace_content(content, caret_pos - len(abbr), caret_pos)
			return True
	
	return False

def expand_abbreviation_with_tab(editor, syntax, profile_name='xhtml'):
	"""
	A special version of <code>expandAbbreviation</code> function: if it can't
	find abbreviation, it will place Tab character at caret position
	@param editor: Editor instance
	@type editor: ZenEditor
	@param syntax: Syntax type (html, css, etc.)
	@type syntax: str
	@param profile_name: Output profile name (html, xml, xhtml)
	@type profile_name: str
	"""
	if not expand_abbreviation(editor, syntax, profile_name):
		editor.replace_content(zen_coding.get_variable('indentation'), editor.get_caret_pos())
	
	return True 

def match_pair(editor, direction='out', syntax=None):
	"""
	Find and select HTML tag pair
	@param editor: Editor instance
	@type editor: ZenEditor
	@param direction: Direction of pair matching: 'in' or 'out'. 
	@type direction: str 
	"""
	direction = direction.lower()
	if syntax is None: syntax = editor.get_profile_name()
	
	range_start, range_end = editor.get_selection_range()
	cursor = range_end
	content = editor.get_content()
	rng = None
	
	old_open_tag = html_matcher.last_match['opening_tag']
	old_close_tag = html_matcher.last_match['closing_tag']
	
	if direction == 'in' and old_open_tag and range_start != range_end:
#		user has previously selected tag and wants to move inward
		if not old_close_tag:
#			unary tag was selected, can't move inward
			return False
		elif old_open_tag.start == range_start:
			if content[old_open_tag.end] == '<':
#				test if the first inward tag matches the entire parent tag's content
				_r = html_matcher.find(content, old_open_tag.end + 1, syntax)
				if _r[0] == old_open_tag.end and _r[1] == old_close_tag.start:
					rng = html_matcher.match(content, old_open_tag.end + 1, syntax)
				else:
					rng = (old_open_tag.end, old_close_tag.start)
			else:
				rng = (old_open_tag.end, old_close_tag.start)
		else:
			new_cursor = content[0:old_close_tag.start].find('<', old_open_tag.end)
			search_pos = new_cursor + 1 if new_cursor != -1 else old_open_tag.end
			rng = html_matcher.match(content, search_pos, syntax)
	else:
		rng = html_matcher.match(content, cursor, syntax)
	
	if rng and rng[0] is not None:
		editor.create_selection(rng[0], rng[1])
		return True
	else:
		return False

def match_pair_inward(editor):
	return match_pair(editor, 'in')
	
def match_pair_outward(editor):
	return match_pair(editor, 'out')

def narrow_to_non_space(text, start, end):
	"""
	Narrow down text indexes, adjusting selection to non-space characters
	@type text: str
	@type start: int
	@type end: int
	@return: list
	"""
	# narrow down selection until first non-space character
	while start < end:
		if not text[start].isspace():
			break
			
		start += 1
	
	while end > start:
		end -= 1
		if not text[end].isspace():
			end += 1
			break
		
	return start, end

def wrap_with_abbreviation(editor, abbr, syntax=None, profile_name=None):
	"""
	Wraps content with abbreviation
	@param editor: Editor instance
	@type editor: ZenEditor
	@param syntax: Syntax type (html, css, etc.)
	@type syntax: str
	@param profile_name: Output profile name (html, xml, xhtml)
	@type profile_name: str
	"""
	if not abbr: return None 
	
	if syntax is None: syntax = editor.get_syntax()
	if profile_name is None: profile_name = editor.get_profile_name()
	
	start_offset, end_offset = editor.get_selection_range()
	content = editor.get_content()
	
	if start_offset == end_offset:
		# no selection, find tag pair
		rng = html_matcher.match(content, start_offset, profile_name)
		
		if rng[0] is None: # nothing to wrap
			return None
		else:
			start_offset, end_offset = rng
			
	start_offset, end_offset = narrow_to_non_space(content, start_offset, end_offset)
	line_bounds = get_line_bounds(content, start_offset)
	padding = get_line_padding(content[line_bounds[0]:line_bounds[1]])
	
	new_content = content[start_offset:end_offset]
	result = zen_coding.wrap_with_abbreviation(abbr, unindent_text(new_content, padding), syntax, profile_name)
	
	if result:
		editor.replace_content(result, start_offset, end_offset)
		return True
	
	return False

def unindent(editor, text):
	"""
	Unindent content, thus preparing text for tag wrapping
	@param editor: Editor instance
	@type editor: ZenEditor
	@param text: str
	@return str
	"""
	return unindent_text(text, get_current_line_padding(editor))

def unindent_text(text, pad):
	"""
	Removes padding at the beginning of each text's line
	@type text: str
	@type pad: str
	"""
	lines = zen_coding.split_by_lines(text)
	
	for i,line in enumerate(lines):
		if line.startswith(pad):
			lines[i] = line[len(pad):]
	
	return zen_coding.get_newline().join(lines)

def get_current_line_padding(editor):
	"""
	Returns padding of current editor's line
	@return str
	"""
	return get_line_padding(editor.get_current_line())

def get_line_padding(line):
	"""
	Returns padding of current editor's line
	@return str
	"""
	m = re.match(r'^(\s+)', line)
	return m and m.group(0) or ''

def find_new_edit_point(editor, inc=1, offset=0):
	"""
	Search for new caret insertion point
	@param editor: Editor instance
	@type editor: ZenEditor
	@param inc: Search increment: -1  search left, 1  search right
	@param offset: Initial offset relative to current caret position
	@return: -1 if insertion point wasn't found
	"""
	cur_point = editor.get_caret_pos() + offset
	content = editor.get_content()
	max_len = len(content)
	next_point = -1
	re_empty_line = r'^\s+$'
	
	def get_line(ix):
		start = ix
		while start >= 0:
			c = content[start]
			if c == '\n' or c == '\r': break
			start -= 1
		
		return content[start:ix]
		
	while cur_point < max_len and cur_point > 0:
		cur_point += inc
		cur_char = char_at(content, cur_point)
		next_char = char_at(content, cur_point + 1)
		prev_char = char_at(content, cur_point - 1)
		
		if cur_char in '"\'':
			if next_char == cur_char and prev_char == '=':
				# empty attribute
				next_point = cur_point + 1
		elif cur_char == '>' and next_char == '<':
			# between tags
			next_point = cur_point + 1
		elif cur_char in '\r\n':
			# empty line
			if re.search(re_empty_line, get_line(cur_point - 1)):
				next_point = cur_point
		
		if next_point != -1: break
	
	return next_point

def prev_edit_point(editor):
	"""
	Move caret to previous edit point
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	cur_pos = editor.get_caret_pos()
	new_point = find_new_edit_point(editor, -1)
		
	if new_point == cur_pos:
		# we're still in the same point, try searching from the other place
		new_point = find_new_edit_point(editor, -1, -2)
	
	if new_point != -1:
		editor.set_caret_pos(new_point)
		return True
	
	return False

def next_edit_point(editor):
	"""
	Move caret to next edit point
	@param editor: Editor instance
	@type editor: ZenEditor
	""" 
	new_point = find_new_edit_point(editor, 1)
	if new_point != -1:
		editor.set_caret_pos(new_point)
		return True
	
	return False

def insert_formatted_newline(editor, mode='html'):
	"""
	Inserts newline character with proper indentation
	@param editor: Editor instance
	@type editor: ZenEditor
	@param mode: Syntax mode (only 'html' is implemented)
	@type mode: str
	"""
	caret_pos = editor.get_caret_pos()
	nl = zen_coding.get_newline()
	pad = zen_coding.get_variable('indentation')
		
	if mode == 'html':
		# let's see if we're breaking newly created tag
		pair = html_matcher.get_tags(editor.get_content(), editor.get_caret_pos(), editor.get_profile_name())
		
		if pair[0] and pair[1] and pair[0]['type'] == 'tag' and pair[0]['end'] == caret_pos and pair[1]['start'] == caret_pos:
			editor.replace_content(nl + pad + zen_coding.get_caret_placeholder() + nl, caret_pos)
		else:
			editor.replace_content(nl, caret_pos)
	else:
		editor.replace_content(nl, caret_pos)
		
	return True

def select_line(editor):
	"""
	Select line under cursor
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	start, end = editor.get_current_line_range();
	editor.create_selection(start, end)
	return True

def go_to_matching_pair(editor):
	"""
	Moves caret to matching opening or closing tag
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	content = editor.get_content()
	caret_pos = editor.get_caret_pos()
	
	if content[caret_pos] == '<': 
		# looks like caret is outside of tag pair  
		caret_pos += 1
		
	tags = html_matcher.get_tags(content, caret_pos, editor.get_profile_name())
		
	if tags and tags[0]:
		# match found
		open_tag, close_tag = tags
			
		if close_tag: # exclude unary tags
			if open_tag['start'] <= caret_pos and open_tag['end'] >= caret_pos:
				editor.set_caret_pos(close_tag['start'])
			elif close_tag['start'] <= caret_pos and close_tag['end'] >= caret_pos:
				editor.set_caret_pos(open_tag['start'])
				
		return True
	
	return False
				

def merge_lines(editor):
	"""
	Merge lines spanned by user selection. If there's no selection, tries to find
	matching tags and use them as selection
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	start, end = editor.get_selection_range()
	if start == end:
		# find matching tag
		pair = html_matcher.match(editor.get_content(), editor.get_caret_pos(), editor.get_profile_name())
		if pair and pair[0] is not None:
			start, end = pair
	
	if start != end:
		# got range, merge lines
		text = editor.get_content()[start:end]
		lines = map(lambda s: re.sub(r'^\s+', '', s), zen_coding.split_by_lines(text))
		text = re.sub(r'\s{2,}', ' ', ''.join(lines))
		editor.replace_content(text, start, end)
		editor.create_selection(start, start + len(text))
		return True
	
	return False

def toggle_comment(editor):
	"""
	Toggle comment on current editor's selection or HTML tag/CSS rule
	@type editor: ZenEditor
	"""
	syntax = editor.get_syntax()
	if syntax in ['css', 'sass']:
		return toggle_css_comment(editor)
	else:
		return toggle_html_comment(editor)

def toggle_html_comment(editor):
	"""
	Toggle HTML comment on current selection or tag
	@type editor: ZenEditor
	@return: True if comment was toggled
	"""
	start, end = editor.get_selection_range()
	content = editor.get_content()
		
	if start == end:
		# no selection, find matching tag
		pair = html_matcher.get_tags(content, editor.get_caret_pos(), editor.get_profile_name())
		if pair and pair[0]: # found pair
			start = pair[0].start
			end = pair[1] and pair[1].end or pair[0].end
	
	return generic_comment_toggle(editor, '<!--', '-->', start, end)

def toggle_css_comment(editor):
	"""
	Simple CSS commenting
	@type editor: ZenEditor
	@return: True if comment was toggled
	"""
	start, end = editor.get_selection_range()
	
	if start == end:
		# no selection, get current line
		start, end = editor.get_current_line_range()

		# adjust start index till first non-space character
		start, end = narrow_to_non_space(editor.get_content(), start, end)
	
	return generic_comment_toggle(editor, '/*', '*/', start, end)

def search_comment(text, pos, start_token, end_token):
	"""
	Search for nearest comment in <code>str</code>, starting from index <code>from</code>
	@param text: Where to search
	@type text: str
	@param pos: Search start index
	@type pos: int
	@param start_token: Comment start string
	@type start_token: str
	@param end_token: Comment end string
	@type end_token: str
	@return: None if comment wasn't found, list otherwise
	"""
	start_ch = start_token[0]
	end_ch = end_token[0]
	comment_start = -1
	comment_end = -1
	
	def has_match(tx, start):
		return text[start:start + len(tx)] == tx
	
		
	# search for comment start
	while pos:
		pos -= 1
		if text[pos] == start_ch and has_match(start_token, pos):
			comment_start = pos
			break
	
	if comment_start != -1:
		# search for comment end
		pos = comment_start
		content_len = len(text)
		while content_len >= pos:
			pos += 1
			if text[pos] == end_ch and has_match(end_token, pos):
				comment_end = pos + len(end_token)
				break
	
	if comment_start != -1 and comment_end != -1:
		return comment_start, comment_end
	else:
		return None

def generic_comment_toggle(editor, comment_start, comment_end, range_start, range_end):
	"""
	Generic comment toggling routine
	@type editor: ZenEditor
	@param comment_start: Comment start token
	@type comment_start: str
	@param comment_end: Comment end token
	@type comment_end: str
	@param range_start: Start selection range
	@type range_start: int
	@param range_end: End selection range
	@type range_end: int
	@return: bool
	"""
	content = editor.get_content()
	caret_pos = [editor.get_caret_pos()]
	new_content = None
		
	def adjust_caret_pos(m):
		caret_pos[0] -= len(m.group(0))
		return ''
		
	def remove_comment(text):
		"""
		Remove comment markers from string
		@param {Sting} str
		@return {String}
		"""
		text = re.sub(r'^' + re.escape(comment_start) + r'\s*', adjust_caret_pos, text)
		return re.sub(r'\s*' + re.escape(comment_end) + '$', '', text)
	
	def has_match(tx, start):
		return content[start:start + len(tx)] == tx
	
	# first, we need to make sure that this substring is not inside comment
	comment_range = search_comment(content, caret_pos[0], comment_start, comment_end)
	
	if comment_range and comment_range[0] <= range_start and comment_range[1] >= range_end:
		# we're inside comment, remove it
		range_start, range_end = comment_range
		new_content = remove_comment(content[range_start:range_end])
	else:
		# should add comment
		# make sure that there's no comment inside selection
		new_content = '%s %s %s' % (comment_start, re.sub(re.escape(comment_start) + r'\s*|\s*' + re.escape(comment_end), '', content[range_start:range_end]), comment_end)
			
		# adjust caret position
		caret_pos[0] += len(comment_start) + 1

	# replace editor content
	if new_content is not None:
		d = caret_pos[0] - range_start
		new_content = new_content[0:d] + zen_coding.get_caret_placeholder() + new_content[d:]
		editor.replace_content(unindent(editor, new_content), range_start, range_end)
		return True
	
	return False

def split_join_tag(editor, profile_name=None):
	"""
	Splits or joins tag, e.g. transforms it into a short notation and vice versa:
	<div></div>  <div /> : join
	<div />  <div></div> : split
	@param editor: Editor instance
	@type editor: ZenEditor
	@param profile_name: Profile name
	@type profile_name: str
	"""
	caret_pos = editor.get_caret_pos()
	profile = zen_coding.get_profile(profile_name or editor.get_profile_name())
	caret = zen_coding.get_caret_placeholder()

	# find tag at current position
	pair = html_matcher.get_tags(editor.get_content(), caret_pos, profile_name or editor.get_profile_name())
	if pair and pair[0]:
		new_content = pair[0].full_tag
		
		if pair[1]: # join tag
			closing_slash = ''
			if profile['self_closing_tag'] is True:
				closing_slash = '/'
			elif profile['self_closing_tag'] == 'xhtml':
				closing_slash = ' /'
				
			new_content = re.sub(r'\s*>$', closing_slash + '>', new_content)
			
			# add caret placeholder
			if len(new_content) + pair[0].start < caret_pos:
				new_content += caret
			else:
				d = caret_pos - pair[0].start
				new_content = new_content[0:d] + caret + new_content[d:]
			
			editor.replace_content(new_content, pair[0].start, pair[1].end)
		else: # split tag
			nl = zen_coding.get_newline()
			pad = zen_coding.get_variable('indentation')
			
			# define tag content depending on profile
			tag_content = profile['tag_nl'] is True and nl + pad + caret + nl or caret
			
			new_content = '%s%s</%s>' % (re.sub(r'\s*\/>$', '>', new_content), tag_content, pair[0].name)
			editor.replace_content(new_content, pair[0].start, pair[0].end)
		
		return True
	else:
		return False
	

def get_line_bounds(text, pos):
	"""
	Returns line bounds for specific character position
	@type text: str
	@param pos: Where to start searching
	@type pos: int
	@return: list
	"""
	start = 0
	end = len(text) - 1
	
	# search left
	for i in range(pos - 1, 0, -1):
		if text[i] in '\n\r':
			start = i + 1
			break
		
	# search right
	for i in range(pos, len(text)):
		if text[i] in '\n\r':
			end = i
			break
		
	return start, end

def remove_tag(editor):
	"""
	Gracefully removes tag under cursor
	@type editor: ZenEditor
	"""
	caret_pos = editor.get_caret_pos()
	content = editor.get_content()
		
	# search for tag
	pair = html_matcher.get_tags(content, caret_pos, editor.get_profile_name())
	if pair and pair[0]:
		if not pair[1]:
			# simply remove unary tag
			editor.replace_content(zen_coding.get_caret_placeholder(), pair[0].start, pair[0].end)
		else:
			tag_content_range = narrow_to_non_space(content, pair[0].end, pair[1].start)
			start_line_bounds = get_line_bounds(content, tag_content_range[0])
			start_line_pad = get_line_padding(content[start_line_bounds[0]:start_line_bounds[1]])
			tag_content = content[tag_content_range[0]:tag_content_range[1]]
				
			tag_content = unindent_text(tag_content, start_line_pad)
			editor.replace_content(zen_coding.get_caret_placeholder() + tag_content, pair[0].start, pair[1].end)
		
		return True
	else:
		return False

########NEW FILE########
__FILENAME__ = zen_core
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Core Zen Coding library. Contains various text manipulation functions:

== Expand abbreviation
Expands abbreviation like ul#nav>li*5>a into a XHTML string.
=== How to use
First, you have to extract current string (where cursor is) from your test 
editor and use <code>find_abbr_in_line()</code> method to extract abbreviation. 
If abbreviation was found, this method will return it as well as position index
of abbreviation inside current line. If abbreviation wasn't 
found, method returns empty string. With abbreviation found, you should call
<code>parse_into_tree()</code> method to transform abbreviation into a tag tree. 
This method returns <code>Tag</code> object on success, None on failure. Then
simply call <code>to_string()</code> method of returned <code>Tag</code> object
to transoform tree into a XHTML string

You can setup output profile using <code>setup_profile()</code> method 
(see <code>default_profile</code> definition for available options) 

 
Created on Apr 17, 2009

@author: Sergey Chikuyonok (http://chikuyonok.ru)
'''
from zen_settings import zen_settings
import re
import stparser

newline = '\n'
"Newline symbol"

caret_placeholder = '{%::zen-caret::%}'

default_tag = 'div'

re_tag = re.compile(r'<\/?[\w:\-]+(?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>\s]+))?)*\s*(\/?)>$')

profiles = {}
"Available output profiles"

default_profile = {
	'tag_case': 'lower',         # values are 'lower', 'upper'
	'attr_case': 'lower',        # values are 'lower', 'upper'
	'attr_quotes': 'double',     # values are 'single', 'double'
	
	'tag_nl': 'decide',          # each tag on new line, values are True, False, 'decide'
	
	'place_cursor': True,        # place cursor char  | (pipe)  in output
	
	'indent': True,              # indent tags
	
	'inline_break': 3,           # how many inline elements should be to force line break (set to 0 to disable)
	
	'self_closing_tag': 'xhtml'  # use self-closing style for writing empty elements, e.g. <br /> or <br>. 
                                 # values are True, False, 'xhtml'
}

basic_filters = 'html';
"Filters that will be applied for unknown syntax"

max_tabstop = 0
"Maximum tabstop index for current session"

def char_at(text, pos):
	"""
	Returns character at specified index of text.
	If index if out of range, returns empty string
	"""
	return text[pos] if pos < len(text) else ''

def has_deep_key(obj, key):
	"""
	Check if <code>obj</code> dictionary contains deep key. For example,
	example, it will allow you to test existance of my_dict[key1][key2][key3],
	testing existance of my_dict[key1] first, then my_dict[key1][key2], 
	and finally my_dict[key1][key2][key3]
	@param obj: Dictionary to test
	@param obj: dict
	@param key: Deep key to test. Can be list (like ['key1', 'key2', 'key3']) or
	string (like 'key1.key2.key3')
	@type key: list, tuple, str
	@return: bool
	"""
	if isinstance(key, str):
		key = key.split('.')
		
	last_obj = obj
	for v in key:
		if hasattr(last_obj, v):
			last_obj = getattr(last_obj, v)
		elif last_obj.has_key(v):
			last_obj = last_obj[v]
		else:
			return False
	
	return True
		

def is_allowed_char(ch):
	"""
	Test if passed symbol is allowed in abbreviation
	@param ch: Symbol to test
	@type ch: str
	@return: bool
	"""
	return ch.isalnum() or ch in "#.>+*:$-_!@[]()|"

def split_by_lines(text, remove_empty=False):
	"""
	Split text into lines. Set <code>remove_empty</code> to true to filter out
	empty lines
	@param text: str
	@param remove_empty: bool
	@return list
	"""
	lines = text.splitlines()
	
	return remove_empty and [line for line in lines if line.strip()] or lines

def make_map(prop):
	"""
	Helper function that transforms string into dictionary for faster search
	@param prop: Key name in <code>zen_settings['html']</code> dictionary
	@type prop: str
	"""
	obj = {}
	for a in zen_settings['html'][prop].split(','):
		obj[a] = True
		
	zen_settings['html'][prop] = obj

def create_profile(options):
	"""
	Create profile by adding default values for passed optoin set
	@param options: Profile options
	@type options: dict
	"""
	for k, v in default_profile.items():
		options.setdefault(k, v)
	
	return options

def setup_profile(name, options = {}):
	"""
	@param name: Profile name
	@type name: str
	@param options: Profile options
	@type options: dict
	"""
	profiles[name.lower()] = create_profile(options);

def get_newline():
	"""
	Returns newline symbol which is used in editor. This function must be 
	redefined to return current editor's settings 
	@return: str
	"""
	return newline

def set_newline(char):
	"""
	Sets newline character used in Zen Coding
	"""
	global newline
	newline = char

def string_to_hash(text):
	"""
	Helper function that transforms string into hash
	@return: dict
	"""
	obj = {}
	items = text.split(",")
	for i in items:
		obj[i] = True
		
	return obj

def pad_string(text, pad):
	"""
	Indents string with space characters (whitespace or tab)
	@param text: Text to indent
	@type text: str
	@param pad: Indentation level (number) or indentation itself (string)
	@type pad: int, str
	@return: str
	"""
	pad_str = ''
	result = ''
	if isinstance(pad, basestring):
		pad_str = pad
	else:
		pad_str = get_indentation() * pad
		
	nl = get_newline()
	
	lines = split_by_lines(text)
	
	if lines:
		result += lines[0]
		for line in lines[1:]:
			result += nl + pad_str + line
			
	return result

def is_snippet(abbr, doc_type = 'html'):
	"""
	Check is passed abbreviation is a snippet
	@return bool
	"""
	return get_snippet(doc_type, abbr) and True or False

def is_ends_with_tag(text):
	"""
	Test is string ends with XHTML tag. This function used for testing if '<'
	symbol belogs to tag or abbreviation 
	@type text: str
	@return: bool
	"""
	return re_tag.search(text) != None

def get_elements_collection(resource, type):
	"""
	Returns specified elements collection (like 'empty', 'block_level') from
	<code>resource</code>. If collections wasn't found, returns empty object
	@type resource: dict
	@type type: str
	@return: dict
	"""
	if 'element_types' in resource and type in resource['element_types']:
		return resource['element_types'][type]
	else:
		return {}
	
def replace_variables(text):
	"""
	Replace variables like ${var} in string
	@param text: str
	@return: str
	"""
	return re.sub(r'\$\{([\w\-]+)\}', lambda m: get_variable(m.group(1)) or m.group(0), text)

def get_abbreviation(res_type, abbr):
	"""
	Returns abbreviation value from data set
	@param res_type: Resource type (html, css, ...)
	@type res_type: str
	@param abbr: Abbreviation name
	@type abbr: str
	@return dict, None
	"""
	return get_settings_resource(res_type, abbr, 'abbreviations')

def get_snippet(res_type, snippet_name):
	"""
	Returns snippet value from data set
	@param res_type: Resource type (html, css, ...)
	@type res_type: str
	@param snippet_name: Snippet name
	@type snippet_name: str
	@return dict, None
	"""
	return get_settings_resource(res_type, snippet_name, 'snippets');

def get_variable(name):
	"""
	Returns variable value
	 @return: str
	"""
	if name in zen_settings['variables']:
		return zen_settings['variables'][name]
	return None

def set_variable(name, value):
	"""
	Set variable value
	"""
	zen_settings['variables'][name] = value

def get_indentation():
	"""
	Returns indentation string
	@return {String}
	"""
	return get_variable('indentation');

def create_resource_chain(syntax, name):
	"""
	Creates resource inheritance chain for lookups
	@param syntax: Syntax name
	@type syntax: str
	@param name: Resource name
	@type name: str
	@return: list
	"""
	result = []
	
	if syntax in zen_settings:
		resource = zen_settings[syntax]
		if name in resource:
			result.append(resource[name])
		if 'extends' in resource:
			# find resource in ancestors
			for type in resource['extends']:
				if  has_deep_key(zen_settings, [type, name]):
					result.append(zen_settings[type][name])
				
	return result

def get_resource(syntax, name):
	"""
	Get resource collection from settings file for specified syntax. 
	It follows inheritance chain if resource wasn't directly found in
	syntax settings
	@param syntax: Syntax name
	@type syntax: str
	@param name: Resource name
	@type name: str
	"""
	chain = create_resource_chain(syntax, name)
	return chain[0] if chain else None

def get_settings_resource(syntax, abbr, name):
	"""
	Returns resurce value from data set with respect of inheritance
	@param syntax: Resource syntax (html, css, ...)
	@type syntax: str
	@param abbr: Abbreviation name
	@type abbr: str
	@param name: Resource name ('snippets' or 'abbreviation')
	@type name: str
	@return dict, None
	"""
	for item in create_resource_chain(syntax, name):
		if abbr in item:
			return item[abbr]
		
	return None

def get_word(ix, text):
	"""
	Get word, starting at <code>ix</code> character of <code>text</code>
	@param ix: int
	@param text: str
	"""
	m = re.match(r'^[\w\-:\$]+', text[ix:])
	return m.group(0) if m else ''
	
def extract_attributes(attr_set):
	"""
	Extract attributes and their values from attribute set 
 	@param attr_set: str
	"""
	attr_set = attr_set.strip()
	loop_count = 100 # endless loop protection
	re_string = r'^(["\'])((?:(?!\1)[^\\]|\\.)*)\1'
	result = []
		
	while attr_set and loop_count:
		loop_count -= 1
		attr_name = get_word(0, attr_set)
		attr = None
		if attr_name:
			attr = {'name': attr_name, 'value': ''}
			
			# let's see if attribute has value
			ch = attr_set[len(attr_name)] if len(attr_set) > len(attr_name) else ''
			if ch == '=':
				ch2 = attr_set[len(attr_name) + 1]
				if ch2 in '"\'':
					# we have a quoted string
					m = re.match(re_string, attr_set[len(attr_name) + 1:])
					if m:
						attr['value'] = m.group(2)
						attr_set = attr_set[len(attr_name) + len(m.group(0)) + 1:].strip()
					else:
						# something wrong, break loop
						attr_set = ''
				else:
					# unquoted string
					m = re.match(r'^(.+?)(\s|$)', attr_set[len(attr_name) + 1:])
					if m:
						attr['value'] = m.group(1)
						attr_set = attr_set[len(attr_name) + len(m.group(1)) + 1:].strip()
					else:
						# something wrong, break loop
						attr_set = ''
				
			else:
				attr_set = attr_set[len(attr_name):].strip()
		else:
			# something wrong, can't extract attribute name
			break
		
		if attr: result.append(attr)
		
	return result

def parse_attributes(text):
	"""
	Parses tag attributes extracted from abbreviation
	"""
	
#	Example of incoming data:
#	#header
#	.some.data
#	.some.data#header
#	[attr]
#	#item[attr=Hello other="World"].class

	result = []
	class_name = None
	char_map = {'#': 'id', '.': 'class'}
	
	# walk char-by-char
	i = 0
	il = len(text)
		
	while i < il:
		ch = text[i]
		
		if ch == '#': # id
			val = get_word(i, text[1:])
			result.append({'name': char_map[ch], 'value': val})
			i += len(val) + 1
			
		elif ch == '.': #class
			val = get_word(i, text[1:])
			if not class_name:
				# remember object pointer for value modification
				class_name = {'name': char_map[ch], 'value': ''}
				result.append(class_name)
			
			if class_name['value']:
				class_name['value'] += ' ' + val
			else:
				class_name['value'] = val
			
			i += len(val) + 1
				
		elif ch == '[': # begin attribute set
			# search for end of set
			end_ix = text.find(']', i)
			if end_ix == -1:
				# invalid attribute set, stop searching
				i = len(text)
			else:
				result.extend(extract_attributes(text[i + 1:end_ix]))
				i = end_ix
		else:
			i += 1
		
		
	return result

class AbbrGroup(object):
	"""
	Abreviation's group element
	"""
	def __init__(self, parent=None):
		"""
		@param parent: Parent group item element
		@type parent: AbbrGroup
		"""
		self.expr = ''
		self.parent = parent
		self.children = []
		
	def add_child(self):
		child = AbbrGroup(self)
		self.children.append(child)
		return child
	
	def clean_up(self):
		for item in self.children:
			expr = item.expr
			if not expr:
				self.children.remove(item)
			else:
				# remove operators at the and of expression
				item.clean_up()

def split_by_groups(abbr):
	"""
	Split abbreviation by groups
	@type abbr: str
	@return: AbbrGroup
	"""
	root = AbbrGroup()
	last_parent = root
	cur_item = root.add_child()
	stack = []
	i = 0
	il = len(abbr)
	
	while i < il:
		ch = abbr[i]
		if ch == '(':
			# found new group
			operator = i and abbr[i - 1] or ''
			if operator == '>':
				stack.append(cur_item)
				last_parent = cur_item
			else:
				stack.append(last_parent)
			cur_item = None
		elif ch == ')':
			last_parent = stack.pop()
			cur_item = None
			next_char = char_at(abbr, i + 1)
			if next_char == '+' or next_char == '>': 
				# next char is group operator, skip it
				i += 1
		else:
			if ch == '+' or ch == '>':
				# skip operator if it's followed by parenthesis
				next_char = char_at(abbr, i + 1)
				if next_char == '(':
					i += 1 
					continue
			
			if not cur_item:
				cur_item = last_parent.add_child()
			cur_item.expr += ch
			
		i += 1
	
	root.clean_up()
	return root

def rollout_tree(tree, parent=None):
	"""
	Roll outs basic Zen Coding tree into simplified, DOM-like tree.
	The simplified tree, for example, represents each multiplied element 
	as a separate element sets with its own content, if exists.
	 
	The simplified tree element contains some meta info (tag name, attributes, 
	etc.) as well as output strings, which are exactly what will be outputted
	after expanding abbreviation. This tree is used for <i>filtering</i>:
	you can apply filters that will alter output strings to get desired look
	of expanded abbreviation.
	 
	@type tree: Tag
	@param parent: ZenNode
	"""
	if not parent:
		parent = ZenNode(tree)
		
	how_many = 1
	tag_content = ''
	
	for child in tree.children:
		how_many = child.count
		
		if child.repeat_by_lines:
			# it's a repeating element
			tag_content = split_by_lines(child.get_content(), True)
			how_many = max(len(tag_content), 1)
		else:
			tag_content = child.get_content()
		
		for j in range(how_many):
			tag = ZenNode(child)
			parent.add_child(tag)
			tag.counter = j + 1
			
			if child.children:
				rollout_tree(child, tag)
				
			add_point = tag.find_deepest_child() or tag
			
			if tag_content:
				if isinstance(tag_content, basestring):
					add_point.content = tag_content
				else:
					add_point.content = tag_content[j] or ''
					
	return parent

def run_filters(tree, profile, filter_list):
	"""
	Runs filters on tree
	@type tree: ZenNode
	@param profile: str, object
	@param filter_list: str, list
	@return: ZenNode
	"""
	import filters
	
	if isinstance(profile, basestring) and profile in profiles:
		profile = profiles[profile];
	
	if not profile:
		profile = profiles['plain']
		
	if isinstance(filter_list, basestring):
		filter_list = re.split(r'[\|,]', filter_list)
		
	for name in filter_list:
		name = name.strip()
		if name and name in filters.filter_map:
			tree = filters.filter_map[name](tree, profile)
			
	return tree

def abbr_to_primary_tree(abbr, doc_type='html'):
	"""
	Transforms abbreviation into a primary internal tree. This tree should'n 
	be used ouside of this scope
	@param abbr: Abbreviation to transform
	@type abbr: str
	@param doc_type: Document type (xsl, html), a key of dictionary where to
	search abbreviation settings
	@type doc_type: str
	@return: Tag
	"""
	root = Tag('', 1, doc_type)
	token = re.compile(r'([\+>])?([a-z@\!\#\.][\w:\-]*)((?:(?:[#\.][\w\-\$]+)|(?:\[[^\]]+\]))+)?(\*(\d*))?(\+$)?', re.IGNORECASE)
	
	if not abbr:
		return None
	
	def expando_replace(m):
		ex = m.group(0)
		a = get_abbreviation(doc_type, ex)
		return a and a.value or ex
		
	def token_expander(operator, tag_name, attrs, has_multiplier, multiplier, has_expando):
		multiply_by_lines = (has_multiplier and not multiplier)
		multiplier = multiplier and int(multiplier) or 1
		
		tag_ch = tag_name[0]
		if tag_ch == '#' or tag_ch == '.':
			if attrs: attrs = tag_name + attrs
			else: attrs = tag_name
			tag_name = default_tag
		
		if has_expando:
			tag_name += '+'
		
		current = is_snippet(tag_name, doc_type) and Snippet(tag_name, multiplier, doc_type) or Tag(tag_name, multiplier, doc_type)
		
		if attrs:
			attrs = parse_attributes(attrs)
			for attr in attrs:
				current.add_attribute(attr['name'], attr['value'])
			
		# dive into tree
		if operator == '>' and token_expander.last:
			token_expander.parent = token_expander.last;
			
		token_expander.parent.add_child(current)
		token_expander.last = current
		
		if multiply_by_lines:
			root.multiply_elem = current
		
		return ''
		
	# replace expandos
	abbr = re.sub(r'([a-z][a-z0-9]*)\+$', expando_replace, abbr)
	
	token_expander.parent = root
	token_expander.last = None
	
	
#	abbr = re.sub(token, lambda m: token_expander(m.group(1), m.group(2), m.group(3), m.group(4), m.group(5), m.group(6), m.group(7)), abbr)
	# Issue from Einar Egilsson
	abbr = token.sub(lambda m: token_expander(m.group(1), m.group(2), m.group(3), m.group(4), m.group(5), m.group(6)), abbr)
	
	root.last = token_expander.last
	
	# empty 'abbr' variable means that abbreviation was expanded successfully, 
	# non-empty variable means there was a syntax error
	return not abbr and root or None;

def expand_group(group, doc_type, parent):
	"""
	Expand single group item 
	@param group: AbbrGroup
	@param doc_type: str
	@param parent: Tag
	"""
	tree = abbr_to_primary_tree(group.expr, doc_type)
	last_item = None
		
	if tree:
		for item in tree.children:
			last_item = item
			parent.add_child(last_item)
	else:
		raise Exception('InvalidGroup')
	
	
	# set repeating element to the topmost node
	root = parent
	while root.parent:
		root = root.parent
	
	root.last = tree.last
	if tree.multiply_elem:
		root.multiply_elem = tree.multiply_elem
		
	# process child groups
	if group.children:
		add_point = last_item.find_deepest_child() or last_item
		for child in group.children:
			expand_group(child, doc_type, add_point)

def replace_unescaped_symbol(text, symbol, replace):
	"""
	Replaces unescaped symbols in <code>text</code>. For example, the '$' symbol
	will be replaced in 'item$count', but not in 'item\$count'.
	@param text: Original string
	@type text: str
	@param symbol: Symbol to replace
	@type symbol: st
	@param replace: Symbol replacement
	@type replace: str, function 
	@return: str
	"""
	i = 0
	il = len(text)
	sl = len(symbol)
	match_count = 0
		
	while i < il:
		if text[i] == '\\':
			# escaped symbol, skip next character
			i += sl + 1
		elif text[i:i + sl] == symbol:
			# have match
			cur_sl = sl
			match_count += 1
			new_value = replace
			if callable(new_value):
				replace_data = replace(text, symbol, i, match_count)
				if replace_data:
					cur_sl = len(replace_data[0])
					new_value = replace_data[1]
				else:
					new_value = False
			
			if new_value is False: # skip replacement
				i += 1
				continue
			
			text = text[0:i] + new_value + text[i + cur_sl:]
			# adjust indexes
			il = len(text)
			i += len(new_value)
		else:
			i += 1
	
	return text
	
def run_action(name, *args, **kwargs):
	"""
	 Runs Zen Coding action. For list of available actions and their
	 arguments see zen_actions.py file.
	 @param name: Action name 
	 @type name: str 
	 @param args: Additional arguments. It may be array of arguments
	 or inline arguments. The first argument should be <code>zen_editor</code> instance
	 @type args: list
	 @example
	 zen_coding.run_actions('expand_abbreviation', zen_editor)
	 zen_coding.run_actions('wrap_with_abbreviation', zen_editor, 'div')  
	"""
	import zen_actions
	
	try:
		if hasattr(zen_actions, name):
			return getattr(zen_actions, name)(*args, **kwargs)
	except:
		return False

def expand_abbreviation(abbr, syntax='html', profile_name='plain'):
	"""
	Expands abbreviation into a XHTML tag string
	@type abbr: str
	@return: str
	"""
	tree_root = parse_into_tree(abbr, syntax);
	if tree_root:
		tree = rollout_tree(tree_root)
		apply_filters(tree, syntax, profile_name, tree_root.filters)
		return replace_variables(tree.to_string())
	
	return ''

def extract_abbreviation(text):
	"""
	Extracts abbreviations from text stream, starting from the end
	@type text: str
	@return: Abbreviation or empty string
	"""
	cur_offset = len(text)
	start_index = -1
	brace_count = 0
	
	while True:
		cur_offset -= 1
		if cur_offset < 0:
			# moved at string start
			start_index = 0
			break
		
		ch = text[cur_offset]
		
		if ch == ']':
			brace_count += 1
		elif ch == '[':
			brace_count -= 1
		else:
			if brace_count: 
				# respect all characters inside attribute sets
				continue
			if not is_allowed_char(ch) or (ch == '>' and is_ends_with_tag(text[0:cur_offset + 1])):
				# found stop symbol
				start_index = cur_offset + 1
				break
		
	return text[start_index:] if start_index != -1 else ''

def parse_into_tree(abbr, doc_type='html'):
	"""
	Parses abbreviation into a node set
	@param abbr: Abbreviation to transform
	@type abbr: str
	@param doc_type: Document type (xsl, html), a key of dictionary where to
	search abbreviation settings
	@type doc_type: str
	@return: Tag
	"""
	# remove filters from abbreviation
	filter_list = []
	
	def filter_replace(m):
		filter_list.append(m.group(1))
		return ''
	
	re_filter = re.compile(r'\|([\w\|\-]+)$')
	abbr = re_filter.sub(filter_replace, abbr)
	
	# split abbreviation by groups
	group_root = split_by_groups(abbr)
	tree_root = Tag('', 1, doc_type)
	
	# then recursively expand each group item
	try:
		for item in group_root.children:
			expand_group(item, doc_type, tree_root)
	except:
		# there's invalid group, stop parsing
		return None
	
	tree_root.filters = ''.join(filter_list)
	return tree_root

def is_inside_tag(html, cursor_pos):
	re_tag = re.compile(r'^<\/?\w[\w\:\-]*.*?>')
	
	# search left to find opening brace
	pos = cursor_pos
	while pos > -1:
		if html[pos] == '<': break
		pos -= 1
	
	
	if pos != -1:
		m = re_tag.match(html[pos:]);
		if m and cursor_pos > pos and cursor_pos < pos + len(m.group(0)):
			return True

	return False

def wrap_with_abbreviation(abbr, text, doc_type='html', profile='plain'):
	"""
	Wraps passed text with abbreviation. Text will be placed inside last
	expanded element
	@param abbr: Abbreviation
	@type abbr: str
	
	@param text: Text to wrap
	@type text: str
	
	@param doc_type: Document type (html, xml, etc.)
	@type doc_type: str
	
	@param profile: Output profile's name.
	@type profile: str
	@return {String}
	"""
	tree_root = parse_into_tree(abbr, doc_type)
	if tree_root:
		repeat_elem = tree_root.multiply_elem or tree_root.last
		repeat_elem.set_content(text)
		repeat_elem.repeat_by_lines = bool(tree_root.multiply_elem)
		
		tree = rollout_tree(tree_root)
		apply_filters(tree, doc_type, profile, tree_root.filters);
		return replace_variables(tree.to_string())
	
	return None

def get_caret_placeholder():
	"""
	Returns caret placeholder
	@return: str
	"""
	if callable(caret_placeholder):
		return caret_placeholder()
	else:
		return caret_placeholder

def set_caret_placeholder(value):
	"""
	Set caret placeholder: a string (like '|') or function.
	You may use a function as a placeholder generator. For example,
	TextMate uses ${0}, ${1}, ..., ${n} natively for quick Tab-switching
	between them.
	@param {String|Function}
	"""
	global caret_placeholder
	caret_placeholder = value

def apply_filters(tree, syntax, profile, additional_filters=None):
	"""
	Applies filters to tree according to syntax
	@param tree: Tag tree to apply filters to
	@type tree: ZenNode
	@param syntax: Syntax name ('html', 'css', etc.)
	@type syntax: str
	@param profile: Profile or profile's name
	@type profile: str, object
	@param additional_filters: List or pipe-separated string of additional filters to apply
	@type additional_filters: str, list 
	 
	@return: ZenNode
	"""
	_filters = get_resource(syntax, 'filters') or basic_filters
		
	if additional_filters:
		_filters += '|'
		if isinstance(additional_filters, basestring):
			_filters += additional_filters
		else:
			_filters += '|'.join(additional_filters)
		
	if not _filters:
		# looks like unknown syntax, apply basic filters
		_filters = basic_filters
		
	return run_filters(tree, profile, _filters)

def replace_counter(text, value):
	"""
	 Replaces '$' character in string assuming it might be escaped with '\'
	 @type text: str
	 @type value: str, int
	 @return: str
	"""
	symbol = '$'
	value = str(value)
	
	def replace_func(tx, symbol, pos, match_num):
		if char_at(tx, pos + 1) == '{' or char_at(tx, pos + 1).isdigit():
			# it's a variable, skip it
			return False
		
		# replace sequense of $ symbols with padded number  
		j = pos + 1
		if j < len(text):
			while tx[j] == '$' and char_at(tx, j + 1) != '{': j += 1
		
		return (tx[pos:j], value.zfill(j - pos))
	
	return replace_unescaped_symbol(text, symbol, replace_func)

def upgrade_tabstops(node):
	"""
	Upgrades tabstops in zen node in order to prevent naming conflicts
	@type node: ZenNode
	@param offset: Tab index offset
	@type offset: int
	@returns Maximum tabstop index in element
	"""
	max_num = [0]
	props = ('start', 'end', 'content')
	
	def _replace(m):
		num = int(m.group(1) or m.group(2))
		if num > max_num[0]: max_num[0] = num
		return re.sub(r'\d+', str(num + max_tabstop), m.group(0), 1)
	
	for prop in props:
		node.__setattr__(prop, re.sub(r'\$(\d+)|\$\{(\d+):[^\}]+\}', _replace, node.__getattribute__(prop)))
		
	globals()['max_tabstop'] += max_num[0]
		
	return max_num[0]

def unescape_text(text):
	"""
	Unescapes special characters used in Zen Coding, like '$', '|', etc.
	@type text: str
	@return: str
	"""
	return re.sub(r'\\(.)', r'\1', text)

def get_profile(name):
	"""
	Get profile by it's name. If profile wasn't found, returns 'plain' profile
	"""
	return profiles[name] if name in profiles else profiles['plain']

def update_settings(settings):
	globals()['zen_settings'] = settings
	
class Tag(object):
	def __init__(self, name, count=1, doc_type='html'):
		"""
		@param name: Tag name
		@type name: str
		@param count:  How many times this tag must be outputted
		@type count: int
		@param doc_type: Document type (xsl, html)
		@type doc_type: str
		"""
		name = name.lower()
		
		abbr = get_abbreviation(doc_type, name)
		
		if abbr and abbr.type == stparser.TYPE_REFERENCE:
			abbr = get_abbreviation(doc_type, abbr.value)
		
		self.name = abbr and abbr.value['name'] or name.replace('+', '')
		self.count = count
		self.children = []
		self.attributes = []
		self.multiply_elem = None
		self.__attr_hash = {}
		self._abbr = abbr
		self.__content = ''
		self.repeat_by_lines = False
		self._res = zen_settings.has_key(doc_type) and zen_settings[doc_type] or {}
		self.parent = None
		
		# add default attributes
		if self._abbr and 'attributes' in self._abbr.value:
			for a in self._abbr.value['attributes']:
				self.add_attribute(a['name'], a['value'])
		
	def add_child(self, tag):
		"""
		Add new child
		@type tag: Tag
		"""
		tag.parent = self
		self.children.append(tag)
		
	def add_attribute(self, name, value):
		"""
		Add attribute to tag. If the attribute with the same name already exists,
		it will be overwritten, but if it's name is 'class', it will be merged
		with the existed one
		@param name: Attribute nama
		@type name: str
		@param value: Attribute value
		@type value: str
		"""
		
		# the only place in Tag where pipe (caret) character may exist
		# is the attribute: escape it with internal placeholder
		value = replace_unescaped_symbol(value, '|', get_caret_placeholder());
		
		if name in self.__attr_hash:
#			attribue already exists
			a = self.__attr_hash[name]
			if name == 'class':
#				'class' is a magic attribute
				if a['value']:
					value = ' ' + value
				a['value'] += value
			else:
				a['value'] = value
		else:
			a = {'name': name, 'value': value}
			self.__attr_hash[name] = a
			self.attributes.append(a)
	
	def has_tags_in_content(self):
		"""
		This function tests if current tags' content contains XHTML tags. 
	 	This function is mostly used for output formatting
		"""
		return self.get_content() and re_tag.search(self.get_content())
	
	def get_content(self):
		return self.__content
	
	def set_content(self, value):
		self.__content = value
		
	def set_content(self, content): #@DuplicatedSignature
		self.__content = content
		
	def get_content(self): #@DuplicatedSignature
		return self.__content
	
	def find_deepest_child(self):
		"""
		Search for deepest and latest child of current element.
		Returns None if there's no children
	 	@return Tag or None 
		"""
		if not self.children:
			return None
			
		deepest_child = self
		while True:
			deepest_child = deepest_child.children[-1]
			if not deepest_child.children:
				break
		
		return deepest_child
	
class Snippet(Tag):
	def __init__(self, name, count=1, doc_type='html'):
		super(Snippet, self).__init__(name, count, doc_type)
		self.value = replace_unescaped_symbol(get_snippet(doc_type, name), '|', get_caret_placeholder())
		self.attributes = {'id': get_caret_placeholder(), 'class': get_caret_placeholder()}
		self._res = zen_settings[doc_type]		
	
	def is_block(self):
		return True
	
class ZenNode(object):
	"""
	Creates simplified tag from Zen Coding tag
	"""
	def __init__(self, tag):
		"""
		@type tag: Tag
		"""
		self.type = 'snippet' if isinstance(tag, Snippet) else 'tag'
		self.name = tag.name
		self.attributes = tag.attributes
		self.children = [];
		self.counter = 1
		
		self.source = tag
		"Source element from which current tag was created"
		
		# relations
		self.parent = None
		self.next_sibling = None
		self.previous_sibling = None
		
		# output params
		self.start = ''
		self.end = ''
		self.content = ''
		self.padding = ''

	def add_child(self, tag):
		"""
		@type tag: ZenNode
		"""
		tag.parent = self
		
		if self.children:
			last_child = self.children[-1]
			tag.previous_sibling = last_child
			last_child.next_sibling = tag
		
		self.children.append(tag)
		
	def get_attribute(self, name):
		"""
		Get attribute's value.
		@type name: str
		@return: None if attribute wasn't found
		"""
		name = name.lower()
		for attr in self.attributes:
			if attr['name'].lower() == name:
				return attr['value']
		
		return None
	
	def is_unary(self):
		"""
		Test if current tag is unary (no closing tag)
		@return: bool
		"""
		if self.type == 'snippet':
			return False
			
		return (self.source._abbr and self.source._abbr.value['is_empty']) or (self.name in get_elements_collection(self.source._res, 'empty'))
	
	def is_inline(self):
		"""
		Test if current tag is inline-level (like <strong>, <img>)
		@return: bool
		"""
		return self.name in get_elements_collection(self.source._res, 'inline_level')
	
	def is_block(self):
		"""
		Test if current element is block-level
		@return: bool
		"""
		return self.type == 'snippet' or not self.is_inline()
	
	def has_tags_in_content(self):
		"""
		This function tests if current tags' content contains xHTML tags. 
		This function is mostly used for output formatting
		"""
		return self.content and re_tag.search(self.content)
	
	def has_children(self):
		"""
		Check if tag has child elements
		@return: bool
		"""
		return bool(self.children)
	
	def has_block_children(self):
		"""
		Test if current tag contains block-level children
		@return: bool
		"""
		if self.has_tags_in_content() and self.is_block():
			return True
		
		for item in self.children:
			if item.is_block():
				return True
			
		return False
	
	def find_deepest_child(self):
		"""
		Search for deepest and latest child of current element
		Returns None if there's no children
		@return: ZenNode|None 
		"""
		if not self.children:
			return None
			
		deepest_child = self
		while True:
			deepest_child = deepest_child.children[-1]
			if not deepest_child.children:
				break
		
		return deepest_child
	
	def to_string(self):
		"@return {String}"
		content = ''.join([item.to_string() for item in self.children])
		return self.start + self.content + content + self.end
		
# create default profiles
setup_profile('xhtml');
setup_profile('html', {'self_closing_tag': False});
setup_profile('xml', {'self_closing_tag': True, 'tag_nl': True});
setup_profile('plain', {'tag_nl': False, 'indent': False, 'place_cursor': False});

# This method call explicity loads default settings from zen_settings.py on start up
# Comment this line if you want to load data from other resources (like editor's 
# native snippet) 
update_settings(stparser.get_settings())

########NEW FILE########
__FILENAME__ = zen_dialog
'''
@author Franck Marcia (franck.marcia@gmail.com)
'''

import pygtk
pygtk.require('2.0')
import gtk

class ZenDialog():

    def __init__(self, editor, x, y, callback, text=""):

        self.editor = editor
        self.exit = False
        self.done = False
        self.abbreviation = text
        self.callback = callback

        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.set_decorated(False)
        self.window.connect("destroy", self.quit)
        self.window.connect("focus-out-event", self.focus_lost)
        self.window.connect("key-press-event", self.key_pressed)
        self.window.set_resizable(False)
        self.window.move(x, y - 27)

        self.frame = gtk.Frame()
        self.window.add(self.frame)
        self.frame.show()

        self.box = gtk.HBox()
        self.frame.add(self.box)
        self.box.show()
        
        self.entry = gtk.Entry()
        self.entry.connect("changed", self.update)
        self.entry.set_text(text)
        self.entry.set_has_frame(False)
        self.entry.set_width_chars(36)
        self.box.pack_start(self.entry, True, True, 4)
        self.entry.show()

        self.window.show()

    def key_pressed(widget, what, event):
        if event.keyval == 65293: # Return
            widget.exit = True
            widget.quit()
        elif event.keyval == 65289: # Tab
            widget.exit = True
            widget.quit()
        elif event.keyval == 65307: # Escape
            widget.exit = False
            widget.done = widget.callback(widget.done, '')
            widget.quit()
        else:
            return False
            
    def focus_lost(self, widget=None, event=None):
        self.exit = True
        self.quit()

    def update(self, entry):
        self.abbreviation = self.entry.get_text()
        self.done = self.callback(self.done, self.abbreviation)

    def quit(self, widget=None, event=None):
        self.window.hide()
        self.window.destroy()
        gtk.main_quit()

    def main(self):
        gtk.main()

def main(editor, window, callback, text=""):

    # Ensure the caret is hidden.
    editor.view.set_cursor_visible(False)
    
    # Get coordinates of the cursor.
    offset_start, offset_end = editor.get_selection_range()
    insert = editor.buffer.get_iter_at_offset(offset_start)
    location = editor.view.get_iter_location(insert)
    window = editor.view.get_window(gtk.TEXT_WINDOW_TEXT)
    xo, yo = window.get_origin()
    xb, yb = editor.view.buffer_to_window_coords(gtk.TEXT_WINDOW_TEXT, location.x + location.width, location.y)

    # Open dialog at coordinates with eventual text.
    my_zen_dialog = ZenDialog(editor, xo + xb, yo + yb, callback, text)
    my_zen_dialog.main()

    # Show the caret again.
    editor.view.set_cursor_visible(True)

    # Return exit status and abbreviation.
    return my_zen_dialog.done and my_zen_dialog.exit, my_zen_dialog.abbreviation


########NEW FILE########
__FILENAME__ = zen_editor
'''
High-level editor interface that communicates with underlying editor (like
Espresso, Coda, etc.) or browser. Basically, you should call set_context(obj) 
method to set up undelying editor context before using any other method.

This interface is used by zen_actions.py for performing different
actions like Expand abbreviation

@example
import zen_editor
zen_editor.set_context(obj);
//now you are ready to use editor object
zen_editor.get_selection_range();

@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru

Gedit implementation:
@author Franck Marcia (franck.marcia@gmail.com)
'''

import zen_core, zen_actions
import os, re, locale
import zen_dialog

class ZenEditor():

    def __init__(self):
        self.last_wrap = ''
        self.last_expand = ''
        zen_core.set_caret_placeholder('')

    def set_context(self, context):
        """
        Setup underlying editor context. You should call this method before 
        using any Zen Coding action.
        @param context: context object
        """
        self.context = context # window
        self.buffer = self.context.get_active_view().get_buffer()
        self.view = context.get_active_view()
        self.document = context.get_active_document()
        
        default_locale = locale.getdefaultlocale()[0]
        lang = re.sub(r'_[^_]+$', '', default_locale)
        if lang != default_locale:
            zen_core.set_variable('lang', lang)
            zen_core.set_variable('locale', default_locale.replace('_', '-'))
        else:
            zen_core.set_variable('lang', default_locale)
            zen_core.set_variable('locale', default_locale)
        
        self.encoding = self.document.get_encoding().get_charset()
        zen_core.set_variable('charset', self.encoding)
        
        if self.view.get_insert_spaces_instead_of_tabs():
            zen_core.set_variable('indentation', " " * context.get_active_view().get_tab_width())
        else:
            zen_core.set_variable('indentation', "\t")
        
    def get_selection_range(self):
        """
        Returns character indexes of selected text
        @return: list of start and end indexes
        @example
        start, end = zen_editor.get_selection_range();
        print('%s, %s' % (start, end))
        """
        offset_start = self.get_insert_offset()
        offset_end = self.get_selection_bound_offset()
        if offset_start < offset_end:
            return offset_start, offset_end
        return offset_end, offset_start


    def create_selection(self, offset_start, offset_end=None):
        """
        Creates selection from start to end character indexes. If end is 
        omitted, this method should place caret and start index.
        @type start: int
        @type end: int
        @example
        zen_editor.create_selection(10, 40)
        # move caret to 15th character
        zen_editor.create_selection(15)
        """
        if offset_end is None:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            self.buffer.place_cursor(iter_start)
        else:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            iter_end = self.buffer.get_iter_at_offset(offset_end)
            self.buffer.select_range(iter_start, iter_end)

    def get_current_line_range(self):
        """
        Returns current line's start and end indexes
        @return: list of start and end indexes
        @example
        start, end = zen_editor.get_current_line_range();
        print('%s, %s' % (start, end))
        """
        iter_current = self.get_insert_iter()
        offset_start = self.buffer.get_iter_at_line(iter_current.get_line()).get_offset()
        offset_end = offset_start + iter_current.get_chars_in_line() - 1
        return offset_start, offset_end

    def get_caret_pos(self):
        """ Returns current caret position """
        return self.get_insert_offset()

    def set_caret_pos(self, pos):
        """
        Sets the new caret position
        @type pos: int
        """
        self.buffer.place_cursor(self.buffer.get_iter_at_offset(pos))

    def get_current_line(self):
        """
        Returns content of current line
        @return: str
        """
        offset_start, offset_end = self.get_current_line_range()
        iter_start = self.buffer.get_iter_at_offset(offset_start)
        iter_end = self.buffer.get_iter_at_offset(offset_end)
        return self.buffer.get_text(iter_start, iter_end).decode(self.encoding)

    def replace_content(self, value, offset_start=None, offset_end=None):
        """
        Replace editor's content or its part (from start to end index). If 
        value contains caret_placeholder, the editor will put caret into
        this position. If you skip start and end arguments, the whole target's 
        content will be replaced with value.

        If you pass start argument only, the value will be placed at start 
        string index of current content.

        If you pass start and end arguments, the corresponding substring of 
        current target's content will be replaced with value
        @param value: Content you want to paste
        @type value: str
        @param start: Start index of editor's content
        @type start: int
        @param end: End index of editor's content
        @type end: int
        """
        if offset_start is None and offset_end is None:
            iter_start = self.buffer.get_iter_at_offset(0)
            iter_end = self.get_end_iter()
        elif offset_end is None:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            iter_end = self.buffer.get_iter_at_offset(offset_start)
        else:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            iter_end = self.buffer.get_iter_at_offset(offset_end)

        self.buffer.delete(iter_start, iter_end)
        self.insertion_start = self.get_insert_offset()
        
        padding = zen_actions.get_current_line_padding(self)
        self.buffer.insert_at_cursor(zen_core.pad_string(value, padding))

        self.insertion_end = self.get_insert_offset()

    def get_content(self):
        """
        Returns editor's content
        @return: str
        """
        iter_start = self.buffer.get_iter_at_offset(0)
        iter_end = self.get_end_iter()
        return self.buffer.get_text(iter_start, iter_end).decode(self.encoding)

    def get_syntax(self):
        """
        Returns current editor's syntax mode
        @return: str
        """
        lang = self.context.get_active_document().get_language()
        lang = lang and lang.get_name()
        if lang == 'CSS': lang = 'css'
        elif lang == 'XSLT': lang = 'xsl'
        elif lang == 'SASS': lang = 'sass'
        else: lang = 'html'
        return lang

    def get_profile_name(self):
        """
        Returns current output profile name (@see zen_coding#setup_profile)
        @return {String}
        """
        return 'xhtml'

    def get_insert_iter(self):
        return self.buffer.get_iter_at_mark(self.buffer.get_insert())
        
    def get_insert_offset(self):
        return self.get_insert_iter().get_offset()

    def get_selection_bound_iter(self):
        return self.buffer.get_iter_at_mark(self.buffer.get_selection_bound())

    def get_selection_bound_offset(self):
        return self.get_selection_bound_iter().get_offset()

    def get_end_iter(self):
        return self.buffer.get_iter_at_offset(self.buffer.get_char_count())

    def get_end_offset(self):
        return self.get_end_iter().get_offset()
        
    def start_edit(self):
        # Bug when the cursor is at the very beginning.
        if self.insertion_start == 0:
            self.insertion_start = 1
        self.set_caret_pos(self.insertion_start)
        if not self.next_edit_point() or (self.get_insert_offset() > self.insertion_end):
            self.set_caret_pos(self.insertion_end)
    
    def show_caret(self):
        self.view.scroll_mark_onscreen(self.buffer.get_insert())

    def get_user_settings_error(self):
        return zen_core.get_variable('user_settings_error')

    def expand_abbreviation(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.expand_abbreviation(self)
        if result:
            self.start_edit()
        self.buffer.end_user_action()

    def save_selection(self):
        self.save_offset_insert = self.get_insert_offset()
        self.save_offset_selection_bound = self.get_selection_bound_offset()

    def restore_selection(self):
        iter_insert = self.buffer.get_iter_at_offset(self.save_offset_insert)
        iter_selection_bound = self.buffer.get_iter_at_offset(self.save_offset_selection_bound)
        self.buffer.select_range(iter_insert, iter_selection_bound)

    def do_expand_with_abbreviation(self, done, abbr):
        self.buffer.begin_user_action()
        if done:
            self.buffer.undo()
            self.restore_selection()
        content = zen_core.expand_abbreviation(abbr, self.get_syntax(), self.get_profile_name())
        if content:
            self.replace_content(content, self.get_insert_offset())
        self.buffer.end_user_action()
        return not not content

    def expand_with_abbreviation(self, window):
        self.set_context(window)
        self.save_selection()
        done, self.last_expand = zen_dialog.main(self, window, self.do_expand_with_abbreviation, self.last_expand)
        if done:
            self.start_edit()

    def do_wrap_with_abbreviation(self, done, abbr):
        self.buffer.begin_user_action()
        if done:
            self.buffer.undo()
            self.restore_selection()
        result = zen_actions.wrap_with_abbreviation(self, abbr)
        self.buffer.end_user_action()
        return result

    def wrap_with_abbreviation(self, window):
        self.set_context(window)
        self.save_selection()
        done, self.last_wrap = zen_dialog.main(self, window, self.do_wrap_with_abbreviation, self.last_wrap)
        if done:
            self.start_edit()

    def match_pair_inward(self, window):
        self.set_context(window)
        zen_actions.match_pair_inward(self)

    def match_pair_outward(self, window):
        self.set_context(window)
        zen_actions.match_pair_outward(self)

    def merge_lines(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.merge_lines(self)
        self.buffer.end_user_action()
        return result

    def prev_edit_point(self, window=None):
        if window:
            self.set_context(window)
        result = zen_actions.prev_edit_point(self)
        self.show_caret()
        return result

    def next_edit_point(self, window=None):
        if window:
            self.set_context(window)
        result = zen_actions.next_edit_point(self)
        self.show_caret()
        return result

    def remove_tag(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.remove_tag(self)
        self.buffer.end_user_action()
        return result

    def split_join_tag(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.split_join_tag(self)
        self.buffer.end_user_action()
        return result

    def toggle_comment(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.toggle_comment(self)
        self.buffer.end_user_action()
        return result

########NEW FILE########
__FILENAME__ = zen_settings
"""
Zen Coding settings
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
"""
zen_settings = {
			
#	Variables that can be placed inside snippets or abbreviations as ${variable}
#	${child} variable is reserved, don't use it
	'variables': {
		'lang': 'en',
		'locale': 'en-US',
		'charset': 'UTF-8',
		'profile': 'xhtml',
		
#		Inner element indentation
		'indentation': '\t'
	},
	
	# common settings are used for quick injection of user-defined snippets
	'common': {
		
	},
	
	'css': {
		'extends': 'common',
		'snippets': {
			"@i": "@import url(|);",
			"@m": "@media print {\n\t|\n}",
			"@f": "@font-face {\n\tfont-family:|;\n\tsrc:url(|);\n}",
			"!": "!important",
			"pos": "position:|;",
			"pos:s": "position:static;",
			"pos:a": "position:absolute;",
			"pos:r": "position:relative;",
			"pos:f": "position:fixed;",
			"t": "top:|;",
			"t:a": "top:auto;",
			"r": "right:|;",
			"r:a": "right:auto;",
			"b": "bottom:|;",
			"b:a": "bottom:auto;",
			"brad": "-webkit-border-radius: ${1:radius};\n-moz-border-radius: $1;\n-ms-border-radius: $1;\nborder-radius: $1;$0",
			"l": "left:|;",
			"l:a": "left:auto;",
			"z": "z-index:|;",
			"z:a": "z-index:auto;",
			"fl": "float:|;",
			"fl:n": "float:none;",
			"fl:l": "float:left;",
			"fl:r": "float:right;",
			"cl": "clear:|;",
			"cl:n": "clear:none;",
			"cl:l": "clear:left;",
			"cl:r": "clear:right;",
			"cl:b": "clear:both;",
			"d": "display:|;",
			"d:n": "display:none;",
			"d:b": "display:block;",
			"d:i": "display:inline;",
			"d:ib": "display:inline-block;",
			"d:li": "display:list-item;",
			"d:ri": "display:run-in;",
			"d:cp": "display:compact;",
			"d:tb": "display:table;",
			"d:itb": "display:inline-table;",
			"d:tbcp": "display:table-caption;",
			"d:tbcl": "display:table-column;",
			"d:tbclg": "display:table-column-group;",
			"d:tbhg": "display:table-header-group;",
			"d:tbfg": "display:table-footer-group;",
			"d:tbr": "display:table-row;",
			"d:tbrg": "display:table-row-group;",
			"d:tbc": "display:table-cell;",
			"d:rb": "display:ruby;",
			"d:rbb": "display:ruby-base;",
			"d:rbbg": "display:ruby-base-group;",
			"d:rbt": "display:ruby-text;",
			"d:rbtg": "display:ruby-text-group;",
			"v": "visibility:|;",
			"v:v": "visibility:visible;",
			"v:h": "visibility:hidden;",
			"v:c": "visibility:collapse;",
			"ov": "overflow:|;",
			"ov:v": "overflow:visible;",
			"ov:h": "overflow:hidden;",
			"ov:s": "overflow:scroll;",
			"ov:a": "overflow:auto;",
			"ovx": "overflow-x:|;",
			"ovx:v": "overflow-x:visible;",
			"ovx:h": "overflow-x:hidden;",
			"ovx:s": "overflow-x:scroll;",
			"ovx:a": "overflow-x:auto;",
			"ovy": "overflow-y:|;",
			"ovy:v": "overflow-y:visible;",
			"ovy:h": "overflow-y:hidden;",
			"ovy:s": "overflow-y:scroll;",
			"ovy:a": "overflow-y:auto;",
			"ovs": "overflow-style:|;",
			"ovs:a": "overflow-style:auto;",
			"ovs:s": "overflow-style:scrollbar;",
			"ovs:p": "overflow-style:panner;",
			"ovs:m": "overflow-style:move;",
			"ovs:mq": "overflow-style:marquee;",
			"zoo": "zoom:1;",
			"cp": "clip:|;",
			"cp:a": "clip:auto;",
			"cp:r": "clip:rect(|);",
			"bxz": "box-sizing:|;",
			"bxz:cb": "box-sizing:content-box;",
			"bxz:bb": "box-sizing:border-box;",
			"bxsh": "box-shadow:|;",
			"bxsh:n": "box-shadow:none;",
			"bxsh:w": "-webkit-box-shadow:0 0 0 #000;",
			"bxsh:m": "-moz-box-shadow:0 0 0 0 #000;",
			"m": "margin:|;",
			"m:a": "margin:auto;",
			"m:0": "margin:0;",
			"m:2": "margin:0 0;",
			"m:3": "margin:0 0 0;",
			"m:4": "margin:0 0 0 0;",
			"mt": "margin-top:|;",
			"mt:a": "margin-top:auto;",
			"mr": "margin-right:|;",
			"mr:a": "margin-right:auto;",
			"mb": "margin-bottom:|;",
			"mb:a": "margin-bottom:auto;",
			"ml": "margin-left:|;",
			"ml:a": "margin-left:auto;",
			"p": "padding:|;",
			"p:0": "padding:0;",
			"p:2": "padding:0 0;",
			"p:3": "padding:0 0 0;",
			"p:4": "padding:0 0 0 0;",
			"pt": "padding-top:|;",
			"pr": "padding-right:|;",
			"pb": "padding-bottom:|;",
			"pl": "padding-left:|;",
			"w": "width:|;",
			"w:a": "width:auto;",
			"h": "height:|;",
			"h:a": "height:auto;",
			"maw": "max-width:|;",
			"maw:n": "max-width:none;",
			"mah": "max-height:|;",
			"mah:n": "max-height:none;",
			"miw": "min-width:|;",
			"mih": "min-height:|;",
			"o": "outline:|;",
			"o:n": "outline:none;",
			"oo": "outline-offset:|;",
			"ow": "outline-width:|;",
			"os": "outline-style:|;",
			"oc": "outline-color:#000;",
			"oc:i": "outline-color:invert;",
			"bd": "border:|;",
			"bd+": "border:1px solid #000;",
			"bd:n": "border:none;",
			"bdbk": "border-break:|;",
			"bdbk:c": "border-break:close;",
			"bdcl": "border-collapse:|;",
			"bdcl:c": "border-collapse:collapse;",
			"bdcl:s": "border-collapse:separate;",
			"bdc": "border-color:#000;",
			"bdi": "border-image:url(|);",
			"bdi:n": "border-image:none;",
			"bdi:w": "-webkit-border-image:url(|) 0 0 0 0 stretch stretch;",
			"bdi:m": "-moz-border-image:url(|) 0 0 0 0 stretch stretch;",
			"bdti": "border-top-image:url(|);",
			"bdti:n": "border-top-image:none;",
			"bdri": "border-right-image:url(|);",
			"bdri:n": "border-right-image:none;",
			"bdbi": "border-bottom-image:url(|);",
			"bdbi:n": "border-bottom-image:none;",
			"bdli": "border-left-image:url(|);",
			"bdli:n": "border-left-image:none;",
			"bdci": "border-corner-image:url(|);",
			"bdci:n": "border-corner-image:none;",
			"bdci:c": "border-corner-image:continue;",
			"bdtli": "border-top-left-image:url(|);",
			"bdtli:n": "border-top-left-image:none;",
			"bdtli:c": "border-top-left-image:continue;",
			"bdtri": "border-top-right-image:url(|);",
			"bdtri:n": "border-top-right-image:none;",
			"bdtri:c": "border-top-right-image:continue;",
			"bdbri": "border-bottom-right-image:url(|);",
			"bdbri:n": "border-bottom-right-image:none;",
			"bdbri:c": "border-bottom-right-image:continue;",
			"bdbli": "border-bottom-left-image:url(|);",
			"bdbli:n": "border-bottom-left-image:none;",
			"bdbli:c": "border-bottom-left-image:continue;",
			"bdf": "border-fit:|;",
			"bdf:c": "border-fit:clip;",
			"bdf:r": "border-fit:repeat;",
			"bdf:sc": "border-fit:scale;",
			"bdf:st": "border-fit:stretch;",
			"bdf:ow": "border-fit:overwrite;",
			"bdf:of": "border-fit:overflow;",
			"bdf:sp": "border-fit:space;",
			"bdl": "border-length:|;",
			"bdl:a": "border-length:auto;",
			"bdsp": "border-spacing:|;",
			"bds": "border-style:|;",
			"bds:n": "border-style:none;",
			"bds:h": "border-style:hidden;",
			"bds:dt": "border-style:dotted;",
			"bds:ds": "border-style:dashed;",
			"bds:s": "border-style:solid;",
			"bds:db": "border-style:double;",
			"bds:dtds": "border-style:dot-dash;",
			"bds:dtdtds": "border-style:dot-dot-dash;",
			"bds:w": "border-style:wave;",
			"bds:g": "border-style:groove;",
			"bds:r": "border-style:ridge;",
			"bds:i": "border-style:inset;",
			"bds:o": "border-style:outset;",
			"bdw": "border-width:|;",
			"bdt": "border-top:|;",
			"bdt+": "border-top:1px solid #000;",
			"bdt:n": "border-top:none;",
			"bdtw": "border-top-width:|;",
			"bdts": "border-top-style:|;",
			"bdts:n": "border-top-style:none;",
			"bdtc": "border-top-color:#000;",
			"bdr": "border-right:|;",
			"bdr+": "border-right:1px solid #000;",
			"bdr:n": "border-right:none;",
			"bdrw": "border-right-width:|;",
			"bdrs": "border-right-style:|;",
			"bdrs:n": "border-right-style:none;",
			"bdrc": "border-right-color:#000;",
			"bdb": "border-bottom:|;",
			"bdb+": "border-bottom:1px solid #000;",
			"bdb:n": "border-bottom:none;",
			"bdbw": "border-bottom-width:|;",
			"bdbs": "border-bottom-style:|;",
			"bdbs:n": "border-bottom-style:none;",
			"bdbc": "border-bottom-color:#000;",
			"bdl": "border-left:|;",
			"bdl+": "border-left:1px solid #000;",
			"bdl:n": "border-left:none;",
			"bdlw": "border-left-width:|;",
			"bdls": "border-left-style:|;",
			"bdls:n": "border-left-style:none;",
			"bdlc": "border-left-color:#000;",
			"bdrs": "border-radius:|;",
			"bdtrrs": "border-top-right-radius:|;",
			"bdtlrs": "border-top-left-radius:|;",
			"bdbrrs": "border-bottom-right-radius:|;",
			"bdblrs": "border-bottom-left-radius:|;",
			"bg": "background:|;",
			"bg+": "background:#FFF url(|) 0 0 no-repeat;",
			"bg:n": "background:none;",
			"bg:ie": "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='|x.png');",
			"bgc": "background-color:#FFF;",
			"bgi": "background-image:url(|);",
			"bgi:n": "background-image:none;",
			"bgr": "background-repeat:|;",
			"bgr:n": "background-repeat:no-repeat;",
			"bgr:x": "background-repeat:repeat-x;",
			"bgr:y": "background-repeat:repeat-y;",
			"bga": "background-attachment:|;",
			"bga:f": "background-attachment:fixed;",
			"bga:s": "background-attachment:scroll;",
			"bgp": "background-position:0 0;",
			"bgpx": "background-position-x:|;",
			"bgpy": "background-position-y:|;",
			"bgbk": "background-break:|;",
			"bgbk:bb": "background-break:bounding-box;",
			"bgbk:eb": "background-break:each-box;",
			"bgbk:c": "background-break:continuous;",
			"bgcp": "background-clip:|;",
			"bgcp:bb": "background-clip:border-box;",
			"bgcp:pb": "background-clip:padding-box;",
			"bgcp:cb": "background-clip:content-box;",
			"bgcp:nc": "background-clip:no-clip;",
			"bgo": "background-origin:|;",
			"bgo:pb": "background-origin:padding-box;",
			"bgo:bb": "background-origin:border-box;",
			"bgo:cb": "background-origin:content-box;",
			"bgz": "background-size:|;",
			"bgz:a": "background-size:auto;",
			"bgz:ct": "background-size:contain;",
			"bgz:cv": "background-size:cover;",
			"c": "color:#000;",
			"tbl": "table-layout:|;",
			"tbl:a": "table-layout:auto;",
			"tbl:f": "table-layout:fixed;",
			"cps": "caption-side:|;",
			"cps:t": "caption-side:top;",
			"cps:b": "caption-side:bottom;",
			"ec": "empty-cells:|;",
			"ec:s": "empty-cells:show;",
			"ec:h": "empty-cells:hide;",
			"lis": "list-style:|;",
			"lis:n": "list-style:none;",
			"lisp": "list-style-position:|;",
			"lisp:i": "list-style-position:inside;",
			"lisp:o": "list-style-position:outside;",
			"list": "list-style-type:|;",
			"list:n": "list-style-type:none;",
			"list:d": "list-style-type:disc;",
			"list:c": "list-style-type:circle;",
			"list:s": "list-style-type:square;",
			"list:dc": "list-style-type:decimal;",
			"list:dclz": "list-style-type:decimal-leading-zero;",
			"list:lr": "list-style-type:lower-roman;",
			"list:ur": "list-style-type:upper-roman;",
			"lisi": "list-style-image:|;",
			"lisi:n": "list-style-image:none;",
			"q": "quotes:|;",
			"q:n": "quotes:none;",
			"q:ru": "quotes:'\00AB' '\00BB' '\201E' '\201C';",
			"q:en": "quotes:'\201C' '\201D' '\2018' '\2019';",
			"ct": "content:|;",
			"ct:n": "content:normal;",
			"ct:oq": "content:open-quote;",
			"ct:noq": "content:no-open-quote;",
			"ct:cq": "content:close-quote;",
			"ct:ncq": "content:no-close-quote;",
			"ct:a": "content:attr(|);",
			"ct:c": "content:counter(|);",
			"ct:cs": "content:counters(|);",
			"coi": "counter-increment:|;",
			"cor": "counter-reset:|;",
			"va": "vertical-align:|;",
			"va:sup": "vertical-align:super;",
			"va:t": "vertical-align:top;",
			"va:tt": "vertical-align:text-top;",
			"va:m": "vertical-align:middle;",
			"va:bl": "vertical-align:baseline;",
			"va:b": "vertical-align:bottom;",
			"va:tb": "vertical-align:text-bottom;",
			"va:sub": "vertical-align:sub;",
			"ta": "text-align:|;",
			"ta:l": "text-align:left;",
			"ta:c": "text-align:center;",
			"ta:r": "text-align:right;",
			"tal": "text-align-last:|;",
			"tal:a": "text-align-last:auto;",
			"tal:l": "text-align-last:left;",
			"tal:c": "text-align-last:center;",
			"tal:r": "text-align-last:right;",
			"td": "text-decoration:|;",
			"td:n": "text-decoration:none;",
			"td:u": "text-decoration:underline;",
			"td:o": "text-decoration:overline;",
			"td:l": "text-decoration:line-through;",
			"te": "text-emphasis:|;",
			"te:n": "text-emphasis:none;",
			"te:ac": "text-emphasis:accent;",
			"te:dt": "text-emphasis:dot;",
			"te:c": "text-emphasis:circle;",
			"te:ds": "text-emphasis:disc;",
			"te:b": "text-emphasis:before;",
			"te:a": "text-emphasis:after;",
			"th": "text-height:|;",
			"th:a": "text-height:auto;",
			"th:f": "text-height:font-size;",
			"th:t": "text-height:text-size;",
			"th:m": "text-height:max-size;",
			"ti": "text-indent:|;",
			"ti:-": "text-indent:-9999px;",
			"tj": "text-justify:|;",
			"tj:a": "text-justify:auto;",
			"tj:iw": "text-justify:inter-word;",
			"tj:ii": "text-justify:inter-ideograph;",
			"tj:ic": "text-justify:inter-cluster;",
			"tj:d": "text-justify:distribute;",
			"tj:k": "text-justify:kashida;",
			"tj:t": "text-justify:tibetan;",
			"to": "text-outline:|;",
			"to+": "text-outline:0 0 #000;",
			"to:n": "text-outline:none;",
			"tr": "text-replace:|;",
			"tr:n": "text-replace:none;",
			"tt": "text-transform:|;",
			"tt:n": "text-transform:none;",
			"tt:c": "text-transform:capitalize;",
			"tt:u": "text-transform:uppercase;",
			"tt:l": "text-transform:lowercase;",
			"tw": "text-wrap:|;",
			"tw:n": "text-wrap:normal;",
			"tw:no": "text-wrap:none;",
			"tw:u": "text-wrap:unrestricted;",
			"tw:s": "text-wrap:suppress;",
			"tsh": "text-shadow:|;",
			"tsh+": "text-shadow:0 0 0 #000;",
			"tsh:n": "text-shadow:none;",
			"lh": "line-height:|;",
			"whs": "white-space:|;",
			"whs:n": "white-space:normal;",
			"whs:p": "white-space:pre;",
			"whs:nw": "white-space:nowrap;",
			"whs:pw": "white-space:pre-wrap;",
			"whs:pl": "white-space:pre-line;",
			"whsc": "white-space-collapse:|;",
			"whsc:n": "white-space-collapse:normal;",
			"whsc:k": "white-space-collapse:keep-all;",
			"whsc:l": "white-space-collapse:loose;",
			"whsc:bs": "white-space-collapse:break-strict;",
			"whsc:ba": "white-space-collapse:break-all;",
			"wob": "word-break:|;",
			"wob:n": "word-break:normal;",
			"wob:k": "word-break:keep-all;",
			"wob:l": "word-break:loose;",
			"wob:bs": "word-break:break-strict;",
			"wob:ba": "word-break:break-all;",
			"wos": "word-spacing:|;",
			"wow": "word-wrap:|;",
			"wow:nm": "word-wrap:normal;",
			"wow:n": "word-wrap:none;",
			"wow:u": "word-wrap:unrestricted;",
			"wow:s": "word-wrap:suppress;",
			"lts": "letter-spacing:|;",
			"f": "font:|;",
			"f+": "font:1em Arial,sans-serif;",
			"fw": "font-weight:|;",
			"fw:n": "font-weight:normal;",
			"fw:b": "font-weight:bold;",
			"fw:br": "font-weight:bolder;",
			"fw:lr": "font-weight:lighter;",
			"fs": "font-style:|;",
			"fs:n": "font-style:normal;",
			"fs:i": "font-style:italic;",
			"fs:o": "font-style:oblique;",
			"fv": "font-variant:|;",
			"fv:n": "font-variant:normal;",
			"fv:sc": "font-variant:small-caps;",
			"fz": "font-size:|;",
			"fza": "font-size-adjust:|;",
			"fza:n": "font-size-adjust:none;",
			"ff": "font-family:|;",
			"ff:s": "font-family:serif;",
			"ff:ss": "font-family:sans-serif;",
			"ff:c": "font-family:cursive;",
			"ff:f": "font-family:fantasy;",
			"ff:m": "font-family:monospace;",
			"fef": "font-effect:|;",
			"fef:n": "font-effect:none;",
			"fef:eg": "font-effect:engrave;",
			"fef:eb": "font-effect:emboss;",
			"fef:o": "font-effect:outline;",
			"fem": "font-emphasize:|;",
			"femp": "font-emphasize-position:|;",
			"femp:b": "font-emphasize-position:before;",
			"femp:a": "font-emphasize-position:after;",
			"fems": "font-emphasize-style:|;",
			"fems:n": "font-emphasize-style:none;",
			"fems:ac": "font-emphasize-style:accent;",
			"fems:dt": "font-emphasize-style:dot;",
			"fems:c": "font-emphasize-style:circle;",
			"fems:ds": "font-emphasize-style:disc;",
			"fsm": "font-smooth:|;",
			"fsm:a": "font-smooth:auto;",
			"fsm:n": "font-smooth:never;",
			"fsm:aw": "font-smooth:always;",
			"fst": "font-stretch:|;",
			"fst:n": "font-stretch:normal;",
			"fst:uc": "font-stretch:ultra-condensed;",
			"fst:ec": "font-stretch:extra-condensed;",
			"fst:c": "font-stretch:condensed;",
			"fst:sc": "font-stretch:semi-condensed;",
			"fst:se": "font-stretch:semi-expanded;",
			"fst:e": "font-stretch:expanded;",
			"fst:ee": "font-stretch:extra-expanded;",
			"fst:ue": "font-stretch:ultra-expanded;",
			"op": "opacity:|;",
			"op:ie": "filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);",
			"op:ms": "-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';",
			"rz": "resize:|;",
			"rz:n": "resize:none;",
			"rz:b": "resize:both;",
			"rz:h": "resize:horizontal;",
			"rz:v": "resize:vertical;",
			"cur": "cursor:|;",
			"cur:a": "cursor:auto;",
			"cur:d": "cursor:default;",
			"cur:c": "cursor:crosshair;",
			"cur:ha": "cursor:hand;",
			"cur:he": "cursor:help;",
			"cur:m": "cursor:move;",
			"cur:p": "cursor:pointer;",
			"cur:t": "cursor:text;",
			"pgbb": "page-break-before:|;",
			"pgbb:au": "page-break-before:auto;",
			"pgbb:al": "page-break-before:always;",
			"pgbb:l": "page-break-before:left;",
			"pgbb:r": "page-break-before:right;",
			"pgbi": "page-break-inside:|;",
			"pgbi:au": "page-break-inside:auto;",
			"pgbi:av": "page-break-inside:avoid;",
			"pgba": "page-break-after:|;",
			"pgba:au": "page-break-after:auto;",
			"pgba:al": "page-break-after:always;",
			"pgba:l": "page-break-after:left;",
			"pgba:r": "page-break-after:right;",
			"orp": "orphans:|;",
			"wid": "widows:|;"
		}
	},
	
	'html': {
		'extends': 'common',
		'filters': 'html',
		'snippets': {
			'cc:ie6': '<!--[if lte IE 6]>\n\t${child}|\n<![endif]-->',
			'cc:ie': '<!--[if IE]>\n\t${child}|\n<![endif]-->',
			'cc:noie': '<!--[if !IE]><!-->\n\t${child}|\n<!--<![endif]-->',
			'html:4t': '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n' +
					'<html lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}">\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:4s': '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">\n' +
					'<html lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}">\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:xt': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n' +
					'<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}" />\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:xs': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n' +
					'<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}" />\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:xxs': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n' +
					'<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}" />\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:5': '<!DOCTYPE HTML>\n' +
					'<html lang="${locale}">\n' +
					'<head>\n' +
					'${indentation}<meta charset="${charset}">\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>'
		},
		
		'abbreviations': {
			'a': '<a href=""></a>',
			'a:link': '<a href="http://|"></a>',
			'a:mail': '<a href="mailto:|"></a>',
			'abbr': '<abbr title=""></abbr>',
			'acronym': '<acronym title=""></acronym>',
			'base': '<base href="" />',
			'bdo': '<bdo dir=""></bdo>',
			'bdo:r': '<bdo dir="rtl"></bdo>',
			'bdo:l': '<bdo dir="ltr"></bdo>',
			'link:css': '<link rel="stylesheet" type="text/css" href="|style.css" media="all" />',
			'link:print': '<link rel="stylesheet" type="text/css" href="|print.css" media="print" />',
			'link:favicon': '<link rel="shortcut icon" type="image/x-icon" href="|favicon.ico" />',
			'link:touch': '<link rel="apple-touch-icon" href="|favicon.png" />',
			'link:rss': '<link rel="alternate" type="application/rss+xml" title="RSS" href="|rss.xml" />',
			'link:atom': '<link rel="alternate" type="application/atom+xml" title="Atom" href="atom.xml" />',
			'meta:utf': '<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />',
			'meta:win': '<meta http-equiv="Content-Type" content="text/html;charset=Win-1251" />',
			'meta:compat': '<meta http-equiv="X-UA-Compatible" content="IE=7" />',
			'style': '<style type="text/css"></style>',
			'script': '<script type="text/javascript"></script>',
			'script:src': '<script type="text/javascript" src=""></script>',
			'img': '<img src="" alt="" />',
			'iframe': '<iframe src="" frameborder="0"></iframe>',
			'embed': '<embed src="" type="" />',
			'object': '<object data="" type=""></object>',
			'param': '<param name="" value="" />',
			'map': '<map name=""></map>',
			'area': '<area shape="" coords="" href="" alt="" />',
			'area:d': '<area shape="default" href="" alt="" />',
			'area:c': '<area shape="circle" coords="" href="" alt="" />',
			'area:r': '<area shape="rect" coords="" href="" alt="" />',
			'area:p': '<area shape="poly" coords="" href="" alt="" />',
			'link': '<link rel="stylesheet" href="" />',
			'form': '<form action=""></form>',
			'form:get': '<form action="" method="get"></form>',
			'form:post': '<form action="" method="post"></form>',
			'label': '<label for=""></label>',
			'input': '<input type="" />',
			'input:hidden': '<input type="hidden" name="" />',
			'input:h': '<input type="hidden" name="" />',
			'input:text': '<input type="text" name="" id="" />',
			'input:t': '<input type="text" name="" id="" />',
			'input:search': '<input type="search" name="" id="" />',
			'input:email': '<input type="email" name="" id="" />',
			'input:url': '<input type="url" name="" id="" />',
			'input:password': '<input type="password" name="" id="" />',
			'input:p': '<input type="password" name="" id="" />',
			'input:datetime': '<input type="datetime" name="" id="" />',
			'input:date': '<input type="date" name="" id="" />',
			'input:datetime-local': '<input type="datetime-local" name="" id="" />',
			'input:month': '<input type="month" name="" id="" />',
			'input:week': '<input type="week" name="" id="" />',
			'input:time': '<input type="time" name="" id="" />',
			'input:number': '<input type="number" name="" id="" />',
			'input:color': '<input type="color" name="" id="" />',
			'input:checkbox': '<input type="checkbox" name="" id="" />',
			'input:c': '<input type="checkbox" name="" id="" />',
			'input:radio': '<input type="radio" name="" id="" />',
			'input:r': '<input type="radio" name="" id="" />',
			'input:range': '<input type="range" name="" id="" />',
			'input:file': '<input type="file" name="" id="" />',
			'input:f': '<input type="file" name="" id="" />',
			'input:submit': '<input type="submit" value="" />',
			'input:s': '<input type="submit" value="" />',
			'input:image': '<input type="image" src="" alt="" />',
			'input:i': '<input type="image" src="" alt="" />',
			'input:reset': '<input type="reset" value="" />',
			'input:button': '<input type="button" value="" />',
			'input:b': '<input type="button" value="" />',
			'select': '<select name="" id=""></select>',
			'option': '<option value=""></option>',
			'textarea': '<textarea name="" id="" cols="30" rows="10"></textarea>',
			'menu:context': '<menu type="context"></menu>',
			'menu:c': '<menu type="context"></menu>',
			'menu:toolbar': '<menu type="toolbar"></menu>',
			'menu:t': '<menu type="toolbar"></menu>',
			'video': '<video src=""></video>',
			'audio': '<audio src=""></audio>',
			'html:xml': '<html xmlns="http://www.w3.org/1999/xhtml"></html>',
			'bq': '<blockquote></blockquote>',
			'acr': '<acronym></acronym>',
			'fig': '<figure></figure>',
			'ifr': '<iframe></iframe>',
			'emb': '<embed></embed>',
			'obj': '<object></object>',
			'src': '<source></source>',
			'cap': '<caption></caption>',
			'colg': '<colgroup></colgroup>',
			'fst': '<fieldset></fieldset>',
			'btn': '<button></button>',
			'optg': '<optgroup></optgroup>',
			'opt': '<option></option>',
			'tarea': '<textarea></textarea>',
			'leg': '<legend></legend>',
			'sect': '<section></section>',
			'art': '<article></article>',
			'hdr': '<header></header>',
			'ftr': '<footer></footer>',
			'adr': '<address></address>',
			'dlg': '<dialog></dialog>',
			'str': '<strong></strong>',
			'prog': '<progress></progress>',
			'fset': '<fieldset></fieldset>',
			'datag': '<datagrid></datagrid>',
			'datal': '<datalist></datalist>',
			'kg': '<keygen></keygen>',
			'out': '<output></output>',
			'det': '<details></details>',
			'cmd': '<command></command>',
			
#			expandos
			'ol+': 'ol>li',
			'ul+': 'ul>li',
			'dl+': 'dl>dt+dd',
			'map+': 'map>area',
			'table+': 'table>tr>td',
			'colgroup+': 'colgroup>col',
			'colg+': 'colgroup>col',
			'tr+': 'tr>td',
			'select+': 'select>option',
			'optgroup+': 'optgroup>option',
			'optg+': 'optgroup>option'

		},
		
		'element_types': {
			'empty': 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command',
			'block_level': 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6',
			'inline_level': 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'
		}
	},
	
	'xsl': {
		'extends': 'common,html',
		'filters': 'html, xsl',
		'abbreviations': {
			'tm': '<xsl:template match="" mode=""></xsl:template>',
			'tmatch': 'tm',
			'tn': '<xsl:template name=""></xsl:template>',
			'tname': 'tn',
			'xsl:when': '<xsl:when test=""></xsl:when>',
			'wh': 'xsl:when',
			'var': '<xsl:variable name="">|</xsl:variable>',
			'vare': '<xsl:variable name="" select=""/>',
			'if': '<xsl:if test=""></xsl:if>',
			'call': '<xsl:call-template name=""/>',
			'attr': '<xsl:attribute name=""></xsl:attribute>',
			'wp': '<xsl:with-param name="" select=""/>',
			'par': '<xsl:param name="" select=""/>',
			'val': '<xsl:value-of select=""/>',
			'co': '<xsl:copy-of select=""/>',
			'each': '<xsl:for-each select=""></xsl:for-each>',
			'ap': '<xsl:apply-templates select="" mode=""/>',
			
#			expandos
			'choose+': 'xsl:choose>xsl:when+xsl:otherwise'
		}
	},
	
	'haml': {
		'filters': 'haml',
		'extends': 'html'
	}
}

########NEW FILE########
__FILENAME__ = fontsize_manipulator
# -*- coding: utf-8 -*-
#
# Zoom - gedit plugin
# Copyright (C) 2010 Christian Luginbhl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

class FontsizeManipulator:
    """Manipulates the fontsize of a specific view."""

    ZOOM_STEP = 1.090507733 # sqrt(sqrt(sqrt(2)))
    # allowing 16 steps in both directions, 25% - 400% of original size (with
    # a little extra range to deal with rounding errors)
    ZOOM_MAX = 4.1
    ZOOM_MIN = 0.24

    def __init__(self, view):
        """Constructor."""
        self._view = view
        self._context = self._view.get_pango_context()
        self._fontdescription = self._context.get_font_description()

        self._zoomlevel = 1.0

        self._original_fontsize = self._get_pango_fontsize()

    def enlarge(self):
        """Enlarges the font up to a defined maximum."""
        new_zoomlevel = self._zoomlevel * self.__class__.ZOOM_STEP
        if (new_zoomlevel < self.__class__.ZOOM_MAX):
            self._zoomlevel = new_zoomlevel
            self._update_font()

    def shrink(self):
        """Shrinks the font down to a defined minimum."""
        new_zoomlevel = self._zoomlevel / self.__class__.ZOOM_STEP
        if (new_zoomlevel > self.__class__.ZOOM_MIN):
            self._zoomlevel = new_zoomlevel
            self._update_font()

    def reset(self):
        """Resets the font to its original size."""
        self._zoomlevel = 1.0
        self._update_font()

    def _update_font(self):
        """Does the actual change of the font in the view."""
        self._fontdescription.set_size(self._calculate_pango_fontsize())
        self._view.set_font(False, self._get_fontname())

    def _calculate_pango_fontsize(self):
        """Calculate the fontsize based on original size and zoomlevel."""
        return int(self._original_fontsize * self._zoomlevel)

    def _get_fontname(self):
        """Returns the fontname to be used in gedit.View.set_font."""
        return self._fontdescription.to_string()

    def _get_pango_fontsize(self):
        """Gets the current font size in pango units."""
        return self._fontdescription.get_size()

########NEW FILE########
__FILENAME__ = localization
# -*- coding: utf-8 -*-
#
# Zoom - gedit plugin
# Copyright (C) 2010 Christian Luginbhl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import gettext
import os

class Localization():
    """Provides a helper to easily setup l10n."""

    _initialized = False

    _domain = 'messages'
    _locale_path = os.path.join(os.path.dirname(__file__), 'locale')

    @classmethod
    def setup(cls):
        """Sets up the gettext localization."""

        if (not cls._initialized):
            gettext.install(cls._domain, cls._locale_path)
            cls._initialized = True

########NEW FILE########
__FILENAME__ = view_helper
# -*- coding: utf-8 -*-
#
# Zoom - gedit plugin
# Copyright (C) 2010 Christian Luginbhl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import gtk

from fontsize_manipulator import FontsizeManipulator

class ViewHelper:
    """Controls a specific view for font manipulation."""

    def __init__(self, view):
        """Constructor."""
        self._view = view
        self._scroll_handler = self._view.connect('scroll_event',
                                                  self._on_scrolling)
        self._fontsize_manipulator = FontsizeManipulator(self._view)

    def deactivate(self):
        """Resets the font and disconnects the scroll-event."""
        self.reset_font()
        self._view.disconnect(self._scroll_handler)

    def _on_scrolling(self, view, event):
        """Callback on scroll wheel movement."""
        event_consumed = False

        if (event.state & gtk.gdk.CONTROL_MASK):
            if event.direction == gtk.gdk.SCROLL_UP:
                self.enlarge_font()
                event_consumed = True
            elif event.direction == gtk.gdk.SCROLL_DOWN:
                self.shrink_font()
                event_consumed = True
        return event_consumed

    def enlarge_font(self):
        """Enlarges the font of this view."""
        self._fontsize_manipulator.enlarge()

    def shrink_font(self):
        """Shrinks the font of this view."""
        self._fontsize_manipulator.shrink()

    def reset_font(self):
        """Resets the font of this view to ist original size."""
        self._fontsize_manipulator.reset()

########NEW FILE########
__FILENAME__ = window_helper
# -*- coding: utf-8 -*-
#
# Zoom - gedit plugin
# Copyright (C) 2010 Christian Luginbhl
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import gtk
import os

from view_helper import ViewHelper
from localization import Localization

class WindowHelper:
    """Adding ability to change the size of the text."""

    _UI_FILE = os.path.join(os.path.dirname(__file__), 'zoom_menu.ui.xml')

    # defining the accelerators for the different "actions". the first entry
    # is used as the one that generates the accelerator name in the menu
    _ENLARGE_ACCELERATORS = ['<Ctrl>plus', '<Ctrl>equal', '<Ctrl>KP_Add']
    _SHRINK_ACCELERATORS = ['<Ctrl>minus', '<Ctrl>KP_Subtract']
    _RESET_ACCELERATORS = ['<Ctrl>0', '<Ctrl>KP_0', '<Ctrl>KP_Insert']

    def __init__(self, window):
        """Constructor."""
        self._window = window
        self._views = {}

        self._action_group = None
        self._ui_id = None
        self._accel_group = None

        Localization.setup()

        self._insert_menu()
        self._setup_supplementary_accelerators()

        for view in self._window.get_views():
            self._initialize_viewhelper(view)

        self._tab_add_handler = self._window.connect('tab-added',
                                                     self._on_tab_added)
        self._tab_remove_handler = self._window.connect('tab-removed',
                                                        self._on_tab_removed)

    def deactivate(self):
        """Deactivates the plugin for a window."""
        for view in self._window.get_views():
            self._deactivate_viewhelper(view)

        self._views = None

        self._remove_menu()
        self._window.remove_accel_group(self._accel_group)
        self._window.disconnect(self._tab_add_handler)
        self._window.disconnect(self._tab_remove_handler)

        self._plugin = None
        self._window = None

    def update_ui(self):
        """Reacts on user interface updates for a window."""
        self._action_group.set_sensitive(self._has_active_view())

    def _insert_menu(self):
        """Adds the menu entries for zooming."""
        manager = self._window.get_ui_manager()

        self._action_group = gtk.ActionGroup('ZoomPluginActions')

        action_submenu = gtk.Action('ZoomSubMenu',
                                    _('_Zoom'),
                                    _('_Zoom'),
                                    None)

        action_enlarge_font = gtk.Action('EnlargeFont',
                                         _('Zoom _In'),
                                         _('Zoom _In'),
                                         None)
        action_enlarge_font.connect('activate', self._enlarge_font)

        action_shrink_font = gtk.Action('ShrinkFont',
                                        _('Zoom _Out'),
                                        _('Zoom _Out'),
                                        None)
        action_shrink_font.connect('activate', self._shrink_font)

        action_reset_font = gtk.Action('OriginalSize',
                                       _('_Reset'),
                                       _('_Reset'),
                                       None)
        action_reset_font.connect('activate', self._reset_font)

        self._action_group.add_action(action_submenu)

        self._action_group.add_action_with_accel(
                               action_enlarge_font,
                               self.__class__._ENLARGE_ACCELERATORS[0])
        self._action_group.add_action_with_accel(
                               action_shrink_font,
                               self.__class__._SHRINK_ACCELERATORS[0])
        self._action_group.add_action_with_accel(
                               action_reset_font,
                               self.__class__._RESET_ACCELERATORS[0])

        manager.insert_action_group(self._action_group)

        self._ui_id = manager.add_ui_from_file(self.__class__._UI_FILE)

    def _remove_menu(self):
        """Removes the additional menu entries."""
        manager = self._window.get_ui_manager()
        manager.remove_ui(self._ui_id)
        manager.remove_action_group(self._action_group)

        manager.ensure_update()

    def _setup_supplementary_accelerators(self):
        """Adds all supplementary accelerators to the main window."""
        self._accel_group = gtk.AccelGroup()
        self._window.add_accel_group(self._accel_group)

        self._connect_accelerators(self.__class__._ENLARGE_ACCELERATORS[1:],
                                   self._enlarge_font)
        self._connect_accelerators(self.__class__._SHRINK_ACCELERATORS[1:],
                                   self._shrink_font)
        self._connect_accelerators(self.__class__._RESET_ACCELERATORS[1:],
                                   self._reset_font)

    def _connect_accelerators(self, accelerator_list, callback_function):
        """Connects accelerators from a list to a callback."""
        for accelerator in accelerator_list:
            key, mod = gtk.accelerator_parse(accelerator)
            self._accel_group.connect_group(key, mod, 0, callback_function)

    def _on_tab_added(self, window, tab):
        """Callback on new tab added."""
        self._initialize_viewhelper(tab.get_view())

    def _on_tab_removed(self, window, tab):
        """Callback on tab removal - deactivates the ViewHelper."""
        self._deactivate_viewhelper(tab.get_view())

    def _initialize_viewhelper(self, view):
        """Initializes a ViewHelper for view if unknown as of now."""
        if (view and (not view in self._views)):
            self._views[view] = ViewHelper(view)

    def _deactivate_viewhelper(self, view):
        """Deactivates the ViewHelper of view if known."""
        if (view and (view in self._views)):
            self._views[view].deactivate()
            del self._views[view]

    # below are the callbacks that are used for both action and accelerators
    # from the main window. because they have a different method signature
    # but none of the arguments are used, this quite ugly looking all-catching
    # agrs-attribute is used for both.

    def _enlarge_font(self, *args):
        """Callback to enlarge the font on menu click or accelerator."""
        if (self._has_active_view()):
            self._get_active_viewhelper().enlarge_font()

    def _shrink_font(self, *args):
        """Callback to shrink the font on menu click or main accelerator."""
        if (self._has_active_view()):
            self._get_active_viewhelper().shrink_font()

    def _reset_font(self, *args):
        """Callback to reset the font on menu click or main accelerator."""
        if (self._has_active_view()):
            self._get_active_viewhelper().reset_font()

    def _has_active_view(self):
        """Returns 'true' if there is an active view."""
        return (self._window.get_active_view() != None)

    def _get_active_viewhelper(self):
        """Returns the ViewHelper of the active view."""
        return self._views[self._window.get_active_view()]

########NEW FILE########
__FILENAME__ = advancedfind
# -*- encoding:utf-8 -*-


# advancedfind.py is part of advancedfind-gedit.
#
#
# Copyright 2010-2012 swatch
#
# advancedfind-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#



from gi.repository import Gtk, Gedit, Gio
import os.path
import os
import fnmatch
import subprocess
import urllib.request, urllib.parse, urllib.error
import re
#import time
import shutil


from .advancedfind_ui import AdvancedFindUI
from .find_result import FindResultView
from . import config_manager
from .config_ui import ConfigUI


import gettext
APP_NAME = 'advancedfind'
CONFIG_DIR = os.path.expanduser('~/.local/share/gedit/plugins/' + APP_NAME + '/config')
#LOCALE_DIR = '/usr/share/locale'
LOCALE_DIR = os.path.join(os.path.dirname(__file__), 'locale')
if not os.path.exists(LOCALE_DIR):
	LOCALE_DIR = '/usr/share/locale'
try:
	t = gettext.translation(APP_NAME, LOCALE_DIR)
	_ = t.gettext
	#Gtk.glade.bindtextdomain(APP_NAME, LOCALE_DIR)
except:
	pass
#gettext.install(APP_NAME, LOCALE_DIR, unicode=True)


# Menu item example, insert a new item in the Edit menu
ui_str = """<ui>
	<menubar name="MenuBar">
		<menu name="SearchMenu" action="Search">
			<placeholder name="SearchOps_0">
				<menuitem name="advanced_find_active" action="advanced_find_active"/>
				<menuitem name="find_next" action="find_next"/>
				<menuitem name="find_previous" action="find_previous"/>
				<menuitem name="select_find_next" action="select_find_next"/>
				<menuitem name="select_find_previous" action="select_find_previous"/>
				<menuitem name="advanced_find_configure" action="advanced_find_configure"/>
			</placeholder>
		</menu>
	</menubar>
</ui>
"""


class AdvancedFindWindowHelper:
	def __init__(self, plugin, window):
		self._window = window
		self._plugin = plugin
		self.find_ui = None
		self.find_history = []
		self.replace_history = []
		self.filter_history = []
		self.path_history = []
		self.find_bookmarks = []
		self.replace_bookmarks = []
		self.filter_bookmarks = []
		self.path_bookmarks = []
		self.current_search_pattern = ""
		self.current_replace_text = ""
		self.current_file_pattern = "*"
		#self.current_path = ""
		self.forwardFlg = True
		self.scopeFlg = 0
		
		'''
		self.result_highlight_tag = Gtk.TextTag('result_highlight')
		self.result_highlight_tag.set_properties(foreground='yellow',background='red')
		self.result_highlight_tag.set_property('family', 'Serif')
		self.result_highlight_tag.set_property('size-points', 12)
		self.result_highlight_tag.set_property('weight', pango.WEIGHT_BOLD)
		self.result_highlight_tag.set_property('underline', pango.UNDERLINE_DOUBLE)
		self.result_highlight_tag.set_property('style', pango.STYLE_ITALIC)
		#'''
		
		user_configfile = os.path.join(CONFIG_DIR, 'config.xml')
		if not os.path.exists(user_configfile):
			if not os.path.exists(os.path.dirname(user_configfile)):
				os.makedirs(os.path.dirname(user_configfile))
			shutil.copy2(os.path.dirname(__file__) + "/config/config.xml", os.path.dirname(user_configfile))
		#print(os.path.dirname(user_configfile))
		configfile = user_configfile
		#print(configfile)

		self.config_manager = config_manager.ConfigManager(configfile)
		self.find_options = self.config_manager.load_configure('FindOption')
		self.config_manager.to_bool(self.find_options)
		
		self.find_dlg_setting = self.config_manager.load_configure('FindGUI')
		self.config_manager.to_bool(self.find_dlg_setting)

		self.shortcuts = self.config_manager.load_configure('Shortcut')
		self.result_highlight = self.config_manager.load_configure('ResultDisplay')
		
		self.result_gui_settings = self.config_manager.load_configure('ResultGUI')
		self.config_manager.to_bool(self.result_gui_settings)
		
		user_patterns = os.path.join(CONFIG_DIR, 'patterns.xml')
		if not os.path.exists(user_patterns):
			if not os.path.exists(os.path.dirname(user_patterns)):
				os.makedirs(os.path.dirname(user_patterns))
			shutil.copy2(os.path.dirname(__file__) + "/config/patterns.xml", os.path.dirname(user_patterns))
		#print os.path.dirname(user_patterns)
		patternsfile = user_patterns
		#print patternsfile
		
		self.patterns_manager = config_manager.ConfigManager(patternsfile)
		self.find_history = self.patterns_manager.load_list('FindHistory')
		self.replace_history = self.patterns_manager.load_list('ReplaceHistory')
		self.filter_history = self.patterns_manager.load_list('FilterHistory')
		self.path_history = self.patterns_manager.load_list('PathHistory')
		self.find_bookmarks = self.patterns_manager.load_list('FindBookmark')
		self.replace_bookmarks = self.patterns_manager.load_list('ReplaceBookmark')
		self.filter_bookmarks = self.patterns_manager.load_list('FilterBookmark')
		self.path_bookmarks = self.patterns_manager.load_list('PathBookmark')

		self._results_view = FindResultView(window, self.result_gui_settings)
		icon = Gtk.Image.new_from_stock(Gtk.STOCK_FIND_AND_REPLACE, Gtk.IconSize.MENU)
		self._window.get_bottom_panel().add_item(self._results_view, 'AdvancedFindBottomPanel', _("Advanced Find/Replace"), icon)
		
		self.msgDialog = Gtk.MessageDialog(self._window, 
						Gtk.DialogFlags.MODAL | Gtk.DialogFlags.DESTROY_WITH_PARENT,
						Gtk.MessageType.INFO,
						Gtk.ButtonsType.CLOSE,
						None)
		
		# Insert menu items
		self._insert_menu()

	def deactivate(self):
		# Remove any installed menu items
		self._remove_menu()

		self.config_manager.update_configure('FindOption', self.find_options)
		self.config_manager.update_configure('FindGUI', self.find_dlg_setting)
		#self.config_manager.update_configure('Shortcut', self.shortcuts)
		self.config_manager.update_configure('ResultDisplay', self.result_highlight)
		self.result_gui_settings.update(self._results_view.get_show_button_option())
		self.config_manager.update_configure('ResultGUI', self.result_gui_settings)
		self.config_manager.update_config_file(self.config_manager.config_file)
		
		if not self.find_dlg_setting['KEEP_HISTORY']:
			self.find_history = []
			self.replace_history = []
			self.filter_history = []
			self.path_history = []
		self.patterns_manager.update_list('FindHistory', self.find_history)
		self.patterns_manager.update_list('ReplaceHistory', self.replace_history)
		self.patterns_manager.update_list('FilterHistory', self.filter_history)
		self.patterns_manager.update_list('PathHistory', self.path_history)
		self.patterns_manager.update_list('FindBookmark', self.find_bookmarks)
		self.patterns_manager.update_list('ReplaceBookmark', self.replace_bookmarks)
		self.patterns_manager.update_list('FilterBookmark', self.filter_bookmarks)
		self.patterns_manager.update_list('PathBookmark', self.path_bookmarks)
		self.patterns_manager.update_config_file(self.patterns_manager.config_file)

		self._window = None
		self._plugin = None
		self.find_ui = None
		self.find_history = None
		self.replace_history = None
		self.filter_history = None
		self.path_history = None
		self.find_bookmarks = None
		self.replace_bookmarks = None
		self.filter_bookmarks = None
		self.path_bookmarks = None
		self._results_view = None
		
		'''
		self.config_manager.update_config_file(self.config_manager.config_file, 'search_option', self.find_options)
		self.config_manager.update_config_file(self.config_manager.config_file, 'find_dialog', self.find_dlg_setting)
		#self.config_manager.update_config_file(self.config_manager.config_file, 'shortcut', self.shortcuts)
		self.config_manager.update_config_file(self.config_manager.config_file, 'result_highlight', self.result_highlight)
		
		self.result_gui_settings.update(self._results_view.get_show_button_option())
		self.config_manager.update_config_file(self.config_manager.config_file, 'result_gui_settings', self.result_gui_settings)
		#'''
	
	def _insert_menu(self):
		# Get the GtkUIManager
		manager = self._window.get_ui_manager()

		# Create a new action group
		self._action_group = Gtk.ActionGroup("AdvancedFindReplaceActions")
		self._action_group.add_actions( #[("AdvancedFindMenu", None, _('Advanced Find/Replace'))] + \
										[("advanced_find_active", None, _("Advanced Find/Replace"), self.shortcuts['ACTIVATE'], _("Advanced Find/Replace"), self.advanced_find_active),
										("find_next", None, _("Find Next"), self.shortcuts['FIND_NEXT'], _("Find Next"), self.find_next),
										("find_previous", None, _("Find Previous"), self.shortcuts['FIND_PREVIOUS'], _("Find Previous"), self.find_previous),
										("select_find_next", None, _("Select and Find Next"), self.shortcuts['SELECT_FIND_NEXT'], _("Select and Find Next"), self.select_find_next),
										("select_find_previous", None, _("Select and Find Previous"), self.shortcuts['SELECT_FIND_PREVIOUS'], _("Select and Find Previous"), self.select_find_previous),
										("advanced_find_configure", None, _("Advanced Find/Replace Settings"), None, _("Advanced Find/Replace Settings"), self.advanced_find_configure)]) 

		# Insert the action group
		manager.insert_action_group(self._action_group, -1)

		# Merge the UI
		self._ui_id = manager.add_ui_from_string(ui_str)

	def _remove_menu(self):
		# Get the GtkUIManager
		manager = self._window.get_ui_manager()

		# Remove the ui
		manager.remove_ui(self._ui_id)

		# Remove the action group
		manager.remove_action_group(self._action_group)

		# Make sure the manager updates
		manager.ensure_update()

	def update_ui(self):
		self._action_group.set_sensitive(self._window.get_active_document() != None)
		
	def show_message_dialog(self, dlg, text):
		dlg.set_property('text', text)
		dlg.run()
		dlg.hide()
		
	def advanced_find_configure(self, action, data = None):
		config_ui = ConfigUI(self._plugin)
		
	def advanced_find_active(self, action, data = None):
		doc = self._window.get_active_document()
		if not doc:
			return
			
		try:
			start, end = doc.get_selection_bounds()
			search_text = str(doc.get_text(start,end,True))
		except:
			search_text = self.current_search_pattern

		if self.find_ui == None:
			self.find_ui = AdvancedFindUI(self._plugin)
		else:
			self.find_ui.findDialog.present()
			self.find_ui.findTextComboboxtext.grab_focus()
			
		if search_text != "":
			self.find_ui.findTextComboboxtext.get_child().set_text(search_text)
		
		if self.current_replace_text != "":
			self.find_ui.replaceTextComboboxtext.get_child().set_text(self.current_replace_text)


		if self.current_file_pattern != "":
			self.find_ui.filterComboboxtext.get_child().set_text(self.current_file_pattern)

		'''	
		if self.current_path != "":
			self.find_ui.pathComboboxentrytext.get_child().set_text(self.current_path)
		#'''

	def create_regex(self, pattern, find_options):
		if find_options['REGEX_SEARCH'] == False:
			try:
				pattern = re.escape(str(r'%s' % pattern, "utf-8"))
			except:
				pattern = re.escape(r'%s' % pattern)
		else:
			try:
				pattern = str(r'%s' % pattern, "utf-8")
			except:
				pattern = r'%s' % pattern
		
		if find_options['MATCH_WHOLE_WORD'] == True:
			pattern = r'\b%s\b' % pattern
		
		re_flg = re.MULTILINE
		if find_options['MATCH_CASE'] == False:
			re_flg |= re.IGNORECASE
		try:
			regex = re.compile(pattern, re_flg)
		except:
			print('regex compile failed')
			regex = None
		
		return regex
		
	def advanced_find_in_doc(self, doc, search_pattern, find_options, forward_flg = True, replace_flg = False, around_flg = False):
		if search_pattern == "":
			return

		regex = self.create_regex(search_pattern, find_options)
		if not regex:
			return

		if doc.get_has_selection():
			sel_start, sel_end = doc.get_selection_bounds()
			match = regex.search(str(doc.get_text(sel_start, sel_end, True)))
			if match and replace_flg == True:
				if find_options['REGEX_SEARCH'] == False:
					replace_text = str(self.find_ui.replaceTextComboboxtext.get_active_text())
				else:
					replace_text = match.expand(str(self.find_ui.replaceTextComboboxtext.get_active_text()))
				doc.delete_selection(False, False)
				doc.insert_at_cursor(replace_text)
				replace_flg = False
			else:
				if forward_flg == True:
					doc.place_cursor(sel_end)
				else:
					doc.place_cursor(sel_start)
			
		view = self._window.get_active_view()
		start, end = doc.get_bounds()
		text = str(doc.get_text(start, end, True))
		#around_flg = False
		
		if forward_flg == True:
			start_pos = doc.get_iter_at_mark(doc.get_insert()).get_offset()
			end_pos = doc.get_end_iter().get_offset()
			match = regex.search(text, start_pos, end_pos)
			if match:
				result_start = doc.get_iter_at_offset(match.start())
				result_end = doc.get_iter_at_offset(match.end())
				doc.select_range(result_start, result_end)
				view.scroll_to_cursor()
		else:
			start_pos = doc.get_start_iter().get_offset()
			end_pos = doc.get_iter_at_mark(doc.get_insert()).get_offset()
			results = []
			match = regex.search(text, start_pos, end_pos)
			while match:
				results.append(match.span())
				start_pos = match.end() + 1
				match = regex.search(text, start_pos, end_pos)
			results_len = len(results)
			if results_len > 0:
				result_start = doc.get_iter_at_offset(results[results_len-1][0])
				result_end = doc.get_iter_at_offset(results[results_len-1][1])
				doc.select_range(result_start, result_end)
				view.scroll_to_cursor()
				
		if not doc.get_has_selection():
			if find_options['WRAP_AROUND'] == True and around_flg == False:
				if forward_flg == True:
					doc.place_cursor(doc.get_start_iter())
				else:
					doc.place_cursor(doc.get_end_iter())
				self.advanced_find_in_doc(doc, search_pattern, find_options, forward_flg, replace_flg, True)
			else:
				self.show_message_dialog(self.msgDialog, _("Nothing is found."))
				
		if replace_flg == True and doc.get_has_selection():
			if find_options['REGEX_SEARCH'] == False:
				replace_text = str(self.find_ui.replaceTextComboboxtext.get_active_text())
			else:
				replace_text = match.expand(str(self.find_ui.replaceTextComboboxtext.get_active_text()))
			doc.delete_selection(False, False)
			doc.insert_at_cursor(replace_text)
			replace_end = doc.get_iter_at_mark(doc.get_insert())
			replace_start = doc.get_iter_at_offset(replace_end.get_offset() - len(replace_text))
			doc.select_range(replace_start, replace_end)
			view.scroll_to_cursor()

	def auto_select_word(self, pattern=r'[_a-zA-Z][_a-zA-Z0-9]*'):
		doc = self._window.get_active_document()
		if doc.get_has_selection():
			start, end = doc.get_selection_bounds()
			return doc.get_text(start, end, True)
		else:
			current_iter = doc.get_iter_at_mark(doc.get_insert())
			line_num = current_iter.get_line()
			line_start = doc.get_iter_at_line(line_num)
			line_text = doc.get_text(line_start, doc.get_iter_at_line(line_num + 1), True)
			line_start_pos = line_start.get_offset()
			matches = re.finditer(pattern, line_text)
			for match in matches:
				if current_iter.get_offset() in range(line_start_pos + match.start(), line_start_pos + match.end() + 1):
					return match.group(0)
			return ''
					
	def find_next(self, action, data = None):
		#print 'find next'
		self.advanced_find_in_doc(self._window.get_active_document(), self.current_search_pattern, self.find_options, True)
	
	def find_previous(self, action, data = None):
		#print('find previous')
		self.advanced_find_in_doc(self._window.get_active_document(), self.current_search_pattern, self.find_options, False)
		
	def select_find_next(self, action, data = None):
		#print(self.auto_select_word())
		self.advanced_find_in_doc(self._window.get_active_document(), self.auto_select_word(), self.find_options, True)

	def select_find_previous(self, action, data = None):
		#print(self.auto_select_word())
		self.advanced_find_in_doc(self._window.get_active_document(), self.auto_select_word(), self.find_options, False)
		
	def advanced_find_all_in_doc(self, parent_it, doc, search_pattern, find_options, replace_flg = False, selection_only = False):
		if search_pattern == "":
			return
		
		regex = self.create_regex(search_pattern, find_options)
		if not regex:
			return

		self.result_highlight_off(doc)
		start, end = doc.get_bounds()
		text = str(doc.get_text(start, end, True))
		
		start_pos = 0
		end_pos = end.get_offset()
		if selection_only == True:
			try:
				sel_start, sel_end = doc.get_selection_bounds()
			except:
				#print('No selection is found.')
				return

			if sel_start and sel_end:
				start_pos = sel_start.get_offset()
				end_pos = sel_end.get_offset()
			else:
				return

		tree_it = None
		match = regex.search(text, start_pos, end_pos)
		if match:
			if not tree_it:
				doc_uri = doc.get_uri_for_display()
				#print(doc_uri)
				if doc_uri == None:
					uri = ''
				else:
					tab = Gedit.Tab.get_from_document(doc)
					uri = urllib.parse.unquote(doc.get_uri_for_display())
				tree_it = self._results_view.append_find_result_filename(parent_it, doc.get_short_name_for_display(), tab, uri)
			
			if replace_flg == False:
				while(match):
					line_num = doc.get_iter_at_offset(match.start()).get_line()
					line_start_pos = doc.get_iter_at_line(line_num).get_offset()
					match_end_line_cnt = doc.get_iter_at_offset(match.end()).get_line() + 1
					if match_end_line_cnt == doc.get_line_count():
						line_end_pos = end_pos
					else:
						line_end_pos = doc.get_iter_at_line(match_end_line_cnt).get_offset()
					line_text = text[line_start_pos:line_end_pos]
					self._results_view.append_find_result(tree_it, str(line_num+1), line_text, match.start(), match.end()-match.start(), "", line_start_pos)
					if match.start() == match.end():
						start_pos = match.end() + 1
					else:
						start_pos = match.end()
					if start_pos > end_pos:
						break
					match = regex.search(text, start_pos, end_pos)
			else:
				results = []
				replace_offset = 0
				doc.begin_user_action()
				while(match):
					if find_options['REGEX_SEARCH'] == False:
						replace_text = str(self.find_ui.replaceTextComboboxtext.get_active_text())
					else:
						replace_text = match.expand(str(self.find_ui.replaceTextComboboxtext.get_active_text()))
					if match.start() == match.end():
						break
					replace_start_pos = match.start() + replace_offset
					replace_end_pos = match.end() + replace_offset
					replace_start = doc.get_iter_at_offset(replace_start_pos)
					replace_end = doc.get_iter_at_offset(replace_end_pos)
					doc.delete(replace_start, replace_end)
					doc.insert(replace_start, replace_text)
					replace_text_len = len(replace_text)
					results.append([replace_start_pos, replace_text_len])
					replace_offset += replace_text_len - (match.end() - match.start())
					start_pos = match.end()
					if start_pos > end_pos:
						break
					match = regex.search(text, start_pos, end_pos)
				doc.end_user_action()
				
				start, end = doc.get_bounds()
				text = str(doc.get_text(start, end, True))

				for result in results:
					line_num = doc.get_iter_at_offset(result[0]).get_line()
					line_start_pos = doc.get_iter_at_line(line_num).get_offset()
					#line_end_pos = result[0]+result[1]
					match_end_line_cnt = doc.get_iter_at_offset(result[0]+result[1]).get_line() + 1
					if match_end_line_cnt == doc.get_line_count():
						line_end_pos = end_pos
					else:
						line_end_pos = doc.get_iter_at_line(match_end_line_cnt).get_offset()
					'''
					line_end_pos = doc.get_iter_at_line(doc.get_iter_at_offset(result[0]+result[1]).get_line()+1).get_offset()
					if line_end_pos == line_start_pos:
						line_end_pos = end_pos
					#'''
					line_text = text[line_start_pos:line_end_pos]
					self._results_view.append_find_result(tree_it, str(line_num+1), line_text, result[0], result[1], "", line_start_pos, True)
			
		self.result_highlight_on(tree_it)
	
	'''
	def check_file_pattern(self, path, pattern_text):
		pattern_list = re.split('\s*\|\s*', pattern_text)
		#print(os.path.basename(path).strip())
		for pattern in pattern_list:
			if fnmatch.fnmatch(os.path.basename(path).strip(), pattern):
				return True
		return False
	#'''
	
	def find_all_in_dir(self, parent_it, dir_path, file_pattern, search_pattern, find_options, replace_flg = False):
		#start_time = time.time()
		if search_pattern == "":
			return
			
		#d_list = []
		file_list = []
		grep_cmd = ['grep', '-l', '-I']
		if find_options['MATCH_WHOLE_WORD'] == True:
			grep_cmd.append('-w')
		if find_options['MATCH_CASE'] == False:
			grep_cmd.append('-i')
		if find_options['INCLUDE_SUBFOLDER'] == True:
			grep_cmd.append('-R')

		if not file_pattern == '': 
			pattern_list = re.split('\s*\|\s*', file_pattern)
			for f_pattern in pattern_list:
				if f_pattern.startswith('-'):
					grep_cmd.append('--exclude=' + f_pattern[1:])
				else:
					grep_cmd.append('--include=' + f_pattern)

		if find_options['REGEX_SEARCH'] == True:
			grep_cmd = grep_cmd + ['-E', '-e', search_pattern, dir_path]
		else:
			grep_cmd = grep_cmd + ['-F', '-e', search_pattern, dir_path]
		#print(grep_cmd)

		p = subprocess.Popen(grep_cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
		for e in p.stderr:
			print(e)

		for f in p.stdout:
			file_list.append(f[:-1])
			
		
		'''
		for root, dirs, files in os.walk(unicode(dir_path, 'utf-8')):
			for d in dirs:
				d_list.append(os.path.join(root, d))	
			for f in files:
				if self.check_file_pattern(f, unicode(file_pattern, 'utf-8')):
					if find_options['INCLUDE_SUBFOLDER'] == True:
						file_list.append(os.path.join(root, f))
					else:
						if os.path.dirname(f) not in d_list:
							file_list.append(os.path.join(root, f))
				self.find_ui.do_events()
		#'''
					
		#mid_time = time.time()
		#print('Use ' + str(mid_time-start_time) + ' seconds to find files.')
		
		self._results_view.is_busy(True)
		self._results_view.do_events()
					
		for file_path in file_list:
			if os.path.isfile(file_path):
				temp_doc = Gedit.Document()
				#file_uri = 'file://' + file_path
				#temp_doc.load(Gio.file_new_for_uri(file_uri), Gedit.encoding_get_from_charset('utf-8'), 0, 0, False)
				temp_doc.load(Gio.file_new_for_path(bytes.decode(file_path)), Gedit.encoding_get_from_charset('utf-8'), 0, 0, False)
				f_temp = open(file_path, 'r')
				try:
					text = str(f_temp.read())
				except:
					text = f_temp.read()
				f_temp.close()
				temp_doc.set_text(text)
				
				self.advanced_find_all_in_doc(parent_it, temp_doc, search_pattern, find_options, replace_flg)
				self.find_ui.do_events()
				if self._results_view.stopButton.get_sensitive() == False:
					break
				
		self._results_view.is_busy(False)
				
		#end_time = time.time()						
		#print('Use ' + str(end_time-mid_time) + ' seconds to find results.')
		#print('Total use ' + str(end_time-start_time) + ' seconds.')
						
	def result_highlight_on(self, file_it):
		if file_it == None:
			return
		if self._results_view.findResultTreemodel.iter_has_child(file_it):
			tab = self._results_view.findResultTreemodel.get_value(file_it, 3)
			if not tab:
				return
			for n in range(0,self._results_view.findResultTreemodel.iter_n_children(file_it)):
				it = self._results_view.findResultTreemodel.iter_nth_child(file_it, n)
				
				result_start = self._results_view.findResultTreemodel.get_value(it, 4)
				result_len = self._results_view.findResultTreemodel.get_value(it, 5)
				doc = tab.get_document()
				if doc.get_tag_table().lookup('result_highlight') == None:
					tag = doc.create_tag("result_highlight", foreground=self.result_highlight['FOREGROUND_COLOR'], background=self.result_highlight['BACKGROUND_COLOR'])
				doc.apply_tag_by_name('result_highlight', doc.get_iter_at_offset(result_start), doc.get_iter_at_offset(result_start + result_len))
		
	def result_highlight_off(self, doc):
		if doc.get_tag_table().lookup('result_highlight'):
			start, end = doc.get_bounds()
			doc.remove_tag_by_name('result_highlight', start, end)
			
		'''
		start, end = doc.get_bounds()
		if doc.get_tag_table().lookup('result_highlight') == None:
			tag = doc.create_tag("result_highlight", foreground=self.result_highlight['FOREGROUND_COLOR'], background=self.result_highlight['BACKGROUND_COLOR'])
		doc.remove_tag_by_name('result_highlight', start, end)
		#'''

	def show_bottom_panel(self):
		panel = self._window.get_bottom_panel()
		if panel.get_property("visible") == False:
			panel.set_property("visible", True)
		panel.activate_item(self._results_view)
		
	def set_bottom_panel_label(self, text = None, icon = None):
		tab = self._results_view
		if text:
			tab.get_parent().get_tab_label(tab).get_children()[0].get_child().get_children()[1].set_text(_(text))
		else:
			tab.get_parent().get_tab_label(tab).get_children()[0].get_child().get_children()[1].set_text(_("Advanced Find/Replace"))
		if icon:
			tab.get_parent().get_tab_label(tab).get_children()[0].get_child().get_children()[0].set_from_file(icon)
		else:
			tab.get_parent().get_tab_label(tab).get_children()[0].get_child().get_children()[0].set_from_icon_name('gtk-find-and-replace', Gtk.IconSize.MENU)
		
		
		

########NEW FILE########
__FILENAME__ = advancedfind_ui
# -*- encoding:utf-8 -*-


# advancedfind_ui.py is part of advancedfind-gedit.
#
#
# Copyright 2010-2012 swatch
#
# advancedfind-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#


from gi.repository import GObject, Gtk, Gedit, Gio

import os.path
import os
import re
#import config_manager
#import gconf


#Gtk.glade.bindtextdomain('advancedfind', os.path.join(os.path.dirname(__file__), 'locale'))
#Gtk.glade.bindtextdomain('advancedfind', '/usr/share/locale')
#Gtk.glade.textdomain('advancedfind')



class AdvancedFindUI(object):
	def __init__(self, plugin):
		try:
			self._instance, self._window = plugin.get_instance()
		except:
			pass

		gladefile = os.path.join(os.path.dirname(__file__),"FindDialog.glade")
		ui = Gtk.Builder()
		ui.set_translation_domain('advancedfind')
		ui.add_from_file(gladefile)
		ui.connect_signals({ "on_findDialog_destroy" : self.on_findDialog_destroy_action,
							"on_findDialog_focus_in_event": self.on_findDialog_focus_in_event_action,
							"on_findDialog_focus_out_event" : self.on_findDialog_focus_out_event_action,
							"on_findDialog_show" : self.on_findDialog_show_action,
							#"on_findDialog_grab_focus" : self.on_findDialog_focus_in_event_action,
							#"on_findDialog_grab_broken_event" : self.on_findDialog_focus_out_event_action,
							
							"on_findEntry_icon_press" : self.findEntryIconPress,
							"on_replaceEntry_icon_press" : self.replaceEntryIconPress,
							"on_filterEntry_icon_press" : self.filterEntryIconPress,
							"on_pathEntry_icon_press" : self.pathEntryIconPress,
							
							"findTextComboboxtext_changed_cb" : self.findTextComboboxtext_changed,
							"replaceTextComboboxtext_changed_cb" : self.replaceTextComboboxtext_changed,
							"filterComboboxtext_changed_cb" : self.filterComboboxtext_changed,
							"pathComboboxtext_changed_cb" : self.pathComboboxtext_changed,
							
							"on_findButton_clicked" : self.on_findButton_clicked_action,
							"on_replaceButton_clicked" : self.on_replaceButton_clicked_action,
							"on_findAllButton_clicked" : self.on_findAllButton_clicked_action,
							"on_replaceAllButton_clicked" : self.on_replaceAllButton_clicked_action,
							"on_closeButton_clicked" : self.on_closeButton_clicked_action,
							"on_selectPathButton_clicked" : self.on_selectPathButton_clicked_action,
							"on_selectPathDialogOkButton_clicked" : self.on_selectPathDialogOkButton_clicked_action,
							"on_selectPathDialogCancelButton_clicked" : self.on_selectPathDialogCancelButton_clicked_action,
							
							"on_matchWholeWordCheckbutton_toggled" : self.on_matchWholeWordCheckbutton_toggled_action,
							"on_matchCaseCheckbutton_toggled" : self.on_matchCaseCheckbutton_toggled_action,
							"on_wrapAroundCheckbutton_toggled" : self.on_wrapAroundCheckbutton_toggled_action,
							"on_followCurrentDocCheckbutton_toggled" : self.on_followCurrentDocCheckbutton_toggled_action,
							"on_includeSubfolderCheckbutton_toggled" : self.on_includeSubfolderCheckbutton_toggled_action,
							"on_regexSearchCheckbutton_toggled" : self.on_regexSearchCheckbutton_toggled_action,
							
							"on_forwardRadiobutton_toggled" : self.directionRadiobuttonGroup_action,
							"on_backwardRadiobutton_toggled" : self.directionRadiobuttonGroup_action,
							
							"on_currentFileRadiobutton_toggled" : self.scopeRadiobuttonGroup_action,
							"on_allFilesRadiobutton_toggled" : self.scopeRadiobuttonGroup_action,
							"on_allFilesInPathRadiobutton_toggled" : self.scopeRadiobuttonGroup_action,
							"on_currentSelectionRadiobutton_toggled" : self.scopeRadiobuttonGroup_action,
							
							"on_opacityScale_vlaue_changed" : self.on_opacityScale_vlaue_changed_action })

		self.findDialog = ui.get_object("findDialog")
		#self.findDialog.set_keep_above(True)
		self.findDialog.set_transient_for(self._window)

		accelgroup = Gtk.AccelGroup()
		#key, modifier = Gtk.accelerator_parse('Escape')
		#accelgroup.connect(key, modifier, Gtk.AccelFlags.VISIBLE, self.esc_accel_action)
		key, modifier = Gtk.accelerator_parse('Return')
		accelgroup.connect(key, modifier, Gtk.AccelFlags.VISIBLE, self.return_accel_action)
		key, modifier = Gtk.accelerator_parse('KP_Enter')
		accelgroup.connect(key, modifier, Gtk.AccelFlags.VISIBLE, self.return_accel_action)
		self.findDialog.add_accel_group(accelgroup)

		self.findTextComboboxtext = ui.get_object("findTextComboboxtext")
		#self.findTextListstore = ui.get_object("findTextListstore")
		#find_cell = Gtk.CellRendererText()
		#self.findTextComboboxtext.pack_start(find_cell, True)
		#self.findTextComboboxtext.add_attribute(find_cell, 'text', 0)
		self.findTextComboboxtext.set_entry_text_column(0)
		try:
			for find_text in self._instance.find_history:
				self.findTextComboboxtext.prepend_text(find_text)
			for find_text in self._instance.find_bookmarks:
				self.findTextComboboxtext.append_text(find_text)
		except:
			pass

		self.replaceTextComboboxtext = ui.get_object("replaceTextComboboxtext")
		#self.replaceTextListstore = ui.get_object("replaceTextListstore")
		#replace_cell = Gtk.CellRendererText()
		#self.replaceTextComboboxtext.pack_start(replace_cell, True)
		#self.replaceTextComboboxtext.add_attribute(replace_cell, 'text', 0)
		self.replaceTextComboboxtext.set_entry_text_column(0)
		try:
			for replace_text in self._instance.replace_history:
				self.replaceTextComboboxtext.prepend_text(replace_text)
			for replace_text in self._instance.replace_bookmarks:
				self.replaceTextComboboxtext.append_text(replace_text)
		except:
			pass
		
		self.filterComboboxtext = ui.get_object("filterComboboxtext")
		self.filterComboboxtext.set_entry_text_column(0)
		#self.filterComboboxtext.get_child().set_text("*")
		#self.filterComboboxtext.prepend_text("*")
		try:
			for file_filter in self._instance.filter_history:
				self.filterComboboxtext.prepend_text(file_filter)
			for file_filter in self._instance.filter_bookmarks:
				self.filterComboboxtext.append_text(file_filter)
		except:
			pass
			
		self.pathExpander = ui.get_object("pathExpander")
		self.selectPathFilechooserdialog = ui.get_object("selectPathFilechooserdialog")
		
		self.pathComboboxtext = ui.get_object("pathComboboxtext")
		self.pathComboboxtext.set_entry_text_column(0)
			
		try:
			for path in self._instance.path_history:
				self.pathComboboxtext.prepend_text(path)
			for path in self._instance.path_bookmarks:
				self.pathComboboxtext.append_text(path)
		except:
			pass
		
		self.pathExpander = ui.get_object("pathExpander")
		self.pathExpander.set_expanded(self._instance.find_dlg_setting['PATH_EXPANDED'])		
		
		self.matchWholeWordCheckbutton = ui.get_object("matchWholeWordCheckbutton")
		self.matchCaseCheckbutton = ui.get_object("matchCaseCheckbutton")
		self.wrapAroundCheckbutton = ui.get_object("wrapAroundCheckbutton")
		self.followCurrentDocCheckbutton = ui.get_object("followCurrentDocCheckbutton")
		self.includeSubfolderCheckbutton = ui.get_object("includeSubfolderCheckbutton")
		self.regexSearchCheckbutton = ui.get_object("regexSearchCheckbutton")
		
		self.optionsExpander = ui.get_object("optionsExpander")
		self.optionsExpander.set_expanded(self._instance.find_dlg_setting['OPTIONS_EXPANDED'])

		self.forwardRadiobutton = ui.get_object("forwardRadiobutton")
		self.backwardRadiobutton = ui.get_object("backwardRadiobutton")
		if self._instance.forwardFlg == True:
			self.forwardRadiobutton.set_active(True)
		else:
			self.backwardRadiobutton.set_active(True)

		self.currentFileRadiobutton = ui.get_object("currentFileRadiobutton")
		self.allFilesRadiobutton = ui.get_object("allFilesRadiobutton")
		self.allFilesInPathRadiobutton = ui.get_object("allFilesInPathRadiobutton")
		self.currentSelectionRadiobutton = ui.get_object("currentSelectionRadiobutton")
		if self._instance.scopeFlg == 0:
			self.currentFileRadiobutton.set_active(True)
		elif self._instance.scopeFlg == 1:
			self.allFilesRadiobutton.set_active(True)
		elif self._instance.scopeFlg == 2:
			self.allFilesInPathRadiobutton.set_active(True)
		elif self._instance.scopeFlg == 3:
			self.currentSelectionRadiobutton.set_active(True)

		self.findButton = ui.get_object("findButton")
		self.replaceButton = ui.get_object("replaceButton")
		self.findAllButton = ui.get_object("findAllButton")
		self.replaceAllButton = ui.get_object("replaceAllButton")
		self.closeButton = ui.get_object("closeButton")
		self.selectPathButton = ui.get_object("selectPathButton")

		self.findDialog.show()

		self.matchWholeWordCheckbutton.set_active(self._instance.find_options['MATCH_WHOLE_WORD'])
		self.matchCaseCheckbutton.set_active(self._instance.find_options['MATCH_CASE'])
		self.wrapAroundCheckbutton.set_active(self._instance.find_options['WRAP_AROUND'])
		self.followCurrentDocCheckbutton.set_active(self._instance.find_options['FOLLOW_CURRENT_DOC'])
		self.includeSubfolderCheckbutton.set_active(self._instance.find_options['INCLUDE_SUBFOLDER'])
		self.regexSearchCheckbutton.set_active(self._instance.find_options['REGEX_SEARCH'])
		
		self.opacityScale = ui.get_object("opacityScale")
		self.opacityScale.set_value(float(self._instance.find_dlg_setting['OPACITY']))
		self.opacityScale.set_fill_level(float(self._instance.find_dlg_setting['OPACITY']))

	def on_findDialog_destroy_action(self, object):
		try:
			self._instance.find_dlg_setting['PATH_EXPANDED'] = self.pathExpander.get_expanded()
			self._instance.find_dlg_setting['OPTIONS_EXPANDED'] = self.optionsExpander.get_expanded()
			self._instance.find_dlg_setting['OPACITY'] = self.opacityScale.get_value()
			self._instance.find_ui = None
		except:
			pass
			
	def on_findDialog_show_action(self,object):
		if self.followCurrentDocCheckbutton.get_active() == True:
			self.pathComboboxtext.get_child().set_text(os.path.dirname(self._instance._window.get_active_document().get_uri_for_display()))
		else:
			filebrowser_root = self.get_filebrowser_root()
			if filebrowser_root != None and self._instance.find_options['ROOT_FOLLOW_FILEBROWSER'] == True:
				self.pathComboboxtext.get_child().set_text(filebrowser_root)
			else:
				self.pathComboboxtext.get_child().set_text(self.selectPathFilechooserdialog.get_filename())
				
	def findEntryIconPress(self, object, icon_pos, event):
		if icon_pos == 1:	#secondary icon
			#self.findTextComboboxtext.get_model().clear()
			for history_pos in range(0, len(self._instance.find_history)):
				self.findTextComboboxtext.remove(0)
			self._instance.find_history = []
		elif icon_pos == 0:	#primary icon
			text = object.get_text()
			if not text:
				return
			if text not in self._instance.find_bookmarks:
				self.findTextComboboxtext.append_text(text)
				self._instance.find_bookmarks.append(text)
				self.set_bookmark_icon(object, True)
			else:
				idx = self._instance.find_bookmarks.index(text)
				self._instance.find_bookmarks.remove(text)
				self.findTextComboboxtext.remove(idx + len(self._instance.find_history) + 1)
				self.set_bookmark_icon(object, False)
		
	def replaceEntryIconPress(self, object, icon_pos, event):
		if icon_pos == 1:	#secondary icon
			#self.replaceTextComboboxtext.get_model().clear()
			for history_pos in range(0, len(self._instance.replace_history)):
				self.replaceTextComboboxtext.remove(0)
			self._instance.replace_history = []
		elif icon_pos == 0:	#primary icon
			text = object.get_text()
			if not text:
				return
			if text not in self._instance.replace_bookmarks:
				self.replaceTextComboboxtext.append_text(text)
				self._instance.replace_bookmarks.append(text)
				self.set_bookmark_icon(object, True)
			else:
				idx = self._instance.replace_bookmarks.index(text)
				self._instance.replace_bookmarks.remove(text)
				self.replaceTextComboboxtext.remove(idx + len(self._instance.replace_history) + 1)
				self.set_bookmark_icon(object, False)
		
	def filterEntryIconPress(self, object, icon_pos, event):
		if icon_pos == 1:	#secondary icon
			#self.filterComboboxtext.get_model().clear()
			for history_pos in range(0, len(self._instance.filter_history)):
				self.filterComboboxtext.remove(0)
			self._instance.filter_history = []
		elif icon_pos == 0:	#primary icon
			text = object.get_text()
			if not text:
				return
			if text not in self._instance.filter_bookmarks:
				self.filterComboboxtext.append_text(text)
				self._instance.filter_bookmarks.append(text)
				self.set_bookmark_icon(object, True)
			else:
				idx = self._instance.filter_bookmarks.index(text)
				self._instance.filter_bookmarks.remove(text)
				self.filterComboboxtext.remove(idx + len(self._instance.filter_history) + 1)
				self.set_bookmark_icon(object, False)
		
	def pathEntryIconPress(self, object, icon_pos, event):
		if icon_pos == 1:	#secondary icon
			#self.pathComboboxtext.get_model().clear()
			for history_pos in range(0, len(self._instance.path_history)):
				self.pathComboboxtext.remove(0)
			self._instance.path_history = []
		elif icon_pos == 0:	#primary icon
			text = object.get_text()
			if not text:
				return
			if text not in self._instance.path_bookmarks:
				self.pathComboboxtext.append_text(text)
				self._instance.path_bookmarks.append(text)
				self.set_bookmark_icon(object, True)
			else:
				idx = self._instance.path_bookmarks.index(text)
				self._instance.path_bookmarks.remove(text)
				self.pathComboboxtext.remove(idx + len(self._instance.path_history) + 1)
				self.set_bookmark_icon(object, False)
				
	def findTextComboboxtext_changed(self, object):
		entry = object.get_child()
		if object.get_active_text() in self._instance.find_bookmarks:
			self.set_bookmark_icon(entry, True)
		else:
			self.set_bookmark_icon(entry, False)

	def replaceTextComboboxtext_changed(self, object):
		entry = object.get_child()
		if object.get_active_text() in self._instance.replace_bookmarks:
			self.set_bookmark_icon(entry, True)
		else:
			self.set_bookmark_icon(entry, False)

	def filterComboboxtext_changed(self, object):
		entry = object.get_child()
		if object.get_active_text() in self._instance.filter_bookmarks:
			self.set_bookmark_icon(entry, True)
		else:
			self.set_bookmark_icon(entry, False)

	def pathComboboxtext_changed(self, object):
		entry = object.get_child()
		if object.get_active_text() in self._instance.path_bookmarks:
			self.set_bookmark_icon(entry, True)
		else:
			self.set_bookmark_icon(entry, False)
			
	def on_findDialog_focus_in_event_action(self, object, event):
		object.set_opacity(1)
		if self.followCurrentDocCheckbutton.get_active() == True:
			self.pathComboboxtext.get_child().set_text(os.path.dirname(self._instance._window.get_active_document().get_uri_for_display()))
		'''	
		else:
			filebrowser_root = self.get_filebrowser_root()
			if filebrowser_root != None and self._instance.find_options['ROOT_FOLLOW_FILEBROWSER'] == True:
				self.pathComboboxtext.get_child().set_text(filebrowser_root)
			else:
				self.pathComboboxtext.get_child().set_text(self.selectPathFilechooserdialog.get_filename())
		#'''

	def on_findDialog_focus_out_event_action(self, object, event):
		object.set_opacity(self.opacityScale.get_value()/100)
	
	'''	
	def esc_accel_action(self, accelgroup, window, key, modifier):
		window.hide()
	#'''
		
	def return_accel_action(self, accelgroup, window, key, modifier):
		#self.on_findButton_clicked_action(None)
		self.on_findAllButton_clicked_action(None)
		
	def main(self):
		Gtk.main()

	def do_events(self):
		while Gtk.events_pending():
			Gtk.main_iteration()
			
	def add_combobox_list(self):
		find_text = self.findTextComboboxtext.get_active_text()
		replace_text = self.replaceTextComboboxtext.get_active_text()
		file_pattern = self.filterComboboxtext.get_active_text()
		path = self.pathComboboxtext.get_active_text()
		self._instance.current_search_pattern = find_text
		self._instance.current_replace_text = replace_text
		self._instance.current_file_pattern = file_pattern
		#self._instance.current_path = path
		
		if find_text != "" and find_text not in self._instance.find_history:
			#if len(self.findTextComboboxtext.get_model()) == 10:
			if len(self._instance.find_history) == 10:
				self._instance.find_history[0:1] = []
				self.findTextComboboxtext.remove(9)
			self._instance.find_history.append(find_text)
			self.findTextComboboxtext.prepend_text(find_text)
			
		if replace_text != "" and replace_text not in self._instance.replace_history:
			#if len(self.replaceTextComboboxtext.get_model()) == 10:
			if len(self._instance.replace_history) == 10:
				self._instance.replace_history[0:1] = []
				self.replaceTextComboboxtext.remove(9)
			self._instance.replace_history.append(replace_text)
			self.replaceTextComboboxtext.prepend_text(replace_text)
			
		if self._instance.scopeFlg == 2: #files in directory
			if file_pattern != "" and file_pattern not in self._instance.filter_history:
				#if len(self.filterComboboxtext.get_model()) == 10:
				if len(self._instance.filter_history) == 10:
					self._instance.filter_history[0:1] = []
					self.filterComboboxtext.remove(9)
				self._instance.filter_history.append(file_pattern)
				self.filterComboboxtext.prepend_text(file_pattern)
			
			if path != "" and path not in self._instance.path_history:
				#if len(self.pathComboboxtext.get_model()) == 10:
				if len(self._instance.path_history) == 10:
					self._instance.path_history[0:1] = []
					self.pathComboboxtext.remove(9)
				self._instance.path_history.append(path)
				self.pathComboboxtext.prepend_text(path)

	# button actions       
	def on_findButton_clicked_action(self, object):
		doc = self._instance._window.get_active_document()
		if not doc:
			return
		
		search_pattern = self.findTextComboboxtext.get_active_text()
		if search_pattern == "":
			return
		
		self.add_combobox_list()
		self._instance.advanced_find_in_doc(doc, search_pattern, self._instance.find_options, self._instance.forwardFlg)
		
	def on_replaceButton_clicked_action(self, object):
		doc = self._instance._window.get_active_document()
		if not doc:
			return
			
		search_pattern = self.findTextComboboxtext.get_active_text()
		if search_pattern == "":
			return
		
		self.add_combobox_list()
		self._instance.advanced_find_in_doc(doc, search_pattern, self._instance.find_options, self._instance.forwardFlg, True)

	def on_findAllButton_clicked_action(self, object):
		search_pattern = self.findTextComboboxtext.get_active_text()
		if search_pattern == "":
			return
		doc = self._instance._window.get_active_document()
		if not doc:
			return
			
		self._instance.set_bottom_panel_label(_('Finding...'), os.path.join(os.path.dirname(__file__), 'loading.gif'))
		#self._instance._results_view.set_sensitive(False)
		self._instance._results_view.is_busy(True)
		self._instance.show_bottom_panel()
		self.findDialog.hide()
		self.do_events()
			
		self.add_combobox_list()
		
		it = self._instance._results_view.append_find_pattern(search_pattern)
		
		if self._instance.scopeFlg == 0: #current document
			self._instance.advanced_find_all_in_doc(it, doc, search_pattern, self._instance.find_options)
			self._instance._results_view.show_find_result()
		elif self._instance.scopeFlg == 1: #all opened documents
			docs = self._instance._window.get_documents()			
			for doc in docs:
				self._instance.advanced_find_all_in_doc(it, doc, search_pattern, self._instance.find_options)
				self.do_events()
				if self._instance._results_view.stopButton.get_sensitive() == False:
					break
			self._instance._results_view.show_find_result()
		elif self._instance.scopeFlg == 2: #files in directory
			dir_path = self.pathComboboxtext.get_active_text()
			file_pattern = self.filterComboboxtext.get_active_text()
			self._instance.find_all_in_dir(it, dir_path, file_pattern, search_pattern, self._instance.find_options)
			self._instance._results_view.show_find_result()
		elif self._instance.scopeFlg == 3: #current selected text
			self._instance.advanced_find_all_in_doc(it, doc, search_pattern, self._instance.find_options, False, True)
			self._instance._results_view.show_find_result()

		self._instance.set_bottom_panel_label()
		#self._instance._results_view.set_sensitive(True)
		self._instance._results_view.is_busy(False)
		#self.do_events()
		#self.findDialog.destroy()

	def on_replaceAllButton_clicked_action(self, object):
		search_pattern = self.findTextComboboxtext.get_active_text()
		if search_pattern == "":
			return
		doc = self._instance._window.get_active_document()
		if not doc:
			return
			
		self._instance.set_bottom_panel_label(_('Replacing...'), os.path.join(os.path.dirname(__file__), 'loading.gif'))
		#self._instance._results_view.set_sensitive(False)
		self._instance._results_view.is_busy(True)
		self._instance.show_bottom_panel()
		self.findDialog.hide()
		self.do_events()
		
		self.add_combobox_list()

		it = self._instance._results_view.append_find_pattern(search_pattern, True, self.replaceTextComboboxtext.get_child().get_text())
		
		if self._instance.scopeFlg == 0: #current document
			self._instance.advanced_find_all_in_doc(it, doc, search_pattern, self._instance.find_options, True)
			self._instance._results_view.show_find_result()
		elif self._instance.scopeFlg == 1: #all opened documents
			docs = self._instance._window.get_documents()
			for doc in docs:
				self._instance.advanced_find_all_in_doc(it, doc, search_pattern, self._instance.find_options, True)
				self.do_events()
				if self._instance._results_view.stopButton.get_sensitive() == False:
					break
			self._instance._results_view.show_find_result()
		elif self._instance.scopeFlg == 2: #files in directory
			path = str(self._instance._results_view.findResultTreemodel.iter_n_children(None) - 1)
			it = self._instance._results_view.findResultTreemodel.get_iter(path)
			self._instance._results_view.show_find_result()
			self._instance._results_view.findResultTreemodel.set_value(it, 2, _("Replace in this scope is not supported."))
		elif self._instance.scopeFlg == 3: #current selected text
			self._instance.advanced_find_all_in_doc(it, doc, search_pattern, self._instance.find_options, True, True)
			self._instance._results_view.show_find_result()
		
		self._instance.set_bottom_panel_label()
		#self._instance._results_view.set_sensitive(True)
		self._instance._results_view.is_busy(False)
		#self.do_events()
		#self.findDialog.destroy()

	def on_closeButton_clicked_action(self, object):
		self.findDialog.destroy()
		
	def on_selectPathButton_clicked_action(self, object):
		self.selectPathFilechooserdialog.show()

	# select path file chooserr dialog actions
	def on_selectPathDialogOkButton_clicked_action(self, object):
		if self.followCurrentDocCheckbutton.get_active() == True:
			self.followCurrentDocCheckbutton.set_active(False)
		folder_path = self.selectPathFilechooserdialog.get_filename()
		self.selectPathFilechooserdialog.select_filename(folder_path)
		self.pathComboboxtext.get_child().set_text(folder_path)
		self.add_combobox_list()
		self.selectPathFilechooserdialog.hide()
		
	def on_selectPathDialogCancelButton_clicked_action(self, object):
		self.selectPathFilechooserdialog.hide()
		
	# find_options    
	def on_matchWholeWordCheckbutton_toggled_action(self, object):
		self._instance.find_options['MATCH_WHOLE_WORD'] = object.get_active()

	def on_matchCaseCheckbutton_toggled_action(self, object):
		self._instance.find_options['MATCH_CASE'] = object.get_active()

	def on_wrapAroundCheckbutton_toggled_action(self, object):
		self._instance.find_options['WRAP_AROUND'] = object.get_active()
		
	def on_followCurrentDocCheckbutton_toggled_action(self, object):
		self._instance.find_options['FOLLOW_CURRENT_DOC'] = object.get_active()
		if object.get_active() == True:
			self.pathComboboxtext.get_child().set_text(os.path.dirname(self._instance._window.get_active_document().get_uri_for_display()))
		else:
			filebrowser_root = self.get_filebrowser_root()
			if filebrowser_root != None and self._instance.find_options['ROOT_FOLLOW_FILEBROWSER'] == True:
				self.pathComboboxtext.get_child().set_text(filebrowser_root)
			else:
				self.pathComboboxtext.get_child().set_text(self.selectPathFilechooserdialog.get_filename())
			
	def on_includeSubfolderCheckbutton_toggled_action(self, object):
		self._instance.find_options['INCLUDE_SUBFOLDER'] = object.get_active()
		
	def on_regexSearchCheckbutton_toggled_action(self, object):
		self._instance.find_options['REGEX_SEARCH'] = object.get_active()
		
	def on_opacityScale_vlaue_changed_action(self, object):
		object.set_fill_level(object.get_value())

	# radiobutton
	def directionRadiobuttonGroup_action(self, object):
		self._instance.forwardFlg = self.forwardRadiobutton.get_active()

	def scopeRadiobuttonGroup_action(self, object):
		if self.currentFileRadiobutton.get_active() == True:
			self._instance.scopeFlg = 0
		elif self.allFilesRadiobutton.get_active() == True:
			self._instance.scopeFlg = 1
		elif self.allFilesInPathRadiobutton.get_active() == True:
			self._instance.scopeFlg = 2
		elif self.currentSelectionRadiobutton.get_active() == True:
			self._instance.scopeFlg = 3
		
		if self._instance.scopeFlg == 2:
			self.pathExpander.set_sensitive(True)
		else:
			self.pathExpander.set_sensitive(False)
			
	def set_bookmark_icon(self, entry, flg=False):
		image = Gtk.Image()
		if flg:
			image.set_from_file(os.path.join(os.path.dirname(__file__), 'star_y.png'))
		else:
			image.set_from_file(os.path.join(os.path.dirname(__file__), 'star_w.png'))	
		entry.set_icon_from_pixbuf(0, image.get_pixbuf())

	# filebrowser integration
	def get_filebrowser_root(self):
		base_key = 'org.gnome.gedit.plugins.filebrowser'
		setting = Gio.Settings.new(base_key)
		root_str = setting.get_string('virtual-root')
		#print(root_str)
		if not root_str:
			return None
		'''
		path = Gio.Vfs.get_default().get_file_for_uri(root_str).get_path()
		print(path + '#')
		return path
		#'''
		#'''
		if root_str.startswith('file://'):
			return root_str[7:]
		else:
			return None
		#'''
		
		
		'''
		base = u'/apps/gedit-2/plugins/filebrowser/on_load'
		client = gconf.client_get_default()
		client.add_dir(base, gconf.CLIENT_PRELOAD_NONE)
		path = os.path.join(base, u'virtual_root')
		val = client.get(path)
		if val != None:
			path_string = val.get_string()
			idx = path_string.find('://') + 3
			return val.get_string()[idx:]
		return None
		#'''
	


if __name__ == "__main__":
	app = AdvancedFindUI(None)
	app.main()


########NEW FILE########
__FILENAME__ = config_manager
# -*- encoding:utf-8 -*-


# config_manager.py is part of advancedfind-gedit
#
#
# Copyright 2010-2012 swatch
#
# advancedfind-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#



import os
from xml.dom.minidom import parse

class ConfigManager:
	def __init__(self, filename):
		if os.path.exists(filename) == True:
			self.config_file = filename
			self.dom = parse(filename) # parse an XML file by name
			#self.root = self.dom.documentElement
	
	def get_configure(self, branch, attr):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		for node in nodes:
			if node.getAttribute('name') == attr:
				#return node.firstChild.nodeValue
				return node.getAttribute('value')
	
	def load_configure(self, branch):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		dic = {}
		for node in nodes:
			#dic[node.getAttribute('name')] = node.firstChild.nodeValue
			dic[node.getAttribute('name')] = node.getAttribute('value')
		return dic
	
	def load_list(self, branch):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		patterns = []
		for node in nodes:
			patterns.append(node.getAttribute('name'))
		return patterns
	
	def update_list(self, branch, patterns):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		for node in nodes:
			root.removeChild(node).unlink()
		for pattern in patterns:
			node = root.appendChild(self.dom.createElement(branch))
			node.setAttribute('name', pattern)
					
	def update_configure(self, branch, dic):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		for node in nodes:
			#node.firstChild.nodeValue = dic[node.getAttribute('name')]
			node.setAttribute('value', str(dic[node.getAttribute('name')]))
		
	def update_config_file(self, filename):
		xml_text = self.dom.toprettyxml('\t', '\n', 'utf-8')
		
		lines = xml_text.splitlines(True)
		newlines = []
		for line in lines:
			if line not in ['\n', '\t\n']:
				newlines.append(line.decode('utf-8'))
		
		#print("".join(newlines))
		f = open(filename, 'w+')
		f.write("".join(newlines))
		f.close
		
	def boolean(self, string):
		if string.lower() in ['true', 'yes', 'y', 'ok']:
			return True
		elif string.lower() in ['false', 'no', 'n', 'cancel']:
			return False
		else:
			return string
		
	def to_bool(self, dic):
		for key in list(dic.keys()):
			dic[key] = self.boolean(dic[key])

	
if __name__ == '__main__':
	config_manager = ConfigManager('config.xml')
	#print config_manager.get_configure('shortcut', 'ADVANCED_FIND_ACTIVE')
	#print config_manager.convert_to_shortcut_string(config_manager.get_configure('shortcut', 'ADVANCED_FIND_ACTIVE'))


########NEW FILE########
__FILENAME__ = config_ui
# -*- encoding:utf-8 -*-


# config_ui.py is part of advancedfind-gedit.
#
#
# Copyright 2010-2012 swatch
#
# advancedfind-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#




from gi.repository import Gtk, Gedit, Gdk
import os.path
	
#from gettext import gettext as _
APP_NAME = 'advancedfind'
CONFIG_DIR = os.path.expanduser('~/.local/share/gedit/plugins/' + APP_NAME + '/config')


class ConfigUI(object):
	def __init__(self, plugin):
		#self._plugin = plugin
		self._instance, self._window = plugin.get_instance()
	
		#Set the Glade file
		gladefile = os.path.join(os.path.dirname(__file__),"config.glade")
		UI = Gtk.Builder()
		UI.set_translation_domain('advancedfind')
		UI.add_from_file(gladefile)
		self.configWindow = UI.get_object("configWindow")
		#self.configWindow.set_transient_for(self._window)
		
		self.fgColorbutton = UI.get_object("fgColorbutton")
		self.bgColorbutton = UI.get_object("bgColorbutton")
		self.fgColorbutton.set_color(Gdk.color_parse(self._instance.result_highlight['FOREGROUND_COLOR']))
		self.bgColorbutton.set_color(Gdk.color_parse(self._instance.result_highlight['BACKGROUND_COLOR']))
		
		'''
		self.colorThemeComboboxtext = UI.get_object("colorThemeComboboxtext")
		#for root, dirs, files in os.walk(os.path.expanduser('~/.local/share/gedit/plugins/' + APP_NAME + '/config/theme')):
		for root, dirs, files in os.walk(os.path.join(CONFIG_DIR, 'theme')):
			for f in files:
				if f.endswith('.xml'):
					self.colorThemeComboboxtext.append_text(f[0:-4])
		#'''
		
		self.rootFollowFilebrowserCheckbutton = UI.get_object("rootFollowFilebrowserCheckbutton")
		self.rootFollowFilebrowserCheckbutton.set_active(self._instance.find_options['ROOT_FOLLOW_FILEBROWSER'])
		
		self.keepHistoryCheckbutton = UI.get_object("keepHistoryCheckbutton")
		self.keepHistoryCheckbutton.set_active(self._instance.find_dlg_setting['KEEP_HISTORY'])
		
		self.configWindow.show_all()

		signals = { "on_configWindow_destroy" : self.on_configWindow_destroy,
					"on_fgColorbutton_color_set" : self.on_fgColorbutton_color_set,
					"on_bgColorbutton_color_set" : self.on_bgColorbutton_color_set,
					#"on_colorThemeComboboxtext_changed" : self.on_colorThemeComboboxtext_changed,
					#"on_colorThemeComboboxtext_popup" : self.on_colorThemeComboboxtext_popup, 
					"on_rootFollowFilebrowserCheckbutton_toggled" : self.on_rootFollowFilebrowserCheckbutton_toggled,
					"on_keepHistoryCheckbutton_toggled" : self.on_keepHistoryCheckbutton_toggled }
		
		UI.connect_signals(signals)
		
		
	def on_configWindow_destroy(self, widget):
		pass
		
	def on_fgColorbutton_color_set(self, widget):
		self._instance.result_highlight['FOREGROUND_COLOR'] = widget.get_color().to_string()
		
	def on_bgColorbutton_color_set(self, widget):
		self._instance.result_highlight['BACKGROUND_COLOR'] = widget.get_color().to_string()
	
	'''
	def on_colorThemeComboboxtext_changed(self, object):
		print(os.path.expanduser('~/.local/share/gedit/plugins/' + APP_NAME + '/config/theme/') + object.get_active_text() + '.xml')
		
	def on_colorThemeComboboxtext_popup(self, object):
		print('Theme selection popdown.')
		object.remove_all();
		for root, dirs, files in os.walk(os.path.expanduser('~/.local/share/gedit/plugins/' + APP_NAME + '/config/theme')):
			for f in files:
				if f.endswith('.xml'):
					object.append_text(f[0:-4])
	#'''

	def on_rootFollowFilebrowserCheckbutton_toggled(self, widget):
		self._instance.find_options['ROOT_FOLLOW_FILEBROWSER'] = widget.get_active()
		
	def on_keepHistoryCheckbutton_toggled(self, object):
		self._instance.find_dlg_setting['KEEP_HISTORY'] = object.get_active()


if __name__ == '__main__':
	dlg = ConfigUI(None)
	Gtk.main()
	

########NEW FILE########
__FILENAME__ = find_result
# -*- encoding:utf-8 -*-


# find_result.py is part of advancedfind-gedit.
#
#
# Copyright 2010-2012 swatch
#
# advancedfind-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#


from gi.repository import Gtk, Gedit, Gio
import os.path
import urllib.request, urllib.parse, urllib.error
import re
from . import config_manager
import shutil


import gettext
APP_NAME = 'advancedfind'
CONFIG_DIR = os.path.expanduser('~/.local/share/gedit/plugins/' + APP_NAME + '/config')
#LOCALE_DIR = '/usr/share/locale'
LOCALE_DIR = os.path.join(os.path.dirname(__file__), 'locale')
if not os.path.exists(LOCALE_DIR):
	LOCALE_DIR = '/usr/share/locale'
try:
	t = gettext.translation(APP_NAME, LOCALE_DIR)
	_ = t.gettext
	#Gtk.glade.bindtextdomain(APP_NAME, LOCALE_DIR)
except:
	pass
#gettext.install(APP_NAME, LOCALE_DIR, unicode=True)


class FindResultView(Gtk.HBox):
	def __init__(self, window, result_gui_settings):
		Gtk.HBox.__init__(self)
		self._window = window
		self.result_gui_settings = result_gui_settings

		# load color theme of results list	
		user_formatfile = os.path.join(CONFIG_DIR, 'theme/'+self.result_gui_settings['COLOR_THEME']+'.xml')
		if not os.path.exists(user_formatfile):
			if not os.path.exists(os.path.dirname(user_formatfile)):
				os.makedirs(os.path.dirname(user_formatfile))
			shutil.copy2(os.path.dirname(__file__) + "/config/theme/default.xml", os.path.dirname(user_formatfile))
		#print(os.path.dirname(user_formatfile))
		format_file = user_formatfile
		#print(format_file)

		self.result_format = config_manager.ConfigManager(format_file).load_configure('result_format')
		config_manager.ConfigManager(format_file).to_bool(self.result_format)
		
		# initialize find result treeview
		self.findResultTreeview = Gtk.TreeView()
		resultsCellRendererText = Gtk.CellRendererText()
		if self.result_format['BACKGROUND']:
			resultsCellRendererText.set_property('cell-background', self.result_format['BACKGROUND'])
		resultsCellRendererText.set_property('font', self.result_format['RESULT_FONT'])
		
		self.findResultTreeview.append_column(Gtk.TreeViewColumn("line", resultsCellRendererText, markup=1))
		self.findResultTreeview.append_column(Gtk.TreeViewColumn("content", resultsCellRendererText, markup=2))
		#self.findResultTreeview.append_column(Gtk.TreeViewColumn("result_start", Gtk.CellRendererText(), text=4))
		#self.findResultTreeview.append_column(Gtk.TreeViewColumn("result_len", Gtk.CellRendererText(), text=5))
		self.findResultTreeview.append_column(Gtk.TreeViewColumn("uri", resultsCellRendererText, text=6))

		self.findResultTreeview.set_grid_lines(int(self.result_format['GRID_PATTERN']))		# 0: None; 1: Horizontal; 2: Vertical; 3: Both
		self.findResultTreeview.set_headers_visible(self.result_format['SHOW_HEADERS'])
		
		try:
			column_num = self.findResultTreeview.get_n_columns()
		except:
			# For older gtk version.
			column_num = self.findResultTreeview.get_columns()
		if self.result_format['SHOW_HEADERS']:
			for i in range(0, column_num):
				self.findResultTreeview.get_column(i).set_resizable(True)
		else:
			for i in range(0, column_num):
				self.findResultTreeview.get_column(i).set_sizing(1)	# 1=autosizing

		self.findResultTreeview.set_rules_hint(True)
		self.findResultTreemodel = Gtk.TreeStore(int, str, str, object, int, int, str)
		self.findResultTreemodel.set_sort_column_id(0, Gtk.SortType.ASCENDING)
		self.findResultTreeview.connect("cursor-changed", self.on_findResultTreeview_cursor_changed_action)
		self.findResultTreeview.connect("button-press-event", self.on_findResultTreeview_button_press_action)
		self.findResultTreeview.set_model(self.findResultTreemodel)

		# initialize scrolled window
		scrollWindow = Gtk.ScrolledWindow()
		scrollWindow.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
		scrollWindow.add(self.findResultTreeview)
		
		# put a separator
		v_separator1 = Gtk.VSeparator()
		
		# initialize button box
		v_box = Gtk.VBox()
		v_buttonbox = Gtk.VButtonBox()
		v_buttonbox.set_layout(Gtk.ButtonBoxStyle.END)
		v_buttonbox.set_spacing(5)
		v_buttonbox.set_homogeneous(True)
		self.selectNextButton = Gtk.Button(_("Next"))
		self.selectNextButton.set_no_show_all(True)
		self.selectNextButton.connect("clicked", self.on_selectNextButton_clicked_action)
		self.expandAllButton = Gtk.Button(_("Expand All"))
		self.expandAllButton.set_no_show_all(True)
		self.expandAllButton.connect("clicked", self.on_expandAllButton_clicked_action)
		self.collapseAllButton = Gtk.Button(_("Collapse All"))
		self.collapseAllButton.set_no_show_all(True)
		self.collapseAllButton.connect("clicked", self.on_collapseAllButton_clicked_action)
		self.clearHighlightButton = Gtk.Button(_("Clear Highlight"))
		self.clearHighlightButton.set_no_show_all(True)
		self.clearHighlightButton.connect("clicked", self.on_clearHightlightButton_clicked_action)
		self.clearButton = Gtk.Button(_("Clear"))
		self.clearButton.set_no_show_all(True)
		self.clearButton.connect("clicked", self.on_clearButton_clicked_action)
		self.stopButton = Gtk.Button(_("Stop"))
		self.stopButton.set_no_show_all(True)
		self.stopButton.connect("clicked", self.on_stopButton_clicked_action)
		self.stopButton.set_sensitive(False)

		v_buttonbox.pack_start(self.selectNextButton, False, False, 5)
		v_buttonbox.pack_start(self.expandAllButton, False, False, 5)
		v_buttonbox.pack_start(self.collapseAllButton, False, False, 5)
		v_buttonbox.pack_start(self.clearHighlightButton, False, False, 5)
		v_buttonbox.pack_start(self.clearButton, False, False, 5)
		v_buttonbox.pack_start(self.stopButton, False, False, 5)
		v_box.pack_end(v_buttonbox, False, False, 5)
		
		#self._status = Gtk.Label()
		#self._status.set_text('test')
		#self._status.hide()
		#v_box.pack_end(self._status, False)
		
		self.pack_start(scrollWindow, True, True, 5)
		self.pack_start(v_separator1, False, False, 0)
		self.pack_start(v_box, False, False, 5)
		
		self.show_all()
		
		#initialize context menu
		self.contextMenu = Gtk.Menu()
		self.expandAllItem = Gtk.MenuItem.new_with_label(_('Expand All'))
		self.collapseAllItem = Gtk.MenuItem.new_with_label(_('Collapse All'))
		self.clearHighlightItem = Gtk.MenuItem.new_with_label(_('Clear Highlight'))
		self.clearItem = Gtk.MenuItem.new_with_label(_('Clear'))
		self.stopItem = Gtk.MenuItem.new_with_label(_('Stop'))
		self.stopItem.set_sensitive(False)
		self.markupItem = Gtk.MenuItem.new_with_label(_('Markup'))

		self.contextMenu.append(self.expandAllItem)
		self.contextMenu.append(self.collapseAllItem)
		self.contextMenu.append(self.clearHighlightItem)
		self.contextMenu.append(self.clearItem)
		self.contextMenu.append(self.stopItem)
		self.contextMenu.append(self.markupItem)
		
		self.expandAllItem.connect('activate', self.on_expandAllItem_activate)
		self.collapseAllItem.connect('activate', self.on_collapseAllItem_activate)
		self.clearHighlightItem.connect('activate', self.on_clearHighlightItem_activate)
		self.clearItem.connect('activate', self.on_clearItem_activate)
		self.stopItem.connect('activate', self.on_stopItem_activate)
		self.markupItem.connect('activate', self.on_markupItem_activate)

		self.expandAllItem.show()
		self.collapseAllItem.show()
		self.clearHighlightItem.show()
		self.clearItem.show()
		self.stopItem.show()
		#self.markupItem.show()
		
		self.contextMenu.append(Gtk.SeparatorMenuItem())
		
		self.showButtonsItem = Gtk.MenuItem.new_with_label(_('Show Buttons'))
		self.contextMenu.append(self.showButtonsItem)
		self.showButtonsItem.show()
		
		self.showButtonsSubmenu = Gtk.Menu()
		self.showNextButtonItem = Gtk.CheckMenuItem.new_with_label(_('Next'))
		self.showExpandAllButtonItem = Gtk.CheckMenuItem.new_with_label(_('Expand All'))
		self.showCollapseAllButtonItem = Gtk.CheckMenuItem.new_with_label(_('Collapse All'))
		self.showClearHighlightButtonItem = Gtk.CheckMenuItem.new_with_label(_('Clear Highlight'))
		self.showClearButtonItem = Gtk.CheckMenuItem.new_with_label(_('Clear'))
		self.showStopButtonItem = Gtk.CheckMenuItem.new_with_label(_('Stop'))

		self.showButtonsSubmenu.append(self.showNextButtonItem)
		self.showButtonsSubmenu.append(self.showExpandAllButtonItem)
		self.showButtonsSubmenu.append(self.showCollapseAllButtonItem)
		self.showButtonsSubmenu.append(self.showClearHighlightButtonItem)
		self.showButtonsSubmenu.append(self.showClearButtonItem)
		self.showButtonsSubmenu.append(self.showStopButtonItem)
		
		self.showNextButtonItem.connect('activate', self.on_showNextButtonItem_activate)
		self.showExpandAllButtonItem.connect('activate', self.on_showExpandAllButtonItem_activate)
		self.showCollapseAllButtonItem.connect('activate', self.on_showCollapseAllButtonItem_activate)
		self.showClearHighlightButtonItem.connect('activate', self.on_showClearHighlightButtonItem_activate)
		self.showClearButtonItem.connect('activate', self.on_showClearButtonItem_activate)
		self.showStopButtonItem.connect('activate', self.on_showStopButtonItem_activate)
		
		self.showNextButtonItem.show()
		self.showExpandAllButtonItem.show()
		self.showCollapseAllButtonItem.show()
		self.showClearHighlightButtonItem.show()
		self.showClearButtonItem.show()
		self.showStopButtonItem.show()
		
		self.showButtonsItem.set_submenu(self.showButtonsSubmenu)
		
		self.show_buttons()


		
	def do_events(self):
		while Gtk.events_pending():
			Gtk.main_iteration()
			
	def to_xml_text(self, text):
		# & -> &amp;
		# < -> &lt;
		# > -> &gt;
		# ' -> &apos;
		# " -> &quot;
		return text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;').replace("'", '&apos;').replace('"', '&quot;')
		
	def remove_markup(self, text):
		regex = re.compile(r'<.+>([^ <>]+)</.+>')
		return regex.sub(r'\1', text)
		
	def on_findResultTreeview_cursor_changed_action(self, object):
		if object.get_selection():
			model, it = object.get_selection().get_selected()
		else:
			return
		if not it:
			return
		
		try:
			m = re.search('.+(<.+>)+([0-9]+)(<.+>)+.*', model.get_value(it, 1))
			#m = re.search('.+(.+)+([0-9]+)(.+)+.*', model.get_value(it, 1))
			line_num = int(m.group(2))
		except:
			return
		
		result_start = model.get_value(it, 4)
		result_len = model.get_value(it, 5)
		
		parent_it = model.iter_parent(it)
		if parent_it:
			uri = model.get_value(parent_it, 6)
			tab = model.get_value(parent_it, 3)
		else:
			return
			
		# Tab wasn't passed, try to find one		
		if not tab:
			docs = self._window.get_documents()
			for doc in docs:
				if urllib.parse.unquote(doc.get_uri_for_display()) == uri:
					tab = Gedit.Tab.get_from_document(doc)
			
		# Still nothing? Open the file then
		if not tab:
			m = re.search('[a-zA-Z0-9]+\:\/\/.+', uri)
			if m == None:
				tab = self._window.create_tab_from_location(Gio.file_new_for_path(uri), None, line_num, 0, False, False)
			else:
				tab = self._window.create_tab_from_location(Gio.file_new_for_uri(uri), None, line_num, 0, False, False)
			self.do_events()
			
		if tab:
			self._window.set_active_tab(tab)
			doc = tab.get_document()
			doc.select_range(doc.get_iter_at_offset(result_start), doc.get_iter_at_offset(result_start + result_len))
			view = tab.get_view()
			view.scroll_to_cursor()
				
	def on_findResultTreeview_button_press_action(self, object, event):
		if event.button == 3:
			#right button click
			self.contextMenu.popup(None, None, None, None, event.button, event.time)
		
	def on_expandAllItem_activate(self, object):
		self.findResultTreeview.expand_all()
		
	def on_collapseAllItem_activate(self, object):
		self.findResultTreeview.collapse_all()
		
	def on_clearHighlightItem_activate(self, object):
		self.clear_highlight()
		
	def on_clearItem_activate(self, object):
		self.clear_find_result()
		
	def on_stopItem_activate(self, object):
		self.stopButton.set_sensitive(False)
		object.set_sensitive(False)
		
	def on_markupItem_activate(self, object):
		model, it = self.findResultTreeview.get_selection().get_selected()
		if not it:
			return

		self.markup_row(model, it)
	
	def markup_row(self, model, it):
		if not it:
			return
		
		mark_head = '<span background="gray">'
		mark_foot = '</span>'
		line_str = model.get_value(it, 1)
		text_str = model.get_value(it, 2)
		if line_str.startswith(mark_head) and line_str.endswith(mark_foot):
			model.set_value(it, 1, line_str[len(mark_head):-1*len(mark_foot)])
		else:
			model.set_value(it, 1, mark_head + line_str + mark_foot)
		if text_str.startswith(mark_head) and text_str.endswith(mark_foot):
			model.set_value(it, 2, text_str[len(mark_head):-1*len(mark_foot)])
		else:
			model.set_value(it, 2, mark_head + text_str + mark_foot)
			
		if self.findResultTreemodel.iter_has_child(it):
			for i in range(0, self.findResultTreemodel.iter_n_children(it)):
				self.markup_row(model, self.findResultTreemodel.iter_nth_child(it, i))
				
	def on_showNextButtonItem_activate(self, object):
		if self.showNextButtonItem.get_active() == True:
			self.result_gui_settings['NEXT_BUTTON'] = True
			self.selectNextButton.show()
		else:
			self.result_gui_settings['NEXT_BUTTON'] = False
			self.selectNextButton.hide()

	def on_showExpandAllButtonItem_activate(self, object):
		if self.showExpandAllButtonItem.get_active() == True:
			self.result_gui_settings['EXPAND_ALL_BUTTON'] = True
			self.expandAllButton.show()
		else:
			self.result_gui_settings['EXPAND_ALL_BUTTON'] = False
			self.expandAllButton.hide()
		
	def on_showCollapseAllButtonItem_activate(self, object):
		if self.showCollapseAllButtonItem.get_active() == True:
			self.result_gui_settings['COLLAPSE_ALL_BUTTON'] = True
			self.collapseAllButton.show()
		else:
			self.result_gui_settings['COLLAPSE_ALL_BUTTON'] = False
			self.collapseAllButton.hide()
		
	def on_showClearHighlightButtonItem_activate(self, object):
		if self.showClearHighlightButtonItem.get_active() == True:
			self.result_gui_settings['CLEAR_HIGHLIGHT_BUTTON'] = True
			self.clearHighlightButton.show()
		else:
			self.result_gui_settings['CLEAR_HIGHLIGHT_BUTTON'] = False
			self.clearHighlightButton.hide()
		
	def on_showClearButtonItem_activate(self, object):
		if self.showClearButtonItem.get_active() == True:
			self.result_gui_settings['CLEAR_BUTTON'] = True
			self.clearButton.show()
		else:
			self.result_gui_settings['CLEAR_BUTTON'] = False
			self.clearButton.hide()
			
	def on_showStopButtonItem_activate(self, object):
		if self.showStopButtonItem.get_active() == True:
			self.result_gui_settings['STOP_BUTTON'] = True
			self.stopButton.show()
		else:
			self.result_gui_settings['STOP_BUTTON'] = False
			self.stopButton.hide()

	def on_selectNextButton_clicked_action(self, object):
		path, column = self.findResultTreeview.get_cursor()
		if not path:
			return
		it = self.findResultTreemodel.get_iter(path)
		if self.findResultTreemodel.iter_has_child(it):
			self.findResultTreeview.expand_row(path, True)
			it1 = self.findResultTreemodel.iter_children(it)
		else:
			it1 = self.findResultTreemodel.iter_next(it)
			
		if not it1:
			it1 = self.findResultTreemodel.iter_parent(it)
			if not it1:
				return
			else:
				it2 = self.findResultTreemodel.iter_next(it1)
				if not it2:
					it2 = self.findResultTreemodel.iter_parent(it1)
					if not it2:
						return
					else:
						it3 = self.findResultTreemodel.iter_next(it2)
						if not it3:
							return
						else:
							path = self.findResultTreemodel.get_path(it3)
				else:
			 		path = self.findResultTreemodel.get_path(it2)
		else:
			path = self.findResultTreemodel.get_path(it1) 
		self.findResultTreeview.set_cursor(path, column, False)

	def on_clearHightlightButton_clicked_action(self, object):
		self.clear_highlight()
		
	def on_expandAllButton_clicked_action(self, object):
		self.findResultTreeview.expand_all()
		
	def on_collapseAllButton_clicked_action(self, object):
		self.findResultTreeview.collapse_all()
			
		
	def on_clearButton_clicked_action(self, object):
		self.clear_find_result()
		
	def on_stopButton_clicked_action(self, object):
		object.set_sensitive(False)

	def append_find_pattern(self, pattern, replace_flg = False, replace_text = None):
		self.findResultTreeview.collapse_all()
		idx = self.findResultTreemodel.iter_n_children(None)
		header = '#' + str(idx) + ' - '
		if replace_flg == True:
			mode = self.result_format['MODE_REPLACE'] %{'HEADER' : header, 'PATTERN' : self.to_xml_text(str(pattern)), 'REPLACE_TEXT' : self.to_xml_text(str(replace_text))}
			#mode = header + ' Replace ' + pattern + ' with ' + replace_text
			it = self.findResultTreemodel.append(None, [idx, mode, '', None, 0, 0, ''])
		else:
			mode = self.result_format['MODE_FIND'] %{'HEADER' : header, 'PATTERN' : self.to_xml_text(str(pattern))}
			#mode = header + ' Search ' + pattern
			it = self.findResultTreemodel.append(None, [idx, mode, '', None, 0, 0, ''])
		return it
	
	def append_find_result_filename(self, parent_it, filename, tab, uri):
		filename_str = self.result_format['FILENAME'] % {'FILENAME' : self.to_xml_text(str(filename))}
		#filename_str = filename
		it = self.findResultTreemodel.append(parent_it, [0, filename_str, '', tab, 0, 0, uri])
		return it
		
	def append_find_result(self, parent_it, line, text, result_offset_start = 0, result_len = 0, uri = "", line_start_pos = 0, replace_flg = False):
		result_line = self.result_format['LINE'] % {'LINE_NUM' : line}
		#result_line = 'Line ' + str(line) + ' : '
		markup_start = result_offset_start - line_start_pos
		markup_end = markup_start + result_len
		
		text_header = self.to_xml_text(text[0:markup_start])
		text_marked = self.to_xml_text(text[markup_start:markup_end])
		text_footer = self.to_xml_text(text[markup_end:])

		if replace_flg == False:
			result_text = (text_header + self.result_format['FIND_RESULT_TEXT'] % {'RESULT_TEXT' : text_marked} + text_footer).rstrip()
			#result_text = (text_header + text_marked + text_footer).rstrip()
			self.findResultTreemodel.append(parent_it, [int(line), result_line, result_text, None, result_offset_start, result_len, uri])
		else:
			result_text = (text_header + self.result_format['REPLACE_RESULT_TEXT'] % {'RESULT_TEXT' : text_marked} + text_footer).rstrip()
			#result_text = (text_header + text_marked + text_footer).rstrip()
			self.findResultTreemodel.append(parent_it, [int(line), result_line, result_text, None, result_offset_start, result_len, uri])
		
	def show_find_result(self):
		path = Gtk.TreePath.new_from_string(str(self.findResultTreemodel.iter_n_children(None) - 1))
		self.findResultTreeview.expand_row(path, True)
		pattern_it = self.findResultTreemodel.get_iter(path)
		self.findResultTreeview.set_cursor(self.findResultTreemodel.get_path(pattern_it), None, False)
		
		file_cnt = self.findResultTreemodel.iter_n_children(pattern_it)
		total_hits = 0
		for i in range(0, file_cnt):
			it1 = self.findResultTreemodel.iter_nth_child(pattern_it, i)
			hits_cnt = self.findResultTreemodel.iter_n_children(it1)
			total_hits += hits_cnt
			hits_str = self.result_format['HITS_CNT'] % {'HITS_CNT' : str(hits_cnt)}
			#hits_str = str(hits_cnt) + ' hits'
			self.findResultTreemodel.set_value(it1, 2, hits_str)
		total_hits_str = self.result_format['TOTAL_HITS'] % {'TOTAL_HITS': str(total_hits), 'FILES_CNT' : str(file_cnt)}
		#total_hits_str = 'Total ' +  str(total_hits) + ' hits in ' + str(file_cnt)
		self.findResultTreemodel.set_value(pattern_it, 2, total_hits_str)

	def clear_highlight(self):
		for doc in self._window.get_documents():
			start, end = doc.get_bounds()
			if doc.get_tag_table().lookup('result_highlight') == None:
				tag = doc.create_tag("result_highlight", foreground='yellow', background='red')
			doc.remove_tag_by_name('result_highlight', start, end)
		
	def clear_find_result(self):
		try:
			vadj = self._window.get_active_view().get_vadjustment()
			vadj_value = vadj.get_value()
		except:
			self.findResultTreemodel.clear()
			return
		self.findResultTreemodel.clear()
		vadj.set_value(vadj_value)
		
	def get_show_button_option(self):
		return self.result_gui_settings
		
	def show_buttons(self):
		if self.result_gui_settings['NEXT_BUTTON'] == True:
			self.selectNextButton.show()
			self.showNextButtonItem.set_active(True)
		if self.result_gui_settings['EXPAND_ALL_BUTTON'] == True:
			self.expandAllButton.show()
			self.showExpandAllButtonItem.set_active(True)
		if self.result_gui_settings['COLLAPSE_ALL_BUTTON'] == True:
			self.collapseAllButton.show()
			self.showCollapseAllButtonItem.set_active(True)
		if self.result_gui_settings['CLEAR_HIGHLIGHT_BUTTON'] == True:
			self.clearHighlightButton.show()
			self.showClearHighlightButtonItem.set_active(True)
		if self.result_gui_settings['CLEAR_BUTTON'] == True:
			self.clearButton.show()
			self.showClearButtonItem.set_active(True)
		if self.result_gui_settings['STOP_BUTTON'] == True:
			self.stopButton.show()
			self.showStopButtonItem.set_active(True)
			
	def is_busy(self, busy_flg = True):
		if busy_flg:
			self.clearButton.set_sensitive(False)
			self.stopButton.set_sensitive(True)
			self.clearItem.set_sensitive(False)
			self.stopItem.set_sensitive(True)
		else:
			self.clearButton.set_sensitive(True)
			self.stopButton.set_sensitive(False)
			self.clearItem.set_sensitive(True)
			self.stopItem.set_sensitive(False)
		self.do_events()		
	



if __name__ == "__main__":
	view = FindResultView(None)
	window = Gtk.Window(Gtk.WindowType.TOPLEVEL)
	window.add(view)
	window.show_all()
	Gtk.main()



########NEW FILE########
__FILENAME__ = FindInFiles
from gi.repository import Gtk, Gio, GObject, Gedit
import os


class ResultsView(Gtk.VBox):
    def __init__(self, geditwindow):
        GObject.GObject.__init__(self)

        # We have to use .geditwindow specifically here
        #(self.window won't work)
        self.window = geditwindow

        # Save the document's encoding in a variable for later use
        #(when opening new tabs)
        try:
            self.encoding = Gedit.encoding_get_current()
        except:
            self.encoding = Gedit.gedit_encoding_get_current()

        # Preferences (we'll control them with toggled checkboxes)
        self.ignore_comments = False
        self.case_sensitive = False
        self.scan_logs = False

        # We save the grep search result data in a ListStore
        # Format:  ID (COUNT)  |  FILE (without path)
        # |  LINE  |  FILE (with path)
        #    Note: We use the full-path version when opening new tabs
        #(when necessary)
        self.search_data = Gtk.ListStore(str, str, str, str)

        # Create a list (a "tree view" without children) to display the results
        self.results_list = Gtk.TreeView(self.search_data)

        # Get the selection attribute of the results_list and assign
        # a couple of properties
        tree_selection = self.results_list.get_selection()

        # Properties...
        tree_selection.set_mode(Gtk.SelectionMode.SINGLE)
        tree_selection.connect("changed", self.view_result)

        # Create the cells for our results list treeview
        #   Note:  We don't need to create a cell or text renderer
        #          for the full-path filename variable because we
        #          won't actually be displaying that information.
        cell_id = Gtk.TreeViewColumn("#")
        cell_line_number = Gtk.TreeViewColumn("Line")
        cell_filename = Gtk.TreeViewColumn("File")

        # Now add the cell objects to the results_list treeview object
        self.results_list.append_column(cell_id)
        self.results_list.append_column(cell_line_number)
        self.results_list.append_column(cell_filename)

        # Create text-rendering objects so that we can actually
        # see the data that we'll put into the objects
        text_renderer_id = Gtk.CellRendererText()
        text_renderer_filename = Gtk.CellRendererText()
        text_renderer_line_number = Gtk.CellRendererText()

        # Pack the text renderer objects into the cell objects we created
        cell_id.pack_start(text_renderer_id, True)
        cell_filename.pack_start(text_renderer_filename, True)
        cell_line_number.pack_start(text_renderer_line_number, True)

        # Now set the IDs to each of the text renderer objects and
        # set them to "text" mode
        cell_id.add_attribute(text_renderer_id, "text", 0)
        cell_filename.add_attribute(text_renderer_filename, "text", 1)
        cell_line_number.add_attribute(text_renderer_line_number, "text", 2)

        # Create a scrolling window object and add
        # our results_list treeview object to it
        scrolled_window = Gtk.ScrolledWindow()
        scrolled_window.add(self.results_list)

        # Pack in the scrolled window object
        self.pack_start(scrolled_window, True, True, 0)

        # Create a "Find" button; we'll pack it into an HBox in a moment...
        button_find = Gtk.Button("Find")
        button_find.connect("clicked", self.button_press)
        # Create a "search bar" to type the search string into; we'll pack it
        # into the HBox as well...
        self.search_form = Gtk.Entry()
        self.search_form.connect("activate", self.button_press)

        # Here's the HBox I mentioned...
        search_box = Gtk.HBox(False, 0)
        search_box.pack_start(self.search_form, False, False, 0)
        search_box.pack_start(button_find, False, False, 0)

        # Pack the search box (search bar + Find button) into the side panel
        self.pack_start(search_box, False, False, 0)

        # Create a check box to decide whether or not to ignore comments
        self.check_ignore = Gtk.CheckButton("Ignore comments")
        self.check_ignore.connect("toggled", self.toggle_ignore)
        # Pack it in...
        self.pack_start(self.check_ignore, False, False, 0)

        # Create a check box to determine whether to pay attention to case
        self.check_case = Gtk.CheckButton("Case Sensitive")
        self.check_case.connect("toggled", self.toggle_case)
        # Pack it in...
        self.pack_start(self.check_case, False, False, 0)

        # Create a check box to determine whether to pay attention to case
        self.check_logs = Gtk.CheckButton("Scan log/bak files")
        self.check_logs.connect("toggled", self.toggle_logs)
        # Pack it in...
        self.pack_start(self.check_logs, False, False, 0)

        # Show all UI elements
        self.show_all()

    # A click of the "Ignore comments" check box calls to this function
    def toggle_ignore(self, widget):
        self.ignore_comments = not self.ignore_comments

    # A click of the "Case sensitive" check box calls to this function
    def toggle_case(self, widget):
        self.case_sensitive = not self.case_sensitive

    # A click of the "Scan log/bak files" check box calls to this function
    def toggle_logs(self, widget):
        self.scan_logs = not self.scan_logs

    # A call goes to view_result whenever the user clicks on
    # one of the results after a search.  In response to the
    # click, we'll go to that file's tab (or open it in a
    # new tab if they since closed that tab) and scroll to
    # the line that the result appears in.
    def view_result(self, widget):
        # Get the selection object
        tree_selection = self.results_list.get_selection()

        # Get the model and iterator for the row selected
        (model, iterator) = tree_selection.get_selected()

        if (iterator):
            # Get the absolute path of the file
            absolute_path = model.get_value(iterator, 3)

            # Get the line number
            line_number = int(model.get_value(iterator, 2)) - 1

            # Get all open tabs
            documents = self.window.get_documents()

            # Loop through the tabs until we find which one matches the file
            # If we don't find it, we'll create it in a new tab afterwards.
            for each in documents:
                doc = each.get_uri_for_display()

                if (doc.replace("file://", "") == absolute_path):
                         # This sets the active tab to "each"
                    (self.window.set_active_tab
                        (Gedit.Tab.get_from_document(each)))
                    each.goto_line(line_number)

                    # Get the bounds of the document
#                    (start, end) = each.get_bounds()

                    self.window.get_active_view().scroll_to_cursor()

                    return

            # If we got this far, then we didn't find the file open in a tab.
            # Thus, we'll want to go ahead and open it...
            self.window.create_tab_from_location(Gio.File.new_for_path(absolute_path), self.encoding, int(model.get_value(iterator, 2)), 0, False, True)

    # Clicking the "Find" button or hitting return in the search area
    # calls button_press.
    # This function, of course, searches each open document for
    # the search query and
    # displays the results in the side panel.
    def button_press(self, widget):
        # Get all open tabs
        documents = self.window.get_documents()

        # Make sure there are documents to search...
        if (len(documents) == 0):
            return  # Can't search nothing.  :P

        # Let's also make sure the user entered a search string
        if (len(self.search_form.get_text()) <= 0):
            return

        # Create a string that will hold all of the filenames;
        # we'll append it to the grep command string.
        string = ""

        fbroot = self.get_filebrowser_root()
        if fbroot != "" and fbroot is not None:
            location = fbroot.replace("file://", "")
            location = location.replace("%20", "\\ ")
        else:
            return

        #if (not)
        #" -type f -not -regex '.*/.svn.*'"
        #" -type f -not -regex '.*/(.svn|.log|.bak).*'"
        search_filter = ' -type f | egrep -v ".*(\.svn.*|\.git.*)"'
        if (not self.scan_logs):
            search_filter = ' -type f | egrep -v ".*(\.svn.*|\.git.*|\.log|\.bak)"'

        hooray = os.popen("find " + location + search_filter).readlines()
        for hip in hooray:
            string += " \"%s\"" % hip[:-1]

        # str_case_operator will hold the "case insensitive"
        # command if necessary
        str_case_operator = ""
        if (not self.case_sensitive):
            str_case_operator = " -i"

       # Create a pipe and call the grep command, then read it
        pipe = os.popen("grep -n -H" + str_case_operator + " %s %s" % (self.search_form.get_text(), string))
        data = pipe.readlines()

        results = data

        # Clear any current results from the side panel
        self.search_data.clear()

        # Process each result...
        for each in results:
            # Each result will look like this:
            #   FILE (absolute path):Line number:string
            #
            #   ... where string is the line that the search data was found in.
            pieces = each.split(":", 2)

            if (len(pieces) == 3):
                line_number = pieces[1]
                # We just want the filename, not the path
                filename = os.path.basename(pieces[0])
                string = pieces[2].lstrip(" ")  # Remove leading whitespace

                # If we want to ignore comments,
                # then we'll make sure it doesn't start with # or //
                if (self.ignore_comments):
                    if (not string.startswith("#") and
                        not string.startswith("//")):
                        self.search_data.append(("%d" % (len(self.search_data)
                         + 1), filename, line_number, pieces[0]))
                else:
                    self.search_data.append(("%d" % (len(self.search_data) +
                     1), filename, line_number, pieces[0]))

    def get_filebrowser_root(self):
        base = u'org.gnome.gedit.plugins.filebrowser'
        client = Gio.Settings.new(base)
#        client.add_dir(base, GConf.ClientPreloadType.PRELOAD_NONE)
#        path = os.path.join(base, u'virtual_root')
        val = client.get_string('virtual-root')
        if val is not None:
          #also read hidden files setting
#            base = u'org.gnome.gedit.plugins.filebrowser'
#            client = Gio.Settings.new(base)
#            client.add_dir(base, GConf.ClientPreloadType.PRELOAD_NONE)
#            path = os.path.join(base, u'filter_mode')
            try:
                fbfilter = client.get_strv('filter-mode')
            except AttributeError:
                fbfilter = "hidden"
            if 'hide-hidden' in fbfilter:
                self._show_hidden = True
            else:
                self._show_hidden = False
        return val


class PluginHelper:
    def __init__(self, plugin, window):
        self.window = window
        self.plugin = plugin

        self.ui_id = None

        self.add_panel(window)

    def deactivate(self):
        self.remove_menu_item()

        self.window = None
        self.plugin = None

#    def update_ui(self):
#        pass

    def add_panel(self, window):
        panel = self.window.get_side_panel()

        self.results_view = ResultsView(self.window)

        image = Gtk.Image()
        image.set_from_stock(Gtk.STOCK_DND_MULTIPLE, Gtk.IconSize.BUTTON)
        self.ui_id = panel.add_item(self.results_view,
            "FindInDocumentsPanel", "Find in Open Documents", image)

    def remove_menu_item(self):
        panel = self.window.get_side_panel()

        panel.remove_item(self.results_view)


class FindInDocumentsPlugin(GObject.Object, Gedit.WindowActivatable):
    window = GObject.property(type=Gedit.Window)

    def __init__(self):
        GObject.Object.__init__(self)
        self.instances = {}

    def do_activate(self):
        self.instances[self.window] = PluginHelper(self, self.window)

    def do_deactivate(self):
        self.instances[self.window].deactivate()

########NEW FILE########
__FILENAME__ = folding
# -*- coding: utf-8 -*-
from gi.repository import GObject, Gedit, Gtk

ui_str = """<ui>
    <menubar name="MenuBar">
        <menu name="ToolsMenu" action="Tools">
            <placeholder name="ToolsOps_2">
                <menuitem name="ToggleFold" action="ToggleFold"/>
            </placeholder>
            <placeholder name="ToolsOps_2">
                <menuitem name="FoldDeepest" action="FoldDeepest"/>
            </placeholder>
            <placeholder name="ToolsOps_2">
                <menuitem name="UnFoldAll" action="UnFoldAll"/>
            </placeholder>
        </menu>
    </menubar>
</ui>
"""

class FoldingPyPlugin(GObject.Object, Gedit.WindowActivatable):
    __gtype_name__ = 'FoldingPyPlugin'
    window = GObject.property(type=Gedit.Window)
    
    def __init__(self):
        GObject.Object.__init__(self)
    
    def do_activate(self):
        self._insert_menu()
        self.do_update_state()
    
    def do_deactivate(self):
        self._remove_menu()
        self._action_group = None
        #self.fold_off
    
    def do_update_state(self):
        action_group = self._action_group
        action_group.set_sensitive(self.window.get_active_document() != None)
        self.doc = self.window.get_active_document()
        if self.doc:
            self.view = self.window.get_active_view()
            table = self.doc.get_tag_table()
            self.fld = table.lookup('fld')
            if self.fld == None:
                self.fld = self.doc.create_tag('fld', foreground="#333333",
                    paragraph_background="#aadc5c")
            self.inv=table.lookup('inv')
            if self.inv == None:
                self.inv = self.doc.create_tag('inv', invisible=True)
    
    def _insert_menu(self):
        manager = self.window.get_ui_manager()
        self._action_group = Gtk.ActionGroup("FoldingPyPluginActions")
        self._action_group.add_actions([
            ("ToggleFold", None, _("Fold/Unfold"), "<Alt>Z", _("Fold/Unfold"),
                lambda a: self.fold()),
            ("FoldDeepest", None, _("Fold Deepest"), "<Alt>X",
                _("Fold Deepest"), lambda a: self.fold_deepest()),
            ("UnFoldAll", None, _("Un-Fold All"), "<Shift><Alt>X",
                _("Un-Fold All"), lambda a: self.fold_off())
        ])
        manager.insert_action_group(self._action_group, -1)
        self._ui_id = manager.add_ui_from_string(ui_str)
    
    def _remove_menu(self):
        manager = self.window.get_ui_manager()
        manager.remove_ui(self._ui_id)
        manager.remove_action_group(self._action_group)
        manager.ensure_update()
    
    def detect_sps(self,sps):
        sps_lstrip = sps.lstrip()
        i = sps.index(sps_lstrip)
        sps = sps[:i]
        return sps.count(' ') + sps.count('\t') * self.view.get_tab_width()
    
    def fold_deepest(self, action=None):
        deepest = 0
        lines = list()
        s = self.doc.get_iter_at_line(0)
        e = s.copy()
        sg = 0
        eg = 0
        while s.forward_visible_line():
            if s.get_char()!="\n":
                e.set_line(s.get_line())
                e.forward_to_line_end()
                text = s.get_text(e)
                if text.strip()!="":
                    indent = self.detect_sps(text)
                    if indent:
                        if indent > deepest:
                            deepest = indent
                            lines = list()
                            sg = s.get_line()
                            eg = s.get_line()
                        elif indent < deepest and eg:
                            lines.append((sg-1, eg))
                            eg = 0
                        elif indent == deepest:
                            if not eg:
                                sg = s.get_line()
                            eg = s.get_line()
        if eg:
            lines.append((sg-1, eg))
        for (sg, eg) in lines:
            s.set_line(sg)
            e.set_line(eg)
            self.fold(None, s, e)
    def fold_off(self,action=None):
        s , e = self.doc.get_bounds()
        self.doc.remove_tag(self.fld, s, e)
        self.doc.remove_tag(self.inv, s, e)
    def fold(self, action=None, a=None, c=None):
        if a == None:
            a = self.doc.get_iter_at_mark(self.doc.get_insert())
        if a.has_tag(self.fld):
            try:
                a.set_line_offset(0)
                b = a.copy()
                b.forward_line()
                self.doc.remove_tag(self.fld, a, b)
                a.forward_to_tag_toggle(self.inv)
                b.forward_to_tag_toggle(self.inv)
                self.doc.remove_tag(self.inv, a, b)
            except:
                pass
        elif (a != None and c != None) or \
            len(self.doc.get_selection_bounds()) == 2:
            if c == None:
                a, c = self.doc.get_selection_bounds()
            if a.get_line() == c.get_line():
                return
            b = a.copy()
            a.set_line_offset(0)
            b.forward_line()
            c.forward_line()
            self.doc.apply_tag(self.fld,a,b)
            # TODO: Don't remove already folded tags and keep track of nested tags
            self.doc.remove_tag(self.fld, b, c)
            self.doc.remove_tag(self.inv, b, c)
            self.doc.apply_tag(self.inv, b, c)
        else:
            a.set_line_offset(0)
            line = a.get_line()
            sfold = a.copy()
            sfold.forward_line()
            text = a.get_text(sfold)
            if text.strip() != "":
                main_indent = self.detect_sps(text)
                fin = a.copy()
                e = a.copy()
                while 1 == 1:
                    if e.forward_line():
                        if e.get_char() == "\n":
                            continue
                        ne = e.copy()
                        ne.forward_to_line_end()
                        text = e.get_text(ne)
                        if text.strip() == "":
                            continue
                        child_indent = self.detect_sps(text)
                        if child_indent <= main_indent:
                            break
                        else:
                            line = e.get_line()
                        fin.set_line(line)
                        fin.forward_line()
                    else:
                        fin.forward_to_end()
                        line = fin.get_line()
                        break
                if a.get_line() < line:
                    self.doc.apply_tag(self.fld, a, sfold)
                    # TODO: Don't remove already folded tags and
                    # keep track of nested tags
                    self.doc.remove_tag(self.fld, sfold, fin)
                    self.doc.remove_tag(self.inv, sfold, fin)
                    self.doc.apply_tag(self.inv, sfold, fin)

########NEW FILE########
__FILENAME__ = gemini
#        Gedit gemini plugin
#        Copyright (C) 2005-2006    Gary Haran <gary.haran@gmail.com>
#
#        Port to Gedit 3 - Shauna Gordon
#        Copyright (C) 2012 Shauna Gordon <shauna@shaunagordon.com>
#
#        This program is free software; you can redistribute it and/or modify
#        it under the terms of the GNU General Public License as published by
#        the Free Software Foundation; either version 2 of the License, or
#        (at your option) any later version.
#
#        This program is distributed in the hope that it will be useful,
#        but WITHOUT ANY WARRANTY; without even the implied warranty of
#        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.    See the
#        GNU General Public License for more details.
#
#        You should have received a copy of the GNU General Public License
#        along with this program; if not, write to the Free Software
#        Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
#        02110-1301  USA

from gi.repository import Gtk, GObject, Gedit
import re

class GeminiPlugin(GObject.Object, Gedit.WindowActivatable):
    handler_ids = []
    window = GObject.property(type=Gedit.Window)

    def __init__(self):
        GObject.Object.__init__(self)

    def do_activate(self):
        view = self.window.get_active_view()
        self.setup_gemini (view)

    def do_deactivate(self):
        for (handler_id, view) in self.handler_ids:
            if view.handler_is_connected(handler_id):
                view.disconnect(handler_id)


    # Starts auto completion for a given view
    def setup_gemini(self, view):
        if type(view) == Gedit.View:
            if getattr(view, 'gemini_instance', False) == False:
                setattr(view, 'gemini_instance',Gemini())
                handler_id = view.connect ('key-press-event', view.gemini_instance.key_press_handler)
                self.handler_ids.append((handler_id, view))

class Gemini:
    start_keyvals = [34, 39, 96, 40, 91, 123]
    end_keyvals   = [34, 39, 96, 41, 93, 125]
    twin_start    = ['"',"'",'`','(','[','{']
    twin_end      = ['"',"'",'`',')',']','}']

    def __init__(self):
        return

    def key_press_handler(self, view, event):
        buf = view.get_buffer()
        cursor_mark = buf.get_insert()
        cursor_iter = buf.get_iter_at_mark(cursor_mark)

        if event.keyval in self.start_keyvals or event.keyval in self.end_keyvals or event.keyval in (65288, 65293):

            back_iter = cursor_iter.copy()
            back_char = back_iter.backward_char()
            back_char = buf.get_text(back_iter, cursor_iter, True)
            forward_iter = cursor_iter.copy()
            forward_char = forward_iter.forward_char()
            forward_char = buf.get_text(cursor_iter, forward_iter, True)

            if event.keyval in self.start_keyvals:
                index = self.start_keyvals.index(event.keyval)
                start_str = self.twin_start[index]
                end_str = self.twin_end[index]
            else:
                index = -1
                start_str, end_str = None, None

            # Here is the meat of the logic
            if buf.get_has_selection() and event.keyval not in (65288, 65535):
                # pad the selected text with twins
                start_iter, end_iter = buf.get_selection_bounds()
                selected_text = start_iter.get_text(end_iter)
                buf.delete(start_iter, end_iter)
                buf.insert_at_cursor(start_str + selected_text + end_str)
                return True
            elif index >= 0 and start_str == self.twin_start[index]:
                # insert the twin that matches your typed twin
                buf.insert(cursor_iter, end_str)
                if cursor_iter.backward_char():
                    buf.place_cursor (cursor_iter)
            elif event.keyval == 65288 and back_char in self.twin_start and forward_char in self.twin_end:
                # delete twins when backspacing starting char next to ending char
                if self.twin_start.index(back_char) == self.twin_end.index(forward_char):
                    buf.delete(cursor_iter, forward_iter)
            elif event.keyval in self.end_keyvals:
                # stop people from closing an already closed pair
                index = self.end_keyvals.index(event.keyval)
                if self.twin_end[index] == forward_char :
                    buf.delete(cursor_iter, forward_iter)
            elif event.keyval == 65293 and forward_char == '}':
                # add proper indentation when hitting before a closing bracket
                cursor_iter = buf.get_iter_at_mark(buf.get_insert ())
                line_start_iter = cursor_iter.copy()
                view.backward_display_line_start(line_start_iter)

                line = buf.get_text(line_start_iter, cursor_iter, True)
                preceding_white_space_pattern = re.compile(r'^(\s*)')
                groups = preceding_white_space_pattern.search(line).groups()
                preceding_white_space = groups[0]
                plen = len(preceding_white_space)

                buf.insert_at_cursor('\n')
                buf.insert_at_cursor(preceding_white_space)
                buf.insert_at_cursor('\n')

                cursor_mark = buf.get_insert()
                cursor_iter = buf.get_iter_at_mark(cursor_mark)

                buf.insert_at_cursor(preceding_white_space)

                cursor_mark = buf.get_insert()
                cursor_iter = buf.get_iter_at_mark(cursor_mark)

                for i in range(plen + 1):
                    if cursor_iter.backward_char():
                        buf.place_cursor(cursor_iter)
                if view.get_insert_spaces_instead_of_tabs():
                    buf.insert_at_cursor(' ' * view.get_tab_width())
                else:
                    buf.insert_at_cursor('\t')
                return True

########NEW FILE########
__FILENAME__ = line_tools
# Copyright (C) 2010 - Jens Nyman (nymanjens.nj@gmail.com)
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.

from gi.repository import Gtk, GObject, Gedit
import re
import traceback

# UI Manager XML
ACTIONS_UI = """
<ui>
    <menubar name="MenuBar">
        <menu name="EditMenu" action="Edit">
            <placeholder name="EditOps_6">
                <menuitem name="ToggleComment" action="ToggleComment"/>
                <menuitem name="ToggleIndentedComment" action="ToggleIndentedComment"/>
                <menuitem name="DuplicateLine" action="DuplicateLine"/>
                <menuitem name="SelectLine" action="SelectLine"/>
                <menuitem name="SelectText" action="SelectText"/>
                <menuitem name="SelectWord" action="SelectWord"/>
                <menuitem name="AddSemicolon" action="AddSemicolon"/>
            </placeholder>
        </menu>
    </menubar>
</ui>
"""

class LineToolsPlugin(GObject.Object, Gedit.WindowActivatable):
    window = GObject.property(type=Gedit.Window)

    def __init__(self):
        GObject.Object.__init__(self)
        self._instances = {}

    def do_activate(self):
        self._instances[self.window] = LineToolsWindowHelper(self, self.window)

    def do_deactivate(self):
        self._instances[self.window].deactivate()
        del self._instances[self.window]

    def do_update_state(self):
        self._instances[self.window].update_ui()



class LineToolsWindowHelper:
    def __init__(self, plugin, window):
        self._window = window
        self._plugin = plugin
        # Insert menu items
        self._insert_menu()

    def deactivate(self):
        # Remove any installed menu items
        self._remove_menu()
        self._window = None
        self._plugin = None
        self._action_group = None

    def _insert_menu(self):
        # actions
        actions = [
            (
                "ToggleComment", # name
                None, # icon stock id
                "_Toggle Comment", # label
                "<Control>r", # shortcut
                "_Toggle Comment", # tooltip
                self.toggle_comment # callback
            ),
            (
                "ToggleIndentedComment", # name
                None, # icon stock id
                "Toggle _Indented Comment", # label
                "<Control><Shift>r", # shortcut
                "Toggle _Indented Comment", # tooltip
                self.toggle_indented_comment # callback
            ),
            (
                "DuplicateLine", # name
                None, # icon stock id
                "_Duplicate Line", # label
                "<Control>b", # shortcut
                "_Duplicate Line", # tooltip
                self.duplicate_line # callback
            ),
            (
                "SelectLine", # name
                None, # icon stock id
                "_Select Line", # label
                "<Control>l", # shortcut
                "_Select Line", # tooltip
                self.select_line # callback
            ),
            (
                "SelectText", # name
                None, # icon stock id
                "Select _Text", # label
                "<Control>j", # shortcut
                "Select _Text", # tooltip
                self.select_text # callback
            ),
            (
                "SelectWord", # name
                None, # icon stock id
                "Select _Word", # label
                "<Control>m", # shortcut
                "Select _Word", # tooltip
                self.select_word # callback
            ),
            (
                "AddSemicolon", # name
                None, # icon stock id
                "Add Semicolon", # label
                "<Control>semicolon", # shortcut
                "Add Semicolon", # tooltip
                self.add_semicolon # callback
            ),
        ]

        # Create a new action group
        self._action_group = Gtk.ActionGroup(self.__class__.__name__)
        self._action_group.add_actions(actions)
        # Get the GtkUIManager
        manager = self._window.get_ui_manager()
        # Insert the action group
        manager.insert_action_group(self._action_group, -1)
        # Merge the UI
        self._ui_id = manager.add_ui_from_string(ACTIONS_UI)

    def _remove_menu(self):
        # Get the GtkUIManager
        manager = self._window.get_ui_manager()
        # Remove the ui
        manager.remove_ui(self._ui_id)
        # Remove the action group
        manager.remove_action_group(self._action_group)
        # Make sure the manager updates
        manager.ensure_update()

    def update_ui(self):
        self._action_group.set_sensitive(self._window.get_active_document() != None)

        
    ############ plugin core functions ############
    ###################### TOGGLE COMMENT ######################
    # Menu activate handlers
    def toggle_comment(self, action, indented = None):
        document = self._window.get_active_document()
        if not document:
            return
        try:
            bounds = document.get_selection_bounds()
            if len(bounds) == 0:
                ### COMMENT SELECTED LINE ###
                cursor = document.get_iter_at_mark(document.get_insert())
                self.toggle_comment_at_cursor(document, cursor, indented)
            else:
                ### COMMENT SELECTED LINES ###
                # Note:
                #   Bug: when moving a line, the next line also gets selected
                #   Solution: subtract 1 char from end offset, but this would change manual selection,
                #             which can or cannot be desired
                #if bounds[1].get_offset() != document.get_iter_at_mark(document.get_insert()).get_offset():
                bounds[1].set_offset(bounds[1].get_offset() - 1);
                
                cursor = bounds[0].copy()
                start_ln_index = bounds[0].get_line()
                end_ln_index = bounds[1].get_line()
                
                uniform_comment_action = None
                for line_index in range(start_ln_index, end_ln_index + 1):
                    cursor = document.get_iter_at_mark(document.get_insert())
                    cursor.set_line(line_index)
                    (indented, uniform_comment_action) = self.toggle_comment_at_cursor(
                        document, cursor, indented, force_comment = uniform_comment_action)
        except:
            err = "Exception\n"
            err += traceback.format_exc()
            document.set_text(err)
    
    def toggle_comment_at_cursor(self, document, cursor, indented, force_comment = None):
        # get comment code
        import os.path
        path = document.get_uri_for_display()
        if path:
            spli = os.path.splitext(path)
            ext = spli[1][1:]
        else:
            ext = ""
        comment_code = {
            'php': '//',
            'js': '//',
            'c': '//',
            'cpp': '//',
            'cc': '//',
            'h': '//',
            'm': '%',
            'py': '#',
            'sql': '#',
            'java': '//',
            'groovy': '//',
            'tex': '%',
            'sh': '#',
        }.get(ext, "#")

        # get cursor at start
        if not cursor.starts_line():
            cursor.set_line_offset(0)
        # get line
        end = cursor.copy()
        if not end.ends_line():
            end.forward_to_line_end()
        line = document.get_text(cursor, end, False)
        index = 0
        for char in line:
            if char == " " or char == "\t":
                index += 1
                continue
            break
        # keep forcing in mind
        remove_comment = line[index:index + len(comment_code)] == comment_code
        if force_comment:
            if force_comment == 'REMOVE' and not remove_comment:
                return (indented, force_comment)
            remove_comment = force_comment == 'REMOVE'
        if remove_comment:
            # remove comment
            extra = 0
            # remove auto-added space
            if len(line) > index + len(comment_code) and line[index + len(comment_code)] == ' ':
                extra = 1
            # don't remove space before tab
            if len(line) > index + len(comment_code) + 1:
                if line[index + len(comment_code) + 1] == " " or line[index + len(comment_code) + 1] == "\t":
                    extra = 0
            cursor.set_line_offset(index)
            end = cursor.copy()
            end.set_line_offset(index + len(comment_code) + extra)
            document.delete(cursor, end)
            return (indented, 'REMOVE')
        else:
            # add comment
            added_space = " "
            # indented comment: comment right before code
            if indented != None:
                if type(indented) is bool:
                    indent_index = indented = index
                else:
                    indent_index = min(indented, index)
                cursor.set_line_offset(indent_index)
                added_space = ''
                    
            # don't add space before tab
            elif len(line) > 0:
                if line[0] == ' ' or line[0] == "\t":
                    added_space = ""
            cursor.get_buffer().insert(cursor, comment_code + added_space)
            return (indented, 'ADD')

    ###################### TOGGLE INDENTED COMMENT ######################
    def toggle_indented_comment(self, action):
        return self.toggle_comment(action, indented = True)
        
        
    ###################### DUPLICATE LINE ######################
    def duplicate_line(self, action):
        document = self._window.get_active_document()
        if not document:
            return
        try:
            bounds = document.get_selection_bounds()
            if len(bounds) == 0:
                ### COMMENT SELECTED LINE ###
                cursor = document.get_iter_at_mark(document.get_insert())
                start = cursor.copy()
                start.set_line_offset(0)
                end = cursor.copy()
                if not end.ends_line():
                    end.forward_to_line_end()
                self.duplicate_bounds(document, start, end)
            else:
                ### COMMENT SELECTED LINES ###
                # Note:
                #   Bug: when moving a line, the next line also gets selected
                #   Solution: subtract 1 char from end offset, but this would change manual selection,
                #             which can or cannot be desired
                #if bounds[1].get_offset() != document.get_iter_at_mark(document.get_insert()).get_offset():
                bounds[1].set_offset(bounds[1].get_offset() - 1);
                
                start = bounds[0].copy()
                start.set_line_offset(0)
                end = bounds[1].copy()
                if not end.ends_line():
                    end.forward_to_line_end()
                self.duplicate_bounds(document, start, end)
        except:
            err = "Exception\n"
            err += traceback.format_exc()
            document.set_text(err)
    
    def duplicate_bounds(self, doc, start, end):
        NL = '\n'
        text = doc.get_text(start, end, False)
        # filter newlines
        # text = ''.join(c for c in text if c not in ['\n', '\r'])
        text = NL + text
        doc.place_cursor(end)
        doc.insert_at_cursor(text)
        cursor = doc.get_iter_at_mark(doc.get_insert())
        start = cursor.copy()
        start.set_offset(cursor.get_offset() - ( len(text) - 1 ))
        doc.select_range(start, cursor)
        
    ###################### SELECT LINE ######################
    def select_line(self, action):
        document = self._window.get_active_document()
        if not document:
            return
        try:
            cursor = document.get_iter_at_mark(document.get_insert())
            start = cursor.copy()
            start.set_line_offset(0)
            end = cursor.copy()
            if not end.ends_line():
                end.forward_to_line_end()
            document.select_range(start, end)
        except:
            err = "Exception\n"
            err += traceback.format_exc()
            document.set_text(err)
        
    ###################### SELECT TEXT ######################
    def select_text(self, action):
        doc = self._window.get_active_document()
        if not doc:
            return
        try:
            # settings
            NON_TEXT = [' ', '\n', '\r', '\t', '+', '-', '>']
            # get vars
            cursor = doc.get_iter_at_mark(doc.get_insert())
            start = cursor.copy()
            start.set_line_offset(0)
            end = cursor.copy()
            if not end.ends_line():
                end.forward_to_line_end()
            line = doc.get_text(start, end, False)
            # sanity check
            if len(line) == 0:
                return
            # get index where text starts
            start_index = 0
            while start_index < len(line) and line[start_index] in NON_TEXT:
                start_index += 1
            # get index where text ends
            end_index = len(line) - 1
            while line[end_index] in NON_TEXT:
                end_index -= 1
                if end_index < 0:
                    return
            # apply indices and select
            start.set_line_offset(start_index)
            end.set_line_offset(end_index + 1)
            doc.select_range(start, end)
        except:
            err = "Exception\n"
            err += traceback.format_exc()
            doc.set_text(err)
        
    ###################### SELECT WORD ######################
    def select_word(self, action):
        doc = self._window.get_active_document()
        if not doc:
            return
        try:
            # help functions
            def valid_text(start, end):
                if not start or not end:
                    return False
                if start.get_line_offset() > end.get_line_offset():
                    (start, end) = (end, start) # swap
                text = doc.get_text(start, end, False)
                for char in text:
                    if not re.match("\w", char):
                        return False
                return True
            def increment(index, incr):
                newindex = index.copy()
                newindex.set_line_offset(index.get_line_offset() + incr)
                return newindex
            def find_word_bound(index, step):
                condition = lambda x: not index.get_line_offset() == 0 if step < 0 else lambda x: not x.ends_line()
                while condition(index):
                    newindex = increment(index, step)
                    # newindex contains word?
                    if not valid_text(newindex, index):
                        break
                    # save new index
                    index = newindex
                return index
            # get vars
            cursor = doc.get_iter_at_mark(doc.get_insert())
            start = find_word_bound(cursor, -1)
            end = find_word_bound(cursor, +1)
            # select start->end
            doc.select_range(start, end)
        except:
            err = "Exception\n"
            err += traceback.format_exc()
            doc.set_text(err)
        
    ###################### ADD SEMICOLON ######################
    def add_semicolon(self, action):
        doc = self._window.get_active_document()
        if not doc:
            return
        try:
            # get vars
            cursor = doc.get_iter_at_mark(doc.get_insert())
            if not cursor.ends_line():
                cursor.forward_to_line_end()
            # select start->end
            cursor.get_buffer().insert(cursor, ';')
        except:
            err = "Exception\n"
            err += traceback.format_exc()
            doc.set_text(err)
        
        
        
    

########NEW FILE########
__FILENAME__ = macropy
#!/usr/bin/python
# -*- coding: utf-8 -*-

'''
  macropy.py 1.0.0
  
  Inspired on first implementation in C for gedit 2 by Sam K. Raju.
  This version for Gedit 3, by Eduardo Romero <eguaio@gmail.com>, Feb 13, 2012.
 
  This program is free software; you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation; either version 2, or (at your option)
  any later version.
 
  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.
 
  You should have received a copy of the GNU General Public License
  along with this program; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 '''

from gi.repository import GObject, Gtk, Gedit

UI_XML = """<ui>
  <menubar name='MenuBar'>
    <menu name='ToolsMenu' action='Tools'>
      <placeholder name='ToolsOps_3'>
        <menu name='Macro' action='MacroPluginOptions'>
          <menuitem action='StartMacroRecording' 
                    name='Start Macro Recording'/>
          <menuitem action='StopMacroRecording' 
                    name= 'Stop Macro Recording'/>
          <menuitem action='PlaybackMacro' 
                    name= 'Playback Macro'/>
        </menu>
      </placeholder>
    </menu>
  </menubar>
  <toolbar name='ToolBar'>
    <separator/>
    <toolitem action='StartMacroRecording'/>
    <toolitem action='StopMacroRecording'/>
    <toolitem action='PlaybackMacro'/>
    <separator/>
  </toolbar>
</ui>"""

class macropy(GObject.Object, Gedit.WindowActivatable):
    __gtype_name__ = 'Macro'
    window = GObject.property(type=Gedit.Window)
   
    def __init__(self):
        GObject.Object.__init__(self)
        self.macro = []
    
    def _add_ui(self):
        manager = self.window.get_ui_manager()
        self._actions = Gtk.ActionGroup('macro_actions')        
        self._actions.add_actions([ 
            ('MacroPluginOptions', Gtk.STOCK_INFO, 'Macro',None, 
            'Record and playback any key secquence', None),
            ('StartMacroRecording', Gtk.STOCK_MEDIA_RECORD, 
                'Start Recording Macro', 
                None, 'Start macro recording', 
                self.on_start_macro_recording),
            ('StopMacroRecording', Gtk.STOCK_MEDIA_STOP, 
                'Stop Recording Macro', 
                None, 'Stop macro recording', 
                self.on_stop_macro_recording),
            ('PlaybackMacro', Gtk.STOCK_MEDIA_PLAY, 'Playback Macro', 
                '<Ctrl><Alt>m', 'Playback recorded macro', 
                self.on_playback_macro)
        ])
        manager.insert_action_group(self._actions)
        self._ui_merge_id = manager.add_ui_from_string(UI_XML)
        manager.ensure_update()
        
    def do_activate(self):
        self._add_ui()   
        self._actions.get_action('StartMacroRecording').set_sensitive(True)         
        self._actions.get_action('StopMacroRecording').set_sensitive(False)            
        self._actions.get_action('PlaybackMacro').set_sensitive(False)  

    def do_deactivate(self):
        self._remove_ui()
  
    def on_start_macro_recording(self, action, data=None):
        handlers = []
        handler_id = self.window.connect('key-press-event', 
                                          self.on_key_press_event)
        handlers.append(handler_id)
        self.window.set_data('Macro1PluginHandlers', handlers) 
        self.macro = []
        self._actions.get_action('StartMacroRecording').set_sensitive(False)
        self._actions.get_action('StopMacroRecording').set_sensitive(True) 
        self._actions.get_action('PlaybackMacro').set_sensitive(False)

    def on_stop_macro_recording(self, action, data=None):
        handlers = self.window.get_data('Macro1PluginHandlers')
        for handler_id in handlers:
            self.window.disconnect(handler_id)
        self._actions.get_action('StartMacroRecording').set_sensitive(True)
        self._actions.get_action('StopMacroRecording').set_sensitive(False) 
        self._actions.get_action('PlaybackMacro').set_sensitive(True) 

    def on_playback_macro(self, action, data=None):    
        for e in self.macro:
            e.put()     
    
    def on_key_press_event(self, window, event):
        self.macro.append(event.copy())
            
    def _remove_ui(self):
        manager = self.window.get_ui_manager()
        manager.remove_ui(self._ui_merge_id)
        manager.remove_action_group(self._actions)
        manager.ensure_update()

########NEW FILE########
__FILENAME__ = open-uri-context-menu
# Copyright (C) 2007-2008 Martin Szulecki
# Copyright (C) 2011 Jean-Philippe Fleury <contact@jpfleury.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

'''
Adds context menu item to open an URI at the pointer position

Testcases (some still fail):

- #include <linux/smb.h>
- <open-uri-context-menu.plugin>, "open-uri-context-menu.plugin"
- (../plugins/open-uri-context-menu.plugin)
- ~/.local/share/gedit/plugins/open-uri-context-menu.plugin
- http://www.gnome.org/~home/index.php3?test=param&another=one#final_anchor
- www.gnome.org/index.html
- mailto:myself@page.com?subject=Some%20matter+me
- http://www.google.com/search?sourceid=navclient&ie=UTF-8&rls=GGLC,GGLC:1969-53,GGLC:en&q=uri+query
- open-uri-context-menu.plugin,open-uri-context-menu.py
- https://bugzilla.novell.com
- SOMEVAR=file:///var/log/messages

Loads of room for improving the URI detection ;)

Version: 0.4.0
'''

from gettext import gettext as _

from gi.repository import Gtk, Gedit, Gio, GObject
import re
import sys
import os
import subprocess
import string

ACCEPTED_SCHEMES = ['file', 'ftp', 'sftp', 'smb', 'dav', 'davs', 'ssh', 'http', 'https']

RE_DELIM = re.compile(r'[\w#/\?:%@&\=\+\.\\~-]+', re.UNICODE|re.MULTILINE)
RE_URI_RFC2396 = re.compile("((([a-zA-Z][0-9a-zA-Z+\\-\\.]*):)?/{0,2}([0-9a-zA-Z;:,/\?@&=\+\$\.\-_!~\*'\(\)%]+))?(#[0-9a-zA-Z;,/\?:@&\=+$\.\\-_!~\*'\(\)%]+)?")

class OpenURIContextMenuPlugin(GObject.Object, Gedit.WindowActivatable):
	__gtype_name__ = "OpenURIContextMenuPlugin"
	window = GObject.property(type=Gedit.Window)

	def __init__(self):
		GObject.Object.__init__(self)

		self.uri = ""
		self.window = None
		self.id_name = 'OpenURIContextMenuPluginID'
		self.encoding = Gedit.encoding_get_from_charset("UTF-8")

	def do_activate(self):
#		self.window = window

		handler_ids = []
		for signal in ('tab-added', 'tab-removed'):
			method = getattr(self, 'on_window_' + signal.replace('-', '_'))
			handler_ids.append(self.window.connect(signal, method))
		self.window.set_data(self.id_name, handler_ids)

		for view in self.window.get_views():
			self.connect_view(view)

	def do_deactivate(self):
		widgets = [self.window] + self.window.get_views()
		for widget in widgets:
			handler_ids = widget.get_data(self.id_name)
			if not handler_ids is None:
				for handler_id in handler_ids:
					widget.disconnect(handler_id)
			widget.set_data(self.id_name, None)

		self.window = None

	def connect_view(self, view):
		handler_id = view.connect('populate-popup', self.on_view_populate_popup)
		view.set_data(self.id_name, [handler_id])

	def update_ui(self, window):
		pass

	def browse_url(self, menu_item, url):
		command = ['xdg-open', url]

		# Avoid to run the browser as user root
		if os.getuid() == 0 and os.environ.has_key('SUDO_USER'):
			command = ['sudo', '-u', os.environ['SUDO_USER']] + command

		subprocess.Popen(command)

	def on_window_tab_added(self, window, tab):
		self.connect_view(tab.get_view())

	def on_window_tab_removed(self, window, tab):
		pass

	def on_view_populate_popup(self, view, menu):
		doc = view.get_buffer()

		win = view.get_window(Gtk.TextWindowType.TEXT);
		ptr_window, x, y, mod = win.get_pointer()
		x, y = view.window_to_buffer_coords(Gtk.TextWindowType.TEXT, x, y);

		# First try at pointer location
		insert = view.get_iter_at_location(x, y);
		
		# Second try at cursor
		if insert == None:
			insert = doc.get_iter_at_mark(doc.get_insert())
			
		while insert.forward_char():
			if not RE_DELIM.match(insert.get_char()):
				break

		start = insert.copy()
		while start.backward_char():
			if not RE_DELIM.match(start.get_char()):
				start.forward_char();
				break

		word = unicode(doc.get_text(start, insert, False))

		if len(word) == 0:
			return True

		word = self.validate_uri(word)
		if not word:
			return True
		
		displayed_word = word
		if len(displayed_word) > 50:
			displayed_word = displayed_word[:50] + u"\u2026"
		
		browse_to = False
		if word.startswith("http://") or word.startswith("https://"):
			browse_to = True
		
		if browse_to:
			browse_uri_item = Gtk.ImageMenuItem(_("Browse to '%s'") % (displayed_word))
			browse_uri_item.set_image(Gtk.Image.new_from_stock(Gtk.STOCK_JUMP_TO, Gtk.IconSize.MENU))
			browse_uri_item.connect('activate', self.browse_url, word);
			browse_uri_item.show();
		
		displayed_word = displayed_word.replace('file://', '')
		open_uri_item = Gtk.ImageMenuItem(_("Open '%s'") % (displayed_word))
		open_uri_item.set_image(Gtk.Image.new_from_stock(Gtk.STOCK_OPEN, Gtk.IconSize.MENU))
		open_uri_item.connect('activate', self.on_open_uri_activate, word);
		open_uri_item.show();

		separator = Gtk.SeparatorMenuItem()
		separator.show();

		menu.prepend(separator)
		menu.prepend(open_uri_item)

		if browse_to:
			menu.prepend(browse_uri_item)
		return True
	
	def on_open_uri_activate(self, menu_item, uri):
		self.open_uri(uri)
		return True

	def validate_uri(self, uri):
		m = RE_URI_RFC2396.search(uri);
		if not m:
			return False
		
		target = m.group()

		if m.group(2) != None:
			if m.group(3) in ACCEPTED_SCHEMES:
				return target
			else:
				return False
		else:
			if m.group(4).startswith("www."):
				return 'http://' + target
		
		target = os.path.expanduser(target)

		if os.path.isfile(target):
			if os.path.isabs(target):
				return 'file://' + target
		
		doc_dir = self.window.get_active_document().get_uri()
		if doc_dir != None:
			if doc_dir.startswith('file://'):
				f = os.path.join(os.path.dirname(doc_dir), target)
				if os.path.isfile(f.replace('file://', '', 1)):
					return f
			else:
				return os.path.join(os.path.dirname(doc_dir), target)
		
		paths = string.split(os.environ["PATH"], os.pathsep)
		for dirname in paths:
			f = os.path.join(os.path.dirname(dirname), 'include', target)
			if os.path.isfile(f):
				return 'file://' + f

		return False

	def get_document_by_uri(self, uri):
		docs = self.window.get_documents()

		for d in docs [:]:
			if d.get_location() == uri:
				return d
		return None

	def open_uri(self, uri):
		doc = self.get_document_by_uri(uri)
		if doc != None :
			tab = Gedit.tab_get_from_document(doc)
			self.window.set_active_tab(tab)
		else:
			self.window.create_tab_from_location(Gio.file_new_for_uri(uri), self.encoding, 0, 0, False, True)
			status = self.window.get_statusbar()
			status_id = status.push(status.get_context_id(self.id_name), _("Loading file '%s'...") % (uri))
			GObject.timeout_add(4000, self.on_statusbar_timeout, status, status.get_context_id(self.id_name), status_id)

	def on_statusbar_timeout(self, status, context_id, status_id):
		status.remove(context_id, status_id)
		return False


########NEW FILE########
__FILENAME__ = pair_char_completion
# -*- coding: utf-8 -*-
#
# Gedit plugin that does automatic pair character completion.
#
# Copyright  2010, Kevin McGuinness <kevin.mcguinness@gmail.com>
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
#

__version__ = '1.0.4'
__author__ = 'Kevin McGuinness'

from gi.repository import Gtk, Gedit, GObject, Gdk
import sys
import os

# Defaults
DEFAULT_STMT_TERMINATOR = ';'
LANG_META_STMT_TERMINATOR_KEY = 'statement-terminator'
NEWLINE_CHAR = '\n'

# Map from language identifiers to (opening parens, closing parens) pairs
language_parens = {}

def add_language_parenthesis(name, spec):
  """Add parenthesis for the given language. The spec should be a string in
     which each pair of characters represents a pair of parenthesis for the
     language, eg. "(){}[]".
  """
  parens = [], []
  for i in range(0, len(spec), 2):
    parens[0].append(spec[i+0])
    parens[1].append(spec[i+1])
  language_parens[name] = parens

def to_char(keyval_or_char):
  """Convert a event keyval or character to a character"""
  if isinstance(keyval_or_char, str):
    return keyval_or_char
  return chr(keyval_or_char) if 0 < keyval_or_char < 128 else None

class PairCompletionPlugin(GObject.Object, Gedit.WindowActivatable):
  """Automatic pair character completion for gedit"""

  ViewHandlerName = 'pair_char_completion_handler'

  window = GObject.property(type=Gedit.Window)

  def __init__(self):
    GObject.Object.__init__(self)
    self.ctrl_enter_enabled = True
    self.language_id = 'plain'
    self.opening_parens = language_parens['default'][0]
    self.closing_parens = language_parens['default'][1]

  def do_activate(self):
    self.do_update_state()

  def do_deactivate(self):
    for view in self.window.get_views():
      handler_id = getattr(view, self.ViewHandlerName, None)
      if handler_id is not None:
        view.disconnect(handler_id)
      setattr(view, self.ViewHandlerName, None)

  def do_update_state(self):
    self.update_ui()


  def update_ui(self):
    view = self.window.get_active_view()
    doc = self.window.get_active_document()
    if isinstance(view, Gedit.View) and doc:
      if getattr(view, self.ViewHandlerName, None) is None:
        handler_id = view.connect('key-press-event', self.on_key_press, doc)
        setattr(view, self.ViewHandlerName, handler_id)

  def is_opening_paren(self,char):
    return char in self.opening_parens

  def is_closing_paren(self,char):
    return char in self.closing_parens

  def get_matching_opening_paren(self,closer):
    try:
      return self.opening_parens[self.closing_parens.index(closer)]
    except ValueError:
      return None

  def get_matching_closing_paren(self,opener):
    try:
      return self.closing_parens[self.opening_parens.index(opener)]
    except ValueError:
      return None

  def would_balance_parens(self, doc, closing_paren):
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    opening_paren = self.get_matching_opening_paren(closing_paren)
    balance = 1
    while balance != 0 and not iter1.is_start():
      iter1.backward_char()
      if iter1.get_char() == opening_paren:
        balance -= 1
      elif iter1.get_char() == closing_paren:
        balance += 1
    return balance == 0

  def compare_marks(self, doc, mark1, mark2):
    return doc.get_iter_at_mark(mark1).compare(doc.get_iter_at_mark(mark2))

  def enclose_selection(self, doc, opening_paren):
    closing_paren = self.get_matching_closing_paren(opening_paren)
    doc.begin_user_action()
    mark1 = doc.get_insert()
    mark2 = doc.get_selection_bound()
    if self.compare_marks(doc, mark1, mark2) > 0:
      mark1, mark2 = mark2, mark1
    doc.insert(doc.get_iter_at_mark(mark1), opening_paren)
    doc.insert(doc.get_iter_at_mark(mark2), closing_paren)
    iter1 = doc.get_iter_at_mark(mark2)
    doc.place_cursor(iter1)
    doc.end_user_action()
    return True

  def auto_close_paren(self, doc, opening_paren):
    closing_paren = self.get_matching_closing_paren(opening_paren)
    doc.begin_user_action()
    doc.insert_at_cursor(opening_paren+closing_paren)
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    iter1.backward_char()
    doc.place_cursor(iter1)
    doc.end_user_action()
    return True

  def move_cursor_forward(self, doc):
    doc.begin_user_action()
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    iter1.forward_char()
    doc.place_cursor(iter1)
    doc.end_user_action()
    return True

  def move_to_end_of_line_and_insert(self, doc, text):
    doc.begin_user_action()
    mark = doc.get_insert()
    iter1 = doc.get_iter_at_mark(mark)
    iter1.set_line_offset(0)
    iter1.forward_to_line_end()
    doc.place_cursor(iter1)
    doc.insert_at_cursor(text)
    doc.end_user_action()
    return True

  def insert_two_lines(self, doc, text):
    doc.begin_user_action()
    mark = doc.get_insert()
    iter1 = doc.get_iter_at_mark(mark)
    doc.place_cursor(iter1)
    doc.insert_at_cursor(text)
    doc.insert_at_cursor(text)
    mark = doc.get_insert()
    iter2 = doc.get_iter_at_mark(mark)
    iter2.backward_chars(len(text))
    doc.place_cursor(iter2)
    doc.end_user_action()
    return True

  def get_char_under_cursor(self, doc):
    return doc.get_iter_at_mark(doc.get_insert()).get_char()

  def get_stmt_terminator(self, doc):
    terminator = DEFAULT_STMT_TERMINATOR
    lang = doc.get_language()
    if lang is not None:
      # Allow this to be changed by the language definition
      lang_terminator = lang.get_metadata(LANG_META_STMT_TERMINATOR_KEY)
      if lang_terminator is not None:
        terminator = lang_terminator
    return terminator

  def get_current_line_indent(self, doc):
    it_start = doc.get_iter_at_mark(doc.get_insert())
    it_start.set_line_offset(0)
    it_end = it_start.copy()
    it_end.forward_to_line_end()
    indentation = []
    while it_start.compare(it_end) < 0:
      char = it_start.get_char()
      if char == ' ' or char == '\t':
        indentation.append(char)
      else:
        break
      it_start.forward_char()
    return ''.join(indentation)

  def is_ctrl_enter(self, event):
    return (self.ctrl_enter_enabled and
      event.keyval == Gdk.KEY_Return and
      event.get_state() & Gdk.ModifierType.CONTROL_MASK)

  def should_auto_close_paren(self, doc):
    iter1 = doc.get_iter_at_mark(doc.get_insert())
    if iter1.is_end() or iter1.ends_line():
      return True
    char = iter1.get_char()
    return not (char.isalnum() or char == '_')

  def update_language(self, doc):
    lang = doc.get_language()
    lang_id = lang.get_id() if lang is not None else 'plain'
    if lang_id != self.language_id:
      parens = language_parens.get(lang_id, language_parens['default'])
      self.opening_parens = parens[0]
      self.closing_parens = parens[1]
      self.language_id = lang_id

  def on_key_press(self, view, event, doc):
    handled = False
    self.update_language(doc)
    ch = to_char(event.keyval)
    key = Gdk.keyval_name(event.keyval)
    if self.is_closing_paren(ch):
      # Skip over closing parenthesis if doing so would mean that the
      # preceeding parenthesis are correctly balanced
      if (self.get_char_under_cursor(doc) == ch and
          self.would_balance_parens(doc, ch)):
        handled = self.move_cursor_forward(doc)
    if not handled and self.is_opening_paren(ch):
      if doc.get_has_selection():
        # Enclose selection in parenthesis or quotes
        handled = self.enclose_selection(doc, ch)
      elif self.should_auto_close_paren(doc):
        # Insert matching closing parenthesis and move cursor back one
        handled = self.auto_close_paren(doc, ch)
    if not handled and self.is_ctrl_enter(event):
      # Handle Ctrl+Return and Ctrl+Shift+Return
      text_to_insert = NEWLINE_CHAR + self.get_current_line_indent(doc)
      if event.get_state() & Gdk.EventMask.SHIFT_MASK:
        text_to_insert = self.get_stmt_terminator(doc) + text_to_insert
      self.move_to_end_of_line_and_insert(doc, text_to_insert)
      view.scroll_mark_onscreen(doc.get_insert())
      handled = True
    if not handled and key in ('Enter', 'Return', 'ISO_Return'):
      # Enter was just pressed
      char_under_cusor = self.get_char_under_cursor(doc)
      if (self.is_closing_paren(char_under_cusor) and
        self.would_balance_parens(doc, char_under_cusor)):
        # If the character under the cursor would balance parenthesis
        text_to_insert = NEWLINE_CHAR + self.get_current_line_indent(doc)
        self.insert_two_lines(doc, text_to_insert)
        handled = True
    return handled

# Load language parenthesis
for path in sys.path:
  fn = os.path.join(path, 'pair_char_lang.py')
  if os.path.isfile(fn):
    execfile(fn, {'lang': add_language_parenthesis})
    break

########NEW FILE########
__FILENAME__ = pair_char_lang
# -*- coding: utf-8 -*-
#
# Programming language pair char support
#
# The default set is used if the language is not specified below. The plain
# set is used for plain text, or when the document has no specified language.
#
lang('default',    '(){}[]""\'\'``')
lang('changelog',  '(){}[]""<>')
lang('html',       '(){}[]""<>')
lang('ruby',       '(){}[]""\'\'``||')
lang('xml',        '(){}[]""<>')
lang('php',        '(){}[]""<>')
lang('plain',      '(){}[]""')
lang('latex',      '(){}[]""$$`\'')

########NEW FILE########
__FILENAME__ = restoretabs
import os
from gi.repository import GObject, GLib, Gtk, Gio, Gedit

SETTINGS_SCHEMA = "org.gnome.gedit.plugins.restoretabs"

class RestoreTabsWindowActivatable(GObject.Object, Gedit.WindowActivatable):
    __gtype_name__ = "RestoreTabsWindowActivatable"
    window = GObject.property(type=Gedit.Window)

    def __init__(self):
        GObject.Object.__init__(self)
        self._handlers = []
    
    def do_activate(self):
        handlers = []
        handler_id = self.window.connect("delete-event", 
                                         self.on_window_delete_event)                             
        self._handlers.append(handler_id)
        self._temp_handler = self.window.connect("show", self.on_window_show)  

    def do_deactivate(self):
        [self.window.disconnect(handler_id) for handler_id in self._handlers]
    
    def do_update_state(self):
        pass
        
    def is_first_window(self):
        app = Gedit.App.get_default()
        if len(app.get_windows()) <= 1:
            return True
        else:
            return False

    def on_window_delete_event(self, window, event, data=None):
        uris = []
        for document in window.get_documents():
            gfile = document.get_location()
            if gfile:
                uris.append(gfile.get_uri())
        settings = Gio.Settings.new(SETTINGS_SCHEMA)
        settings.set_value('uris', GLib.Variant("as", uris))
        return False
    
    def on_window_show(self, window, data=None):
        if self.is_first_window():
            tab = self.window.get_active_tab()
            if tab.get_state() == 0 and not tab.get_document().get_location():
                self.window.close_tab(tab)
            settings = Gio.Settings.new(SETTINGS_SCHEMA)
            uris = settings.get_value('uris')
            if uris:
                for uri in uris:
                    location = Gio.file_new_for_uri(uri)
                    tab = self.window.get_tab_from_location(location)
                    if not tab:
                        self.window.create_tab_from_location(location, None, 0, 
                                                             0, False, True)
            self.window.disconnect(self._temp_handler)


########NEW FILE########
__FILENAME__ = rubyonrailsloader
# Copyright (C) 2011 Hassan Zamani
# Thanks to Alexandre da Silva
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
# details.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 51
# Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

"""Automatically detects if file resides in a ruby on rails application and set the properly language."""

import os
from gi.repository import GObject, Gedit, GtkSource

class RubyOnRailsLoader(GObject.Object, Gedit.WindowActivatable):
    __gtype_name__ = "RubyOnRailsLoader"
    name = __gtype_name__
    
    window = GObject.property(type=Gedit.Window)
    
    def __init__(self):
        GObject.Object.__init__(self)
    

    def do_activate(self):
        handler_id = self.window.connect("tab-added", self.on_tab_added)
        self.window.set_data(self.name,  handler_id)
        for doc in self.window.get_documents():
            self.connect_document(doc)


    def do_deactivate(self):
        handler_id = self.window.get_data(self.name)
        self.window.disconnect(handler_id)
        self.window.set_data(self.name, None)
    

    def do_update_state(self):
        pass
        

    def on_tab_added(self, window, tab):
        doc = tab.get_document()
        self.connect_document(doc)
        

    def connect_document(self, doc):
        """Connect to doc's `load` signal."""
        handler_id = doc.connect("loaded", self.on_document_load)
        doc.set_data(self.name, handler_id)
        

    def on_document_load(self, doc, *args):
        language = doc.get_language()
        if language:
            lang = language.get_id()
            if lang == 'ruby':
                uri = doc.get_uri_for_display()
                if self.get_in_rails(uri):
                    lang = GtkSource.LanguageManager.get_default().get_language('rubyonrails')
                    doc.set_language(lang)


    def get_in_rails(self, uri):
        rails_root = self.get_data('RailsLoaderRoot')
        if rails_root:
            return rails_root
        base_dir = os.path.dirname(uri)
        depth = 10
        while depth > 0:
            depth -= 1
            app_dir = os.path.join(base_dir, 'app')
            config_dir = os.path.join(base_dir, 'config')
            environment_file = os.path.join(base_dir, 'config', 'environment.rb')
            if os.path.isdir(app_dir) and os.path.isdir(config_dir) and os.path.isfile(environment_file):
                rails_root = base_dir
                break
            else:
                base_dir = os.path.abspath(os.path.join(base_dir, '..'))
        if rails_root:
            self.set_data('RailsLoaderRoot', rails_root)
            return True
        return False


    def set_data(self, name, value):
        self.window.get_active_tab().get_view().set_data(name, value)


    def get_data(self, name):
        return self.window.get_active_tab().get_view().get_data(name)


########NEW FILE########
__FILENAME__ = config_manager
# -*- encoding:utf-8 -*-


# config_manager.py is part of smart-highlighting-gedit.
#
#
# Copyright 2010-2012 swatch
#
# smart-highlighting-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#



import os
from xml.dom.minidom import parse

class ConfigManager:
	def __init__(self, filename):
		if os.path.exists(filename) == True:
			self.config_file = filename
			self.dom = parse(filename) # parse an XML file by name
			#self.root = self.dom.documentElement
	
	def get_configure(self, branch, attr):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		for i in range(0, len(nodes)):
			if nodes[i].getAttribute('name') == attr:
				return nodes[i].firstChild.nodeValue
	
	def load_configure(self, branch):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		dic = {}
		for i in range(0, len(nodes)):
			dic[nodes[i].getAttribute('name')] = nodes[i].firstChild.nodeValue
		return dic
	
	def update_config_file(self, filename, branch, dic):
		root = self.dom.documentElement
		nodes = root.getElementsByTagName(branch)
		for i in range(0, len(nodes)):
			nodes[i].firstChild.nodeValue = dic[nodes[i].getAttribute('name')]

		f = open(filename, 'w+')
		#print(bytes.decode(self.dom.toprettyxml('', '', 'utf-8'), 'utf-8'))
		f.write(bytes.decode(self.dom.toprettyxml('', '', 'utf-8'), 'utf-8'))
		f.close
		
	def boolean(self, string):
		return string.lower() in ['true', 'yes', 't', 'y', 'ok', '1']
		
	def to_bool(self, dic):
		for key in list(dic.keys()):
			dic[key] = self.boolean(dic[key])

	
if __name__ == '__main__':
	pass

########NEW FILE########
__FILENAME__ = config_ui
# -*- encoding:utf-8 -*-


# config_ui.py is part of smart-highlighting-gedit
#
#
# Copyright 2010-2012 swatch
#
# smart-highlighting-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#



#import sys
from gi.repository import Gtk, Gedit, Gdk
import os.path

#Gtk.glade.bindtextdomain('smart-highlight', os.path.join(os.path.dirname(__file__), 'locale'))
#Gtk.glade.textdomain('smart-highlight')


class ConfigUI(object):
	def __init__(self, plugin):
		#self._plugin = plugin
		self._instance, self._window = plugin.get_instance()
	
		#Set the Glade file
		gladefile = os.path.join(os.path.dirname(__file__),"config.glade")
		UI = Gtk.Builder()
		UI.set_translation_domain('smart_highlight')
		UI.add_from_file(gladefile)
		self.configWindow = UI.get_object("configWindow")
		self.matchWholeWordCheckbutton = UI.get_object("matchWholeWordCheckbutton")
		self.matchCaseCheckbutton = UI.get_object("matchCaseCheckbutton")
		self.regexSearchCheckbutton = UI.get_object("regexSearchCheckbutton")
		self.fgColorbutton = UI.get_object("fgColorbutton")
		self.bgColorbutton = UI.get_object("bgColorbutton")
		
		self.matchWholeWordCheckbutton.set_active(self._instance.options['MATCH_WHOLE_WORD'])
		self.matchCaseCheckbutton.set_active(self._instance.options['MATCH_CASE'])
		self.regexSearchCheckbutton.set_active(self._instance.options['REGEX_SEARCH'])
		self.fgColorbutton.set_color(Gdk.color_parse(self._instance.smart_highlight['FOREGROUND_COLOR']))
		self.bgColorbutton.set_color(Gdk.color_parse(self._instance.smart_highlight['BACKGROUND_COLOR']))
			
		self.configWindow.show_all()

		signals = { "on_configWindow_destroy" : self.on_configWindow_destroy,
					"on_matchWholeWordCheckbutton_toggled" : self.on_matchWholeWordCheckbutton_toggled,
					"on_matchCaseCheckbutton_toggled" : self.on_matchCaseCheckbutton_toggled,
					"on_regexSearchCheckbutton_toggled": self.on_regexSearchCheckbutton_toggled,
					"on_fgColorbutton_color_set" : self.on_fgColorbutton_color_set,
					"on_bgColorbutton_color_set" : self.on_bgColorbutton_color_set }
		
		UI.connect_signals(signals)
		
		
	def on_configWindow_destroy(self, widget):
		pass
		
	def on_matchWholeWordCheckbutton_toggled(self, widget):
		self._instance.options['MATCH_WHOLE_WORD'] = widget.get_active()
		
	def on_matchCaseCheckbutton_toggled(self, widget):
		self._instance.options['MATCH_CASE'] = widget.get_active()
	
	def on_regexSearchCheckbutton_toggled(self, widget):
		self._instance.options['REGEX_SEARCH'] = widget.get_active()
		
	def on_fgColorbutton_color_set(self, widget):
		self._instance.smart_highlight['FOREGROUND_COLOR'] = widget.get_color().to_string()
		
	def on_bgColorbutton_color_set(self, widget):
		self._instance.smart_highlight['BACKGROUND_COLOR'] = widget.get_color().to_string()	


if __name__ == '__main__':
	dlg = ConfigUI(None)
	Gtk.main()


########NEW FILE########
__FILENAME__ = smart_highlight
# -*- encoding:utf-8 -*-


# smart_highlight.py is part of smart-highlighting-gedit.
#
#
# Copyright 2010-2012 swatch
#
# smart-highlighting-gedit is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#




from gi.repository import Gtk, Gdk, Gedit
import re
import os.path
#import pango
import shutil

from . import config_manager
from .config_ui import ConfigUI

import gettext
APP_NAME = 'smart_highlight'		#Same as module name defined at .plugin file.
CONFIG_DIR = os.path.expanduser('~/.local/share/gedit/plugins/' + APP_NAME + '/config')
#LOCALE_DIR = '/usr/share/locale'
LOCALE_DIR = os.path.join(os.path.dirname(__file__), 'locale')
print(LOCALE_DIR)
if not os.path.exists(LOCALE_DIR):
	LOCALE_DIR = '/usr/share/locale'
	print('locale')
try:
	t = gettext.translation(APP_NAME, LOCALE_DIR)
	_ = t.gettext
	print('gettext')
except:
	print('none')
	pass
#gettext.install(APP_NAME, LOCALE_DIR, unicode=True)


ui_str = """<ui>
	<menubar name="MenuBar">
		<menu name="ToolsMenu" action="Tools">
			<placeholder name="ToolsOps_0">
				<separator/>
				<menu name="SmartHighlightMenu" action="SmartHighlightMenu">
					<placeholder name="SmartHighlightMenuHolder">
						<menuitem name="smart_highlight_configure" action="smart_highlight_configure"/>
					</placeholder>
				</menu>
				<separator/>
			</placeholder>
		</menu>
	</menubar>
</ui>
"""



class SmartHighlightWindowHelper:
	def __init__(self, plugin, window):
		self._window = window
		self._plugin = plugin
		self.current_selection = ''
		self.start_iter = None
		self.end_iter = None
		self.vadj_value = 0
		views = self._window.get_views()
		for view in views:
			view.get_buffer().connect('mark-set', self.on_textbuffer_markset_event)
			view.get_vadjustment().connect('value-changed', self.on_view_vadjustment_value_changed)
			#view.connect('button-press-event', self.on_view_button_press_event)
		self.active_tab_added_id = self._window.connect("tab-added", self.tab_added_action)

		user_configfile = os.path.join(CONFIG_DIR, 'config.xml')
		if not os.path.exists(user_configfile):
			if not os.path.exists(os.path.dirname(user_configfile)):
				os.makedirs(os.path.dirname(user_configfile))
			shutil.copy2(os.path.dirname(__file__) + "/config/config.xml", os.path.dirname(user_configfile))
		configfile = user_configfile
		'''		
		user_configfile = os.path.join(os.path.expanduser('~/.local/share/gedit/plugins/' + 'smart_highlight'), 'config.xml')
		if os.path.exists(user_configfile):
			configfile = user_configfile
		else:	
			configfile = os.path.join(os.path.dirname(__file__), "config.xml")
		#'''
		self.config_manager = config_manager.ConfigManager(configfile)
		self.options = self.config_manager.load_configure('search_option')
		self.config_manager.to_bool(self.options)
		self.smart_highlight = self.config_manager.load_configure('smart_highlight')
		
		self._insert_menu()

	def deactivate(self):
		# Remove any installed menu items
		self._window.disconnect(self.active_tab_added_id)
		self.config_manager.update_config_file(self.config_manager.config_file, 'search_option', self.options)
		self.config_manager.update_config_file(self.config_manager.config_file, 'smart_highlight', self.smart_highlight)
		
	def _insert_menu(self):
		# Get the GtkUIManager
		manager = self._window.get_ui_manager()

		# Create a new action group
		self._action_group = Gtk.ActionGroup("SmartHighlightActions")
		self._action_group.add_actions( [("SmartHighlightMenu", None, _('Smart Highlighting'))] + \
										[("smart_highlight_configure", None, _("Configuration"), None, _("Smart Highlighting Configure"), self.smart_highlight_configure)]) 

		# Insert the action group
		manager.insert_action_group(self._action_group, -1)

		# Merge the UI
		self._ui_id = manager.add_ui_from_string(ui_str)
	
	def _remove_menu(self):
		# Get the GtkUIManager
		manager = self._window.get_ui_manager()

		# Remove the ui
		manager.remove_ui(self._ui_id)

		# Remove the action group
		manager.remove_action_group(self._action_group)

		# Make sure the manager updates
		manager.ensure_update()

	def update_ui(self):
		self._action_group.set_sensitive(self._window.get_active_document() != None)

	'''		
	def show_message_dialog(self, text):
		dlg = Gtk.MessageDialog(self._window, 
								Gtk.DialogFlags.MODAL | Gtk.DialogFlags.DESTROY_WITH_PARENT,
								Gtk.MessageType.INFO,
								Gtk.ButtonsType.CLOSE,
								_(text))
		dlg.run()
		dlg.hide()
	#'''
		
		
	def create_regex(self, pattern, options):
		if options['REGEX_SEARCH'] == False:
			pattern = re.escape(str(r'%s' % pattern))
		else:
			pattern = str(r'%s' % pattern)
		
		if options['MATCH_WHOLE_WORD'] == True:
			pattern = r'\b%s\b' % pattern
			
		if options['MATCH_CASE'] == True:
			regex = re.compile(pattern, re.MULTILINE)
		else:
			regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)
		
		return regex

	def smart_highlighting_action(self, doc, search_pattern, iter, clear_flg = True):
		regex = self.create_regex(search_pattern, self.options)
		if clear_flg == True:
			self.smart_highlight_off(doc)
		
		self.vadj_value = self._window.get_active_view().get_vadjustment().get_value()
		current_line = iter.get_line()
		start_line = current_line - 50
		end_line = current_line + 50
		if start_line <= 0:
			self.start_iter = doc.get_start_iter()
		else:
			self.start_iter = doc.get_iter_at_line(start_line)
		if end_line < doc.get_line_count():
			self.end_iter = doc.get_iter_at_line(end_line)
		else:
			self.end_iter = doc.get_end_iter()
			
		text = str(doc.get_text(self.start_iter, self.end_iter, True))
		
		match = regex.search(text)
		while(match):
			self.smart_highlight_on(doc, match.start()+self.start_iter.get_offset(), match.end() - match.start())
			match = regex.search(text, match.end()+1)
			
	def tab_added_action(self, action, tab):
		view = tab.get_view()
		view.get_buffer().connect('mark-set', self.on_textbuffer_markset_event)
		view.get_vadjustment().connect('value-changed', self.on_view_vadjustment_value_changed)
		#view.connect('button-press-event', self.on_view_button_press_event)
	
	def on_textbuffer_markset_event(self, textbuffer, iter, textmark):
		#print textmark.get_name()
		if textmark.get_name() != 'selection_bound' and textmark.get_name() != 'insert':
			return
		if textbuffer.get_selection_bounds():
			start, end = textbuffer.get_selection_bounds()
			self.current_selection = textbuffer.get_text(start, end, True)
			self.smart_highlighting_action(textbuffer, self.current_selection, iter)
		else:
 			self.current_selection = ''
 			self.smart_highlight_off(textbuffer)
	
	def smart_highlight_on(self, doc, highlight_start, highlight_len):
		if doc.get_tag_table().lookup('smart_highlight') == None:
			tag = doc.create_tag("smart_highlight", foreground=self.smart_highlight['FOREGROUND_COLOR'], background=self.smart_highlight['BACKGROUND_COLOR'])
		doc.apply_tag_by_name('smart_highlight', doc.get_iter_at_offset(highlight_start), doc.get_iter_at_offset(highlight_start + highlight_len))
		
	def smart_highlight_off(self, doc):
		start, end = doc.get_bounds()
		if doc.get_tag_table().lookup('smart_highlight') == None:
			tag = doc.create_tag("smart_highlight", foreground=self.smart_highlight['FOREGROUND_COLOR'], background=self.smart_highlight['BACKGROUND_COLOR'])
		doc.remove_tag_by_name('smart_highlight', start, end)
		
	def smart_highlight_configure(self, action, data = None):
		config_ui = ConfigUI(self._plugin)
		
	def on_view_vadjustment_value_changed(self, object, data = None):
		if self.current_selection == '':
			return
		if object.get_value() < self.vadj_value:	#scroll up
			self.smart_highlighting_action(self._window.get_active_document(), self.current_selection, self.start_iter, False)
		else:	#scroll down
			self.smart_highlighting_action(self._window.get_active_document(), self.current_selection, self.end_iter, False)

			

	'''		
	def auto_select_word_bounds(self, pattern=r'[_a-zA-Z][_a-zA-Z0-9]*'):
		doc = self._window.get_active_document()
		if doc.get_has_selection():
			start, end = doc.get_selection_bounds()
			return start, end
		else:
			current_iter = doc.get_iter_at_mark(doc.get_insert())
			line_num = current_iter.get_line()
			line_start = doc.get_iter_at_line(line_num)
			line_text = doc.get_text(line_start, doc.get_iter_at_line(line_num + 1), True)
			line_start_pos = line_start.get_offset()
			matches = re.finditer(pattern, line_text)
			for match in matches:
				if current_iter.get_offset() in range(line_start_pos + match.start(), line_start_pos + match.end() + 1):
					return doc.get_iter_at_offset(line_start_pos + match.start()), doc.get_iter_at_offset(line_start_pos+match.end())
			return None
	
	def on_view_button_press_event(self, object, event):
		#if event.button == 1 and event.type == Gdk.EventType.BUTTON_PRESS:
		if event.button == 1 and event.type == 5:	#EventType 2BUTTON_PRESS
			print '2button press'
			start, end = self.auto_select_word_bounds()
			print self._window.get_active_document().get_text(start, end, True)
			self._window.get_active_document().select_range(start, end)
 	#'''
 	


########NEW FILE########
__FILENAME__ = ctags
import os
import subprocess
import shlex

def get_ctags_version(executable=None):
    """
    Return the text output from the --version option to ctags or None if ctags
    executable cannot be found. Use executable for custom ctags builds and/or
    path.
    """
    args = shlex.split("ctags --version")
    try:
        p = subprocess.Popen(args, 0, shell=False, stdout=subprocess.PIPE, executable=executable)
        version = p.communicate()[0]
    except:
        version = None
    return version

class Tag(object):
    """
    Represents a ctags "tag" found in some source code. 
    """
    def __init__(self, name):
        self.name = name
        self.file = None
        self.ex_command = None
        self.kind = None
        self.fields = {}

class Kind(object):
    """
    Represents a ctags "kind" found in some source code such as "member" or 
    "class". 
    """
    def __init__(self, name):
        self.name = name
        self.language = None
        
    def group_name(self):
        """
        Return the kind name as a group name. For example, 'variable' would
        be 'Variables'. Pluralization is complex but this method is not. It
        works more often than not.
        """
        group = self.name
        
        if self.name[-1] == 's': 
            group += 'es'
        elif self.name[-1] == 'y':
            group = self.name[0:-1] + 'ies'
        else:
            group += 's'
            
        return group.capitalize()
    
    def icon_name(self):
        """
        Return the icon name in the form of 'source-<kind>'.
        """
        return 'source-' + self.name
                
class Parser(object):
    """
    Ctags Parser
    
    Parses the output of a ctags command into a list of tags and a dictionary
    of kinds.
    """
    def has_kind(self, kind_name):
        """
        Return true if kind_name is found in the list of kinds.
        """
        if kind_name in self.kinds:
            return True
        else:
            return False
    
    def __init__(self):
        self.tags = []
        self.kinds = {}
        self.tree = {}
    
    def parse(self, command, executable=None):
        """
        Parse ctags tags from the output of a ctags command. For example:
        ctags -n --fields=fiKmnsSzt -f - some_file.php
        """
        #args = [arg.replace('%20', ' ') for arg in shlex.split(command)] 
        args = shlex.split(command)
        p = subprocess.Popen(args, 0, shell=False, stdout=subprocess.PIPE, executable=executable)
        symbols = self._parse_text(p.communicate()[0])
    
    def _parse_text(self, text):
        """
        Parses ctags text which may have come from a TAG file or from raw output
        from a ctags command.
        """
        for line in text.splitlines():
            name = None
            file = None
            ex_command = None
            kind = None
            for i, field in enumerate(line.split("\t")):
                if i == 0: tag = Tag(field)
                elif i == 1: tag.file = field
                elif i == 2: tag.ex_command = field
                elif i > 2:
                    if ":" in field:
                        key, value = field.split(":")[0:2]
                        tag.fields[key] = value
                        if key == 'kind':
                            kind = Kind(value)
                            if not kind in self.kinds:
                                self.kinds[value] = kind
                            
            if kind is not None:
                if 'language' in tag.fields:
                    kind.language = tag.fields['language']
                tag.kind = kind
            
            self.tags.append(tag)  
    """
    def get_tree(self):
        tree = {}
        for tag in self.tags:
            if 'class' in tag.fields:
                parent = tag.fields['class']
                if "." in parent:
                    parents = parent.split(".")
                    node = tree
                    for p in parents:
                        if not p in node:
                            node[p] = {'tag':None, 'children':{}}
                        node = node[p]
                    print node
                    node['tag'] = tag                        
                else:
                    if not parent in self.tree:
                        tree[parent] = {'tag':None, 'children':{}}
                    tree[parent]['children'][tag.name] = {'tag':tag, 'children':{}}
            else:
                if tag.name in self.tree:
                    tree[tag.name]['tag'] = tag
                else:
                    tree[tag.name] = {'tag': tag, 'children':{}}
        return tree
    """
            
    

########NEW FILE########
__FILENAME__ = plugin
import os
import sys
import logging
import tempfile
import ctags
from gi.repository import GObject, GdkPixbuf, Gedit, Gtk, PeasGtk, Gio

logging.basicConfig()
LOG_LEVEL = logging.WARN
SETTINGS_SCHEMA = "org.gnome.gedit.plugins.sourcecodebrowser"
DATA_DIR = os.path.join(os.path.dirname(__file__), 'data')
ICON_DIR = os.path.join(DATA_DIR, 'icons', '16x16')
 
class SourceTree(Gtk.VBox):
    """
    Source Tree Widget
    
    A treeview storing the heirarchy of source code symbols within a particular
    document. Requries exhuberant-ctags.
    """
    __gsignals__ = {
        "tag-activated": (GObject.SIGNAL_RUN_FIRST, GObject.TYPE_NONE, (GObject.TYPE_PYOBJECT,)),
    }   
    
    def __init__(self):
        Gtk.VBox.__init__(self)
        self._log = logging.getLogger(self.__class__.__name__)
        self._log.setLevel(LOG_LEVEL)
        self._pixbufs = {}
        self._current_uri = None
        self.expanded_rows = {}
        
        # preferences (should be set by plugin)
        self.show_line_numbers = True
        self.ctags_executable = 'ctags'
        self.expand_rows = True
        self.sort_list = True
        self.create_ui()
        self.show_all()
    
    def get_missing_pixbuf(self):
        """ Used for symbols that do not have a known image. """
        if not 'missing' in self._pixbufs:
            filename = os.path.join(ICON_DIR, "missing-image.png")
            self._pixbufs['missing'] = GdkPixbuf.Pixbuf.new_from_file(filename)
        
        return self._pixbufs['missing']
        
    def get_pixbuf(self, icon_name):
        """ 
        Get the pixbuf for a specific icon name fron an internal dictionary of
        pixbufs. If the icon is not already in the dictionary, it will be loaded
        from an external file.        
        """
        if icon_name not in self._pixbufs: 
            filename = os.path.join(ICON_DIR, icon_name + ".png")
            if os.path.exists(filename):
                try:
                    self._pixbufs[icon_name] = GdkPixbuf.Pixbuf.new_from_file(filename)
                except Exception as e:
                    self._log.warn("Could not load pixbuf for icon '%s': %s", 
                                   icon_name, 
                                   str(e))
                    self._pixbufs[icon_name] = self.get_missing_pixbuf()
            else:
                self._pixbufs[icon_name] = self.get_missing_pixbuf()
                                       
        return self._pixbufs[icon_name]

    def clear(self):
        """ Clear the tree view so that new data can be loaded. """
        if self.expand_rows: 
            self._save_expanded_rows()
        self._store.clear()
        
    def create_ui(self):
        """ Craete the main user interface and pack into box. """
        self._store = Gtk.TreeStore(GdkPixbuf.Pixbuf,       # icon
                                    GObject.TYPE_STRING,    # name
                                    GObject.TYPE_STRING,    # kind
                                    GObject.TYPE_STRING,    # uri 
                                    GObject.TYPE_STRING,    # line               
                                    GObject.TYPE_STRING)    # markup                           
        self._treeview = Gtk.TreeView.new_with_model(self._store)
        self._treeview.set_headers_visible(False)          
        column = Gtk.TreeViewColumn("Symbol")
        cell = Gtk.CellRendererPixbuf()
        column.pack_start(cell, False)
        column.add_attribute(cell, 'pixbuf', 0)
        cell = Gtk.CellRendererText()
        column.pack_start(cell, True)
        column.add_attribute(cell, 'markup', 5)
        self._treeview.append_column(column)
        
        self._treeview.connect("row-activated", self.on_row_activated)
        
        sw = Gtk.ScrolledWindow()
        sw.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        sw.add(self._treeview)
        self.pack_start(sw, True, True, 0)
    
    def _get_tag_iter(self, tag, parent_iter=None):
        """
        Get the tree iter for the specified tag, or None if the tag cannot
        be found.
        """
        tag_iter = self._store.iter_children(parent_iter)
        while tag_iter:
            if self._store.get_value(tag_iter, 1) == tag.name:
                return tag_iter
            tag_iter = self._store.iter_next(tag_iter)
        
        return None
            
    def _get_kind_iter(self, kind, uri, parent_iter=None):
        """
        Get the iter for the specified kind. Creates a new node if the iter
        is not found under the specirfied parent_iter.
        """
        kind_iter = self._store.iter_children(parent_iter)
        while kind_iter:
            if self._store.get_value(kind_iter, 2) == kind.name:
                return kind_iter
            kind_iter = self._store.iter_next(kind_iter)
        
        # Kind node not found, so we'll create it.
        pixbuf = self.get_pixbuf(kind.icon_name())
        markup = "<i>%s</i>" % kind.group_name()
        kind_iter = self._store.append(parent_iter, (pixbuf, 
                                       kind.group_name(), 
                                       kind.name, 
                                       uri, 
                                       None, 
                                       markup))
        return kind_iter
        
    def load(self, kinds, tags, uri):
        """
        Load the tags into the treeview and restore the expanded rows if 
        applicable.
        """
        self._current_uri = uri
        # load root-level tags first
        for i, tag in enumerate(tags):
            if "class" not in tag.fields: 
                parent_iter = None
                pixbuf = self.get_pixbuf(tag.kind.icon_name())
                if 'line' in tag.fields and self.show_line_numbers:
                    markup = "%s [%s]" % (tag.name, tag.fields['line'])
                else:
                    markup = tag.name
                kind_iter = self._get_kind_iter(tag.kind, uri, parent_iter)
                new_iter = self._store.append(kind_iter, (pixbuf, 
                                                          tag.name, 
                                                          tag.kind.name, 
                                                          uri, 
                                                          tag.fields['line'], 
                                                          markup))
        # second level tags 
        for tag in tags:
            if "class" in tag.fields and "." not in tag.fields['class']:
                pixbuf = self.get_pixbuf(tag.kind.icon_name())
                if 'line' in tag.fields and self.show_line_numbers:
                    markup = "%s [%s]" % (tag.name, tag.fields['line'])
                else:
                    markup = tag.name
                for parent_tag in tags:
                    if parent_tag.name == tag.fields['class']:
                        break
                kind_iter = self._get_kind_iter(parent_tag.kind, uri, None)
                parent_iter = self._get_tag_iter(parent_tag, kind_iter)
                kind_iter = self._get_kind_iter(tag.kind, uri, parent_iter) # for sub-kind nodes
                new_iter = self._store.append(kind_iter, (pixbuf, 
                                                          tag.name, 
                                                          tag.kind.name, 
                                                          uri, 
                                                          tag.fields['line'], 
                                                          markup))
        # TODO: We need to go at least one more level to deal with the inline 
        # classes used in many python projects (eg. Models in Django)
        # Recursion would be even better.
        
        # sort         
        if self.sort_list:                               
            self._store.set_sort_column_id(1, Gtk.SortType.ASCENDING)
        
        # expand
        if uri in self.expanded_rows:
            for strpath in self.expanded_rows[uri]:
                path = Gtk.TreePath.new_from_string(strpath)
                if path:
                    self._treeview.expand_row(path, False)
        elif uri not in self.expanded_rows and self.expand_rows:
            self._treeview.expand_all()
            """
            curiter = self._store.get_iter_first()
            while curiter:
                path = self._store.get_path(curiter)
                self._treeview.expand_row(path, False)
                curiter = self._store.iter_next(iter)
            """

    def on_row_activated(self, treeview, path, column, data=None):
        """
        If the row has uri and line number information, emits the tag-activated
        signal so that the editor can jump to the tag's location.
        """
        model = treeview.get_model()
        iter = model.get_iter(path)
        uri = model.get_value(iter, 3)
        line = model.get_value(iter, 4)
        if uri and line:
            self.emit("tag-activated", (uri, line))

    def parse_file(self, path, uri):
        """
        Parse symbols out of a file using exhuberant ctags. The path is the local
        filename to pass to ctags, and the uri is the actual URI as known by
        Gedit. They would be different for remote files.
        """
        command = "ctags -nu --fields=fiKlmnsSzt -f - '%s'" % path
        #self._log.debug(command)
        try:
            parser = ctags.Parser()
            parser.parse(command, self.ctags_executable)
        except Exception as e:
            self._log.warn("Could not execute ctags: %s (executable=%s)",
                           str(e), 
                           self.ctags_executable)
        self.load(parser.kinds, parser.tags, uri)
    
    
    def _save_expanded_rows(self):
        self.expanded_rows[self._current_uri] = []
        self._treeview.map_expanded_rows(self._save_expanded_rows_mapping_func, 
                                         self._current_uri)
    
    def _save_expanded_rows_mapping_func(self, treeview, path, uri):
        self.expanded_rows[uri].append(str(path))
        
        
class Config(object):
    def __init__(self):
        self._log = logging.getLogger(self.__class__.__name__)
        self._log.setLevel(LOG_LEVEL)
        
    def get_widget(self, has_schema):
        filename = os.path.join(DATA_DIR, 'configure_dialog.ui')
        builder = Gtk.Builder()
        try:
            count = builder.add_objects_from_file(filename, ["configure_widget"])
            assert(count > 0)
        except Exception as e:
            self._log.error("Failed to load %s: %s." % (filename, str(e)))
            return None
        widget = builder.get_object("configure_widget")
        widget.set_border_width(12)
        
        if not has_schema:
            widget.set_sensitive(False)
        else:
            self._settings = Gio.Settings.new(SETTINGS_SCHEMA)
            builder.get_object("show_line_numbers").set_active(
                self._settings.get_boolean('show-line-numbers')
            )
            builder.get_object("expand_rows").set_active(
                self._settings.get_boolean('expand-rows')
            )
            builder.get_object("load_remote_files").set_active(
                self._settings.get_boolean('load-remote-files')
            )
            builder.get_object("sort_list").set_active(
                self._settings.get_boolean('sort-list')
            )
            builder.get_object("ctags_executable").set_text(
                self._settings.get_string('ctags-executable')
            )
            builder.connect_signals(self)
        return widget
    
    def on_show_line_numbers_toggled(self, button, data=None):
        self._settings.set_boolean('show-line-numbers', button.get_active())
    
    def on_expand_rows_toggled(self, button, data=None):
        self._settings.set_boolean('expand-rows', button.get_active())
    
    def on_load_remote_files_toggled(self, button, data=None):
        self._settings.set_boolean('load-remote-files', button.get_active())
    
    def on_sort_list_toggled(self, button, data=None):
        self._settings.set_boolean('sort-list', button.get_active())
        
    def on_ctags_executable_changed(self, editable, data=None):
        self._settings.set_string('ctags-executable', editable.get_text())
    
    
class SourceCodeBrowserPlugin(GObject.Object, Gedit.WindowActivatable, PeasGtk.Configurable):
    """
    Source Code Browser Plugin for Gedit 3.x
    
    Adds a tree view to the side panel of a Gedit window which provides a list
    of programming symbols (functions, classes, variables, etc.).
    
    https://live.gnome.org/Gedit/PythonPluginHowTo
    """
    __gtype_name__ = "SourceCodeBrowserPlugin"
    window = GObject.property(type=Gedit.Window)

    def __init__(self):
        GObject.Object.__init__(self)
        self._log = logging.getLogger(self.__class__.__name__)
        self._log.setLevel(LOG_LEVEL)
        self._is_loaded = False
        self._ctags_version = None

        filename = os.path.join(ICON_DIR, "source-code-browser.png")
        self.icon = Gtk.Image.new_from_file(filename)
    
    def do_create_configure_widget(self):
        return Config().get_widget(self._has_settings_schema())
        
    def do_activate(self):
        """ Activate plugin """
        self._log.debug("Activating plugin")
        self._init_settings()
        self._version_check()
        self._sourcetree = SourceTree()
        self._sourcetree.ctags_executable = self.ctags_executable
        self._sourcetree.show_line_numbers = self.show_line_numbers
        self._sourcetree.expand_rows = self.expand_rows
        self._sourcetree.sort_list = self.sort_list
        panel = self.window.get_side_panel()
        panel.add_item(self._sourcetree, "SymbolBrowserPlugin", "Source Code", self.icon)
        self._handlers = []
        hid = self._sourcetree.connect("focus", self.on_sourcetree_focus)
        self._handlers.append((self._sourcetree, hid))
        if self.ctags_version is not None:
            hid = self._sourcetree.connect('tag-activated', self.on_tag_activated)
            self._handlers.append((self._sourcetree, hid))
            hid = self.window.connect("active-tab-state-changed", self.on_tab_state_changed)
            self._handlers.append((self.window, hid))
            hid = self.window.connect("active-tab-changed", self.on_active_tab_changed)
            self._handlers.append((self.window, hid))
            hid = self.window.connect("tab-removed", self.on_tab_removed)
            self._handlers.append((self.window, hid))
        else:
            self._sourcetree.set_sensitive(False)
    
    def do_deactivate(self):
        """ Deactivate the plugin """
        self._log.debug("Deactivating plugin")
        for obj, hid in self._handlers:
            obj.disconnect(hid)
        self._handlers = None
        pane = self.window.get_side_panel()
        pane.remove_item(self._sourcetree)
        self._sourcetree = None
    
    def _has_settings_schema(self):
        schemas = Gio.Settings.list_schemas()
        if not SETTINGS_SCHEMA in schemas:
            return False
        else:
            return True
            
    def _init_settings(self):
        """ Initialize GSettings if available. """
        if self._has_settings_schema():
            settings = Gio.Settings.new(SETTINGS_SCHEMA)
            self.load_remote_files = settings.get_boolean("load-remote-files")
            self.show_line_numbers = settings.get_boolean("show-line-numbers")
            self.expand_rows = settings.get_boolean("expand-rows")
            self.sort_list = settings.get_boolean("sort-list")
            self.ctags_executable = settings.get_string("ctags-executable")
            settings.connect("changed::load-remote-files", self.on_setting_changed)
            settings.connect("changed::show-line-numbers", self.on_setting_changed)
            settings.connect("changed::expand-rows", self.on_setting_changed)
            settings.connect("changed::sort-list", self.on_setting_changed)
            settings.connect("changed::ctags-executable", self.on_setting_changed)
            self._settings = settings
        else:
            self._log.warn("Settings schema not installed. Plugin will not be configurable.")
            self._settings = None
            self.load_remote_files = True
            self.show_line_numbers = False
            self.expand_rows = True
            self.sort_list = True
            self.ctags_executable = 'ctags'
   
    def _load_active_document_symbols(self):
        """ Load the symbols for the given URI. """
        self._sourcetree.clear()
        self._is_loaded = False
        # do not load if not the active tab in the panel
        panel = self.window.get_side_panel()
        if not panel.item_is_active(self._sourcetree):
            return

        document = self.window.get_active_document()
        if document:
            location = document.get_location()
            if location:
                uri = location.get_uri()
                self._log.debug("Loading %s...", uri)
                if uri is not None:
                    if uri[:7] == "file://":
                        # use get_parse_name() to get path in UTF-8
                        filename = location.get_parse_name() 
                        self._sourcetree.parse_file(filename, uri)
                    elif self.load_remote_files:
                        basename = location.get_basename()
                        fd, filename = tempfile.mkstemp('.'+basename)
                        contents = document.get_text(document.get_start_iter(),
                                                     document.get_end_iter(),
                                                     True)
                        os.write(fd, contents)
                        os.close(fd)
                        while Gtk.events_pending():
                            Gtk.main_iteration()
                        self._sourcetree.parse_file(filename, uri)
                        os.unlink(filename)
                    self._loaded_document = document
        self._is_loaded = True
            
    def on_active_tab_changed(self, window, tab, data=None):
        self._load_active_document_symbols()
    
    def on_setting_changed(self, settings, key, data=None):
        """
        self.load_remote_files = True
        self.show_line_numbers = False
        self.expand_rows = True
        self.ctags_executable = 'ctags'
        """
        if key == 'load-remote-files':
            self.load_remote_files = self._settings.get_boolean(key)
        elif key == 'show-line-numbers':
            self.show_line_numbers = self._settings.get_boolean(key)
        elif key == 'expand-rows':
            self.expand_rows = self._settings.get_boolean(key)
        elif key == 'sort-list':
            self.sort_list = self._settings.get_boolean(key)
        elif key == 'ctags-executable':
            self.ctags_executable = self._settings.get_string(key)
        
        if self._sourcetree is not None:
            self._sourcetree.ctags_executable = self.ctags_executable
            self._sourcetree.show_line_numbers = self.show_line_numbers
            self._sourcetree.expand_rows = self.expand_rows
            self._sourcetree.sort_list = self.sort_list
            self._sourcetree.expanded_rows = {}
            self._load_active_document_symbols()
    
    def on_sourcetree_focus(self, direction, data=None):
        if not self._is_loaded:
            self._load_active_document_symbols()
        return False
        
    def on_tab_state_changed(self, window, data=None):
        self._load_active_document_symbols()
    
    def on_tab_removed(self, window, tab, data=None):
        if not self.window.get_active_document():
            self._sourcetree.clear()
        
    def on_tag_activated(self, sourcetree, location, data=None):
        """ Go to the line where the double-clicked symbol is defined. """
        uri, line = location
        self._log.debug("%s, line %s." % (uri, line))
        document = self.window.get_active_document()
        view = self.window.get_active_view()
        line = int(line) - 1 # lines start from 0
        document.goto_line(line)
        view.scroll_to_cursor()
        
    def _version_check(self):
        """ Make sure the exhuberant ctags is installed. """
        self.ctags_version = ctags.get_ctags_version(self.ctags_executable) 
        if not self.ctags_version:
            self._log.warn("Could not find ctags executable: %s" % 
                           (self.ctags_executable))
            
        
        

########NEW FILE########
__FILENAME__ = tabswitch
# -*- coding: utf-8 -*-

VERSION = "0.1"

from gi.repository import GObject, Gtk, Gedit, Gdk, Gio
from gettext import gettext as _
import cPickle, os

class TabSwitchPlugin(GObject.Object, Gedit.WindowActivatable):
    __gtype_name__ = "ExamplePyWindowActivatable"
    window = GObject.property(type=Gedit.Window)

    def __init__(self):
        GObject.Object.__init__(self)
        self.id_name = 'TabSwitchPluginID'
    
    def do_activate(self):
        l_ids = []
        for signal in ('key-press-event',):
            method = getattr(self, 'on_window_' + signal.replace('-', '_'))
            l_ids.append(self.window.connect(signal, method))
        self.window.set_data(self.id_name, l_ids)
    
    def do_deactivate(self):
        l_ids = self.window.get_data(self.id_name)
        
        for l_id in l_ids:
            self.window.disconnect(l_id)
    
    def on_window_key_press_event(self, window, event):
        key = Gdk.keyval_name(event.keyval)

        if event.state & Gdk.ModifierType.CONTROL_MASK and key in ('Tab', 'ISO_Left_Tab'):
            atab = self.window.get_active_tab()
            docs = self.window.get_documents()
            tabs = []
            for doc in docs:
              tabs.append(Gedit.Tab.get_from_document(doc))
            
            tlen = len(tabs)
            i = 0
            tab = atab
            
            for tab in tabs:
                i += 1
                if tab == atab:
                    break
            
            if key == 'ISO_Left_Tab':
                i -= 2
            
            if i < 0:
                tab = tabs[tlen-1]
            elif i >= tlen:
                tab = tabs[0]
            else:
                tab = tabs[i]
            
            self.window.set_active_tab(tab)
            
            return True


########NEW FILE########
__FILENAME__ = whitespaceterminator
# coding: utf8
# Copyright  2011 Kozea
# Licensed under a 3-clause BSD license.

"""
Strip trailing whitespace before saving.

"""

from gi.repository import GObject, Gedit


class WhiteSpaceTerminator(GObject.Object, Gedit.WindowActivatable):
    """Strip trailing whitespace before saving."""
    window = GObject.property(type=Gedit.Window)

    def do_activate(self):
        self.handlers = []
        handler = self.window.connect("tab-added", self.on_tab_added)
        self.handlers.append((self.window, handler))
        for document in self.window.get_documents():
            document.connect("save", self.on_document_save)
            self.handlers.append((document, handler))

    def on_tab_added(self, window, tab, data=None):
        handler = tab.get_document().connect("save", self.on_document_save)
        self.handlers.append((tab, handler))

    def on_document_save(self, document, location, encoding, compression,
                         flags, data=None):
        for i, text in enumerate(document.props.text.rstrip().splitlines()):
            strip_stop = document.get_iter_at_line(i)
            strip_stop.forward_to_line_end()
            strip_start = strip_stop.copy()
            strip_start.backward_chars(len(text) - len(text.rstrip()))
            document.delete(strip_start, strip_stop)
        document.delete(strip_start, document.get_end_iter())

    def do_deactivate(self):
        for obj, handler in self.handlers:
            obj.disconnect(handler)

########NEW FILE########
__FILENAME__ = comment
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Comment important tags (with 'id' and 'class' attributes)
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
from zencoding import zen_core as zen_coding

alias = 'c'
"Filter name alias (if not defined, ZC will use module name)"

def add_comments(node, i):
	
	"""
	Add comments to tag
	@type node: ZenNode
	@type i: int
	"""
	id_attr = node.get_attribute('id')
	class_attr = node.get_attribute('class')
	nl = zen_coding.get_newline()
		
	if id_attr or class_attr:
		comment_str = ''
		padding = node.parent and node.parent.padding or ''
		if id_attr: comment_str += '#' + id_attr
		if class_attr: comment_str += '.' + class_attr
		
		node.start = node.start.replace('<', '<!-- ' + comment_str + ' -->' + nl + padding + '<', 1)
		node.end = node.end.replace('>', '>' + nl + padding + '<!-- /' + comment_str + ' -->', 1)
		
		# replace counters
		node.start = zen_coding.replace_counter(node.start, i + 1)
		node.end = zen_coding.replace_counter(node.end, i + 1)

def process(tree, profile):
	if profile['tag_nl'] is False:
		return tree
		
	for i, item in enumerate(tree.children):
		if item.is_block():
			add_comments(item, i)
		process(item, profile)
	
	return tree
########NEW FILE########
__FILENAME__ = escape
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter for escaping unsafe XML characters: <, >, &
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
import re

alias = 'e'
"Filter name alias (if not defined, ZC will use module name)"

char_map = {
	'<': '&lt;',
	'>': '&gt;',
	'&': '&amp;'
}

re_chars = re.compile(r'[<>&]')

def escape_chars(text):
	return re_chars.sub(lambda m: char_map[m.group(0)], text)

def process(tree, profile=None):
	for item in tree.children:
		item.start = escape_chars(item.start)
		item.end = escape_chars(item.end)
		
		process(item)
	
	return tree
########NEW FILE########
__FILENAME__ = format-css
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Format CSS properties: add space after property name:
padding:0; -> padding: 0;
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
import re

alias = 'fc'
"Filter name alias (if not defined, ZC will use module name)"

re_css_prop = re.compile(r'([\w\-]+\s*:)\s*')

def process(tree, profile):
	for item in tree.children:
		# CSS properties are always snippets 
		if item.type == 'snippet':
			item.start = re_css_prop.sub(r'\1 ', item.start)
		
		process(item, profile)
		
	return tree
########NEW FILE########
__FILENAME__ = format
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Generic formatting filter: creates proper indentation for each tree node,
placing "%s" placeholder where the actual output should be. You can use
this filter to preformat tree and then replace %s placeholder to whatever you
need. This filter should't be called directly from editor as a part 
of abbreviation.
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
"""
import re
from zencoding import zen_core as zen_coding

alias = '_format'
"Filter name alias (if not defined, ZC will use module name)"

child_token = '${child}'
placeholder = '%s'

def get_newline():
	return zen_coding.get_newline()


def get_indentation():
	return zen_coding.get_indentation()

def has_block_sibling(item):
	"""
	Test if passed node has block-level sibling element
	@type item: ZenNode
	@return: bool
	"""
	return item.parent and item.parent.has_block_children()

def is_very_first_child(item):
	"""
	Test if passed itrem is very first child of the whole tree
	@type tree: ZenNode
	"""
	return item.parent and not item.parent.parent and not item.previous_sibling

def should_break_line(node, profile):
	"""
	Need to add line break before element
	@type node: ZenNode
	@type profile: dict
	@return: bool
	"""
	if not profile['inline_break']:
		return False
		
	# find toppest non-inline sibling
	while node.previous_sibling and node.previous_sibling.is_inline():
		node = node.previous_sibling
	
	if not node.is_inline():
		return False
		
	# calculate how many inline siblings we have
	node_count = 1
	node = node.next_sibling
	while node:
		if node.is_inline():
			node_count += 1
		else:
			break
		node = node.next_sibling
	
	return node_count >= profile['inline_break']

def should_break_child(node, profile):
	"""
	 Need to add newline because <code>item</code> has too many inline children
	 @type node: ZenNode
	 @type profile: dict
	 @return: bool
	"""
	# we need to test only one child element, because 
	# has_block_children() method will do the rest
	return node.children and should_break_line(node.children[0], profile)

def process_snippet(item, profile, level=0):
	"""
	Processes element with <code>snippet</code> type
	@type item: ZenNode
	@type profile: dict
	@param level: Depth level
	@type level: int
	"""
	data = item.source.value;
		
	if not data:
		# snippet wasn't found, process it as tag
		return process_tag(item, profile, level)
		
	item.start = placeholder
	item.end = placeholder
	
	padding = item.parent.padding if item.parent else get_indentation() * level 
	
	if not is_very_first_child(item):
		item.start = get_newline() + padding + item.start
	
	# adjust item formatting according to last line of <code>start</code> property
	parts = data.split(child_token)
	lines = zen_coding.split_by_lines(parts[0] or '')
	padding_delta = get_indentation()
		
	if len(lines) > 1:
		m = re.match(r'^(\s+)', lines[-1])
		if m:
			padding_delta = m.group(1)
	
	item.padding = padding + padding_delta
	
	return item

def process_tag(item, profile, level=0):
	"""
	Processes element with <code>tag</code> type
	@type item: ZenNode
	@type profile: dict
	@param level: Depth level
	@type level: int
	"""
	if not item.name:
		# looks like it's a root element
		return item
	
	item.start = placeholder
	item.end = placeholder
	
	is_unary = item.is_unary() and not item.children
		
	# formatting output
	if profile['tag_nl'] is not False:
		padding = item.parent.padding if item.parent else get_indentation() * level
		force_nl = profile['tag_nl'] is True
		should_break = should_break_line(item, profile)
		
		# formatting block-level elements
		if ((item.is_block() or should_break) and item.parent) or force_nl:
			# snippet children should take different formatting
			if not item.parent or (item.parent.type != 'snippet' and not is_very_first_child(item)):
				item.start = get_newline() + padding + item.start
				
			if item.has_block_children() or should_break_child(item, profile) or (force_nl and not is_unary):
				item.end = get_newline() + padding + item.end
				
			if item.has_tags_in_content() or (force_nl and not item.has_children() and not is_unary):
				item.start += get_newline() + padding + get_indentation()
			
		elif item.is_inline() and has_block_sibling(item) and not is_very_first_child(item):
			item.start = get_newline() + padding + item.start
		
		item.padding = padding + get_indentation()
	
	return item

def process(tree, profile, level=0):
	"""
	Processes simplified tree, making it suitable for output as HTML structure
	@type item: ZenNode
	@type profile: dict
	@param level: Depth level
	@type level: int
	"""
	
	for item in tree.children:
		if item.type == 'tag':
			item = process_tag(item, profile, level)
		else:
			item = process_snippet(item, profile, level)
		
		if item.content:
			item.content = zen_coding.pad_string(item.content, item.padding)
			
		process(item, profile, level + 1)
	
	return tree
########NEW FILE########
__FILENAME__ = haml
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter that produces HAML tree
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
from zencoding import zen_core as zen_coding

child_token = '${child}'
	
def make_attributes_string(tag, profile):
	"""
	 Creates HTML attributes string from tag according to profile settings
	 @type tag: ZenNode
	 @type profile: dict
	"""
	# make attribute string
	attrs = ''
	attr_quote = profile['attr_quotes'] == 'single' and "'" or '"'
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
		
	# use short notation for ID and CLASS attributes
	for a in tag.attributes:
		name_lower = a['name'].lower()
		if name_lower == 'id':
			attrs += '#' + (a['value'] or cursor)
		elif name_lower == 'class':
			attrs += '.' + (a['value'] or cursor)
			
	other_attrs = []
	
	# process other attributes
	for a in tag.attributes:
		name_lower = a['name'].lower()
		if name_lower != 'id' and name_lower != 'class':
			attr_name = profile['attr_case'] == 'upper' and a['name'].upper() or name_lower
			other_attrs.append(':' + attr_name + ' => ' + attr_quote + (a['value'] or cursor) + attr_quote)
		
	if other_attrs:
		attrs += '{' + ', '.join(other_attrs) + '}'
	
	return attrs

def _replace(placeholder, value):
	if placeholder:
		return placeholder % value
	else:
		return value		

def process_snippet(item, profile, level=0):
	"""
	Processes element with <code>snippet</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	data = item.source.value
		
	if not data:
		# snippet wasn't found, process it as tag
		return process_tag(item, profile, level)
		
	tokens = data.split(child_token)
	if len(tokens) < 2:
		start = tokens[0]
		end = ''
	else:
		start, end = tokens
	
	padding = item.parent and item.parent.padding or ''
		
	item.start = _replace(item.start, zen_coding.pad_string(start, padding))
	item.end = _replace(item.end, zen_coding.pad_string(end, padding))
	
	return item

def has_block_sibling(item):
	"""
	Test if passed node has block-level sibling element
	@type item: ZenNode
	@return: bool
	"""
	return item.parent and item.parent.has_block_children()

def process_tag(item, profile, level=0):
	"""
	Processes element with <code>tag</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	if not item.name:
		# looks like it's root element
		return item
	
	attrs = make_attributes_string(item, profile) 
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
	self_closing = ''
	is_unary = item.is_unary() and not item.children
	
	if profile['self_closing_tag'] and is_unary:
		self_closing = '/'
		
	# define tag name
	tag_name = '%' + (profile['tag_case'] == 'upper' and item.name.upper() or item.name.lower())
					
	if tag_name.lower() == '%div' and '{' not in attrs:
		# omit div tag
		tag_name = ''
		
	item.end = ''
	item.start = _replace(item.start, tag_name + attrs + self_closing)
	
	if not item.children and not is_unary:
		item.start += cursor
	
	return item

def process(tree, profile, level=0):
	"""
	Processes simplified tree, making it suitable for output as HTML structure
	@type tree: ZenNode
	@type profile: dict
	@type level: int
	"""
	if level == 0:
		# preformat tree
		tree = zen_coding.run_filters(tree, profile, '_format')
		
	for i, item in enumerate(tree.children):
		if item.type == 'tag':
			process_tag(item, profile, level)
		else:
			process_snippet(item, profile, level)
	
		# replace counters
		item.start = zen_coding.unescape_text(zen_coding.replace_counter(item.start, item.counter))
		item.end = zen_coding.unescape_text(zen_coding.replace_counter(item.end, item.counter))
		process(item, profile, level + 1)
		
	return tree

########NEW FILE########
__FILENAME__ = html
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter that produces HTML tree
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
from zencoding import zen_core as zen_coding

child_token = '${child}'

def make_attributes_string(tag, profile):
	"""
	Creates HTML attributes string from tag according to profile settings
	@type tag: ZenNode
	@type profile: dict
	"""
	# make attribute string
	attrs = ''
	attr_quote = profile['attr_quotes'] == 'single' and "'" or '"'
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
	
	# process other attributes
	for a in tag.attributes:
		attr_name = profile['attr_case'] == 'upper' and a['name'].upper() or a['name'].lower()
		attrs += ' ' + attr_name + '=' + attr_quote + (a['value'] or cursor) + attr_quote
		
	return attrs

def _replace(placeholder, value):
	if placeholder:
		return placeholder % value
	else:
		return value

def process_snippet(item, profile, level):
	"""
	Processes element with <code>snippet</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	data = item.source.value;
		
	if not data:
		# snippet wasn't found, process it as tag
		return process_tag(item, profile, level)
		
	tokens = data.split(child_token)
	if len(tokens) < 2:
		start = tokens[0]
		end = ''
	else:
		start, end = tokens
		
	padding = item.parent and item.parent.padding or ''
		
	item.start = _replace(item.start, zen_coding.pad_string(start, padding))
	item.end = _replace(item.end, zen_coding.pad_string(end, padding))
	
	return item


def has_block_sibling(item):
	"""
	Test if passed node has block-level sibling element
	@type item: ZenNode
	@return: bool
	"""
	return item.parent and item.parent.has_block_children()

def process_tag(item, profile, level):
	"""
	Processes element with <code>tag</code> type
	@type item: ZenNode
	@type profile: dict
	@type level: int
	"""
	if not item.name:
		# looks like it's root element
		return item
	
	attrs = make_attributes_string(item, profile) 
	cursor = profile['place_cursor'] and zen_coding.get_caret_placeholder() or ''
	self_closing = ''
	is_unary = item.is_unary() and not item.children
	start= ''
	end = ''
	
	if profile['self_closing_tag'] == 'xhtml':
		self_closing = ' /'
	elif profile['self_closing_tag'] is True:
		self_closing = '/'
		
	# define opening and closing tags
	tag_name = profile['tag_case'] == 'upper' and item.name.upper() or item.name.lower()
	if is_unary:
		start = '<' + tag_name + attrs + self_closing + '>'
		item.end = ''
	else:
		start = '<' + tag_name + attrs + '>'
		end = '</' + tag_name + '>'
	
	item.start = _replace(item.start, start)
	item.end = _replace(item.end, end)
	
	if not item.children and not is_unary:
		item.start += cursor
	
	return item

def process(tree, profile, level=0):
	"""
	Processes simplified tree, making it suitable for output as HTML structure
	@type tree: ZenNode
	@type profile: dict
	@type level: int
	"""
	if level == 0:
		# preformat tree
		tree = zen_coding.run_filters(tree, profile, '_format')
		zen_coding.max_tabstop = 0
		
	for item in tree.children:
		if item.type == 'tag':
			process_tag(item, profile, level)
		else:
			process_snippet(item, profile, level)
	
		# replace counters
		item.start = zen_coding.unescape_text(zen_coding.replace_counter(item.start, item.counter))
		item.end = zen_coding.unescape_text(zen_coding.replace_counter(item.end, item.counter))
		zen_coding.upgrade_tabstops(item)
		
		process(item, profile, level + 1)
		
	return tree

########NEW FILE########
__FILENAME__ = xsl
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Filter for trimming "select" attributes from some tags that contains
child elements
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
'''
import re

tags = {
	'xsl:variable': 1,
	'xsl:with-param': 1
}

re_attr = re.compile(r'\s+select\s*=\s*([\'"]).*?\1')

def trim_attribute(node):
	"""
	Removes "select" attribute from node
	@type node: ZenNode
	"""
	node.start = re_attr.sub('', node.start)

def process(tree, profile):
	for item in tree.children:
		if item.type == 'tag' and item.name.lower() in tags and item.children:
			trim_attribute(item)
		
		process(item, profile)
########NEW FILE########
__FILENAME__ = html_matcher
#!/usr/bin/env python
# -*- coding: utf-8 -*-

'''
Context-independent xHTML pair matcher
Use method <code>match(html, start_ix)</code> to find matching pair.
If pair was found, this function returns a list of indexes where tag pair 
starts and ends. If pair wasn't found, <code>None</code> will be returned.

The last matched (or unmatched) result is saved in <code>last_match</code> 
dictionary for later use.

@author: Sergey Chikuyonok (serge.che@gmail.com)
'''
import re

start_tag = r'<([\w\:\-]+)((?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>\s]+))?)*)\s*(\/?)>'
end_tag = r'<\/([\w\:\-]+)[^>]*>'
attr = r'([\w\-:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:\'((?:\\.|[^\'])*)\')|([^>\s]+)))?'

"Last matched HTML pair"
last_match = {
	'opening_tag': None, # Tag() or Comment() object
	'closing_tag': None, # Tag() or Comment() object
	'start_ix': -1,
	'end_ix': -1
}

cur_mode = 'xhtml'
"Current matching mode"

def set_mode(new_mode):
	global cur_mode
	if new_mode != 'html': new_mode = 'xhtml'
	cur_mode = new_mode

def make_map(elems):
	"""
	Create dictionary of elements for faster searching
	@param elems: Elements, separated by comma
	@type elems: str
	"""
	obj = {}
	for elem in elems.split(','):
			obj[elem] = True

	return obj

# Empty Elements - HTML 4.01
empty = make_map("area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed");

# Block Elements - HTML 4.01
block = make_map("address,applet,blockquote,button,center,dd,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,isindex,li,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul");

# Inline Elements - HTML 4.01
inline = make_map("a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,select,small,span,strike,strong,sub,sup,textarea,tt,u,var");

# Elements that you can, intentionally, leave open
# (and which close themselves)
close_self = make_map("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr");

# Attributes that have their values filled in disabled="disabled"
fill_attrs = make_map("checked,compact,declare,defer,disabled,ismap,multiple,nohref,noresize,noshade,nowrap,readonly,selected");

#Special Elements (can contain anything)
# serge.che: parsing data inside <scipt> elements is a "feature"
special = make_map("style");

class Tag():
	"""Matched tag"""
	def __init__(self, match, ix):
		"""
		@type match: MatchObject
		@param match: Matched HTML tag
		@type ix: int
		@param ix: Tag's position
		"""
		global cur_mode
		
		name = match.group(1).lower()
		self.name = name
		self.full_tag = match.group(0)
		self.start = ix
		self.end = ix + len(self.full_tag)
		self.unary = ( len(match.groups()) > 2 and bool(match.group(3)) ) or (name in empty and cur_mode == 'html')
		self.type = 'tag'
		self.close_self = (name in close_self and cur_mode == 'html')

class Comment():
	"Matched comment"
	def __init__(self, start, end):
		self.start = start
		self.end = end
		self.type = 'comment'

def make_range(opening_tag=None, closing_tag=None, ix=0):
	"""
	Makes selection ranges for matched tag pair
	@type opening_tag: Tag
    @type closing_tag: Tag
    @type ix: int
    @return list
	"""
	start_ix, end_ix = -1, -1
	
	if opening_tag and not closing_tag: # unary element
		start_ix = opening_tag.start
		end_ix = opening_tag.end
	elif opening_tag and closing_tag: # complete element
		if (opening_tag.start < ix and opening_tag.end > ix) or (closing_tag.start <= ix and closing_tag.end > ix):
			start_ix = opening_tag.start
			end_ix = closing_tag.end;
		else:
			start_ix = opening_tag.end
			end_ix = closing_tag.start
	
	return start_ix, end_ix

def save_match(opening_tag=None, closing_tag=None, ix=0):
	"""
	Save matched tag for later use and return found indexes
    @type opening_tag: Tag
    @type closing_tag: Tag
    @type ix: int
    @return list
	"""
	last_match['opening_tag'] = opening_tag; 
	last_match['closing_tag'] = closing_tag;
	
	last_match['start_ix'], last_match['end_ix'] = make_range(opening_tag, closing_tag, ix)
	
	return last_match['start_ix'] != -1 and (last_match['start_ix'], last_match['end_ix']) or (None, None)

def match(html, start_ix, mode='xhtml'):
	"""
	Search for matching tags in <code>html</code>, starting from
	<code>start_ix</code> position. The result is automatically saved
	in <code>last_match</code> property
	"""
	return _find_pair(html, start_ix, mode, save_match)

def find(html, start_ix, mode='xhtml'):
	"""
	Search for matching tags in <code>html</code>, starting from
	<code>start_ix</code> position.
	"""
	return _find_pair(html, start_ix, mode)

def get_tags(html, start_ix, mode='xhtml'):
	"""
	Search for matching tags in <code>html</code>, starting from 
	<code>start_ix</code> position. The difference between 
	<code>match</code> function itself is that <code>get_tags</code> 
	method doesn't save matched result in <code>last_match</code> property 
	and returns array of opening and closing tags
	This method is generally used for lookups
	"""
	return _find_pair(html, start_ix, mode, lambda op, cl=None, ix=0: (op, cl) if op and op.type == 'tag' else None)


def _find_pair(html, start_ix, mode='xhtml', action=make_range):
	"""
	Search for matching tags in <code>html</code>, starting from
	<code>start_ix</code> position
	
	@param html: Code to search
	@type html: str
	
	@param start_ix: Character index where to start searching pair
	(commonly, current caret position)
	@type start_ix: int
	
	@param action: Function that creates selection range
	@type action: function
	
	@return: list
	"""

	forward_stack = []
	backward_stack = []
	opening_tag = None
	closing_tag = None
	html_len = len(html)
	
	set_mode(mode)

	def has_match(substr, start=None):
		if start is None:
			start = ix

		return html.find(substr, start) == start


	def find_comment_start(start_pos):
		while start_pos:
			if html[start_pos] == '<' and has_match('<!--', start_pos):
				break

			start_pos -= 1

		return start_pos

#    find opening tag
	ix = start_ix - 1
	while ix >= 0:
		ch = html[ix]
		if ch == '<':
			check_str = html[ix:]
			m = re.match(end_tag, check_str)
			if m:  # found closing tag
				tmp_tag = Tag(m, ix)
				if tmp_tag.start < start_ix and tmp_tag.end > start_ix: # direct hit on searched closing tag
					closing_tag = tmp_tag
				else:
					backward_stack.append(tmp_tag)
			else:
				m = re.match(start_tag, check_str)
				if m: # found opening tag
					tmp_tag = Tag(m, ix);
					if tmp_tag.unary:
						if tmp_tag.start < start_ix and tmp_tag.end > start_ix: # exact match
							return action(tmp_tag, None, start_ix)
					elif backward_stack and backward_stack[-1].name == tmp_tag.name:
						backward_stack.pop()
					else: # found nearest unclosed tag
						opening_tag = tmp_tag
						break
				elif check_str.startswith('<!--'): # found comment start
					end_ix = check_str.find('-->') + ix + 3;
					if ix < start_ix and end_ix >= start_ix:
						return action(Comment(ix, end_ix))
		elif ch == '-' and has_match('-->'): # found comment end
			# search left until comment start is reached
			ix = find_comment_start(ix)

		ix -= 1
		
	if not opening_tag:
		return action(None)
	
	# find closing tag
	if not closing_tag:
		ix = start_ix
		while ix < html_len:
			ch = html[ix]
			if ch == '<':
				check_str = html[ix:]
				m = re.match(start_tag, check_str)
				if m: # found opening tag
					tmp_tag = Tag(m, ix);
					if not tmp_tag.unary:
						forward_stack.append(tmp_tag)
				else:
					m = re.match(end_tag, check_str)
					if m:   #found closing tag
						tmp_tag = Tag(m, ix);
						if forward_stack and forward_stack[-1].name == tmp_tag.name:
							forward_stack.pop()
						else:  # found matched closing tag
							closing_tag = tmp_tag;
							break
					elif has_match('<!--'): # found comment
						ix += check_str.find('-->') + 3
						continue
			elif ch == '-' and has_match('-->'):
				# looks like cursor was inside comment with invalid HTML
				if not forward_stack or forward_stack[-1].type != 'comment':
					end_ix = ix + 3
					return action(Comment( find_comment_start(ix), end_ix ))
				
			ix += 1
	
	return action(opening_tag, closing_tag, start_ix)

########NEW FILE########
__FILENAME__ = plugin
# @file plugin.py
#
# Connect Zen Coding to Gedit.
#
# Author Franck Marcia (franck.marcia@gmail.com)
#
from gi.repository import Gedit, GObject, Gtk
import os
from zen_editor import ZenEditor

zencoding_ui_str = """
<ui>
  <menubar name="MenuBar">
    <menu name="EditMenu" action="Edit">
      <placeholder name="EditOps_5">
        <menu action="ZenCodingMenuAction">
          <menuitem name="ZenCodingExpand"   action="ZenCodingExpandAction"/>
          <menuitem name="ZenCodingExpandW"  action="ZenCodingExpandWAction"/>
          <menuitem name="ZenCodingWrap"     action="ZenCodingWrapAction"/>
          <separator/>
          <menuitem name="ZenCodingInward"   action="ZenCodingInwardAction"/>
          <menuitem name="ZenCodingOutward"  action="ZenCodingOutwardAction"/>
          <menuitem name="ZenCodingMerge"    action="ZenCodingMergeAction"/>
          <separator/>
          <menuitem name="ZenCodingPrev"     action="ZenCodingPrevAction"/>
          <menuitem name="ZenCodingNext"     action="ZenCodingNextAction"/>
          <separator/>
          <menuitem name="ZenCodingRemove"   action="ZenCodingRemoveAction"/>
          <menuitem name="ZenCodingSplit"    action="ZenCodingSplitAction"/>
          <menuitem name="ZenCodingComment"  action="ZenCodingCommentAction"/>
        </menu>
      </placeholder>
    </menu>
  </menubar>
</ui>
"""

class ZenCodingPlugin(GObject.Object, Gedit.WindowActivatable):
    """A Gedit plugin to implement Zen Coding's HTML and CSS shorthand expander."""

    window = GObject.property(type=Gedit.Window)
    
    def do_activate(self):
        actions = [
          ('ZenCodingMenuAction',     None, '_Zen Coding',                     None,                 "Zen Coding tools",                            None),
          ('ZenCodingExpandAction',   None, '_Expand abbreviation',            '<Ctrl>E',            "Expand abbreviation to raw HTML/CSS",         self.expand_abbreviation),
          ('ZenCodingExpandWAction',  None, '_Expand dynamic abbreviation...', '<Ctrl><Alt>E',       "Dynamically expand abbreviation as you type", self.expand_with_abbreviation),
          ('ZenCodingWrapAction',     None, '_Wrap with abbreviation...',      '<Ctrl><Shift>E',     "Wrap with code expanded from abbreviation",   self.wrap_with_abbreviation),
          ('ZenCodingInwardAction',   None, 'Balance tag _inward',             '<Ctrl><Alt>I',       "Select inner tag's content",                  self.match_pair_inward),
          ('ZenCodingOutwardAction',  None, 'Balance tag _outward',            '<Ctrl><Alt><Shift>O',"Select outer tag's content",                  self.match_pair_outward),
          ('ZenCodingMergeAction',    None, '_Merge lines',                    '<Ctrl><Alt>M',       "Merge all lines of the current selection",    self.merge_lines),
          ('ZenCodingPrevAction',     None, '_Previous edit point',            '<Alt>Left',          "Place the cursor at the previous edit point", self.prev_edit_point),
          ('ZenCodingNextAction',     None, '_Next edit point',                '<Alt>Right',         "Place the cursor at the next edit point",     self.next_edit_point),
          ('ZenCodingRemoveAction',   None, '_Remove tag',                     '<Ctrl><Alt>R',       "Remove a tag",                                self.remove_tag),
          ('ZenCodingSplitAction',    None, 'Split or _join tag',              '<Ctrl><Alt>J',       "Toggle between single and double tag",        self.split_join_tag),
          ('ZenCodingCommentAction',  None, 'Toggle _comment',                 '<Ctrl><Alt>C',       "Toggle an XML or HTML comment",               self.toggle_comment)
        ]
        windowdata = dict()
        self.window.ZenCodingPluginDataKey = windowdata
        windowdata["action_group"] = Gtk.ActionGroup("GeditZenCodingPluginActions")
        windowdata["action_group"].add_actions(actions)
        manager = self.window.get_ui_manager()
        manager.insert_action_group(windowdata["action_group"], -1)
        windowdata["ui_id"] = manager.add_ui_from_string(zencoding_ui_str)
        self.window.ZenCodingPluginInfo = windowdata
        self.editor = ZenEditor()
        error = self.editor.get_user_settings_error()
        if error:
            md = Gtk.MessageDialog(self.window, Gtk.DialogFlags.MODAL, Gtk.MessageType.ERROR,
                Gtk.ButtonsType.CLOSE, "There is an error in user settings:")
            message = "{0} on line {1} at character {2}\n\nUser settings will not be available."
            md.set_title("Zen Coding error")
            md.format_secondary_text(message.format(error['msg'], error['lineno'], error['offset']))
            md.run()
            md.destroy()


    def do_deactivate(self):
        windowdata = self.window.ZenCodingPluginDataKey
        manager = self.window.get_ui_manager()
        manager.remove_ui(windowdata["ui_id"])
        manager.remove_action_group(windowdata["action_group"])

    def do_update_state(self):
        view = self.window.get_active_view()
        windowdata = self.window.ZenCodingPluginDataKey
        windowdata["action_group"].set_sensitive(bool(view and view.get_editable()))

    def expand_abbreviation(self, action):
        self.editor.expand_abbreviation(self.window)
        
    def expand_with_abbreviation(self, action):
        self.editor.expand_with_abbreviation(self.window)

    def wrap_with_abbreviation(self, action):
        self.editor.wrap_with_abbreviation(self.window)

    def match_pair_inward(self, action):
        self.editor.match_pair_inward(self.window)

    def match_pair_outward(self, action):
        self.editor.match_pair_outward(self.window)

    def merge_lines(self, action):
        self.editor.merge_lines(self.window)

    def prev_edit_point(self, action):
        self.editor.prev_edit_point(self.window)

    def next_edit_point(self, action):
        self.editor.next_edit_point(self.window)

    def remove_tag(self, action):
        self.editor.remove_tag(self.window)

    def split_join_tag(self, action):
        self.editor.split_join_tag(self.window)

    def toggle_comment(self, action):
        self.editor.toggle_comment(self.window)

########NEW FILE########
__FILENAME__ = stparser
'''
Zen Coding's settings parser
Created on Jun 14, 2009

@author: Sergey Chikuyonok (http://chikuyonok.ru)
'''
from copy import deepcopy

import re
import types
from zen_settings import zen_settings

_original_settings = deepcopy(zen_settings)

TYPE_ABBREVIATION = 'zen-tag',
TYPE_EXPANDO = 'zen-expando',
TYPE_REFERENCE = 'zen-reference';
""" Reference to another abbreviation or tag """

re_tag = r'^<([\w\-]+(?:\:[\w\-]+)?)((?:\s+[\w\-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>\s]+))?)*)\s*(\/?)>'
"Regular expression for XML tag matching"
	
re_attrs = r'([\w\-]+)\s*=\s*([\'"])(.*?)\2'
"Regular expression for matching XML attributes"

class Entry:
	"""
	Unified object for parsed data
	"""
	def __init__(self, entry_type, key, value):
		"""
		@type entry_type: str
		@type key: str
		@type value: dict
		"""
		self.type = entry_type
		self.key = key
		self.value = value

def _make_expando(key, value):
	"""
	Make expando from string
	@type key: str
	@type value: str
	@return: Entry
	"""
	return Entry(TYPE_EXPANDO, key, value)

def _make_abbreviation(key, tag_name, attrs, is_empty=False):
	"""
	Make abbreviation from string
	@param key: Abbreviation key
	@type key: str
	@param tag_name: Expanded element's tag name
	@type tag_name: str
	@param attrs: Expanded element's attributes
	@type attrs: str
	@param is_empty: Is expanded element empty or not
	@type is_empty: bool
	@return: dict
	"""
	result = {
		'name': tag_name,
		'is_empty': is_empty
	};
	
	if attrs:
		result['attributes'] = [];
		for m in re.findall(re_attrs, attrs):
			result['attributes'].append({
				'name': m[0],
				'value': m[2]
			})
			
	return Entry(TYPE_ABBREVIATION, key, result)

def _parse_abbreviations(obj):
	"""
	Parses all abbreviations inside dictionary
 	@param obj: dict
	"""
	for key, value in obj.items():
		key = key.strip()
		if key[-1] == '+':
#			this is expando, leave 'value' as is
			obj[key] = _make_expando(key, value)
		else:
			m = re.search(re_tag, value)
			if m:
				obj[key] = _make_abbreviation(key, m.group(1), m.group(2), (m.group(3) == '/'))
			else:
#				assume it's reference to another abbreviation
				obj[key] = Entry(TYPE_REFERENCE, key, value)

def parse(settings):
	"""
	Parse user's settings. This function must be called *before* any activity
	in zen coding (for example, expanding abbreviation)
 	@type settings: dict
	"""
	for p, value in settings.items():
		if p == 'abbreviations':
			_parse_abbreviations(value)
		elif p == 'extends':
			settings[p] = [v.strip() for v in value.split(',')]
		elif type(value) == types.DictType:
			parse(value)


def extend(parent, child):
	"""
	Recursevly extends parent dictionary with children's keys. Used for merging
	default settings with user's
	@type parent: dict
	@type child: dict
	"""
	for p, value in child.items():
		if type(value) == types.DictType:
			if p not in parent:
				parent[p] = {}
			extend(parent[p], value)
		else:
			parent[p] = value
				


def create_maps(obj):
	"""
	Create hash maps on certain string properties of zen settings
	@type obj: dict
	"""
	for p, value in obj.items():
		if p == 'element_types':
			for k, v in value.items():
				if isinstance(v, str):
					value[k] = [el.strip() for el in v.split(',')]
		elif type(value) == types.DictType:
			create_maps(value)


if __name__ == '__main__':
	pass

def get_settings(user_settings=None):
	"""
	Main function that gather all settings and returns parsed dictionary
	@param user_settings: A dictionary of user-defined settings
	"""
	settings = deepcopy(_original_settings)
	create_maps(settings)
	
	if user_settings:
		user_settings = deepcopy(user_settings)
		create_maps(user_settings)
		extend(settings, user_settings)
	
	# now we need to parse final set of settings
	parse(settings)
	
	return settings
	

########NEW FILE########
__FILENAME__ = zen_actions
#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Middleware layer that communicates between editor and Zen Coding.
This layer describes all available Zen Coding actions, like 
"Expand Abbreviation".
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
"""
from zencoding import zen_core as zen_coding
from zencoding import html_matcher
import re
from zen_core import char_at

def find_abbreviation(editor):
	"""
	Search for abbreviation in editor from current caret position
	@param editor: Editor instance
	@type editor: ZenEditor
	@return: str
	"""
	start, end = editor.get_selection_range()
	if start != end:
		# abbreviation is selected by user
		return editor.get_content()[start:end]
	
	# search for new abbreviation from current caret position
	cur_line_start, cur_line_end = editor.get_current_line_range()
	return zen_coding.extract_abbreviation(editor.get_content()[cur_line_start:start])

def expand_abbreviation(editor, syntax=None, profile_name=None):
	"""
	Find from current caret position and expand abbreviation in editor
	@param editor: Editor instance
	@type editor: ZenEditor
	@param syntax: Syntax type (html, css, etc.)
	@type syntax: str
	@param profile_name: Output profile name (html, xml, xhtml)
	@type profile_name: str
	@return: True if abbreviation was expanded successfully
	"""
	if syntax is None: syntax = editor.get_syntax()
	if profile_name is None: profile_name = editor.get_profile_name()
	
	range_start, caret_pos = editor.get_selection_range()
	abbr = find_abbreviation(editor)
	content = ''
		
	if abbr:
		content = zen_coding.expand_abbreviation(abbr, syntax, profile_name)
		if content:
			editor.replace_content(content, caret_pos - len(abbr), caret_pos)
			return True
	
	return False

def expand_abbreviation_with_tab(editor, syntax, profile_name='xhtml'):
	"""
	A special version of <code>expandAbbreviation</code> function: if it can't
	find abbreviation, it will place Tab character at caret position
	@param editor: Editor instance
	@type editor: ZenEditor
	@param syntax: Syntax type (html, css, etc.)
	@type syntax: str
	@param profile_name: Output profile name (html, xml, xhtml)
	@type profile_name: str
	"""
	if not expand_abbreviation(editor, syntax, profile_name):
		editor.replace_content(zen_coding.get_variable('indentation'), editor.get_caret_pos())
	
	return True 

def match_pair(editor, direction='out', syntax=None):
	"""
	Find and select HTML tag pair
	@param editor: Editor instance
	@type editor: ZenEditor
	@param direction: Direction of pair matching: 'in' or 'out'. 
	@type direction: str 
	"""
	direction = direction.lower()
	if syntax is None: syntax = editor.get_profile_name()
	
	range_start, range_end = editor.get_selection_range()
	cursor = range_end
	content = editor.get_content()
	rng = None
	
	old_open_tag = html_matcher.last_match['opening_tag']
	old_close_tag = html_matcher.last_match['closing_tag']
	
	if direction == 'in' and old_open_tag and range_start != range_end:
#		user has previously selected tag and wants to move inward
		if not old_close_tag:
#			unary tag was selected, can't move inward
			return False
		elif old_open_tag.start == range_start:
			if content[old_open_tag.end] == '<':
#				test if the first inward tag matches the entire parent tag's content
				_r = html_matcher.find(content, old_open_tag.end + 1, syntax)
				if _r[0] == old_open_tag.end and _r[1] == old_close_tag.start:
					rng = html_matcher.match(content, old_open_tag.end + 1, syntax)
				else:
					rng = (old_open_tag.end, old_close_tag.start)
			else:
				rng = (old_open_tag.end, old_close_tag.start)
		else:
			new_cursor = content[0:old_close_tag.start].find('<', old_open_tag.end)
			search_pos = new_cursor + 1 if new_cursor != -1 else old_open_tag.end
			rng = html_matcher.match(content, search_pos, syntax)
	else:
		rng = html_matcher.match(content, cursor, syntax)
	
	if rng and rng[0] is not None:
		editor.create_selection(rng[0], rng[1])
		return True
	else:
		return False

def match_pair_inward(editor):
	return match_pair(editor, 'in')
	
def match_pair_outward(editor):
	return match_pair(editor, 'out')

def narrow_to_non_space(text, start, end):
	"""
	Narrow down text indexes, adjusting selection to non-space characters
	@type text: str
	@type start: int
	@type end: int
	@return: list
	"""
	# narrow down selection until first non-space character
	while start < end:
		if not text[start].isspace():
			break
			
		start += 1
	
	while end > start:
		end -= 1
		if not text[end].isspace():
			end += 1
			break
		
	return start, end

def wrap_with_abbreviation(editor, abbr, syntax=None, profile_name=None):
	"""
	Wraps content with abbreviation
	@param editor: Editor instance
	@type editor: ZenEditor
	@param syntax: Syntax type (html, css, etc.)
	@type syntax: str
	@param profile_name: Output profile name (html, xml, xhtml)
	@type profile_name: str
	"""
	if not abbr: return None 
	
	if syntax is None: syntax = editor.get_syntax()
	if profile_name is None: profile_name = editor.get_profile_name()
	
	start_offset, end_offset = editor.get_selection_range()
	content = editor.get_content()
	
	if start_offset == end_offset:
		# no selection, find tag pair
		rng = html_matcher.match(content, start_offset, profile_name)
		
		if rng[0] is None: # nothing to wrap
			return None
		else:
			start_offset, end_offset = rng
			
	start_offset, end_offset = narrow_to_non_space(content, start_offset, end_offset)
	line_bounds = get_line_bounds(content, start_offset)
	padding = get_line_padding(content[line_bounds[0]:line_bounds[1]])
	
	new_content = content[start_offset:end_offset]
	result = zen_coding.wrap_with_abbreviation(abbr, unindent_text(new_content, padding), syntax, profile_name)
	
	if result:
		editor.replace_content(result, start_offset, end_offset)
		return True
	
	return False

def unindent(editor, text):
	"""
	Unindent content, thus preparing text for tag wrapping
	@param editor: Editor instance
	@type editor: ZenEditor
	@param text: str
	@return str
	"""
	return unindent_text(text, get_current_line_padding(editor))

def unindent_text(text, pad):
	"""
	Removes padding at the beginning of each text's line
	@type text: str
	@type pad: str
	"""
	lines = zen_coding.split_by_lines(text)
	
	for i,line in enumerate(lines):
		if line.startswith(pad):
			lines[i] = line[len(pad):]
	
	return zen_coding.get_newline().join(lines)

def get_current_line_padding(editor):
	"""
	Returns padding of current editor's line
	@return str
	"""
	return get_line_padding(editor.get_current_line())

def get_line_padding(line):
	"""
	Returns padding of current editor's line
	@return str
	"""
	m = re.match(r'^(\s+)', line)
	return m and m.group(0) or ''

def find_new_edit_point(editor, inc=1, offset=0):
	"""
	Search for new caret insertion point
	@param editor: Editor instance
	@type editor: ZenEditor
	@param inc: Search increment: -1  search left, 1  search right
	@param offset: Initial offset relative to current caret position
	@return: -1 if insertion point wasn't found
	"""
	cur_point = editor.get_caret_pos() + offset
	content = editor.get_content()
	max_len = len(content)
	next_point = -1
	re_empty_line = r'^\s+$'
	
	def get_line(ix):
		start = ix
		while start >= 0:
			c = content[start]
			if c == '\n' or c == '\r': break
			start -= 1
		
		return content[start:ix]
		
	while cur_point < max_len and cur_point > 0:
		cur_point += inc
		cur_char = char_at(content, cur_point)
		next_char = char_at(content, cur_point + 1)
		prev_char = char_at(content, cur_point - 1)
		
		if cur_char in '"\'':
			if next_char == cur_char and prev_char == '=':
				# empty attribute
				next_point = cur_point + 1
		elif cur_char == '>' and next_char == '<':
			# between tags
			next_point = cur_point + 1
		elif cur_char == ':' and next_char == ';':
			# empty CSS value
			next_point = cur_point + 1
		elif cur_char == '(' and next_char == ')':
		    # empty CSS parenthesis
		    next_point = cur_point + 1
		elif cur_char in '\r\n':
			# empty line
			if re.search(re_empty_line, get_line(cur_point - 1)):
				next_point = cur_point
		
		if next_point != -1: break
	
	return next_point

def prev_edit_point(editor):
	"""
	Move caret to previous edit point
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	cur_pos = editor.get_caret_pos()
	new_point = find_new_edit_point(editor, -1)
		
	if new_point == cur_pos:
		# we're still in the same point, try searching from the other place
		new_point = find_new_edit_point(editor, -1, -2)
	
	if new_point != -1:
		editor.set_caret_pos(new_point)
		return True
	
	return False

def next_edit_point(editor):
	"""
	Move caret to next edit point
	@param editor: Editor instance
	@type editor: ZenEditor
	""" 
	new_point = find_new_edit_point(editor, 1)
	if new_point != -1:
		editor.set_caret_pos(new_point)
		return True
	
	return False

def insert_formatted_newline(editor, mode='html'):
	"""
	Inserts newline character with proper indentation
	@param editor: Editor instance
	@type editor: ZenEditor
	@param mode: Syntax mode (only 'html' is implemented)
	@type mode: str
	"""
	caret_pos = editor.get_caret_pos()
	nl = zen_coding.get_newline()
	pad = zen_coding.get_variable('indentation')
		
	if mode == 'html':
		# let's see if we're breaking newly created tag
		pair = html_matcher.get_tags(editor.get_content(), editor.get_caret_pos(), editor.get_profile_name())
		
		if pair[0] and pair[1] and pair[0]['type'] == 'tag' and pair[0]['end'] == caret_pos and pair[1]['start'] == caret_pos:
			editor.replace_content(nl + pad + zen_coding.get_caret_placeholder() + nl, caret_pos)
		else:
			editor.replace_content(nl, caret_pos)
	else:
		editor.replace_content(nl, caret_pos)
		
	return True

def select_line(editor):
	"""
	Select line under cursor
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	start, end = editor.get_current_line_range();
	editor.create_selection(start, end)
	return True

def go_to_matching_pair(editor):
	"""
	Moves caret to matching opening or closing tag
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	content = editor.get_content()
	caret_pos = editor.get_caret_pos()
	
	if content[caret_pos] == '<': 
		# looks like caret is outside of tag pair  
		caret_pos += 1
		
	tags = html_matcher.get_tags(content, caret_pos, editor.get_profile_name())
		
	if tags and tags[0]:
		# match found
		open_tag, close_tag = tags
			
		if close_tag: # exclude unary tags
			if open_tag['start'] <= caret_pos and open_tag['end'] >= caret_pos:
				editor.set_caret_pos(close_tag['start'])
			elif close_tag['start'] <= caret_pos and close_tag['end'] >= caret_pos:
				editor.set_caret_pos(open_tag['start'])
				
		return True
	
	return False
				

def merge_lines(editor):
	"""
	Merge lines spanned by user selection. If there's no selection, tries to find
	matching tags and use them as selection
	@param editor: Editor instance
	@type editor: ZenEditor
	"""
	start, end = editor.get_selection_range()
	if start == end:
		# find matching tag
		pair = html_matcher.match(editor.get_content(), editor.get_caret_pos(), editor.get_profile_name())
		if pair and pair[0] is not None:
			start, end = pair
	
	if start != end:
		# got range, merge lines
		text = editor.get_content()[start:end]
		lines = map(lambda s: re.sub(r'^\s+', '', s), zen_coding.split_by_lines(text))
		text = re.sub(r'\s{2,}', ' ', ''.join(lines))
		editor.replace_content(text, start, end)
		editor.create_selection(start, start + len(text))
		return True
	
	return False

def toggle_comment(editor):
	"""
	Toggle comment on current editor's selection or HTML tag/CSS rule
	@type editor: ZenEditor
	"""
	syntax = editor.get_syntax()
	if syntax == 'css':
		return toggle_css_comment(editor)
	else:
		return toggle_html_comment(editor)

def toggle_html_comment(editor):
	"""
	Toggle HTML comment on current selection or tag
	@type editor: ZenEditor
	@return: True if comment was toggled
	"""
	start, end = editor.get_selection_range()
	content = editor.get_content()
		
	if start == end:
		# no selection, find matching tag
		pair = html_matcher.get_tags(content, editor.get_caret_pos(), editor.get_profile_name())
		if pair and pair[0]: # found pair
			start = pair[0].start
			end = pair[1] and pair[1].end or pair[0].end
	
	return generic_comment_toggle(editor, '<!--', '-->', start, end)

def toggle_css_comment(editor):
	"""
	Simple CSS commenting
	@type editor: ZenEditor
	@return: True if comment was toggled
	"""
	start, end = editor.get_selection_range()
	
	if start == end:
		# no selection, get current line
		start, end = editor.get_current_line_range()

		# adjust start index till first non-space character
		start, end = narrow_to_non_space(editor.get_content(), start, end)
	
	return generic_comment_toggle(editor, '/*', '*/', start, end)

def search_comment(text, pos, start_token, end_token):
	"""
	Search for nearest comment in <code>str</code>, starting from index <code>from</code>
	@param text: Where to search
	@type text: str
	@param pos: Search start index
	@type pos: int
	@param start_token: Comment start string
	@type start_token: str
	@param end_token: Comment end string
	@type end_token: str
	@return: None if comment wasn't found, list otherwise
	"""
	start_ch = start_token[0]
	end_ch = end_token[0]
	comment_start = -1
	comment_end = -1
	
	def has_match(tx, start):
		return text[start:start + len(tx)] == tx
	
		
	# search for comment start
	while pos:
		pos -= 1
		if text[pos] == start_ch and has_match(start_token, pos):
			comment_start = pos
			break
	
	if comment_start != -1:
		# search for comment end
		pos = comment_start
		content_len = len(text)
		while content_len >= pos:
			pos += 1
			if text[pos] == end_ch and has_match(end_token, pos):
				comment_end = pos + len(end_token)
				break
	
	if comment_start != -1 and comment_end != -1:
		return comment_start, comment_end
	else:
		return None

def generic_comment_toggle(editor, comment_start, comment_end, range_start, range_end):
	"""
	Generic comment toggling routine
	@type editor: ZenEditor
	@param comment_start: Comment start token
	@type comment_start: str
	@param comment_end: Comment end token
	@type comment_end: str
	@param range_start: Start selection range
	@type range_start: int
	@param range_end: End selection range
	@type range_end: int
	@return: bool
	"""
	content = editor.get_content()
	caret_pos = [editor.get_caret_pos()]
	new_content = None
		
	def adjust_caret_pos(m):
		caret_pos[0] -= len(m.group(0))
		return ''
		
	def remove_comment(text):
		"""
		Remove comment markers from string
		@param {Sting} str
		@return {String}
		"""
		text = re.sub(r'^' + re.escape(comment_start) + r'\s*', adjust_caret_pos, text)
		return re.sub(r'\s*' + re.escape(comment_end) + '$', '', text)
	
	def has_match(tx, start):
		return content[start:start + len(tx)] == tx
	
	# first, we need to make sure that this substring is not inside comment
	comment_range = search_comment(content, caret_pos[0], comment_start, comment_end)
	
	if comment_range and comment_range[0] <= range_start and comment_range[1] >= range_end:
		# we're inside comment, remove it
		range_start, range_end = comment_range
		new_content = remove_comment(content[range_start:range_end])
	else:
		# should add comment
		# make sure that there's no comment inside selection
		new_content = '%s %s %s' % (comment_start, re.sub(re.escape(comment_start) + r'\s*|\s*' + re.escape(comment_end), '', content[range_start:range_end]), comment_end)
			
		# adjust caret position
		caret_pos[0] += len(comment_start) + 1

	# replace editor content
	if new_content is not None:
		d = caret_pos[0] - range_start
		new_content = new_content[0:d] + zen_coding.get_caret_placeholder() + new_content[d:]
		editor.replace_content(unindent(editor, new_content), range_start, range_end)
		return True
	
	return False

def split_join_tag(editor, profile_name=None):
	"""
	Splits or joins tag, e.g. transforms it into a short notation and vice versa:
	<div></div>  <div /> : join
	<div />  <div></div> : split
	@param editor: Editor instance
	@type editor: ZenEditor
	@param profile_name: Profile name
	@type profile_name: str
	"""
	caret_pos = editor.get_caret_pos()
	profile = zen_coding.get_profile(profile_name or editor.get_profile_name())
	caret = zen_coding.get_caret_placeholder()

	# find tag at current position
	pair = html_matcher.get_tags(editor.get_content(), caret_pos, profile_name or editor.get_profile_name())
	if pair and pair[0]:
		new_content = pair[0].full_tag
		
		if pair[1]: # join tag
			closing_slash = ''
			if profile['self_closing_tag'] is True:
				closing_slash = '/'
			elif profile['self_closing_tag'] == 'xhtml':
				closing_slash = ' /'
				
			new_content = re.sub(r'\s*>$', closing_slash + '>', new_content)
			
			# add caret placeholder
			if len(new_content) + pair[0].start < caret_pos:
				new_content += caret
			else:
				d = caret_pos - pair[0].start
				new_content = new_content[0:d] + caret + new_content[d:]
			
			editor.replace_content(new_content, pair[0].start, pair[1].end)
		else: # split tag
			nl = zen_coding.get_newline()
			pad = zen_coding.get_variable('indentation')
			
			# define tag content depending on profile
			tag_content = profile['tag_nl'] is True and nl + pad + caret + nl or caret
			
			new_content = '%s%s</%s>' % (re.sub(r'\s*\/>$', '>', new_content), tag_content, pair[0].name)
			editor.replace_content(new_content, pair[0].start, pair[0].end)
		
		return True
	else:
		return False
	

def get_line_bounds(text, pos):
	"""
	Returns line bounds for specific character position
	@type text: str
	@param pos: Where to start searching
	@type pos: int
	@return: list
	"""
	start = 0
	end = len(text) - 1
	
	# search left
	for i in range(pos - 1, 0, -1):
		if text[i] in '\n\r':
			start = i + 1
			break
		
	# search right
	for i in range(pos, len(text)):
		if text[i] in '\n\r':
			end = i
			break
		
	return start, end

def remove_tag(editor):
	"""
	Gracefully removes tag under cursor
	@type editor: ZenEditor
	"""
	caret_pos = editor.get_caret_pos()
	content = editor.get_content()
		
	# search for tag
	pair = html_matcher.get_tags(content, caret_pos, editor.get_profile_name())
	if pair and pair[0]:
		if not pair[1]:
			# simply remove unary tag
			editor.replace_content(zen_coding.get_caret_placeholder(), pair[0].start, pair[0].end)
		else:
			tag_content_range = narrow_to_non_space(content, pair[0].end, pair[1].start)
			start_line_bounds = get_line_bounds(content, tag_content_range[0])
			start_line_pad = get_line_padding(content[start_line_bounds[0]:start_line_bounds[1]])
			tag_content = content[tag_content_range[0]:tag_content_range[1]]
				
			tag_content = unindent_text(tag_content, start_line_pad)
			editor.replace_content(zen_coding.get_caret_placeholder() + tag_content, pair[0].start, pair[1].end)
		
		return True
	else:
		return False

########NEW FILE########
__FILENAME__ = zen_core
#!/usr/bin/env python
# -*- coding: utf-8 -*-
'''
Core Zen Coding library. Contains various text manipulation functions:

== Expand abbreviation
Expands abbreviation like ul#nav>li*5>a into a XHTML string.
=== How to use
First, you have to extract current string (where cursor is) from your test 
editor and use <code>find_abbr_in_line()</code> method to extract abbreviation. 
If abbreviation was found, this method will return it as well as position index
of abbreviation inside current line. If abbreviation wasn't 
found, method returns empty string. With abbreviation found, you should call
<code>parse_into_tree()</code> method to transform abbreviation into a tag tree. 
This method returns <code>Tag</code> object on success, None on failure. Then
simply call <code>to_string()</code> method of returned <code>Tag</code> object
to transoform tree into a XHTML string

You can setup output profile using <code>setup_profile()</code> method 
(see <code>default_profile</code> definition for available options) 

 
Created on Apr 17, 2009

@author: Sergey Chikuyonok (http://chikuyonok.ru)
'''
from zen_settings import zen_settings
import re
import stparser

newline = '\n'
"Newline symbol"

caret_placeholder = '{%::zen-caret::%}'

default_tag = 'div'

re_tag = re.compile(r'<\/?[\w:\-]+(?:\s+[\w\-:]+(?:\s*=\s*(?:(?:"[^"]*")|(?:\'[^\']*\')|[^>\s]+))?)*\s*(\/?)>$')

profiles = {}
"Available output profiles"

default_profile = {
	'tag_case': 'lower',         # values are 'lower', 'upper'
	'attr_case': 'lower',        # values are 'lower', 'upper'
	'attr_quotes': 'double',     # values are 'single', 'double'
	
	'tag_nl': 'decide',          # each tag on new line, values are True, False, 'decide'
	
	'place_cursor': True,        # place cursor char  | (pipe)  in output
	
	'indent': True,              # indent tags
	
	'inline_break': 3,           # how many inline elements should be to force line break (set to 0 to disable)
	
	'self_closing_tag': 'xhtml'  # use self-closing style for writing empty elements, e.g. <br /> or <br>. 
                                 # values are True, False, 'xhtml'
}

basic_filters = 'html';
"Filters that will be applied for unknown syntax"

max_tabstop = 0
"Maximum tabstop index for current session"

def char_at(text, pos):
	"""
	Returns character at specified index of text.
	If index if out of range, returns empty string
	"""
	return text[pos] if pos < len(text) else ''

def has_deep_key(obj, key):
	"""
	Check if <code>obj</code> dictionary contains deep key. For example,
	example, it will allow you to test existance of my_dict[key1][key2][key3],
	testing existance of my_dict[key1] first, then my_dict[key1][key2], 
	and finally my_dict[key1][key2][key3]
	@param obj: Dictionary to test
	@param obj: dict
	@param key: Deep key to test. Can be list (like ['key1', 'key2', 'key3']) or
	string (like 'key1.key2.key3')
	@type key: list, tuple, str
	@return: bool
	"""
	if isinstance(key, str):
		key = key.split('.')
		
	last_obj = obj
	for v in key:
		if hasattr(last_obj, v):
			last_obj = getattr(last_obj, v)
		elif last_obj.has_key(v):
			last_obj = last_obj[v]
		else:
			return False
	
	return True
		

def is_allowed_char(ch):
	"""
	Test if passed symbol is allowed in abbreviation
	@param ch: Symbol to test
	@type ch: str
	@return: bool
	"""
	return ch.isalnum() or ch in "#.>+*:$-_!@[]()|"

def split_by_lines(text, remove_empty=False):
	"""
	Split text into lines. Set <code>remove_empty</code> to true to filter out
	empty lines
	@param text: str
	@param remove_empty: bool
	@return list
	"""
	lines = text.splitlines()
	
	return remove_empty and [line for line in lines if line.strip()] or lines

def make_map(prop):
	"""
	Helper function that transforms string into dictionary for faster search
	@param prop: Key name in <code>zen_settings['html']</code> dictionary
	@type prop: str
	"""
	obj = {}
	for a in zen_settings['html'][prop].split(','):
		obj[a] = True
		
	zen_settings['html'][prop] = obj

def create_profile(options):
	"""
	Create profile by adding default values for passed optoin set
	@param options: Profile options
	@type options: dict
	"""
	for k, v in default_profile.items():
		options.setdefault(k, v)
	
	return options

def setup_profile(name, options = {}):
	"""
	@param name: Profile name
	@type name: str
	@param options: Profile options
	@type options: dict
	"""
	profiles[name.lower()] = create_profile(options);

def get_newline():
	"""
	Returns newline symbol which is used in editor. This function must be 
	redefined to return current editor's settings 
	@return: str
	"""
	return newline

def set_newline(char):
	"""
	Sets newline character used in Zen Coding
	"""
	global newline
	newline = char

def string_to_hash(text):
	"""
	Helper function that transforms string into hash
	@return: dict
	"""
	obj = {}
	items = text.split(",")
	for i in items:
		obj[i] = True
		
	return obj

def pad_string(text, pad):
	"""
	Indents string with space characters (whitespace or tab)
	@param text: Text to indent
	@type text: str
	@param pad: Indentation level (number) or indentation itself (string)
	@type pad: int, str
	@return: str
	"""
	pad_str = ''
	result = ''
	if isinstance(pad, basestring):
		pad_str = pad
	else:
		pad_str = get_indentation() * pad
		
	nl = get_newline()
	
	lines = split_by_lines(text)
	
	if lines:
		result += lines[0]
		for line in lines[1:]:
			result += nl + pad_str + line
			
	return result

def is_snippet(abbr, doc_type = 'html'):
	"""
	Check is passed abbreviation is a snippet
	@return bool
	"""
	return get_snippet(doc_type, abbr) and True or False

def is_ends_with_tag(text):
	"""
	Test is string ends with XHTML tag. This function used for testing if '<'
	symbol belogs to tag or abbreviation 
	@type text: str
	@return: bool
	"""
	return re_tag.search(text) != None

def get_elements_collection(resource, type):
	"""
	Returns specified elements collection (like 'empty', 'block_level') from
	<code>resource</code>. If collections wasn't found, returns empty object
	@type resource: dict
	@type type: str
	@return: dict
	"""
	if 'element_types' in resource and type in resource['element_types']:
		return resource['element_types'][type]
	else:
		return {}
	
def replace_variables(text):
	"""
	Replace variables like ${var} in string
	@param text: str
	@return: str
	"""
	return re.sub(r'\$\{([\w\-]+)\}', lambda m: get_variable(m.group(1)) or m.group(0), text)

def get_abbreviation(res_type, abbr):
	"""
	Returns abbreviation value from data set
	@param res_type: Resource type (html, css, ...)
	@type res_type: str
	@param abbr: Abbreviation name
	@type abbr: str
	@return dict, None
	"""
	return get_settings_resource(res_type, abbr, 'abbreviations')

def get_snippet(res_type, snippet_name):
	"""
	Returns snippet value from data set
	@param res_type: Resource type (html, css, ...)
	@type res_type: str
	@param snippet_name: Snippet name
	@type snippet_name: str
	@return dict, None
	"""
	return get_settings_resource(res_type, snippet_name, 'snippets');

def get_variable(name):
	"""
	Returns variable value
	 @return: str
	"""
	if name in zen_settings['variables']:
		return zen_settings['variables'][name]
	return None

def set_variable(name, value):
	"""
	Set variable value
	"""
	zen_settings['variables'][name] = value

def get_indentation():
	"""
	Returns indentation string
	@return {String}
	"""
	return get_variable('indentation');

def create_resource_chain(syntax, name):
	"""
	Creates resource inheritance chain for lookups
	@param syntax: Syntax name
	@type syntax: str
	@param name: Resource name
	@type name: str
	@return: list
	"""
	result = []
	
	if syntax in zen_settings:
		resource = zen_settings[syntax]
		if name in resource:
			result.append(resource[name])
		if 'extends' in resource:
			# find resource in ancestors
			for type in resource['extends']:
				if  has_deep_key(zen_settings, [type, name]):
					result.append(zen_settings[type][name])
				
	return result

def get_resource(syntax, name):
	"""
	Get resource collection from settings file for specified syntax. 
	It follows inheritance chain if resource wasn't directly found in
	syntax settings
	@param syntax: Syntax name
	@type syntax: str
	@param name: Resource name
	@type name: str
	"""
	chain = create_resource_chain(syntax, name)
	return chain[0] if chain else None

def get_settings_resource(syntax, abbr, name):
	"""
	Returns resurce value from data set with respect of inheritance
	@param syntax: Resource syntax (html, css, ...)
	@type syntax: str
	@param abbr: Abbreviation name
	@type abbr: str
	@param name: Resource name ('snippets' or 'abbreviation')
	@type name: str
	@return dict, None
	"""
	for item in create_resource_chain(syntax, name):
		if abbr in item:
			return item[abbr]
		
	return None

def get_word(ix, text):
	"""
	Get word, starting at <code>ix</code> character of <code>text</code>
	@param ix: int
	@param text: str
	"""
	m = re.match(r'^[\w\-:\$]+', text[ix:])
	return m.group(0) if m else ''
	
def extract_attributes(attr_set):
	"""
	Extract attributes and their values from attribute set 
 	@param attr_set: str
	"""
	attr_set = attr_set.strip()
	loop_count = 100 # endless loop protection
	re_string = r'^(["\'])((?:(?!\1)[^\\]|\\.)*)\1'
	result = []
		
	while attr_set and loop_count:
		loop_count -= 1
		attr_name = get_word(0, attr_set)
		attr = None
		if attr_name:
			attr = {'name': attr_name, 'value': ''}
			
			# let's see if attribute has value
			ch = attr_set[len(attr_name)] if len(attr_set) > len(attr_name) else ''
			if ch == '=':
				ch2 = attr_set[len(attr_name) + 1]
				if ch2 in '"\'':
					# we have a quoted string
					m = re.match(re_string, attr_set[len(attr_name) + 1:])
					if m:
						attr['value'] = m.group(2)
						attr_set = attr_set[len(attr_name) + len(m.group(0)) + 1:].strip()
					else:
						# something wrong, break loop
						attr_set = ''
				else:
					# unquoted string
					m = re.match(r'^(.+?)(\s|$)', attr_set[len(attr_name) + 1:])
					if m:
						attr['value'] = m.group(1)
						attr_set = attr_set[len(attr_name) + len(m.group(1)) + 1:].strip()
					else:
						# something wrong, break loop
						attr_set = ''
				
			else:
				attr_set = attr_set[len(attr_name):].strip()
		else:
			# something wrong, can't extract attribute name
			break
		
		if attr: result.append(attr)
		
	return result

def parse_attributes(text):
	"""
	Parses tag attributes extracted from abbreviation
	"""
	
#	Example of incoming data:
#	#header
#	.some.data
#	.some.data#header
#	[attr]
#	#item[attr=Hello other="World"].class

	result = []
	class_name = None
	char_map = {'#': 'id', '.': 'class'}
	
	# walk char-by-char
	i = 0
	il = len(text)
		
	while i < il:
		ch = text[i]
		
		if ch == '#': # id
			val = get_word(i, text[1:])
			result.append({'name': char_map[ch], 'value': val})
			i += len(val) + 1
			
		elif ch == '.': #class
			val = get_word(i, text[1:])
			if not class_name:
				# remember object pointer for value modification
				class_name = {'name': char_map[ch], 'value': ''}
				result.append(class_name)
			
			if class_name['value']:
				class_name['value'] += ' ' + val
			else:
				class_name['value'] = val
			
			i += len(val) + 1
				
		elif ch == '[': # begin attribute set
			# search for end of set
			end_ix = text.find(']', i)
			if end_ix == -1:
				# invalid attribute set, stop searching
				i = len(text)
			else:
				result.extend(extract_attributes(text[i + 1:end_ix]))
				i = end_ix
		else:
			i += 1
		
		
	return result

class AbbrGroup(object):
	"""
	Abreviation's group element
	"""
	def __init__(self, parent=None):
		"""
		@param parent: Parent group item element
		@type parent: AbbrGroup
		"""
		self.expr = ''
		self.parent = parent
		self.children = []
		
	def add_child(self):
		child = AbbrGroup(self)
		self.children.append(child)
		return child
	
	def clean_up(self):
		for item in self.children:
			expr = item.expr
			if not expr:
				self.children.remove(item)
			else:
				# remove operators at the and of expression
				item.clean_up()

def split_by_groups(abbr):
	"""
	Split abbreviation by groups
	@type abbr: str
	@return: AbbrGroup
	"""
	root = AbbrGroup()
	last_parent = root
	cur_item = root.add_child()
	stack = []
	i = 0
	il = len(abbr)
	
	while i < il:
		ch = abbr[i]
		if ch == '(':
			# found new group
			operator = i and abbr[i - 1] or ''
			if operator == '>':
				stack.append(cur_item)
				last_parent = cur_item
			else:
				stack.append(last_parent)
			cur_item = None
		elif ch == ')':
			last_parent = stack.pop()
			cur_item = None
			next_char = char_at(abbr, i + 1)
			if next_char == '+' or next_char == '>': 
				# next char is group operator, skip it
				i += 1
		else:
			if ch == '+' or ch == '>':
				# skip operator if it's followed by parenthesis
				next_char = char_at(abbr, i + 1)
				if next_char == '(':
					i += 1 
					continue
			
			if not cur_item:
				cur_item = last_parent.add_child()
			cur_item.expr += ch
			
		i += 1
	
	root.clean_up()
	return root

def rollout_tree(tree, parent=None):
	"""
	Roll outs basic Zen Coding tree into simplified, DOM-like tree.
	The simplified tree, for example, represents each multiplied element 
	as a separate element sets with its own content, if exists.
	 
	The simplified tree element contains some meta info (tag name, attributes, 
	etc.) as well as output strings, which are exactly what will be outputted
	after expanding abbreviation. This tree is used for <i>filtering</i>:
	you can apply filters that will alter output strings to get desired look
	of expanded abbreviation.
	 
	@type tree: Tag
	@param parent: ZenNode
	"""
	if not parent:
		parent = ZenNode(tree)
		
	how_many = 1
	tag_content = ''
	
	for child in tree.children:
		how_many = child.count
		
		if child.repeat_by_lines:
			# it's a repeating element
			tag_content = split_by_lines(child.get_content(), True)
			how_many = max(len(tag_content), 1)
		else:
			tag_content = child.get_content()
		
		for j in range(how_many):
			tag = ZenNode(child)
			parent.add_child(tag)
			tag.counter = j + 1
			
			if child.children:
				rollout_tree(child, tag)
				
			add_point = tag.find_deepest_child() or tag
			
			if tag_content:
				if isinstance(tag_content, basestring):
					add_point.content = tag_content
				else:
					add_point.content = tag_content[j] or ''
					
	return parent

def run_filters(tree, profile, filter_list):
	"""
	Runs filters on tree
	@type tree: ZenNode
	@param profile: str, object
	@param filter_list: str, list
	@return: ZenNode
	"""
	import filters
	
	if isinstance(profile, basestring) and profile in profiles:
		profile = profiles[profile];
	
	if not profile:
		profile = profiles['plain']
		
	if isinstance(filter_list, basestring):
		filter_list = re.split(r'[\|,]', filter_list)
		
	for name in filter_list:
		name = name.strip()
		if name and name in filters.filter_map:
			tree = filters.filter_map[name](tree, profile)
			
	return tree

def abbr_to_primary_tree(abbr, doc_type='html'):
	"""
	Transforms abbreviation into a primary internal tree. This tree should'n 
	be used ouside of this scope
	@param abbr: Abbreviation to transform
	@type abbr: str
	@param doc_type: Document type (xsl, html), a key of dictionary where to
	search abbreviation settings
	@type doc_type: str
	@return: Tag
	"""
	root = Tag('', 1, doc_type)
	token = re.compile(r'([\+>])?([a-z@\!\#\.][\w:\-]*)((?:(?:[#\.][\w\-\$]+)|(?:\[[^\]]+\]))+)?(\*(\d*))?(\+$)?', re.IGNORECASE)
	
	if not abbr:
		return None
	
	def expando_replace(m):
		ex = m.group(0)
		a = get_abbreviation(doc_type, ex)
		return a and a.value or ex
		
	def token_expander(operator, tag_name, attrs, has_multiplier, multiplier, has_expando):
		multiply_by_lines = (has_multiplier and not multiplier)
		multiplier = multiplier and int(multiplier) or 1
		
		tag_ch = tag_name[0]
		if tag_ch == '#' or tag_ch == '.':
			if attrs: attrs = tag_name + attrs
			else: attrs = tag_name
			tag_name = default_tag
		
		if has_expando:
			tag_name += '+'
		
		current = is_snippet(tag_name, doc_type) and Snippet(tag_name, multiplier, doc_type) or Tag(tag_name, multiplier, doc_type)
		
		if attrs:
			attrs = parse_attributes(attrs)
			for attr in attrs:
				current.add_attribute(attr['name'], attr['value'])
			
		# dive into tree
		if operator == '>' and token_expander.last:
			token_expander.parent = token_expander.last;
			
		token_expander.parent.add_child(current)
		token_expander.last = current
		
		if multiply_by_lines:
			root.multiply_elem = current
		
		return ''
		
	# replace expandos
	abbr = re.sub(r'([a-z][a-z0-9]*)\+$', expando_replace, abbr)
	
	token_expander.parent = root
	token_expander.last = None
	
	
#	abbr = re.sub(token, lambda m: token_expander(m.group(1), m.group(2), m.group(3), m.group(4), m.group(5), m.group(6), m.group(7)), abbr)
	# Issue from Einar Egilsson
	abbr = token.sub(lambda m: token_expander(m.group(1), m.group(2), m.group(3), m.group(4), m.group(5), m.group(6)), abbr)
	
	root.last = token_expander.last
	
	# empty 'abbr' variable means that abbreviation was expanded successfully, 
	# non-empty variable means there was a syntax error
	return not abbr and root or None;

def expand_group(group, doc_type, parent):
	"""
	Expand single group item 
	@param group: AbbrGroup
	@param doc_type: str
	@param parent: Tag
	"""
	tree = abbr_to_primary_tree(group.expr, doc_type)
	last_item = None
		
	if tree:
		for item in tree.children:
			last_item = item
			parent.add_child(last_item)
	else:
		raise Exception('InvalidGroup')
	
	
	# set repeating element to the topmost node
	root = parent
	while root.parent:
		root = root.parent
	
	root.last = tree.last
	if tree.multiply_elem:
		root.multiply_elem = tree.multiply_elem
		
	# process child groups
	if group.children:
		add_point = last_item.find_deepest_child() or last_item
		for child in group.children:
			expand_group(child, doc_type, add_point)

def replace_unescaped_symbol(text, symbol, replace):
	"""
	Replaces unescaped symbols in <code>text</code>. For example, the '$' symbol
	will be replaced in 'item$count', but not in 'item\$count'.
	@param text: Original string
	@type text: str
	@param symbol: Symbol to replace
	@type symbol: st
	@param replace: Symbol replacement
	@type replace: str, function 
	@return: str
	"""
	i = 0
	il = len(text)
	sl = len(symbol)
	match_count = 0
		
	while i < il:
		if text[i] == '\\':
			# escaped symbol, skip next character
			i += sl + 1
		elif text[i:i + sl] == symbol:
			# have match
			cur_sl = sl
			match_count += 1
			new_value = replace
			if callable(new_value):
				replace_data = replace(text, symbol, i, match_count)
				if replace_data:
					cur_sl = len(replace_data[0])
					new_value = replace_data[1]
				else:
					new_value = False
			
			if new_value is False: # skip replacement
				i += 1
				continue
			
			text = text[0:i] + new_value + text[i + cur_sl:]
			# adjust indexes
			il = len(text)
			i += len(new_value)
		else:
			i += 1
	
	return text
	
def run_action(name, *args, **kwargs):
	"""
	 Runs Zen Coding action. For list of available actions and their
	 arguments see zen_actions.py file.
	 @param name: Action name 
	 @type name: str 
	 @param args: Additional arguments. It may be array of arguments
	 or inline arguments. The first argument should be <code>zen_editor</code> instance
	 @type args: list
	 @example
	 zen_coding.run_actions('expand_abbreviation', zen_editor)
	 zen_coding.run_actions('wrap_with_abbreviation', zen_editor, 'div')  
	"""
	import zen_actions
	
	try:
		if hasattr(zen_actions, name):
			return getattr(zen_actions, name)(*args, **kwargs)
	except:
		return False

def expand_abbreviation(abbr, syntax='html', profile_name='plain'):
	"""
	Expands abbreviation into a XHTML tag string
	@type abbr: str
	@return: str
	"""
	tree_root = parse_into_tree(abbr, syntax);
	if tree_root:
		tree = rollout_tree(tree_root)
		apply_filters(tree, syntax, profile_name, tree_root.filters)
		return replace_variables(tree.to_string())
	
	return ''

def extract_abbreviation(text):
	"""
	Extracts abbreviations from text stream, starting from the end
	@type text: str
	@return: Abbreviation or empty string
	"""
	cur_offset = len(text)
	start_index = -1
	brace_count = 0
	
	while True:
		cur_offset -= 1
		if cur_offset < 0:
			# moved at string start
			start_index = 0
			break
		
		ch = text[cur_offset]
		
		if ch == ']':
			brace_count += 1
		elif ch == '[':
			brace_count -= 1
		else:
			if brace_count: 
				# respect all characters inside attribute sets
				continue
			if not is_allowed_char(ch) or (ch == '>' and is_ends_with_tag(text[0:cur_offset + 1])):
				# found stop symbol
				start_index = cur_offset + 1
				break
		
	return text[start_index:] if start_index != -1 else ''

def parse_into_tree(abbr, doc_type='html'):
	"""
	Parses abbreviation into a node set
	@param abbr: Abbreviation to transform
	@type abbr: str
	@param doc_type: Document type (xsl, html), a key of dictionary where to
	search abbreviation settings
	@type doc_type: str
	@return: Tag
	"""
	# remove filters from abbreviation
	filter_list = []
	
	def filter_replace(m):
		filter_list.append(m.group(1))
		return ''
	
	re_filter = re.compile(r'\|([\w\|\-]+)$')
	abbr = re_filter.sub(filter_replace, abbr)
	
	# split abbreviation by groups
	group_root = split_by_groups(abbr)
	tree_root = Tag('', 1, doc_type)
	
	# then recursively expand each group item
	try:
		for item in group_root.children:
			expand_group(item, doc_type, tree_root)
	except:
		# there's invalid group, stop parsing
		return None
	
	tree_root.filters = ''.join(filter_list)
	return tree_root

def is_inside_tag(html, cursor_pos):
	re_tag = re.compile(r'^<\/?\w[\w\:\-]*.*?>')
	
	# search left to find opening brace
	pos = cursor_pos
	while pos > -1:
		if html[pos] == '<': break
		pos -= 1
	
	
	if pos != -1:
		m = re_tag.match(html[pos:]);
		if m and cursor_pos > pos and cursor_pos < pos + len(m.group(0)):
			return True

	return False

def wrap_with_abbreviation(abbr, text, doc_type='html', profile='plain'):
	"""
	Wraps passed text with abbreviation. Text will be placed inside last
	expanded element
	@param abbr: Abbreviation
	@type abbr: str
	
	@param text: Text to wrap
	@type text: str
	
	@param doc_type: Document type (html, xml, etc.)
	@type doc_type: str
	
	@param profile: Output profile's name.
	@type profile: str
	@return {String}
	"""
	tree_root = parse_into_tree(abbr, doc_type)
	if tree_root:
		repeat_elem = tree_root.multiply_elem or tree_root.last
		repeat_elem.set_content(text)
		repeat_elem.repeat_by_lines = bool(tree_root.multiply_elem)
		
		tree = rollout_tree(tree_root)
		apply_filters(tree, doc_type, profile, tree_root.filters);
		return replace_variables(tree.to_string())
	
	return None

def get_caret_placeholder():
	"""
	Returns caret placeholder
	@return: str
	"""
	if callable(caret_placeholder):
		return caret_placeholder()
	else:
		return caret_placeholder

def set_caret_placeholder(value):
	"""
	Set caret placeholder: a string (like '|') or function.
	You may use a function as a placeholder generator. For example,
	TextMate uses ${0}, ${1}, ..., ${n} natively for quick Tab-switching
	between them.
	@param {String|Function}
	"""
	global caret_placeholder
	caret_placeholder = value

def apply_filters(tree, syntax, profile, additional_filters=None):
	"""
	Applies filters to tree according to syntax
	@param tree: Tag tree to apply filters to
	@type tree: ZenNode
	@param syntax: Syntax name ('html', 'css', etc.)
	@type syntax: str
	@param profile: Profile or profile's name
	@type profile: str, object
	@param additional_filters: List or pipe-separated string of additional filters to apply
	@type additional_filters: str, list 
	 
	@return: ZenNode
	"""
	_filters = get_resource(syntax, 'filters') or basic_filters
		
	if additional_filters:
		_filters += '|'
		if isinstance(additional_filters, basestring):
			_filters += additional_filters
		else:
			_filters += '|'.join(additional_filters)
		
	if not _filters:
		# looks like unknown syntax, apply basic filters
		_filters = basic_filters
		
	return run_filters(tree, profile, _filters)

def replace_counter(text, value):
	"""
	 Replaces '$' character in string assuming it might be escaped with '\'
	 @type text: str
	 @type value: str, int
	 @return: str
	"""
	symbol = '$'
	value = str(value)
	
	def replace_func(tx, symbol, pos, match_num):
		if char_at(tx, pos + 1) == '{' or char_at(tx, pos + 1).isdigit():
			# it's a variable, skip it
			return False
		
		# replace sequense of $ symbols with padded number  
		j = pos + 1
		if j < len(text):
			while tx[j] == '$' and char_at(tx, j + 1) != '{': j += 1
		
		return (tx[pos:j], value.zfill(j - pos))
	
	return replace_unescaped_symbol(text, symbol, replace_func)

def upgrade_tabstops(node):
	"""
	Upgrades tabstops in zen node in order to prevent naming conflicts
	@type node: ZenNode
	@param offset: Tab index offset
	@type offset: int
	@returns Maximum tabstop index in element
	"""
	max_num = [0]
	props = ('start', 'end', 'content')
	
	def _replace(m):
		num = int(m.group(1) or m.group(2))
		if num > max_num[0]: max_num[0] = num
		return re.sub(r'\d+', str(num + max_tabstop), m.group(0), 1)
	
	for prop in props:
		node.__setattr__(prop, re.sub(r'\$(\d+)|\$\{(\d+):[^\}]+\}', _replace, node.__getattribute__(prop)))
		
	globals()['max_tabstop'] += max_num[0]
		
	return max_num[0]

def unescape_text(text):
	"""
	Unescapes special characters used in Zen Coding, like '$', '|', etc.
	@type text: str
	@return: str
	"""
	return re.sub(r'\\(.)', r'\1', text)

def get_profile(name):
	"""
	Get profile by it's name. If profile wasn't found, returns 'plain' profile
	"""
	return profiles[name] if name in profiles else profiles['plain']

def update_settings(settings):
	globals()['zen_settings'] = settings
	
class Tag(object):
	def __init__(self, name, count=1, doc_type='html'):
		"""
		@param name: Tag name
		@type name: str
		@param count:  How many times this tag must be outputted
		@type count: int
		@param doc_type: Document type (xsl, html)
		@type doc_type: str
		"""
		name = name.lower()
		
		abbr = get_abbreviation(doc_type, name)
		
		if abbr and abbr.type == stparser.TYPE_REFERENCE:
			abbr = get_abbreviation(doc_type, abbr.value)
		
		self.name = abbr and abbr.value['name'] or name.replace('+', '')
		self.count = count
		self.children = []
		self.attributes = []
		self.multiply_elem = None
		self.__attr_hash = {}
		self._abbr = abbr
		self.__content = ''
		self.repeat_by_lines = False
		self._res = zen_settings.has_key(doc_type) and zen_settings[doc_type] or {}
		self.parent = None
		
		# add default attributes
		if self._abbr and 'attributes' in self._abbr.value:
			for a in self._abbr.value['attributes']:
				self.add_attribute(a['name'], a['value'])
		
	def add_child(self, tag):
		"""
		Add new child
		@type tag: Tag
		"""
		tag.parent = self
		self.children.append(tag)
		
	def add_attribute(self, name, value):
		"""
		Add attribute to tag. If the attribute with the same name already exists,
		it will be overwritten, but if it's name is 'class', it will be merged
		with the existed one
		@param name: Attribute nama
		@type name: str
		@param value: Attribute value
		@type value: str
		"""
		
		# the only place in Tag where pipe (caret) character may exist
		# is the attribute: escape it with internal placeholder
		value = replace_unescaped_symbol(value, '|', get_caret_placeholder());
		
		if name in self.__attr_hash:
#			attribue already exists
			a = self.__attr_hash[name]
			if name == 'class':
#				'class' is a magic attribute
				if a['value']:
					value = ' ' + value
				a['value'] += value
			else:
				a['value'] = value
		else:
			a = {'name': name, 'value': value}
			self.__attr_hash[name] = a
			self.attributes.append(a)
	
	def has_tags_in_content(self):
		"""
		This function tests if current tags' content contains XHTML tags. 
	 	This function is mostly used for output formatting
		"""
		return self.get_content() and re_tag.search(self.get_content())
	
	def get_content(self):
		return self.__content
	
	def set_content(self, value):
		self.__content = value
		
	def set_content(self, content): #@DuplicatedSignature
		self.__content = content
		
	def get_content(self): #@DuplicatedSignature
		return self.__content
	
	def find_deepest_child(self):
		"""
		Search for deepest and latest child of current element.
		Returns None if there's no children
	 	@return Tag or None 
		"""
		if not self.children:
			return None
			
		deepest_child = self
		while True:
			deepest_child = deepest_child.children[-1]
			if not deepest_child.children:
				break
		
		return deepest_child
	
class Snippet(Tag):
	def __init__(self, name, count=1, doc_type='html'):
		super(Snippet, self).__init__(name, count, doc_type)
		self.value = replace_unescaped_symbol(get_snippet(doc_type, name), '|', get_caret_placeholder())
		self.attributes = {'id': get_caret_placeholder(), 'class': get_caret_placeholder()}
		self._res = zen_settings[doc_type]		
	
	def is_block(self):
		return True
	
class ZenNode(object):
	"""
	Creates simplified tag from Zen Coding tag
	"""
	def __init__(self, tag):
		"""
		@type tag: Tag
		"""
		self.type = 'snippet' if isinstance(tag, Snippet) else 'tag'
		self.name = tag.name
		self.attributes = tag.attributes
		self.children = [];
		self.counter = 1
		
		self.source = tag
		"Source element from which current tag was created"
		
		# relations
		self.parent = None
		self.next_sibling = None
		self.previous_sibling = None
		
		# output params
		self.start = ''
		self.end = ''
		self.content = ''
		self.padding = ''

	def add_child(self, tag):
		"""
		@type tag: ZenNode
		"""
		tag.parent = self
		
		if self.children:
			last_child = self.children[-1]
			tag.previous_sibling = last_child
			last_child.next_sibling = tag
		
		self.children.append(tag)
		
	def get_attribute(self, name):
		"""
		Get attribute's value.
		@type name: str
		@return: None if attribute wasn't found
		"""
		name = name.lower()
		for attr in self.attributes:
			if attr['name'].lower() == name:
				return attr['value']
		
		return None
	
	def is_unary(self):
		"""
		Test if current tag is unary (no closing tag)
		@return: bool
		"""
		if self.type == 'snippet':
			return False
			
		return (self.source._abbr and self.source._abbr.value['is_empty']) or (self.name in get_elements_collection(self.source._res, 'empty'))
	
	def is_inline(self):
		"""
		Test if current tag is inline-level (like <strong>, <img>)
		@return: bool
		"""
		return self.name in get_elements_collection(self.source._res, 'inline_level')
	
	def is_block(self):
		"""
		Test if current element is block-level
		@return: bool
		"""
		return self.type == 'snippet' or not self.is_inline()
	
	def has_tags_in_content(self):
		"""
		This function tests if current tags' content contains xHTML tags. 
		This function is mostly used for output formatting
		"""
		return self.content and re_tag.search(self.content)
	
	def has_children(self):
		"""
		Check if tag has child elements
		@return: bool
		"""
		return bool(self.children)
	
	def has_block_children(self):
		"""
		Test if current tag contains block-level children
		@return: bool
		"""
		if self.has_tags_in_content() and self.is_block():
			return True
		
		for item in self.children:
			if item.is_block():
				return True
			
		return False
	
	def find_deepest_child(self):
		"""
		Search for deepest and latest child of current element
		Returns None if there's no children
		@return: ZenNode|None 
		"""
		if not self.children:
			return None
			
		deepest_child = self
		while True:
			deepest_child = deepest_child.children[-1]
			if not deepest_child.children:
				break
		
		return deepest_child
	
	def to_string(self):
		"@return {String}"
		content = ''.join([item.to_string() for item in self.children])
		return self.start + self.content + content + self.end
		
# create default profiles
setup_profile('xhtml');
setup_profile('html', {'self_closing_tag': False});
setup_profile('xml', {'self_closing_tag': True, 'tag_nl': True});
setup_profile('plain', {'tag_nl': False, 'indent': False, 'place_cursor': False});

# This method call explicity loads default settings from zen_settings.py on start up
# Comment this line if you want to load data from other resources (like editor's 
# native snippet) 
update_settings(stparser.get_settings())

########NEW FILE########
__FILENAME__ = zen_dialog
'''
@author Franck Marcia (franck.marcia@gmail.com)
'''

from gi.repository import Gtk

class ZenDialog():

    def __init__(self, editor, x, y, callback, text=""):

        self.editor = editor
        self.exit = False
        self.done = False
        self.abbreviation = text
        self.callback = callback

        self.window = Gtk.Window(type=Gtk.WindowType.TOPLEVEL)
        self.window.set_decorated(False)
        self.window.connect("destroy", self.quit)
        self.window.connect("focus-out-event", self.focus_lost)
        self.window.connect("key-press-event", self.key_pressed)
        self.window.set_resizable(False)
        self.window.move(x, y - 27)

        self.frame = Gtk.Frame()
        self.window.add(self.frame)
        self.frame.show()

        self.box = Gtk.HBox(False, 0)
        self.frame.add(self.box)
        self.box.show()
        
        self.entry = Gtk.Entry()
        self.entry.connect("changed", self.update)
        self.entry.set_text(text)
        self.entry.set_has_frame(False)
        self.entry.set_width_chars(36)
        self.box.pack_start(self.entry, True, True, 4)
        self.entry.show()

        self.window.show()

    def key_pressed(widget, what, event):
        if event.keyval == 65293: # Return
            widget.exit = True
            widget.quit()
        elif event.keyval == 65289: # Tab
            widget.exit = True
            widget.quit()
        elif event.keyval == 65307: # Escape
            widget.exit = False
            widget.done = widget.callback(widget.done, '')
            widget.quit()
        else:
            return False
            
    def focus_lost(self, widget=None, event=None):
        self.exit = True
        self.quit()

    def update(self, entry):
        self.abbreviation = self.entry.get_text()
        self.done = self.callback(self.done, self.abbreviation)

    def quit(self, widget=None, event=None):
        self.window.hide()
        self.window.destroy()
        Gtk.main_quit()

    def main(self):
        Gtk.main()

def main(editor, window, callback, text=""):

    # Ensure the caret is hidden.
    editor.view.set_cursor_visible(False)
    
    # Get coordinates of the cursor.
    offset_start, offset_end = editor.get_selection_range()
    insert = editor.buffer.get_iter_at_offset(offset_start)
    location = editor.view.get_iter_location(insert)
    window = editor.view.get_window(Gtk.TextWindowType.TEXT)
    thing, xo, yo = window.get_origin()
    xb, yb = editor.view.buffer_to_window_coords(Gtk.TextWindowType.TEXT, location.x + location.width, location.y)

    # Open dialog at coordinates with eventual text.
    my_zen_dialog = ZenDialog(editor, xo + xb, yo + yb, callback, text)
    my_zen_dialog.main()

    # Show the caret again.
    editor.view.set_cursor_visible(True)

    # Return exit status and abbreviation.
    return my_zen_dialog.done and my_zen_dialog.exit, my_zen_dialog.abbreviation


########NEW FILE########
__FILENAME__ = zen_editor
'''
High-level editor interface that communicates with underlying editor (like
Espresso, Coda, etc.) or browser. Basically, you should call set_context(obj) 
method to set up undelying editor context before using any other method.

This interface is used by zen_actions.py for performing different
actions like Expand abbreviation

@example
import zen_editor
zen_editor.set_context(obj);
//now you are ready to use editor object
zen_editor.get_selection_range();

@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru

Gedit implementation:
@author Franck Marcia (franck.marcia@gmail.com)
'''

import zen_core, zen_actions
import os, re, locale
import zen_dialog

class ZenEditor():

    def __init__(self):
        self.last_wrap = ''
        self.last_expand = ''
        zen_core.set_caret_placeholder('')

    def set_context(self, context):
        """
        Setup underlying editor context. You should call this method before 
        using any Zen Coding action.
        @param context: context object
        """
        self.context = context # window
        self.buffer = self.context.get_active_view().get_buffer()
        self.view = context.get_active_view()
        self.document = context.get_active_document()
        
        default_locale = locale.getdefaultlocale()[0] if locale.getdefaultlocale()[0] else "en_US"
        lang = re.sub(r'_[^_]+$', '', default_locale)
        if lang != default_locale:
            zen_core.set_variable('lang', lang)
            zen_core.set_variable('locale', default_locale.replace('_', '-'))
        else:
            zen_core.set_variable('lang', default_locale)
            zen_core.set_variable('locale', default_locale)
        
        self.encoding = self.document.get_encoding().get_charset()
        zen_core.set_variable('charset', self.encoding)
        
        if self.view.get_insert_spaces_instead_of_tabs():
            zen_core.set_variable('indentation', " " * context.get_active_view().get_tab_width())
        else:
            zen_core.set_variable('indentation', "\t")
        
    def get_selection_range(self):
        """
        Returns character indexes of selected text
        @return: list of start and end indexes
        @example
        start, end = zen_editor.get_selection_range();
        print('%s, %s' % (start, end))
        """
        offset_start = self.get_insert_offset()
        offset_end = self.get_selection_bound_offset()
        if offset_start < offset_end:
            return offset_start, offset_end
        return offset_end, offset_start


    def create_selection(self, offset_start, offset_end=None):
        """
        Creates selection from start to end character indexes. If end is 
        omitted, this method should place caret and start index.
        @type start: int
        @type end: int
        @example
        zen_editor.create_selection(10, 40)
        # move caret to 15th character
        zen_editor.create_selection(15)
        """
        if offset_end is None:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            self.buffer.place_cursor(iter_start)
        else:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            iter_end = self.buffer.get_iter_at_offset(offset_end)
            self.buffer.select_range(iter_start, iter_end)

    def get_current_line_range(self):
        """
        Returns current line's start and end indexes
        @return: list of start and end indexes
        @example
        start, end = zen_editor.get_current_line_range();
        print('%s, %s' % (start, end))
        """
        iter_current = self.get_insert_iter()
        offset_start = self.buffer.get_iter_at_line(iter_current.get_line()).get_offset()
        offset_end = offset_start + iter_current.get_chars_in_line() - 1
        return offset_start, offset_end

    def get_caret_pos(self):
        """ Returns current caret position """
        return self.get_insert_offset()

    def set_caret_pos(self, pos):
        """
        Sets the new caret position
        @type pos: int
        """
        self.buffer.place_cursor(self.buffer.get_iter_at_offset(pos))

    def get_current_line(self):
        """
        Returns content of current line
        @return: str
        """
        offset_start, offset_end = self.get_current_line_range()
        iter_start = self.buffer.get_iter_at_offset(offset_start)
        iter_end = self.buffer.get_iter_at_offset(offset_end)
        return self.buffer.get_text(iter_start, iter_end, False).decode(self.encoding)

    def replace_content(self, value, offset_start=None, offset_end=None):
        """
        Replace editor's content or its part (from start to end index). If 
        value contains caret_placeholder, the editor will put caret into
        this position. If you skip start and end arguments, the whole target's 
        content will be replaced with value.

        If you pass start argument only, the value will be placed at start 
        string index of current content.

        If you pass start and end arguments, the corresponding substring of 
        current target's content will be replaced with value
        @param value: Content you want to paste
        @type value: str
        @param start: Start index of editor's content
        @type start: int
        @param end: End index of editor's content
        @type end: int
        """
        if offset_start is None and offset_end is None:
            iter_start = self.buffer.get_iter_at_offset(0)
            iter_end = self.get_end_iter()
        elif offset_end is None:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            iter_end = self.buffer.get_iter_at_offset(offset_start)
        else:
            iter_start = self.buffer.get_iter_at_offset(offset_start)
            iter_end = self.buffer.get_iter_at_offset(offset_end)

        self.buffer.delete(iter_start, iter_end)
        self.insertion_start = self.get_insert_offset()
        
        padding = zen_actions.get_current_line_padding(self)
        self.buffer.insert_at_cursor(zen_core.pad_string(value, padding))

        self.insertion_end = self.get_insert_offset()

    def get_content(self):
        """
        Returns editor's content
        @return: str
        """
        iter_start = self.buffer.get_iter_at_offset(0)
        iter_end = self.get_end_iter()
        return self.buffer.get_text(iter_start, iter_end, False).decode(self.encoding)

    def get_syntax(self):
        """
        Returns current editor's syntax mode
        @return: str
        """
        lang = self.context.get_active_document().get_language()
        lang = lang and lang.get_name()
        if lang == 'CSS': lang = 'css'
        elif lang == 'XSLT': lang = 'xsl'
        else: lang = 'html'
        return lang

    def get_profile_name(self):
        """
        Returns current output profile name (@see zen_coding#setup_profile)
        @return {String}
        """
        return 'xhtml'

    def get_insert_iter(self):
        return self.buffer.get_iter_at_mark(self.buffer.get_insert())
        
    def get_insert_offset(self):
        return self.get_insert_iter().get_offset()

    def get_selection_bound_iter(self):
        return self.buffer.get_iter_at_mark(self.buffer.get_selection_bound())

    def get_selection_bound_offset(self):
        return self.get_selection_bound_iter().get_offset()

    def get_end_iter(self):
        return self.buffer.get_iter_at_offset(self.buffer.get_char_count())

    def get_end_offset(self):
        return self.get_end_iter().get_offset()
        
    def start_edit(self):
        # Bug when the cursor is at the very beginning.
        if self.insertion_start == 0:
            self.insertion_start = 1
        self.set_caret_pos(self.insertion_start)
        if not self.next_edit_point() or (self.get_insert_offset() > self.insertion_end):
            self.set_caret_pos(self.insertion_end)
    
    def show_caret(self):
        self.view.scroll_mark_onscreen(self.buffer.get_insert())

    def get_user_settings_error(self):
        return zen_core.get_variable('user_settings_error')

    def expand_abbreviation(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.expand_abbreviation(self)
        if result:
            self.start_edit()
        self.buffer.end_user_action()

    def save_selection(self):
        self.save_offset_insert = self.get_insert_offset()
        self.save_offset_selection_bound = self.get_selection_bound_offset()

    def restore_selection(self):
        iter_insert = self.buffer.get_iter_at_offset(self.save_offset_insert)
        iter_selection_bound = self.buffer.get_iter_at_offset(self.save_offset_selection_bound)
        self.buffer.select_range(iter_insert, iter_selection_bound)

    def do_expand_with_abbreviation(self, done, abbr):
        self.buffer.begin_user_action()
        if done:
            self.buffer.undo()
            self.restore_selection()
        content = zen_core.expand_abbreviation(abbr, self.get_syntax(), self.get_profile_name())
        if content:
            self.replace_content(content, self.get_insert_offset())
        self.buffer.end_user_action()
        return not not content

    def expand_with_abbreviation(self, window):
        self.set_context(window)
        self.save_selection()
        done, self.last_expand = zen_dialog.main(self, window, self.do_expand_with_abbreviation, self.last_expand)
        if done:
            self.start_edit()

    def do_wrap_with_abbreviation(self, done, abbr):
        self.buffer.begin_user_action()
        if done:
            self.buffer.undo()
            self.restore_selection()
        result = zen_actions.wrap_with_abbreviation(self, abbr)
        self.buffer.end_user_action()
        return result

    def wrap_with_abbreviation(self, window):
        self.set_context(window)
        self.save_selection()
        done, self.last_wrap = zen_dialog.main(self, window, self.do_wrap_with_abbreviation, self.last_wrap)
        if done:
            self.start_edit()

    def match_pair_inward(self, window):
        self.set_context(window)
        zen_actions.match_pair_inward(self)

    def match_pair_outward(self, window):
        self.set_context(window)
        zen_actions.match_pair_outward(self)

    def merge_lines(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.merge_lines(self)
        self.buffer.end_user_action()
        return result

    def prev_edit_point(self, window=None):
        if window:
            self.set_context(window)
        result = zen_actions.prev_edit_point(self)
        self.show_caret()
        return result

    def next_edit_point(self, window=None):
        if window:
            self.set_context(window)
        result = zen_actions.next_edit_point(self)
        self.show_caret()
        return result

    def remove_tag(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.remove_tag(self)
        self.buffer.end_user_action()
        return result

    def split_join_tag(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.split_join_tag(self)
        self.buffer.end_user_action()
        return result

    def toggle_comment(self, window):
        self.set_context(window)
        self.buffer.begin_user_action()
        result = zen_actions.toggle_comment(self)
        self.buffer.end_user_action()
        return result

########NEW FILE########
__FILENAME__ = zen_settings
"""
Zen Coding settings
@author Sergey Chikuyonok (serge.che@gmail.com)
@link http://chikuyonok.ru
"""
zen_settings = {
			
#	Variables that can be placed inside snippets or abbreviations as ${variable}
#	${child} variable is reserved, don't use it
	'variables': {
		'lang': 'en',
		'locale': 'en-US',
		'charset': 'UTF-8',
		'profile': 'xhtml',
		
#		Inner element indentation
		'indentation': '\t'
	},
	
	# common settings are used for quick injection of user-defined snippets
	'common': {
		
	},
	
	'css': {
		'extends': 'common',
		'snippets': {
			"@i": "@import url(|);",
			"@m": "@media print {\n\t|\n}",
			"@f": "@font-face {\n\tfont-family:|;\n\tsrc:url(|);\n}",
			"!": "!important",
			"pos": "position:|;",
			"pos:s": "position:static;",
			"pos:a": "position:absolute;",
			"pos:r": "position:relative;",
			"pos:f": "position:fixed;",
			"t": "top:|;",
			"t:a": "top:auto;",
			"r": "right:|;",
			"r:a": "right:auto;",
			"b": "bottom:|;",
			"b:a": "bottom:auto;",
			"brad": "-webkit-border-radius: ${1:radius};\n-moz-border-radius: $1;\n-ms-border-radius: $1;\nborder-radius: $1;$0",
			"l": "left:|;",
			"l:a": "left:auto;",
			"z": "z-index:|;",
			"z:a": "z-index:auto;",
			"fl": "float:|;",
			"fl:n": "float:none;",
			"fl:l": "float:left;",
			"fl:r": "float:right;",
			"cl": "clear:|;",
			"cl:n": "clear:none;",
			"cl:l": "clear:left;",
			"cl:r": "clear:right;",
			"cl:b": "clear:both;",
			"d": "display:|;",
			"d:n": "display:none;",
			"d:b": "display:block;",
			"d:i": "display:inline;",
			"d:ib": "display:inline-block;",
			"d:li": "display:list-item;",
			"d:ri": "display:run-in;",
			"d:cp": "display:compact;",
			"d:tb": "display:table;",
			"d:itb": "display:inline-table;",
			"d:tbcp": "display:table-caption;",
			"d:tbcl": "display:table-column;",
			"d:tbclg": "display:table-column-group;",
			"d:tbhg": "display:table-header-group;",
			"d:tbfg": "display:table-footer-group;",
			"d:tbr": "display:table-row;",
			"d:tbrg": "display:table-row-group;",
			"d:tbc": "display:table-cell;",
			"d:rb": "display:ruby;",
			"d:rbb": "display:ruby-base;",
			"d:rbbg": "display:ruby-base-group;",
			"d:rbt": "display:ruby-text;",
			"d:rbtg": "display:ruby-text-group;",
			"v": "visibility:|;",
			"v:v": "visibility:visible;",
			"v:h": "visibility:hidden;",
			"v:c": "visibility:collapse;",
			"ov": "overflow:|;",
			"ov:v": "overflow:visible;",
			"ov:h": "overflow:hidden;",
			"ov:s": "overflow:scroll;",
			"ov:a": "overflow:auto;",
			"ovx": "overflow-x:|;",
			"ovx:v": "overflow-x:visible;",
			"ovx:h": "overflow-x:hidden;",
			"ovx:s": "overflow-x:scroll;",
			"ovx:a": "overflow-x:auto;",
			"ovy": "overflow-y:|;",
			"ovy:v": "overflow-y:visible;",
			"ovy:h": "overflow-y:hidden;",
			"ovy:s": "overflow-y:scroll;",
			"ovy:a": "overflow-y:auto;",
			"ovs": "overflow-style:|;",
			"ovs:a": "overflow-style:auto;",
			"ovs:s": "overflow-style:scrollbar;",
			"ovs:p": "overflow-style:panner;",
			"ovs:m": "overflow-style:move;",
			"ovs:mq": "overflow-style:marquee;",
			"zoo": "zoom:1;",
			"cp": "clip:|;",
			"cp:a": "clip:auto;",
			"cp:r": "clip:rect(|);",
			"bxz": "box-sizing:|;",
			"bxz:cb": "box-sizing:content-box;",
			"bxz:bb": "box-sizing:border-box;",
			"bxsh": "box-shadow:|;",
			"bxsh:n": "box-shadow:none;",
			"bxsh:w": "-webkit-box-shadow:0 0 0 #000;",
			"bxsh:m": "-moz-box-shadow:0 0 0 0 #000;",
			"m": "margin:|;",
			"m:a": "margin:auto;",
			"m:0": "margin:0;",
			"m:2": "margin:0 0;",
			"m:3": "margin:0 0 0;",
			"m:4": "margin:0 0 0 0;",
			"mt": "margin-top:|;",
			"mt:a": "margin-top:auto;",
			"mr": "margin-right:|;",
			"mr:a": "margin-right:auto;",
			"mb": "margin-bottom:|;",
			"mb:a": "margin-bottom:auto;",
			"ml": "margin-left:|;",
			"ml:a": "margin-left:auto;",
			"p": "padding:|;",
			"p:0": "padding:0;",
			"p:2": "padding:0 0;",
			"p:3": "padding:0 0 0;",
			"p:4": "padding:0 0 0 0;",
			"pt": "padding-top:|;",
			"pr": "padding-right:|;",
			"pb": "padding-bottom:|;",
			"pl": "padding-left:|;",
			"w": "width:|;",
			"w:a": "width:auto;",
			"h": "height:|;",
			"h:a": "height:auto;",
			"maw": "max-width:|;",
			"maw:n": "max-width:none;",
			"mah": "max-height:|;",
			"mah:n": "max-height:none;",
			"miw": "min-width:|;",
			"mih": "min-height:|;",
			"o": "outline:|;",
			"o:n": "outline:none;",
			"oo": "outline-offset:|;",
			"ow": "outline-width:|;",
			"os": "outline-style:|;",
			"oc": "outline-color:#000;",
			"oc:i": "outline-color:invert;",
			"bd": "border:|;",
			"bd+": "border:1px solid #000;",
			"bd:n": "border:none;",
			"bdbk": "border-break:|;",
			"bdbk:c": "border-break:close;",
			"bdcl": "border-collapse:|;",
			"bdcl:c": "border-collapse:collapse;",
			"bdcl:s": "border-collapse:separate;",
			"bdc": "border-color:#000;",
			"bdi": "border-image:url(|);",
			"bdi:n": "border-image:none;",
			"bdi:w": "-webkit-border-image:url(|) 0 0 0 0 stretch stretch;",
			"bdi:m": "-moz-border-image:url(|) 0 0 0 0 stretch stretch;",
			"bdti": "border-top-image:url(|);",
			"bdti:n": "border-top-image:none;",
			"bdri": "border-right-image:url(|);",
			"bdri:n": "border-right-image:none;",
			"bdbi": "border-bottom-image:url(|);",
			"bdbi:n": "border-bottom-image:none;",
			"bdli": "border-left-image:url(|);",
			"bdli:n": "border-left-image:none;",
			"bdci": "border-corner-image:url(|);",
			"bdci:n": "border-corner-image:none;",
			"bdci:c": "border-corner-image:continue;",
			"bdtli": "border-top-left-image:url(|);",
			"bdtli:n": "border-top-left-image:none;",
			"bdtli:c": "border-top-left-image:continue;",
			"bdtri": "border-top-right-image:url(|);",
			"bdtri:n": "border-top-right-image:none;",
			"bdtri:c": "border-top-right-image:continue;",
			"bdbri": "border-bottom-right-image:url(|);",
			"bdbri:n": "border-bottom-right-image:none;",
			"bdbri:c": "border-bottom-right-image:continue;",
			"bdbli": "border-bottom-left-image:url(|);",
			"bdbli:n": "border-bottom-left-image:none;",
			"bdbli:c": "border-bottom-left-image:continue;",
			"bdf": "border-fit:|;",
			"bdf:c": "border-fit:clip;",
			"bdf:r": "border-fit:repeat;",
			"bdf:sc": "border-fit:scale;",
			"bdf:st": "border-fit:stretch;",
			"bdf:ow": "border-fit:overwrite;",
			"bdf:of": "border-fit:overflow;",
			"bdf:sp": "border-fit:space;",
			"bdl": "border-length:|;",
			"bdl:a": "border-length:auto;",
			"bdsp": "border-spacing:|;",
			"bds": "border-style:|;",
			"bds:n": "border-style:none;",
			"bds:h": "border-style:hidden;",
			"bds:dt": "border-style:dotted;",
			"bds:ds": "border-style:dashed;",
			"bds:s": "border-style:solid;",
			"bds:db": "border-style:double;",
			"bds:dtds": "border-style:dot-dash;",
			"bds:dtdtds": "border-style:dot-dot-dash;",
			"bds:w": "border-style:wave;",
			"bds:g": "border-style:groove;",
			"bds:r": "border-style:ridge;",
			"bds:i": "border-style:inset;",
			"bds:o": "border-style:outset;",
			"bdw": "border-width:|;",
			"bdt": "border-top:|;",
			"bdt+": "border-top:1px solid #000;",
			"bdt:n": "border-top:none;",
			"bdtw": "border-top-width:|;",
			"bdts": "border-top-style:|;",
			"bdts:n": "border-top-style:none;",
			"bdtc": "border-top-color:#000;",
			"bdr": "border-right:|;",
			"bdr+": "border-right:1px solid #000;",
			"bdr:n": "border-right:none;",
			"bdrw": "border-right-width:|;",
			"bdrs": "border-right-style:|;",
			"bdrs:n": "border-right-style:none;",
			"bdrc": "border-right-color:#000;",
			"bdb": "border-bottom:|;",
			"bdb+": "border-bottom:1px solid #000;",
			"bdb:n": "border-bottom:none;",
			"bdbw": "border-bottom-width:|;",
			"bdbs": "border-bottom-style:|;",
			"bdbs:n": "border-bottom-style:none;",
			"bdbc": "border-bottom-color:#000;",
			"bdl": "border-left:|;",
			"bdl+": "border-left:1px solid #000;",
			"bdl:n": "border-left:none;",
			"bdlw": "border-left-width:|;",
			"bdls": "border-left-style:|;",
			"bdls:n": "border-left-style:none;",
			"bdlc": "border-left-color:#000;",
			"bdrs": "border-radius:|;",
			"bdtrrs": "border-top-right-radius:|;",
			"bdtlrs": "border-top-left-radius:|;",
			"bdbrrs": "border-bottom-right-radius:|;",
			"bdblrs": "border-bottom-left-radius:|;",
			"bg": "background:|;",
			"bg+": "background:#FFF url(|) 0 0 no-repeat;",
			"bg:n": "background:none;",
			"bg:ie": "filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='|x.png');",
			"bgc": "background-color:#FFF;",
			"bgi": "background-image:url(|);",
			"bgi:n": "background-image:none;",
			"bgr": "background-repeat:|;",
			"bgr:n": "background-repeat:no-repeat;",
			"bgr:x": "background-repeat:repeat-x;",
			"bgr:y": "background-repeat:repeat-y;",
			"bga": "background-attachment:|;",
			"bga:f": "background-attachment:fixed;",
			"bga:s": "background-attachment:scroll;",
			"bgp": "background-position:0 0;",
			"bgpx": "background-position-x:|;",
			"bgpy": "background-position-y:|;",
			"bgbk": "background-break:|;",
			"bgbk:bb": "background-break:bounding-box;",
			"bgbk:eb": "background-break:each-box;",
			"bgbk:c": "background-break:continuous;",
			"bgcp": "background-clip:|;",
			"bgcp:bb": "background-clip:border-box;",
			"bgcp:pb": "background-clip:padding-box;",
			"bgcp:cb": "background-clip:content-box;",
			"bgcp:nc": "background-clip:no-clip;",
			"bgo": "background-origin:|;",
			"bgo:pb": "background-origin:padding-box;",
			"bgo:bb": "background-origin:border-box;",
			"bgo:cb": "background-origin:content-box;",
			"bgz": "background-size:|;",
			"bgz:a": "background-size:auto;",
			"bgz:ct": "background-size:contain;",
			"bgz:cv": "background-size:cover;",
			"c": "color:#000;",
			"tbl": "table-layout:|;",
			"tbl:a": "table-layout:auto;",
			"tbl:f": "table-layout:fixed;",
			"cps": "caption-side:|;",
			"cps:t": "caption-side:top;",
			"cps:b": "caption-side:bottom;",
			"ec": "empty-cells:|;",
			"ec:s": "empty-cells:show;",
			"ec:h": "empty-cells:hide;",
			"lis": "list-style:|;",
			"lis:n": "list-style:none;",
			"lisp": "list-style-position:|;",
			"lisp:i": "list-style-position:inside;",
			"lisp:o": "list-style-position:outside;",
			"list": "list-style-type:|;",
			"list:n": "list-style-type:none;",
			"list:d": "list-style-type:disc;",
			"list:c": "list-style-type:circle;",
			"list:s": "list-style-type:square;",
			"list:dc": "list-style-type:decimal;",
			"list:dclz": "list-style-type:decimal-leading-zero;",
			"list:lr": "list-style-type:lower-roman;",
			"list:ur": "list-style-type:upper-roman;",
			"lisi": "list-style-image:|;",
			"lisi:n": "list-style-image:none;",
			"q": "quotes:|;",
			"q:n": "quotes:none;",
			"q:ru": "quotes:'\00AB' '\00BB' '\201E' '\201C';",
			"q:en": "quotes:'\201C' '\201D' '\2018' '\2019';",
			"ct": "content:|;",
			"ct:n": "content:normal;",
			"ct:oq": "content:open-quote;",
			"ct:noq": "content:no-open-quote;",
			"ct:cq": "content:close-quote;",
			"ct:ncq": "content:no-close-quote;",
			"ct:a": "content:attr(|);",
			"ct:c": "content:counter(|);",
			"ct:cs": "content:counters(|);",
			"coi": "counter-increment:|;",
			"cor": "counter-reset:|;",
			"va": "vertical-align:|;",
			"va:sup": "vertical-align:super;",
			"va:t": "vertical-align:top;",
			"va:tt": "vertical-align:text-top;",
			"va:m": "vertical-align:middle;",
			"va:bl": "vertical-align:baseline;",
			"va:b": "vertical-align:bottom;",
			"va:tb": "vertical-align:text-bottom;",
			"va:sub": "vertical-align:sub;",
			"ta": "text-align:|;",
			"ta:l": "text-align:left;",
			"ta:c": "text-align:center;",
			"ta:r": "text-align:right;",
			"tal": "text-align-last:|;",
			"tal:a": "text-align-last:auto;",
			"tal:l": "text-align-last:left;",
			"tal:c": "text-align-last:center;",
			"tal:r": "text-align-last:right;",
			"td": "text-decoration:|;",
			"td:n": "text-decoration:none;",
			"td:u": "text-decoration:underline;",
			"td:o": "text-decoration:overline;",
			"td:l": "text-decoration:line-through;",
			"te": "text-emphasis:|;",
			"te:n": "text-emphasis:none;",
			"te:ac": "text-emphasis:accent;",
			"te:dt": "text-emphasis:dot;",
			"te:c": "text-emphasis:circle;",
			"te:ds": "text-emphasis:disc;",
			"te:b": "text-emphasis:before;",
			"te:a": "text-emphasis:after;",
			"th": "text-height:|;",
			"th:a": "text-height:auto;",
			"th:f": "text-height:font-size;",
			"th:t": "text-height:text-size;",
			"th:m": "text-height:max-size;",
			"ti": "text-indent:|;",
			"ti:-": "text-indent:-9999px;",
			"tj": "text-justify:|;",
			"tj:a": "text-justify:auto;",
			"tj:iw": "text-justify:inter-word;",
			"tj:ii": "text-justify:inter-ideograph;",
			"tj:ic": "text-justify:inter-cluster;",
			"tj:d": "text-justify:distribute;",
			"tj:k": "text-justify:kashida;",
			"tj:t": "text-justify:tibetan;",
			"to": "text-outline:|;",
			"to+": "text-outline:0 0 #000;",
			"to:n": "text-outline:none;",
			"tr": "text-replace:|;",
			"tr:n": "text-replace:none;",
			"tt": "text-transform:|;",
			"tt:n": "text-transform:none;",
			"tt:c": "text-transform:capitalize;",
			"tt:u": "text-transform:uppercase;",
			"tt:l": "text-transform:lowercase;",
			"tw": "text-wrap:|;",
			"tw:n": "text-wrap:normal;",
			"tw:no": "text-wrap:none;",
			"tw:u": "text-wrap:unrestricted;",
			"tw:s": "text-wrap:suppress;",
			"tsh": "text-shadow:|;",
			"tsh+": "text-shadow:0 0 0 #000;",
			"tsh:n": "text-shadow:none;",
			"lh": "line-height:|;",
			"whs": "white-space:|;",
			"whs:n": "white-space:normal;",
			"whs:p": "white-space:pre;",
			"whs:nw": "white-space:nowrap;",
			"whs:pw": "white-space:pre-wrap;",
			"whs:pl": "white-space:pre-line;",
			"whsc": "white-space-collapse:|;",
			"whsc:n": "white-space-collapse:normal;",
			"whsc:k": "white-space-collapse:keep-all;",
			"whsc:l": "white-space-collapse:loose;",
			"whsc:bs": "white-space-collapse:break-strict;",
			"whsc:ba": "white-space-collapse:break-all;",
			"wob": "word-break:|;",
			"wob:n": "word-break:normal;",
			"wob:k": "word-break:keep-all;",
			"wob:l": "word-break:loose;",
			"wob:bs": "word-break:break-strict;",
			"wob:ba": "word-break:break-all;",
			"wos": "word-spacing:|;",
			"wow": "word-wrap:|;",
			"wow:nm": "word-wrap:normal;",
			"wow:n": "word-wrap:none;",
			"wow:u": "word-wrap:unrestricted;",
			"wow:s": "word-wrap:suppress;",
			"lts": "letter-spacing:|;",
			"f": "font:|;",
			"f+": "font:1em Arial,sans-serif;",
			"fw": "font-weight:|;",
			"fw:n": "font-weight:normal;",
			"fw:b": "font-weight:bold;",
			"fw:br": "font-weight:bolder;",
			"fw:lr": "font-weight:lighter;",
			"fs": "font-style:|;",
			"fs:n": "font-style:normal;",
			"fs:i": "font-style:italic;",
			"fs:o": "font-style:oblique;",
			"fv": "font-variant:|;",
			"fv:n": "font-variant:normal;",
			"fv:sc": "font-variant:small-caps;",
			"fz": "font-size:|;",
			"fza": "font-size-adjust:|;",
			"fza:n": "font-size-adjust:none;",
			"ff": "font-family:|;",
			"ff:s": "font-family:serif;",
			"ff:ss": "font-family:sans-serif;",
			"ff:c": "font-family:cursive;",
			"ff:f": "font-family:fantasy;",
			"ff:m": "font-family:monospace;",
			"fef": "font-effect:|;",
			"fef:n": "font-effect:none;",
			"fef:eg": "font-effect:engrave;",
			"fef:eb": "font-effect:emboss;",
			"fef:o": "font-effect:outline;",
			"fem": "font-emphasize:|;",
			"femp": "font-emphasize-position:|;",
			"femp:b": "font-emphasize-position:before;",
			"femp:a": "font-emphasize-position:after;",
			"fems": "font-emphasize-style:|;",
			"fems:n": "font-emphasize-style:none;",
			"fems:ac": "font-emphasize-style:accent;",
			"fems:dt": "font-emphasize-style:dot;",
			"fems:c": "font-emphasize-style:circle;",
			"fems:ds": "font-emphasize-style:disc;",
			"fsm": "font-smooth:|;",
			"fsm:a": "font-smooth:auto;",
			"fsm:n": "font-smooth:never;",
			"fsm:aw": "font-smooth:always;",
			"fst": "font-stretch:|;",
			"fst:n": "font-stretch:normal;",
			"fst:uc": "font-stretch:ultra-condensed;",
			"fst:ec": "font-stretch:extra-condensed;",
			"fst:c": "font-stretch:condensed;",
			"fst:sc": "font-stretch:semi-condensed;",
			"fst:se": "font-stretch:semi-expanded;",
			"fst:e": "font-stretch:expanded;",
			"fst:ee": "font-stretch:extra-expanded;",
			"fst:ue": "font-stretch:ultra-expanded;",
			"op": "opacity:|;",
			"op:ie": "filter:progid:DXImageTransform.Microsoft.Alpha(Opacity=100);",
			"op:ms": "-ms-filter:'progid:DXImageTransform.Microsoft.Alpha(Opacity=100)';",
			"rz": "resize:|;",
			"rz:n": "resize:none;",
			"rz:b": "resize:both;",
			"rz:h": "resize:horizontal;",
			"rz:v": "resize:vertical;",
			"cur": "cursor:|;",
			"cur:a": "cursor:auto;",
			"cur:d": "cursor:default;",
			"cur:c": "cursor:crosshair;",
			"cur:ha": "cursor:hand;",
			"cur:he": "cursor:help;",
			"cur:m": "cursor:move;",
			"cur:p": "cursor:pointer;",
			"cur:t": "cursor:text;",
			"pgbb": "page-break-before:|;",
			"pgbb:au": "page-break-before:auto;",
			"pgbb:al": "page-break-before:always;",
			"pgbb:l": "page-break-before:left;",
			"pgbb:r": "page-break-before:right;",
			"pgbi": "page-break-inside:|;",
			"pgbi:au": "page-break-inside:auto;",
			"pgbi:av": "page-break-inside:avoid;",
			"pgba": "page-break-after:|;",
			"pgba:au": "page-break-after:auto;",
			"pgba:al": "page-break-after:always;",
			"pgba:l": "page-break-after:left;",
			"pgba:r": "page-break-after:right;",
			"orp": "orphans:|;",
			"wid": "widows:|;"
		}
	},
	
	'html': {
		'extends': 'common',
		'filters': 'html',
		'snippets': {
			'cc:ie6': '<!--[if lte IE 6]>\n\t${child}|\n<![endif]-->',
			'cc:ie': '<!--[if IE]>\n\t${child}|\n<![endif]-->',
			'cc:noie': '<!--[if !IE]><!-->\n\t${child}|\n<!--<![endif]-->',
			'html:4t': '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">\n' +
					'<html lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}">\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:4s': '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">\n' +
					'<html lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}">\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:xt': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">\n' +
					'<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}" />\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:xs': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n' +
					'<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}" />\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:xxs': '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">\n' +
					'<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="${lang}">\n' +
					'<head>\n' +
					'${indentation}<meta http-equiv="Content-Type" content="text/html;charset=${charset}" />\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>',
			
			'html:5': '<!DOCTYPE HTML>\n' +
					'<html lang="${locale}">\n' +
					'<head>\n' +
					'${indentation}<meta charset="${charset}">\n' +
					'${indentation}<title></title>\n' +
					'</head>\n' +
					'<body>\n\t${child}|\n</body>\n' +
					'</html>'
		},
		
		'abbreviations': {
			'a': '<a href=""></a>',
			'a:link': '<a href="http://|"></a>',
			'a:mail': '<a href="mailto:|"></a>',
			'abbr': '<abbr title=""></abbr>',
			'acronym': '<acronym title=""></acronym>',
			'base': '<base href="" />',
			'bdo': '<bdo dir=""></bdo>',
			'bdo:r': '<bdo dir="rtl"></bdo>',
			'bdo:l': '<bdo dir="ltr"></bdo>',
			'link:css': '<link rel="stylesheet" type="text/css" href="|style.css" media="all" />',
			'link:print': '<link rel="stylesheet" type="text/css" href="|print.css" media="print" />',
			'link:favicon': '<link rel="shortcut icon" type="image/x-icon" href="|favicon.ico" />',
			'link:touch': '<link rel="apple-touch-icon" href="|favicon.png" />',
			'link:rss': '<link rel="alternate" type="application/rss+xml" title="RSS" href="|rss.xml" />',
			'link:atom': '<link rel="alternate" type="application/atom+xml" title="Atom" href="atom.xml" />',
			'meta:utf': '<meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />',
			'meta:win': '<meta http-equiv="Content-Type" content="text/html;charset=Win-1251" />',
			'meta:compat': '<meta http-equiv="X-UA-Compatible" content="IE=7" />',
			'style': '<style type="text/css"></style>',
			'script': '<script type="text/javascript"></script>',
			'script:src': '<script type="text/javascript" src=""></script>',
			'img': '<img src="" alt="" />',
			'iframe': '<iframe src="" frameborder="0"></iframe>',
			'embed': '<embed src="" type="" />',
			'object': '<object data="" type=""></object>',
			'param': '<param name="" value="" />',
			'map': '<map name=""></map>',
			'area': '<area shape="" coords="" href="" alt="" />',
			'area:d': '<area shape="default" href="" alt="" />',
			'area:c': '<area shape="circle" coords="" href="" alt="" />',
			'area:r': '<area shape="rect" coords="" href="" alt="" />',
			'area:p': '<area shape="poly" coords="" href="" alt="" />',
			'link': '<link rel="stylesheet" href="" />',
			'form': '<form action=""></form>',
			'form:get': '<form action="" method="get"></form>',
			'form:post': '<form action="" method="post"></form>',
			'label': '<label for=""></label>',
			'input': '<input type="" />',
			'input:hidden': '<input type="hidden" name="" />',
			'input:h': '<input type="hidden" name="" />',
			'input:text': '<input type="text" name="" id="" />',
			'input:t': '<input type="text" name="" id="" />',
			'input:search': '<input type="search" name="" id="" />',
			'input:email': '<input type="email" name="" id="" />',
			'input:url': '<input type="url" name="" id="" />',
			'input:password': '<input type="password" name="" id="" />',
			'input:p': '<input type="password" name="" id="" />',
			'input:datetime': '<input type="datetime" name="" id="" />',
			'input:date': '<input type="date" name="" id="" />',
			'input:datetime-local': '<input type="datetime-local" name="" id="" />',
			'input:month': '<input type="month" name="" id="" />',
			'input:week': '<input type="week" name="" id="" />',
			'input:time': '<input type="time" name="" id="" />',
			'input:number': '<input type="number" name="" id="" />',
			'input:color': '<input type="color" name="" id="" />',
			'input:checkbox': '<input type="checkbox" name="" id="" />',
			'input:c': '<input type="checkbox" name="" id="" />',
			'input:radio': '<input type="radio" name="" id="" />',
			'input:r': '<input type="radio" name="" id="" />',
			'input:range': '<input type="range" name="" id="" />',
			'input:file': '<input type="file" name="" id="" />',
			'input:f': '<input type="file" name="" id="" />',
			'input:submit': '<input type="submit" value="" />',
			'input:s': '<input type="submit" value="" />',
			'input:image': '<input type="image" src="" alt="" />',
			'input:i': '<input type="image" src="" alt="" />',
			'input:reset': '<input type="reset" value="" />',
			'input:button': '<input type="button" value="" />',
			'input:b': '<input type="button" value="" />',
			'select': '<select name="" id=""></select>',
			'option': '<option value=""></option>',
			'textarea': '<textarea name="" id="" cols="30" rows="10"></textarea>',
			'menu:context': '<menu type="context"></menu>',
			'menu:c': '<menu type="context"></menu>',
			'menu:toolbar': '<menu type="toolbar"></menu>',
			'menu:t': '<menu type="toolbar"></menu>',
			'video': '<video src=""></video>',
			'audio': '<audio src=""></audio>',
			'html:xml': '<html xmlns="http://www.w3.org/1999/xhtml"></html>',
			'bq': '<blockquote></blockquote>',
			'acr': '<acronym></acronym>',
			'fig': '<figure></figure>',
			'ifr': '<iframe></iframe>',
			'emb': '<embed></embed>',
			'obj': '<object></object>',
			'src': '<source></source>',
			'cap': '<caption></caption>',
			'colg': '<colgroup></colgroup>',
			'fst': '<fieldset></fieldset>',
			'btn': '<button></button>',
			'optg': '<optgroup></optgroup>',
			'opt': '<option></option>',
			'tarea': '<textarea></textarea>',
			'leg': '<legend></legend>',
			'sect': '<section></section>',
			'art': '<article></article>',
			'hdr': '<header></header>',
			'ftr': '<footer></footer>',
			'adr': '<address></address>',
			'dlg': '<dialog></dialog>',
			'str': '<strong></strong>',
			'prog': '<progress></progress>',
			'fset': '<fieldset></fieldset>',
			'datag': '<datagrid></datagrid>',
			'datal': '<datalist></datalist>',
			'kg': '<keygen></keygen>',
			'out': '<output></output>',
			'det': '<details></details>',
			'cmd': '<command></command>',
			
#			expandos
			'ol+': 'ol>li',
			'ul+': 'ul>li',
			'dl+': 'dl>dt+dd',
			'map+': 'map>area',
			'table+': 'table>tr>td',
			'colgroup+': 'colgroup>col',
			'colg+': 'colgroup>col',
			'tr+': 'tr>td',
			'select+': 'select>option',
			'optgroup+': 'optgroup>option',
			'optg+': 'optgroup>option'

		},
		
		'element_types': {
			'empty': 'area,base,basefont,br,col,frame,hr,img,input,isindex,link,meta,param,embed,keygen,command',
			'block_level': 'address,applet,blockquote,button,center,dd,del,dir,div,dl,dt,fieldset,form,frameset,hr,iframe,ins,isindex,li,link,map,menu,noframes,noscript,object,ol,p,pre,script,table,tbody,td,tfoot,th,thead,tr,ul,h1,h2,h3,h4,h5,h6',
			'inline_level': 'a,abbr,acronym,applet,b,basefont,bdo,big,br,button,cite,code,del,dfn,em,font,i,iframe,img,input,ins,kbd,label,map,object,q,s,samp,script,select,small,span,strike,strong,sub,sup,textarea,tt,u,var'
		}
	},
	
	'xsl': {
		'extends': 'common,html',
		'filters': 'html, xsl',
		'abbreviations': {
			'tm': '<xsl:template match="" mode=""></xsl:template>',
			'tmatch': 'tm',
			'tn': '<xsl:template name=""></xsl:template>',
			'tname': 'tn',
			'xsl:when': '<xsl:when test=""></xsl:when>',
			'wh': 'xsl:when',
			'var': '<xsl:variable name="">|</xsl:variable>',
			'vare': '<xsl:variable name="" select=""/>',
			'if': '<xsl:if test=""></xsl:if>',
			'call': '<xsl:call-template name=""/>',
			'attr': '<xsl:attribute name=""></xsl:attribute>',
			'wp': '<xsl:with-param name="" select=""/>',
			'par': '<xsl:param name="" select=""/>',
			'val': '<xsl:value-of select=""/>',
			'co': '<xsl:copy-of select=""/>',
			'each': '<xsl:for-each select=""></xsl:for-each>',
			'ap': '<xsl:apply-templates select="" mode=""/>',
			
#			expandos
			'choose+': 'xsl:choose>xsl:when+xsl:otherwise'
		}
	},
	
	'haml': {
		'filters': 'haml',
		'extends': 'html'
	}
}

########NEW FILE########
